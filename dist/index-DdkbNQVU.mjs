function p2(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var F_ = { exports: {} }, yB = F_.exports, zA;
function bB() {
  return zA || (zA = 1, function(r, e) {
    (function(t, i) {
      r.exports = i();
    })(yB, function() {
      var t = {}, i = {};
      function n(c, o, d) {
        if (i[c] = d, c === "index") {
          var m = "var sharedModule = {}; (" + i.shared + ")(sharedModule); (" + i.worker + ")(sharedModule);", y = {};
          return i.shared(y), i.index(t, y), typeof window < "u" && t.setWorkerUrl(window.URL.createObjectURL(new Blob([m], { type: "text/javascript" }))), t;
        }
      }
      n("shared", ["exports"], function(c) {
        function o(h, l, u, p) {
          return new (u || (u = Promise))(function(_, x) {
            function A(O) {
              try {
                M(p.next(O));
              } catch (N) {
                x(N);
              }
            }
            function E(O) {
              try {
                M(p.throw(O));
              } catch (N) {
                x(N);
              }
            }
            function M(O) {
              var N;
              O.done ? _(O.value) : (N = O.value, N instanceof u ? N : new u(function(V) {
                V(N);
              })).then(A, E);
            }
            M((p = p.apply(h, l || [])).next());
          });
        }
        function d(h, l) {
          this.x = h, this.y = l;
        }
        function m(h) {
          return h && h.__esModule && Object.prototype.hasOwnProperty.call(h, "default") ? h.default : h;
        }
        var y, T;
        typeof SuppressedError == "function" && SuppressedError, d.prototype = { clone() {
          return new d(this.x, this.y);
        }, add(h) {
          return this.clone()._add(h);
        }, sub(h) {
          return this.clone()._sub(h);
        }, multByPoint(h) {
          return this.clone()._multByPoint(h);
        }, divByPoint(h) {
          return this.clone()._divByPoint(h);
        }, mult(h) {
          return this.clone()._mult(h);
        }, div(h) {
          return this.clone()._div(h);
        }, rotate(h) {
          return this.clone()._rotate(h);
        }, rotateAround(h, l) {
          return this.clone()._rotateAround(h, l);
        }, matMult(h) {
          return this.clone()._matMult(h);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(h) {
          return this.x === h.x && this.y === h.y;
        }, dist(h) {
          return Math.sqrt(this.distSqr(h));
        }, distSqr(h) {
          const l = h.x - this.x, u = h.y - this.y;
          return l * l + u * u;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(h) {
          return Math.atan2(this.y - h.y, this.x - h.x);
        }, angleWith(h) {
          return this.angleWithSep(h.x, h.y);
        }, angleWithSep(h, l) {
          return Math.atan2(this.x * l - this.y * h, this.x * h + this.y * l);
        }, _matMult(h) {
          const l = h[2] * this.x + h[3] * this.y;
          return this.x = h[0] * this.x + h[1] * this.y, this.y = l, this;
        }, _add(h) {
          return this.x += h.x, this.y += h.y, this;
        }, _sub(h) {
          return this.x -= h.x, this.y -= h.y, this;
        }, _mult(h) {
          return this.x *= h, this.y *= h, this;
        }, _div(h) {
          return this.x /= h, this.y /= h, this;
        }, _multByPoint(h) {
          return this.x *= h.x, this.y *= h.y, this;
        }, _divByPoint(h) {
          return this.x /= h.x, this.y /= h.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const h = this.y;
          return this.y = this.x, this.x = -h, this;
        }, _rotate(h) {
          const l = Math.cos(h), u = Math.sin(h), p = u * this.x + l * this.y;
          return this.x = l * this.x - u * this.y, this.y = p, this;
        }, _rotateAround(h, l) {
          const u = Math.cos(h), p = Math.sin(h), _ = l.y + p * (this.x - l.x) + u * (this.y - l.y);
          return this.x = l.x + u * (this.x - l.x) - p * (this.y - l.y), this.y = _, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: d }, d.convert = function(h) {
          if (h instanceof d) return h;
          if (Array.isArray(h)) return new d(+h[0], +h[1]);
          if (h.x !== void 0 && h.y !== void 0) return new d(+h.x, +h.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var P = function() {
          if (T) return y;
          function h(l, u, p, _) {
            this.cx = 3 * l, this.bx = 3 * (p - l) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * u, this.by = 3 * (_ - u) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = l, this.p1y = u, this.p2x = p, this.p2y = _;
          }
          return T = 1, y = h, h.prototype = { sampleCurveX: function(l) {
            return ((this.ax * l + this.bx) * l + this.cx) * l;
          }, sampleCurveY: function(l) {
            return ((this.ay * l + this.by) * l + this.cy) * l;
          }, sampleCurveDerivativeX: function(l) {
            return (3 * this.ax * l + 2 * this.bx) * l + this.cx;
          }, solveCurveX: function(l, u) {
            if (u === void 0 && (u = 1e-6), l < 0) return 0;
            if (l > 1) return 1;
            for (var p = l, _ = 0; _ < 8; _++) {
              var x = this.sampleCurveX(p) - l;
              if (Math.abs(x) < u) return p;
              var A = this.sampleCurveDerivativeX(p);
              if (Math.abs(A) < 1e-6) break;
              p -= x / A;
            }
            var E = 0, M = 1;
            for (p = l, _ = 0; _ < 20 && (x = this.sampleCurveX(p), !(Math.abs(x - l) < u)); _++) l > x ? E = p : M = p, p = 0.5 * (M - E) + E;
            return p;
          }, solve: function(l, u) {
            return this.sampleCurveY(this.solveCurveX(l, u));
          } }, y;
        }(), I = m(P);
        let D, k;
        function $() {
          return D == null && (D = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), D;
        }
        function G() {
          if (k == null && (k = !1, $())) {
            const l = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (l) {
              for (let p = 0; p < 5 * 5; p++) {
                const _ = 4 * p;
                l.fillStyle = `rgb(${_},${_ + 1},${_ + 2})`, l.fillRect(p % 5, Math.floor(p / 5), 1, 1);
              }
              const u = l.getImageData(0, 0, 5, 5).data;
              for (let p = 0; p < 5 * 5 * 4; p++) if (p % 4 != 3 && u[p] !== p) {
                k = !0;
                break;
              }
            }
          }
          return k || !1;
        }
        var te = 1e-6, Z = typeof Float32Array < "u" ? Float32Array : Array;
        function H() {
          var h = new Z(9);
          return Z != Float32Array && (h[1] = 0, h[2] = 0, h[3] = 0, h[5] = 0, h[6] = 0, h[7] = 0), h[0] = 1, h[4] = 1, h[8] = 1, h;
        }
        function J(h) {
          return h[0] = 1, h[1] = 0, h[2] = 0, h[3] = 0, h[4] = 0, h[5] = 1, h[6] = 0, h[7] = 0, h[8] = 0, h[9] = 0, h[10] = 1, h[11] = 0, h[12] = 0, h[13] = 0, h[14] = 0, h[15] = 1, h;
        }
        function re() {
          var h = new Z(3);
          return Z != Float32Array && (h[0] = 0, h[1] = 0, h[2] = 0), h;
        }
        function be(h) {
          var l = h[0], u = h[1], p = h[2];
          return Math.sqrt(l * l + u * u + p * p);
        }
        function pe(h, l, u) {
          var p = new Z(3);
          return p[0] = h, p[1] = l, p[2] = u, p;
        }
        function oe(h, l, u) {
          return h[0] = l[0] + u[0], h[1] = l[1] + u[1], h[2] = l[2] + u[2], h;
        }
        function Ee(h, l, u) {
          return h[0] = l[0] * u, h[1] = l[1] * u, h[2] = l[2] * u, h;
        }
        function le(h, l, u) {
          var p = l[0], _ = l[1], x = l[2], A = u[0], E = u[1], M = u[2];
          return h[0] = _ * M - x * E, h[1] = x * A - p * M, h[2] = p * E - _ * A, h;
        }
        var _e, Ve = be;
        function Be(h, l, u) {
          var p = l[0], _ = l[1], x = l[2], A = l[3];
          return h[0] = u[0] * p + u[4] * _ + u[8] * x + u[12] * A, h[1] = u[1] * p + u[5] * _ + u[9] * x + u[13] * A, h[2] = u[2] * p + u[6] * _ + u[10] * x + u[14] * A, h[3] = u[3] * p + u[7] * _ + u[11] * x + u[15] * A, h;
        }
        function gt() {
          var h = new Z(4);
          return Z != Float32Array && (h[0] = 0, h[1] = 0, h[2] = 0), h[3] = 1, h;
        }
        function St(h, l, u, p) {
          var _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", x = Math.PI / 360;
          l *= x, p *= x, u *= x;
          var A = Math.sin(l), E = Math.cos(l), M = Math.sin(u), O = Math.cos(u), N = Math.sin(p), V = Math.cos(p);
          switch (_) {
            case "xyz":
              h[0] = A * O * V + E * M * N, h[1] = E * M * V - A * O * N, h[2] = E * O * N + A * M * V, h[3] = E * O * V - A * M * N;
              break;
            case "xzy":
              h[0] = A * O * V - E * M * N, h[1] = E * M * V - A * O * N, h[2] = E * O * N + A * M * V, h[3] = E * O * V + A * M * N;
              break;
            case "yxz":
              h[0] = A * O * V + E * M * N, h[1] = E * M * V - A * O * N, h[2] = E * O * N - A * M * V, h[3] = E * O * V + A * M * N;
              break;
            case "yzx":
              h[0] = A * O * V + E * M * N, h[1] = E * M * V + A * O * N, h[2] = E * O * N - A * M * V, h[3] = E * O * V - A * M * N;
              break;
            case "zxy":
              h[0] = A * O * V - E * M * N, h[1] = E * M * V + A * O * N, h[2] = E * O * N + A * M * V, h[3] = E * O * V - A * M * N;
              break;
            case "zyx":
              h[0] = A * O * V - E * M * N, h[1] = E * M * V + A * O * N, h[2] = E * O * N - A * M * V, h[3] = E * O * V + A * M * N;
              break;
            default:
              throw new Error("Unknown angle order " + _);
          }
          return h;
        }
        function Mt() {
          var h = new Z(2);
          return Z != Float32Array && (h[0] = 0, h[1] = 0), h;
        }
        function mt(h, l) {
          var u = new Z(2);
          return u[0] = h, u[1] = l, u;
        }
        re(), _e = new Z(4), Z != Float32Array && (_e[0] = 0, _e[1] = 0, _e[2] = 0, _e[3] = 0), re(), pe(1, 0, 0), pe(0, 1, 0), gt(), gt(), H(), Mt();
        const wt = 8192;
        function Yt(h, l, u) {
          return l * (wt / (h.tileSize * Math.pow(2, u - h.tileID.overscaledZ)));
        }
        function Dt(h, l) {
          return (h % l + l) % l;
        }
        function fe(h, l, u) {
          return h * (1 - u) + l * u;
        }
        function De(h) {
          if (h <= 0) return 0;
          if (h >= 1) return 1;
          const l = h * h, u = l * h;
          return 4 * (h < 0.5 ? u : 3 * (h - l) + u - 0.75);
        }
        function je(h, l, u, p) {
          const _ = new I(h, l, u, p);
          return (x) => _.solve(x);
        }
        const Ke = je(0.25, 0.1, 0.25, 1);
        function rt(h, l, u) {
          return Math.min(u, Math.max(l, h));
        }
        function at(h, l, u) {
          const p = u - l, _ = ((h - l) % p + p) % p + l;
          return _ === l ? u : _;
        }
        function Et(h, ...l) {
          for (const u of l) for (const p in u) h[p] = u[p];
          return h;
        }
        let Tt = 1;
        function Vt(h, l, u) {
          const p = {};
          for (const _ in h) p[_] = l.call(this, h[_], _, h);
          return p;
        }
        function tr(h, l, u) {
          const p = {};
          for (const _ in h) l.call(this, h[_], _, h) && (p[_] = h[_]);
          return p;
        }
        function ur(h) {
          return Array.isArray(h) ? h.map(ur) : typeof h == "object" && h ? Vt(h, ur) : h;
        }
        const dr = {};
        function Ct(h) {
          dr[h] || (typeof console < "u" && console.warn(h), dr[h] = !0);
        }
        function Oe(h, l, u) {
          return (u.y - h.y) * (l.x - h.x) > (l.y - h.y) * (u.x - h.x);
        }
        function ii(h) {
          return typeof WorkerGlobalScope < "u" && h !== void 0 && h instanceof WorkerGlobalScope;
        }
        let Zr = null;
        function Rr(h) {
          if (Zr == null) {
            const l = h.navigator ? h.navigator.userAgent : null;
            Zr = !!h.safari || !(!l || !(/\b(iPad|iPhone|iPod)\b/.test(l) || l.match("Safari") && !l.match("Chrome")));
          }
          return Zr;
        }
        function Jt(h) {
          return typeof ImageBitmap < "u" && h instanceof ImageBitmap;
        }
        const Sr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function hr(h, l, u, p, _) {
          return o(this, void 0, void 0, function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const x = new VideoFrame(h, { timestamp: 0 });
            try {
              const A = x?.format;
              if (!A || !A.startsWith("BGR") && !A.startsWith("RGB")) throw new Error(`Unrecognized format ${A}`);
              const E = A.startsWith("BGR"), M = new Uint8ClampedArray(p * _ * 4);
              if (yield x.copyTo(M, function(O, N, V, Y, ee) {
                const ie = 4 * Math.max(-N, 0), ue = (Math.max(0, V) - V) * Y * 4 + ie, ve = 4 * Y, Re = Math.max(0, N), it = Math.max(0, V);
                return { rect: { x: Re, y: it, width: Math.min(O.width, N + Y) - Re, height: Math.min(O.height, V + ee) - it }, layout: [{ offset: ue, stride: ve }] };
              }(h, l, u, p, _)), E) for (let O = 0; O < M.length; O += 4) {
                const N = M[O];
                M[O] = M[O + 2], M[O + 2] = N;
              }
              return M;
            } finally {
              x.close();
            }
          });
        }
        let qr, xr;
        function bi(h, l, u, p) {
          return h.addEventListener(l, u, p), { unsubscribe: () => {
            h.removeEventListener(l, u, p);
          } };
        }
        function Yr(h) {
          return h * Math.PI / 180;
        }
        function Fr(h) {
          return h / Math.PI * 180;
        }
        const Ri = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, Kr = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, wr = "AbortError";
        function Ue() {
          return new Error(wr);
        }
        const K = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function ne(h) {
          return K.REGISTERED_PROTOCOLS[h.substring(0, h.indexOf("://"))];
        }
        const de = "global-dispatcher";
        class Te extends Error {
          constructor(l, u, p, _) {
            super(`AJAXError: ${u} (${l}): ${p}`), this.status = l, this.statusText = u, this.url = p, this.body = _;
          }
        }
        const Pe = () => ii(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, qe = function(h, l) {
          if (/:\/\//.test(h.url) && !/^https?:|^file:/.test(h.url)) {
            const p = ne(h.url);
            if (p) return p(h, l);
            if (ii(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: h, targetMapId: de }, l);
          }
          if (!(/^file:/.test(u = h.url) || /^file:/.test(Pe()) && !/^\w+:/.test(u))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(p, _) {
              return o(this, void 0, void 0, function* () {
                const x = new Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, cache: p.cache, referrer: Pe(), signal: _.signal });
                let A, E;
                p.type !== "json" || x.headers.has("Accept") || x.headers.set("Accept", "application/json");
                try {
                  A = yield fetch(x);
                } catch (O) {
                  throw new Te(0, O.message, p.url, new Blob());
                }
                if (!A.ok) {
                  const O = yield A.blob();
                  throw new Te(A.status, A.statusText, p.url, O);
                }
                E = p.type === "arrayBuffer" || p.type === "image" ? A.arrayBuffer() : p.type === "json" ? A.json() : A.text();
                const M = yield E;
                if (_.signal.aborted) throw Ue();
                return { data: M, cacheControl: A.headers.get("Cache-Control"), expires: A.headers.get("Expires") };
              });
            }(h, l);
            if (ii(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: h, mustQueue: !0, targetMapId: de }, l);
          }
          var u;
          return function(p, _) {
            return new Promise((x, A) => {
              var E;
              const M = new XMLHttpRequest();
              M.open(p.method || "GET", p.url, !0), p.type !== "arrayBuffer" && p.type !== "image" || (M.responseType = "arraybuffer");
              for (const O in p.headers) M.setRequestHeader(O, p.headers[O]);
              p.type === "json" && (M.responseType = "text", !((E = p.headers) === null || E === void 0) && E.Accept || M.setRequestHeader("Accept", "application/json")), M.withCredentials = p.credentials === "include", M.onerror = () => {
                A(new Error(M.statusText));
              }, M.onload = () => {
                if (!_.signal.aborted) if ((M.status >= 200 && M.status < 300 || M.status === 0) && M.response !== null) {
                  let O = M.response;
                  if (p.type === "json") try {
                    O = JSON.parse(M.response);
                  } catch (N) {
                    return void A(N);
                  }
                  x({ data: O, cacheControl: M.getResponseHeader("Cache-Control"), expires: M.getResponseHeader("Expires") });
                } else {
                  const O = new Blob([M.response], { type: M.getResponseHeader("Content-Type") });
                  A(new Te(M.status, M.statusText, p.url, O));
                }
              }, _.signal.addEventListener("abort", () => {
                M.abort(), A(Ue());
              }), M.send(p.body);
            });
          }(h, l);
        };
        function Je(h) {
          if (!h || h.indexOf("://") <= 0 || h.indexOf("data:image/") === 0 || h.indexOf("blob:") === 0) return !0;
          const l = new URL(h), u = window.location;
          return l.protocol === u.protocol && l.host === u.host;
        }
        function He(h, l, u) {
          u[h] && u[h].indexOf(l) !== -1 || (u[h] = u[h] || [], u[h].push(l));
        }
        function nt(h, l, u) {
          if (u && u[h]) {
            const p = u[h].indexOf(l);
            p !== -1 && u[h].splice(p, 1);
          }
        }
        class Bt {
          constructor(l, u = {}) {
            Et(this, u), this.type = l;
          }
        }
        class It extends Bt {
          constructor(l, u = {}) {
            super("error", Et({ error: l }, u));
          }
        }
        class rr {
          on(l, u) {
            return this._listeners = this._listeners || {}, He(l, u, this._listeners), { unsubscribe: () => {
              this.off(l, u);
            } };
          }
          off(l, u) {
            return nt(l, u, this._listeners), nt(l, u, this._oneTimeListeners), this;
          }
          once(l, u) {
            return u ? (this._oneTimeListeners = this._oneTimeListeners || {}, He(l, u, this._oneTimeListeners), this) : new Promise((p) => this.once(l, p));
          }
          fire(l, u) {
            typeof l == "string" && (l = new Bt(l, u || {}));
            const p = l.type;
            if (this.listens(p)) {
              l.target = this;
              const _ = this._listeners && this._listeners[p] ? this._listeners[p].slice() : [];
              for (const E of _) E.call(this, l);
              const x = this._oneTimeListeners && this._oneTimeListeners[p] ? this._oneTimeListeners[p].slice() : [];
              for (const E of x) nt(p, E, this._oneTimeListeners), E.call(this, l);
              const A = this._eventedParent;
              A && (Et(l, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), A.fire(l));
            } else l instanceof It && console.error(l.error);
            return this;
          }
          listens(l) {
            return this._listeners && this._listeners[l] && this._listeners[l].length > 0 || this._oneTimeListeners && this._oneTimeListeners[l] && this._oneTimeListeners[l].length > 0 || this._eventedParent && this._eventedParent.listens(l);
          }
          setEventedParent(l, u) {
            return this._eventedParent = l, this._eventedParentData = u, this;
          }
        }
        var We = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "array", value: "fontFaces" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const mr = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Li(h, l) {
          const u = {};
          for (const p in h) p !== "ref" && (u[p] = h[p]);
          return mr.forEach((p) => {
            p in l && (u[p] = l[p]);
          }), u;
        }
        function fr(h, l) {
          if (Array.isArray(h)) {
            if (!Array.isArray(l) || h.length !== l.length) return !1;
            for (let u = 0; u < h.length; u++) if (!fr(h[u], l[u])) return !1;
            return !0;
          }
          if (typeof h == "object" && h !== null && l !== null) {
            if (typeof l != "object" || Object.keys(h).length !== Object.keys(l).length) return !1;
            for (const u in h) if (!fr(h[u], l[u])) return !1;
            return !0;
          }
          return h === l;
        }
        function Hr(h, l) {
          h.push(l);
        }
        function li(h, l, u) {
          Hr(u, { command: "addSource", args: [h, l[h]] });
        }
        function _r(h, l, u) {
          Hr(l, { command: "removeSource", args: [h] }), u[h] = !0;
        }
        function qi(h, l, u, p) {
          _r(h, u, p), li(h, l, u);
        }
        function nn(h, l, u) {
          let p;
          for (p in h[u]) if (Object.prototype.hasOwnProperty.call(h[u], p) && p !== "data" && !fr(h[u][p], l[u][p])) return !1;
          for (p in l[u]) if (Object.prototype.hasOwnProperty.call(l[u], p) && p !== "data" && !fr(h[u][p], l[u][p])) return !1;
          return !0;
        }
        function Ei(h, l, u, p, _, x) {
          h = h || {}, l = l || {};
          for (const A in h) Object.prototype.hasOwnProperty.call(h, A) && (fr(h[A], l[A]) || u.push({ command: x, args: [p, A, l[A], _] }));
          for (const A in l) Object.prototype.hasOwnProperty.call(l, A) && !Object.prototype.hasOwnProperty.call(h, A) && (fr(h[A], l[A]) || u.push({ command: x, args: [p, A, l[A], _] }));
        }
        function vi(h) {
          return h.id;
        }
        function ci(h, l) {
          return h[l.id] = l, h;
        }
        class Lt {
          constructor(l, u, p, _) {
            this.message = (l ? `${l}: ` : "") + p, _ && (this.identifier = _), u != null && u.__line__ && (this.line = u.__line__);
          }
        }
        function pi(h, ...l) {
          for (const u of l) for (const p in u) h[p] = u[p];
          return h;
        }
        class Rn extends Error {
          constructor(l, u) {
            super(u), this.message = u, this.key = l;
          }
        }
        class eo {
          constructor(l, u = []) {
            this.parent = l, this.bindings = {};
            for (const [p, _] of u) this.bindings[p] = _;
          }
          concat(l) {
            return new eo(this, l);
          }
          get(l) {
            if (this.bindings[l]) return this.bindings[l];
            if (this.parent) return this.parent.get(l);
            throw new Error(`${l} not found in scope.`);
          }
          has(l) {
            return !!this.bindings[l] || !!this.parent && this.parent.has(l);
          }
        }
        const sn = { kind: "null" }, Xt = { kind: "number" }, Dr = { kind: "string" }, zr = { kind: "boolean" }, bn = { kind: "color" }, qo = { kind: "projectionDefinition" }, Qn = { kind: "object" }, Nr = { kind: "value" }, wo = { kind: "collator" }, Wo = { kind: "formatted" }, Xo = { kind: "padding" }, Ul = { kind: "colorArray" }, Zo = { kind: "numberArray" }, ol = { kind: "resolvedImage" }, Ao = { kind: "variableAnchorOffsetCollection" };
        function Qi(h, l) {
          return { kind: "array", itemType: h, N: l };
        }
        function ti(h) {
          if (h.kind === "array") {
            const l = ti(h.itemType);
            return typeof h.N == "number" ? `array<${l}, ${h.N}>` : h.itemType.kind === "value" ? "array" : `array<${l}>`;
          }
          return h.kind;
        }
        const ch = [sn, Xt, Dr, zr, bn, qo, Wo, Qn, Qi(Nr), Xo, Zo, Ul, ol, Ao];
        function ha(h, l) {
          if (l.kind === "error") return null;
          if (h.kind === "array") {
            if (l.kind === "array" && (l.N === 0 && l.itemType.kind === "value" || !ha(h.itemType, l.itemType)) && (typeof h.N != "number" || h.N === l.N)) return null;
          } else {
            if (h.kind === l.kind) return null;
            if (h.kind === "value") {
              for (const u of ch) if (!ha(u, l)) return null;
            }
          }
          return `Expected ${ti(h)} but found ${ti(l)} instead.`;
        }
        function fa(h, l) {
          return l.some((u) => u.kind === h.kind);
        }
        function Yo(h, l) {
          return l.some((u) => u === "null" ? h === null : u === "array" ? Array.isArray(h) : u === "object" ? h && !Array.isArray(h) && typeof h == "object" : u === typeof h);
        }
        function Jo(h, l) {
          return h.kind === "array" && l.kind === "array" ? h.itemType.kind === l.itemType.kind && typeof h.N == "number" : h.kind === l.kind;
        }
        const zl = 0.96422, Tu = 0.82521, Ln = 4 / 29, da = 6 / 29, Su = 3 * da * da, La = da * da * da, jl = Math.PI / 180, Ko = 180 / Math.PI;
        function al(h) {
          return (h %= 360) < 0 && (h += 360), h;
        }
        function Sn([h, l, u, p]) {
          let _, x;
          const A = Bc((0.2225045 * (h = Vl(h)) + 0.7168786 * (l = Vl(l)) + 0.0606169 * (u = Vl(u))) / 1);
          h === l && l === u ? _ = x = A : (_ = Bc((0.4360747 * h + 0.3850649 * l + 0.1430804 * u) / zl), x = Bc((0.0139322 * h + 0.0971045 * l + 0.7141733 * u) / Tu));
          const E = 116 * A - 16;
          return [E < 0 ? 0 : E, 500 * (_ - A), 200 * (A - x), p];
        }
        function Vl(h) {
          return h <= 0.04045 ? h / 12.92 : Math.pow((h + 0.055) / 1.055, 2.4);
        }
        function Bc(h) {
          return h > La ? Math.pow(h, 1 / 3) : h / Su + Ln;
        }
        function ll([h, l, u, p]) {
          let _ = (h + 16) / 116, x = isNaN(l) ? _ : _ + l / 500, A = isNaN(u) ? _ : _ - u / 200;
          return _ = 1 * To(_), x = zl * To(x), A = Tu * To(A), [Eu(3.1338561 * x - 1.6168667 * _ - 0.4906146 * A), Eu(-0.9787684 * x + 1.9161415 * _ + 0.033454 * A), Eu(0.0719453 * x - 0.2289914 * _ + 1.4052427 * A), p];
        }
        function Eu(h) {
          return (h = h <= 304e-5 ? 12.92 * h : 1.055 * Math.pow(h, 1 / 2.4) - 0.055) < 0 ? 0 : h > 1 ? 1 : h;
        }
        function To(h) {
          return h > da ? h * h * h : Su * (h - Ln);
        }
        const cl = Object.hasOwn || function(h, l) {
          return Object.prototype.hasOwnProperty.call(h, l);
        };
        function ul(h, l) {
          return cl(h, l) ? h[l] : void 0;
        }
        function Qo(h) {
          return parseInt(h.padEnd(2, h), 16) / 255;
        }
        function kc(h, l) {
          return Ba(l ? h / 100 : h, 0, 1);
        }
        function Ba(h, l, u) {
          return Math.min(Math.max(l, h), u);
        }
        function Cu(h) {
          return !h.some(Number.isNaN);
        }
        const So = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Jr(h, l, u) {
          return h + u * (l - h);
        }
        function fs(h, l, u) {
          return h.map((p, _) => Jr(p, l[_], u));
        }
        class jr {
          constructor(l, u, p, _ = 1, x = !0) {
            this.r = l, this.g = u, this.b = p, this.a = _, x || (this.r *= _, this.g *= _, this.b *= _, _ || this.overwriteGetter("rgb", [l, u, p, _]));
          }
          static parse(l) {
            if (l instanceof jr) return l;
            if (typeof l != "string") return;
            const u = function(p) {
              if ((p = p.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const _ = ul(So, p);
              if (_) {
                const [A, E, M] = _;
                return [A / 255, E / 255, M / 255, 1];
              }
              if (p.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(p)) {
                const A = p.length < 6 ? 1 : 2;
                let E = 1;
                return [Qo(p.slice(E, E += A)), Qo(p.slice(E, E += A)), Qo(p.slice(E, E += A)), Qo(p.slice(E, E + A) || "ff")];
              }
              if (p.startsWith("rgb")) {
                const A = p.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (A) {
                  const [E, M, O, N, V, Y, ee, ie, ue, ve, Re, it] = A, ze = [N || " ", ee || " ", ve].join("");
                  if (ze === "  " || ze === "  /" || ze === ",," || ze === ",,,") {
                    const Ze = [O, Y, ue].join(""), yt = Ze === "%%%" ? 100 : Ze === "" ? 255 : 0;
                    if (yt) {
                      const Pt = [Ba(+M / yt, 0, 1), Ba(+V / yt, 0, 1), Ba(+ie / yt, 0, 1), Re ? kc(+Re, it) : 1];
                      if (Cu(Pt)) return Pt;
                    }
                  }
                  return;
                }
              }
              const x = p.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (x) {
                const [A, E, M, O, N, V, Y, ee, ie] = x, ue = [M || " ", N || " ", Y].join("");
                if (ue === "  " || ue === "  /" || ue === ",," || ue === ",,,") {
                  const ve = [+E, Ba(+O, 0, 100), Ba(+V, 0, 100), ee ? kc(+ee, ie) : 1];
                  if (Cu(ve)) return function([Re, it, ze, Ze]) {
                    function yt(Pt) {
                      const Gt = (Pt + Re / 30) % 12, or = it * Math.min(ze, 1 - ze);
                      return ze - or * Math.max(-1, Math.min(Gt - 3, 9 - Gt, 1));
                    }
                    return Re = al(Re), it /= 100, ze /= 100, [yt(0), yt(8), yt(4), Ze];
                  }(ve);
                }
              }
            }(l);
            return u ? new jr(...u, !1) : void 0;
          }
          get rgb() {
            const { r: l, g: u, b: p, a: _ } = this, x = _ || 1 / 0;
            return this.overwriteGetter("rgb", [l / x, u / x, p / x, _]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(l) {
              const [u, p, _, x] = Sn(l), A = Math.sqrt(p * p + _ * _);
              return [Math.round(1e4 * A) ? al(Math.atan2(_, p) * Ko) : NaN, A, u, x];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Sn(this.rgb));
          }
          overwriteGetter(l, u) {
            return Object.defineProperty(this, l, { value: u }), u;
          }
          toString() {
            const [l, u, p, _] = this.rgb;
            return `rgba(${[l, u, p].map((x) => Math.round(255 * x)).join(",")},${_})`;
          }
          static interpolate(l, u, p, _ = "rgb") {
            switch (_) {
              case "rgb": {
                const [x, A, E, M] = fs(l.rgb, u.rgb, p);
                return new jr(x, A, E, M, !1);
              }
              case "hcl": {
                const [x, A, E, M] = l.hcl, [O, N, V, Y] = u.hcl;
                let ee, ie;
                if (isNaN(x) || isNaN(O)) isNaN(x) ? isNaN(O) ? ee = NaN : (ee = O, E !== 1 && E !== 0 || (ie = N)) : (ee = x, V !== 1 && V !== 0 || (ie = A));
                else {
                  let ze = O - x;
                  O > x && ze > 180 ? ze -= 360 : O < x && x - O > 180 && (ze += 360), ee = x + p * ze;
                }
                const [ue, ve, Re, it] = function([ze, Ze, yt, Pt]) {
                  return ze = isNaN(ze) ? 0 : ze * jl, ll([yt, Math.cos(ze) * Ze, Math.sin(ze) * Ze, Pt]);
                }([ee, ie ?? Jr(A, N, p), Jr(E, V, p), Jr(M, Y, p)]);
                return new jr(ue, ve, Re, it, !1);
              }
              case "lab": {
                const [x, A, E, M] = ll(fs(l.lab, u.lab, p));
                return new jr(x, A, E, M, !1);
              }
            }
          }
        }
        jr.black = new jr(0, 0, 0, 1), jr.white = new jr(1, 1, 1, 1), jr.transparent = new jr(0, 0, 0, 0), jr.red = new jr(1, 0, 0, 1);
        class Oc {
          constructor(l, u, p) {
            this.sensitivity = l ? u ? "variant" : "case" : u ? "accent" : "base", this.locale = p, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(l, u) {
            return this.collator.compare(l, u);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const hl = ["bottom", "center", "top"];
        class ka {
          constructor(l, u, p, _, x, A) {
            this.text = l, this.image = u, this.scale = p, this.fontStack = _, this.textColor = x, this.verticalAlign = A;
          }
        }
        class Er {
          constructor(l) {
            this.sections = l;
          }
          static fromString(l) {
            return new Er([new ka(l, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((l) => l.text.length !== 0 || l.image && l.image.name.length !== 0);
          }
          static factory(l) {
            return l instanceof Er ? l : Er.fromString(l);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((l) => l.text).join("");
          }
        }
        class Fn {
          constructor(l) {
            this.values = l.slice();
          }
          static parse(l) {
            if (l instanceof Fn) return l;
            if (typeof l == "number") return new Fn([l, l, l, l]);
            if (Array.isArray(l) && !(l.length < 1 || l.length > 4)) {
              for (const u of l) if (typeof u != "number") return;
              switch (l.length) {
                case 1:
                  l = [l[0], l[0], l[0], l[0]];
                  break;
                case 2:
                  l = [l[0], l[1], l[0], l[1]];
                  break;
                case 3:
                  l = [l[0], l[1], l[2], l[1]];
              }
              return new Fn(l);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(l, u, p) {
            return new Fn(fs(l.values, u.values, p));
          }
        }
        class es {
          constructor(l) {
            this.values = l.slice();
          }
          static parse(l) {
            if (l instanceof es) return l;
            if (typeof l == "number") return new es([l]);
            if (Array.isArray(l)) {
              for (const u of l) if (typeof u != "number") return;
              return new es(l);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(l, u, p) {
            return new es(fs(l.values, u.values, p));
          }
        }
        class Bn {
          constructor(l) {
            this.values = l.slice();
          }
          static parse(l) {
            if (l instanceof Bn) return l;
            if (typeof l == "string") {
              const p = jr.parse(l);
              return p ? new Bn([p]) : void 0;
            }
            if (!Array.isArray(l)) return;
            const u = [];
            for (const p of l) {
              if (typeof p != "string") return;
              const _ = jr.parse(p);
              if (!_) return;
              u.push(_);
            }
            return new Bn(u);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(l, u, p, _ = "rgb") {
            const x = [];
            if (l.values.length != u.values.length) throw new Error(`colorArray: Arrays have mismatched length (${l.values.length} vs. ${u.values.length}), cannot interpolate.`);
            for (let A = 0; A < l.values.length; A++) x.push(jr.interpolate(l.values[A], u.values[A], p, _));
            return new Bn(x);
          }
        }
        class ji extends Error {
          constructor(l) {
            super(l), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const Oa = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class on {
          constructor(l) {
            this.values = l.slice();
          }
          static parse(l) {
            if (l instanceof on) return l;
            if (Array.isArray(l) && !(l.length < 1) && l.length % 2 == 0) {
              for (let u = 0; u < l.length; u += 2) {
                const p = l[u], _ = l[u + 1];
                if (typeof p != "string" || !Oa.has(p) || !Array.isArray(_) || _.length !== 2 || typeof _[0] != "number" || typeof _[1] != "number") return;
              }
              return new on(l);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(l, u, p) {
            const _ = l.values, x = u.values;
            if (_.length !== x.length) throw new ji(`Cannot interpolate values of different length. from: ${l.toString()}, to: ${u.toString()}`);
            const A = [];
            for (let E = 0; E < _.length; E += 2) {
              if (_[E] !== x[E]) throw new ji(`Cannot interpolate values containing mismatched anchors. from[${E}]: ${_[E]}, to[${E}]: ${x[E]}`);
              A.push(_[E]);
              const [M, O] = _[E + 1], [N, V] = x[E + 1];
              A.push([Jr(M, N, p), Jr(O, V, p)]);
            }
            return new on(A);
          }
        }
        class Hn {
          constructor(l) {
            this.name = l.name, this.available = l.available;
          }
          toString() {
            return this.name;
          }
          static fromString(l) {
            return l ? new Hn({ name: l, available: !1 }) : null;
          }
        }
        class As {
          constructor(l, u, p) {
            this.from = l, this.to = u, this.transition = p;
          }
          static interpolate(l, u, p) {
            return new As(l, u, p);
          }
          static parse(l) {
            return l instanceof As ? l : Array.isArray(l) && l.length === 3 && typeof l[0] == "string" && typeof l[1] == "string" && typeof l[2] == "number" ? new As(l[0], l[1], l[2]) : typeof l == "object" && typeof l.from == "string" && typeof l.to == "string" && typeof l.transition == "number" ? new As(l.from, l.to, l.transition) : typeof l == "string" ? new As(l, l, 1) : void 0;
          }
        }
        function fl(h, l, u, p) {
          return typeof h == "number" && h >= 0 && h <= 255 && typeof l == "number" && l >= 0 && l <= 255 && typeof u == "number" && u >= 0 && u <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : `Invalid rgba value [${[h, l, u, p].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof p == "number" ? [h, l, u, p] : [h, l, u]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function pa(h) {
          if (h === null || typeof h == "string" || typeof h == "boolean" || typeof h == "number" || h instanceof As || h instanceof jr || h instanceof Oc || h instanceof Er || h instanceof Fn || h instanceof es || h instanceof Bn || h instanceof on || h instanceof Hn) return !0;
          if (Array.isArray(h)) {
            for (const l of h) if (!pa(l)) return !1;
            return !0;
          }
          if (typeof h == "object") {
            for (const l in h) if (!pa(h[l])) return !1;
            return !0;
          }
          return !1;
        }
        function ki(h) {
          if (h === null) return sn;
          if (typeof h == "string") return Dr;
          if (typeof h == "boolean") return zr;
          if (typeof h == "number") return Xt;
          if (h instanceof jr) return bn;
          if (h instanceof As) return qo;
          if (h instanceof Oc) return wo;
          if (h instanceof Er) return Wo;
          if (h instanceof Fn) return Xo;
          if (h instanceof es) return Zo;
          if (h instanceof Bn) return Ul;
          if (h instanceof on) return Ao;
          if (h instanceof Hn) return ol;
          if (Array.isArray(h)) {
            const l = h.length;
            let u;
            for (const p of h) {
              const _ = ki(p);
              if (u) {
                if (u === _) continue;
                u = Nr;
                break;
              }
              u = _;
            }
            return Qi(u || Nr, l);
          }
          return Qn;
        }
        function Si(h) {
          const l = typeof h;
          return h === null ? "" : l === "string" || l === "number" || l === "boolean" ? String(h) : h instanceof jr || h instanceof As || h instanceof Er || h instanceof Fn || h instanceof es || h instanceof Bn || h instanceof on || h instanceof Hn ? h.toString() : JSON.stringify(h);
        }
        class to {
          constructor(l, u) {
            this.type = l, this.value = u;
          }
          static parse(l, u) {
            if (l.length !== 2) return u.error(`'literal' expression requires exactly one argument, but found ${l.length - 1} instead.`);
            if (!pa(l[1])) return u.error("invalid value");
            const p = l[1];
            let _ = ki(p);
            const x = u.expectedType;
            return _.kind !== "array" || _.N !== 0 || !x || x.kind !== "array" || typeof x.N == "number" && x.N !== 0 || (_ = x), new to(_, p);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const fi = { string: Dr, number: Xt, boolean: zr, object: Qn };
        class Or {
          constructor(l, u) {
            this.type = l, this.args = u;
          }
          static parse(l, u) {
            if (l.length < 2) return u.error("Expected at least one argument.");
            let p, _ = 1;
            const x = l[0];
            if (x === "array") {
              let E, M;
              if (l.length > 2) {
                const O = l[1];
                if (typeof O != "string" || !(O in fi) || O === "object") return u.error('The item type argument of "array" must be one of string, number, boolean', 1);
                E = fi[O], _++;
              } else E = Nr;
              if (l.length > 3) {
                if (l[2] !== null && (typeof l[2] != "number" || l[2] < 0 || l[2] !== Math.floor(l[2]))) return u.error('The length argument to "array" must be a positive integer literal', 2);
                M = l[2], _++;
              }
              p = Qi(E, M);
            } else {
              if (!fi[x]) throw new Error(`Types doesn't contain name = ${x}`);
              p = fi[x];
            }
            const A = [];
            for (; _ < l.length; _++) {
              const E = u.parse(l[_], _, Nr);
              if (!E) return null;
              A.push(E);
            }
            return new Or(p, A);
          }
          evaluate(l) {
            for (let u = 0; u < this.args.length; u++) {
              const p = this.args[u].evaluate(l);
              if (!ha(this.type, ki(p))) return p;
              if (u === this.args.length - 1) throw new ji(`Expected value to be of type ${ti(this.type)}, but found ${ti(ki(p))} instead.`);
            }
            throw new Error();
          }
          eachChild(l) {
            this.args.forEach(l);
          }
          outputDefined() {
            return this.args.every((l) => l.outputDefined());
          }
        }
        const dl = { "to-boolean": zr, "to-color": bn, "to-number": Xt, "to-string": Dr };
        class Qr {
          constructor(l, u) {
            this.type = l, this.args = u;
          }
          static parse(l, u) {
            if (l.length < 2) return u.error("Expected at least one argument.");
            const p = l[0];
            if (!dl[p]) throw new Error(`Can't parse ${p} as it is not part of the known types`);
            if ((p === "to-boolean" || p === "to-string") && l.length !== 2) return u.error("Expected one argument.");
            const _ = dl[p], x = [];
            for (let A = 1; A < l.length; A++) {
              const E = u.parse(l[A], A, Nr);
              if (!E) return null;
              x.push(E);
            }
            return new Qr(_, x);
          }
          evaluate(l) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(l);
              case "color": {
                let u, p;
                for (const _ of this.args) {
                  if (u = _.evaluate(l), p = null, u instanceof jr) return u;
                  if (typeof u == "string") {
                    const x = l.parseColor(u);
                    if (x) return x;
                  } else if (Array.isArray(u) && (p = u.length < 3 || u.length > 4 ? `Invalid rgba value ${JSON.stringify(u)}: expected an array containing either three or four numeric values.` : fl(u[0], u[1], u[2], u[3]), !p)) return new jr(u[0] / 255, u[1] / 255, u[2] / 255, u[3]);
                }
                throw new ji(p || `Could not parse color from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "padding": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(l);
                  const _ = Fn.parse(u);
                  if (_) return _;
                }
                throw new ji(`Could not parse padding from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "numberArray": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(l);
                  const _ = es.parse(u);
                  if (_) return _;
                }
                throw new ji(`Could not parse numberArray from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "colorArray": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(l);
                  const _ = Bn.parse(u);
                  if (_) return _;
                }
                throw new ji(`Could not parse colorArray from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(l);
                  const _ = on.parse(u);
                  if (_) return _;
                }
                throw new ji(`Could not parse variableAnchorOffsetCollection from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "number": {
                let u = null;
                for (const p of this.args) {
                  if (u = p.evaluate(l), u === null) return 0;
                  const _ = Number(u);
                  if (!isNaN(_)) return _;
                }
                throw new ji(`Could not convert ${JSON.stringify(u)} to number.`);
              }
              case "formatted":
                return Er.fromString(Si(this.args[0].evaluate(l)));
              case "resolvedImage":
                return Hn.fromString(Si(this.args[0].evaluate(l)));
              case "projectionDefinition":
                return this.args[0].evaluate(l);
              default:
                return Si(this.args[0].evaluate(l));
            }
          }
          eachChild(l) {
            this.args.forEach(l);
          }
          outputDefined() {
            return this.args.every((l) => l.outputDefined());
          }
        }
        const Da = ["Unknown", "Point", "LineString", "Polygon"];
        class ro {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Da[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(l) {
            let u = this._parseColorCache.get(l);
            return u || (u = jr.parse(l), this._parseColorCache.set(l, u)), u;
          }
        }
        class ea {
          constructor(l, u, p = [], _, x = new eo(), A = []) {
            this.registry = l, this.path = p, this.key = p.map((E) => `[${E}]`).join(""), this.scope = x, this.errors = A, this.expectedType = _, this._isConstant = u;
          }
          parse(l, u, p, _, x = {}) {
            return u ? this.concat(u, p, _)._parse(l, x) : this._parse(l, x);
          }
          _parse(l, u) {
            function p(_, x, A) {
              return A === "assert" ? new Or(x, [_]) : A === "coerce" ? new Qr(x, [_]) : _;
            }
            if (l !== null && typeof l != "string" && typeof l != "boolean" && typeof l != "number" || (l = ["literal", l]), Array.isArray(l)) {
              if (l.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const _ = l[0];
              if (typeof _ != "string") return this.error(`Expression name must be a string, but found ${typeof _} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const x = this.registry[_];
              if (x) {
                let A = x.parse(l, this);
                if (!A) return null;
                if (this.expectedType) {
                  const E = this.expectedType, M = A.type;
                  if (E.kind !== "string" && E.kind !== "number" && E.kind !== "boolean" && E.kind !== "object" && E.kind !== "array" || M.kind !== "value") {
                    if (E.kind === "projectionDefinition" && ["string", "array"].includes(M.kind) || ["color", "formatted", "resolvedImage"].includes(E.kind) && ["value", "string"].includes(M.kind) || ["padding", "numberArray"].includes(E.kind) && ["value", "number", "array"].includes(M.kind) || E.kind === "colorArray" && ["value", "string", "array"].includes(M.kind) || E.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(M.kind)) A = p(A, E, u.typeAnnotation || "coerce");
                    else if (this.checkSubtype(E, M)) return null;
                  } else A = p(A, E, u.typeAnnotation || "assert");
                }
                if (!(A instanceof to) && A.type.kind !== "resolvedImage" && this._isConstant(A)) {
                  const E = new ro();
                  try {
                    A = new to(A.type, A.evaluate(E));
                  } catch (M) {
                    return this.error(M.message), null;
                  }
                }
                return A;
              }
              return this.error(`Unknown expression "${_}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(l === void 0 ? "'undefined' value invalid. Use null instead." : typeof l == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof l} instead.`);
          }
          concat(l, u, p) {
            const _ = typeof l == "number" ? this.path.concat(l) : this.path, x = p ? this.scope.concat(p) : this.scope;
            return new ea(this.registry, this._isConstant, _, u || null, x, this.errors);
          }
          error(l, ...u) {
            const p = `${this.key}${u.map((_) => `[${_}]`).join("")}`;
            this.errors.push(new Rn(p, l));
          }
          checkSubtype(l, u) {
            const p = ha(l, u);
            return p && this.error(p), p;
          }
        }
        class ta {
          constructor(l, u) {
            this.type = u.type, this.bindings = [].concat(l), this.result = u;
          }
          evaluate(l) {
            return this.result.evaluate(l);
          }
          eachChild(l) {
            for (const u of this.bindings) l(u[1]);
            l(this.result);
          }
          static parse(l, u) {
            if (l.length < 4) return u.error(`Expected at least 3 arguments, but found ${l.length - 1} instead.`);
            const p = [];
            for (let x = 1; x < l.length - 1; x += 2) {
              const A = l[x];
              if (typeof A != "string") return u.error(`Expected string, but found ${typeof A} instead.`, x);
              if (/[^a-zA-Z0-9_]/.test(A)) return u.error("Variable names must contain only alphanumeric characters or '_'.", x);
              const E = u.parse(l[x + 1], x + 1);
              if (!E) return null;
              p.push([A, E]);
            }
            const _ = u.parse(l[l.length - 1], l.length - 1, u.expectedType, p);
            return _ ? new ta(p, _) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class ra {
          constructor(l, u) {
            this.type = u.type, this.name = l, this.boundExpression = u;
          }
          static parse(l, u) {
            if (l.length !== 2 || typeof l[1] != "string") return u.error("'var' expression requires exactly one string literal argument.");
            const p = l[1];
            return u.scope.has(p) ? new ra(p, u.scope.get(p)) : u.error(`Unknown variable "${p}". Make sure "${p}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(l) {
            return this.boundExpression.evaluate(l);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class Na {
          constructor(l, u, p) {
            this.type = l, this.index = u, this.input = p;
          }
          static parse(l, u) {
            if (l.length !== 3) return u.error(`Expected 2 arguments, but found ${l.length - 1} instead.`);
            const p = u.parse(l[1], 1, Xt), _ = u.parse(l[2], 2, Qi(u.expectedType || Nr));
            return p && _ ? new Na(_.type.itemType, p, _) : null;
          }
          evaluate(l) {
            const u = this.index.evaluate(l), p = this.input.evaluate(l);
            if (u < 0) throw new ji(`Array index out of bounds: ${u} < 0.`);
            if (u >= p.length) throw new ji(`Array index out of bounds: ${u} > ${p.length - 1}.`);
            if (u !== Math.floor(u)) throw new ji(`Array index must be an integer, but found ${u} instead.`);
            return p[u];
          }
          eachChild(l) {
            l(this.index), l(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class pl {
          constructor(l, u) {
            this.type = zr, this.needle = l, this.haystack = u;
          }
          static parse(l, u) {
            if (l.length !== 3) return u.error(`Expected 2 arguments, but found ${l.length - 1} instead.`);
            const p = u.parse(l[1], 1, Nr), _ = u.parse(l[2], 2, Nr);
            return p && _ ? fa(p.type, [zr, Dr, Xt, sn, Nr]) ? new pl(p, _) : u.error(`Expected first argument to be of type boolean, string, number or null, but found ${ti(p.type)} instead`) : null;
          }
          evaluate(l) {
            const u = this.needle.evaluate(l), p = this.haystack.evaluate(l);
            if (!p) return !1;
            if (!Yo(u, ["boolean", "string", "number", "null"])) throw new ji(`Expected first argument to be of type boolean, string, number or null, but found ${ti(ki(u))} instead.`);
            if (!Yo(p, ["string", "array"])) throw new ji(`Expected second argument to be of type array or string, but found ${ti(ki(p))} instead.`);
            return p.indexOf(u) >= 0;
          }
          eachChild(l) {
            l(this.needle), l(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class Ts {
          constructor(l, u, p) {
            this.type = Xt, this.needle = l, this.haystack = u, this.fromIndex = p;
          }
          static parse(l, u) {
            if (l.length <= 2 || l.length >= 5) return u.error(`Expected 2 or 3 arguments, but found ${l.length - 1} instead.`);
            const p = u.parse(l[1], 1, Nr), _ = u.parse(l[2], 2, Nr);
            if (!p || !_) return null;
            if (!fa(p.type, [zr, Dr, Xt, sn, Nr])) return u.error(`Expected first argument to be of type boolean, string, number or null, but found ${ti(p.type)} instead`);
            if (l.length === 4) {
              const x = u.parse(l[3], 3, Xt);
              return x ? new Ts(p, _, x) : null;
            }
            return new Ts(p, _);
          }
          evaluate(l) {
            const u = this.needle.evaluate(l), p = this.haystack.evaluate(l);
            if (!Yo(u, ["boolean", "string", "number", "null"])) throw new ji(`Expected first argument to be of type boolean, string, number or null, but found ${ti(ki(u))} instead.`);
            let _;
            if (this.fromIndex && (_ = this.fromIndex.evaluate(l)), Yo(p, ["string"])) {
              const x = p.indexOf(u, _);
              return x === -1 ? -1 : [...p.slice(0, x)].length;
            }
            if (Yo(p, ["array"])) return p.indexOf(u, _);
            throw new ji(`Expected second argument to be of type array or string, but found ${ti(ki(p))} instead.`);
          }
          eachChild(l) {
            l(this.needle), l(this.haystack), this.fromIndex && l(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class po {
          constructor(l, u, p, _, x, A) {
            this.inputType = l, this.type = u, this.input = p, this.cases = _, this.outputs = x, this.otherwise = A;
          }
          static parse(l, u) {
            if (l.length < 5) return u.error(`Expected at least 4 arguments, but found only ${l.length - 1}.`);
            if (l.length % 2 != 1) return u.error("Expected an even number of arguments.");
            let p, _;
            u.expectedType && u.expectedType.kind !== "value" && (_ = u.expectedType);
            const x = {}, A = [];
            for (let O = 2; O < l.length - 1; O += 2) {
              let N = l[O];
              const V = l[O + 1];
              Array.isArray(N) || (N = [N]);
              const Y = u.concat(O);
              if (N.length === 0) return Y.error("Expected at least one branch label.");
              for (const ie of N) {
                if (typeof ie != "number" && typeof ie != "string") return Y.error("Branch labels must be numbers or strings.");
                if (typeof ie == "number" && Math.abs(ie) > Number.MAX_SAFE_INTEGER) return Y.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof ie == "number" && Math.floor(ie) !== ie) return Y.error("Numeric branch labels must be integer values.");
                if (p) {
                  if (Y.checkSubtype(p, ki(ie))) return null;
                } else p = ki(ie);
                if (x[String(ie)] !== void 0) return Y.error("Branch labels must be unique.");
                x[String(ie)] = A.length;
              }
              const ee = u.parse(V, O, _);
              if (!ee) return null;
              _ = _ || ee.type, A.push(ee);
            }
            const E = u.parse(l[1], 1, Nr);
            if (!E) return null;
            const M = u.parse(l[l.length - 1], l.length - 1, _);
            return M ? E.type.kind !== "value" && u.concat(1).checkSubtype(p, E.type) ? null : new po(p, _, E, x, A, M) : null;
          }
          evaluate(l) {
            const u = this.input.evaluate(l);
            return (ki(u) === this.inputType && this.outputs[this.cases[u]] || this.otherwise).evaluate(l);
          }
          eachChild(l) {
            l(this.input), this.outputs.forEach(l), l(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((l) => l.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class F {
          constructor(l, u, p) {
            this.type = l, this.branches = u, this.otherwise = p;
          }
          static parse(l, u) {
            if (l.length < 4) return u.error(`Expected at least 3 arguments, but found only ${l.length - 1}.`);
            if (l.length % 2 != 0) return u.error("Expected an odd number of arguments.");
            let p;
            u.expectedType && u.expectedType.kind !== "value" && (p = u.expectedType);
            const _ = [];
            for (let A = 1; A < l.length - 1; A += 2) {
              const E = u.parse(l[A], A, zr);
              if (!E) return null;
              const M = u.parse(l[A + 1], A + 1, p);
              if (!M) return null;
              _.push([E, M]), p = p || M.type;
            }
            const x = u.parse(l[l.length - 1], l.length - 1, p);
            if (!x) return null;
            if (!p) throw new Error("Can't infer output type");
            return new F(p, _, x);
          }
          evaluate(l) {
            for (const [u, p] of this.branches) if (u.evaluate(l)) return p.evaluate(l);
            return this.otherwise.evaluate(l);
          }
          eachChild(l) {
            for (const [u, p] of this.branches) l(u), l(p);
            l(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([l, u]) => u.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class se {
          constructor(l, u, p, _) {
            this.type = l, this.input = u, this.beginIndex = p, this.endIndex = _;
          }
          static parse(l, u) {
            if (l.length <= 2 || l.length >= 5) return u.error(`Expected 2 or 3 arguments, but found ${l.length - 1} instead.`);
            const p = u.parse(l[1], 1, Nr), _ = u.parse(l[2], 2, Xt);
            if (!p || !_) return null;
            if (!fa(p.type, [Qi(Nr), Dr, Nr])) return u.error(`Expected first argument to be of type array or string, but found ${ti(p.type)} instead`);
            if (l.length === 4) {
              const x = u.parse(l[3], 3, Xt);
              return x ? new se(p.type, p, _, x) : null;
            }
            return new se(p.type, p, _);
          }
          evaluate(l) {
            const u = this.input.evaluate(l), p = this.beginIndex.evaluate(l);
            let _;
            if (this.endIndex && (_ = this.endIndex.evaluate(l)), Yo(u, ["string"])) return [...u].slice(p, _).join("");
            if (Yo(u, ["array"])) return u.slice(p, _);
            throw new ji(`Expected first argument to be of type array or string, but found ${ti(ki(u))} instead.`);
          }
          eachChild(l) {
            l(this.input), l(this.beginIndex), this.endIndex && l(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function Ie(h, l) {
          const u = h.length - 1;
          let p, _, x = 0, A = u, E = 0;
          for (; x <= A; ) if (E = Math.floor((x + A) / 2), p = h[E], _ = h[E + 1], p <= l) {
            if (E === u || l < _) return E;
            x = E + 1;
          } else {
            if (!(p > l)) throw new ji("Input is not a number.");
            A = E - 1;
          }
          return 0;
        }
        class Ye {
          constructor(l, u, p) {
            this.type = l, this.input = u, this.labels = [], this.outputs = [];
            for (const [_, x] of p) this.labels.push(_), this.outputs.push(x);
          }
          static parse(l, u) {
            if (l.length - 1 < 4) return u.error(`Expected at least 4 arguments, but found only ${l.length - 1}.`);
            if ((l.length - 1) % 2 != 0) return u.error("Expected an even number of arguments.");
            const p = u.parse(l[1], 1, Xt);
            if (!p) return null;
            const _ = [];
            let x = null;
            u.expectedType && u.expectedType.kind !== "value" && (x = u.expectedType);
            for (let A = 1; A < l.length; A += 2) {
              const E = A === 1 ? -1 / 0 : l[A], M = l[A + 1], O = A, N = A + 1;
              if (typeof E != "number") return u.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', O);
              if (_.length && _[_.length - 1][0] >= E) return u.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', O);
              const V = u.parse(M, N, x);
              if (!V) return null;
              x = x || V.type, _.push([E, V]);
            }
            return new Ye(x, p, _);
          }
          evaluate(l) {
            const u = this.labels, p = this.outputs;
            if (u.length === 1) return p[0].evaluate(l);
            const _ = this.input.evaluate(l);
            if (_ <= u[0]) return p[0].evaluate(l);
            const x = u.length;
            return _ >= u[x - 1] ? p[x - 1].evaluate(l) : p[Ie(u, _)].evaluate(l);
          }
          eachChild(l) {
            l(this.input);
            for (const u of this.outputs) l(u);
          }
          outputDefined() {
            return this.outputs.every((l) => l.outputDefined());
          }
        }
        function ut(h) {
          return h && h.__esModule && Object.prototype.hasOwnProperty.call(h, "default") ? h.default : h;
        }
        var Nt, Ut, vr = function() {
          if (Ut) return Nt;
          function h(l, u, p, _) {
            this.cx = 3 * l, this.bx = 3 * (p - l) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * u, this.by = 3 * (_ - u) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = l, this.p1y = u, this.p2x = p, this.p2y = _;
          }
          return Ut = 1, Nt = h, h.prototype = { sampleCurveX: function(l) {
            return ((this.ax * l + this.bx) * l + this.cx) * l;
          }, sampleCurveY: function(l) {
            return ((this.ay * l + this.by) * l + this.cy) * l;
          }, sampleCurveDerivativeX: function(l) {
            return (3 * this.ax * l + 2 * this.bx) * l + this.cx;
          }, solveCurveX: function(l, u) {
            if (u === void 0 && (u = 1e-6), l < 0) return 0;
            if (l > 1) return 1;
            for (var p = l, _ = 0; _ < 8; _++) {
              var x = this.sampleCurveX(p) - l;
              if (Math.abs(x) < u) return p;
              var A = this.sampleCurveDerivativeX(p);
              if (Math.abs(A) < 1e-6) break;
              p -= x / A;
            }
            var E = 0, M = 1;
            for (p = l, _ = 0; _ < 20 && (x = this.sampleCurveX(p), !(Math.abs(x - l) < u)); _++) l > x ? E = p : M = p, p = 0.5 * (M - E) + E;
            return p;
          }, solve: function(l, u) {
            return this.sampleCurveY(this.solveCurveX(l, u));
          } }, Nt;
        }(), Cr = ut(vr);
        class Ir {
          constructor(l, u, p, _, x) {
            this.type = l, this.operator = u, this.interpolation = p, this.input = _, this.labels = [], this.outputs = [];
            for (const [A, E] of x) this.labels.push(A), this.outputs.push(E);
          }
          static interpolationFactor(l, u, p, _) {
            let x = 0;
            if (l.name === "exponential") x = ni(u, l.base, p, _);
            else if (l.name === "linear") x = ni(u, 1, p, _);
            else if (l.name === "cubic-bezier") {
              const A = l.controlPoints;
              x = new Cr(A[0], A[1], A[2], A[3]).solve(ni(u, 1, p, _));
            }
            return x;
          }
          static parse(l, u) {
            let [p, _, x, ...A] = l;
            if (!Array.isArray(_) || _.length === 0) return u.error("Expected an interpolation type expression.", 1);
            if (_[0] === "linear") _ = { name: "linear" };
            else if (_[0] === "exponential") {
              const O = _[1];
              if (typeof O != "number") return u.error("Exponential interpolation requires a numeric base.", 1, 1);
              _ = { name: "exponential", base: O };
            } else {
              if (_[0] !== "cubic-bezier") return u.error(`Unknown interpolation type ${String(_[0])}`, 1, 0);
              {
                const O = _.slice(1);
                if (O.length !== 4 || O.some((N) => typeof N != "number" || N < 0 || N > 1)) return u.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                _ = { name: "cubic-bezier", controlPoints: O };
              }
            }
            if (l.length - 1 < 4) return u.error(`Expected at least 4 arguments, but found only ${l.length - 1}.`);
            if ((l.length - 1) % 2 != 0) return u.error("Expected an even number of arguments.");
            if (x = u.parse(x, 2, Xt), !x) return null;
            const E = [];
            let M = null;
            p !== "interpolate-hcl" && p !== "interpolate-lab" || u.expectedType == Ul ? u.expectedType && u.expectedType.kind !== "value" && (M = u.expectedType) : M = bn;
            for (let O = 0; O < A.length; O += 2) {
              const N = A[O], V = A[O + 1], Y = O + 3, ee = O + 4;
              if (typeof N != "number") return u.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', Y);
              if (E.length && E[E.length - 1][0] >= N) return u.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', Y);
              const ie = u.parse(V, ee, M);
              if (!ie) return null;
              M = M || ie.type, E.push([N, ie]);
            }
            return Jo(M, Xt) || Jo(M, qo) || Jo(M, bn) || Jo(M, Xo) || Jo(M, Zo) || Jo(M, Ul) || Jo(M, Ao) || Jo(M, Qi(Xt)) ? new Ir(M, p, _, x, E) : u.error(`Type ${ti(M)} is not interpolatable.`);
          }
          evaluate(l) {
            const u = this.labels, p = this.outputs;
            if (u.length === 1) return p[0].evaluate(l);
            const _ = this.input.evaluate(l);
            if (_ <= u[0]) return p[0].evaluate(l);
            const x = u.length;
            if (_ >= u[x - 1]) return p[x - 1].evaluate(l);
            const A = Ie(u, _), E = Ir.interpolationFactor(this.interpolation, _, u[A], u[A + 1]), M = p[A].evaluate(l), O = p[A + 1].evaluate(l);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Jr(M, O, E);
                  case "color":
                    return jr.interpolate(M, O, E);
                  case "padding":
                    return Fn.interpolate(M, O, E);
                  case "colorArray":
                    return Bn.interpolate(M, O, E);
                  case "numberArray":
                    return es.interpolate(M, O, E);
                  case "variableAnchorOffsetCollection":
                    return on.interpolate(M, O, E);
                  case "array":
                    return fs(M, O, E);
                  case "projectionDefinition":
                    return As.interpolate(M, O, E);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return jr.interpolate(M, O, E, "hcl");
                  case "colorArray":
                    return Bn.interpolate(M, O, E, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return jr.interpolate(M, O, E, "lab");
                  case "colorArray":
                    return Bn.interpolate(M, O, E, "lab");
                }
            }
          }
          eachChild(l) {
            l(this.input);
            for (const u of this.outputs) l(u);
          }
          outputDefined() {
            return this.outputs.every((l) => l.outputDefined());
          }
        }
        function ni(h, l, u, p) {
          const _ = p - u, x = h - u;
          return _ === 0 ? 0 : l === 1 ? x / _ : (Math.pow(l, x) - 1) / (Math.pow(l, _) - 1);
        }
        const ri = { color: jr.interpolate, number: Jr, padding: Fn.interpolate, numberArray: es.interpolate, colorArray: Bn.interpolate, variableAnchorOffsetCollection: on.interpolate, array: fs };
        class Fi {
          constructor(l, u) {
            this.type = l, this.args = u;
          }
          static parse(l, u) {
            if (l.length < 2) return u.error("Expected at least one argument.");
            let p = null;
            const _ = u.expectedType;
            _ && _.kind !== "value" && (p = _);
            const x = [];
            for (const E of l.slice(1)) {
              const M = u.parse(E, 1 + x.length, p, void 0, { typeAnnotation: "omit" });
              if (!M) return null;
              p = p || M.type, x.push(M);
            }
            if (!p) throw new Error("No output type");
            const A = _ && x.some((E) => ha(_, E.type));
            return new Fi(A ? Nr : p, x);
          }
          evaluate(l) {
            let u, p = null, _ = 0;
            for (const x of this.args) if (_++, p = x.evaluate(l), p && p instanceof Hn && !p.available && (u || (u = p.name), p = null, _ === this.args.length && (p = u)), p !== null) break;
            return p;
          }
          eachChild(l) {
            this.args.forEach(l);
          }
          outputDefined() {
            return this.args.every((l) => l.outputDefined());
          }
        }
        function En(h, l) {
          return h === "==" || h === "!=" ? l.kind === "boolean" || l.kind === "string" || l.kind === "number" || l.kind === "null" || l.kind === "value" : l.kind === "string" || l.kind === "number" || l.kind === "value";
        }
        function Ui(h, l, u, p) {
          return p.compare(l, u) === 0;
        }
        function an(h, l, u) {
          const p = h !== "==" && h !== "!=";
          return class p5 {
            constructor(x, A, E) {
              this.type = zr, this.lhs = x, this.rhs = A, this.collator = E, this.hasUntypedArgument = x.type.kind === "value" || A.type.kind === "value";
            }
            static parse(x, A) {
              if (x.length !== 3 && x.length !== 4) return A.error("Expected two or three arguments.");
              const E = x[0];
              let M = A.parse(x[1], 1, Nr);
              if (!M) return null;
              if (!En(E, M.type)) return A.concat(1).error(`"${E}" comparisons are not supported for type '${ti(M.type)}'.`);
              let O = A.parse(x[2], 2, Nr);
              if (!O) return null;
              if (!En(E, O.type)) return A.concat(2).error(`"${E}" comparisons are not supported for type '${ti(O.type)}'.`);
              if (M.type.kind !== O.type.kind && M.type.kind !== "value" && O.type.kind !== "value") return A.error(`Cannot compare types '${ti(M.type)}' and '${ti(O.type)}'.`);
              p && (M.type.kind === "value" && O.type.kind !== "value" ? M = new Or(O.type, [M]) : M.type.kind !== "value" && O.type.kind === "value" && (O = new Or(M.type, [O])));
              let N = null;
              if (x.length === 4) {
                if (M.type.kind !== "string" && O.type.kind !== "string" && M.type.kind !== "value" && O.type.kind !== "value") return A.error("Cannot use collator to compare non-string types.");
                if (N = A.parse(x[3], 3, wo), !N) return null;
              }
              return new p5(M, O, N);
            }
            evaluate(x) {
              const A = this.lhs.evaluate(x), E = this.rhs.evaluate(x);
              if (p && this.hasUntypedArgument) {
                const M = ki(A), O = ki(E);
                if (M.kind !== O.kind || M.kind !== "string" && M.kind !== "number") throw new ji(`Expected arguments for "${h}" to be (string, string) or (number, number), but found (${M.kind}, ${O.kind}) instead.`);
              }
              if (this.collator && !p && this.hasUntypedArgument) {
                const M = ki(A), O = ki(E);
                if (M.kind !== "string" || O.kind !== "string") return l(x, A, E);
              }
              return this.collator ? u(x, A, E, this.collator.evaluate(x)) : l(x, A, E);
            }
            eachChild(x) {
              x(this.lhs), x(this.rhs), this.collator && x(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const vn = an("==", function(h, l, u) {
          return l === u;
        }, Ui), Un = an("!=", function(h, l, u) {
          return l !== u;
        }, function(h, l, u, p) {
          return !Ui(0, l, u, p);
        }), qn = an("<", function(h, l, u) {
          return l < u;
        }, function(h, l, u, p) {
          return p.compare(l, u) < 0;
        }), Fa = an(">", function(h, l, u) {
          return l > u;
        }, function(h, l, u, p) {
          return p.compare(l, u) > 0;
        }), Dc = an("<=", function(h, l, u) {
          return l <= u;
        }, function(h, l, u, p) {
          return p.compare(l, u) <= 0;
        }), uh = an(">=", function(h, l, u) {
          return l >= u;
        }, function(h, l, u, p) {
          return p.compare(l, u) >= 0;
        });
        class Eo {
          constructor(l, u, p) {
            this.type = wo, this.locale = p, this.caseSensitive = l, this.diacriticSensitive = u;
          }
          static parse(l, u) {
            if (l.length !== 2) return u.error("Expected one argument.");
            const p = l[1];
            if (typeof p != "object" || Array.isArray(p)) return u.error("Collator options argument must be an object.");
            const _ = u.parse(p["case-sensitive"] !== void 0 && p["case-sensitive"], 1, zr);
            if (!_) return null;
            const x = u.parse(p["diacritic-sensitive"] !== void 0 && p["diacritic-sensitive"], 1, zr);
            if (!x) return null;
            let A = null;
            return p.locale && (A = u.parse(p.locale, 1, Dr), !A) ? null : new Eo(_, x, A);
          }
          evaluate(l) {
            return new Oc(this.caseSensitive.evaluate(l), this.diacriticSensitive.evaluate(l), this.locale ? this.locale.evaluate(l) : null);
          }
          eachChild(l) {
            l(this.caseSensitive), l(this.diacriticSensitive), this.locale && l(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class go {
          constructor(l, u, p, _, x) {
            this.type = Dr, this.number = l, this.locale = u, this.currency = p, this.minFractionDigits = _, this.maxFractionDigits = x;
          }
          static parse(l, u) {
            if (l.length !== 3) return u.error("Expected two arguments.");
            const p = u.parse(l[1], 1, Xt);
            if (!p) return null;
            const _ = l[2];
            if (typeof _ != "object" || Array.isArray(_)) return u.error("NumberFormat options argument must be an object.");
            let x = null;
            if (_.locale && (x = u.parse(_.locale, 1, Dr), !x)) return null;
            let A = null;
            if (_.currency && (A = u.parse(_.currency, 1, Dr), !A)) return null;
            let E = null;
            if (_["min-fraction-digits"] && (E = u.parse(_["min-fraction-digits"], 1, Xt), !E)) return null;
            let M = null;
            return _["max-fraction-digits"] && (M = u.parse(_["max-fraction-digits"], 1, Xt), !M) ? null : new go(p, x, A, E, M);
          }
          evaluate(l) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(l) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(l) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(l) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(l) : void 0 }).format(this.number.evaluate(l));
          }
          eachChild(l) {
            l(this.number), this.locale && l(this.locale), this.currency && l(this.currency), this.minFractionDigits && l(this.minFractionDigits), this.maxFractionDigits && l(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class gl {
          constructor(l) {
            this.type = Wo, this.sections = l;
          }
          static parse(l, u) {
            if (l.length < 2) return u.error("Expected at least one argument.");
            const p = l[1];
            if (!Array.isArray(p) && typeof p == "object") return u.error("First argument must be an image or text section.");
            const _ = [];
            let x = !1;
            for (let A = 1; A <= l.length - 1; ++A) {
              const E = l[A];
              if (x && typeof E == "object" && !Array.isArray(E)) {
                x = !1;
                let M = null;
                if (E["font-scale"] && (M = u.parse(E["font-scale"], 1, Xt), !M)) return null;
                let O = null;
                if (E["text-font"] && (O = u.parse(E["text-font"], 1, Qi(Dr)), !O)) return null;
                let N = null;
                if (E["text-color"] && (N = u.parse(E["text-color"], 1, bn), !N)) return null;
                let V = null;
                if (E["vertical-align"]) {
                  if (typeof E["vertical-align"] == "string" && !hl.includes(E["vertical-align"])) return u.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${E["vertical-align"]}' instead.`);
                  if (V = u.parse(E["vertical-align"], 1, Dr), !V) return null;
                }
                const Y = _[_.length - 1];
                Y.scale = M, Y.font = O, Y.textColor = N, Y.verticalAlign = V;
              } else {
                const M = u.parse(l[A], 1, Nr);
                if (!M) return null;
                const O = M.type.kind;
                if (O !== "string" && O !== "value" && O !== "null" && O !== "resolvedImage") return u.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                x = !0, _.push({ content: M, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new gl(_);
          }
          evaluate(l) {
            return new Er(this.sections.map((u) => {
              const p = u.content.evaluate(l);
              return ki(p) === ol ? new ka("", p, null, null, null, u.verticalAlign ? u.verticalAlign.evaluate(l) : null) : new ka(Si(p), null, u.scale ? u.scale.evaluate(l) : null, u.font ? u.font.evaluate(l).join(",") : null, u.textColor ? u.textColor.evaluate(l) : null, u.verticalAlign ? u.verticalAlign.evaluate(l) : null);
            }));
          }
          eachChild(l) {
            for (const u of this.sections) l(u.content), u.scale && l(u.scale), u.font && l(u.font), u.textColor && l(u.textColor), u.verticalAlign && l(u.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class ml {
          constructor(l) {
            this.type = ol, this.input = l;
          }
          static parse(l, u) {
            if (l.length !== 2) return u.error("Expected two arguments.");
            const p = u.parse(l[1], 1, Dr);
            return p ? new ml(p) : u.error("No image name provided.");
          }
          evaluate(l) {
            const u = this.input.evaluate(l), p = Hn.fromString(u);
            return p && l.availableImages && (p.available = l.availableImages.indexOf(u) > -1), p;
          }
          eachChild(l) {
            l(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class ga {
          constructor(l) {
            this.type = Xt, this.input = l;
          }
          static parse(l, u) {
            if (l.length !== 2) return u.error(`Expected 1 argument, but found ${l.length - 1} instead.`);
            const p = u.parse(l[1], 1);
            return p ? p.type.kind !== "array" && p.type.kind !== "string" && p.type.kind !== "value" ? u.error(`Expected argument of type string or array, but found ${ti(p.type)} instead.`) : new ga(p) : null;
          }
          evaluate(l) {
            const u = this.input.evaluate(l);
            if (typeof u == "string") return [...u].length;
            if (Array.isArray(u)) return u.length;
            throw new ji(`Expected value to be of type string or array, but found ${ti(ki(u))} instead.`);
          }
          eachChild(l) {
            l(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const Oi = 8192;
        function Ua(h, l) {
          const u = (180 + h[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + h[1] * Math.PI / 360))) / 360, _ = Math.pow(2, l.z);
          return [Math.round(u * _ * Oi), Math.round(p * _ * Oi)];
        }
        function Co(h, l) {
          const u = Math.pow(2, l.z);
          return [(_ = (h[0] / Oi + l.x) / u, 360 * _ - 180), (p = (h[1] / Oi + l.y) / u, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * p) * Math.PI / 180)) - 90)];
          var p, _;
        }
        function ia(h, l) {
          h[0] = Math.min(h[0], l[0]), h[1] = Math.min(h[1], l[1]), h[2] = Math.max(h[2], l[0]), h[3] = Math.max(h[3], l[1]);
        }
        function za(h, l) {
          return !(h[0] <= l[0] || h[2] >= l[2] || h[1] <= l[1] || h[3] >= l[3]);
        }
        function Ss(h, l, u) {
          const p = h[0] - l[0], _ = h[1] - l[1], x = h[0] - u[0], A = h[1] - u[1];
          return p * A - x * _ == 0 && p * x <= 0 && _ * A <= 0;
        }
        function Gl(h, l, u, p) {
          return (_ = [p[0] - u[0], p[1] - u[1]])[0] * (x = [l[0] - h[0], l[1] - h[1]])[1] - _[1] * x[0] != 0 && !(!$l(h, l, u, p) || !$l(u, p, h, l));
          var _, x;
        }
        function Nc(h, l, u) {
          for (const p of u) for (let _ = 0; _ < p.length - 1; ++_) if (Gl(h, l, p[_], p[_ + 1])) return !0;
          return !1;
        }
        function ja(h, l, u = !1) {
          let p = !1;
          for (const E of l) for (let M = 0; M < E.length - 1; M++) {
            if (Ss(h, E[M], E[M + 1])) return u;
            (x = E[M])[1] > (_ = h)[1] != (A = E[M + 1])[1] > _[1] && _[0] < (A[0] - x[0]) * (_[1] - x[1]) / (A[1] - x[1]) + x[0] && (p = !p);
          }
          var _, x, A;
          return p;
        }
        function ts(h, l) {
          for (const u of l) if (ja(h, u)) return !0;
          return !1;
        }
        function mo(h, l) {
          for (const u of h) if (!ja(u, l)) return !1;
          for (let u = 0; u < h.length - 1; ++u) if (Nc(h[u], h[u + 1], l)) return !1;
          return !0;
        }
        function Fc(h, l) {
          for (const u of l) if (mo(h, u)) return !0;
          return !1;
        }
        function $l(h, l, u, p) {
          const _ = p[0] - u[0], x = p[1] - u[1], A = (h[0] - u[0]) * x - _ * (h[1] - u[1]), E = (l[0] - u[0]) * x - _ * (l[1] - u[1]);
          return A > 0 && E < 0 || A < 0 && E > 0;
        }
        function na(h, l, u) {
          const p = [];
          for (let _ = 0; _ < h.length; _++) {
            const x = [];
            for (let A = 0; A < h[_].length; A++) {
              const E = Ua(h[_][A], u);
              ia(l, E), x.push(E);
            }
            p.push(x);
          }
          return p;
        }
        function Hl(h, l, u) {
          const p = [];
          for (let _ = 0; _ < h.length; _++) {
            const x = na(h[_], l, u);
            p.push(x);
          }
          return p;
        }
        function zs(h, l, u, p) {
          if (h[0] < u[0] || h[0] > u[2]) {
            const _ = 0.5 * p;
            let x = h[0] - u[0] > _ ? -p : u[0] - h[0] > _ ? p : 0;
            x === 0 && (x = h[0] - u[2] > _ ? -p : u[2] - h[0] > _ ? p : 0), h[0] += x;
          }
          ia(l, h);
        }
        function js(h, l, u, p) {
          const _ = Math.pow(2, p.z) * Oi, x = [p.x * Oi, p.y * Oi], A = [];
          for (const E of h) for (const M of E) {
            const O = [M.x + x[0], M.y + x[1]];
            zs(O, l, u, _), A.push(O);
          }
          return A;
        }
        function _l(h, l, u, p) {
          const _ = Math.pow(2, p.z) * Oi, x = [p.x * Oi, p.y * Oi], A = [];
          for (const M of h) {
            const O = [];
            for (const N of M) {
              const V = [N.x + x[0], N.y + x[1]];
              ia(l, V), O.push(V);
            }
            A.push(O);
          }
          if (l[2] - l[0] <= _ / 2) {
            (E = l)[0] = E[1] = 1 / 0, E[2] = E[3] = -1 / 0;
            for (const M of A) for (const O of M) zs(O, l, u, _);
          }
          var E;
          return A;
        }
        class Wn {
          constructor(l, u) {
            this.type = zr, this.geojson = l, this.geometries = u;
          }
          static parse(l, u) {
            if (l.length !== 2) return u.error(`'within' expression requires exactly one argument, but found ${l.length - 1} instead.`);
            if (pa(l[1])) {
              const p = l[1];
              if (p.type === "FeatureCollection") {
                const _ = [];
                for (const x of p.features) {
                  const { type: A, coordinates: E } = x.geometry;
                  A === "Polygon" && _.push(E), A === "MultiPolygon" && _.push(...E);
                }
                if (_.length) return new Wn(p, { type: "MultiPolygon", coordinates: _ });
              } else if (p.type === "Feature") {
                const _ = p.geometry.type;
                if (_ === "Polygon" || _ === "MultiPolygon") return new Wn(p, p.geometry);
              } else if (p.type === "Polygon" || p.type === "MultiPolygon") return new Wn(p, p);
            }
            return u.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(l) {
            if (l.geometry() != null && l.canonicalID() != null) {
              if (l.geometryType() === "Point") return function(u, p) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], A = u.canonicalID();
                if (p.type === "Polygon") {
                  const E = na(p.coordinates, x, A), M = js(u.geometry(), _, x, A);
                  if (!za(_, x)) return !1;
                  for (const O of M) if (!ja(O, E)) return !1;
                }
                if (p.type === "MultiPolygon") {
                  const E = Hl(p.coordinates, x, A), M = js(u.geometry(), _, x, A);
                  if (!za(_, x)) return !1;
                  for (const O of M) if (!ts(O, E)) return !1;
                }
                return !0;
              }(l, this.geometries);
              if (l.geometryType() === "LineString") return function(u, p) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], A = u.canonicalID();
                if (p.type === "Polygon") {
                  const E = na(p.coordinates, x, A), M = _l(u.geometry(), _, x, A);
                  if (!za(_, x)) return !1;
                  for (const O of M) if (!mo(O, E)) return !1;
                }
                if (p.type === "MultiPolygon") {
                  const E = Hl(p.coordinates, x, A), M = _l(u.geometry(), _, x, A);
                  if (!za(_, x)) return !1;
                  for (const O of M) if (!Fc(O, E)) return !1;
                }
                return !0;
              }(l, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Va = class {
          constructor(h = [], l = (u, p) => u < p ? -1 : u > p ? 1 : 0) {
            if (this.data = h, this.length = this.data.length, this.compare = l, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
          }
          push(h) {
            this.data.push(h), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const h = this.data[0], l = this.data.pop();
            return --this.length > 0 && (this.data[0] = l, this._down(0)), h;
          }
          peek() {
            return this.data[0];
          }
          _up(h) {
            const { data: l, compare: u } = this, p = l[h];
            for (; h > 0; ) {
              const _ = h - 1 >> 1, x = l[_];
              if (u(p, x) >= 0) break;
              l[h] = x, h = _;
            }
            l[h] = p;
          }
          _down(h) {
            const { data: l, compare: u } = this, p = this.length >> 1, _ = l[h];
            for (; h < p; ) {
              let x = 1 + (h << 1);
              const A = x + 1;
              if (A < this.length && u(l[A], l[x]) < 0 && (x = A), u(l[x], _) >= 0) break;
              l[h] = l[x], h = x;
            }
            l[h] = _;
          }
        };
        function Uc(h, l, u = 0, p = h.length - 1, _ = kn) {
          for (; p > u; ) {
            if (p - u > 600) {
              const M = p - u + 1, O = l - u + 1, N = Math.log(M), V = 0.5 * Math.exp(2 * N / 3), Y = 0.5 * Math.sqrt(N * V * (M - V) / M) * (O - M / 2 < 0 ? -1 : 1);
              Uc(h, l, Math.max(u, Math.floor(l - O * V / M + Y)), Math.min(p, Math.floor(l + (M - O) * V / M + Y)), _);
            }
            const x = h[l];
            let A = u, E = p;
            for (Io(h, u, l), _(h[p], x) > 0 && Io(h, u, p); A < E; ) {
              for (Io(h, A, E), A++, E--; _(h[A], x) < 0; ) A++;
              for (; _(h[E], x) > 0; ) E--;
            }
            _(h[u], x) === 0 ? Io(h, u, E) : (E++, Io(h, E, p)), E <= l && (u = E + 1), l <= E && (p = E - 1);
          }
        }
        function Io(h, l, u) {
          const p = h[l];
          h[l] = h[u], h[u] = p;
        }
        function kn(h, l) {
          return h < l ? -1 : h > l ? 1 : 0;
        }
        function yl(h, l) {
          if (h.length <= 1) return [h];
          const u = [];
          let p, _;
          for (const x of h) {
            const A = ma(x);
            A !== 0 && (x.area = Math.abs(A), _ === void 0 && (_ = A < 0), _ === A < 0 ? (p && u.push(p), p = [x]) : p.push(x));
          }
          if (p && u.push(p), l > 1) for (let x = 0; x < u.length; x++) u[x].length <= l || (Uc(u[x], l, 1, u[x].length - 1, sa), u[x] = u[x].slice(0, l));
          return u;
        }
        function sa(h, l) {
          return l.area - h.area;
        }
        function ma(h) {
          let l = 0;
          for (let u, p, _ = 0, x = h.length, A = x - 1; _ < x; A = _++) u = h[_], p = h[A], l += (p.x - u.x) * (u.y + p.y);
          return l;
        }
        const ql = 1 / 298.257223563, Wl = ql * (2 - ql), bl = Math.PI / 180;
        class vl {
          constructor(l) {
            const u = 6378.137 * bl * 1e3, p = Math.cos(l * bl), _ = 1 / (1 - Wl * (1 - p * p)), x = Math.sqrt(_);
            this.kx = u * x * p, this.ky = u * x * _ * (1 - Wl);
          }
          distance(l, u) {
            const p = this.wrap(l[0] - u[0]) * this.kx, _ = (l[1] - u[1]) * this.ky;
            return Math.sqrt(p * p + _ * _);
          }
          pointOnLine(l, u) {
            let p, _, x, A, E = 1 / 0;
            for (let M = 0; M < l.length - 1; M++) {
              let O = l[M][0], N = l[M][1], V = this.wrap(l[M + 1][0] - O) * this.kx, Y = (l[M + 1][1] - N) * this.ky, ee = 0;
              V === 0 && Y === 0 || (ee = (this.wrap(u[0] - O) * this.kx * V + (u[1] - N) * this.ky * Y) / (V * V + Y * Y), ee > 1 ? (O = l[M + 1][0], N = l[M + 1][1]) : ee > 0 && (O += V / this.kx * ee, N += Y / this.ky * ee)), V = this.wrap(u[0] - O) * this.kx, Y = (u[1] - N) * this.ky;
              const ie = V * V + Y * Y;
              ie < E && (E = ie, p = O, _ = N, x = M, A = ee);
            }
            return { point: [p, _], index: x, t: Math.max(0, Math.min(1, A)) };
          }
          wrap(l) {
            for (; l < -180; ) l += 360;
            for (; l > 180; ) l -= 360;
            return l;
          }
        }
        function xl(h, l) {
          return l[0] - h[0];
        }
        function _a(h) {
          return h[1] - h[0] + 1;
        }
        function rs(h, l) {
          return h[1] >= h[0] && h[1] < l;
        }
        function Xl(h, l) {
          if (h[0] > h[1]) return [null, null];
          const u = _a(h);
          if (l) {
            if (u === 2) return [h, null];
            const _ = Math.floor(u / 2);
            return [[h[0], h[0] + _], [h[0] + _, h[1]]];
          }
          if (u === 1) return [h, null];
          const p = Math.floor(u / 2) - 1;
          return [[h[0], h[0] + p], [h[0] + p + 1, h[1]]];
        }
        function Vs(h, l) {
          if (!rs(l, h.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let p = l[0]; p <= l[1]; ++p) ia(u, h[p]);
          return u;
        }
        function Po(h) {
          const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const u of h) for (const p of u) ia(l, p);
          return l;
        }
        function Wi(h) {
          return h[0] !== -1 / 0 && h[1] !== -1 / 0 && h[2] !== 1 / 0 && h[3] !== 1 / 0;
        }
        function Lr(h, l, u) {
          if (!Wi(h) || !Wi(l)) return NaN;
          let p = 0, _ = 0;
          return h[2] < l[0] && (p = l[0] - h[2]), h[0] > l[2] && (p = h[0] - l[2]), h[1] > l[3] && (_ = h[1] - l[3]), h[3] < l[1] && (_ = l[1] - h[3]), u.distance([0, 0], [p, _]);
        }
        function Xi(h, l, u) {
          const p = u.pointOnLine(l, h);
          return u.distance(h, p.point);
        }
        function xn(h, l, u, p, _) {
          const x = Math.min(Xi(h, [u, p], _), Xi(l, [u, p], _)), A = Math.min(Xi(u, [h, l], _), Xi(p, [h, l], _));
          return Math.min(x, A);
        }
        function Ga(h, l, u, p, _) {
          if (!rs(l, h.length) || !rs(p, u.length)) return 1 / 0;
          let x = 1 / 0;
          for (let A = l[0]; A < l[1]; ++A) {
            const E = h[A], M = h[A + 1];
            for (let O = p[0]; O < p[1]; ++O) {
              const N = u[O], V = u[O + 1];
              if (Gl(E, M, N, V)) return 0;
              x = Math.min(x, xn(E, M, N, V, _));
            }
          }
          return x;
        }
        function zc(h, l, u, p, _) {
          if (!rs(l, h.length) || !rs(p, u.length)) return NaN;
          let x = 1 / 0;
          for (let A = l[0]; A <= l[1]; ++A) for (let E = p[0]; E <= p[1]; ++E) if (x = Math.min(x, _.distance(h[A], u[E])), x === 0) return x;
          return x;
        }
        function ya(h, l, u) {
          if (ja(h, l, !0)) return 0;
          let p = 1 / 0;
          for (const _ of l) {
            const x = _[0], A = _[_.length - 1];
            if (x !== A && (p = Math.min(p, Xi(h, [A, x], u)), p === 0)) return p;
            const E = u.pointOnLine(_, h);
            if (p = Math.min(p, u.distance(h, E.point)), p === 0) return p;
          }
          return p;
        }
        function Iu(h, l, u, p) {
          if (!rs(l, h.length)) return NaN;
          for (let x = l[0]; x <= l[1]; ++x) if (ja(h[x], u, !0)) return 0;
          let _ = 1 / 0;
          for (let x = l[0]; x < l[1]; ++x) {
            const A = h[x], E = h[x + 1];
            for (const M of u) for (let O = 0, N = M.length, V = N - 1; O < N; V = O++) {
              const Y = M[V], ee = M[O];
              if (Gl(A, E, Y, ee)) return 0;
              _ = Math.min(_, xn(A, E, Y, ee, p));
            }
          }
          return _;
        }
        function Kh(h, l) {
          for (const u of h) for (const p of u) if (ja(p, l, !0)) return !0;
          return !1;
        }
        function dd(h, l, u, p = 1 / 0) {
          const _ = Po(h), x = Po(l);
          if (p !== 1 / 0 && Lr(_, x, u) >= p) return p;
          if (za(_, x)) {
            if (Kh(h, l)) return 0;
          } else if (Kh(l, h)) return 0;
          let A = 1 / 0;
          for (const E of h) for (let M = 0, O = E.length, N = O - 1; M < O; N = M++) {
            const V = E[N], Y = E[M];
            for (const ee of l) for (let ie = 0, ue = ee.length, ve = ue - 1; ie < ue; ve = ie++) {
              const Re = ee[ve], it = ee[ie];
              if (Gl(V, Y, Re, it)) return 0;
              A = Math.min(A, xn(V, Y, Re, it, u));
            }
          }
          return A;
        }
        function Qh(h, l, u, p, _, x) {
          if (!x) return;
          const A = Lr(Vs(p, x), _, u);
          A < l && h.push([A, x, [0, 0]]);
        }
        function Pu(h, l, u, p, _, x, A) {
          if (!x || !A) return;
          const E = Lr(Vs(p, x), Vs(_, A), u);
          E < l && h.push([E, x, A]);
        }
        function Mu(h, l, u, p, _ = 1 / 0) {
          let x = Math.min(p.distance(h[0], u[0][0]), _);
          if (x === 0) return x;
          const A = new Va([[0, [0, h.length - 1], [0, 0]]], xl), E = Po(u);
          for (; A.length > 0; ) {
            const M = A.pop();
            if (M[0] >= x) continue;
            const O = M[1], N = l ? 50 : 100;
            if (_a(O) <= N) {
              if (!rs(O, h.length)) return NaN;
              if (l) {
                const V = Iu(h, O, u, p);
                if (isNaN(V) || V === 0) return V;
                x = Math.min(x, V);
              } else for (let V = O[0]; V <= O[1]; ++V) {
                const Y = ya(h[V], u, p);
                if (x = Math.min(x, Y), x === 0) return 0;
              }
            } else {
              const V = Xl(O, l);
              Qh(A, x, p, h, E, V[0]), Qh(A, x, p, h, E, V[1]);
            }
          }
          return x;
        }
        function Ru(h, l, u, p, _, x = 1 / 0) {
          let A = Math.min(x, _.distance(h[0], u[0]));
          if (A === 0) return A;
          const E = new Va([[0, [0, h.length - 1], [0, u.length - 1]]], xl);
          for (; E.length > 0; ) {
            const M = E.pop();
            if (M[0] >= A) continue;
            const O = M[1], N = M[2], V = l ? 50 : 100, Y = p ? 50 : 100;
            if (_a(O) <= V && _a(N) <= Y) {
              if (!rs(O, h.length) && rs(N, u.length)) return NaN;
              let ee;
              if (l && p) ee = Ga(h, O, u, N, _), A = Math.min(A, ee);
              else if (l && !p) {
                const ie = h.slice(O[0], O[1] + 1);
                for (let ue = N[0]; ue <= N[1]; ++ue) if (ee = Xi(u[ue], ie, _), A = Math.min(A, ee), A === 0) return A;
              } else if (!l && p) {
                const ie = u.slice(N[0], N[1] + 1);
                for (let ue = O[0]; ue <= O[1]; ++ue) if (ee = Xi(h[ue], ie, _), A = Math.min(A, ee), A === 0) return A;
              } else ee = zc(h, O, u, N, _), A = Math.min(A, ee);
            } else {
              const ee = Xl(O, l), ie = Xl(N, p);
              Pu(E, A, _, h, u, ee[0], ie[0]), Pu(E, A, _, h, u, ee[0], ie[1]), Pu(E, A, _, h, u, ee[1], ie[0]), Pu(E, A, _, h, u, ee[1], ie[1]);
            }
          }
          return A;
        }
        function hh(h) {
          return h.type === "MultiPolygon" ? h.coordinates.map((l) => ({ type: "Polygon", coordinates: l })) : h.type === "MultiLineString" ? h.coordinates.map((l) => ({ type: "LineString", coordinates: l })) : h.type === "MultiPoint" ? h.coordinates.map((l) => ({ type: "Point", coordinates: l })) : [h];
        }
        class wl {
          constructor(l, u) {
            this.type = Xt, this.geojson = l, this.geometries = u;
          }
          static parse(l, u) {
            if (l.length !== 2) return u.error(`'distance' expression requires exactly one argument, but found ${l.length - 1} instead.`);
            if (pa(l[1])) {
              const p = l[1];
              if (p.type === "FeatureCollection") return new wl(p, p.features.map((_) => hh(_.geometry)).flat());
              if (p.type === "Feature") return new wl(p, hh(p.geometry));
              if ("type" in p && "coordinates" in p) return new wl(p, hh(p));
            }
            return u.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(l) {
            if (l.geometry() != null && l.canonicalID() != null) {
              if (l.geometryType() === "Point") return function(u, p) {
                const _ = u.geometry(), x = _.flat().map((M) => Co([M.x, M.y], u.canonical));
                if (_.length === 0) return NaN;
                const A = new vl(x[0][1]);
                let E = 1 / 0;
                for (const M of p) {
                  switch (M.type) {
                    case "Point":
                      E = Math.min(E, Ru(x, !1, [M.coordinates], !1, A, E));
                      break;
                    case "LineString":
                      E = Math.min(E, Ru(x, !1, M.coordinates, !0, A, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, Mu(x, !1, M.coordinates, A, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              }(l, this.geometries);
              if (l.geometryType() === "LineString") return function(u, p) {
                const _ = u.geometry(), x = _.flat().map((M) => Co([M.x, M.y], u.canonical));
                if (_.length === 0) return NaN;
                const A = new vl(x[0][1]);
                let E = 1 / 0;
                for (const M of p) {
                  switch (M.type) {
                    case "Point":
                      E = Math.min(E, Ru(x, !0, [M.coordinates], !1, A, E));
                      break;
                    case "LineString":
                      E = Math.min(E, Ru(x, !0, M.coordinates, !0, A, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, Mu(x, !0, M.coordinates, A, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              }(l, this.geometries);
              if (l.geometryType() === "Polygon") return function(u, p) {
                const _ = u.geometry();
                if (_.length === 0 || _[0].length === 0) return NaN;
                const x = yl(_, 0).map((M) => M.map((O) => O.map((N) => Co([N.x, N.y], u.canonical)))), A = new vl(x[0][0][0][1]);
                let E = 1 / 0;
                for (const M of p) for (const O of x) {
                  switch (M.type) {
                    case "Point":
                      E = Math.min(E, Mu([M.coordinates], !1, O, A, E));
                      break;
                    case "LineString":
                      E = Math.min(E, Mu(M.coordinates, !0, O, A, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, dd(O, M.coordinates, A, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              }(l, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class jc {
          constructor(l) {
            this.type = Nr, this.key = l;
          }
          static parse(l, u) {
            if (l.length !== 2) return u.error(`Expected 1 argument, but found ${l.length - 1} instead.`);
            const p = l[1];
            return p == null ? u.error("Global state property must be defined.") : typeof p != "string" ? u.error(`Global state property must be string, but found ${typeof l[1]} instead.`) : new jc(p);
          }
          evaluate(l) {
            var u;
            const p = (u = l.globals) === null || u === void 0 ? void 0 : u.globalState;
            return p && Object.keys(p).length !== 0 ? ul(p, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const Zl = { "==": vn, "!=": Un, ">": Fa, "<": qn, ">=": uh, "<=": Dc, array: Or, at: Na, boolean: Or, case: F, coalesce: Fi, collator: Eo, format: gl, image: ml, in: pl, "index-of": Ts, interpolate: Ir, "interpolate-hcl": Ir, "interpolate-lab": Ir, length: ga, let: ta, literal: to, match: po, number: Or, "number-format": go, object: Or, slice: se, step: Ye, string: Or, "to-boolean": Qr, "to-color": Qr, "to-number": Qr, "to-string": Qr, var: ra, within: Wn, distance: wl, "global-state": jc };
        class _o {
          constructor(l, u, p, _) {
            this.name = l, this.type = u, this._evaluate = p, this.args = _;
          }
          evaluate(l) {
            return this._evaluate(l, this.args);
          }
          eachChild(l) {
            this.args.forEach(l);
          }
          outputDefined() {
            return !1;
          }
          static parse(l, u) {
            const p = l[0], _ = _o.definitions[p];
            if (!_) return u.error(`Unknown expression "${p}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const x = Array.isArray(_) ? _[0] : _.type, A = Array.isArray(_) ? [[_[1], _[2]]] : _.overloads, E = A.filter(([O]) => !Array.isArray(O) || O.length === l.length - 1);
            let M = null;
            for (const [O, N] of E) {
              M = new ea(u.registry, Lu, u.path, null, u.scope);
              const V = [];
              let Y = !1;
              for (let ee = 1; ee < l.length; ee++) {
                const ie = l[ee], ue = Array.isArray(O) ? O[ee - 1] : O.type, ve = M.parse(ie, 1 + V.length, ue);
                if (!ve) {
                  Y = !0;
                  break;
                }
                V.push(ve);
              }
              if (!Y) if (Array.isArray(O) && O.length !== V.length) M.error(`Expected ${O.length} arguments, but found ${V.length} instead.`);
              else {
                for (let ee = 0; ee < V.length; ee++) {
                  const ie = Array.isArray(O) ? O[ee] : O.type, ue = V[ee];
                  M.concat(ee + 1).checkSubtype(ie, ue.type);
                }
                if (M.errors.length === 0) return new _o(p, x, N, V);
              }
            }
            if (E.length === 1) u.errors.push(...M.errors);
            else {
              const O = (E.length ? E : A).map(([V]) => {
                return Y = V, Array.isArray(Y) ? `(${Y.map(ti).join(", ")})` : `(${ti(Y.type)}...)`;
                var Y;
              }).join(" | "), N = [];
              for (let V = 1; V < l.length; V++) {
                const Y = u.parse(l[V], 1 + N.length);
                if (!Y) return null;
                N.push(ti(Y.type));
              }
              u.error(`Expected arguments of type ${O}, but found (${N.join(", ")}) instead.`);
            }
            return null;
          }
          static register(l, u) {
            _o.definitions = u;
            for (const p in u) l[p] = _o;
          }
        }
        function ef(h, [l, u, p, _]) {
          l = l.evaluate(h), u = u.evaluate(h), p = p.evaluate(h);
          const x = _ ? _.evaluate(h) : 1, A = fl(l, u, p, x);
          if (A) throw new ji(A);
          return new jr(l / 255, u / 255, p / 255, x, !1);
        }
        function Vc(h, l) {
          return h in l;
        }
        function fh(h, l) {
          const u = l[h];
          return u === void 0 ? null : u;
        }
        function Al(h) {
          return { type: h };
        }
        function Lu(h) {
          if (h instanceof ra) return Lu(h.boundExpression);
          if (h instanceof _o && h.name === "error" || h instanceof Eo || h instanceof Wn || h instanceof wl || h instanceof jc) return !1;
          const l = h instanceof Qr || h instanceof Or;
          let u = !0;
          return h.eachChild((p) => {
            u = l ? u && Lu(p) : u && p instanceof to;
          }), !!u && Bu(h) && ku(h, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Bu(h) {
          if (h instanceof _o && (h.name === "get" && h.args.length === 1 || h.name === "feature-state" || h.name === "has" && h.args.length === 1 || h.name === "properties" || h.name === "geometry-type" || h.name === "id" || /^filter-/.test(h.name)) || h instanceof Wn || h instanceof wl) return !1;
          let l = !0;
          return h.eachChild((u) => {
            l && !Bu(u) && (l = !1);
          }), l;
        }
        function Gc(h) {
          if (h instanceof _o && h.name === "feature-state") return !1;
          let l = !0;
          return h.eachChild((u) => {
            l && !Gc(u) && (l = !1);
          }), l;
        }
        function ku(h, l) {
          if (h instanceof _o && l.indexOf(h.name) >= 0) return !1;
          let u = !0;
          return h.eachChild((p) => {
            u && !ku(p, l) && (u = !1);
          }), u;
        }
        function tf(h) {
          return { result: "success", value: h };
        }
        function Yl(h) {
          return { result: "error", value: h };
        }
        function Tl(h) {
          return h["property-type"] === "data-driven" || h["property-type"] === "cross-faded-data-driven";
        }
        function Ou(h) {
          return !!h.expression && h.expression.parameters.indexOf("zoom") > -1;
        }
        function Gs(h) {
          return !!h.expression && h.expression.interpolated;
        }
        function $r(h) {
          return h instanceof Number ? "number" : h instanceof String ? "string" : h instanceof Boolean ? "boolean" : Array.isArray(h) ? "array" : h === null ? "null" : typeof h;
        }
        function $a(h) {
          return typeof h == "object" && h !== null && !Array.isArray(h) && ki(h) === Qn;
        }
        function dh(h) {
          return h;
        }
        function rf(h, l) {
          const u = h.stops && typeof h.stops[0][0] == "object", p = u || !(u || h.property !== void 0), _ = h.type || (Gs(l) ? "exponential" : "interval"), x = function(N) {
            switch (N.type) {
              case "color":
                return jr.parse;
              case "padding":
                return Fn.parse;
              case "numberArray":
                return es.parse;
              case "colorArray":
                return Bn.parse;
              default:
                return null;
            }
          }(l);
          if (x && ((h = pi({}, h)).stops && (h.stops = h.stops.map((N) => [N[0], x(N[1])])), h.default = x(h.default ? h.default : l.default)), h.colorSpace && (A = h.colorSpace) !== "rgb" && A !== "hcl" && A !== "lab") throw new Error(`Unknown color space: "${h.colorSpace}"`);
          var A;
          const E = function(N) {
            switch (N) {
              case "exponential":
                return sf;
              case "interval":
                return nf;
              case "categorical":
                return Du;
              case "identity":
                return $c;
              default:
                throw new Error(`Unknown function type "${N}"`);
            }
          }(_);
          let M, O;
          if (_ === "categorical") {
            M = /* @__PURE__ */ Object.create(null);
            for (const N of h.stops) M[N[0]] = N[1];
            O = typeof h.stops[0][0];
          }
          if (u) {
            const N = {}, V = [];
            for (let ie = 0; ie < h.stops.length; ie++) {
              const ue = h.stops[ie], ve = ue[0].zoom;
              N[ve] === void 0 && (N[ve] = { zoom: ve, type: h.type, property: h.property, default: h.default, stops: [] }, V.push(ve)), N[ve].stops.push([ue[0].value, ue[1]]);
            }
            const Y = [];
            for (const ie of V) Y.push([N[ie].zoom, rf(N[ie], l)]);
            const ee = { name: "linear" };
            return { kind: "composite", interpolationType: ee, interpolationFactor: Ir.interpolationFactor.bind(void 0, ee), zoomStops: Y.map((ie) => ie[0]), evaluate: ({ zoom: ie }, ue) => sf({ stops: Y, base: h.base }, l, ie).evaluate(ie, ue) };
          }
          if (p) {
            const N = _ === "exponential" ? { name: "exponential", base: h.base !== void 0 ? h.base : 1 } : null;
            return { kind: "camera", interpolationType: N, interpolationFactor: Ir.interpolationFactor.bind(void 0, N), zoomStops: h.stops.map((V) => V[0]), evaluate: ({ zoom: V }) => E(h, l, V, M, O) };
          }
          return { kind: "source", evaluate(N, V) {
            const Y = V && V.properties ? V.properties[h.property] : void 0;
            return Y === void 0 ? Sl(h.default, l.default) : E(h, l, Y, M, O);
          } };
        }
        function Sl(h, l, u) {
          return h !== void 0 ? h : l !== void 0 ? l : u !== void 0 ? u : void 0;
        }
        function Du(h, l, u, p, _) {
          return Sl(typeof u === _ ? p[u] : void 0, h.default, l.default);
        }
        function nf(h, l, u) {
          if ($r(u) !== "number") return Sl(h.default, l.default);
          const p = h.stops.length;
          if (p === 1 || u <= h.stops[0][0]) return h.stops[0][1];
          if (u >= h.stops[p - 1][0]) return h.stops[p - 1][1];
          const _ = Ie(h.stops.map((x) => x[0]), u);
          return h.stops[_][1];
        }
        function sf(h, l, u) {
          const p = h.base !== void 0 ? h.base : 1;
          if ($r(u) !== "number") return Sl(h.default, l.default);
          const _ = h.stops.length;
          if (_ === 1 || u <= h.stops[0][0]) return h.stops[0][1];
          if (u >= h.stops[_ - 1][0]) return h.stops[_ - 1][1];
          const x = Ie(h.stops.map((N) => N[0]), u), A = function(N, V, Y, ee) {
            const ie = ee - Y, ue = N - Y;
            return ie === 0 ? 0 : V === 1 ? ue / ie : (Math.pow(V, ue) - 1) / (Math.pow(V, ie) - 1);
          }(u, p, h.stops[x][0], h.stops[x + 1][0]), E = h.stops[x][1], M = h.stops[x + 1][1], O = ri[l.type] || dh;
          return typeof E.evaluate == "function" ? { evaluate(...N) {
            const V = E.evaluate.apply(void 0, N), Y = M.evaluate.apply(void 0, N);
            if (V !== void 0 && Y !== void 0) return O(V, Y, A, h.colorSpace);
          } } : O(E, M, A, h.colorSpace);
        }
        function $c(h, l, u) {
          switch (l.type) {
            case "color":
              u = jr.parse(u);
              break;
            case "formatted":
              u = Er.fromString(u.toString());
              break;
            case "resolvedImage":
              u = Hn.fromString(u.toString());
              break;
            case "padding":
              u = Fn.parse(u);
              break;
            case "colorArray":
              u = Bn.parse(u);
              break;
            case "numberArray":
              u = es.parse(u);
              break;
            default:
              $r(u) === l.type || l.type === "enum" && l.values[u] || (u = void 0);
          }
          return Sl(u, h.default, l.default);
        }
        _o.register(Zl, { error: [{ kind: "error" }, [Dr], (h, [l]) => {
          throw new ji(l.evaluate(h));
        }], typeof: [Dr, [Nr], (h, [l]) => ti(ki(l.evaluate(h)))], "to-rgba": [Qi(Xt, 4), [bn], (h, [l]) => {
          const [u, p, _, x] = l.evaluate(h).rgb;
          return [255 * u, 255 * p, 255 * _, x];
        }], rgb: [bn, [Xt, Xt, Xt], ef], rgba: [bn, [Xt, Xt, Xt, Xt], ef], has: { type: zr, overloads: [[[Dr], (h, [l]) => Vc(l.evaluate(h), h.properties())], [[Dr, Qn], (h, [l, u]) => Vc(l.evaluate(h), u.evaluate(h))]] }, get: { type: Nr, overloads: [[[Dr], (h, [l]) => fh(l.evaluate(h), h.properties())], [[Dr, Qn], (h, [l, u]) => fh(l.evaluate(h), u.evaluate(h))]] }, "feature-state": [Nr, [Dr], (h, [l]) => fh(l.evaluate(h), h.featureState || {})], properties: [Qn, [], (h) => h.properties()], "geometry-type": [Dr, [], (h) => h.geometryType()], id: [Nr, [], (h) => h.id()], zoom: [Xt, [], (h) => h.globals.zoom], "heatmap-density": [Xt, [], (h) => h.globals.heatmapDensity || 0], elevation: [Xt, [], (h) => h.globals.elevation || 0], "line-progress": [Xt, [], (h) => h.globals.lineProgress || 0], accumulated: [Nr, [], (h) => h.globals.accumulated === void 0 ? null : h.globals.accumulated], "+": [Xt, Al(Xt), (h, l) => {
          let u = 0;
          for (const p of l) u += p.evaluate(h);
          return u;
        }], "*": [Xt, Al(Xt), (h, l) => {
          let u = 1;
          for (const p of l) u *= p.evaluate(h);
          return u;
        }], "-": { type: Xt, overloads: [[[Xt, Xt], (h, [l, u]) => l.evaluate(h) - u.evaluate(h)], [[Xt], (h, [l]) => -l.evaluate(h)]] }, "/": [Xt, [Xt, Xt], (h, [l, u]) => l.evaluate(h) / u.evaluate(h)], "%": [Xt, [Xt, Xt], (h, [l, u]) => l.evaluate(h) % u.evaluate(h)], ln2: [Xt, [], () => Math.LN2], pi: [Xt, [], () => Math.PI], e: [Xt, [], () => Math.E], "^": [Xt, [Xt, Xt], (h, [l, u]) => Math.pow(l.evaluate(h), u.evaluate(h))], sqrt: [Xt, [Xt], (h, [l]) => Math.sqrt(l.evaluate(h))], log10: [Xt, [Xt], (h, [l]) => Math.log(l.evaluate(h)) / Math.LN10], ln: [Xt, [Xt], (h, [l]) => Math.log(l.evaluate(h))], log2: [Xt, [Xt], (h, [l]) => Math.log(l.evaluate(h)) / Math.LN2], sin: [Xt, [Xt], (h, [l]) => Math.sin(l.evaluate(h))], cos: [Xt, [Xt], (h, [l]) => Math.cos(l.evaluate(h))], tan: [Xt, [Xt], (h, [l]) => Math.tan(l.evaluate(h))], asin: [Xt, [Xt], (h, [l]) => Math.asin(l.evaluate(h))], acos: [Xt, [Xt], (h, [l]) => Math.acos(l.evaluate(h))], atan: [Xt, [Xt], (h, [l]) => Math.atan(l.evaluate(h))], min: [Xt, Al(Xt), (h, l) => Math.min(...l.map((u) => u.evaluate(h)))], max: [Xt, Al(Xt), (h, l) => Math.max(...l.map((u) => u.evaluate(h)))], abs: [Xt, [Xt], (h, [l]) => Math.abs(l.evaluate(h))], round: [Xt, [Xt], (h, [l]) => {
          const u = l.evaluate(h);
          return u < 0 ? -Math.round(-u) : Math.round(u);
        }], floor: [Xt, [Xt], (h, [l]) => Math.floor(l.evaluate(h))], ceil: [Xt, [Xt], (h, [l]) => Math.ceil(l.evaluate(h))], "filter-==": [zr, [Dr, Nr], (h, [l, u]) => h.properties()[l.value] === u.value], "filter-id-==": [zr, [Nr], (h, [l]) => h.id() === l.value], "filter-type-==": [zr, [Dr], (h, [l]) => h.geometryType() === l.value], "filter-<": [zr, [Dr, Nr], (h, [l, u]) => {
          const p = h.properties()[l.value], _ = u.value;
          return typeof p == typeof _ && p < _;
        }], "filter-id-<": [zr, [Nr], (h, [l]) => {
          const u = h.id(), p = l.value;
          return typeof u == typeof p && u < p;
        }], "filter->": [zr, [Dr, Nr], (h, [l, u]) => {
          const p = h.properties()[l.value], _ = u.value;
          return typeof p == typeof _ && p > _;
        }], "filter-id->": [zr, [Nr], (h, [l]) => {
          const u = h.id(), p = l.value;
          return typeof u == typeof p && u > p;
        }], "filter-<=": [zr, [Dr, Nr], (h, [l, u]) => {
          const p = h.properties()[l.value], _ = u.value;
          return typeof p == typeof _ && p <= _;
        }], "filter-id-<=": [zr, [Nr], (h, [l]) => {
          const u = h.id(), p = l.value;
          return typeof u == typeof p && u <= p;
        }], "filter->=": [zr, [Dr, Nr], (h, [l, u]) => {
          const p = h.properties()[l.value], _ = u.value;
          return typeof p == typeof _ && p >= _;
        }], "filter-id->=": [zr, [Nr], (h, [l]) => {
          const u = h.id(), p = l.value;
          return typeof u == typeof p && u >= p;
        }], "filter-has": [zr, [Nr], (h, [l]) => l.value in h.properties()], "filter-has-id": [zr, [], (h) => h.id() !== null && h.id() !== void 0], "filter-type-in": [zr, [Qi(Dr)], (h, [l]) => l.value.indexOf(h.geometryType()) >= 0], "filter-id-in": [zr, [Qi(Nr)], (h, [l]) => l.value.indexOf(h.id()) >= 0], "filter-in-small": [zr, [Dr, Qi(Nr)], (h, [l, u]) => u.value.indexOf(h.properties()[l.value]) >= 0], "filter-in-large": [zr, [Dr, Qi(Nr)], (h, [l, u]) => function(p, _, x, A) {
          for (; x <= A; ) {
            const E = x + A >> 1;
            if (_[E] === p) return !0;
            _[E] > p ? A = E - 1 : x = E + 1;
          }
          return !1;
        }(h.properties()[l.value], u.value, 0, u.value.length - 1)], all: { type: zr, overloads: [[[zr, zr], (h, [l, u]) => l.evaluate(h) && u.evaluate(h)], [Al(zr), (h, l) => {
          for (const u of l) if (!u.evaluate(h)) return !1;
          return !0;
        }]] }, any: { type: zr, overloads: [[[zr, zr], (h, [l, u]) => l.evaluate(h) || u.evaluate(h)], [Al(zr), (h, l) => {
          for (const u of l) if (u.evaluate(h)) return !0;
          return !1;
        }]] }, "!": [zr, [zr], (h, [l]) => !l.evaluate(h)], "is-supported-script": [zr, [Dr], (h, [l]) => {
          const u = h.globals && h.globals.isSupportedScript;
          return !u || u(l.evaluate(h));
        }], upcase: [Dr, [Dr], (h, [l]) => l.evaluate(h).toUpperCase()], downcase: [Dr, [Dr], (h, [l]) => l.evaluate(h).toLowerCase()], concat: [Dr, Al(Nr), (h, l) => l.map((u) => Si(u.evaluate(h))).join("")], "resolved-locale": [Dr, [wo], (h, [l]) => l.evaluate(h).resolvedLocale()] });
        class Hc {
          constructor(l, u, p) {
            this.expression = l, this._warningHistory = {}, this._evaluator = new ro(), this._defaultValue = u ? function(_) {
              if (_.type === "color" && $a(_.default)) return new jr(0, 0, 0, 0);
              switch (_.type) {
                case "color":
                  return jr.parse(_.default) || null;
                case "padding":
                  return Fn.parse(_.default) || null;
                case "numberArray":
                  return es.parse(_.default) || null;
                case "colorArray":
                  return Bn.parse(_.default) || null;
                case "variableAnchorOffsetCollection":
                  return on.parse(_.default) || null;
                case "projectionDefinition":
                  return As.parse(_.default) || null;
                default:
                  return _.default === void 0 ? null : _.default;
              }
            }(u) : null, this._enumValues = u && u.type === "enum" ? u.values : null, this._globalState = p;
          }
          evaluateWithoutErrorHandling(l, u, p, _, x, A) {
            return this._globalState && (l = Wc(l, this._globalState)), this._evaluator.globals = l, this._evaluator.feature = u, this._evaluator.featureState = p, this._evaluator.canonical = _, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = A, this.expression.evaluate(this._evaluator);
          }
          evaluate(l, u, p, _, x, A) {
            this._globalState && (l = Wc(l, this._globalState)), this._evaluator.globals = l, this._evaluator.feature = u || null, this._evaluator.featureState = p || null, this._evaluator.canonical = _, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = A || null;
            try {
              const E = this.expression.evaluate(this._evaluator);
              if (E == null || typeof E == "number" && E != E) return this._defaultValue;
              if (this._enumValues && !(E in this._enumValues)) throw new ji(`Expected value to be one of ${Object.keys(this._enumValues).map((M) => JSON.stringify(M)).join(", ")}, but found ${JSON.stringify(E)} instead.`);
              return E;
            } catch (E) {
              return this._warningHistory[E.message] || (this._warningHistory[E.message] = !0, typeof console < "u" && console.warn(E.message)), this._defaultValue;
            }
          }
        }
        function Jl(h) {
          return Array.isArray(h) && h.length > 0 && typeof h[0] == "string" && h[0] in Zl;
        }
        function qc(h, l, u) {
          const p = new ea(Zl, Lu, [], l ? function(x) {
            const A = { color: bn, string: Dr, number: Xt, enum: Dr, boolean: zr, formatted: Wo, padding: Xo, numberArray: Zo, colorArray: Ul, projectionDefinition: qo, resolvedImage: ol, variableAnchorOffsetCollection: Ao };
            return x.type === "array" ? Qi(A[x.value] || Nr, x.length) : A[x.type];
          }(l) : void 0), _ = p.parse(h, void 0, void 0, void 0, l && l.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return _ ? tf(new Hc(_, l, u)) : Yl(p.errors);
        }
        class ph {
          constructor(l, u, p) {
            this.kind = l, this._styleExpression = u, this.isStateDependent = l !== "constant" && !Gc(u.expression), this.globalStateRefs = gh(u.expression), this._globalState = p;
          }
          evaluateWithoutErrorHandling(l, u, p, _, x, A) {
            return this._globalState && (l = Wc(l, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(l, u, p, _, x, A);
          }
          evaluate(l, u, p, _, x, A) {
            return this._globalState && (l = Wc(l, this._globalState)), this._styleExpression.evaluate(l, u, p, _, x, A);
          }
        }
        class of {
          constructor(l, u, p, _, x) {
            this.kind = l, this.zoomStops = p, this._styleExpression = u, this.isStateDependent = l !== "camera" && !Gc(u.expression), this.globalStateRefs = gh(u.expression), this.interpolationType = _, this._globalState = x;
          }
          evaluateWithoutErrorHandling(l, u, p, _, x, A) {
            return this._globalState && (l = Wc(l, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(l, u, p, _, x, A);
          }
          evaluate(l, u, p, _, x, A) {
            return this._globalState && (l = Wc(l, this._globalState)), this._styleExpression.evaluate(l, u, p, _, x, A);
          }
          interpolationFactor(l, u, p) {
            return this.interpolationType ? Ir.interpolationFactor(this.interpolationType, l, u, p) : 0;
          }
        }
        function af(h, l, u) {
          const p = qc(h, l, u);
          if (p.result === "error") return p;
          const _ = p.value.expression, x = Bu(_);
          if (!x && !Tl(l)) return Yl([new Rn("", "data expressions not supported")]);
          const A = ku(_, ["zoom"]);
          if (!A && !Ou(l)) return Yl([new Rn("", "zoom expressions not supported")]);
          const E = Fu(_);
          return E || A ? E instanceof Rn ? Yl([E]) : E instanceof Ir && !Gs(l) ? Yl([new Rn("", '"interpolate" expressions cannot be used with this property')]) : tf(E ? new of(x ? "camera" : "composite", p.value, E.labels, E instanceof Ir ? E.interpolation : void 0, u) : new ph(x ? "constant" : "source", p.value, u)) : Yl([new Rn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Nu {
          constructor(l, u) {
            this._parameters = l, this._specification = u, pi(this, rf(this._parameters, this._specification));
          }
          static deserialize(l) {
            return new Nu(l._parameters, l._specification);
          }
          static serialize(l) {
            return { _parameters: l._parameters, _specification: l._specification };
          }
        }
        function Fu(h) {
          let l = null;
          if (h instanceof ta) l = Fu(h.result);
          else if (h instanceof Fi) {
            for (const u of h.args) if (l = Fu(u), l) break;
          } else (h instanceof Ye || h instanceof Ir) && h.input instanceof _o && h.input.name === "zoom" && (l = h);
          return l instanceof Rn || h.eachChild((u) => {
            const p = Fu(u);
            p instanceof Rn ? l = p : !l && p ? l = new Rn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : l && p && l !== p && (l = new Rn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), l;
        }
        function gh(h, l = /* @__PURE__ */ new Set()) {
          return h instanceof jc && l.add(h.key), h.eachChild((u) => {
            gh(u, l);
          }), l;
        }
        function Wc(h, l) {
          const { zoom: u, heatmapDensity: p, elevation: _, lineProgress: x, isSupportedScript: A, accumulated: E } = h ?? {};
          return { zoom: u, heatmapDensity: p, elevation: _, lineProgress: x, isSupportedScript: A, accumulated: E, globalState: l };
        }
        function mh(h) {
          if (h === !0 || h === !1) return !0;
          if (!Array.isArray(h) || h.length === 0) return !1;
          switch (h[0]) {
            case "has":
              return h.length >= 2 && h[1] !== "$id" && h[1] !== "$type";
            case "in":
              return h.length >= 3 && (typeof h[1] != "string" || Array.isArray(h[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return h.length !== 3 || Array.isArray(h[1]) || Array.isArray(h[2]);
            case "any":
            case "all":
              for (const l of h.slice(1)) if (!mh(l) && typeof l != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const _h = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function El(h, l) {
          if (h == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          mh(h) || (h = yh(h));
          const u = qc(h, _h, l);
          if (u.result === "error") throw new Error(u.value.map((p) => `${p.key}: ${p.message}`).join(", "));
          return { filter: (p, _, x) => u.value.evaluate(p, _, {}, x), needGeometry: pd(h), getGlobalStateRefs: () => gh(u.value.expression) };
        }
        function Uu(h, l) {
          return h < l ? -1 : h > l ? 1 : 0;
        }
        function pd(h) {
          if (!Array.isArray(h)) return !1;
          if (h[0] === "within" || h[0] === "distance") return !0;
          for (let l = 1; l < h.length; l++) if (pd(h[l])) return !0;
          return !1;
        }
        function yh(h) {
          if (!h) return !0;
          const l = h[0];
          return h.length <= 1 ? l !== "any" : l === "==" ? bh(h[1], h[2], "==") : l === "!=" ? Xc(bh(h[1], h[2], "==")) : l === "<" || l === ">" || l === "<=" || l === ">=" ? bh(h[1], h[2], l) : l === "any" ? (u = h.slice(1), ["any"].concat(u.map(yh))) : l === "all" ? ["all"].concat(h.slice(1).map(yh)) : l === "none" ? ["all"].concat(h.slice(1).map(yh).map(Xc)) : l === "in" ? lf(h[1], h.slice(2)) : l === "!in" ? Xc(lf(h[1], h.slice(2))) : l === "has" ? cf(h[1]) : l !== "!has" || Xc(cf(h[1]));
          var u;
        }
        function bh(h, l, u) {
          switch (h) {
            case "$type":
              return [`filter-type-${u}`, l];
            case "$id":
              return [`filter-id-${u}`, l];
            default:
              return [`filter-${u}`, h, l];
          }
        }
        function lf(h, l) {
          if (l.length === 0) return !1;
          switch (h) {
            case "$type":
              return ["filter-type-in", ["literal", l]];
            case "$id":
              return ["filter-id-in", ["literal", l]];
            default:
              return l.length > 200 && !l.some((u) => typeof u != typeof l[0]) ? ["filter-in-large", h, ["literal", l.sort(Uu)]] : ["filter-in-small", h, ["literal", l]];
          }
        }
        function cf(h) {
          switch (h) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", h];
          }
        }
        function Xc(h) {
          return ["!", h];
        }
        function zu(h) {
          const l = typeof h;
          if (l === "number" || l === "boolean" || l === "string" || h == null) return JSON.stringify(h);
          if (Array.isArray(h)) {
            let _ = "[";
            for (const x of h) _ += `${zu(x)},`;
            return `${_}]`;
          }
          const u = Object.keys(h).sort();
          let p = "{";
          for (let _ = 0; _ < u.length; _++) p += `${JSON.stringify(u[_])}:${zu(h[u[_]])},`;
          return `${p}}`;
        }
        function ba(h) {
          let l = "";
          for (const u of mr) l += `/${zu(h[u])}`;
          return l;
        }
        function io(h) {
          const l = h.value;
          return l ? [new Lt(h.key, l, "constants have been deprecated as of v8")] : [];
        }
        function Ci(h) {
          return h instanceof Number || h instanceof String || h instanceof Boolean ? h.valueOf() : h;
        }
        function Kl(h) {
          if (Array.isArray(h)) return h.map(Kl);
          if (h instanceof Object && !(h instanceof Number || h instanceof String || h instanceof Boolean)) {
            const l = {};
            for (const u in h) l[u] = Kl(h[u]);
            return l;
          }
          return Ci(h);
        }
        function yo(h) {
          const l = h.key, u = h.value, p = h.valueSpec || {}, _ = h.objectElementValidators || {}, x = h.style, A = h.styleSpec, E = h.validateSpec;
          let M = [];
          const O = $r(u);
          if (O !== "object") return [new Lt(l, u, `object expected, ${O} found`)];
          for (const N in u) {
            const V = N.split(".")[0], Y = ul(p, V) || p["*"];
            let ee;
            if (ul(_, V)) ee = _[V];
            else if (ul(p, V)) ee = E;
            else if (_["*"]) ee = _["*"];
            else {
              if (!p["*"]) {
                M.push(new Lt(l, u[N], `unknown property "${N}"`));
                continue;
              }
              ee = E;
            }
            M = M.concat(ee({ key: (l && `${l}.`) + N, value: u[N], valueSpec: Y, style: x, styleSpec: A, object: u, objectKey: N, validateSpec: E }, u));
          }
          for (const N in p) _[N] || p[N].required && p[N].default === void 0 && u[N] === void 0 && M.push(new Lt(l, u, `missing required property "${N}"`));
          return M;
        }
        function va(h) {
          const l = h.value, u = h.valueSpec, p = h.style, _ = h.styleSpec, x = h.key, A = h.arrayElementValidator || h.validateSpec;
          if ($r(l) !== "array") return [new Lt(x, l, `array expected, ${$r(l)} found`)];
          if (u.length && l.length !== u.length) return [new Lt(x, l, `array length ${u.length} expected, length ${l.length} found`)];
          if (u["min-length"] && l.length < u["min-length"]) return [new Lt(x, l, `array length at least ${u["min-length"]} expected, length ${l.length} found`)];
          let E = { type: u.value, values: u.values };
          _.$version < 7 && (E.function = u.function), $r(u.value) === "object" && (E = u.value);
          let M = [];
          for (let O = 0; O < l.length; O++) M = M.concat(A({ array: l, arrayIndex: O, value: l[O], valueSpec: E, validateSpec: h.validateSpec, style: p, styleSpec: _, key: `${x}[${O}]` }));
          return M;
        }
        function $s(h) {
          const l = h.key, u = h.value, p = h.valueSpec;
          let _ = $r(u);
          return _ === "number" && u != u && (_ = "NaN"), _ !== "number" ? [new Lt(l, u, `number expected, ${_} found`)] : "minimum" in p && u < p.minimum ? [new Lt(l, u, `${u} is less than the minimum value ${p.minimum}`)] : "maximum" in p && u > p.maximum ? [new Lt(l, u, `${u} is greater than the maximum value ${p.maximum}`)] : [];
        }
        function gd(h) {
          const l = h.valueSpec, u = Ci(h.value.type);
          let p, _, x, A = {};
          const E = u !== "categorical" && h.value.property === void 0, M = !E, O = $r(h.value.stops) === "array" && $r(h.value.stops[0]) === "array" && $r(h.value.stops[0][0]) === "object", N = yo({ key: h.key, value: h.value, valueSpec: h.styleSpec.function, validateSpec: h.validateSpec, style: h.style, styleSpec: h.styleSpec, objectElementValidators: { stops: function(ee) {
            if (u === "identity") return [new Lt(ee.key, ee.value, 'identity function may not have a "stops" property')];
            let ie = [];
            const ue = ee.value;
            return ie = ie.concat(va({ key: ee.key, value: ue, valueSpec: ee.valueSpec, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, arrayElementValidator: V })), $r(ue) === "array" && ue.length === 0 && ie.push(new Lt(ee.key, ue, "array must have at least one stop")), ie;
          }, default: function(ee) {
            return ee.validateSpec({ key: ee.key, value: ee.value, valueSpec: l, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec });
          } } });
          return u === "identity" && E && N.push(new Lt(h.key, h.value, 'missing required property "property"')), u === "identity" || h.value.stops || N.push(new Lt(h.key, h.value, 'missing required property "stops"')), u === "exponential" && h.valueSpec.expression && !Gs(h.valueSpec) && N.push(new Lt(h.key, h.value, "exponential functions not supported")), h.styleSpec.$version >= 8 && (M && !Tl(h.valueSpec) ? N.push(new Lt(h.key, h.value, "property functions not supported")) : E && !Ou(h.valueSpec) && N.push(new Lt(h.key, h.value, "zoom functions not supported"))), u !== "categorical" && !O || h.value.property !== void 0 || N.push(new Lt(h.key, h.value, '"property" property is required')), N;
          function V(ee) {
            let ie = [];
            const ue = ee.value, ve = ee.key;
            if ($r(ue) !== "array") return [new Lt(ve, ue, `array expected, ${$r(ue)} found`)];
            if (ue.length !== 2) return [new Lt(ve, ue, `array length 2 expected, length ${ue.length} found`)];
            if (O) {
              if ($r(ue[0]) !== "object") return [new Lt(ve, ue, `object expected, ${$r(ue[0])} found`)];
              if (ue[0].zoom === void 0) return [new Lt(ve, ue, "object stop key must have zoom")];
              if (ue[0].value === void 0) return [new Lt(ve, ue, "object stop key must have value")];
              if (x && x > Ci(ue[0].zoom)) return [new Lt(ve, ue[0].zoom, "stop zoom values must appear in ascending order")];
              Ci(ue[0].zoom) !== x && (x = Ci(ue[0].zoom), _ = void 0, A = {}), ie = ie.concat(yo({ key: `${ve}[0]`, value: ue[0], valueSpec: { zoom: {} }, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, objectElementValidators: { zoom: $s, value: Y } }));
            } else ie = ie.concat(Y({ key: `${ve}[0]`, value: ue[0], validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }, ue));
            return Jl(Kl(ue[1])) ? ie.concat([new Lt(`${ve}[1]`, ue[1], "expressions are not allowed in function stops.")]) : ie.concat(ee.validateSpec({ key: `${ve}[1]`, value: ue[1], valueSpec: l, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }));
          }
          function Y(ee, ie) {
            const ue = $r(ee.value), ve = Ci(ee.value), Re = ee.value !== null ? ee.value : ie;
            if (p) {
              if (ue !== p) return [new Lt(ee.key, Re, `${ue} stop domain type must match previous stop domain type ${p}`)];
            } else p = ue;
            if (ue !== "number" && ue !== "string" && ue !== "boolean") return [new Lt(ee.key, Re, "stop domain value must be a number, string, or boolean")];
            if (ue !== "number" && u !== "categorical") {
              let it = `number expected, ${ue} found`;
              return Tl(l) && u === void 0 && (it += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Lt(ee.key, Re, it)];
            }
            return u !== "categorical" || ue !== "number" || isFinite(ve) && Math.floor(ve) === ve ? u !== "categorical" && ue === "number" && _ !== void 0 && ve < _ ? [new Lt(ee.key, Re, "stop domain values must appear in ascending order")] : (_ = ve, u === "categorical" && ve in A ? [new Lt(ee.key, Re, "stop domain values must be unique")] : (A[ve] = !0, [])) : [new Lt(ee.key, Re, `integer expected, found ${ve}`)];
          }
        }
        function Zc(h) {
          const l = (h.expressionContext === "property" ? af : qc)(Kl(h.value), h.valueSpec);
          if (l.result === "error") return l.value.map((p) => new Lt(`${h.key}${p.key}`, h.value, p.message));
          const u = l.value.expression || l.value._styleExpression.expression;
          if (h.expressionContext === "property" && h.propertyKey === "text-font" && !u.outputDefined()) return [new Lt(h.key, h.value, `Invalid data expression for "${h.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (h.expressionContext === "property" && h.propertyType === "layout" && !Gc(u)) return [new Lt(h.key, h.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (h.expressionContext === "filter" && !Gc(u)) return [new Lt(h.key, h.value, '"feature-state" data expressions are not supported with filters.')];
          if (h.expressionContext && h.expressionContext.indexOf("cluster") === 0) {
            if (!ku(u, ["zoom", "feature-state"])) return [new Lt(h.key, h.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (h.expressionContext === "cluster-initial" && !Bu(u)) return [new Lt(h.key, h.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function ju(h) {
          const l = h.key, u = h.value, p = $r(u);
          return p !== "string" ? [new Lt(l, u, `color expected, ${p} found`)] : jr.parse(String(u)) ? [] : [new Lt(l, u, `color expected, "${u}" found`)];
        }
        function Ql(h) {
          const l = h.key, u = h.value, p = h.valueSpec, _ = [];
          return Array.isArray(p.values) ? p.values.indexOf(Ci(u)) === -1 && _.push(new Lt(l, u, `expected one of [${p.values.join(", ")}], ${JSON.stringify(u)} found`)) : Object.keys(p.values).indexOf(Ci(u)) === -1 && _.push(new Lt(l, u, `expected one of [${Object.keys(p.values).join(", ")}], ${JSON.stringify(u)} found`)), _;
        }
        function ec(h) {
          return mh(Kl(h.value)) ? Zc(pi({}, h, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : uf(h);
        }
        function uf(h) {
          const l = h.value, u = h.key;
          if ($r(l) !== "array") return [new Lt(u, l, `array expected, ${$r(l)} found`)];
          const p = h.styleSpec;
          let _, x = [];
          if (l.length < 1) return [new Lt(u, l, "filter array must have at least 1 element")];
          switch (x = x.concat(Ql({ key: `${u}[0]`, value: l[0], valueSpec: p.filter_operator, style: h.style, styleSpec: h.styleSpec })), Ci(l[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              l.length >= 2 && Ci(l[1]) === "$type" && x.push(new Lt(u, l, `"$type" cannot be use with operator "${l[0]}"`));
            case "==":
            case "!=":
              l.length !== 3 && x.push(new Lt(u, l, `filter array for operator "${l[0]}" must have 3 elements`));
            case "in":
            case "!in":
              l.length >= 2 && (_ = $r(l[1]), _ !== "string" && x.push(new Lt(`${u}[1]`, l[1], `string expected, ${_} found`)));
              for (let A = 2; A < l.length; A++) _ = $r(l[A]), Ci(l[1]) === "$type" ? x = x.concat(Ql({ key: `${u}[${A}]`, value: l[A], valueSpec: p.geometry_type, style: h.style, styleSpec: h.styleSpec })) : _ !== "string" && _ !== "number" && _ !== "boolean" && x.push(new Lt(`${u}[${A}]`, l[A], `string, number, or boolean expected, ${_} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let A = 1; A < l.length; A++) x = x.concat(uf({ key: `${u}[${A}]`, value: l[A], style: h.style, styleSpec: h.styleSpec }));
              break;
            case "has":
            case "!has":
              _ = $r(l[1]), l.length !== 2 ? x.push(new Lt(u, l, `filter array for "${l[0]}" operator must have 2 elements`)) : _ !== "string" && x.push(new Lt(`${u}[1]`, l[1], `string expected, ${_} found`));
          }
          return x;
        }
        function hf(h, l) {
          const u = h.key, p = h.validateSpec, _ = h.style, x = h.styleSpec, A = h.value, E = h.objectKey, M = x[`${l}_${h.layerType}`];
          if (!M) return [];
          const O = E.match(/^(.*)-transition$/);
          if (l === "paint" && O && M[O[1]] && M[O[1]].transition) return p({ key: u, value: A, valueSpec: x.transition, style: _, styleSpec: x });
          const N = h.valueSpec || M[E];
          if (!N) return [new Lt(u, A, `unknown property "${E}"`)];
          let V;
          if ($r(A) === "string" && Tl(N) && !N.tokens && (V = /^{([^}]+)}$/.exec(A))) return [new Lt(u, A, `"${E}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(V[1])} }\`.`)];
          const Y = [];
          return h.layerType === "symbol" && (E === "text-field" && _ && !_.glyphs && Y.push(new Lt(u, A, 'use of "text-field" requires a style "glyphs" property')), E === "text-font" && $a(Kl(A)) && Ci(A.type) === "identity" && Y.push(new Lt(u, A, '"text-font" does not support identity functions'))), Y.concat(p({ key: h.key, value: A, valueSpec: N, style: _, styleSpec: x, expressionContext: "property", propertyType: l, propertyKey: E }));
        }
        function Yc(h) {
          return hf(h, "paint");
        }
        function Vu(h) {
          return hf(h, "layout");
        }
        function tc(h) {
          let l = [];
          const u = h.value, p = h.key, _ = h.style, x = h.styleSpec;
          if ($r(u) !== "object") return [new Lt(p, u, `object expected, ${$r(u)} found`)];
          u.type || u.ref || l.push(new Lt(p, u, 'either "type" or "ref" is required'));
          let A = Ci(u.type);
          const E = Ci(u.ref);
          if (u.id) {
            const M = Ci(u.id);
            for (let O = 0; O < h.arrayIndex; O++) {
              const N = _.layers[O];
              Ci(N.id) === M && l.push(new Lt(p, u.id, `duplicate layer id "${u.id}", previously used at line ${N.id.__line__}`));
            }
          }
          if ("ref" in u) {
            let M;
            ["type", "source", "source-layer", "filter", "layout"].forEach((O) => {
              O in u && l.push(new Lt(p, u[O], `"${O}" is prohibited for ref layers`));
            }), _.layers.forEach((O) => {
              Ci(O.id) === E && (M = O);
            }), M ? M.ref ? l.push(new Lt(p, u.ref, "ref cannot reference another ref layer")) : A = Ci(M.type) : l.push(new Lt(p, u.ref, `ref layer "${E}" not found`));
          } else if (A !== "background") if (u.source) {
            const M = _.sources && _.sources[u.source], O = M && Ci(M.type);
            M ? O === "vector" && A === "raster" ? l.push(new Lt(p, u.source, `layer "${u.id}" requires a raster source`)) : O !== "raster-dem" && A === "hillshade" || O !== "raster-dem" && A === "color-relief" ? l.push(new Lt(p, u.source, `layer "${u.id}" requires a raster-dem source`)) : O === "raster" && A !== "raster" ? l.push(new Lt(p, u.source, `layer "${u.id}" requires a vector source`)) : O !== "vector" || u["source-layer"] ? O === "raster-dem" && A !== "hillshade" && A !== "color-relief" ? l.push(new Lt(p, u.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : A !== "line" || !u.paint || !u.paint["line-gradient"] || O === "geojson" && M.lineMetrics || l.push(new Lt(p, u, `layer "${u.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : l.push(new Lt(p, u, `layer "${u.id}" must specify a "source-layer"`)) : l.push(new Lt(p, u.source, `source "${u.source}" not found`));
          } else l.push(new Lt(p, u, 'missing required property "source"'));
          return l = l.concat(yo({ key: p, value: u, valueSpec: x.layer, style: h.style, styleSpec: h.styleSpec, validateSpec: h.validateSpec, objectElementValidators: { "*": () => [], type: () => h.validateSpec({ key: `${p}.type`, value: u.type, valueSpec: x.layer.type, style: h.style, styleSpec: h.styleSpec, validateSpec: h.validateSpec, object: u, objectKey: "type" }), filter: ec, layout: (M) => yo({ layer: u, key: M.key, value: M.value, style: M.style, styleSpec: M.styleSpec, validateSpec: M.validateSpec, objectElementValidators: { "*": (O) => Vu(pi({ layerType: A }, O)) } }), paint: (M) => yo({ layer: u, key: M.key, value: M.value, style: M.style, styleSpec: M.styleSpec, validateSpec: M.validateSpec, objectElementValidators: { "*": (O) => Yc(pi({ layerType: A }, O)) } }) } })), l;
        }
        function xa(h) {
          const l = h.value, u = h.key, p = $r(l);
          return p !== "string" ? [new Lt(u, l, `string expected, ${p} found`)] : [];
        }
        const Jc = { promoteId: function({ key: h, value: l }) {
          if ($r(l) === "string") return xa({ key: h, value: l });
          {
            const u = [];
            for (const p in l) u.push(...xa({ key: `${h}.${p}`, value: l[p] }));
            return u;
          }
        } };
        function ff(h) {
          const l = h.value, u = h.key, p = h.styleSpec, _ = h.style, x = h.validateSpec;
          if (!l.type) return [new Lt(u, l, '"type" is required')];
          const A = Ci(l.type);
          let E;
          switch (A) {
            case "vector":
            case "raster":
              return E = yo({ key: u, value: l, valueSpec: p[`source_${A.replace("-", "_")}`], style: h.style, styleSpec: p, objectElementValidators: Jc, validateSpec: x }), E;
            case "raster-dem":
              return E = function(M) {
                var O;
                const N = (O = M.sourceName) !== null && O !== void 0 ? O : "", V = M.value, Y = M.styleSpec, ee = Y.source_raster_dem, ie = M.style;
                let ue = [];
                const ve = $r(V);
                if (V === void 0) return ue;
                if (ve !== "object") return ue.push(new Lt("source_raster_dem", V, `object expected, ${ve} found`)), ue;
                const Re = Ci(V.encoding) === "custom", it = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ze = M.value.encoding ? `"${M.value.encoding}"` : "Default";
                for (const Ze in V) !Re && it.includes(Ze) ? ue.push(new Lt(Ze, V[Ze], `In "${N}": "${Ze}" is only valid when "encoding" is set to "custom". ${ze} encoding found`)) : ee[Ze] ? ue = ue.concat(M.validateSpec({ key: Ze, value: V[Ze], valueSpec: ee[Ze], validateSpec: M.validateSpec, style: ie, styleSpec: Y })) : ue.push(new Lt(Ze, V[Ze], `unknown property "${Ze}"`));
                return ue;
              }({ sourceName: u, value: l, style: h.style, styleSpec: p, validateSpec: x }), E;
            case "geojson":
              if (E = yo({ key: u, value: l, valueSpec: p.source_geojson, style: _, styleSpec: p, validateSpec: x, objectElementValidators: Jc }), l.cluster) for (const M in l.clusterProperties) {
                const [O, N] = l.clusterProperties[M], V = typeof O == "string" ? [O, ["accumulated"], ["get", M]] : O;
                E.push(...Zc({ key: `${u}.${M}.map`, value: N, expressionContext: "cluster-map" })), E.push(...Zc({ key: `${u}.${M}.reduce`, value: V, expressionContext: "cluster-reduce" }));
              }
              return E;
            case "video":
              return yo({ key: u, value: l, valueSpec: p.source_video, style: _, validateSpec: x, styleSpec: p });
            case "image":
              return yo({ key: u, value: l, valueSpec: p.source_image, style: _, validateSpec: x, styleSpec: p });
            case "canvas":
              return [new Lt(u, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Ql({ key: `${u}.type`, value: l.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function md(h) {
          const l = h.value, u = h.styleSpec, p = u.light, _ = h.style;
          let x = [];
          const A = $r(l);
          if (l === void 0) return x;
          if (A !== "object") return x = x.concat([new Lt("light", l, `object expected, ${A} found`)]), x;
          for (const E in l) {
            const M = E.match(/^(.*)-transition$/);
            x = x.concat(M && p[M[1]] && p[M[1]].transition ? h.validateSpec({ key: E, value: l[E], valueSpec: u.transition, validateSpec: h.validateSpec, style: _, styleSpec: u }) : p[E] ? h.validateSpec({ key: E, value: l[E], valueSpec: p[E], validateSpec: h.validateSpec, style: _, styleSpec: u }) : [new Lt(E, l[E], `unknown property "${E}"`)]);
          }
          return x;
        }
        function _d(h) {
          const l = h.value, u = h.styleSpec, p = u.sky, _ = h.style, x = $r(l);
          if (l === void 0) return [];
          if (x !== "object") return [new Lt("sky", l, `object expected, ${x} found`)];
          let A = [];
          for (const E in l) A = A.concat(p[E] ? h.validateSpec({ key: E, value: l[E], valueSpec: p[E], style: _, styleSpec: u }) : [new Lt(E, l[E], `unknown property "${E}"`)]);
          return A;
        }
        function yd(h) {
          const l = h.value, u = h.styleSpec, p = u.terrain, _ = h.style;
          let x = [];
          const A = $r(l);
          if (l === void 0) return x;
          if (A !== "object") return x = x.concat([new Lt("terrain", l, `object expected, ${A} found`)]), x;
          for (const E in l) x = x.concat(p[E] ? h.validateSpec({ key: E, value: l[E], valueSpec: p[E], validateSpec: h.validateSpec, style: _, styleSpec: u }) : [new Lt(E, l[E], `unknown property "${E}"`)]);
          return x;
        }
        function bd(h) {
          let l = [];
          const u = h.value, p = h.key;
          if (Array.isArray(u)) {
            const _ = [], x = [];
            for (const A in u) u[A].id && _.includes(u[A].id) && l.push(new Lt(p, u, `all the sprites' ids must be unique, but ${u[A].id} is duplicated`)), _.push(u[A].id), u[A].url && x.includes(u[A].url) && l.push(new Lt(p, u, `all the sprites' URLs must be unique, but ${u[A].url} is duplicated`)), x.push(u[A].url), l = l.concat(yo({ key: `${p}[${A}]`, value: u[A], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: h.validateSpec }));
            return l;
          }
          return xa({ key: p, value: u });
        }
        function vd(h) {
          return l = h.value, l && l.constructor === Object ? [] : [new Lt(h.key, h.value, `object expected, ${$r(h.value)} found`)];
          var l;
        }
        const Kc = { "*": () => [], array: va, boolean: function(h) {
          const l = h.value, u = h.key, p = $r(l);
          return p !== "boolean" ? [new Lt(u, l, `boolean expected, ${p} found`)] : [];
        }, number: $s, color: ju, constants: io, enum: Ql, filter: ec, function: gd, layer: tc, object: yo, source: ff, light: md, sky: _d, terrain: yd, projection: function(h) {
          const l = h.value, u = h.styleSpec, p = u.projection, _ = h.style, x = $r(l);
          if (l === void 0) return [];
          if (x !== "object") return [new Lt("projection", l, `object expected, ${x} found`)];
          let A = [];
          for (const E in l) A = A.concat(p[E] ? h.validateSpec({ key: E, value: l[E], valueSpec: p[E], style: _, styleSpec: u }) : [new Lt(E, l[E], `unknown property "${E}"`)]);
          return A;
        }, projectionDefinition: function(h) {
          const l = h.key;
          let u = h.value;
          u = u instanceof String ? u.valueOf() : u;
          const p = $r(u);
          return p !== "array" || function(_) {
            return Array.isArray(_) && _.length === 3 && typeof _[0] == "string" && typeof _[1] == "string" && typeof _[2] == "number";
          }(u) || function(_) {
            return !!["interpolate", "step", "literal"].includes(_[0]);
          }(u) ? ["array", "string"].includes(p) ? [] : [new Lt(l, u, `projection expected, invalid type "${p}" found`)] : [new Lt(l, u, `projection expected, invalid array ${JSON.stringify(u)} found`)];
        }, string: xa, formatted: function(h) {
          return xa(h).length === 0 ? [] : Zc(h);
        }, resolvedImage: function(h) {
          return xa(h).length === 0 ? [] : Zc(h);
        }, padding: function(h) {
          const l = h.key, u = h.value;
          if ($r(u) === "array") {
            if (u.length < 1 || u.length > 4) return [new Lt(l, u, `padding requires 1 to 4 values; ${u.length} values found`)];
            const p = { type: "number" };
            let _ = [];
            for (let x = 0; x < u.length; x++) _ = _.concat(h.validateSpec({ key: `${l}[${x}]`, value: u[x], validateSpec: h.validateSpec, valueSpec: p }));
            return _;
          }
          return $s({ key: l, value: u, valueSpec: {} });
        }, numberArray: function(h) {
          const l = h.key, u = h.value;
          if ($r(u) === "array") {
            const p = { type: "number" };
            if (u.length < 1) return [new Lt(l, u, "array length at least 1 expected, length 0 found")];
            let _ = [];
            for (let x = 0; x < u.length; x++) _ = _.concat(h.validateSpec({ key: `${l}[${x}]`, value: u[x], validateSpec: h.validateSpec, valueSpec: p }));
            return _;
          }
          return $s({ key: l, value: u, valueSpec: {} });
        }, colorArray: function(h) {
          const l = h.key, u = h.value;
          if ($r(u) === "array") {
            if (u.length < 1) return [new Lt(l, u, "array length at least 1 expected, length 0 found")];
            let p = [];
            for (let _ = 0; _ < u.length; _++) p = p.concat(ju({ key: `${l}[${_}]`, value: u[_] }));
            return p;
          }
          return ju({ key: l, value: u });
        }, variableAnchorOffsetCollection: function(h) {
          const l = h.key, u = h.value, p = $r(u), _ = h.styleSpec;
          if (p !== "array" || u.length < 1 || u.length % 2 != 0) return [new Lt(l, u, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let x = [];
          for (let A = 0; A < u.length; A += 2) x = x.concat(Ql({ key: `${l}[${A}]`, value: u[A], valueSpec: _.layout_symbol["text-anchor"] })), x = x.concat(va({ key: `${l}[${A + 1}]`, value: u[A + 1], valueSpec: { length: 2, value: "number" }, validateSpec: h.validateSpec, style: h.style, styleSpec: _ }));
          return x;
        }, sprite: bd, state: vd };
        function Ha(h) {
          const l = h.value, u = h.valueSpec, p = h.styleSpec;
          return h.validateSpec = Ha, u.expression && $a(Ci(l)) ? gd(h) : u.expression && Jl(Kl(l)) ? Zc(h) : u.type && Kc[u.type] ? Kc[u.type](h) : yo(pi({}, h, { valueSpec: u.type ? p[u.type] : u }));
        }
        function ds(h) {
          const l = h.value, u = h.key, p = xa(h);
          return p.length || (l.indexOf("{fontstack}") === -1 && p.push(new Lt(u, l, '"glyphs" url must include a "{fontstack}" token')), l.indexOf("{range}") === -1 && p.push(new Lt(u, l, '"glyphs" url must include a "{range}" token'))), p;
        }
        function Es(h, l = We) {
          let u = [];
          return u = u.concat(Ha({ key: "", value: h, valueSpec: l.$root, styleSpec: l, style: h, validateSpec: Ha, objectElementValidators: { glyphs: ds, "*": () => [] } })), h.constants && (u = u.concat(io({ key: "constants", value: h.constants }))), df(u);
        }
        function Mo(h) {
          return function(l) {
            return h(Object.assign({}, l, { validateSpec: Ha }));
          };
        }
        function df(h) {
          return [].concat(h).sort((l, u) => l.line - u.line);
        }
        function C(h) {
          return function(...l) {
            return df(h.apply(this, l));
          };
        }
        Es.source = C(Mo(ff)), Es.sprite = C(Mo(bd)), Es.glyphs = C(Mo(ds)), Es.light = C(Mo(md)), Es.sky = C(Mo(_d)), Es.terrain = C(Mo(yd)), Es.state = C(Mo(vd)), Es.layer = C(Mo(tc)), Es.filter = C(Mo(ec)), Es.paintProperty = C(Mo(Yc)), Es.layoutProperty = C(Mo(Vu));
        const L = Es, z = L.light, W = L.sky, ae = L.paintProperty, he = L.layoutProperty;
        function ge(h, l) {
          let u = !1;
          if (l && l.length) for (const p of l) h.fire(new It(new Error(p.message))), u = !0;
          return u;
        }
        class ye {
          constructor(l, u, p) {
            const _ = this.cells = [];
            if (l instanceof ArrayBuffer) {
              this.arrayBuffer = l;
              const A = new Int32Array(this.arrayBuffer);
              l = A[0], this.d = (u = A[1]) + 2 * (p = A[2]);
              for (let M = 0; M < this.d * this.d; M++) {
                const O = A[3 + M], N = A[3 + M + 1];
                _.push(O === N ? null : A.subarray(O, N));
              }
              const E = A[3 + _.length + 1];
              this.keys = A.subarray(A[3 + _.length], E), this.bboxes = A.subarray(E), this.insert = this._insertReadonly;
            } else {
              this.d = u + 2 * p;
              for (let A = 0; A < this.d * this.d; A++) _.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = u, this.extent = l, this.padding = p, this.scale = u / l, this.uid = 0;
            const x = p / u * l;
            this.min = -x, this.max = l + x;
          }
          insert(l, u, p, _, x) {
            this._forEachCell(u, p, _, x, this._insertCell, this.uid++, void 0, void 0), this.keys.push(l), this.bboxes.push(u), this.bboxes.push(p), this.bboxes.push(_), this.bboxes.push(x);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(l, u, p, _, x, A) {
            this.cells[x].push(A);
          }
          query(l, u, p, _, x) {
            const A = this.min, E = this.max;
            if (l <= A && u <= A && E <= p && E <= _ && !x) return Array.prototype.slice.call(this.keys);
            {
              const M = [];
              return this._forEachCell(l, u, p, _, this._queryCell, M, {}, x), M;
            }
          }
          _queryCell(l, u, p, _, x, A, E, M) {
            const O = this.cells[x];
            if (O !== null) {
              const N = this.keys, V = this.bboxes;
              for (let Y = 0; Y < O.length; Y++) {
                const ee = O[Y];
                if (E[ee] === void 0) {
                  const ie = 4 * ee;
                  (M ? M(V[ie + 0], V[ie + 1], V[ie + 2], V[ie + 3]) : l <= V[ie + 2] && u <= V[ie + 3] && p >= V[ie + 0] && _ >= V[ie + 1]) ? (E[ee] = !0, A.push(N[ee])) : E[ee] = !1;
                }
              }
            }
          }
          _forEachCell(l, u, p, _, x, A, E, M) {
            const O = this._convertToCellCoord(l), N = this._convertToCellCoord(u), V = this._convertToCellCoord(p), Y = this._convertToCellCoord(_);
            for (let ee = O; ee <= V; ee++) for (let ie = N; ie <= Y; ie++) {
              const ue = this.d * ie + ee;
              if ((!M || M(this._convertFromCellCoord(ee), this._convertFromCellCoord(ie), this._convertFromCellCoord(ee + 1), this._convertFromCellCoord(ie + 1))) && x.call(this, l, u, p, _, ue, A, E, M)) return;
            }
          }
          _convertFromCellCoord(l) {
            return (l - this.padding) / this.scale;
          }
          _convertToCellCoord(l) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(l * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const l = this.cells, u = 3 + this.cells.length + 1 + 1;
            let p = 0;
            for (let A = 0; A < this.cells.length; A++) p += this.cells[A].length;
            const _ = new Int32Array(u + p + this.keys.length + this.bboxes.length);
            _[0] = this.extent, _[1] = this.n, _[2] = this.padding;
            let x = u;
            for (let A = 0; A < l.length; A++) {
              const E = l[A];
              _[3 + A] = x, _.set(E, x), x += E.length;
            }
            return _[3 + l.length] = x, _.set(this.keys, x), x += this.keys.length, _[3 + l.length + 1] = x, _.set(this.bboxes, x), x += this.bboxes.length, _.buffer;
          }
          static serialize(l, u) {
            const p = l.toArrayBuffer();
            return u && u.push(p), { buffer: p };
          }
          static deserialize(l) {
            return new ye(l.buffer);
          }
        }
        const xe = {};
        function me(h, l, u = {}) {
          if (xe[h]) throw new Error(`${h} is already registered.`);
          Object.defineProperty(l, "_classRegistryKey", { value: h, writeable: !1 }), xe[h] = { klass: l, omit: u.omit || [], shallow: u.shallow || [] };
        }
        me("Object", Object), me("Set", Set), me("TransferableGridIndex", ye), me("Color", jr), me("Error", Error), me("AJAXError", Te), me("ResolvedImage", Hn), me("StylePropertyFunction", Nu), me("StyleExpression", Hc, { omit: ["_evaluator"] }), me("ZoomDependentExpression", of), me("ZoomConstantExpression", ph), me("CompoundExpression", _o, { omit: ["_evaluate"] });
        for (const h in Zl) Zl[h]._classRegistryKey || me(`Expression_${h}`, Zl[h]);
        function et(h) {
          return h && typeof ArrayBuffer < "u" && (h instanceof ArrayBuffer || h.constructor && h.constructor.name === "ArrayBuffer");
        }
        function bt(h) {
          return h.$name || h.constructor._classRegistryKey;
        }
        function ke(h) {
          return !function(l) {
            if (l === null || typeof l != "object") return !1;
            const u = bt(l);
            return !(!u || u === "Object");
          }(h) && (h == null || typeof h == "boolean" || typeof h == "number" || typeof h == "string" || h instanceof Boolean || h instanceof Number || h instanceof String || h instanceof Date || h instanceof RegExp || h instanceof Blob || h instanceof Error || et(h) || Jt(h) || ArrayBuffer.isView(h) || h instanceof ImageData);
        }
        function st(h, l) {
          if (ke(h)) return (et(h) || Jt(h)) && l && l.push(h), ArrayBuffer.isView(h) && l && l.push(h.buffer), h instanceof ImageData && l && l.push(h.data.buffer), h;
          if (Array.isArray(h)) {
            const x = [];
            for (const A of h) x.push(st(A, l));
            return x;
          }
          if (typeof h != "object") throw new Error("can't serialize object of type " + typeof h);
          const u = bt(h);
          if (!u) throw new Error(`can't serialize object of unregistered class ${h.constructor.name}`);
          if (!xe[u]) throw new Error(`${u} is not registered.`);
          const { klass: p } = xe[u], _ = p.serialize ? p.serialize(h, l) : {};
          if (p.serialize) {
            if (l && _ === l[l.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const x in h) {
              if (!h.hasOwnProperty(x) || xe[u].omit.indexOf(x) >= 0) continue;
              const A = h[x];
              _[x] = xe[u].shallow.indexOf(x) >= 0 ? A : st(A, l);
            }
            h instanceof Error && (_.message = h.message);
          }
          if (_.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return u !== "Object" && (_.$name = u), _;
        }
        function ht(h) {
          if (ke(h)) return h;
          if (Array.isArray(h)) return h.map(ht);
          if (typeof h != "object") throw new Error("can't deserialize object of type " + typeof h);
          const l = bt(h) || "Object";
          if (!xe[l]) throw new Error(`can't deserialize unregistered class ${l}`);
          const { klass: u } = xe[l];
          if (!u) throw new Error(`can't deserialize unregistered class ${l}`);
          if (u.deserialize) return u.deserialize(h);
          const p = Object.create(u.prototype);
          for (const _ of Object.keys(h)) {
            if (_ === "$name") continue;
            const x = h[_];
            p[_] = xe[l].shallow.indexOf(_) >= 0 ? x : ht(x);
          }
          return p;
        }
        class kt {
          constructor() {
            this.first = !0;
          }
          update(l, u) {
            const p = Math.floor(l);
            return this.first ? (this.first = !1, this.lastIntegerZoom = p, this.lastIntegerZoomTime = 0, this.lastZoom = l, this.lastFloorZoom = p, !0) : (this.lastFloorZoom > p ? (this.lastIntegerZoom = p + 1, this.lastIntegerZoomTime = u) : this.lastFloorZoom < p && (this.lastIntegerZoom = p, this.lastIntegerZoomTime = u), l !== this.lastZoom && (this.lastZoom = l, this.lastFloorZoom = p, !0));
          }
        }
        const tt = { "Latin-1 Supplement": (h) => h >= 128 && h <= 255, "Hangul Jamo": (h) => h >= 4352 && h <= 4607, Khmer: (h) => h >= 6016 && h <= 6143, "General Punctuation": (h) => h >= 8192 && h <= 8303, "Letterlike Symbols": (h) => h >= 8448 && h <= 8527, "Number Forms": (h) => h >= 8528 && h <= 8591, "Miscellaneous Technical": (h) => h >= 8960 && h <= 9215, "Control Pictures": (h) => h >= 9216 && h <= 9279, "Optical Character Recognition": (h) => h >= 9280 && h <= 9311, "Enclosed Alphanumerics": (h) => h >= 9312 && h <= 9471, "Geometric Shapes": (h) => h >= 9632 && h <= 9727, "Miscellaneous Symbols": (h) => h >= 9728 && h <= 9983, "Miscellaneous Symbols and Arrows": (h) => h >= 11008 && h <= 11263, "Ideographic Description Characters": (h) => h >= 12272 && h <= 12287, "CJK Symbols and Punctuation": (h) => h >= 12288 && h <= 12351, Hiragana: (h) => h >= 12352 && h <= 12447, Katakana: (h) => h >= 12448 && h <= 12543, Kanbun: (h) => h >= 12688 && h <= 12703, "CJK Strokes": (h) => h >= 12736 && h <= 12783, "Enclosed CJK Letters and Months": (h) => h >= 12800 && h <= 13055, "CJK Compatibility": (h) => h >= 13056 && h <= 13311, "Yijing Hexagram Symbols": (h) => h >= 19904 && h <= 19967, "CJK Unified Ideographs": (h) => h >= 19968 && h <= 40959, "Hangul Syllables": (h) => h >= 44032 && h <= 55215, "Private Use Area": (h) => h >= 57344 && h <= 63743, "Vertical Forms": (h) => h >= 65040 && h <= 65055, "CJK Compatibility Forms": (h) => h >= 65072 && h <= 65103, "Small Form Variants": (h) => h >= 65104 && h <= 65135, "Halfwidth and Fullwidth Forms": (h) => h >= 65280 && h <= 65519 };
        function Ot(h) {
          for (const l of h) if (si(l.charCodeAt(0))) return !0;
          return !1;
        }
        function jt(h) {
          for (const l of h) if (!Br(l.charCodeAt(0))) return !1;
          return !0;
        }
        function Kt(h) {
          const l = h.map((u) => {
            try {
              return new RegExp(`\\p{sc=${u}}`, "u").source;
            } catch {
              return null;
            }
          }).filter((u) => u);
          return new RegExp(l.join("|"), "u");
        }
        const Wt = Kt(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Br(h) {
          return !Wt.test(String.fromCodePoint(h));
        }
        const yr = Kt(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function si(h) {
          return !(h !== 746 && h !== 747 && (h < 4352 || !(tt["CJK Compatibility Forms"](h) && !(h >= 65097 && h <= 65103) || tt["CJK Compatibility"](h) || tt["CJK Strokes"](h) || !(!tt["CJK Symbols and Punctuation"](h) || h >= 12296 && h <= 12305 || h >= 12308 && h <= 12319 || h === 12336) || tt["Enclosed CJK Letters and Months"](h) || tt["Ideographic Description Characters"](h) || tt.Kanbun(h) || tt.Katakana(h) && h !== 12540 || !(!tt["Halfwidth and Fullwidth Forms"](h) || h === 65288 || h === 65289 || h === 65293 || h >= 65306 && h <= 65310 || h === 65339 || h === 65341 || h === 65343 || h >= 65371 && h <= 65503 || h === 65507 || h >= 65512 && h <= 65519) || !(!tt["Small Form Variants"](h) || h >= 65112 && h <= 65118 || h >= 65123 && h <= 65126) || tt["Vertical Forms"](h) || tt["Yijing Hexagram Symbols"](h) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(h)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(h)) || yr.test(String.fromCodePoint(h)))));
        }
        function Tr(h) {
          return !(si(h) || function(l) {
            return !!(tt["Latin-1 Supplement"](l) && (l === 167 || l === 169 || l === 174 || l === 177 || l === 188 || l === 189 || l === 190 || l === 215 || l === 247) || tt["General Punctuation"](l) && (l === 8214 || l === 8224 || l === 8225 || l === 8240 || l === 8241 || l === 8251 || l === 8252 || l === 8258 || l === 8263 || l === 8264 || l === 8265 || l === 8273) || tt["Letterlike Symbols"](l) || tt["Number Forms"](l) || tt["Miscellaneous Technical"](l) && (l >= 8960 && l <= 8967 || l >= 8972 && l <= 8991 || l >= 8996 && l <= 9e3 || l === 9003 || l >= 9085 && l <= 9114 || l >= 9150 && l <= 9165 || l === 9167 || l >= 9169 && l <= 9179 || l >= 9186 && l <= 9215) || tt["Control Pictures"](l) && l !== 9251 || tt["Optical Character Recognition"](l) || tt["Enclosed Alphanumerics"](l) || tt["Geometric Shapes"](l) || tt["Miscellaneous Symbols"](l) && !(l >= 9754 && l <= 9759) || tt["Miscellaneous Symbols and Arrows"](l) && (l >= 11026 && l <= 11055 || l >= 11088 && l <= 11097 || l >= 11192 && l <= 11243) || tt["CJK Symbols and Punctuation"](l) || tt.Katakana(l) || tt["Private Use Area"](l) || tt["CJK Compatibility Forms"](l) || tt["Small Form Variants"](l) || tt["Halfwidth and Fullwidth Forms"](l) || l === 8734 || l === 8756 || l === 8757 || l >= 9984 && l <= 10087 || l >= 10102 && l <= 10131 || l === 65532 || l === 65533);
          }(h));
        }
        const xi = Kt(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function zn(h) {
          return xi.test(String.fromCodePoint(h));
        }
        function ui(h, l) {
          return !(!l && zn(h) || h >= 2304 && h <= 3583 || h >= 3840 && h <= 4255 || tt.Khmer(h));
        }
        function Pr(h) {
          for (const l of h) if (zn(l.charCodeAt(0))) return !0;
          return !1;
        }
        const lr = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(h) {
            this.pluginStatus = h.pluginStatus, this.pluginURL = h.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(h) {
            if (lr.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = h.applyArabicShaping, this.processBidirectionalText = h.processBidirectionalText, this.processStyledBidirectionalText = h.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(h, l) {
            return o(this, void 0, void 0, function* () {
              if (this.isParsed()) return this.getState();
              if (h.pluginStatus !== "loading") return this.setState(h), h;
              const u = h.pluginURL, p = new Promise((x) => {
                this.loadScriptResolve = x;
              });
              l(u);
              const _ = new Promise((x) => setTimeout(() => x(), this.TIMEOUT));
              if (yield Promise.race([p, _]), this.isParsed()) {
                const x = { pluginStatus: "loaded", pluginURL: u };
                return this.setState(x), x;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${u}`);
            });
          }
        }();
        class Wr {
          constructor(l, u) {
            this.isSupportedScript = oi, this.zoom = l, u ? (this.now = u.now || 0, this.fadeDuration = u.fadeDuration || 0, this.zoomHistory = u.zoomHistory || new kt(), this.transition = u.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new kt(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const l = this.zoom, u = l - Math.floor(l), p = this.crossFadingFactor();
            return l > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: u + (1 - u) * p } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - p) * u };
          }
        }
        function oi(h) {
          return function(l, u) {
            for (const p of l) if (!ui(p.charCodeAt(0), u)) return !1;
            return !0;
          }(h, lr.getRTLTextPluginStatus() === "loaded");
        }
        class _i {
          constructor(l, u, p) {
            this.property = l, this.value = u, this.expression = function(_, x, A) {
              if ($a(_)) return new Nu(_, x);
              if (Jl(_)) {
                const E = af(_, x, A);
                if (E.result === "error") throw new Error(E.value.map((M) => `${M.key}: ${M.message}`).join(", "));
                return E.value;
              }
              {
                let E = _;
                return x.type === "color" && typeof _ == "string" ? E = jr.parse(_) : x.type !== "padding" || typeof _ != "number" && !Array.isArray(_) ? x.type !== "numberArray" || typeof _ != "number" && !Array.isArray(_) ? x.type !== "colorArray" || typeof _ != "string" && !Array.isArray(_) ? x.type === "variableAnchorOffsetCollection" && Array.isArray(_) ? E = on.parse(_) : x.type === "projectionDefinition" && typeof _ == "string" && (E = As.parse(_)) : E = Bn.parse(_) : E = es.parse(_) : E = Fn.parse(_), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => E };
              }
            }(u === void 0 ? l.specification.default : u, l.specification, p);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(l, u, p) {
            return this.property.possiblyEvaluate(this, l, u, p);
          }
        }
        class Vi {
          constructor(l, u) {
            this.property = l, this.value = new _i(l, void 0, u);
          }
          transitioned(l, u) {
            return new ps(this.property, this.value, u, Et({}, l.transition, this.transition), l.now);
          }
          untransitioned() {
            return new ps(this.property, this.value, null, {}, 0);
          }
        }
        class Xn {
          constructor(l, u) {
            this._properties = l, this._values = Object.create(l.defaultTransitionablePropertyValues), this._globalState = u;
          }
          getValue(l) {
            return ur(this._values[l].value.value);
          }
          setValue(l, u) {
            Object.prototype.hasOwnProperty.call(this._values, l) || (this._values[l] = new Vi(this._values[l].property, this._globalState)), this._values[l].value = new _i(this._values[l].property, u === null ? void 0 : ur(u), this._globalState);
          }
          getTransition(l) {
            return ur(this._values[l].transition);
          }
          setTransition(l, u) {
            Object.prototype.hasOwnProperty.call(this._values, l) || (this._values[l] = new Vi(this._values[l].property, this._globalState)), this._values[l].transition = ur(u) || void 0;
          }
          serialize() {
            const l = {};
            for (const u of Object.keys(this._values)) {
              const p = this.getValue(u);
              p !== void 0 && (l[u] = p);
              const _ = this.getTransition(u);
              _ !== void 0 && (l[`${u}-transition`] = _);
            }
            return l;
          }
          transitioned(l, u) {
            const p = new fn(this._properties);
            for (const _ of Object.keys(this._values)) p._values[_] = this._values[_].transitioned(l, u._values[_]);
            return p;
          }
          untransitioned() {
            const l = new fn(this._properties);
            for (const u of Object.keys(this._values)) l._values[u] = this._values[u].untransitioned();
            return l;
          }
        }
        class ps {
          constructor(l, u, p, _, x) {
            this.property = l, this.value = u, this.begin = x + _.delay || 0, this.end = this.begin + _.duration || 0, l.specification.transition && (_.delay || _.duration) && (this.prior = p);
          }
          possiblyEvaluate(l, u, p) {
            const _ = l.now || 0, x = this.value.possiblyEvaluate(l, u, p), A = this.prior;
            if (A) {
              if (_ > this.end) return this.prior = null, x;
              if (this.value.isDataDriven()) return this.prior = null, x;
              if (_ < this.begin) return A.possiblyEvaluate(l, u, p);
              {
                const E = (_ - this.begin) / (this.end - this.begin);
                return this.property.interpolate(A.possiblyEvaluate(l, u, p), x, De(E));
              }
            }
            return x;
          }
        }
        class fn {
          constructor(l) {
            this._properties = l, this._values = Object.create(l.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(l, u, p) {
            const _ = new pn(this._properties);
            for (const x of Object.keys(this._values)) _._values[x] = this._values[x].possiblyEvaluate(l, u, p);
            return _;
          }
          hasTransition() {
            for (const l of Object.keys(this._values)) if (this._values[l].prior) return !0;
            return !1;
          }
        }
        class Zn {
          constructor(l, u) {
            this._properties = l, this._values = Object.create(l.defaultPropertyValues), this._globalState = u;
          }
          hasValue(l) {
            return this._values[l].value !== void 0;
          }
          getValue(l) {
            return ur(this._values[l].value);
          }
          setValue(l, u) {
            this._values[l] = new _i(this._values[l].property, u === null ? void 0 : ur(u), this._globalState);
          }
          serialize() {
            const l = {};
            for (const u of Object.keys(this._values)) {
              const p = this.getValue(u);
              p !== void 0 && (l[u] = p);
            }
            return l;
          }
          possiblyEvaluate(l, u, p) {
            const _ = new pn(this._properties);
            for (const x of Object.keys(this._values)) _._values[x] = this._values[x].possiblyEvaluate(l, u, p);
            return _;
          }
        }
        class dn {
          constructor(l, u, p) {
            this.property = l, this.value = u, this.parameters = p;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(l) {
            return this.value.kind === "constant" ? this.value.value : l;
          }
          evaluate(l, u, p, _) {
            return this.property.evaluate(this.value, this.parameters, l, u, p, _);
          }
        }
        class pn {
          constructor(l) {
            this._properties = l, this._values = Object.create(l.defaultPossiblyEvaluatedValues);
          }
          get(l) {
            return this._values[l];
          }
        }
        class Qt {
          constructor(l) {
            this.specification = l;
          }
          possiblyEvaluate(l, u) {
            if (l.isDataDriven()) throw new Error("Value should not be data driven");
            return l.expression.evaluate(u);
          }
          interpolate(l, u, p) {
            const _ = ri[this.specification.type];
            return _ ? _(l, u, p) : l;
          }
        }
        class cr {
          constructor(l, u) {
            this.specification = l, this.overrides = u;
          }
          possiblyEvaluate(l, u, p, _) {
            return new dn(this, l.expression.kind === "constant" || l.expression.kind === "camera" ? { kind: "constant", value: l.expression.evaluate(u, null, {}, p, _) } : l.expression, u);
          }
          interpolate(l, u, p) {
            if (l.value.kind !== "constant" || u.value.kind !== "constant") return l;
            if (l.value.value === void 0 || u.value.value === void 0) return new dn(this, { kind: "constant", value: void 0 }, l.parameters);
            const _ = ri[this.specification.type];
            if (_) {
              const x = _(l.value.value, u.value.value, p);
              return new dn(this, { kind: "constant", value: x }, l.parameters);
            }
            return l;
          }
          evaluate(l, u, p, _, x, A) {
            return l.kind === "constant" ? l.value : l.evaluate(u, p, _, x, A);
          }
        }
        class Zi extends cr {
          possiblyEvaluate(l, u, p, _) {
            if (l.value === void 0) return new dn(this, { kind: "constant", value: void 0 }, u);
            if (l.expression.kind === "constant") {
              const x = l.expression.evaluate(u, null, {}, p, _), A = l.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, E = this._calculate(A, A, A, u);
              return new dn(this, { kind: "constant", value: E }, u);
            }
            if (l.expression.kind === "camera") {
              const x = this._calculate(l.expression.evaluate({ zoom: u.zoom - 1 }), l.expression.evaluate({ zoom: u.zoom }), l.expression.evaluate({ zoom: u.zoom + 1 }), u);
              return new dn(this, { kind: "constant", value: x }, u);
            }
            return new dn(this, l.expression, u);
          }
          evaluate(l, u, p, _, x, A) {
            if (l.kind === "source") {
              const E = l.evaluate(u, p, _, x, A);
              return this._calculate(E, E, E, u);
            }
            return l.kind === "composite" ? this._calculate(l.evaluate({ zoom: Math.floor(u.zoom) - 1 }, p, _), l.evaluate({ zoom: Math.floor(u.zoom) }, p, _), l.evaluate({ zoom: Math.floor(u.zoom) + 1 }, p, _), u) : l.value;
          }
          _calculate(l, u, p, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: l, to: u } : { from: p, to: u };
          }
          interpolate(l) {
            return l;
          }
        }
        class Bi {
          constructor(l) {
            this.specification = l;
          }
          possiblyEvaluate(l, u, p, _) {
            if (l.value !== void 0) {
              if (l.expression.kind === "constant") {
                const x = l.expression.evaluate(u, null, {}, p, _);
                return this._calculate(x, x, x, u);
              }
              return this._calculate(l.expression.evaluate(new Wr(Math.floor(u.zoom - 1), u)), l.expression.evaluate(new Wr(Math.floor(u.zoom), u)), l.expression.evaluate(new Wr(Math.floor(u.zoom + 1), u)), u);
            }
          }
          _calculate(l, u, p, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: l, to: u } : { from: p, to: u };
          }
          interpolate(l) {
            return l;
          }
        }
        class On {
          constructor(l) {
            this.specification = l;
          }
          possiblyEvaluate(l, u, p, _) {
            return !!l.expression.evaluate(u, null, {}, p, _);
          }
          interpolate() {
            return !1;
          }
        }
        class ln {
          constructor(l) {
            this.properties = l, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const u in l) {
              const p = l[u];
              p.specification.overridable && this.overridableProperties.push(u);
              const _ = this.defaultPropertyValues[u] = new _i(p, void 0, void 0), x = this.defaultTransitionablePropertyValues[u] = new Vi(p, void 0);
              this.defaultTransitioningPropertyValues[u] = x.untransitioned(), this.defaultPossiblyEvaluatedValues[u] = _.possiblyEvaluate({});
            }
          }
        }
        me("DataDrivenProperty", cr), me("DataConstantProperty", Qt), me("CrossFadedDataDrivenProperty", Zi), me("CrossFadedProperty", Bi), me("ColorRampProperty", On);
        const Cn = "-transition";
        class gn extends rr {
          constructor(l, u, p) {
            if (super(), this.id = l.id, this.type = l.type, this._globalState = p, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, l.type !== "custom" && (this.metadata = l.metadata, this.minzoom = l.minzoom, this.maxzoom = l.maxzoom, l.type !== "background" && (this.source = l.source, this.sourceLayer = l["source-layer"], this.filter = l.filter, this._featureFilter = El(l.filter, p)), u.layout && (this._unevaluatedLayout = new Zn(u.layout, p)), u.paint)) {
              this._transitionablePaint = new Xn(u.paint, p);
              for (const _ in l.paint) this.setPaintProperty(_, l.paint[_], { validate: !1 });
              for (const _ in l.layout) this.setLayoutProperty(_, l.layout[_], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new pn(u.paint);
            }
          }
          setFilter(l) {
            this.filter = l, this._featureFilter = El(l, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(l) {
            return l === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(l);
          }
          getLayoutAffectingGlobalStateRefs() {
            const l = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const u in this._unevaluatedLayout._values) {
              const p = this._unevaluatedLayout._values[u];
              for (const _ of p.getGlobalStateRefs()) l.add(_);
            }
            for (const u of this._featureFilter.getGlobalStateRefs()) l.add(u);
            return l;
          }
          getPaintAffectingGlobalStateRefs() {
            var l;
            const u = new globalThis.Map();
            if (this._transitionablePaint) for (const p in this._transitionablePaint._values) {
              const _ = this._transitionablePaint._values[p].value;
              for (const x of _.getGlobalStateRefs()) {
                const A = (l = u.get(x)) !== null && l !== void 0 ? l : [];
                A.push({ name: p, value: _.value }), u.set(x, A);
              }
            }
            return u;
          }
          setLayoutProperty(l, u, p = {}) {
            u != null && this._validate(he, `layers.${this.id}.layout.${l}`, l, u, p) || (l !== "visibility" ? this._unevaluatedLayout.setValue(l, u) : this.visibility = u);
          }
          getPaintProperty(l) {
            return l.endsWith(Cn) ? this._transitionablePaint.getTransition(l.slice(0, -11)) : this._transitionablePaint.getValue(l);
          }
          setPaintProperty(l, u, p = {}) {
            if (u != null && this._validate(ae, `layers.${this.id}.paint.${l}`, l, u, p)) return !1;
            if (l.endsWith(Cn)) return this._transitionablePaint.setTransition(l.slice(0, -11), u || void 0), !1;
            {
              const _ = this._transitionablePaint._values[l], x = _.property.specification["property-type"] === "cross-faded-data-driven", A = _.value.isDataDriven(), E = _.value;
              this._transitionablePaint.setValue(l, u), this._handleSpecialPaintPropertyUpdate(l);
              const M = this._transitionablePaint._values[l].value;
              return M.isDataDriven() || A || x || this._handleOverridablePaintPropertyUpdate(l, E, M);
            }
          }
          _handleSpecialPaintPropertyUpdate(l) {
          }
          _handleOverridablePaintPropertyUpdate(l, u, p) {
            return !1;
          }
          isHidden(l, u = !1) {
            return !!(this.minzoom && l < (u ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && l >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(l) {
            this._transitioningPaint = this._transitionablePaint.transitioned(l, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(l, u) {
            l.getCrossfadeParameters && (this._crossfadeParameters = l.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(l, void 0, u)), this.paint = this._transitioningPaint.possiblyEvaluate(l, void 0, u);
          }
          serialize() {
            const l = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (l.layout = l.layout || {}, l.layout.visibility = this.visibility), tr(l, (u, p) => !(u === void 0 || p === "layout" && !Object.keys(u).length || p === "paint" && !Object.keys(u).length));
          }
          _validate(l, u, p, _, x = {}) {
            return (!x || x.validate !== !1) && ge(this, l.call(L, { key: u, layerType: this.type, objectKey: p, value: _, styleSpec: We, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const l in this.paint._values) {
              const u = this.paint.get(l);
              if (u instanceof dn && Tl(u.property.specification) && (u.value.kind === "source" || u.value.kind === "composite") && u.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        let Gi;
        var Yn = { get paint() {
          return Gi = Gi || new ln({ "raster-opacity": new Qt(We.paint_raster["raster-opacity"]), "raster-hue-rotate": new Qt(We.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Qt(We.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Qt(We.paint_raster["raster-brightness-max"]), "raster-saturation": new Qt(We.paint_raster["raster-saturation"]), "raster-contrast": new Qt(We.paint_raster["raster-contrast"]), "raster-resampling": new Qt(We.paint_raster["raster-resampling"]), "raster-fade-duration": new Qt(We.paint_raster["raster-fade-duration"]) });
        } };
        class is extends gn {
          constructor(l, u) {
            super(l, Yn, u);
          }
        }
        const Hs = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class gs {
          constructor(l, u) {
            this._structArray = l, this._pos1 = u * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class wi {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(l, u) {
            return l._trim(), u && (l.isTransferred = !0, u.push(l.arrayBuffer)), { length: l.length, arrayBuffer: l.arrayBuffer };
          }
          static deserialize(l) {
            const u = Object.create(this.prototype);
            return u.arrayBuffer = l.arrayBuffer, u.length = l.length, u.capacity = l.arrayBuffer.byteLength / u.bytesPerElement, u._refreshViews(), u;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(l) {
            this.reserve(l), this.length = l;
          }
          reserve(l) {
            if (l > this.capacity) {
              this.capacity = Math.max(l, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const u = this.uint8;
              this._refreshViews(), u && this.uint8.set(u);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Ai(h, l = 1) {
          let u = 0, p = 0;
          return { members: h.map((_) => {
            const x = Hs[_.type].BYTES_PER_ELEMENT, A = u = no(u, Math.max(l, x)), E = _.components || 1;
            return p = Math.max(p, x), u += x * E, { name: _.name, type: _.type, components: E, offset: A };
          }), size: no(u, Math.max(p, l)), alignment: l };
        }
        function no(h, l) {
          return Math.ceil(h / l) * l;
        }
        class Di extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, l, u);
          }
          emplace(l, u, p) {
            const _ = 2 * l;
            return this.int16[_ + 0] = u, this.int16[_ + 1] = p, l;
          }
        }
        Di.prototype.bytesPerElement = 4, me("StructArrayLayout2i4", Di);
        class In extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, l, u, p);
          }
          emplace(l, u, p, _) {
            const x = 3 * l;
            return this.int16[x + 0] = u, this.int16[x + 1] = p, this.int16[x + 2] = _, l;
          }
        }
        In.prototype.bytesPerElement = 6, me("StructArrayLayout3i6", In);
        class so extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, l, u, p, _);
          }
          emplace(l, u, p, _, x) {
            const A = 4 * l;
            return this.int16[A + 0] = u, this.int16[A + 1] = p, this.int16[A + 2] = _, this.int16[A + 3] = x, l;
          }
        }
        so.prototype.bytesPerElement = 8, me("StructArrayLayout4i8", so);
        class oa extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, l, u, p, _, x, A);
          }
          emplace(l, u, p, _, x, A, E) {
            const M = 6 * l;
            return this.int16[M + 0] = u, this.int16[M + 1] = p, this.int16[M + 2] = _, this.int16[M + 3] = x, this.int16[M + 4] = A, this.int16[M + 5] = E, l;
          }
        }
        oa.prototype.bytesPerElement = 12, me("StructArrayLayout2i4i12", oa);
        class Ro extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, l, u, p, _, x, A);
          }
          emplace(l, u, p, _, x, A, E) {
            const M = 4 * l, O = 8 * l;
            return this.int16[M + 0] = u, this.int16[M + 1] = p, this.uint8[O + 4] = _, this.uint8[O + 5] = x, this.uint8[O + 6] = A, this.uint8[O + 7] = E, l;
          }
        }
        Ro.prototype.bytesPerElement = 8, me("StructArrayLayout2i4ub8", Ro);
        class wn extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(l, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, l, u);
          }
          emplace(l, u, p) {
            const _ = 2 * l;
            return this.float32[_ + 0] = u, this.float32[_ + 1] = p, l;
          }
        }
        wn.prototype.bytesPerElement = 8, me("StructArrayLayout2f8", wn);
        class Qc extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A, E, M, O, N) {
            const V = this.length;
            return this.resize(V + 1), this.emplace(V, l, u, p, _, x, A, E, M, O, N);
          }
          emplace(l, u, p, _, x, A, E, M, O, N, V) {
            const Y = 10 * l;
            return this.uint16[Y + 0] = u, this.uint16[Y + 1] = p, this.uint16[Y + 2] = _, this.uint16[Y + 3] = x, this.uint16[Y + 4] = A, this.uint16[Y + 5] = E, this.uint16[Y + 6] = M, this.uint16[Y + 7] = O, this.uint16[Y + 8] = N, this.uint16[Y + 9] = V, l;
          }
        }
        Qc.prototype.bytesPerElement = 20, me("StructArrayLayout10ui20", Qc);
        class Cl extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A, E, M) {
            const O = this.length;
            return this.resize(O + 1), this.emplace(O, l, u, p, _, x, A, E, M);
          }
          emplace(l, u, p, _, x, A, E, M, O) {
            const N = 8 * l;
            return this.uint16[N + 0] = u, this.uint16[N + 1] = p, this.uint16[N + 2] = _, this.uint16[N + 3] = x, this.uint16[N + 4] = A, this.uint16[N + 5] = E, this.uint16[N + 6] = M, this.uint16[N + 7] = O, l;
          }
        }
        Cl.prototype.bytesPerElement = 16, me("StructArrayLayout8ui16", Cl);
        class wa extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A, E, M, O, N, V, Y) {
            const ee = this.length;
            return this.resize(ee + 1), this.emplace(ee, l, u, p, _, x, A, E, M, O, N, V, Y);
          }
          emplace(l, u, p, _, x, A, E, M, O, N, V, Y, ee) {
            const ie = 12 * l;
            return this.int16[ie + 0] = u, this.int16[ie + 1] = p, this.int16[ie + 2] = _, this.int16[ie + 3] = x, this.uint16[ie + 4] = A, this.uint16[ie + 5] = E, this.uint16[ie + 6] = M, this.uint16[ie + 7] = O, this.int16[ie + 8] = N, this.int16[ie + 9] = V, this.int16[ie + 10] = Y, this.int16[ie + 11] = ee, l;
          }
        }
        wa.prototype.bytesPerElement = 24, me("StructArrayLayout4i4ui4i24", wa);
        class rc extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, l, u, p);
          }
          emplace(l, u, p, _) {
            const x = 3 * l;
            return this.float32[x + 0] = u, this.float32[x + 1] = p, this.float32[x + 2] = _, l;
          }
        }
        rc.prototype.bytesPerElement = 12, me("StructArrayLayout3f12", rc);
        class vh extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(l) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, l);
          }
          emplace(l, u) {
            return this.uint32[1 * l + 0] = u, l;
          }
        }
        vh.prototype.bytesPerElement = 4, me("StructArrayLayout1ul4", vh);
        class ic extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A, E, M, O) {
            const N = this.length;
            return this.resize(N + 1), this.emplace(N, l, u, p, _, x, A, E, M, O);
          }
          emplace(l, u, p, _, x, A, E, M, O, N) {
            const V = 10 * l, Y = 5 * l;
            return this.int16[V + 0] = u, this.int16[V + 1] = p, this.int16[V + 2] = _, this.int16[V + 3] = x, this.int16[V + 4] = A, this.int16[V + 5] = E, this.uint32[Y + 3] = M, this.uint16[V + 8] = O, this.uint16[V + 9] = N, l;
          }
        }
        ic.prototype.bytesPerElement = 20, me("StructArrayLayout6i1ul2ui20", ic);
        class Gu extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, l, u, p, _, x, A);
          }
          emplace(l, u, p, _, x, A, E) {
            const M = 6 * l;
            return this.int16[M + 0] = u, this.int16[M + 1] = p, this.int16[M + 2] = _, this.int16[M + 3] = x, this.int16[M + 4] = A, this.int16[M + 5] = E, l;
          }
        }
        Gu.prototype.bytesPerElement = 12, me("StructArrayLayout2i2i2i12", Gu);
        class Aa extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x) {
            const A = this.length;
            return this.resize(A + 1), this.emplace(A, l, u, p, _, x);
          }
          emplace(l, u, p, _, x, A) {
            const E = 4 * l, M = 8 * l;
            return this.float32[E + 0] = u, this.float32[E + 1] = p, this.float32[E + 2] = _, this.int16[M + 6] = x, this.int16[M + 7] = A, l;
          }
        }
        Aa.prototype.bytesPerElement = 16, me("StructArrayLayout2f1f2i16", Aa);
        class xh extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, l, u, p, _, x, A);
          }
          emplace(l, u, p, _, x, A, E) {
            const M = 16 * l, O = 4 * l, N = 8 * l;
            return this.uint8[M + 0] = u, this.uint8[M + 1] = p, this.float32[O + 1] = _, this.float32[O + 2] = x, this.int16[N + 6] = A, this.int16[N + 7] = E, l;
          }
        }
        xh.prototype.bytesPerElement = 16, me("StructArrayLayout2ub2f2i16", xh);
        class wh extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, l, u, p);
          }
          emplace(l, u, p, _) {
            const x = 3 * l;
            return this.uint16[x + 0] = u, this.uint16[x + 1] = p, this.uint16[x + 2] = _, l;
          }
        }
        wh.prototype.bytesPerElement = 6, me("StructArrayLayout3ui6", wh);
        class v extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie, ue, ve, Re) {
            const it = this.length;
            return this.resize(it + 1), this.emplace(it, l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie, ue, ve, Re);
          }
          emplace(l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie, ue, ve, Re, it) {
            const ze = 24 * l, Ze = 12 * l, yt = 48 * l;
            return this.int16[ze + 0] = u, this.int16[ze + 1] = p, this.uint16[ze + 2] = _, this.uint16[ze + 3] = x, this.uint32[Ze + 2] = A, this.uint32[Ze + 3] = E, this.uint32[Ze + 4] = M, this.uint16[ze + 10] = O, this.uint16[ze + 11] = N, this.uint16[ze + 12] = V, this.float32[Ze + 7] = Y, this.float32[Ze + 8] = ee, this.uint8[yt + 36] = ie, this.uint8[yt + 37] = ue, this.uint8[yt + 38] = ve, this.uint32[Ze + 10] = Re, this.int16[ze + 22] = it, l;
          }
        }
        v.prototype.bytesPerElement = 48, me("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", v);
        class a extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie, ue, ve, Re, it, ze, Ze, yt, Pt, Gt, or, er, nr, Ar, ir) {
            const sr = this.length;
            return this.resize(sr + 1), this.emplace(sr, l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie, ue, ve, Re, it, ze, Ze, yt, Pt, Gt, or, er, nr, Ar, ir);
          }
          emplace(l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie, ue, ve, Re, it, ze, Ze, yt, Pt, Gt, or, er, nr, Ar, ir, sr) {
            const Ft = 32 * l, Gr = 16 * l;
            return this.int16[Ft + 0] = u, this.int16[Ft + 1] = p, this.int16[Ft + 2] = _, this.int16[Ft + 3] = x, this.int16[Ft + 4] = A, this.int16[Ft + 5] = E, this.int16[Ft + 6] = M, this.int16[Ft + 7] = O, this.uint16[Ft + 8] = N, this.uint16[Ft + 9] = V, this.uint16[Ft + 10] = Y, this.uint16[Ft + 11] = ee, this.uint16[Ft + 12] = ie, this.uint16[Ft + 13] = ue, this.uint16[Ft + 14] = ve, this.uint16[Ft + 15] = Re, this.uint16[Ft + 16] = it, this.uint16[Ft + 17] = ze, this.uint16[Ft + 18] = Ze, this.uint16[Ft + 19] = yt, this.uint16[Ft + 20] = Pt, this.uint16[Ft + 21] = Gt, this.uint16[Ft + 22] = or, this.uint32[Gr + 12] = er, this.float32[Gr + 13] = nr, this.float32[Gr + 14] = Ar, this.uint16[Ft + 30] = ir, this.uint16[Ft + 31] = sr, l;
          }
        }
        a.prototype.bytesPerElement = 64, me("StructArrayLayout8i15ui1ul2f2ui64", a);
        class f extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(l) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, l);
          }
          emplace(l, u) {
            return this.float32[1 * l + 0] = u, l;
          }
        }
        f.prototype.bytesPerElement = 4, me("StructArrayLayout1f4", f);
        class g extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, l, u, p);
          }
          emplace(l, u, p, _) {
            const x = 3 * l;
            return this.uint16[6 * l + 0] = u, this.float32[x + 1] = p, this.float32[x + 2] = _, l;
          }
        }
        g.prototype.bytesPerElement = 12, me("StructArrayLayout1ui2f12", g);
        class b extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, l, u, p);
          }
          emplace(l, u, p, _) {
            const x = 4 * l;
            return this.uint32[2 * l + 0] = u, this.uint16[x + 2] = p, this.uint16[x + 3] = _, l;
          }
        }
        b.prototype.bytesPerElement = 8, me("StructArrayLayout1ul2ui8", b);
        class w extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, l, u);
          }
          emplace(l, u, p) {
            const _ = 2 * l;
            return this.uint16[_ + 0] = u, this.uint16[_ + 1] = p, l;
          }
        }
        w.prototype.bytesPerElement = 4, me("StructArrayLayout2ui4", w);
        class S extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(l) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, l);
          }
          emplace(l, u) {
            return this.uint16[1 * l + 0] = u, l;
          }
        }
        S.prototype.bytesPerElement = 2, me("StructArrayLayout1ui2", S);
        class R extends wi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(l, u, p, _) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, l, u, p, _);
          }
          emplace(l, u, p, _, x) {
            const A = 4 * l;
            return this.float32[A + 0] = u, this.float32[A + 1] = p, this.float32[A + 2] = _, this.float32[A + 3] = x, l;
          }
        }
        R.prototype.bytesPerElement = 16, me("StructArrayLayout4f16", R);
        class B extends gs {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new d(this.anchorPointX, this.anchorPointY);
          }
        }
        B.prototype.size = 20;
        class U extends ic {
          get(l) {
            return new B(this, l);
          }
        }
        me("CollisionBoxArray", U);
        class j extends gs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(l) {
            this._structArray.uint8[this._pos1 + 37] = l;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(l) {
            this._structArray.uint8[this._pos1 + 38] = l;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(l) {
            this._structArray.uint32[this._pos4 + 10] = l;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        j.prototype.size = 48;
        class X extends v {
          get(l) {
            return new j(this, l);
          }
        }
        me("PlacedSymbolArray", X);
        class q extends gs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(l) {
            this._structArray.uint32[this._pos4 + 12] = l;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        q.prototype.size = 64;
        class Q extends a {
          get(l) {
            return new q(this, l);
          }
        }
        me("SymbolInstanceArray", Q);
        class ce extends f {
          getoffsetX(l) {
            return this.float32[1 * l + 0];
          }
        }
        me("GlyphOffsetArray", ce);
        class we extends In {
          getx(l) {
            return this.int16[3 * l + 0];
          }
          gety(l) {
            return this.int16[3 * l + 1];
          }
          gettileUnitDistanceFromAnchor(l) {
            return this.int16[3 * l + 2];
          }
        }
        me("SymbolLineVertexArray", we);
        class Ae extends gs {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Ae.prototype.size = 12;
        class Se extends g {
          get(l) {
            return new Ae(this, l);
          }
        }
        me("TextAnchorOffsetArray", Se);
        class Me extends gs {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        Me.prototype.size = 8;
        class Ge extends b {
          get(l) {
            return new Me(this, l);
          }
        }
        me("FeatureIndexArray", Ge);
        class Le extends Di {
        }
        class $e extends Di {
        }
        class Xe extends Di {
        }
        class Fe extends oa {
        }
        class Qe extends Ro {
        }
        class At extends wn {
        }
        class ft extends Qc {
        }
        class dt extends Cl {
        }
        class _t extends wa {
        }
        class qt extends rc {
        }
        class Zt extends vh {
        }
        class zt extends Gu {
        }
        class pr extends xh {
        }
        class Vr extends wh {
        }
        class Ti extends w {
        }
        const $i = Ai([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: cn } = $i;
        class hi {
          constructor(l = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = l;
          }
          prepareSegment(l, u, p, _) {
            const x = this.segments[this.segments.length - 1];
            return l > hi.MAX_VERTEX_ARRAY_LENGTH && Ct(`Max vertices per segment is ${hi.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${l}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${hi.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !x || x.vertexLength + l > hi.MAX_VERTEX_ARRAY_LENGTH || x.sortKey !== _ ? this.createNewSegment(u, p, _) : x;
          }
          createNewSegment(l, u, p) {
            const _ = { vertexOffset: l.length, primitiveOffset: u.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return p !== void 0 && (_.sortKey = p), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(_), _;
          }
          getOrCreateLatestSegment(l, u, p) {
            return this.prepareSegment(0, l, u, p);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const l of this.segments) for (const u in l.vaos) l.vaos[u].destroy();
          }
          static simpleSegment(l, u, p, _) {
            return new hi([{ vertexOffset: l, primitiveOffset: u, vertexLength: p, primitiveLength: _, vaos: {}, sortKey: 0 }]);
          }
        }
        function en(h, l) {
          return 256 * (h = rt(Math.floor(h), 0, 255)) + rt(Math.floor(l), 0, 255);
        }
        hi.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, me("SegmentVector", hi);
        const ms = Ai([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), Pn = Ai([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var Cs, jn, Jn, Is = { exports: {} }, eu = { exports: {} }, tu = { exports: {} }, $u = function() {
          if (Jn) return Is.exports;
          Jn = 1;
          var h = (Cs || (Cs = 1, eu.exports = function(u, p) {
            var _, x, A, E, M, O, N, V;
            for (x = u.length - (_ = 3 & u.length), A = p, M = 3432918353, O = 461845907, V = 0; V < x; ) N = 255 & u.charCodeAt(V) | (255 & u.charCodeAt(++V)) << 8 | (255 & u.charCodeAt(++V)) << 16 | (255 & u.charCodeAt(++V)) << 24, ++V, A = 27492 + (65535 & (E = 5 * (65535 & (A = (A ^= N = (65535 & (N = (N = (65535 & N) * M + (((N >>> 16) * M & 65535) << 16) & 4294967295) << 15 | N >>> 17)) * O + (((N >>> 16) * O & 65535) << 16) & 4294967295) << 13 | A >>> 19)) + ((5 * (A >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (E >>> 16) & 65535) << 16);
            switch (N = 0, _) {
              case 3:
                N ^= (255 & u.charCodeAt(V + 2)) << 16;
              case 2:
                N ^= (255 & u.charCodeAt(V + 1)) << 8;
              case 1:
                A ^= N = (65535 & (N = (N = (65535 & (N ^= 255 & u.charCodeAt(V))) * M + (((N >>> 16) * M & 65535) << 16) & 4294967295) << 15 | N >>> 17)) * O + (((N >>> 16) * O & 65535) << 16) & 4294967295;
            }
            return A ^= u.length, A = 2246822507 * (65535 & (A ^= A >>> 16)) + ((2246822507 * (A >>> 16) & 65535) << 16) & 4294967295, A = 3266489909 * (65535 & (A ^= A >>> 13)) + ((3266489909 * (A >>> 16) & 65535) << 16) & 4294967295, (A ^= A >>> 16) >>> 0;
          }), eu.exports), l = (jn || (jn = 1, tu.exports = function(u, p) {
            for (var _, x = u.length, A = p ^ x, E = 0; x >= 4; ) _ = 1540483477 * (65535 & (_ = 255 & u.charCodeAt(E) | (255 & u.charCodeAt(++E)) << 8 | (255 & u.charCodeAt(++E)) << 16 | (255 & u.charCodeAt(++E)) << 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16), A = 1540483477 * (65535 & A) + ((1540483477 * (A >>> 16) & 65535) << 16) ^ (_ = 1540483477 * (65535 & (_ ^= _ >>> 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16)), x -= 4, ++E;
            switch (x) {
              case 3:
                A ^= (255 & u.charCodeAt(E + 2)) << 16;
              case 2:
                A ^= (255 & u.charCodeAt(E + 1)) << 8;
              case 1:
                A = 1540483477 * (65535 & (A ^= 255 & u.charCodeAt(E))) + ((1540483477 * (A >>> 16) & 65535) << 16);
            }
            return A = 1540483477 * (65535 & (A ^= A >>> 13)) + ((1540483477 * (A >>> 16) & 65535) << 16), (A ^= A >>> 15) >>> 0;
          }), tu.exports);
          return Is.exports = h, Is.exports.murmur3 = h, Is.exports.murmur2 = l, Is.exports;
        }(), ru = m($u);
        class Hu {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(l, u, p, _) {
            this.ids.push(pf(l)), this.positions.push(u, p, _);
          }
          getPositions(l) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const u = pf(l);
            let p = 0, _ = this.ids.length - 1;
            for (; p < _; ) {
              const A = p + _ >> 1;
              this.ids[A] >= u ? _ = A : p = A + 1;
            }
            const x = [];
            for (; this.ids[p] === u; ) x.push({ index: this.positions[3 * p], start: this.positions[3 * p + 1], end: this.positions[3 * p + 2] }), p++;
            return x;
          }
          static serialize(l, u) {
            const p = new Float64Array(l.ids), _ = new Uint32Array(l.positions);
            return iu(p, _, 0, p.length - 1), u && u.push(p.buffer, _.buffer), { ids: p, positions: _ };
          }
          static deserialize(l) {
            const u = new Hu();
            return u.ids = l.ids, u.positions = l.positions, u.indexed = !0, u;
          }
        }
        function pf(h) {
          const l = +h;
          return !isNaN(l) && l <= Number.MAX_SAFE_INTEGER ? l : ru(String(h));
        }
        function iu(h, l, u, p) {
          for (; u < p; ) {
            const _ = h[u + p >> 1];
            let x = u - 1, A = p + 1;
            for (; ; ) {
              do
                x++;
              while (h[x] < _);
              do
                A--;
              while (h[A] > _);
              if (x >= A) break;
              bo(h, x, A), bo(l, 3 * x, 3 * A), bo(l, 3 * x + 1, 3 * A + 1), bo(l, 3 * x + 2, 3 * A + 2);
            }
            A - u < p - A ? (iu(h, l, u, A), u = A + 1) : (iu(h, l, A + 1, p), p = A);
          }
        }
        function bo(h, l, u) {
          const p = h[l];
          h[l] = h[u], h[u] = p;
        }
        me("FeaturePositionMap", Hu);
        class oo {
          constructor(l, u) {
            this.gl = l.gl, this.location = u;
          }
        }
        class Il extends oo {
          constructor(l, u) {
            super(l, u), this.current = 0;
          }
          set(l) {
            this.current !== l && (this.current = l, this.gl.uniform1f(this.location, l));
          }
        }
        class Ah extends oo {
          constructor(l, u) {
            super(l, u), this.current = [0, 0, 0, 0];
          }
          set(l) {
            l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] && l[3] === this.current[3] || (this.current = l, this.gl.uniform4f(this.location, l[0], l[1], l[2], l[3]));
          }
        }
        class ns extends oo {
          constructor(l, u) {
            super(l, u), this.current = jr.transparent;
          }
          set(l) {
            l.r === this.current.r && l.g === this.current.g && l.b === this.current.b && l.a === this.current.a || (this.current = l, this.gl.uniform4f(this.location, l.r, l.g, l.b, l.a));
          }
        }
        const Ps = new Float32Array(16);
        function Lo(h) {
          return [en(255 * h.r, 255 * h.g), en(255 * h.b, 255 * h.a)];
        }
        class Vn {
          constructor(l, u, p) {
            this.value = l, this.uniformNames = u.map((_) => `u_${_}`), this.type = p;
          }
          setUniform(l, u, p) {
            l.set(p.constantOr(this.value));
          }
          getBinding(l, u, p) {
            return this.type === "color" ? new ns(l, u) : new Il(l, u);
          }
        }
        class qu {
          constructor(l, u) {
            this.uniformNames = u.map((p) => `u_${p}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(l, u) {
            this.pixelRatioFrom = u.pixelRatio, this.pixelRatioTo = l.pixelRatio, this.patternFrom = u.tlbr, this.patternTo = l.tlbr;
          }
          setConstantDashPositions(l, u) {
            this.dashTo = [0, l.y, l.height, l.width], this.dashFrom = [0, u.y, u.height, u.width];
          }
          setUniform(l, u, p, _) {
            let x = null;
            _ === "u_pattern_to" ? x = this.patternTo : _ === "u_pattern_from" ? x = this.patternFrom : _ === "u_dasharray_to" ? x = this.dashTo : _ === "u_dasharray_from" ? x = this.dashFrom : _ === "u_pixel_ratio_to" ? x = this.pixelRatioTo : _ === "u_pixel_ratio_from" && (x = this.pixelRatioFrom), x !== null && l.set(x);
          }
          getBinding(l, u, p) {
            return p.substr(0, 9) === "u_pattern" || p.substr(0, 12) === "u_dasharray_" ? new Ah(l, u) : new Il(l, u);
          }
        }
        class nc {
          constructor(l, u, p, _) {
            this.expression = l, this.type = p, this.maxValue = 0, this.paintVertexAttributes = u.map((x) => ({ name: `a_${x}`, type: "Float32", components: p === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new _();
          }
          populatePaintArray(l, u, p) {
            const _ = this.paintVertexArray.length, x = this.expression.evaluate(new Wr(0, p), u, {}, p.canonical, [], p.formattedSection);
            this.paintVertexArray.resize(l), this._setPaintValue(_, l, x);
          }
          updatePaintArray(l, u, p, _, x) {
            const A = this.expression.evaluate(new Wr(0, x), p, _);
            this._setPaintValue(l, u, A);
          }
          _setPaintValue(l, u, p) {
            if (this.type === "color") {
              const _ = Lo(p);
              for (let x = l; x < u; x++) this.paintVertexArray.emplace(x, _[0], _[1]);
            } else {
              for (let _ = l; _ < u; _++) this.paintVertexArray.emplace(_, p);
              this.maxValue = Math.max(this.maxValue, Math.abs(p));
            }
          }
          upload(l) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = l.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class qa {
          constructor(l, u, p, _, x, A) {
            this.expression = l, this.uniformNames = u.map((E) => `u_${E}_t`), this.type = p, this.useIntegerZoom = _, this.zoom = x, this.maxValue = 0, this.paintVertexAttributes = u.map((E) => ({ name: `a_${E}`, type: "Float32", components: p === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new A();
          }
          populatePaintArray(l, u, p) {
            const _ = this.expression.evaluate(new Wr(this.zoom, p), u, {}, p.canonical, [], p.formattedSection), x = this.expression.evaluate(new Wr(this.zoom + 1, p), u, {}, p.canonical, [], p.formattedSection), A = this.paintVertexArray.length;
            this.paintVertexArray.resize(l), this._setPaintValue(A, l, _, x);
          }
          updatePaintArray(l, u, p, _, x) {
            const A = this.expression.evaluate(new Wr(this.zoom, x), p, _), E = this.expression.evaluate(new Wr(this.zoom + 1, x), p, _);
            this._setPaintValue(l, u, A, E);
          }
          _setPaintValue(l, u, p, _) {
            if (this.type === "color") {
              const x = Lo(p), A = Lo(_);
              for (let E = l; E < u; E++) this.paintVertexArray.emplace(E, x[0], x[1], A[0], A[1]);
            } else {
              for (let x = l; x < u; x++) this.paintVertexArray.emplace(x, p, _);
              this.maxValue = Math.max(this.maxValue, Math.abs(p), Math.abs(_));
            }
          }
          upload(l) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = l.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(l, u) {
            const p = this.useIntegerZoom ? Math.floor(u.zoom) : u.zoom, _ = rt(this.expression.interpolationFactor(p, this.zoom, this.zoom + 1), 0, 1);
            l.set(_);
          }
          getBinding(l, u, p) {
            return new Il(l, u);
          }
        }
        class nu {
          constructor(l, u, p, _, x, A) {
            this.expression = l, this.type = u, this.useIntegerZoom = p, this.zoom = _, this.layerId = A, this.zoomInPaintVertexArray = new x(), this.zoomOutPaintVertexArray = new x();
          }
          populatePaintArray(l, u, p) {
            const _ = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(l), this.zoomOutPaintVertexArray.resize(l), this._setPaintValues(_, l, this.getPositionIds(u), p);
          }
          updatePaintArray(l, u, p, _, x) {
            this._setPaintValues(l, u, this.getPositionIds(p), x);
          }
          _setPaintValues(l, u, p, _) {
            const x = this.getPositions(_);
            if (!x || !p) return;
            const A = x[p.min], E = x[p.mid], M = x[p.max];
            if (A && E && M) for (let O = l; O < u; O++) this.emplace(this.zoomInPaintVertexArray, O, E, A), this.emplace(this.zoomOutPaintVertexArray, O, E, M);
          }
          upload(l) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const u = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = l.createVertexBuffer(this.zoomInPaintVertexArray, u, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = l.createVertexBuffer(this.zoomOutPaintVertexArray, u, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Tm extends nu {
          getPositions(l) {
            return l.imagePositions;
          }
          getPositionIds(l) {
            return l.patterns && l.patterns[this.layerId];
          }
          getVertexAttributes() {
            return ms.members;
          }
          emplace(l, u, p, _) {
            l.emplace(u, p.tlbr[0], p.tlbr[1], p.tlbr[2], p.tlbr[3], _.tlbr[0], _.tlbr[1], _.tlbr[2], _.tlbr[3], p.pixelRatio, _.pixelRatio);
          }
        }
        class Sm extends nu {
          getPositions(l) {
            return l.dashPositions;
          }
          getPositionIds(l) {
            return l.dashes && l.dashes[this.layerId];
          }
          getVertexAttributes() {
            return Pn.members;
          }
          emplace(l, u, p, _) {
            l.emplace(u, 0, p.y, p.height, p.width, 0, _.y, _.height, _.width);
          }
        }
        class su {
          constructor(l, u, p) {
            this.binders = {}, this._buffers = [];
            const _ = [];
            for (const x in l.paint._values) {
              if (!p(x)) continue;
              const A = l.paint.get(x);
              if (!(A instanceof dn && Tl(A.property.specification))) continue;
              const E = Em(x, l.type), M = A.value, O = A.property.specification.type, N = A.property.useIntegerZoom, V = A.property.specification["property-type"], Y = V === "cross-faded" || V === "cross-faded-data-driven";
              if (M.kind === "constant") this.binders[x] = Y ? new qu(M.value, E) : new Vn(M.value, E, O), _.push(`/u_${x}`);
              else if (M.kind === "source" || Y) {
                const ee = $p(x, O, "source");
                this.binders[x] = Y ? x === "line-dasharray" ? new Sm(M, O, N, u, ee, l.id) : new Tm(M, O, N, u, ee, l.id) : new nc(M, E, O, ee), _.push(`/a_${x}`);
              } else {
                const ee = $p(x, O, "composite");
                this.binders[x] = new qa(M, E, O, N, u, ee), _.push(`/z_${x}`);
              }
            }
            this.cacheKey = _.sort().join("");
          }
          getMaxValue(l) {
            const u = this.binders[l];
            return u instanceof nc || u instanceof qa ? u.maxValue : 0;
          }
          populatePaintArrays(l, u, p) {
            for (const _ in this.binders) {
              const x = this.binders[_];
              (x instanceof nc || x instanceof qa || x instanceof nu) && x.populatePaintArray(l, u, p);
            }
          }
          setConstantPatternPositions(l, u) {
            for (const p in this.binders) {
              const _ = this.binders[p];
              _ instanceof qu && _.setConstantPatternPositions(l, u);
            }
          }
          setConstantDashPositions(l, u) {
            for (const p in this.binders) {
              const _ = this.binders[p];
              _ instanceof qu && _.setConstantDashPositions(l, u);
            }
          }
          updatePaintArrays(l, u, p, _, x) {
            let A = !1;
            for (const E in l) {
              const M = u.getPositions(E);
              for (const O of M) {
                const N = p.feature(O.index);
                for (const V in this.binders) {
                  const Y = this.binders[V];
                  if ((Y instanceof nc || Y instanceof qa || Y instanceof nu) && Y.expression.isStateDependent === !0) {
                    const ee = _.paint.get(V);
                    Y.expression = ee.value, Y.updatePaintArray(O.start, O.end, N, l[E], x), A = !0;
                  }
                }
              }
            }
            return A;
          }
          defines() {
            const l = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              (p instanceof Vn || p instanceof qu) && l.push(...p.uniformNames.map((_) => `#define HAS_UNIFORM_${_}`));
            }
            return l;
          }
          getBinderAttributes() {
            const l = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              if (p instanceof nc || p instanceof qa) for (let _ = 0; _ < p.paintVertexAttributes.length; _++) l.push(p.paintVertexAttributes[_].name);
              else if (p instanceof nu) {
                const _ = p.getVertexAttributes();
                for (const x of _) l.push(x.name);
              }
            }
            return l;
          }
          getBinderUniforms() {
            const l = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              if (p instanceof Vn || p instanceof qu || p instanceof qa) for (const _ of p.uniformNames) l.push(_);
            }
            return l;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(l, u) {
            const p = [];
            for (const _ in this.binders) {
              const x = this.binders[_];
              if (x instanceof Vn || x instanceof qu || x instanceof qa) {
                for (const A of x.uniformNames) if (u[A]) {
                  const E = x.getBinding(l, u[A], A);
                  p.push({ name: A, property: _, binding: E });
                }
              }
            }
            return p;
          }
          setUniforms(l, u, p, _) {
            for (const { name: x, property: A, binding: E } of u) this.binders[A].setUniform(E, _, p.get(A), x);
          }
          updatePaintBuffers(l) {
            this._buffers = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              if (l && p instanceof nu) {
                const _ = l.fromScale === 2 ? p.zoomInPaintVertexBuffer : p.zoomOutPaintVertexBuffer;
                _ && this._buffers.push(_);
              } else (p instanceof nc || p instanceof qa) && p.paintVertexBuffer && this._buffers.push(p.paintVertexBuffer);
            }
          }
          upload(l) {
            for (const u in this.binders) {
              const p = this.binders[u];
              (p instanceof nc || p instanceof qa || p instanceof nu) && p.upload(l);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const l in this.binders) {
              const u = this.binders[l];
              (u instanceof nc || u instanceof qa || u instanceof nu) && u.destroy();
            }
          }
        }
        class ou {
          constructor(l, u, p = () => !0) {
            this.programConfigurations = {};
            for (const _ of l) this.programConfigurations[_.id] = new su(_, u, p);
            this.needsUpload = !1, this._featureMap = new Hu(), this._bufferOffset = 0;
          }
          populatePaintArrays(l, u, p, _) {
            for (const x in this.programConfigurations) this.programConfigurations[x].populatePaintArrays(l, u, _);
            u.id !== void 0 && this._featureMap.add(u.id, p, this._bufferOffset, l), this._bufferOffset = l, this.needsUpload = !0;
          }
          updatePaintArrays(l, u, p, _) {
            for (const x of p) this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(l, this._featureMap, u, x, _) || this.needsUpload;
          }
          get(l) {
            return this.programConfigurations[l];
          }
          upload(l) {
            if (this.needsUpload) {
              for (const u in this.programConfigurations) this.programConfigurations[u].upload(l);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const l in this.programConfigurations) this.programConfigurations[l].destroy();
          }
        }
        function Em(h, l) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[h] || [h.replace(`${l}-`, "").replace(/-/g, "_")];
        }
        function $p(h, l, u) {
          const p = { color: { source: wn, composite: R }, number: { source: f, composite: wn } }, _ = function(x) {
            return { "line-pattern": { source: ft, composite: ft }, "fill-pattern": { source: ft, composite: ft }, "fill-extrusion-pattern": { source: ft, composite: ft }, "line-dasharray": { source: dt, composite: dt } }[x];
          }(h);
          return _ && _[u] || p[l][u];
        }
        me("ConstantBinder", Vn), me("CrossFadedConstantBinder", qu), me("SourceExpressionBinder", nc), me("CrossFadedPatternBinder", Tm), me("CrossFadedDasharrayBinder", Sm), me("CompositeExpressionBinder", qa), me("ProgramConfiguration", su, { omit: ["_buffers"] }), me("ProgramConfigurationSet", ou);
        const gf = Math.pow(2, 14) - 1, Hp = -gf - 1;
        function sc(h) {
          const l = wt / h.extent, u = h.loadGeometry();
          for (let p = 0; p < u.length; p++) {
            const _ = u[p];
            for (let x = 0; x < _.length; x++) {
              const A = _[x], E = Math.round(A.x * l), M = Math.round(A.y * l);
              A.x = rt(E, Hp, gf), A.y = rt(M, Hp, gf), (E < A.x || E > A.x + 1 || M < A.y || M > A.y + 1) && Ct("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return u;
        }
        function mf(h, l) {
          return { type: h.type, id: h.id, properties: h.properties, geometry: l ? sc(h) : [] };
        }
        const aw = -32768;
        function w4(h, l, u, p, _) {
          h.emplaceBack(aw + 8 * l + p, aw + 8 * u + _);
        }
        class y0 {
          constructor(l) {
            this.zoom = l.zoom, this.overscaling = l.overscaling, this.layers = l.layers, this.layerIds = this.layers.map((u) => u.id), this.index = l.index, this.hasDependencies = !1, this.layoutVertexArray = new $e(), this.indexArray = new Vr(), this.segments = new hi(), this.programConfigurations = new ou(l.layers, l.zoom), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(l, u, p) {
            const _ = this.layers[0], x = [];
            let A = null, E = !1, M = _.type === "heatmap";
            if (_.type === "circle") {
              const N = _;
              A = N.layout.get("circle-sort-key"), E = !A.isConstant(), M = M || N.paint.get("circle-pitch-alignment") === "map";
            }
            const O = M ? u.subdivisionGranularity.circle : 1;
            for (const { feature: N, id: V, index: Y, sourceLayerIndex: ee } of l) {
              const ie = this.layers[0]._featureFilter.needGeometry, ue = mf(N, ie);
              if (!this.layers[0]._featureFilter.filter(new Wr(this.zoom), ue, p)) continue;
              const ve = E ? A.evaluate(ue, {}, p) : void 0, Re = { id: V, properties: N.properties, type: N.type, sourceLayerIndex: ee, index: Y, geometry: ie ? ue.geometry : sc(N), patterns: {}, sortKey: ve };
              x.push(Re);
            }
            E && x.sort((N, V) => N.sortKey - V.sortKey);
            for (const N of x) {
              const { geometry: V, index: Y, sourceLayerIndex: ee } = N, ie = l[Y].feature;
              this.addFeature(N, V, Y, p, O), u.featureIndex.insert(ie, V, Y, ee, this.index);
            }
          }
          update(l, u, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(l, u, this.stateDependentLayers, { imagePositions: p });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(l) {
            this.uploaded || (this.layoutVertexBuffer = l.createVertexBuffer(this.layoutVertexArray, cn), this.indexBuffer = l.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(l), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(l, u, p, _, x = 1) {
            let A;
            switch (x) {
              case 1:
                A = [0, 7];
                break;
              case 3:
                A = [0, 2, 5, 7];
                break;
              case 5:
                A = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                A = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${x}; valid values are 1, 3, 5, 7.`);
            }
            const E = A.length;
            for (const M of u) for (const O of M) {
              const N = O.x, V = O.y;
              if (N < 0 || N >= wt || V < 0 || V >= wt) continue;
              const Y = this.segments.prepareSegment(E * E, this.layoutVertexArray, this.indexArray, l.sortKey), ee = Y.vertexLength;
              for (let ie = 0; ie < E; ie++) for (let ue = 0; ue < E; ue++) w4(this.layoutVertexArray, N, V, A[ue], A[ie]);
              for (let ie = 0; ie < E - 1; ie++) for (let ue = 0; ue < E - 1; ue++) {
                const ve = ee + ie * E + ue, Re = ee + (ie + 1) * E + ue;
                this.indexArray.emplaceBack(ve, Re + 1, ve + 1), this.indexArray.emplaceBack(ve, Re, Re + 1);
              }
              Y.vertexLength += E * E, Y.primitiveLength += (E - 1) * (E - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, l, p, { imagePositions: {}, canonical: _ });
          }
        }
        function lw(h, l) {
          for (let u = 0; u < h.length; u++) if (xd(l, h[u])) return !0;
          for (let u = 0; u < l.length; u++) if (xd(h, l[u])) return !0;
          return !!b0(h, l);
        }
        function Cm(h, l, u) {
          return !!xd(h, l) || !!v0(l, h, u);
        }
        function cw(h, l) {
          if (h.length === 1) return hw(l, h[0]);
          for (let u = 0; u < l.length; u++) {
            const p = l[u];
            for (let _ = 0; _ < p.length; _++) if (xd(h, p[_])) return !0;
          }
          for (let u = 0; u < h.length; u++) if (hw(l, h[u])) return !0;
          for (let u = 0; u < l.length; u++) if (b0(h, l[u])) return !0;
          return !1;
        }
        function A4(h, l, u) {
          if (h.length > 1) {
            if (b0(h, l)) return !0;
            for (let p = 0; p < l.length; p++) if (v0(l[p], h, u)) return !0;
          }
          for (let p = 0; p < h.length; p++) if (v0(h[p], l, u)) return !0;
          return !1;
        }
        function b0(h, l) {
          if (h.length === 0 || l.length === 0) return !1;
          for (let u = 0; u < h.length - 1; u++) {
            const p = h[u], _ = h[u + 1];
            for (let x = 0; x < l.length - 1; x++) if (T4(p, _, l[x], l[x + 1])) return !0;
          }
          return !1;
        }
        function T4(h, l, u, p) {
          return Oe(h, u, p) !== Oe(l, u, p) && Oe(h, l, u) !== Oe(h, l, p);
        }
        function v0(h, l, u) {
          const p = u * u;
          if (l.length === 1) return h.distSqr(l[0]) < p;
          for (let _ = 1; _ < l.length; _++) if (uw(h, l[_ - 1], l[_]) < p) return !0;
          return !1;
        }
        function uw(h, l, u) {
          const p = l.distSqr(u);
          if (p === 0) return h.distSqr(l);
          const _ = ((h.x - l.x) * (u.x - l.x) + (h.y - l.y) * (u.y - l.y)) / p;
          return h.distSqr(_ < 0 ? l : _ > 1 ? u : u.sub(l)._mult(_)._add(l));
        }
        function hw(h, l) {
          let u, p, _, x = !1;
          for (let A = 0; A < h.length; A++) {
            u = h[A];
            for (let E = 0, M = u.length - 1; E < u.length; M = E++) p = u[E], _ = u[M], p.y > l.y != _.y > l.y && l.x < (_.x - p.x) * (l.y - p.y) / (_.y - p.y) + p.x && (x = !x);
          }
          return x;
        }
        function xd(h, l) {
          let u = !1;
          for (let p = 0, _ = h.length - 1; p < h.length; _ = p++) {
            const x = h[p], A = h[_];
            x.y > l.y != A.y > l.y && l.x < (A.x - x.x) * (l.y - x.y) / (A.y - x.y) + x.x && (u = !u);
          }
          return u;
        }
        function S4(h, l, u) {
          const p = u[0], _ = u[2];
          if (h.x < p.x && l.x < p.x || h.x > _.x && l.x > _.x || h.y < p.y && l.y < p.y || h.y > _.y && l.y > _.y) return !1;
          const x = Oe(h, l, u[0]);
          return x !== Oe(h, l, u[1]) || x !== Oe(h, l, u[2]) || x !== Oe(h, l, u[3]);
        }
        function wd(h, l, u) {
          const p = l.paint.get(h).value;
          return p.kind === "constant" ? p.value : u.programConfigurations.get(l.id).getMaxValue(h);
        }
        function Im(h) {
          return Math.sqrt(h[0] * h[0] + h[1] * h[1]);
        }
        function Pm(h, l, u, p, _) {
          if (!l[0] && !l[1]) return h;
          const x = d.convert(l)._mult(_);
          u === "viewport" && x._rotate(-p);
          const A = [];
          for (let E = 0; E < h.length; E++) A.push(h[E].sub(x));
          return A;
        }
        function E4({ queryGeometry: h, size: l }, u) {
          return Cm(h, u, l);
        }
        function C4({ queryGeometry: h, size: l, transform: u, unwrappedTileID: p, getElevation: _ }, x) {
          return Cm(h, x, l * (u.projectTileCoordinates(x.x, x.y, p, _).signedDistanceFromCamera / u.cameraToCenterDistance));
        }
        function I4({ queryGeometry: h, size: l, transform: u, unwrappedTileID: p, getElevation: _ }, x) {
          const A = u.projectTileCoordinates(x.x, x.y, p, _).signedDistanceFromCamera, E = l * (u.cameraToCenterDistance / A);
          return Cm(h, x0(x, u, p, _), E);
        }
        function P4({ queryGeometry: h, size: l, transform: u, unwrappedTileID: p, getElevation: _ }, x) {
          return Cm(h, x0(x, u, p, _), l);
        }
        function fw({ queryGeometry: h, size: l, transform: u, unwrappedTileID: p, getElevation: _, pitchAlignment: x = "map", pitchScale: A = "map" }, E) {
          const M = x === "map" ? A === "map" ? E4 : C4 : A === "map" ? I4 : P4, O = { queryGeometry: h, size: l, transform: u, unwrappedTileID: p, getElevation: _ };
          for (const N of E) for (const V of N) if (M(O, V)) return !0;
          return !1;
        }
        function x0(h, l, u, p) {
          const _ = l.projectTileCoordinates(h.x, h.y, u, p).point;
          return new d((0.5 * _.x + 0.5) * l.width, (0.5 * -_.y + 0.5) * l.height);
        }
        let dw, pw;
        me("CircleBucket", y0, { omit: ["layers"] });
        var M4 = { get paint() {
          return pw = pw || new ln({ "circle-radius": new cr(We.paint_circle["circle-radius"]), "circle-color": new cr(We.paint_circle["circle-color"]), "circle-blur": new cr(We.paint_circle["circle-blur"]), "circle-opacity": new cr(We.paint_circle["circle-opacity"]), "circle-translate": new Qt(We.paint_circle["circle-translate"]), "circle-translate-anchor": new Qt(We.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Qt(We.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Qt(We.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new cr(We.paint_circle["circle-stroke-width"]), "circle-stroke-color": new cr(We.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new cr(We.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return dw = dw || new ln({ "circle-sort-key": new cr(We.layout_circle["circle-sort-key"]) });
        } };
        class R4 extends gn {
          constructor(l, u) {
            super(l, M4, u);
          }
          createBucket(l) {
            return new y0(l);
          }
          queryRadius(l) {
            const u = l;
            return wd("circle-radius", this, u) + wd("circle-stroke-width", this, u) + Im(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: l, feature: u, featureState: p, geometry: _, transform: x, pixelsToTileUnits: A, unwrappedTileID: E, getElevation: M }) {
            const O = Pm(l, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -x.bearingInRadians, A), N = this.paint.get("circle-radius").evaluate(u, p) + this.paint.get("circle-stroke-width").evaluate(u, p), V = this.paint.get("circle-pitch-scale"), Y = this.paint.get("circle-pitch-alignment");
            let ee, ie;
            return Y === "map" ? (ee = O, ie = N * A) : (ee = function(ue, ve, Re, it) {
              return ue.map((ze) => x0(ze, ve, Re, it));
            }(O, x, E, M), ie = N), fw({ queryGeometry: ee, size: ie, transform: x, unwrappedTileID: E, getElevation: M, pitchAlignment: Y, pitchScale: V }, _);
          }
        }
        class gw extends y0 {
        }
        let mw;
        me("HeatmapBucket", gw, { omit: ["layers"] });
        var L4 = { get paint() {
          return mw = mw || new ln({ "heatmap-radius": new cr(We.paint_heatmap["heatmap-radius"]), "heatmap-weight": new cr(We.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Qt(We.paint_heatmap["heatmap-intensity"]), "heatmap-color": new On(We.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Qt(We.paint_heatmap["heatmap-opacity"]) });
        } };
        function w0(h, { width: l, height: u }, p, _) {
          if (_) {
            if (_ instanceof Uint8ClampedArray) _ = new Uint8Array(_.buffer);
            else if (_.length !== l * u * p) throw new RangeError(`mismatched image size. expected: ${_.length} but got: ${l * u * p}`);
          } else _ = new Uint8Array(l * u * p);
          return h.width = l, h.height = u, h.data = _, h;
        }
        function _w(h, { width: l, height: u }, p) {
          if (l === h.width && u === h.height) return;
          const _ = w0({}, { width: l, height: u }, p);
          A0(h, _, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(h.width, l), height: Math.min(h.height, u) }, p), h.width = l, h.height = u, h.data = _.data;
        }
        function A0(h, l, u, p, _, x) {
          if (_.width === 0 || _.height === 0) return l;
          if (_.width > h.width || _.height > h.height || u.x > h.width - _.width || u.y > h.height - _.height) throw new RangeError("out of range source coordinates for image copy");
          if (_.width > l.width || _.height > l.height || p.x > l.width - _.width || p.y > l.height - _.height) throw new RangeError("out of range destination coordinates for image copy");
          const A = h.data, E = l.data;
          if (A === E) throw new Error("srcData equals dstData, so image is already copied");
          for (let M = 0; M < _.height; M++) {
            const O = ((u.y + M) * h.width + u.x) * x, N = ((p.y + M) * l.width + p.x) * x;
            for (let V = 0; V < _.width * x; V++) E[N + V] = A[O + V];
          }
          return l;
        }
        class qp {
          constructor(l, u) {
            w0(this, l, 1, u);
          }
          resize(l) {
            _w(this, l, 1);
          }
          clone() {
            return new qp({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(l, u, p, _, x) {
            A0(l, u, p, _, x, 1);
          }
        }
        class aa {
          constructor(l, u) {
            w0(this, l, 4, u);
          }
          resize(l) {
            _w(this, l, 4);
          }
          replace(l, u) {
            u ? this.data.set(l) : this.data = l instanceof Uint8ClampedArray ? new Uint8Array(l.buffer) : l;
          }
          clone() {
            return new aa({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(l, u, p, _, x) {
            A0(l, u, p, _, x, 4);
          }
          setPixel(l, u, p) {
            const _ = 4 * (l * this.width + u);
            this.data[_ + 0] = Math.round(255 * p.r / p.a), this.data[_ + 1] = Math.round(255 * p.g / p.a), this.data[_ + 2] = Math.round(255 * p.b / p.a), this.data[_ + 3] = Math.round(255 * p.a);
          }
        }
        function yw(h) {
          const l = {}, u = h.resolution || 256, p = h.clips ? h.clips.length : 1, _ = h.image || new aa({ width: u, height: p });
          if (Math.log(u) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${u}`);
          const x = (A, E, M) => {
            l[h.evaluationKey] = M;
            const O = h.expression.evaluate(l);
            _.setPixel(A / 4 / u, E / 4, O);
          };
          if (h.clips) for (let A = 0, E = 0; A < p; ++A, E += 4 * u) for (let M = 0, O = 0; M < u; M++, O += 4) {
            const N = M / (u - 1), { start: V, end: Y } = h.clips[A];
            x(E, O, V * (1 - N) + Y * N);
          }
          else for (let A = 0, E = 0; A < u; A++, E += 4) x(0, E, A / (u - 1));
          return _;
        }
        me("AlphaImage", qp), me("RGBAImage", aa);
        const T0 = "big-fb";
        class B4 extends gn {
          createBucket(l) {
            return new gw(l);
          }
          constructor(l, u) {
            super(l, L4, u), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(l) {
            l === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = yw({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(T0) && this.heatmapFbos.delete(T0);
          }
          queryRadius(l) {
            return wd("heatmap-radius", this, l);
          }
          queryIntersectsFeature({ queryGeometry: l, feature: u, featureState: p, geometry: _, transform: x, pixelsToTileUnits: A, unwrappedTileID: E, getElevation: M }) {
            return fw({ queryGeometry: l, size: this.paint.get("heatmap-radius").evaluate(u, p) * A, transform: x, unwrappedTileID: E, getElevation: M }, _);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let bw;
        var k4 = { get paint() {
          return bw = bw || new ln({ "hillshade-illumination-direction": new Qt(We.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Qt(We.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Qt(We.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Qt(We.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Qt(We.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Qt(We.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Qt(We.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Qt(We.paint_hillshade["hillshade-method"]) });
        } };
        class O4 extends gn {
          constructor(l, u) {
            super(l, k4, u), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let l = this.paint.get("hillshade-illumination-direction").values, u = this.paint.get("hillshade-illumination-altitude").values, p = this.paint.get("hillshade-highlight-color").values, _ = this.paint.get("hillshade-shadow-color").values;
            const x = Math.max(l.length, u.length, p.length, _.length);
            l = l.concat(Array(x - l.length).fill(l.at(-1))), u = u.concat(Array(x - u.length).fill(u.at(-1))), p = p.concat(Array(x - p.length).fill(p.at(-1))), _ = _.concat(Array(x - _.length).fill(_.at(-1)));
            const A = u.map(Yr);
            return { directionRadians: l.map(Yr), altitudeRadians: A, shadowColor: _, highlightColor: p };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let vw;
        var D4 = { get paint() {
          return vw = vw || new ln({ "color-relief-opacity": new Qt(We["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new On(We["paint_color-relief"]["color-relief-color"]) });
        } };
        class S0 {
          constructor(l, u, p, _) {
            this.context = l, this.format = p, this.texture = l.gl.createTexture(), this.update(u, _);
          }
          update(l, u, p) {
            const { width: _, height: x } = l, A = !(this.size && this.size[0] === _ && this.size[1] === x || p), { context: E } = this, { gl: M } = E;
            if (this.useMipmap = !!(u && u.useMipmap), M.bindTexture(M.TEXTURE_2D, this.texture), E.pixelStoreUnpackFlipY.set(!1), E.pixelStoreUnpack.set(1), E.pixelStoreUnpackPremultiplyAlpha.set(this.format === M.RGBA && (!u || u.premultiply !== !1)), A) this.size = [_, x], l instanceof HTMLImageElement || l instanceof HTMLCanvasElement || l instanceof HTMLVideoElement || l instanceof ImageData || Jt(l) ? M.texImage2D(M.TEXTURE_2D, 0, this.format, this.format, M.UNSIGNED_BYTE, l) : M.texImage2D(M.TEXTURE_2D, 0, this.format, _, x, 0, this.format, M.UNSIGNED_BYTE, l.data);
            else {
              const { x: O, y: N } = p || { x: 0, y: 0 };
              l instanceof HTMLImageElement || l instanceof HTMLCanvasElement || l instanceof HTMLVideoElement || l instanceof ImageData || Jt(l) ? M.texSubImage2D(M.TEXTURE_2D, 0, O, N, M.RGBA, M.UNSIGNED_BYTE, l) : M.texSubImage2D(M.TEXTURE_2D, 0, O, N, _, x, M.RGBA, M.UNSIGNED_BYTE, l.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && M.generateMipmap(M.TEXTURE_2D), E.pixelStoreUnpackFlipY.setDefault(), E.pixelStoreUnpack.setDefault(), E.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(l, u, p) {
            const { context: _ } = this, { gl: x } = _;
            x.bindTexture(x.TEXTURE_2D, this.texture), p !== x.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (p = x.LINEAR), l !== this.filter && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, l), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, p || l), this.filter = l), u !== this.wrap && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, u), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, u), this.wrap = u);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: l } = this.context;
            l.deleteTexture(this.texture), this.texture = null;
          }
        }
        class xw {
          constructor(l, u, p, _ = 1, x = 1, A = 1, E = 0) {
            if (this.uid = l, u.height !== u.width) throw new RangeError("DEM tiles must be square");
            if (p && !["mapbox", "terrarium", "custom"].includes(p)) return void Ct(`"${p}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = u.height;
            const M = this.dim = u.height - 2;
            switch (this.data = new Uint32Array(u.data.buffer), p) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = _, this.greenFactor = x, this.blueFactor = A, this.baseShift = E;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let O = 0; O < M; O++) this.data[this._idx(-1, O)] = this.data[this._idx(0, O)], this.data[this._idx(M, O)] = this.data[this._idx(M - 1, O)], this.data[this._idx(O, -1)] = this.data[this._idx(O, 0)], this.data[this._idx(O, M)] = this.data[this._idx(O, M - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(M, -1)] = this.data[this._idx(M - 1, 0)], this.data[this._idx(-1, M)] = this.data[this._idx(0, M - 1)], this.data[this._idx(M, M)] = this.data[this._idx(M - 1, M - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let O = 0; O < M; O++) for (let N = 0; N < M; N++) {
              const V = this.get(O, N);
              V > this.max && (this.max = V), V < this.min && (this.min = V);
            }
          }
          get(l, u) {
            const p = new Uint8Array(this.data.buffer), _ = 4 * this._idx(l, u);
            return this.unpack(p[_], p[_ + 1], p[_ + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(l, u) {
            if (l < -1 || l >= this.dim + 1 || u < -1 || u >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (u + 1) * this.stride + (l + 1);
          }
          unpack(l, u, p) {
            return l * this.redFactor + u * this.greenFactor + p * this.blueFactor - this.baseShift;
          }
          pack(l) {
            return ww(l, this.getUnpackVector());
          }
          getPixels() {
            return new aa({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(l, u, p) {
            if (this.dim !== l.dim) throw new Error("dem dimension mismatch");
            let _ = u * this.dim, x = u * this.dim + this.dim, A = p * this.dim, E = p * this.dim + this.dim;
            switch (u) {
              case -1:
                _ = x - 1;
                break;
              case 1:
                x = _ + 1;
            }
            switch (p) {
              case -1:
                A = E - 1;
                break;
              case 1:
                E = A + 1;
            }
            const M = -u * this.dim, O = -p * this.dim;
            for (let N = A; N < E; N++) for (let V = _; V < x; V++) this.data[this._idx(V, N)] = l.data[this._idx(V + M, N + O)];
          }
        }
        function ww(h, l) {
          const u = l[0], p = l[1], _ = l[2], x = l[3], A = Math.min(u, p, _), E = Math.round((h + x) / A);
          return { r: Math.floor(E * A / u) % 256, g: Math.floor(E * A / p) % 256, b: Math.floor(E * A / _) % 256 };
        }
        me("DEMData", xw);
        class N4 extends gn {
          constructor(l, u) {
            super(l, D4, u);
          }
          _createColorRamp(l) {
            const u = { elevationStops: [], colorStops: [] }, p = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (p instanceof ph && p._styleExpression.expression instanceof Ir) {
              this.colorRampExpression = p;
              const A = p._styleExpression.expression;
              u.elevationStops = A.labels, u.colorStops = [];
              for (const E of u.elevationStops) u.colorStops.push(A.evaluate({ globals: { elevation: E } }));
            }
            if (u.elevationStops.length < 1 && (u.elevationStops = [0], u.colorStops = [jr.transparent]), u.elevationStops.length < 2 && (u.elevationStops.push(u.elevationStops[0] + 1), u.colorStops.push(u.colorStops[0])), u.elevationStops.length <= l) return u;
            const _ = { elevationStops: [], colorStops: [] }, x = (u.elevationStops.length - 1) / (l - 1);
            for (let A = 0; A < u.elevationStops.length - 0.5; A += x) _.elevationStops.push(u.elevationStops[Math.round(A)]), _.colorStops.push(u.colorStops[Math.round(A)]);
            return Ct(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), _;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(l, u, p) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const _ = this._createColorRamp(u), x = new aa({ width: _.colorStops.length, height: 1 }), A = new aa({ width: _.colorStops.length, height: 1 });
            for (let E = 0; E < _.elevationStops.length; E++) {
              const M = ww(_.elevationStops[E], p);
              A.setPixel(0, E, new jr(M.r / 255, M.g / 255, M.b / 255, 1)), x.setPixel(0, E, _.colorStops[E]);
            }
            return this.colorRampTextures = { elevationTexture: new S0(l, A, l.gl.RGBA), colorTexture: new S0(l, x, l.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const F4 = Ai([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: U4 } = F4;
        function Mm(h, l, u) {
          const p = u.patternDependencies;
          let _ = !1;
          for (const x of l) {
            const A = x.paint.get(`${h}-pattern`);
            A.isConstant() || (_ = !0);
            const E = A.constantOr(null);
            E && (_ = !0, p[E.to] = !0, p[E.from] = !0);
          }
          return _;
        }
        function E0(h, l, u, p, _) {
          const { zoom: x } = p, A = _.patternDependencies;
          for (const E of l) {
            const M = E.paint.get(`${h}-pattern`).value;
            if (M.kind !== "constant") {
              let O = M.evaluate({ zoom: x - 1 }, u, {}, _.availableImages), N = M.evaluate({ zoom: x }, u, {}, _.availableImages), V = M.evaluate({ zoom: x + 1 }, u, {}, _.availableImages);
              O = O && O.name ? O.name : O, N = N && N.name ? N.name : N, V = V && V.name ? V.name : V, A[O] = !0, A[N] = !0, A[V] = !0, u.patterns[E.id] = { min: O, mid: N, max: V };
            }
          }
          return u;
        }
        function Aw(h, l, u, p, _) {
          let x;
          if (_ === function(A, E, M, O) {
            let N = 0;
            for (let V = E, Y = M - O; V < M; V += O) N += (A[Y] - A[V]) * (A[V + 1] + A[Y + 1]), Y = V;
            return N;
          }(h, l, u, p) > 0) for (let A = l; A < u; A += p) x = Cw(A / p | 0, h[A], h[A + 1], x);
          else for (let A = u - p; A >= l; A -= p) x = Cw(A / p | 0, h[A], h[A + 1], x);
          return x && Ad(x, x.next) && (Yp(x), x = x.next), x;
        }
        function _f(h, l) {
          if (!h) return h;
          l || (l = h);
          let u, p = h;
          do
            if (u = !1, p.steiner || !Ad(p, p.next) && Kn(p.prev, p, p.next) !== 0) p = p.next;
            else {
              if (Yp(p), p = l = p.prev, p === p.next) break;
              u = !0;
            }
          while (u || p !== l);
          return l;
        }
        function Wp(h, l, u, p, _, x, A) {
          if (!h) return;
          !A && x && function(M, O, N, V) {
            let Y = M;
            do
              Y.z === 0 && (Y.z = C0(Y.x, Y.y, O, N, V)), Y.prevZ = Y.prev, Y.nextZ = Y.next, Y = Y.next;
            while (Y !== M);
            Y.prevZ.nextZ = null, Y.prevZ = null, function(ee) {
              let ie, ue = 1;
              do {
                let ve, Re = ee;
                ee = null;
                let it = null;
                for (ie = 0; Re; ) {
                  ie++;
                  let ze = Re, Ze = 0;
                  for (let Pt = 0; Pt < ue && (Ze++, ze = ze.nextZ, ze); Pt++) ;
                  let yt = ue;
                  for (; Ze > 0 || yt > 0 && ze; ) Ze !== 0 && (yt === 0 || !ze || Re.z <= ze.z) ? (ve = Re, Re = Re.nextZ, Ze--) : (ve = ze, ze = ze.nextZ, yt--), it ? it.nextZ = ve : ee = ve, ve.prevZ = it, it = ve;
                  Re = ze;
                }
                it.nextZ = null, ue *= 2;
              } while (ie > 1);
            }(Y);
          }(h, p, _, x);
          let E = h;
          for (; h.prev !== h.next; ) {
            const M = h.prev, O = h.next;
            if (x ? j4(h, p, _, x) : z4(h)) l.push(M.i, h.i, O.i), Yp(h), h = O.next, E = O.next;
            else if ((h = O) === E) {
              A ? A === 1 ? Wp(h = V4(_f(h), l), l, u, p, _, x, 2) : A === 2 && G4(h, l, u, p, _, x) : Wp(_f(h), l, u, p, _, x, 1);
              break;
            }
          }
        }
        function z4(h) {
          const l = h.prev, u = h, p = h.next;
          if (Kn(l, u, p) >= 0) return !1;
          const _ = l.x, x = u.x, A = p.x, E = l.y, M = u.y, O = p.y, N = Math.min(_, x, A), V = Math.min(E, M, O), Y = Math.max(_, x, A), ee = Math.max(E, M, O);
          let ie = p.next;
          for (; ie !== l; ) {
            if (ie.x >= N && ie.x <= Y && ie.y >= V && ie.y <= ee && Xp(_, E, x, M, A, O, ie.x, ie.y) && Kn(ie.prev, ie, ie.next) >= 0) return !1;
            ie = ie.next;
          }
          return !0;
        }
        function j4(h, l, u, p) {
          const _ = h.prev, x = h, A = h.next;
          if (Kn(_, x, A) >= 0) return !1;
          const E = _.x, M = x.x, O = A.x, N = _.y, V = x.y, Y = A.y, ee = Math.min(E, M, O), ie = Math.min(N, V, Y), ue = Math.max(E, M, O), ve = Math.max(N, V, Y), Re = C0(ee, ie, l, u, p), it = C0(ue, ve, l, u, p);
          let ze = h.prevZ, Ze = h.nextZ;
          for (; ze && ze.z >= Re && Ze && Ze.z <= it; ) {
            if (ze.x >= ee && ze.x <= ue && ze.y >= ie && ze.y <= ve && ze !== _ && ze !== A && Xp(E, N, M, V, O, Y, ze.x, ze.y) && Kn(ze.prev, ze, ze.next) >= 0 || (ze = ze.prevZ, Ze.x >= ee && Ze.x <= ue && Ze.y >= ie && Ze.y <= ve && Ze !== _ && Ze !== A && Xp(E, N, M, V, O, Y, Ze.x, Ze.y) && Kn(Ze.prev, Ze, Ze.next) >= 0)) return !1;
            Ze = Ze.nextZ;
          }
          for (; ze && ze.z >= Re; ) {
            if (ze.x >= ee && ze.x <= ue && ze.y >= ie && ze.y <= ve && ze !== _ && ze !== A && Xp(E, N, M, V, O, Y, ze.x, ze.y) && Kn(ze.prev, ze, ze.next) >= 0) return !1;
            ze = ze.prevZ;
          }
          for (; Ze && Ze.z <= it; ) {
            if (Ze.x >= ee && Ze.x <= ue && Ze.y >= ie && Ze.y <= ve && Ze !== _ && Ze !== A && Xp(E, N, M, V, O, Y, Ze.x, Ze.y) && Kn(Ze.prev, Ze, Ze.next) >= 0) return !1;
            Ze = Ze.nextZ;
          }
          return !0;
        }
        function V4(h, l) {
          let u = h;
          do {
            const p = u.prev, _ = u.next.next;
            !Ad(p, _) && Sw(p, u, u.next, _) && Zp(p, _) && Zp(_, p) && (l.push(p.i, u.i, _.i), Yp(u), Yp(u.next), u = h = _), u = u.next;
          } while (u !== h);
          return _f(u);
        }
        function G4(h, l, u, p, _, x) {
          let A = h;
          do {
            let E = A.next.next;
            for (; E !== A.prev; ) {
              if (A.i !== E.i && X4(A, E)) {
                let M = Ew(A, E);
                return A = _f(A, A.next), M = _f(M, M.next), Wp(A, l, u, p, _, x, 0), void Wp(M, l, u, p, _, x, 0);
              }
              E = E.next;
            }
            A = A.next;
          } while (A !== h);
        }
        function $4(h, l) {
          let u = h.x - l.x;
          return u === 0 && (u = h.y - l.y, u === 0) && (u = (h.next.y - h.y) / (h.next.x - h.x) - (l.next.y - l.y) / (l.next.x - l.x)), u;
        }
        function H4(h, l) {
          const u = function(_, x) {
            let A = x;
            const E = _.x, M = _.y;
            let O, N = -1 / 0;
            if (Ad(_, A)) return A;
            do {
              if (Ad(_, A.next)) return A.next;
              if (M <= A.y && M >= A.next.y && A.next.y !== A.y) {
                const ue = A.x + (M - A.y) * (A.next.x - A.x) / (A.next.y - A.y);
                if (ue <= E && ue > N && (N = ue, O = A.x < A.next.x ? A : A.next, ue === E)) return O;
              }
              A = A.next;
            } while (A !== x);
            if (!O) return null;
            const V = O, Y = O.x, ee = O.y;
            let ie = 1 / 0;
            A = O;
            do {
              if (E >= A.x && A.x >= Y && E !== A.x && Tw(M < ee ? E : N, M, Y, ee, M < ee ? N : E, M, A.x, A.y)) {
                const ue = Math.abs(M - A.y) / (E - A.x);
                Zp(A, _) && (ue < ie || ue === ie && (A.x > O.x || A.x === O.x && q4(O, A))) && (O = A, ie = ue);
              }
              A = A.next;
            } while (A !== V);
            return O;
          }(h, l);
          if (!u) return l;
          const p = Ew(u, h);
          return _f(p, p.next), _f(u, u.next);
        }
        function q4(h, l) {
          return Kn(h.prev, h, l.prev) < 0 && Kn(l.next, h, h.next) < 0;
        }
        function C0(h, l, u, p, _) {
          return (h = 1431655765 & ((h = 858993459 & ((h = 252645135 & ((h = 16711935 & ((h = (h - u) * _ | 0) | h << 8)) | h << 4)) | h << 2)) | h << 1)) | (l = 1431655765 & ((l = 858993459 & ((l = 252645135 & ((l = 16711935 & ((l = (l - p) * _ | 0) | l << 8)) | l << 4)) | l << 2)) | l << 1)) << 1;
        }
        function W4(h) {
          let l = h, u = h;
          do
            (l.x < u.x || l.x === u.x && l.y < u.y) && (u = l), l = l.next;
          while (l !== h);
          return u;
        }
        function Tw(h, l, u, p, _, x, A, E) {
          return (_ - A) * (l - E) >= (h - A) * (x - E) && (h - A) * (p - E) >= (u - A) * (l - E) && (u - A) * (x - E) >= (_ - A) * (p - E);
        }
        function Xp(h, l, u, p, _, x, A, E) {
          return !(h === A && l === E) && Tw(h, l, u, p, _, x, A, E);
        }
        function X4(h, l) {
          return h.next.i !== l.i && h.prev.i !== l.i && !function(u, p) {
            let _ = u;
            do {
              if (_.i !== u.i && _.next.i !== u.i && _.i !== p.i && _.next.i !== p.i && Sw(_, _.next, u, p)) return !0;
              _ = _.next;
            } while (_ !== u);
            return !1;
          }(h, l) && (Zp(h, l) && Zp(l, h) && function(u, p) {
            let _ = u, x = !1;
            const A = (u.x + p.x) / 2, E = (u.y + p.y) / 2;
            do
              _.y > E != _.next.y > E && _.next.y !== _.y && A < (_.next.x - _.x) * (E - _.y) / (_.next.y - _.y) + _.x && (x = !x), _ = _.next;
            while (_ !== u);
            return x;
          }(h, l) && (Kn(h.prev, h, l.prev) || Kn(h, l.prev, l)) || Ad(h, l) && Kn(h.prev, h, h.next) > 0 && Kn(l.prev, l, l.next) > 0);
        }
        function Kn(h, l, u) {
          return (l.y - h.y) * (u.x - l.x) - (l.x - h.x) * (u.y - l.y);
        }
        function Ad(h, l) {
          return h.x === l.x && h.y === l.y;
        }
        function Sw(h, l, u, p) {
          const _ = Lm(Kn(h, l, u)), x = Lm(Kn(h, l, p)), A = Lm(Kn(u, p, h)), E = Lm(Kn(u, p, l));
          return _ !== x && A !== E || !(_ !== 0 || !Rm(h, u, l)) || !(x !== 0 || !Rm(h, p, l)) || !(A !== 0 || !Rm(u, h, p)) || !(E !== 0 || !Rm(u, l, p));
        }
        function Rm(h, l, u) {
          return l.x <= Math.max(h.x, u.x) && l.x >= Math.min(h.x, u.x) && l.y <= Math.max(h.y, u.y) && l.y >= Math.min(h.y, u.y);
        }
        function Lm(h) {
          return h > 0 ? 1 : h < 0 ? -1 : 0;
        }
        function Zp(h, l) {
          return Kn(h.prev, h, h.next) < 0 ? Kn(h, l, h.next) >= 0 && Kn(h, h.prev, l) >= 0 : Kn(h, l, h.prev) < 0 || Kn(h, h.next, l) < 0;
        }
        function Ew(h, l) {
          const u = I0(h.i, h.x, h.y), p = I0(l.i, l.x, l.y), _ = h.next, x = l.prev;
          return h.next = l, l.prev = h, u.next = _, _.prev = u, p.next = u, u.prev = p, x.next = p, p.prev = x, p;
        }
        function Cw(h, l, u, p) {
          const _ = I0(h, l, u);
          return p ? (_.next = p.next, _.prev = p, p.next.prev = _, p.next = _) : (_.prev = _, _.next = _), _;
        }
        function Yp(h) {
          h.next.prev = h.prev, h.prev.next = h.next, h.prevZ && (h.prevZ.nextZ = h.nextZ), h.nextZ && (h.nextZ.prevZ = h.prevZ);
        }
        function I0(h, l, u) {
          return { i: h, x: l, y: u, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class Td {
          constructor(l, u) {
            if (u > l) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = l, this._minGranularity = u;
          }
          getGranularityForZoomLevel(l) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << l)), this._minGranularity, 1);
          }
        }
        class Bm {
          constructor(l) {
            this.fill = l.fill, this.line = l.line, this.tile = l.tile, this.stencil = l.stencil, this.circle = l.circle;
          }
        }
        Bm.noSubdivision = new Bm({ fill: new Td(0, 0), line: new Td(0, 0), tile: new Td(0, 0), stencil: new Td(0, 0), circle: 1 }), me("SubdivisionGranularityExpression", Td), me("SubdivisionGranularitySetting", Bm);
        const Sd = -32768, Jp = 32767;
        class Z4 {
          constructor(l, u) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = l, this._granularityCellSize = wt / l, this._canonical = u;
          }
          _getKey(l, u) {
            return (l += 32768) << 16 | u + 32768;
          }
          _vertexToIndex(l, u) {
            if (l < -32768 || u < -32768 || l > 32767 || u > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const p = 0 | Math.round(l), _ = 0 | Math.round(u), x = this._getKey(p, _);
            if (this._vertexDictionary.has(x)) return this._vertexDictionary.get(x);
            const A = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(x, A), this._vertexBuffer.push(p, _), A;
          }
          _subdivideTrianglesScanline(l) {
            if (this._granularity < 2) return function(_, x) {
              const A = [];
              for (let E = 0; E < x.length; E += 3) {
                const M = x[E], O = x[E + 1], N = x[E + 2], V = _[2 * M], Y = _[2 * M + 1];
                (_[2 * O] - V) * (_[2 * N + 1] - Y) - (_[2 * O + 1] - Y) * (_[2 * N] - V) > 0 ? (A.push(M), A.push(N), A.push(O)) : (A.push(M), A.push(O), A.push(N));
              }
              return A;
            }(this._vertexBuffer, l);
            const u = [], p = l.length;
            for (let _ = 0; _ < p; _ += 3) {
              const x = [l[_ + 0], l[_ + 1], l[_ + 2]], A = [this._vertexBuffer[2 * l[_ + 0] + 0], this._vertexBuffer[2 * l[_ + 0] + 1], this._vertexBuffer[2 * l[_ + 1] + 0], this._vertexBuffer[2 * l[_ + 1] + 1], this._vertexBuffer[2 * l[_ + 2] + 0], this._vertexBuffer[2 * l[_ + 2] + 1]];
              let E = 1 / 0, M = 1 / 0, O = -1 / 0, N = -1 / 0;
              for (let ue = 0; ue < 3; ue++) {
                const ve = A[2 * ue], Re = A[2 * ue + 1];
                E = Math.min(E, ve), O = Math.max(O, ve), M = Math.min(M, Re), N = Math.max(N, Re);
              }
              if (E === O || M === N) continue;
              const V = Math.floor(E / this._granularityCellSize), Y = Math.ceil(O / this._granularityCellSize), ee = Math.floor(M / this._granularityCellSize), ie = Math.ceil(N / this._granularityCellSize);
              if (V !== Y || ee !== ie) for (let ue = ee; ue < ie; ue++) {
                const ve = this._scanlineGenerateVertexRingForCellRow(ue, A, x);
                Y4(this._vertexBuffer, ve, u);
              }
              else u.push(...x);
            }
            return u;
          }
          _scanlineGenerateVertexRingForCellRow(l, u, p) {
            const _ = l * this._granularityCellSize, x = _ + this._granularityCellSize, A = [];
            for (let E = 0; E < 3; E++) {
              const M = u[2 * E], O = u[2 * E + 1], N = u[2 * (E + 1) % 6], V = u[(2 * (E + 1) + 1) % 6], Y = u[2 * (E + 2) % 6], ee = u[(2 * (E + 2) + 1) % 6], ie = N - M, ue = V - O, ve = ie === 0, Re = ue === 0, it = (_ - O) / ue, ze = (x - O) / ue, Ze = Math.min(it, ze), yt = Math.max(it, ze);
              if (!Re && (Ze >= 1 || yt <= 0) || Re && (O < _ || O > x)) {
                V >= _ && V <= x && A.push(p[(E + 1) % 3]);
                continue;
              }
              !Re && Ze > 0 && A.push(this._vertexToIndex(M + ie * Ze, O + ue * Ze));
              const Pt = M + ie * Math.max(Ze, 0), Gt = M + ie * Math.min(yt, 1);
              ve || this._generateIntraEdgeVertices(A, M, O, N, V, Pt, Gt), !Re && yt < 1 && A.push(this._vertexToIndex(M + ie * yt, O + ue * yt)), (Re || V >= _ && V <= x) && A.push(p[(E + 1) % 3]), !Re && (V <= _ || V >= x) && this._generateInterEdgeVertices(A, M, O, N, V, Y, ee, Gt, _, x);
            }
            return A;
          }
          _generateIntraEdgeVertices(l, u, p, _, x, A, E) {
            const M = _ - u, O = x - p, N = O === 0, V = N ? Math.min(u, _) : Math.min(A, E), Y = N ? Math.max(u, _) : Math.max(A, E), ee = Math.floor(V / this._granularityCellSize) + 1, ie = Math.ceil(Y / this._granularityCellSize) - 1;
            if (N ? u < _ : A < E) for (let ue = ee; ue <= ie; ue++) {
              const ve = ue * this._granularityCellSize;
              l.push(this._vertexToIndex(ve, p + O * (ve - u) / M));
            }
            else for (let ue = ie; ue >= ee; ue--) {
              const ve = ue * this._granularityCellSize;
              l.push(this._vertexToIndex(ve, p + O * (ve - u) / M));
            }
          }
          _generateInterEdgeVertices(l, u, p, _, x, A, E, M, O, N) {
            const V = x - p, Y = A - _, ee = E - x, ie = (O - x) / ee, ue = (N - x) / ee, ve = Math.min(ie, ue), Re = Math.max(ie, ue), it = _ + Y * ve;
            let ze = Math.floor(Math.min(it, M) / this._granularityCellSize) + 1, Ze = Math.ceil(Math.max(it, M) / this._granularityCellSize) - 1, yt = M < it;
            const Pt = ee === 0;
            if (Pt && (E === O || E === N)) return;
            if (Pt || ve >= 1 || Re <= 0) {
              const or = p - E, er = A + (u - A) * Math.min((O - E) / or, (N - E) / or);
              ze = Math.floor(Math.min(er, M) / this._granularityCellSize) + 1, Ze = Math.ceil(Math.max(er, M) / this._granularityCellSize) - 1, yt = M < er;
            }
            const Gt = V > 0 ? N : O;
            if (yt) for (let or = ze; or <= Ze; or++) l.push(this._vertexToIndex(or * this._granularityCellSize, Gt));
            else for (let or = Ze; or >= ze; or--) l.push(this._vertexToIndex(or * this._granularityCellSize, Gt));
          }
          _generateOutline(l) {
            const u = [];
            for (const p of l) {
              const _ = yf(p, this._granularity, !0), x = this._pointArrayToIndices(_), A = [];
              for (let E = 1; E < x.length; E++) A.push(x[E - 1]), A.push(x[E]);
              u.push(A);
            }
            return u;
          }
          _handlePoles(l) {
            let u = !1, p = !1;
            this._canonical && (this._canonical.y === 0 && (u = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (p = !0)), (u || p) && this._fillPoles(l, u, p);
          }
          _ensureNoPoleVertices() {
            const l = this._vertexBuffer;
            for (let u = 0; u < l.length; u += 2) {
              const p = l[u + 1];
              p === Sd && (l[u + 1] = -32767), p === Jp && (l[u + 1] = 32766);
            }
          }
          _generatePoleQuad(l, u, p, _, x, A) {
            _ > x != (A === Sd) ? (l.push(u), l.push(p), l.push(this._vertexToIndex(_, A)), l.push(p), l.push(this._vertexToIndex(x, A)), l.push(this._vertexToIndex(_, A))) : (l.push(p), l.push(u), l.push(this._vertexToIndex(_, A)), l.push(this._vertexToIndex(x, A)), l.push(p), l.push(this._vertexToIndex(_, A)));
          }
          _fillPoles(l, u, p) {
            const _ = this._vertexBuffer, x = wt, A = l.length;
            for (let E = 2; E < A; E += 3) {
              const M = l[E - 2], O = l[E - 1], N = l[E], V = _[2 * M], Y = _[2 * M + 1], ee = _[2 * O], ie = _[2 * O + 1], ue = _[2 * N], ve = _[2 * N + 1];
              u && (Y === 0 && ie === 0 && this._generatePoleQuad(l, M, O, V, ee, Sd), ie === 0 && ve === 0 && this._generatePoleQuad(l, O, N, ee, ue, Sd), ve === 0 && Y === 0 && this._generatePoleQuad(l, N, M, ue, V, Sd)), p && (Y === x && ie === x && this._generatePoleQuad(l, M, O, V, ee, Jp), ie === x && ve === x && this._generatePoleQuad(l, O, N, ee, ue, Jp), ve === x && Y === x && this._generatePoleQuad(l, N, M, ue, V, Jp));
            }
          }
          _initializeVertices(l) {
            for (let u = 0; u < l.length; u += 2) this._vertexToIndex(l[u], l[u + 1]);
          }
          subdividePolygonInternal(l, u) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: p, holeIndices: _ } = function(E) {
              const M = [], O = [];
              for (const N of E) if (N.length !== 0) {
                N !== E[0] && M.push(O.length / 2);
                for (let V = 0; V < N.length; V++) O.push(N[V].x), O.push(N[V].y);
              }
              return { flattened: O, holeIndices: M };
            }(l);
            let x;
            this._initializeVertices(p);
            try {
              const E = function(O, N, V = 2) {
                const Y = N && N.length, ee = Y ? N[0] * V : O.length;
                let ie = Aw(O, 0, ee, V, !0);
                const ue = [];
                if (!ie || ie.next === ie.prev) return ue;
                let ve, Re, it;
                if (Y && (ie = function(ze, Ze, yt, Pt) {
                  const Gt = [];
                  for (let or = 0, er = Ze.length; or < er; or++) {
                    const nr = Aw(ze, Ze[or] * Pt, or < er - 1 ? Ze[or + 1] * Pt : ze.length, Pt, !1);
                    nr === nr.next && (nr.steiner = !0), Gt.push(W4(nr));
                  }
                  Gt.sort($4);
                  for (let or = 0; or < Gt.length; or++) yt = H4(Gt[or], yt);
                  return yt;
                }(O, N, ie, V)), O.length > 80 * V) {
                  ve = O[0], Re = O[1];
                  let ze = ve, Ze = Re;
                  for (let yt = V; yt < ee; yt += V) {
                    const Pt = O[yt], Gt = O[yt + 1];
                    Pt < ve && (ve = Pt), Gt < Re && (Re = Gt), Pt > ze && (ze = Pt), Gt > Ze && (Ze = Gt);
                  }
                  it = Math.max(ze - ve, Ze - Re), it = it !== 0 ? 32767 / it : 0;
                }
                return Wp(ie, ue, V, ve, Re, it, 0), ue;
              }(p, _), M = this._convertIndices(p, E);
              x = this._subdivideTrianglesScanline(M);
            } catch (E) {
              console.error(E);
            }
            let A = [];
            return u && (A = this._generateOutline(l)), this._ensureNoPoleVertices(), this._handlePoles(x), { verticesFlattened: this._vertexBuffer, indicesTriangles: x, indicesLineList: A };
          }
          _convertIndices(l, u) {
            const p = [];
            for (let _ = 0; _ < u.length; _++) p.push(this._vertexToIndex(l[2 * u[_]], l[2 * u[_] + 1]));
            return p;
          }
          _pointArrayToIndices(l) {
            const u = [];
            for (let p = 0; p < l.length; p++) {
              const _ = l[p];
              u.push(this._vertexToIndex(_.x, _.y));
            }
            return u;
          }
        }
        function Iw(h, l, u, p = !0) {
          return new Z4(u, l).subdividePolygonInternal(h, p);
        }
        function yf(h, l, u = !1) {
          if (!h || h.length < 1) return [];
          if (h.length < 2) return [];
          const p = h[0], _ = h[h.length - 1], x = u && (p.x !== _.x || p.y !== _.y);
          if (l < 2) return x ? [...h, h[0]] : [...h];
          const A = Math.floor(wt / l), E = [];
          E.push(new d(h[0].x, h[0].y));
          const M = h.length, O = x ? M : M - 1;
          for (let N = 0; N < O; N++) {
            const V = h[N], Y = N < M - 1 ? h[N + 1] : h[0], ee = V.x, ie = V.y, ue = Y.x, ve = Y.y, Re = ee !== ue, it = ie !== ve;
            if (!Re && !it) continue;
            const ze = ue - ee, Ze = ve - ie, yt = Math.abs(ze), Pt = Math.abs(Ze);
            let Gt = ee, or = ie;
            for (; ; ) {
              const nr = ze > 0 ? (Math.floor(Gt / A) + 1) * A : (Math.ceil(Gt / A) - 1) * A, Ar = Ze > 0 ? (Math.floor(or / A) + 1) * A : (Math.ceil(or / A) - 1) * A, ir = Math.abs(Gt - nr), sr = Math.abs(or - Ar), Ft = Math.abs(Gt - ue), Gr = Math.abs(or - ve), Xr = Re ? ir / yt : Number.POSITIVE_INFINITY, kr = it ? sr / Pt : Number.POSITIVE_INFINITY;
              if ((Ft <= ir || !Re) && (Gr <= sr || !it)) break;
              if (Xr < kr && Re || !it) {
                Gt = nr, or += Ze * Xr;
                const br = new d(Gt, Math.round(or));
                E[E.length - 1].x === br.x && E[E.length - 1].y === br.y || E.push(br);
              } else {
                Gt += ze * kr, or = Ar;
                const br = new d(Math.round(Gt), or);
                E[E.length - 1].x === br.x && E[E.length - 1].y === br.y || E.push(br);
              }
            }
            const er = new d(ue, ve);
            E[E.length - 1].x === er.x && E[E.length - 1].y === er.y || E.push(er);
          }
          return E;
        }
        function Y4(h, l, u) {
          if (l.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let p = 0, _ = h[2 * l[0]];
          for (let M = 1; M < l.length; M++) {
            const O = h[2 * l[M]];
            O < _ && (_ = O, p = M);
          }
          const x = l.length;
          let A = p, E = (A + 1) % x;
          for (; ; ) {
            const M = A - 1 >= 0 ? A - 1 : x - 1, O = (E + 1) % x, N = h[2 * l[M]], V = h[2 * l[O]], Y = h[2 * l[A]], ee = h[2 * l[A] + 1], ie = h[2 * l[E] + 1];
            let ue = !1;
            if (N < V) ue = !0;
            else if (N > V) ue = !1;
            else {
              const ve = ie - ee, Re = -(h[2 * l[E]] - Y), it = ee < ie ? 1 : -1;
              ((N - Y) * ve + (h[2 * l[M] + 1] - ee) * Re) * it > ((V - Y) * ve + (h[2 * l[O] + 1] - ee) * Re) * it && (ue = !0);
            }
            if (ue) {
              const ve = l[M], Re = l[A], it = l[E];
              ve !== Re && ve !== it && Re !== it && u.push(it, Re, ve), A--, A < 0 && (A = x - 1);
            } else {
              const ve = l[O], Re = l[A], it = l[E];
              ve !== Re && ve !== it && Re !== it && u.push(it, Re, ve), E++, E >= x && (E = 0);
            }
            if (M === O) break;
          }
        }
        function Pw(h, l, u, p, _, x, A, E, M) {
          const O = _.length / 2, N = A && E && M;
          if (O < hi.MAX_VERTEX_ARRAY_LENGTH) {
            const V = l.prepareSegment(O, u, p), Y = V.vertexLength;
            for (let ue = 0; ue < x.length; ue += 3) p.emplaceBack(Y + x[ue], Y + x[ue + 1], Y + x[ue + 2]);
            let ee, ie;
            V.vertexLength += O, V.primitiveLength += x.length / 3, N && (ie = A.prepareSegment(O, u, E), ee = ie.vertexLength, ie.vertexLength += O);
            for (let ue = 0; ue < _.length; ue += 2) h(_[ue], _[ue + 1]);
            if (N) for (let ue = 0; ue < M.length; ue++) {
              const ve = M[ue];
              for (let Re = 1; Re < ve.length; Re += 2) E.emplaceBack(ee + ve[Re - 1], ee + ve[Re]);
              ie.primitiveLength += ve.length / 2;
            }
          } else (function(V, Y, ee, ie, ue, ve) {
            const Re = [];
            for (let Pt = 0; Pt < ie.length / 2; Pt++) Re.push(-1);
            const it = { count: 0 };
            let ze = 0, Ze = V.getOrCreateLatestSegment(Y, ee), yt = Ze.vertexLength;
            for (let Pt = 2; Pt < ue.length; Pt += 3) {
              const Gt = ue[Pt - 2], or = ue[Pt - 1], er = ue[Pt];
              let nr = Re[Gt] < ze, Ar = Re[or] < ze, ir = Re[er] < ze;
              Ze.vertexLength + ((nr ? 1 : 0) + (Ar ? 1 : 0) + (ir ? 1 : 0)) > hi.MAX_VERTEX_ARRAY_LENGTH && (Ze = V.createNewSegment(Y, ee), ze = it.count, nr = !0, Ar = !0, ir = !0, yt = 0);
              const sr = Kp(Re, ie, ve, it, Gt, nr, Ze), Ft = Kp(Re, ie, ve, it, or, Ar, Ze), Gr = Kp(Re, ie, ve, it, er, ir, Ze);
              ee.emplaceBack(yt + sr - ze, yt + Ft - ze, yt + Gr - ze), Ze.primitiveLength++;
            }
          })(l, u, p, _, x, h), N && function(V, Y, ee, ie, ue, ve) {
            const Re = [];
            for (let Pt = 0; Pt < ie.length / 2; Pt++) Re.push(-1);
            const it = { count: 0 };
            let ze = 0, Ze = V.getOrCreateLatestSegment(Y, ee), yt = Ze.vertexLength;
            for (let Pt = 0; Pt < ue.length; Pt++) {
              const Gt = ue[Pt];
              for (let or = 1; or < ue[Pt].length; or += 2) {
                const er = Gt[or - 1], nr = Gt[or];
                let Ar = Re[er] < ze, ir = Re[nr] < ze;
                Ze.vertexLength + ((Ar ? 1 : 0) + (ir ? 1 : 0)) > hi.MAX_VERTEX_ARRAY_LENGTH && (Ze = V.createNewSegment(Y, ee), ze = it.count, Ar = !0, ir = !0, yt = 0);
                const sr = Kp(Re, ie, ve, it, er, Ar, Ze), Ft = Kp(Re, ie, ve, it, nr, ir, Ze);
                ee.emplaceBack(yt + sr - ze, yt + Ft - ze), Ze.primitiveLength++;
              }
            }
          }(A, u, E, _, M, h), l.forceNewSegmentOnNextPrepare(), A?.forceNewSegmentOnNextPrepare();
        }
        function Kp(h, l, u, p, _, x, A) {
          if (x) {
            const E = p.count;
            return u(l[2 * _], l[2 * _ + 1]), h[_] = p.count, p.count++, A.vertexLength++, E;
          }
          return h[_];
        }
        class P0 {
          constructor(l) {
            this.zoom = l.zoom, this.overscaling = l.overscaling, this.layers = l.layers, this.layerIds = this.layers.map((u) => u.id), this.index = l.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new Xe(), this.indexArray = new Vr(), this.indexArray2 = new Ti(), this.programConfigurations = new ou(l.layers, l.zoom), this.segments = new hi(), this.segments2 = new hi(), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(l, u, p) {
            this.hasDependencies = Mm("fill", this.layers, u);
            const _ = this.layers[0].layout.get("fill-sort-key"), x = !_.isConstant(), A = [];
            for (const { feature: E, id: M, index: O, sourceLayerIndex: N } of l) {
              const V = this.layers[0]._featureFilter.needGeometry, Y = mf(E, V);
              if (!this.layers[0]._featureFilter.filter(new Wr(this.zoom), Y, p)) continue;
              const ee = x ? _.evaluate(Y, {}, p, u.availableImages) : void 0, ie = { id: M, properties: E.properties, type: E.type, sourceLayerIndex: N, index: O, geometry: V ? Y.geometry : sc(E), patterns: {}, sortKey: ee };
              A.push(ie);
            }
            x && A.sort((E, M) => E.sortKey - M.sortKey);
            for (const E of A) {
              const { geometry: M, index: O, sourceLayerIndex: N } = E;
              if (this.hasDependencies) {
                const V = E0("fill", this.layers, E, { zoom: this.zoom }, u);
                this.patternFeatures.push(V);
              } else this.addFeature(E, M, O, p, {}, u.subdivisionGranularity);
              u.featureIndex.insert(l[O].feature, M, O, N, this.index);
            }
          }
          update(l, u, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(l, u, this.stateDependentLayers, { imagePositions: p });
          }
          addFeatures(l, u, p) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, u, p, l.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(l) {
            this.uploaded || (this.layoutVertexBuffer = l.createVertexBuffer(this.layoutVertexArray, U4), this.indexBuffer = l.createIndexBuffer(this.indexArray), this.indexBuffer2 = l.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(l), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(l, u, p, _, x, A) {
            for (const E of yl(u, 500)) {
              const M = Iw(E, _, A.fill.getGranularityForZoomLevel(_.z)), O = this.layoutVertexArray;
              Pw((N, V) => {
                O.emplaceBack(N, V);
              }, this.segments, this.layoutVertexArray, this.indexArray, M.verticesFlattened, M.indicesTriangles, this.segments2, this.indexArray2, M.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, l, p, { imagePositions: x, canonical: _ });
          }
        }
        let Mw, Rw;
        me("FillBucket", P0, { omit: ["layers", "patternFeatures"] });
        var J4 = { get paint() {
          return Rw = Rw || new ln({ "fill-antialias": new Qt(We.paint_fill["fill-antialias"]), "fill-opacity": new cr(We.paint_fill["fill-opacity"]), "fill-color": new cr(We.paint_fill["fill-color"]), "fill-outline-color": new cr(We.paint_fill["fill-outline-color"]), "fill-translate": new Qt(We.paint_fill["fill-translate"]), "fill-translate-anchor": new Qt(We.paint_fill["fill-translate-anchor"]), "fill-pattern": new Zi(We.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Mw = Mw || new ln({ "fill-sort-key": new cr(We.layout_fill["fill-sort-key"]) });
        } };
        class K4 extends gn {
          constructor(l, u) {
            super(l, J4, u);
          }
          recalculate(l, u) {
            super.recalculate(l, u);
            const p = this.paint._values["fill-outline-color"];
            p.value.kind === "constant" && p.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(l) {
            return new P0(l);
          }
          queryRadius() {
            return Im(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: l, geometry: u, transform: p, pixelsToTileUnits: _ }) {
            return cw(Pm(l, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -p.bearingInRadians, _), u);
          }
          isTileClipped() {
            return !0;
          }
        }
        const Q4 = Ai([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), eL = Ai([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: tL } = Q4;
        class Ed {
          constructor(l, u, p, _, x) {
            this.properties = {}, this.extent = p, this.type = 0, this.id = void 0, this._pbf = l, this._geometry = -1, this._keys = _, this._values = x, l.readFields(rL, this, u);
          }
          loadGeometry() {
            const l = this._pbf;
            l.pos = this._geometry;
            const u = l.readVarint() + l.pos, p = [];
            let _, x = 1, A = 0, E = 0, M = 0;
            for (; l.pos < u; ) {
              if (A <= 0) {
                const O = l.readVarint();
                x = 7 & O, A = O >> 3;
              }
              if (A--, x === 1 || x === 2) E += l.readSVarint(), M += l.readSVarint(), x === 1 && (_ && p.push(_), _ = []), _ && _.push(new d(E, M));
              else {
                if (x !== 7) throw new Error(`unknown command ${x}`);
                _ && _.push(_[0].clone());
              }
            }
            return _ && p.push(_), p;
          }
          bbox() {
            const l = this._pbf;
            l.pos = this._geometry;
            const u = l.readVarint() + l.pos;
            let p = 1, _ = 0, x = 0, A = 0, E = 1 / 0, M = -1 / 0, O = 1 / 0, N = -1 / 0;
            for (; l.pos < u; ) {
              if (_ <= 0) {
                const V = l.readVarint();
                p = 7 & V, _ = V >> 3;
              }
              if (_--, p === 1 || p === 2) x += l.readSVarint(), A += l.readSVarint(), x < E && (E = x), x > M && (M = x), A < O && (O = A), A > N && (N = A);
              else if (p !== 7) throw new Error(`unknown command ${p}`);
            }
            return [E, O, M, N];
          }
          toGeoJSON(l, u, p) {
            const _ = this.extent * Math.pow(2, p), x = this.extent * l, A = this.extent * u, E = this.loadGeometry();
            function M(Y) {
              return [360 * (Y.x + x) / _ - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (Y.y + A) / _) * Math.PI)) - 90];
            }
            function O(Y) {
              return Y.map(M);
            }
            let N;
            if (this.type === 1) {
              const Y = [];
              for (const ie of E) Y.push(ie[0]);
              const ee = O(Y);
              N = Y.length === 1 ? { type: "Point", coordinates: ee[0] } : { type: "MultiPoint", coordinates: ee };
            } else if (this.type === 2) {
              const Y = E.map(O);
              N = Y.length === 1 ? { type: "LineString", coordinates: Y[0] } : { type: "MultiLineString", coordinates: Y };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const Y = function(ie) {
                  const ue = ie.length;
                  if (ue <= 1) return [ie];
                  const ve = [];
                  let Re, it;
                  for (let ze = 0; ze < ue; ze++) {
                    const Ze = iL(ie[ze]);
                    Ze !== 0 && (it === void 0 && (it = Ze < 0), it === Ze < 0 ? (Re && ve.push(Re), Re = [ie[ze]]) : Re && Re.push(ie[ze]));
                  }
                  return Re && ve.push(Re), ve;
                }(E), ee = [];
                for (const ie of Y) ee.push(ie.map(O));
                N = ee.length === 1 ? { type: "Polygon", coordinates: ee[0] } : { type: "MultiPolygon", coordinates: ee };
              }
            }
            const V = { type: "Feature", geometry: N, properties: this.properties };
            return this.id != null && (V.id = this.id), V;
          }
        }
        function rL(h, l, u) {
          h === 1 ? l.id = u.readVarint() : h === 2 ? function(p, _) {
            const x = p.readVarint() + p.pos;
            for (; p.pos < x; ) {
              const A = _._keys[p.readVarint()], E = _._values[p.readVarint()];
              _.properties[A] = E;
            }
          }(u, l) : h === 3 ? l.type = u.readVarint() : h === 4 && (l._geometry = u.pos);
        }
        function iL(h) {
          let l = 0;
          for (let u, p, _ = 0, x = h.length, A = x - 1; _ < x; A = _++) u = h[_], p = h[A], l += (p.x - u.x) * (u.y + p.y);
          return l;
        }
        Ed.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Lw {
          constructor(l, u) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = l, this._keys = [], this._values = [], this._features = [], l.readFields(nL, this, u), this.length = this._features.length;
          }
          feature(l) {
            if (l < 0 || l >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[l];
            const u = this._pbf.readVarint() + this._pbf.pos;
            return new Ed(this._pbf, u, this.extent, this._keys, this._values);
          }
        }
        function nL(h, l, u) {
          h === 15 ? l.version = u.readVarint() : h === 1 ? l.name = u.readString() : h === 5 ? l.extent = u.readVarint() : h === 2 ? l._features.push(u.pos) : h === 3 ? l._keys.push(u.readString()) : h === 4 && l._values.push(function(p) {
            let _ = null;
            const x = p.readVarint() + p.pos;
            for (; p.pos < x; ) {
              const A = p.readVarint() >> 3;
              _ = A === 1 ? p.readString() : A === 2 ? p.readFloat() : A === 3 ? p.readDouble() : A === 4 ? p.readVarint64() : A === 5 ? p.readVarint() : A === 6 ? p.readSVarint() : A === 7 ? p.readBoolean() : null;
            }
            if (_ == null) throw new Error("unknown feature value");
            return _;
          }(u));
        }
        class Bw {
          constructor(l, u) {
            this.layers = l.readFields(sL, {}, u);
          }
        }
        function sL(h, l, u) {
          if (h === 3) {
            const p = new Lw(u, u.readVarint() + u.pos);
            p.length && (l[p.name] = p);
          }
        }
        const M0 = Math.pow(2, 13);
        function Qp(h, l, u, p, _, x, A, E) {
          h.emplaceBack(l, u, 2 * Math.floor(p * M0) + A, _ * M0 * 2, x * M0 * 2, Math.round(E));
        }
        class R0 {
          constructor(l) {
            this.zoom = l.zoom, this.overscaling = l.overscaling, this.layers = l.layers, this.layerIds = this.layers.map((u) => u.id), this.index = l.index, this.hasDependencies = !1, this.layoutVertexArray = new Fe(), this.centroidVertexArray = new Le(), this.indexArray = new Vr(), this.programConfigurations = new ou(l.layers, l.zoom), this.segments = new hi(), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(l, u, p) {
            this.features = [], this.hasDependencies = Mm("fill-extrusion", this.layers, u);
            for (const { feature: _, id: x, index: A, sourceLayerIndex: E } of l) {
              const M = this.layers[0]._featureFilter.needGeometry, O = mf(_, M);
              if (!this.layers[0]._featureFilter.filter(new Wr(this.zoom), O, p)) continue;
              const N = { id: x, sourceLayerIndex: E, index: A, geometry: M ? O.geometry : sc(_), properties: _.properties, type: _.type, patterns: {} };
              this.hasDependencies ? this.features.push(E0("fill-extrusion", this.layers, N, { zoom: this.zoom }, u)) : this.addFeature(N, N.geometry, A, p, {}, u.subdivisionGranularity), u.featureIndex.insert(_, N.geometry, A, E, this.index, !0);
            }
          }
          addFeatures(l, u, p) {
            for (const _ of this.features) {
              const { geometry: x } = _;
              this.addFeature(_, x, _.index, u, p, l.subdivisionGranularity);
            }
          }
          update(l, u, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(l, u, this.stateDependentLayers, { imagePositions: p });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(l) {
            this.uploaded || (this.layoutVertexBuffer = l.createVertexBuffer(this.layoutVertexArray, tL), this.centroidVertexBuffer = l.createVertexBuffer(this.centroidVertexArray, eL.members, !0), this.indexBuffer = l.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(l), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(l, u, p, _, x, A) {
            for (const E of yl(u, 500)) {
              const M = { x: 0, y: 0, sampleCount: 0 }, O = this.layoutVertexArray.length;
              this.processPolygon(M, _, l, E, A);
              const N = this.layoutVertexArray.length - O, V = Math.floor(M.x / M.sampleCount), Y = Math.floor(M.y / M.sampleCount);
              for (let ee = 0; ee < N; ee++) this.centroidVertexArray.emplaceBack(V, Y);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, l, p, { imagePositions: x, canonical: _ });
          }
          processPolygon(l, u, p, _, x) {
            if (_.length < 1 || kw(_[0])) return;
            for (const V of _) V.length !== 0 && oL(l, V);
            const A = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, E = x.fill.getGranularityForZoomLevel(u.z), M = Ed.types[p.type] === "Polygon";
            for (const V of _) {
              if (V.length === 0 || kw(V)) continue;
              const Y = yf(V, E, M);
              this._generateSideFaces(Y, A);
            }
            if (!M) return;
            const O = Iw(_, u, E, !1), N = this.layoutVertexArray;
            Pw((V, Y) => {
              Qp(N, V, Y, 0, 0, 1, 1, 0);
            }, this.segments, this.layoutVertexArray, this.indexArray, O.verticesFlattened, O.indicesTriangles);
          }
          _generateSideFaces(l, u) {
            let p = 0;
            for (let _ = 1; _ < l.length; _++) {
              const x = l[_], A = l[_ - 1];
              if (aL(x, A)) continue;
              u.segment.vertexLength + 4 > hi.MAX_VERTEX_ARRAY_LENGTH && (u.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const E = x.sub(A)._perp()._unit(), M = A.dist(x);
              p + M > 32768 && (p = 0), Qp(this.layoutVertexArray, x.x, x.y, E.x, E.y, 0, 0, p), Qp(this.layoutVertexArray, x.x, x.y, E.x, E.y, 0, 1, p), p += M, Qp(this.layoutVertexArray, A.x, A.y, E.x, E.y, 0, 0, p), Qp(this.layoutVertexArray, A.x, A.y, E.x, E.y, 0, 1, p);
              const O = u.segment.vertexLength;
              this.indexArray.emplaceBack(O, O + 2, O + 1), this.indexArray.emplaceBack(O + 1, O + 2, O + 3), u.segment.vertexLength += 4, u.segment.primitiveLength += 2;
            }
          }
        }
        function oL(h, l) {
          for (let u = 0; u < l.length; u++) {
            const p = l[u];
            u === l.length - 1 && l[0].x === p.x && l[0].y === p.y || (h.x += p.x, h.y += p.y, h.sampleCount++);
          }
        }
        function aL(h, l) {
          return h.x === l.x && (h.x < 0 || h.x > wt) || h.y === l.y && (h.y < 0 || h.y > wt);
        }
        function kw(h) {
          return h.every((l) => l.x < 0) || h.every((l) => l.x > wt) || h.every((l) => l.y < 0) || h.every((l) => l.y > wt);
        }
        let Ow;
        me("FillExtrusionBucket", R0, { omit: ["layers", "features"] });
        var lL = { get paint() {
          return Ow = Ow || new ln({ "fill-extrusion-opacity": new Qt(We["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new cr(We["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Qt(We["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Qt(We["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Zi(We["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new cr(We["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new cr(We["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Qt(We["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class cL extends gn {
          constructor(l, u) {
            super(l, lL, u);
          }
          createBucket(l) {
            return new R0(l);
          }
          queryRadius() {
            return Im(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: l, feature: u, featureState: p, geometry: _, transform: x, pixelsToTileUnits: A, pixelPosMatrix: E }) {
            const M = Pm(l, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -x.bearingInRadians, A), O = this.paint.get("fill-extrusion-height").evaluate(u, p), N = this.paint.get("fill-extrusion-base").evaluate(u, p), V = function(ee, ie) {
              const ue = [];
              for (const ve of ee) {
                const Re = [ve.x, ve.y, 0, 1];
                Be(Re, Re, ie), ue.push(new d(Re[0] / Re[3], Re[1] / Re[3]));
              }
              return ue;
            }(M, E), Y = function(ee, ie, ue, ve) {
              const Re = [], it = [], ze = ve[8] * ie, Ze = ve[9] * ie, yt = ve[10] * ie, Pt = ve[11] * ie, Gt = ve[8] * ue, or = ve[9] * ue, er = ve[10] * ue, nr = ve[11] * ue;
              for (const Ar of ee) {
                const ir = [], sr = [];
                for (const Ft of Ar) {
                  const Gr = Ft.x, Xr = Ft.y, kr = ve[0] * Gr + ve[4] * Xr + ve[12], br = ve[1] * Gr + ve[5] * Xr + ve[13], yi = ve[2] * Gr + ve[6] * Xr + ve[14], Dn = ve[3] * Gr + ve[7] * Xr + ve[15], _s = yi + yt, lo = Dn + Pt, Xa = kr + Gt, la = br + or, qs = yi + er, Mn = Dn + nr, Rs = new d((kr + ze) / lo, (br + Ze) / lo);
                  Rs.z = _s / lo, ir.push(Rs);
                  const Ws = new d(Xa / Mn, la / Mn);
                  Ws.z = qs / Mn, sr.push(Ws);
                }
                Re.push(ir), it.push(sr);
              }
              return [Re, it];
            }(_, N, O, E);
            return function(ee, ie, ue) {
              let ve = 1 / 0;
              cw(ue, ie) && (ve = Dw(ue, ie[0]));
              for (let Re = 0; Re < ie.length; Re++) {
                const it = ie[Re], ze = ee[Re];
                for (let Ze = 0; Ze < it.length - 1; Ze++) {
                  const yt = it[Ze], Pt = [yt, it[Ze + 1], ze[Ze + 1], ze[Ze], yt];
                  lw(ue, Pt) && (ve = Math.min(ve, Dw(ue, Pt)));
                }
              }
              return ve !== 1 / 0 && ve;
            }(Y[0], Y[1], V);
          }
        }
        function eg(h, l) {
          return h.x * l.x + h.y * l.y;
        }
        function Dw(h, l) {
          if (h.length === 1) {
            let u = 0;
            const p = l[u++];
            let _;
            for (; !_ || p.equals(_); ) if (_ = l[u++], !_) return 1 / 0;
            for (; u < l.length; u++) {
              const x = l[u], A = h[0], E = _.sub(p), M = x.sub(p), O = A.sub(p), N = eg(E, E), V = eg(E, M), Y = eg(M, M), ee = eg(O, E), ie = eg(O, M), ue = N * Y - V * V, ve = (Y * ee - V * ie) / ue, Re = (N * ie - V * ee) / ue, it = p.z * (1 - ve - Re) + _.z * ve + x.z * Re;
              if (isFinite(it)) return it;
            }
            return 1 / 0;
          }
          {
            let u = 1 / 0;
            for (const p of l) u = Math.min(u, p.z);
            return u;
          }
        }
        const uL = Ai([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: hL } = uL, fL = Ai([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: dL } = fL, pL = Math.cos(Math.PI / 180 * 37.5), Nw = Math.pow(2, 14) / 0.5;
        class L0 {
          constructor(l) {
            this.zoom = l.zoom, this.overscaling = l.overscaling, this.layers = l.layers, this.layerIds = this.layers.map((u) => u.id), this.index = l.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((u) => {
              this.gradients[u.id] = {};
            }), this.layoutVertexArray = new Qe(), this.layoutVertexArray2 = new At(), this.indexArray = new Vr(), this.programConfigurations = new ou(l.layers, l.zoom), this.segments = new hi(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(l, u, p) {
            this.hasDependencies = Mm("line", this.layers, u) || this.hasLineDasharray(this.layers);
            const _ = this.layers[0].layout.get("line-sort-key"), x = !_.isConstant(), A = [];
            for (const { feature: E, id: M, index: O, sourceLayerIndex: N } of l) {
              const V = this.layers[0]._featureFilter.needGeometry, Y = mf(E, V);
              if (!this.layers[0]._featureFilter.filter(new Wr(this.zoom), Y, p)) continue;
              const ee = x ? _.evaluate(Y, {}, p) : void 0, ie = { id: M, properties: E.properties, type: E.type, sourceLayerIndex: N, index: O, geometry: V ? Y.geometry : sc(E), patterns: {}, dashes: {}, sortKey: ee };
              A.push(ie);
            }
            x && A.sort((E, M) => E.sortKey - M.sortKey);
            for (const E of A) {
              const { geometry: M, index: O, sourceLayerIndex: N } = E;
              this.hasDependencies ? (Mm("line", this.layers, u) ? E0("line", this.layers, E, { zoom: this.zoom }, u) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, E, this.zoom, u), this.patternFeatures.push(E)) : this.addFeature(E, M, O, p, {}, {}, u.subdivisionGranularity), u.featureIndex.insert(l[O].feature, M, O, N, this.index);
            }
          }
          update(l, u, p, _) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(l, u, this.stateDependentLayers, { imagePositions: p, dashPositions: _ });
          }
          addFeatures(l, u, p, _) {
            for (const x of this.patternFeatures) this.addFeature(x, x.geometry, x.index, u, p, _, l.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(l) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = l.createVertexBuffer(this.layoutVertexArray2, dL)), this.layoutVertexBuffer = l.createVertexBuffer(this.layoutVertexArray, hL), this.indexBuffer = l.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(l), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(l) {
            if (l.properties && Object.prototype.hasOwnProperty.call(l.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(l.properties, "mapbox_clip_end")) return { start: +l.properties.mapbox_clip_start, end: +l.properties.mapbox_clip_end };
          }
          addFeature(l, u, p, _, x, A, E) {
            const M = this.layers[0].layout, O = M.get("line-join").evaluate(l, {}), N = M.get("line-cap"), V = M.get("line-miter-limit"), Y = M.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(l);
            for (const ee of u) this.addLine(ee, l, O, N, V, Y, _, E);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, l, p, { imagePositions: x, dashPositions: A, canonical: _ });
          }
          addLine(l, u, p, _, x, A, E, M) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, l = yf(l, E ? M.line.getGranularityForZoomLevel(E.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ze = 0; ze < l.length - 1; ze++) this.totalDistance += l[ze].dist(l[ze + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const O = Ed.types[u.type] === "Polygon";
            let N = l.length;
            for (; N >= 2 && l[N - 1].equals(l[N - 2]); ) N--;
            let V = 0;
            for (; V < N - 1 && l[V].equals(l[V + 1]); ) V++;
            if (N < (O ? 3 : 2)) return;
            p === "bevel" && (x = 1.05);
            const Y = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, ee = this.segments.prepareSegment(10 * N, this.layoutVertexArray, this.indexArray);
            let ie, ue, ve, Re, it;
            this.e1 = this.e2 = -1, O && (ie = l[N - 2], it = l[V].sub(ie)._unit()._perp());
            for (let ze = V; ze < N; ze++) {
              if (ve = ze === N - 1 ? O ? l[V + 1] : void 0 : l[ze + 1], ve && l[ze].equals(ve)) continue;
              it && (Re = it), ie && (ue = ie), ie = l[ze], it = ve ? ve.sub(ie)._unit()._perp() : Re, Re = Re || it;
              let Ze = Re.add(it);
              Ze.x === 0 && Ze.y === 0 || Ze._unit();
              const yt = Re.x * it.x + Re.y * it.y, Pt = Ze.x * it.x + Ze.y * it.y, Gt = Pt !== 0 ? 1 / Pt : 1 / 0, or = 2 * Math.sqrt(2 - 2 * Pt), er = Pt < pL && ue && ve, nr = Re.x * it.y - Re.y * it.x > 0;
              if (er && ze > V) {
                const sr = ie.dist(ue);
                if (sr > 2 * Y) {
                  const Ft = ie.sub(ie.sub(ue)._mult(Y / sr)._round());
                  this.updateDistance(ue, Ft), this.addCurrentVertex(Ft, Re, 0, 0, ee), ue = Ft;
                }
              }
              const Ar = ue && ve;
              let ir = Ar ? p : O ? "butt" : _;
              if (Ar && ir === "round" && (Gt < A ? ir = "miter" : Gt <= 2 && (ir = "fakeround")), ir === "miter" && Gt > x && (ir = "bevel"), ir === "bevel" && (Gt > 2 && (ir = "flipbevel"), Gt < x && (ir = "miter")), ue && this.updateDistance(ue, ie), ir === "miter") Ze._mult(Gt), this.addCurrentVertex(ie, Ze, 0, 0, ee);
              else if (ir === "flipbevel") {
                if (Gt > 100) Ze = it.mult(-1);
                else {
                  const sr = Gt * Re.add(it).mag() / Re.sub(it).mag();
                  Ze._perp()._mult(sr * (nr ? -1 : 1));
                }
                this.addCurrentVertex(ie, Ze, 0, 0, ee), this.addCurrentVertex(ie, Ze.mult(-1), 0, 0, ee);
              } else if (ir === "bevel" || ir === "fakeround") {
                const sr = -Math.sqrt(Gt * Gt - 1), Ft = nr ? sr : 0, Gr = nr ? 0 : sr;
                if (ue && this.addCurrentVertex(ie, Re, Ft, Gr, ee), ir === "fakeround") {
                  const Xr = Math.round(180 * or / Math.PI / 20);
                  for (let kr = 1; kr < Xr; kr++) {
                    let br = kr / Xr;
                    if (br !== 0.5) {
                      const Dn = br - 0.5;
                      br += br * Dn * (br - 1) * ((1.0904 + yt * (yt * (3.55645 - 1.43519 * yt) - 3.2452)) * Dn * Dn + (0.848013 + yt * (0.215638 * yt - 1.06021)));
                    }
                    const yi = it.sub(Re)._mult(br)._add(Re)._unit()._mult(nr ? -1 : 1);
                    this.addHalfVertex(ie, yi.x, yi.y, !1, nr, 0, ee);
                  }
                }
                ve && this.addCurrentVertex(ie, it, -Ft, -Gr, ee);
              } else if (ir === "butt") this.addCurrentVertex(ie, Ze, 0, 0, ee);
              else if (ir === "square") {
                const sr = ue ? 1 : -1;
                this.addCurrentVertex(ie, Ze, sr, sr, ee);
              } else ir === "round" && (ue && (this.addCurrentVertex(ie, Re, 0, 0, ee), this.addCurrentVertex(ie, Re, 1, 1, ee, !0)), ve && (this.addCurrentVertex(ie, it, -1, -1, ee, !0), this.addCurrentVertex(ie, it, 0, 0, ee)));
              if (er && ze < N - 1) {
                const sr = ie.dist(ve);
                if (sr > 2 * Y) {
                  const Ft = ie.add(ve.sub(ie)._mult(Y / sr)._round());
                  this.updateDistance(ie, Ft), this.addCurrentVertex(Ft, it, 0, 0, ee), ie = Ft;
                }
              }
            }
          }
          addCurrentVertex(l, u, p, _, x, A = !1) {
            const E = u.y * _ - u.x, M = -u.y - u.x * _;
            this.addHalfVertex(l, u.x + u.y * p, u.y - u.x * p, A, !1, p, x), this.addHalfVertex(l, E, M, A, !0, -_, x), this.distance > Nw / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(l, u, p, _, x, A));
          }
          addHalfVertex({ x: l, y: u }, p, _, x, A, E, M) {
            const O = 0.5 * (this.lineClips ? this.scaledDistance * (Nw - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((l << 1) + (x ? 1 : 0), (u << 1) + (A ? 1 : 0), Math.round(63 * p) + 128, Math.round(63 * _) + 128, 1 + (E === 0 ? 0 : E < 0 ? -1 : 1) | (63 & O) << 2, O >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const N = M.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, N, this.e2), M.primitiveLength++), A ? this.e2 = N : this.e1 = N;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(l, u) {
            this.distance += l.dist(u), this.updateScaledDistance();
          }
          hasLineDasharray(l) {
            for (const u of l) {
              const p = u.paint.get("line-dasharray");
              if (p && !p.isConstant()) return !0;
            }
            return !1;
          }
          addLineDashDependencies(l, u, p, _) {
            for (const x of l) {
              const A = x.paint.get("line-dasharray");
              if (!A || A.value.kind === "constant") continue;
              const E = x.layout.get("line-cap") === "round", M = { dasharray: A.value.evaluate({ zoom: p - 1 }, u, {}), round: E }, O = { dasharray: A.value.evaluate({ zoom: p }, u, {}), round: E }, N = { dasharray: A.value.evaluate({ zoom: p + 1 }, u, {}), round: E }, V = `${M.dasharray.join(",")},${M.round}`, Y = `${O.dasharray.join(",")},${O.round}`, ee = `${N.dasharray.join(",")},${N.round}`;
              _.dashDependencies[V] = M, _.dashDependencies[Y] = O, _.dashDependencies[ee] = N, u.dashes[x.id] = { min: V, mid: Y, max: ee };
            }
          }
        }
        let Fw, Uw;
        me("LineBucket", L0, { omit: ["layers", "patternFeatures"] });
        var zw = { get paint() {
          return Uw = Uw || new ln({ "line-opacity": new cr(We.paint_line["line-opacity"]), "line-color": new cr(We.paint_line["line-color"]), "line-translate": new Qt(We.paint_line["line-translate"]), "line-translate-anchor": new Qt(We.paint_line["line-translate-anchor"]), "line-width": new cr(We.paint_line["line-width"]), "line-gap-width": new cr(We.paint_line["line-gap-width"]), "line-offset": new cr(We.paint_line["line-offset"]), "line-blur": new cr(We.paint_line["line-blur"]), "line-dasharray": new Zi(We.paint_line["line-dasharray"]), "line-pattern": new Zi(We.paint_line["line-pattern"]), "line-gradient": new On(We.paint_line["line-gradient"]) });
        }, get layout() {
          return Fw = Fw || new ln({ "line-cap": new Qt(We.layout_line["line-cap"]), "line-join": new cr(We.layout_line["line-join"]), "line-miter-limit": new Qt(We.layout_line["line-miter-limit"]), "line-round-limit": new Qt(We.layout_line["line-round-limit"]), "line-sort-key": new cr(We.layout_line["line-sort-key"]) });
        } };
        class gL extends cr {
          possiblyEvaluate(l, u) {
            return u = new Wr(Math.floor(u.zoom), { now: u.now, fadeDuration: u.fadeDuration, zoomHistory: u.zoomHistory, transition: u.transition }), super.possiblyEvaluate(l, u);
          }
          evaluate(l, u, p, _) {
            return u = Et({}, u, { zoom: Math.floor(u.zoom) }), super.evaluate(l, u, p, _);
          }
        }
        let km;
        class mL extends gn {
          constructor(l, u) {
            super(l, zw, u), this.gradientVersion = 0, km || (km = new gL(zw.paint.properties["line-width"].specification), km.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(l) {
            if (l === "line-gradient") {
              const u = this.gradientExpression();
              this.stepInterpolant = !!function(p) {
                return p._styleExpression !== void 0;
              }(u) && u._styleExpression.expression instanceof Ye, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(l, u) {
            super.recalculate(l, u), this.paint._values["line-floorwidth"] = km.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, l);
          }
          createBucket(l) {
            return new L0(l);
          }
          queryRadius(l) {
            const u = l, p = jw(wd("line-width", this, u), wd("line-gap-width", this, u)), _ = wd("line-offset", this, u);
            return p / 2 + Math.abs(_) + Im(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: l, feature: u, featureState: p, geometry: _, transform: x, pixelsToTileUnits: A }) {
            const E = Pm(l, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -x.bearingInRadians, A), M = A / 2 * jw(this.paint.get("line-width").evaluate(u, p), this.paint.get("line-gap-width").evaluate(u, p)), O = this.paint.get("line-offset").evaluate(u, p);
            return O && (_ = function(N, V) {
              const Y = [];
              for (let ee = 0; ee < N.length; ee++) {
                const ie = N[ee], ue = [];
                for (let ve = 0; ve < ie.length; ve++) {
                  const Re = ie[ve - 1], it = ie[ve], ze = ie[ve + 1], Ze = ve === 0 ? new d(0, 0) : it.sub(Re)._unit()._perp(), yt = ve === ie.length - 1 ? new d(0, 0) : ze.sub(it)._unit()._perp(), Pt = Ze._add(yt)._unit(), Gt = Pt.x * yt.x + Pt.y * yt.y;
                  Gt !== 0 && Pt._mult(1 / Gt), ue.push(Pt._mult(V)._add(it));
                }
                Y.push(ue);
              }
              return Y;
            }(_, O * A)), function(N, V, Y) {
              for (let ee = 0; ee < V.length; ee++) {
                const ie = V[ee];
                if (N.length >= 3) {
                  for (let ue = 0; ue < ie.length; ue++) if (xd(N, ie[ue])) return !0;
                }
                if (A4(N, ie, Y)) return !0;
              }
              return !1;
            }(E, _, M);
          }
          isTileClipped() {
            return !0;
          }
        }
        function jw(h, l) {
          return l > 0 ? l + 2 * h : h;
        }
        const _L = Ai([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), yL = Ai([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Ai([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const bL = Ai([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Ai([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Vw = Ai([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), vL = Ai([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function xL(h, l, u) {
          return h.sections.forEach((p) => {
            p.text = function(_, x, A) {
              const E = x.layout.get("text-transform").evaluate(A, {});
              return E === "uppercase" ? _ = _.toLocaleUpperCase() : E === "lowercase" && (_ = _.toLocaleLowerCase()), lr.applyArabicShaping && (_ = lr.applyArabicShaping(_)), _;
            }(p.text, l, u);
          }), h;
        }
        Ai([{ name: "triangle", components: 3, type: "Uint16" }]), Ai([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ai([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Ai([{ type: "Float32", name: "offsetX" }]), Ai([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Ai([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const tg = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
        var Ms = 24;
        const B0 = 4294967296, Gw = 1 / B0, $w = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class k0 {
          constructor(l = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(l) ? l : new Uint8Array(l), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(l, u, p = this.length) {
            for (; this.pos < p; ) {
              const _ = this.readVarint(), x = _ >> 3, A = this.pos;
              this.type = 7 & _, l(x, u, this), this.pos === A && this.skip(_);
            }
            return u;
          }
          readMessage(l, u) {
            return this.readFields(l, u, this.readVarint() + this.pos);
          }
          readFixed32() {
            const l = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, l;
          }
          readSFixed32() {
            const l = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, l;
          }
          readFixed64() {
            const l = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * B0;
            return this.pos += 8, l;
          }
          readSFixed64() {
            const l = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * B0;
            return this.pos += 8, l;
          }
          readFloat() {
            const l = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, l;
          }
          readDouble() {
            const l = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, l;
          }
          readVarint(l) {
            const u = this.buf;
            let p, _;
            return _ = u[this.pos++], p = 127 & _, _ < 128 ? p : (_ = u[this.pos++], p |= (127 & _) << 7, _ < 128 ? p : (_ = u[this.pos++], p |= (127 & _) << 14, _ < 128 ? p : (_ = u[this.pos++], p |= (127 & _) << 21, _ < 128 ? p : (_ = u[this.pos], p |= (15 & _) << 28, function(x, A, E) {
              const M = E.buf;
              let O, N;
              if (N = M[E.pos++], O = (112 & N) >> 4, N < 128 || (N = M[E.pos++], O |= (127 & N) << 3, N < 128) || (N = M[E.pos++], O |= (127 & N) << 10, N < 128) || (N = M[E.pos++], O |= (127 & N) << 17, N < 128) || (N = M[E.pos++], O |= (127 & N) << 24, N < 128) || (N = M[E.pos++], O |= (1 & N) << 31, N < 128)) return Cd(x, O, A);
              throw new Error("Expected varint not more than 10 bytes");
            }(p, l, this)))));
          }
          readVarint64() {
            return this.readVarint(!0);
          }
          readSVarint() {
            const l = this.readVarint();
            return l % 2 == 1 ? (l + 1) / -2 : l / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const l = this.readVarint() + this.pos, u = this.pos;
            return this.pos = l, l - u >= 12 && $w ? $w.decode(this.buf.subarray(u, l)) : function(p, _, x) {
              let A = "", E = _;
              for (; E < x; ) {
                const M = p[E];
                let O, N, V, Y = null, ee = M > 239 ? 4 : M > 223 ? 3 : M > 191 ? 2 : 1;
                if (E + ee > x) break;
                ee === 1 ? M < 128 && (Y = M) : ee === 2 ? (O = p[E + 1], (192 & O) == 128 && (Y = (31 & M) << 6 | 63 & O, Y <= 127 && (Y = null))) : ee === 3 ? (O = p[E + 1], N = p[E + 2], (192 & O) == 128 && (192 & N) == 128 && (Y = (15 & M) << 12 | (63 & O) << 6 | 63 & N, (Y <= 2047 || Y >= 55296 && Y <= 57343) && (Y = null))) : ee === 4 && (O = p[E + 1], N = p[E + 2], V = p[E + 3], (192 & O) == 128 && (192 & N) == 128 && (192 & V) == 128 && (Y = (15 & M) << 18 | (63 & O) << 12 | (63 & N) << 6 | 63 & V, (Y <= 65535 || Y >= 1114112) && (Y = null))), Y === null ? (Y = 65533, ee = 1) : Y > 65535 && (Y -= 65536, A += String.fromCharCode(Y >>> 10 & 1023 | 55296), Y = 56320 | 1023 & Y), A += String.fromCharCode(Y), E += ee;
              }
              return A;
            }(this.buf, u, l);
          }
          readBytes() {
            const l = this.readVarint() + this.pos, u = this.buf.subarray(this.pos, l);
            return this.pos = l, u;
          }
          readPackedVarint(l = [], u) {
            const p = this.readPackedEnd();
            for (; this.pos < p; ) l.push(this.readVarint(u));
            return l;
          }
          readPackedSVarint(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readSVarint());
            return l;
          }
          readPackedBoolean(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readBoolean());
            return l;
          }
          readPackedFloat(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readFloat());
            return l;
          }
          readPackedDouble(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readDouble());
            return l;
          }
          readPackedFixed32(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readFixed32());
            return l;
          }
          readPackedSFixed32(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readSFixed32());
            return l;
          }
          readPackedFixed64(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readFixed64());
            return l;
          }
          readPackedSFixed64(l = []) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) l.push(this.readSFixed64());
            return l;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(l) {
            const u = 7 & l;
            if (u === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (u === 2) this.pos = this.readVarint() + this.pos;
            else if (u === 5) this.pos += 4;
            else {
              if (u !== 1) throw new Error(`Unimplemented type: ${u}`);
              this.pos += 8;
            }
          }
          writeTag(l, u) {
            this.writeVarint(l << 3 | u);
          }
          realloc(l) {
            let u = this.length || 16;
            for (; u < this.pos + l; ) u *= 2;
            if (u !== this.length) {
              const p = new Uint8Array(u);
              p.set(this.buf), this.buf = p, this.dataView = new DataView(p.buffer), this.length = u;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(l) {
            this.realloc(4), this.dataView.setInt32(this.pos, l, !0), this.pos += 4;
          }
          writeSFixed32(l) {
            this.realloc(4), this.dataView.setInt32(this.pos, l, !0), this.pos += 4;
          }
          writeFixed64(l) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & l, !0), this.dataView.setInt32(this.pos + 4, Math.floor(l * Gw), !0), this.pos += 8;
          }
          writeSFixed64(l) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & l, !0), this.dataView.setInt32(this.pos + 4, Math.floor(l * Gw), !0), this.pos += 8;
          }
          writeVarint(l) {
            (l = +l || 0) > 268435455 || l < 0 ? function(u, p) {
              let _, x;
              if (u >= 0 ? (_ = u % 4294967296 | 0, x = u / 4294967296 | 0) : (_ = ~(-u % 4294967296), x = ~(-u / 4294967296), 4294967295 ^ _ ? _ = _ + 1 | 0 : (_ = 0, x = x + 1 | 0)), u >= 18446744073709552e3 || u < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              p.realloc(10), function(A, E, M) {
                M.buf[M.pos++] = 127 & A | 128, A >>>= 7, M.buf[M.pos++] = 127 & A | 128, A >>>= 7, M.buf[M.pos++] = 127 & A | 128, A >>>= 7, M.buf[M.pos++] = 127 & A | 128, M.buf[M.pos] = 127 & (A >>>= 7);
              }(_, 0, p), function(A, E) {
                const M = (7 & A) << 4;
                E.buf[E.pos++] |= M | ((A >>>= 3) ? 128 : 0), A && (E.buf[E.pos++] = 127 & A | ((A >>>= 7) ? 128 : 0), A && (E.buf[E.pos++] = 127 & A | ((A >>>= 7) ? 128 : 0), A && (E.buf[E.pos++] = 127 & A | ((A >>>= 7) ? 128 : 0), A && (E.buf[E.pos++] = 127 & A | ((A >>>= 7) ? 128 : 0), A && (E.buf[E.pos++] = 127 & A)))));
              }(x, p);
            }(l, this) : (this.realloc(4), this.buf[this.pos++] = 127 & l | (l > 127 ? 128 : 0), l <= 127 || (this.buf[this.pos++] = 127 & (l >>>= 7) | (l > 127 ? 128 : 0), l <= 127 || (this.buf[this.pos++] = 127 & (l >>>= 7) | (l > 127 ? 128 : 0), l <= 127 || (this.buf[this.pos++] = l >>> 7 & 127))));
          }
          writeSVarint(l) {
            this.writeVarint(l < 0 ? 2 * -l - 1 : 2 * l);
          }
          writeBoolean(l) {
            this.writeVarint(+l);
          }
          writeString(l) {
            l = String(l), this.realloc(4 * l.length), this.pos++;
            const u = this.pos;
            this.pos = function(_, x, A) {
              for (let E, M, O = 0; O < x.length; O++) {
                if (E = x.charCodeAt(O), E > 55295 && E < 57344) {
                  if (!M) {
                    E > 56319 || O + 1 === x.length ? (_[A++] = 239, _[A++] = 191, _[A++] = 189) : M = E;
                    continue;
                  }
                  if (E < 56320) {
                    _[A++] = 239, _[A++] = 191, _[A++] = 189, M = E;
                    continue;
                  }
                  E = M - 55296 << 10 | E - 56320 | 65536, M = null;
                } else M && (_[A++] = 239, _[A++] = 191, _[A++] = 189, M = null);
                E < 128 ? _[A++] = E : (E < 2048 ? _[A++] = E >> 6 | 192 : (E < 65536 ? _[A++] = E >> 12 | 224 : (_[A++] = E >> 18 | 240, _[A++] = E >> 12 & 63 | 128), _[A++] = E >> 6 & 63 | 128), _[A++] = 63 & E | 128);
              }
              return A;
            }(this.buf, l, this.pos);
            const p = this.pos - u;
            p >= 128 && Hw(u, p, this), this.pos = u - 1, this.writeVarint(p), this.pos += p;
          }
          writeFloat(l) {
            this.realloc(4), this.dataView.setFloat32(this.pos, l, !0), this.pos += 4;
          }
          writeDouble(l) {
            this.realloc(8), this.dataView.setFloat64(this.pos, l, !0), this.pos += 8;
          }
          writeBytes(l) {
            const u = l.length;
            this.writeVarint(u), this.realloc(u);
            for (let p = 0; p < u; p++) this.buf[this.pos++] = l[p];
          }
          writeRawMessage(l, u) {
            this.pos++;
            const p = this.pos;
            l(u, this);
            const _ = this.pos - p;
            _ >= 128 && Hw(p, _, this), this.pos = p - 1, this.writeVarint(_), this.pos += _;
          }
          writeMessage(l, u, p) {
            this.writeTag(l, 2), this.writeRawMessage(u, p);
          }
          writePackedVarint(l, u) {
            u.length && this.writeMessage(l, wL, u);
          }
          writePackedSVarint(l, u) {
            u.length && this.writeMessage(l, AL, u);
          }
          writePackedBoolean(l, u) {
            u.length && this.writeMessage(l, EL, u);
          }
          writePackedFloat(l, u) {
            u.length && this.writeMessage(l, TL, u);
          }
          writePackedDouble(l, u) {
            u.length && this.writeMessage(l, SL, u);
          }
          writePackedFixed32(l, u) {
            u.length && this.writeMessage(l, CL, u);
          }
          writePackedSFixed32(l, u) {
            u.length && this.writeMessage(l, IL, u);
          }
          writePackedFixed64(l, u) {
            u.length && this.writeMessage(l, PL, u);
          }
          writePackedSFixed64(l, u) {
            u.length && this.writeMessage(l, ML, u);
          }
          writeBytesField(l, u) {
            this.writeTag(l, 2), this.writeBytes(u);
          }
          writeFixed32Field(l, u) {
            this.writeTag(l, 5), this.writeFixed32(u);
          }
          writeSFixed32Field(l, u) {
            this.writeTag(l, 5), this.writeSFixed32(u);
          }
          writeFixed64Field(l, u) {
            this.writeTag(l, 1), this.writeFixed64(u);
          }
          writeSFixed64Field(l, u) {
            this.writeTag(l, 1), this.writeSFixed64(u);
          }
          writeVarintField(l, u) {
            this.writeTag(l, 0), this.writeVarint(u);
          }
          writeSVarintField(l, u) {
            this.writeTag(l, 0), this.writeSVarint(u);
          }
          writeStringField(l, u) {
            this.writeTag(l, 2), this.writeString(u);
          }
          writeFloatField(l, u) {
            this.writeTag(l, 5), this.writeFloat(u);
          }
          writeDoubleField(l, u) {
            this.writeTag(l, 1), this.writeDouble(u);
          }
          writeBooleanField(l, u) {
            this.writeVarintField(l, +u);
          }
        }
        function Cd(h, l, u) {
          return u ? 4294967296 * l + (h >>> 0) : 4294967296 * (l >>> 0) + (h >>> 0);
        }
        function Hw(h, l, u) {
          const p = l <= 16383 ? 1 : l <= 2097151 ? 2 : l <= 268435455 ? 3 : Math.floor(Math.log(l) / (7 * Math.LN2));
          u.realloc(p);
          for (let _ = u.pos - 1; _ >= h; _--) u.buf[_ + p] = u.buf[_];
        }
        function wL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeVarint(h[u]);
        }
        function AL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeSVarint(h[u]);
        }
        function TL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeFloat(h[u]);
        }
        function SL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeDouble(h[u]);
        }
        function EL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeBoolean(h[u]);
        }
        function CL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeFixed32(h[u]);
        }
        function IL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeSFixed32(h[u]);
        }
        function PL(h, l) {
          for (let u = 0; u < h.length; u++) l.writeFixed64(h[u]);
        }
        function ML(h, l) {
          for (let u = 0; u < h.length; u++) l.writeSFixed64(h[u]);
        }
        function RL(h, l, u) {
          h === 1 && u.readMessage(LL, l);
        }
        function LL(h, l, u) {
          if (h === 3) {
            const { id: p, bitmap: _, width: x, height: A, left: E, top: M, advance: O } = u.readMessage(BL, {});
            l.push({ id: p, bitmap: new qp({ width: x + 6, height: A + 6 }, _), metrics: { width: x, height: A, left: E, top: M, advance: O } });
          }
        }
        function BL(h, l, u) {
          h === 1 ? l.id = u.readVarint() : h === 2 ? l.bitmap = u.readBytes() : h === 3 ? l.width = u.readVarint() : h === 4 ? l.height = u.readVarint() : h === 5 ? l.left = u.readSVarint() : h === 6 ? l.top = u.readSVarint() : h === 7 && (l.advance = u.readVarint());
        }
        function qw(h) {
          let l = 0, u = 0;
          for (const A of h) l += A.w * A.h, u = Math.max(u, A.w);
          h.sort((A, E) => E.h - A.h);
          const p = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(l / 0.95)), u), h: 1 / 0 }];
          let _ = 0, x = 0;
          for (const A of h) for (let E = p.length - 1; E >= 0; E--) {
            const M = p[E];
            if (!(A.w > M.w || A.h > M.h)) {
              if (A.x = M.x, A.y = M.y, x = Math.max(x, A.y + A.h), _ = Math.max(_, A.x + A.w), A.w === M.w && A.h === M.h) {
                const O = p.pop();
                O && E < p.length && (p[E] = O);
              } else A.h === M.h ? (M.x += A.w, M.w -= A.w) : A.w === M.w ? (M.y += A.h, M.h -= A.h) : (p.push({ x: M.x + A.w, y: M.y, w: M.w - A.w, h: A.h }), M.y += A.h, M.h -= A.h);
              break;
            }
          }
          return { w: _, h: x, fill: l / (_ * x) || 0 };
        }
        class O0 {
          constructor(l, { pixelRatio: u, version: p, stretchX: _, stretchY: x, content: A, textFitWidth: E, textFitHeight: M }) {
            this.paddedRect = l, this.pixelRatio = u, this.stretchX = _, this.stretchY = x, this.content = A, this.version = p, this.textFitWidth = E, this.textFitHeight = M;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Ww {
          constructor(l, u) {
            const p = {}, _ = {};
            this.haveRenderCallbacks = [];
            const x = [];
            this.addImages(l, p, x), this.addImages(u, _, x);
            const { w: A, h: E } = qw(x), M = new aa({ width: A || 1, height: E || 1 });
            for (const O in l) {
              const N = l[O], V = p[O].paddedRect;
              aa.copy(N.data, M, { x: 0, y: 0 }, { x: V.x + 1, y: V.y + 1 }, N.data);
            }
            for (const O in u) {
              const N = u[O], V = _[O].paddedRect, Y = V.x + 1, ee = V.y + 1, ie = N.data.width, ue = N.data.height;
              aa.copy(N.data, M, { x: 0, y: 0 }, { x: Y, y: ee }, N.data), aa.copy(N.data, M, { x: 0, y: ue - 1 }, { x: Y, y: ee - 1 }, { width: ie, height: 1 }), aa.copy(N.data, M, { x: 0, y: 0 }, { x: Y, y: ee + ue }, { width: ie, height: 1 }), aa.copy(N.data, M, { x: ie - 1, y: 0 }, { x: Y - 1, y: ee }, { width: 1, height: ue }), aa.copy(N.data, M, { x: 0, y: 0 }, { x: Y + ie, y: ee }, { width: 1, height: ue });
            }
            this.image = M, this.iconPositions = p, this.patternPositions = _;
          }
          addImages(l, u, p) {
            for (const _ in l) {
              const x = l[_], A = { x: 0, y: 0, w: x.data.width + 2, h: x.data.height + 2 };
              p.push(A), u[_] = new O0(A, x), x.hasRenderCallback && this.haveRenderCallbacks.push(_);
            }
          }
          patchUpdatedImages(l, u) {
            l.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const p in l.updatedImages) this.patchUpdatedImage(this.iconPositions[p], l.getImage(p), u), this.patchUpdatedImage(this.patternPositions[p], l.getImage(p), u);
          }
          patchUpdatedImage(l, u, p) {
            if (!l || !u || l.version === u.version) return;
            l.version = u.version;
            const [_, x] = l.tl;
            p.update(u.data, void 0, { x: _, y: x });
          }
        }
        var Th;
        me("ImagePosition", O0), me("ImageAtlas", Ww), c.ao = void 0, (Th = c.ao || (c.ao = {}))[Th.none = 0] = "none", Th[Th.horizontal = 1] = "horizontal", Th[Th.vertical = 2] = "vertical", Th[Th.horizontalOnly = 3] = "horizontalOnly";
        class rg {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(l, u, p) {
            const _ = new rg();
            return _.scale = l || 1, _.fontStack = u, _.verticalAlign = p || "bottom", _;
          }
          static forImage(l, u) {
            const p = new rg();
            return p.imageName = l, p.verticalAlign = u || "bottom", p;
          }
        }
        class Id {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(l, u) {
            const p = new Id();
            for (let _ = 0; _ < l.sections.length; _++) {
              const x = l.sections[_];
              x.image ? p.addImageSection(x) : p.addTextSection(x, u);
            }
            return p;
          }
          length() {
            return this.text.length;
          }
          getSection(l) {
            return this.sections[this.sectionIndex[l]];
          }
          getSectionIndex(l) {
            return this.sectionIndex[l];
          }
          getCharCode(l) {
            return this.text.charCodeAt(l);
          }
          verticalizePunctuation() {
            this.text = function(l) {
              let u = "";
              for (let p = 0; p < l.length; p++) {
                const _ = l.charCodeAt(p + 1) || null, x = l.charCodeAt(p - 1) || null;
                u += _ && Tr(_) && !tg[l[p + 1]] || x && Tr(x) && !tg[l[p - 1]] || !tg[l[p]] ? l[p] : tg[l[p]];
              }
              return u;
            }(this.text);
          }
          trim() {
            let l = 0;
            for (let p = 0; p < this.text.length && Dm[this.text.charCodeAt(p)]; p++) l++;
            let u = this.text.length;
            for (let p = this.text.length - 1; p >= 0 && p >= l && Dm[this.text.charCodeAt(p)]; p--) u--;
            this.text = this.text.substring(l, u), this.sectionIndex = this.sectionIndex.slice(l, u);
          }
          substring(l, u) {
            const p = new Id();
            return p.text = this.text.substring(l, u), p.sectionIndex = this.sectionIndex.slice(l, u), p.sections = this.sections, p;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((l, u) => Math.max(l, this.sections[u].scale), 0);
          }
          getMaxImageSize(l) {
            let u = 0, p = 0;
            for (let _ = 0; _ < this.length(); _++) {
              const x = this.getSection(_);
              if (x.imageName) {
                const A = l[x.imageName];
                if (!A) continue;
                const E = A.displaySize;
                u = Math.max(u, E[0]), p = Math.max(p, E[1]);
              }
            }
            return { maxImageWidth: u, maxImageHeight: p };
          }
          addTextSection(l, u) {
            this.text += l.text, this.sections.push(rg.forText(l.scale, l.fontStack || u, l.verticalAlign));
            const p = this.sections.length - 1;
            for (let _ = 0; _ < l.text.length; ++_) this.sectionIndex.push(p);
          }
          addImageSection(l) {
            const u = l.image ? l.image.name : "";
            if (u.length === 0) return void Ct("Can't add FormattedSection with an empty image.");
            const p = this.getNextImageSectionCharCode();
            p ? (this.text += String.fromCharCode(p), this.sections.push(rg.forImage(u, l.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Ct("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Om(h, l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie) {
          const ue = Id.fromFeature(h, _);
          let ve;
          V === c.ao.vertical && ue.verticalizePunctuation();
          const { processBidirectionalText: Re, processStyledBidirectionalText: it } = lr;
          if (Re && ue.sections.length === 1) {
            ve = [];
            const yt = Re(ue.toString(), D0(ue, O, x, l, p, ee));
            for (const Pt of yt) {
              const Gt = new Id();
              Gt.text = Pt, Gt.sections = ue.sections;
              for (let or = 0; or < Pt.length; or++) Gt.sectionIndex.push(0);
              ve.push(Gt);
            }
          } else if (it) {
            ve = [];
            const yt = it(ue.text, ue.sectionIndex, D0(ue, O, x, l, p, ee));
            for (const Pt of yt) {
              const Gt = new Id();
              Gt.text = Pt[0], Gt.sectionIndex = Pt[1], Gt.sections = ue.sections, ve.push(Gt);
            }
          } else ve = function(yt, Pt) {
            const Gt = [], or = yt.text;
            let er = 0;
            for (const nr of Pt) Gt.push(yt.substring(er, nr)), er = nr;
            return er < or.length && Gt.push(yt.substring(er, or.length)), Gt;
          }(ue, D0(ue, O, x, l, p, ee));
          const ze = [], Ze = { positionedLines: ze, text: ue.toString(), top: N[1], bottom: N[1], left: N[0], right: N[0], writingMode: V, iconsInText: !1, verticalizable: !1 };
          return function(yt, Pt, Gt, or, er, nr, Ar, ir, sr, Ft, Gr, Xr) {
            let kr = 0, br = 0, yi = 0, Dn = 0;
            const _s = ir === "right" ? 1 : ir === "left" ? 0 : 0.5, lo = Ms / Xr;
            let Xa = 0;
            for (const Mn of er) {
              Mn.trim();
              const Rs = Mn.getMaxScale(), Ws = { positionedGlyphs: [], lineOffset: 0 };
              yt.positionedLines[Xa] = Ws;
              const Xs = Ws.positionedGlyphs;
              let Bo = 0;
              if (!Mn.length()) {
                br += nr, ++Xa;
                continue;
              }
              const Za = NL(or, Mn, lo);
              for (let ca = 0; ca < Mn.length(); ca++) {
                const ys = Mn.getSection(ca), Bs = Mn.getSectionIndex(ca), ks = Mn.getCharCode(ca), ss = FL(sr, Gr, ks);
                let mn;
                if (ys.imageName) {
                  if (yt.iconsInText = !0, ys.scale = ys.scale * lo, mn = zL(ys, ss, Rs, Za, or), !mn) continue;
                  Bo = Math.max(Bo, mn.imageOffset);
                } else if (mn = UL(ys, ks, ss, Za, Pt, Gt), !mn) continue;
                const { rect: oc, metrics: Ld, baselineOffset: ac } = mn;
                Xs.push({ glyph: ks, imageName: ys.imageName, x: kr, y: br + ac + -17, vertical: ss, scale: ys.scale, fontStack: ys.fontStack, sectionIndex: Bs, metrics: Ld, rect: oc }), ss ? (yt.verticalizable = !0, kr += (ys.imageName ? Ld.advance : Ms) * ys.scale + Ft) : kr += Ld.advance * ys.scale + Ft;
              }
              Xs.length !== 0 && (yi = Math.max(kr - Ft, yi), jL(Xs, 0, Xs.length - 1, _s)), kr = 0, Ws.lineOffset = Math.max(Bo, (Rs - 1) * Ms);
              const Ls = nr * Rs + Bo;
              br += Ls, Dn = Math.max(Ls, Dn), ++Xa;
            }
            const { horizontalAlign: la, verticalAlign: qs } = N0(Ar);
            (function(Mn, Rs, Ws, Xs, Bo, Za, Ls, ca, ys) {
              const Bs = (Rs - Ws) * Bo;
              let ks = 0;
              ks = Za !== Ls ? -ca * Xs - -17 : -Xs * ys * Ls + 0.5 * Ls;
              for (const ss of Mn) for (const mn of ss.positionedGlyphs) mn.x += Bs, mn.y += ks;
            })(yt.positionedLines, _s, la, qs, yi, Dn, nr, br, er.length), yt.top += -qs * br, yt.bottom = yt.top + br, yt.left += -la * yi, yt.right = yt.left + yi;
          }(Ze, l, u, p, ve, A, E, M, V, O, Y, ie), !function(yt) {
            for (const Pt of yt) if (Pt.positionedGlyphs.length !== 0) return !1;
            return !0;
          }(ze) && Ze;
        }
        const Dm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, kL = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, OL = { 40: !0 };
        function Xw(h, l, u, p, _, x) {
          if (l.imageName) {
            const A = p[l.imageName];
            return A ? A.displaySize[0] * l.scale * Ms / x + _ : 0;
          }
          {
            const A = u[l.fontStack], E = A && A[h];
            return E ? E.metrics.advance * l.scale + _ : 0;
          }
        }
        function Zw(h, l, u, p) {
          const _ = Math.pow(h - l, 2);
          return p ? h < l ? _ / 2 : 2 * _ : _ + Math.abs(u) * u;
        }
        function DL(h, l, u) {
          let p = 0;
          return h === 10 && (p -= 1e4), u && (p += 150), h !== 40 && h !== 65288 || (p += 50), l !== 41 && l !== 65289 || (p += 50), p;
        }
        function Yw(h, l, u, p, _, x) {
          let A = null, E = Zw(l, u, _, x);
          for (const M of p) {
            const O = Zw(l - M.x, u, _, x) + M.badness;
            O <= E && (A = M, E = O);
          }
          return { index: h, x: l, priorBreak: A, badness: E };
        }
        function Jw(h) {
          return h ? Jw(h.priorBreak).concat(h.index) : [];
        }
        function D0(h, l, u, p, _, x) {
          if (!h) return [];
          const A = [], E = function(V, Y, ee, ie, ue, ve) {
            let Re = 0;
            for (let it = 0; it < V.length(); it++) {
              const ze = V.getSection(it);
              Re += Xw(V.getCharCode(it), ze, ie, ue, Y, ve);
            }
            return Re / Math.max(1, Math.ceil(Re / ee));
          }(h, l, u, p, _, x), M = h.text.indexOf("​") >= 0;
          let O = 0;
          for (let V = 0; V < h.length(); V++) {
            const Y = h.getSection(V), ee = h.getCharCode(V);
            if (Dm[ee] || (O += Xw(ee, Y, p, _, l, x)), V < h.length() - 1) {
              const ie = !((N = ee) < 11904) && (!!tt["CJK Compatibility Forms"](N) || !!tt["CJK Compatibility"](N) || !!tt["CJK Strokes"](N) || !!tt["CJK Symbols and Punctuation"](N) || !!tt["Enclosed CJK Letters and Months"](N) || !!tt["Halfwidth and Fullwidth Forms"](N) || !!tt["Ideographic Description Characters"](N) || !!tt["Vertical Forms"](N) || yr.test(String.fromCodePoint(N)));
              (kL[ee] || ie || Y.imageName || V !== h.length() - 2 && OL[h.getCharCode(V + 1)]) && A.push(Yw(V + 1, O, E, A, DL(ee, h.getCharCode(V + 1), ie && M), !1));
            }
          }
          var N;
          return Jw(Yw(h.length(), O, E, A, 0, !0));
        }
        function N0(h) {
          let l = 0.5, u = 0.5;
          switch (h) {
            case "right":
            case "top-right":
            case "bottom-right":
              l = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              l = 0;
          }
          switch (h) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              u = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              u = 0;
          }
          return { horizontalAlign: l, verticalAlign: u };
        }
        function NL(h, l, u) {
          const p = l.getMaxScale() * Ms, { maxImageWidth: _, maxImageHeight: x } = l.getMaxImageSize(h), A = Math.max(p, x * u);
          return { verticalLineContentWidth: Math.max(p, _ * u), horizontalLineContentHeight: A };
        }
        function Kw(h) {
          switch (h) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function FL(h, l, u) {
          return !(h === c.ao.horizontal || !l && !si(u) || l && (Dm[u] || (p = u, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(p)))));
          var p;
        }
        function UL(h, l, u, p, _, x) {
          const A = x[h.fontStack], E = function(O, N, V, Y) {
            if (O && O.rect) return O;
            const ee = N[V.fontStack], ie = ee && ee[Y];
            return ie ? { rect: null, metrics: ie.metrics } : null;
          }(A && A[l], _, h, l);
          if (E === null) return null;
          let M;
          if (u) M = p.verticalLineContentWidth - h.scale * Ms;
          else {
            const O = Kw(h.verticalAlign);
            M = (p.horizontalLineContentHeight - h.scale * Ms) * O;
          }
          return { rect: E.rect, metrics: E.metrics, baselineOffset: M };
        }
        function zL(h, l, u, p, _) {
          const x = _[h.imageName];
          if (!x) return null;
          const A = x.paddedRect, E = x.displaySize, M = { width: E[0], height: E[1], left: 1, top: -3, advance: l ? E[1] : E[0] };
          let O;
          if (l) O = p.verticalLineContentWidth - E[1] * h.scale;
          else {
            const N = Kw(h.verticalAlign);
            O = (p.horizontalLineContentHeight - E[1] * h.scale) * N;
          }
          return { rect: A, metrics: M, baselineOffset: O, imageOffset: (l ? E[0] : E[1]) * h.scale - Ms * u };
        }
        function jL(h, l, u, p) {
          if (p === 0) return;
          const _ = h[u], x = (h[u].x + _.metrics.advance * _.scale) * p;
          for (let A = l; A <= u; A++) h[A].x -= x;
        }
        function VL(h, l, u) {
          const { horizontalAlign: p, verticalAlign: _ } = N0(u), x = l[0] - h.displaySize[0] * p, A = l[1] - h.displaySize[1] * _;
          return { image: h, top: A, bottom: A + h.displaySize[1], left: x, right: x + h.displaySize[0] };
        }
        function Qw(h) {
          var l, u;
          let p = h.left, _ = h.top, x = h.right - p, A = h.bottom - _;
          const E = (l = h.image.textFitWidth) !== null && l !== void 0 ? l : "stretchOrShrink", M = (u = h.image.textFitHeight) !== null && u !== void 0 ? u : "stretchOrShrink", O = (h.image.content[2] - h.image.content[0]) / (h.image.content[3] - h.image.content[1]);
          if (M === "proportional") {
            if (E === "stretchOnly" && x / A < O || E === "proportional") {
              const N = Math.ceil(A * O);
              p *= N / x, x = N;
            }
          } else if (E === "proportional" && M === "stretchOnly" && O !== 0 && x / A > O) {
            const N = Math.ceil(x / O);
            _ *= N / A, A = N;
          }
          return { x1: p, y1: _, x2: p + x, y2: _ + A };
        }
        function eA(h, l, u, p, _, x) {
          const A = h.image;
          let E;
          if (A.content) {
            const ve = A.content, Re = A.pixelRatio || 1;
            E = [ve[0] / Re, ve[1] / Re, A.displaySize[0] - ve[2] / Re, A.displaySize[1] - ve[3] / Re];
          }
          const M = l.left * x, O = l.right * x;
          let N, V, Y, ee;
          u === "width" || u === "both" ? (ee = _[0] + M - p[3], V = _[0] + O + p[1]) : (ee = _[0] + (M + O - A.displaySize[0]) / 2, V = ee + A.displaySize[0]);
          const ie = l.top * x, ue = l.bottom * x;
          return u === "height" || u === "both" ? (N = _[1] + ie - p[0], Y = _[1] + ue + p[2]) : (N = _[1] + (ie + ue - A.displaySize[1]) / 2, Y = N + A.displaySize[1]), { image: A, top: N, right: V, bottom: Y, left: ee, collisionPadding: E };
        }
        const Wu = 128, Sh = 32640;
        function tA(h, l) {
          const { expression: u } = l;
          if (u.kind === "constant") return { kind: "constant", layoutSize: u.evaluate(new Wr(h + 1)) };
          if (u.kind === "source") return { kind: "source" };
          {
            const { zoomStops: p, interpolationType: _ } = u;
            let x = 0;
            for (; x < p.length && p[x] <= h; ) x++;
            x = Math.max(0, x - 1);
            let A = x;
            for (; A < p.length && p[A] < h + 1; ) A++;
            A = Math.min(p.length - 1, A);
            const E = p[x], M = p[A];
            return u.kind === "composite" ? { kind: "composite", minZoom: E, maxZoom: M, interpolationType: _ } : { kind: "camera", minZoom: E, maxZoom: M, minSize: u.evaluate(new Wr(E)), maxSize: u.evaluate(new Wr(M)), interpolationType: _ };
          }
        }
        function F0(h, l, u) {
          let p = "never";
          const _ = h.get(l);
          return _ ? p = _ : h.get(u) && (p = "always"), p;
        }
        const $L = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Nm(h, l, u, p, _, x, A, E, M, O, N, V, Y) {
          const ee = E ? Math.min(Sh, Math.round(E[0])) : 0, ie = E ? Math.min(Sh, Math.round(E[1])) : 0;
          h.emplaceBack(l, u, Math.round(32 * p), Math.round(32 * _), x, A, (ee << 1) + (M ? 1 : 0), ie, 16 * O, 16 * N, 256 * V, 256 * Y);
        }
        function U0(h, l, u) {
          h.emplaceBack(l.x, l.y, u), h.emplaceBack(l.x, l.y, u), h.emplaceBack(l.x, l.y, u), h.emplaceBack(l.x, l.y, u);
        }
        function HL(h) {
          for (const l of h.sections) if (Pr(l.text)) return !0;
          return !1;
        }
        class z0 {
          constructor(l) {
            this.layoutVertexArray = new _t(), this.indexArray = new Vr(), this.programConfigurations = l, this.segments = new hi(), this.dynamicLayoutVertexArray = new qt(), this.opacityVertexArray = new Zt(), this.hasVisibleVertices = !1, this.placedSymbolArray = new X();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(l, u, p, _) {
            this.isEmpty() || (p && (this.layoutVertexBuffer = l.createVertexBuffer(this.layoutVertexArray, _L.members), this.indexBuffer = l.createIndexBuffer(this.indexArray, u), this.dynamicLayoutVertexBuffer = l.createVertexBuffer(this.dynamicLayoutVertexArray, yL.members, !0), this.opacityVertexBuffer = l.createVertexBuffer(this.opacityVertexArray, $L, !0), this.opacityVertexBuffer.itemSize = 1), (p || _) && this.programConfigurations.upload(l));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        me("SymbolBuffers", z0);
        class j0 {
          constructor(l, u, p) {
            this.layoutVertexArray = new l(), this.layoutAttributes = u, this.indexArray = new p(), this.segments = new hi(), this.collisionVertexArray = new pr();
          }
          upload(l) {
            this.layoutVertexBuffer = l.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = l.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = l.createVertexBuffer(this.collisionVertexArray, bL.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        me("CollisionBuffers", j0);
        class Pd {
          constructor(l) {
            this.collisionBoxArray = l.collisionBoxArray, this.zoom = l.zoom, this.overscaling = Rr(globalThis) ? Math.min(l.overscaling, 128) : l.overscaling, this.layers = l.layers, this.layerIds = this.layers.map((A) => A.id), this.index = l.index, this.pixelRatio = l.pixelRatio, this.sourceLayerIndex = l.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const u = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = tA(this.zoom, u["text-size"]), this.iconSizeData = tA(this.zoom, u["icon-size"]);
            const p = this.layers[0].layout, _ = p.get("symbol-sort-key"), x = p.get("symbol-z-order");
            this.canOverlap = F0(p, "text-overlap", "text-allow-overlap") !== "never" || F0(p, "icon-overlap", "icon-allow-overlap") !== "never" || p.get("text-ignore-placement") || p.get("icon-ignore-placement"), this.sortFeaturesByKey = x !== "viewport-y" && !_.isConstant(), this.sortFeaturesByY = (x === "viewport-y" || x === "auto" && !this.sortFeaturesByKey) && this.canOverlap, p.get("symbol-placement") === "point" && (this.writingModes = p.get("text-writing-mode").map((A) => c.ao[A])), this.stateDependentLayerIds = this.layers.filter((A) => A.isStateDependent()).map((A) => A.id), this.sourceID = l.sourceID;
          }
          createArrays() {
            this.text = new z0(new ou(this.layers, this.zoom, (l) => /^text/.test(l))), this.icon = new z0(new ou(this.layers, this.zoom, (l) => /^icon/.test(l))), this.glyphOffsetArray = new ce(), this.lineVertexArray = new we(), this.symbolInstances = new Q(), this.textAnchorOffsets = new Se();
          }
          calculateGlyphDependencies(l, u, p, _, x) {
            for (let A = 0; A < l.length; A++) if (u[l.charCodeAt(A)] = !0, (p || _) && x) {
              const E = tg[l.charAt(A)];
              E && (u[E.charCodeAt(0)] = !0);
            }
          }
          populate(l, u, p) {
            const _ = this.layers[0], x = _.layout, A = x.get("text-font"), E = x.get("text-field"), M = x.get("icon-image"), O = (E.value.kind !== "constant" || E.value.value instanceof Er && !E.value.value.isEmpty() || E.value.value.toString().length > 0) && (A.value.kind !== "constant" || A.value.value.length > 0), N = M.value.kind !== "constant" || !!M.value.value || Object.keys(M.parameters).length > 0, V = x.get("symbol-sort-key");
            if (this.features = [], !O && !N) return;
            const Y = u.iconDependencies, ee = u.glyphDependencies, ie = u.availableImages, ue = new Wr(this.zoom);
            for (const { feature: ve, id: Re, index: it, sourceLayerIndex: ze } of l) {
              const Ze = _._featureFilter.needGeometry, yt = mf(ve, Ze);
              if (!_._featureFilter.filter(ue, yt, p)) continue;
              let Pt, Gt;
              if (Ze || (yt.geometry = sc(ve)), O) {
                const er = _.getValueAndResolveTokens("text-field", yt, p, ie), nr = Er.factory(er), Ar = this.hasRTLText = this.hasRTLText || HL(nr);
                (!Ar || lr.getRTLTextPluginStatus() === "unavailable" || Ar && lr.isParsed()) && (Pt = xL(nr, _, yt));
              }
              if (N) {
                const er = _.getValueAndResolveTokens("icon-image", yt, p, ie);
                Gt = er instanceof Hn ? er : Hn.fromString(er);
              }
              if (!Pt && !Gt) continue;
              const or = this.sortFeaturesByKey ? V.evaluate(yt, {}, p) : void 0;
              if (this.features.push({ id: Re, text: Pt, icon: Gt, index: it, sourceLayerIndex: ze, geometry: yt.geometry, properties: ve.properties, type: Ed.types[ve.type], sortKey: or }), Gt && (Y[Gt.name] = !0), Pt) {
                const er = A.evaluate(yt, {}, p).join(","), nr = x.get("text-rotation-alignment") !== "viewport" && x.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(c.ao.vertical) >= 0;
                for (const Ar of Pt.sections) if (Ar.image) Y[Ar.image.name] = !0;
                else {
                  const ir = Ot(Pt.toString()), sr = Ar.fontStack || er, Ft = ee[sr] = ee[sr] || {};
                  this.calculateGlyphDependencies(Ar.text, Ft, nr, this.allowVerticalPlacement, ir);
                }
              }
            }
            x.get("symbol-placement") === "line" && (this.features = function(ve) {
              const Re = {}, it = {}, ze = [];
              let Ze = 0;
              function yt(er) {
                ze.push(ve[er]), Ze++;
              }
              function Pt(er, nr, Ar) {
                const ir = it[er];
                return delete it[er], it[nr] = ir, ze[ir].geometry[0].pop(), ze[ir].geometry[0] = ze[ir].geometry[0].concat(Ar[0]), ir;
              }
              function Gt(er, nr, Ar) {
                const ir = Re[nr];
                return delete Re[nr], Re[er] = ir, ze[ir].geometry[0].shift(), ze[ir].geometry[0] = Ar[0].concat(ze[ir].geometry[0]), ir;
              }
              function or(er, nr, Ar) {
                const ir = Ar ? nr[0][nr[0].length - 1] : nr[0][0];
                return `${er}:${ir.x}:${ir.y}`;
              }
              for (let er = 0; er < ve.length; er++) {
                const nr = ve[er], Ar = nr.geometry, ir = nr.text ? nr.text.toString() : null;
                if (!ir) {
                  yt(er);
                  continue;
                }
                const sr = or(ir, Ar), Ft = or(ir, Ar, !0);
                if (sr in it && Ft in Re && it[sr] !== Re[Ft]) {
                  const Gr = Gt(sr, Ft, Ar), Xr = Pt(sr, Ft, ze[Gr].geometry);
                  delete Re[sr], delete it[Ft], it[or(ir, ze[Xr].geometry, !0)] = Xr, ze[Gr].geometry = null;
                } else sr in it ? Pt(sr, Ft, Ar) : Ft in Re ? Gt(sr, Ft, Ar) : (yt(er), Re[sr] = Ze - 1, it[Ft] = Ze - 1);
              }
              return ze.filter((er) => er.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((ve, Re) => ve.sortKey - Re.sortKey);
          }
          update(l, u, p) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(l, u, this.layers, { imagePositions: p }), this.icon.programConfigurations.updatePaintArrays(l, u, this.layers, { imagePositions: p }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(l) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(l), this.iconCollisionBox.upload(l)), this.text.upload(l, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(l, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(l, u) {
            const p = this.lineVertexArray.length;
            if (l.segment !== void 0) {
              let _ = l.dist(u[l.segment + 1]), x = l.dist(u[l.segment]);
              const A = {};
              for (let E = l.segment + 1; E < u.length; E++) A[E] = { x: u[E].x, y: u[E].y, tileUnitDistanceFromAnchor: _ }, E < u.length - 1 && (_ += u[E + 1].dist(u[E]));
              for (let E = l.segment || 0; E >= 0; E--) A[E] = { x: u[E].x, y: u[E].y, tileUnitDistanceFromAnchor: x }, E > 0 && (x += u[E - 1].dist(u[E]));
              for (let E = 0; E < u.length; E++) {
                const M = A[E];
                this.lineVertexArray.emplaceBack(M.x, M.y, M.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: p, lineLength: this.lineVertexArray.length - p };
          }
          addSymbols(l, u, p, _, x, A, E, M, O, N, V, Y) {
            const ee = l.indexArray, ie = l.layoutVertexArray, ue = l.segments.prepareSegment(4 * u.length, ie, ee, this.canOverlap ? A.sortKey : void 0), ve = this.glyphOffsetArray.length, Re = ue.vertexLength, it = this.allowVerticalPlacement && E === c.ao.vertical ? Math.PI / 2 : 0, ze = A.text && A.text.sections;
            for (let Ze = 0; Ze < u.length; Ze++) {
              const { tl: yt, tr: Pt, bl: Gt, br: or, tex: er, pixelOffsetTL: nr, pixelOffsetBR: Ar, minFontScaleX: ir, minFontScaleY: sr, glyphOffset: Ft, isSDF: Gr, sectionIndex: Xr } = u[Ze], kr = ue.vertexLength, br = Ft[1];
              Nm(ie, M.x, M.y, yt.x, br + yt.y, er.x, er.y, p, Gr, nr.x, nr.y, ir, sr), Nm(ie, M.x, M.y, Pt.x, br + Pt.y, er.x + er.w, er.y, p, Gr, Ar.x, nr.y, ir, sr), Nm(ie, M.x, M.y, Gt.x, br + Gt.y, er.x, er.y + er.h, p, Gr, nr.x, Ar.y, ir, sr), Nm(ie, M.x, M.y, or.x, br + or.y, er.x + er.w, er.y + er.h, p, Gr, Ar.x, Ar.y, ir, sr), U0(l.dynamicLayoutVertexArray, M, it), ee.emplaceBack(kr, kr + 2, kr + 1), ee.emplaceBack(kr + 1, kr + 2, kr + 3), ue.vertexLength += 4, ue.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Ft[0]), Ze !== u.length - 1 && Xr === u[Ze + 1].sectionIndex || l.programConfigurations.populatePaintArrays(ie.length, A, A.index, { imagePositions: {}, canonical: Y, formattedSection: ze && ze[Xr] });
            }
            l.placedSymbolArray.emplaceBack(M.x, M.y, ve, this.glyphOffsetArray.length - ve, Re, O, N, M.segment, p ? p[0] : 0, p ? p[1] : 0, _[0], _[1], E, 0, !1, 0, V);
          }
          _addCollisionDebugVertex(l, u, p, _, x, A) {
            return u.emplaceBack(0, 0), l.emplaceBack(p.x, p.y, _, x, Math.round(A.x), Math.round(A.y));
          }
          addCollisionDebugVertices(l, u, p, _, x, A, E) {
            const M = x.segments.prepareSegment(4, x.layoutVertexArray, x.indexArray), O = M.vertexLength, N = x.layoutVertexArray, V = x.collisionVertexArray, Y = E.anchorX, ee = E.anchorY;
            this._addCollisionDebugVertex(N, V, A, Y, ee, new d(l, u)), this._addCollisionDebugVertex(N, V, A, Y, ee, new d(p, u)), this._addCollisionDebugVertex(N, V, A, Y, ee, new d(p, _)), this._addCollisionDebugVertex(N, V, A, Y, ee, new d(l, _)), M.vertexLength += 4;
            const ie = x.indexArray;
            ie.emplaceBack(O, O + 1), ie.emplaceBack(O + 1, O + 2), ie.emplaceBack(O + 2, O + 3), ie.emplaceBack(O + 3, O), M.primitiveLength += 4;
          }
          addDebugCollisionBoxes(l, u, p, _) {
            for (let x = l; x < u; x++) {
              const A = this.collisionBoxArray.get(x);
              this.addCollisionDebugVertices(A.x1, A.y1, A.x2, A.y2, _ ? this.textCollisionBox : this.iconCollisionBox, A.anchorPoint, p);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new j0(zt, Vw.members, Ti), this.iconCollisionBox = new j0(zt, Vw.members, Ti);
            for (let l = 0; l < this.symbolInstances.length; l++) {
              const u = this.symbolInstances.get(l);
              this.addDebugCollisionBoxes(u.textBoxStartIndex, u.textBoxEndIndex, u, !0), this.addDebugCollisionBoxes(u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u, !0), this.addDebugCollisionBoxes(u.iconBoxStartIndex, u.iconBoxEndIndex, u, !1), this.addDebugCollisionBoxes(u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex, u, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(l, u, p, _, x, A, E, M, O) {
            const N = {};
            for (let V = u; V < p; V++) {
              const Y = l.get(V);
              N.textBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, N.textFeatureIndex = Y.featureIndex;
              break;
            }
            for (let V = _; V < x; V++) {
              const Y = l.get(V);
              N.verticalTextBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, N.verticalTextFeatureIndex = Y.featureIndex;
              break;
            }
            for (let V = A; V < E; V++) {
              const Y = l.get(V);
              N.iconBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, N.iconFeatureIndex = Y.featureIndex;
              break;
            }
            for (let V = M; V < O; V++) {
              const Y = l.get(V);
              N.verticalIconBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, N.verticalIconFeatureIndex = Y.featureIndex;
              break;
            }
            return N;
          }
          deserializeCollisionBoxes(l) {
            this.collisionArrays = [];
            for (let u = 0; u < this.symbolInstances.length; u++) {
              const p = this.symbolInstances.get(u);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(l, p.textBoxStartIndex, p.textBoxEndIndex, p.verticalTextBoxStartIndex, p.verticalTextBoxEndIndex, p.iconBoxStartIndex, p.iconBoxEndIndex, p.verticalIconBoxStartIndex, p.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(l, u) {
            const p = l.placedSymbolArray.get(u), _ = p.vertexStartIndex + 4 * p.numGlyphs;
            for (let x = p.vertexStartIndex; x < _; x += 4) l.indexArray.emplaceBack(x, x + 2, x + 1), l.indexArray.emplaceBack(x + 1, x + 2, x + 3);
          }
          getSortedSymbolIndexes(l) {
            if (this.sortedAngle === l && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const u = Math.sin(l), p = Math.cos(l), _ = [], x = [], A = [];
            for (let E = 0; E < this.symbolInstances.length; ++E) {
              A.push(E);
              const M = this.symbolInstances.get(E);
              _.push(0 | Math.round(u * M.anchorX + p * M.anchorY)), x.push(M.featureIndex);
            }
            return A.sort((E, M) => _[E] - _[M] || x[M] - x[E]), A;
          }
          addToSortKeyRanges(l, u) {
            const p = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            p && p.sortKey === u ? p.symbolInstanceEnd = l + 1 : this.sortKeyRanges.push({ sortKey: u, symbolInstanceStart: l, symbolInstanceEnd: l + 1 });
          }
          sortFeatures(l) {
            if (this.sortFeaturesByY && this.sortedAngle !== l && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(l), this.sortedAngle = l, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const u of this.symbolInstanceIndexes) {
                const p = this.symbolInstances.get(u);
                this.featureSortOrder.push(p.featureIndex), [p.rightJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.leftJustifiedTextSymbolIndex].forEach((_, x, A) => {
                  _ >= 0 && A.indexOf(_) === x && this.addIndicesForPlacedSymbol(this.text, _);
                }), p.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, p.verticalPlacedTextSymbolIndex), p.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.placedIconSymbolIndex), p.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let rA, iA;
        me("SymbolBucket", Pd, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Pd.MAX_GLYPHS = 65535, Pd.addDynamicAttributes = U0;
        var V0 = { get paint() {
          return iA = iA || new ln({ "icon-opacity": new cr(We.paint_symbol["icon-opacity"]), "icon-color": new cr(We.paint_symbol["icon-color"]), "icon-halo-color": new cr(We.paint_symbol["icon-halo-color"]), "icon-halo-width": new cr(We.paint_symbol["icon-halo-width"]), "icon-halo-blur": new cr(We.paint_symbol["icon-halo-blur"]), "icon-translate": new Qt(We.paint_symbol["icon-translate"]), "icon-translate-anchor": new Qt(We.paint_symbol["icon-translate-anchor"]), "text-opacity": new cr(We.paint_symbol["text-opacity"]), "text-color": new cr(We.paint_symbol["text-color"], { runtimeType: bn, getOverride: (h) => h.textColor, hasOverride: (h) => !!h.textColor }), "text-halo-color": new cr(We.paint_symbol["text-halo-color"]), "text-halo-width": new cr(We.paint_symbol["text-halo-width"]), "text-halo-blur": new cr(We.paint_symbol["text-halo-blur"]), "text-translate": new Qt(We.paint_symbol["text-translate"]), "text-translate-anchor": new Qt(We.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return rA = rA || new ln({ "symbol-placement": new Qt(We.layout_symbol["symbol-placement"]), "symbol-spacing": new Qt(We.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Qt(We.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new cr(We.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Qt(We.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Qt(We.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Qt(We.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Qt(We.layout_symbol["icon-ignore-placement"]), "icon-optional": new Qt(We.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Qt(We.layout_symbol["icon-rotation-alignment"]), "icon-size": new cr(We.layout_symbol["icon-size"]), "icon-text-fit": new Qt(We.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Qt(We.layout_symbol["icon-text-fit-padding"]), "icon-image": new cr(We.layout_symbol["icon-image"]), "icon-rotate": new cr(We.layout_symbol["icon-rotate"]), "icon-padding": new cr(We.layout_symbol["icon-padding"]), "icon-keep-upright": new Qt(We.layout_symbol["icon-keep-upright"]), "icon-offset": new cr(We.layout_symbol["icon-offset"]), "icon-anchor": new cr(We.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Qt(We.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Qt(We.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Qt(We.layout_symbol["text-rotation-alignment"]), "text-field": new cr(We.layout_symbol["text-field"]), "text-font": new cr(We.layout_symbol["text-font"]), "text-size": new cr(We.layout_symbol["text-size"]), "text-max-width": new cr(We.layout_symbol["text-max-width"]), "text-line-height": new Qt(We.layout_symbol["text-line-height"]), "text-letter-spacing": new cr(We.layout_symbol["text-letter-spacing"]), "text-justify": new cr(We.layout_symbol["text-justify"]), "text-radial-offset": new cr(We.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Qt(We.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new cr(We.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new cr(We.layout_symbol["text-anchor"]), "text-max-angle": new Qt(We.layout_symbol["text-max-angle"]), "text-writing-mode": new Qt(We.layout_symbol["text-writing-mode"]), "text-rotate": new cr(We.layout_symbol["text-rotate"]), "text-padding": new Qt(We.layout_symbol["text-padding"]), "text-keep-upright": new Qt(We.layout_symbol["text-keep-upright"]), "text-transform": new cr(We.layout_symbol["text-transform"]), "text-offset": new cr(We.layout_symbol["text-offset"]), "text-allow-overlap": new Qt(We.layout_symbol["text-allow-overlap"]), "text-overlap": new Qt(We.layout_symbol["text-overlap"]), "text-ignore-placement": new Qt(We.layout_symbol["text-ignore-placement"]), "text-optional": new Qt(We.layout_symbol["text-optional"]) });
        } };
        class nA {
          constructor(l) {
            if (l.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = l.property.overrides ? l.property.overrides.runtimeType : sn, this.defaultValue = l;
          }
          evaluate(l) {
            if (l.formattedSection) {
              const u = this.defaultValue.property.overrides;
              if (u && u.hasOverride(l.formattedSection)) return u.getOverride(l.formattedSection);
            }
            return l.feature && l.featureState ? this.defaultValue.evaluate(l.feature, l.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(l) {
            this.defaultValue.isConstant() || l(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        me("FormatSectionOverride", nA, { omit: ["defaultValue"] });
        class Fm extends gn {
          constructor(l, u) {
            super(l, V0, u);
          }
          recalculate(l, u) {
            if (super.recalculate(l, u), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const p = this.layout.get("text-writing-mode");
              if (p) {
                const _ = [];
                for (const x of p) _.indexOf(x) < 0 && _.push(x);
                this.layout._values["text-writing-mode"] = _;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(l, u, p, _) {
            const x = this.layout.get(l).evaluate(u, {}, p, _), A = this._unevaluatedLayout._values[l];
            return A.isDataDriven() || Jl(A.value) || !x ? x : function(E, M) {
              return M.replace(/{([^{}]+)}/g, (O, N) => E && N in E ? String(E[N]) : "");
            }(u.properties, x);
          }
          createBucket(l) {
            return new Pd(l);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const l of V0.paint.overridableProperties) {
              if (!Fm.hasPaintOverride(this.layout, l)) continue;
              const u = this.paint.get(l), p = new nA(u), _ = new Hc(p, u.property.specification);
              let x = null;
              x = u.value.kind === "constant" || u.value.kind === "source" ? new ph("source", _) : new of("composite", _, u.value.zoomStops), this.paint._values[l] = new dn(u.property, x, u.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(l, u, p) {
            return !(!this.layout || u.isDataDriven() || p.isDataDriven()) && Fm.hasPaintOverride(this.layout, l);
          }
          static hasPaintOverride(l, u) {
            const p = l.get("text-field"), _ = V0.paint.properties[u];
            let x = !1;
            const A = (E) => {
              for (const M of E) if (_.overrides && _.overrides.hasOverride(M)) return void (x = !0);
            };
            if (p.value.kind === "constant" && p.value.value instanceof Er) A(p.value.value.sections);
            else if (p.value.kind === "source" || p.value.kind === "composite") {
              const E = (O) => {
                x || (O instanceof to && ki(O.value) === Wo ? A(O.value.sections) : O instanceof gl ? A(O.sections) : O.eachChild(E));
              }, M = p.value;
              M._styleExpression && E(M._styleExpression.expression);
            }
            return x;
          }
        }
        let sA;
        var qL = { get paint() {
          return sA = sA || new ln({ "background-color": new Qt(We.paint_background["background-color"]), "background-pattern": new Bi(We.paint_background["background-pattern"]), "background-opacity": new Qt(We.paint_background["background-opacity"]) });
        } };
        class WL extends gn {
          constructor(l, u) {
            super(l, qL, u);
          }
        }
        class XL extends gn {
          constructor(l, u) {
            super(l, {}, u), this.onAdd = (p) => {
              this.implementation.onAdd && this.implementation.onAdd(p, p.painter.context.gl);
            }, this.onRemove = (p) => {
              this.implementation.onRemove && this.implementation.onRemove(p, p.painter.context.gl);
            }, this.implementation = l;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class ZL {
          constructor(l) {
            this._methodToThrottle = l, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const YL = { once: !0 }, G0 = 63710088e-1;
        class Eh {
          constructor(l, u) {
            if (isNaN(l) || isNaN(u)) throw new Error(`Invalid LngLat object: (${l}, ${u})`);
            if (this.lng = +l, this.lat = +u, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Eh(at(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(l) {
            const u = Math.PI / 180, p = this.lat * u, _ = l.lat * u, x = Math.sin(p) * Math.sin(_) + Math.cos(p) * Math.cos(_) * Math.cos((l.lng - this.lng) * u);
            return G0 * Math.acos(Math.min(x, 1));
          }
          static convert(l) {
            if (l instanceof Eh) return l;
            if (Array.isArray(l) && (l.length === 2 || l.length === 3)) return new Eh(Number(l[0]), Number(l[1]));
            if (!Array.isArray(l) && typeof l == "object" && l !== null) return new Eh(Number("lng" in l ? l.lng : l.lon), Number(l.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const oA = 2 * Math.PI * G0;
        function aA(h) {
          return oA * Math.cos(h * Math.PI / 180);
        }
        function lA(h) {
          return (180 + h) / 360;
        }
        function cA(h) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + h * Math.PI / 360))) / 360;
        }
        function uA(h, l) {
          return h / aA(l);
        }
        function $0(h) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * h) * Math.PI / 180)) - 90;
        }
        function hA(h, l) {
          return h * aA($0(l));
        }
        class ig {
          constructor(l, u, p = 0) {
            this.x = +l, this.y = +u, this.z = +p;
          }
          static fromLngLat(l, u = 0) {
            const p = Eh.convert(l);
            return new ig(lA(p.lng), cA(p.lat), uA(u, p.lat));
          }
          toLngLat() {
            return new Eh(360 * this.x - 180, $0(this.y));
          }
          toAltitude() {
            return hA(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / oA * (l = $0(this.y), 1 / Math.cos(l * Math.PI / 180));
            var l;
          }
        }
        function fA(h, l, u) {
          var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, u);
          return [h * p - 2 * Math.PI * 6378137 / 2, l * p - 2 * Math.PI * 6378137 / 2];
        }
        class H0 {
          constructor(l, u, p) {
            if (!function(_, x, A) {
              return !(_ < 0 || _ > 25 || A < 0 || A >= Math.pow(2, _) || x < 0 || x >= Math.pow(2, _));
            }(l, u, p)) throw new Error(`x=${u}, y=${p}, z=${l} outside of bounds. 0<=x<${Math.pow(2, l)}, 0<=y<${Math.pow(2, l)} 0<=z<=25 `);
            this.z = l, this.x = u, this.y = p, this.key = Md(0, l, l, u, p);
          }
          equals(l) {
            return this.z === l.z && this.x === l.x && this.y === l.y;
          }
          url(l, u, p) {
            const _ = (A = this.y, E = this.z, M = fA(256 * (x = this.x), 256 * (A = Math.pow(2, E) - A - 1), E), O = fA(256 * (x + 1), 256 * (A + 1), E), M[0] + "," + M[1] + "," + O[0] + "," + O[1]);
            var x, A, E, M, O;
            const N = function(V, Y, ee) {
              let ie, ue = "";
              for (let ve = V; ve > 0; ve--) ie = 1 << ve - 1, ue += (Y & ie ? 1 : 0) + (ee & ie ? 2 : 0);
              return ue;
            }(this.z, this.x, this.y);
            return l[(this.x + this.y) % l.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(p === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, u > 1 ? "@2x" : "").replace(/{quadkey}/g, N).replace(/{bbox-epsg-3857}/g, _);
          }
          isChildOf(l) {
            const u = this.z - l.z;
            return u > 0 && l.x === this.x >> u && l.y === this.y >> u;
          }
          getTilePoint(l) {
            const u = Math.pow(2, this.z);
            return new d((l.x * u - this.x) * wt, (l.y * u - this.y) * wt);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class dA {
          constructor(l, u) {
            this.wrap = l, this.canonical = u, this.key = Md(l, u.z, u.z, u.x, u.y);
          }
        }
        class Wa {
          constructor(l, u, p, _, x) {
            if (this.terrainRttPosMatrix32f = null, l < p) throw new Error(`overscaledZ should be >= z; overscaledZ = ${l}; z = ${p}`);
            this.overscaledZ = l, this.wrap = u, this.canonical = new H0(p, +_, +x), this.key = Md(u, l, p, _, x);
          }
          clone() {
            return new Wa(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(l) {
            return this.overscaledZ === l.overscaledZ && this.wrap === l.wrap && this.canonical.equals(l.canonical);
          }
          scaledTo(l) {
            if (l > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${l}; overscaledZ = ${this.overscaledZ}`);
            const u = this.canonical.z - l;
            return l > this.canonical.z ? new Wa(l, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Wa(l, this.wrap, l, this.canonical.x >> u, this.canonical.y >> u);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(l, u) {
            if (l > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${l}; overscaledZ = ${this.overscaledZ}`);
            const p = this.canonical.z - l;
            return l > this.canonical.z ? Md(this.wrap * +u, l, this.canonical.z, this.canonical.x, this.canonical.y) : Md(this.wrap * +u, l, l, this.canonical.x >> p, this.canonical.y >> p);
          }
          isChildOf(l) {
            if (l.wrap !== this.wrap || this.overscaledZ - l.overscaledZ <= 0) return !1;
            if (l.overscaledZ === 0) return this.overscaledZ > 0;
            const u = this.canonical.z - l.canonical.z;
            return !(u < 0) && l.canonical.x === this.canonical.x >> u && l.canonical.y === this.canonical.y >> u;
          }
          children(l) {
            if (this.overscaledZ >= l) return [new Wa(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const u = this.canonical.z + 1, p = 2 * this.canonical.x, _ = 2 * this.canonical.y;
            return [new Wa(u, this.wrap, u, p, _), new Wa(u, this.wrap, u, p + 1, _), new Wa(u, this.wrap, u, p, _ + 1), new Wa(u, this.wrap, u, p + 1, _ + 1)];
          }
          isLessThan(l) {
            return this.wrap < l.wrap || !(this.wrap > l.wrap) && (this.overscaledZ < l.overscaledZ || !(this.overscaledZ > l.overscaledZ) && (this.canonical.x < l.canonical.x || !(this.canonical.x > l.canonical.x) && this.canonical.y < l.canonical.y));
          }
          wrapped() {
            return new Wa(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(l) {
            return new Wa(this.overscaledZ, l, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new dA(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(l) {
            return this.canonical.getTilePoint(new ig(l.x - this.wrap, l.y));
          }
        }
        function Md(h, l, u, p, _) {
          (h *= 2) < 0 && (h = -1 * h - 1);
          const x = 1 << u;
          return (x * x * h + x * _ + p).toString(36) + u.toString(36) + l.toString(36);
        }
        function ng(h, l) {
          return l ? h.properties[l] : h.id;
        }
        me("CanonicalTileID", H0), me("OverscaledTileID", Wa, { omit: ["terrainRttPosMatrix32f"] });
        class bf {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(l) {
            return this.minX = Math.min(this.minX, l.x), this.minY = Math.min(this.minY, l.y), this.maxX = Math.max(this.maxX, l.x), this.maxY = Math.max(this.maxY, l.y), this;
          }
          expandBy(l) {
            return this.minX -= l, this.minY -= l, this.maxX += l, this.maxY += l, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(l) {
            return this.expandBy(-l);
          }
          map(l) {
            const u = new bf();
            return u.extend(l(new d(this.minX, this.minY))), u.extend(l(new d(this.maxX, this.minY))), u.extend(l(new d(this.minX, this.maxY))), u.extend(l(new d(this.maxX, this.maxY))), u;
          }
          static fromPoints(l) {
            const u = new bf();
            for (const p of l) u.extend(p);
            return u;
          }
          contains(l) {
            return l.x >= this.minX && l.x <= this.maxX && l.y >= this.minY && l.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(l) {
            return !this.empty() && !l.empty() && l.minX >= this.minX && l.maxX <= this.maxX && l.minY >= this.minY && l.maxY <= this.maxY;
          }
          intersects(l) {
            return !this.empty() && !l.empty() && l.minX <= this.maxX && l.maxX >= this.minX && l.minY <= this.maxY && l.maxY >= this.minY;
          }
        }
        class pA {
          constructor(l) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let u = 0; u < l.length; u++) {
              const p = l[u];
              this._stringToNumber[p] = u, this._numberToString[u] = p;
            }
          }
          encode(l) {
            return this._stringToNumber[l];
          }
          decode(l) {
            if (l >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${l} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[l];
          }
        }
        class gA {
          constructor(l, u, p, _, x) {
            this.type = "Feature", this._vectorTileFeature = l, l._z = u, l._x = p, l._y = _, this.properties = l.properties, this.id = x;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(l) {
            this._geometry = l;
          }
          toJSON() {
            const l = { geometry: this.geometry };
            for (const u in this) u !== "_geometry" && u !== "_vectorTileFeature" && (l[u] = this[u]);
            return l;
          }
        }
        class mA {
          constructor(l, u) {
            this.tileID = l, this.x = l.canonical.x, this.y = l.canonical.y, this.z = l.canonical.z, this.grid = new ye(wt, 16, 0), this.grid3D = new ye(wt, 16, 0), this.featureIndexArray = new Ge(), this.promoteId = u;
          }
          insert(l, u, p, _, x, A) {
            const E = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(p, _, x);
            const M = A ? this.grid3D : this.grid;
            for (let O = 0; O < u.length; O++) {
              const N = u[O], V = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let Y = 0; Y < N.length; Y++) {
                const ee = N[Y];
                V[0] = Math.min(V[0], ee.x), V[1] = Math.min(V[1], ee.y), V[2] = Math.max(V[2], ee.x), V[3] = Math.max(V[3], ee.y);
              }
              V[0] < wt && V[1] < wt && V[2] >= 0 && V[3] >= 0 && M.insert(E, V[0], V[1], V[2], V[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Bw(new k0(this.rawTileData)).layers, this.sourceLayerCoder = new pA(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(l, u, p, _) {
            this.loadVTLayers();
            const x = l.params, A = wt / l.tileSize / l.scale, E = El(x.filter, x.globalState), M = l.queryGeometry, O = l.queryPadding * A, N = bf.fromPoints(M), V = this.grid.query(N.minX - O, N.minY - O, N.maxX + O, N.maxY + O), Y = bf.fromPoints(l.cameraQueryGeometry).expandBy(O), ee = this.grid3D.query(Y.minX, Y.minY, Y.maxX, Y.maxY, (ve, Re, it, ze) => function(Ze, yt, Pt, Gt, or) {
              for (const nr of Ze) if (yt <= nr.x && Pt <= nr.y && Gt >= nr.x && or >= nr.y) return !0;
              const er = [new d(yt, Pt), new d(yt, or), new d(Gt, or), new d(Gt, Pt)];
              if (Ze.length > 2) {
                for (const nr of er) if (xd(Ze, nr)) return !0;
              }
              for (let nr = 0; nr < Ze.length - 1; nr++) if (S4(Ze[nr], Ze[nr + 1], er)) return !0;
              return !1;
            }(l.cameraQueryGeometry, ve - O, Re - O, it + O, ze + O));
            for (const ve of ee) V.push(ve);
            V.sort(JL);
            const ie = {};
            let ue;
            for (let ve = 0; ve < V.length; ve++) {
              const Re = V[ve];
              if (Re === ue) continue;
              ue = Re;
              const it = this.featureIndexArray.get(Re);
              let ze = null;
              this.loadMatchingFeature(ie, it.bucketIndex, it.sourceLayerIndex, it.featureIndex, E, x.layers, x.availableImages, u, p, _, (Ze, yt, Pt) => (ze || (ze = sc(Ze)), yt.queryIntersectsFeature({ queryGeometry: M, feature: Ze, featureState: Pt, geometry: ze, zoom: this.z, transform: l.transform, pixelsToTileUnits: A, pixelPosMatrix: l.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: l.getElevation })));
            }
            return ie;
          }
          loadMatchingFeature(l, u, p, _, x, A, E, M, O, N, V) {
            const Y = this.bucketLayerIDs[u];
            if (A && !Y.some((ve) => A.has(ve))) return;
            const ee = this.sourceLayerCoder.decode(p), ie = this.vtLayers[ee].feature(_);
            if (x.needGeometry) {
              const ve = mf(ie, !0);
              if (!x.filter(new Wr(this.tileID.overscaledZ), ve, this.tileID.canonical)) return;
            } else if (!x.filter(new Wr(this.tileID.overscaledZ), ie)) return;
            const ue = this.getId(ie, ee);
            for (let ve = 0; ve < Y.length; ve++) {
              const Re = Y[ve];
              if (A && !A.has(Re)) continue;
              const it = M[Re];
              if (!it) continue;
              let ze = {};
              ue && N && (ze = N.getState(it.sourceLayer || "_geojsonTileLayer", ue));
              const Ze = Et({}, O[Re]);
              Ze.paint = _A(Ze.paint, it.paint, ie, ze, E), Ze.layout = _A(Ze.layout, it.layout, ie, ze, E);
              const yt = !V || V(ie, it, ze);
              if (!yt) continue;
              const Pt = new gA(ie, this.z, this.x, this.y, ue);
              Pt.layer = Ze;
              let Gt = l[Re];
              Gt === void 0 && (Gt = l[Re] = []), Gt.push({ featureIndex: _, feature: Pt, intersectionZ: yt });
            }
          }
          lookupSymbolFeatures(l, u, p, _, x, A, E, M) {
            const O = {};
            this.loadVTLayers();
            const N = El(x.filterSpec, x.globalState);
            for (const V of l) this.loadMatchingFeature(O, p, _, V, N, A, E, M, u);
            return O;
          }
          hasLayer(l) {
            for (const u of this.bucketLayerIDs) for (const p of u) if (l === p) return !0;
            return !1;
          }
          getId(l, u) {
            var p;
            let _ = l.id;
            return this.promoteId && (_ = l.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[u]], typeof _ == "boolean" && (_ = Number(_)), _ === void 0 && (!((p = l.properties) === null || p === void 0) && p.cluster) && this.promoteId && (_ = Number(l.properties.cluster_id))), _;
          }
        }
        function _A(h, l, u, p, _) {
          return Vt(h, (x, A) => {
            const E = l instanceof pn ? l.get(A) : null;
            return E && E.evaluate ? E.evaluate(u, p, _) : E;
          });
        }
        function JL(h, l) {
          return l - h;
        }
        function yA(h, l, u, p, _) {
          const x = [];
          for (let A = 0; A < h.length; A++) {
            const E = h[A];
            let M;
            for (let O = 0; O < E.length - 1; O++) {
              let N = E[O], V = E[O + 1];
              N.x < l && V.x < l || (N.x < l ? N = new d(l, N.y + (l - N.x) / (V.x - N.x) * (V.y - N.y))._round() : V.x < l && (V = new d(l, N.y + (l - N.x) / (V.x - N.x) * (V.y - N.y))._round()), N.y < u && V.y < u || (N.y < u ? N = new d(N.x + (u - N.y) / (V.y - N.y) * (V.x - N.x), u)._round() : V.y < u && (V = new d(N.x + (u - N.y) / (V.y - N.y) * (V.x - N.x), u)._round()), N.x >= p && V.x >= p || (N.x >= p ? N = new d(p, N.y + (p - N.x) / (V.x - N.x) * (V.y - N.y))._round() : V.x >= p && (V = new d(p, N.y + (p - N.x) / (V.x - N.x) * (V.y - N.y))._round()), N.y >= _ && V.y >= _ || (N.y >= _ ? N = new d(N.x + (_ - N.y) / (V.y - N.y) * (V.x - N.x), _)._round() : V.y >= _ && (V = new d(N.x + (_ - N.y) / (V.y - N.y) * (V.x - N.x), _)._round()), M && N.equals(M[M.length - 1]) || (M = [N], x.push(M)), M.push(V)))));
            }
          }
          return x;
        }
        me("FeatureIndex", mA, { omit: ["rawTileData", "sourceLayerCoder"] });
        class Ch extends d {
          constructor(l, u, p, _) {
            super(l, u), this.angle = p, _ !== void 0 && (this.segment = _);
          }
          clone() {
            return new Ch(this.x, this.y, this.angle, this.segment);
          }
        }
        function bA(h, l, u, p, _) {
          if (l.segment === void 0 || u === 0) return !0;
          let x = l, A = l.segment + 1, E = 0;
          for (; E > -u / 2; ) {
            if (A--, A < 0) return !1;
            E -= h[A].dist(x), x = h[A];
          }
          E += h[A].dist(h[A + 1]), A++;
          const M = [];
          let O = 0;
          for (; E < u / 2; ) {
            const N = h[A], V = h[A + 1];
            if (!V) return !1;
            let Y = h[A - 1].angleTo(N) - N.angleTo(V);
            for (Y = Math.abs((Y + 3 * Math.PI) % (2 * Math.PI) - Math.PI), M.push({ distance: E, angleDelta: Y }), O += Y; E - M[0].distance > p; ) O -= M.shift().angleDelta;
            if (O > _) return !1;
            A++, E += N.dist(V);
          }
          return !0;
        }
        function vA(h) {
          let l = 0;
          for (let u = 0; u < h.length - 1; u++) l += h[u].dist(h[u + 1]);
          return l;
        }
        function xA(h, l, u) {
          return h ? 0.6 * l * u : 0;
        }
        function wA(h, l) {
          return Math.max(h ? h.right - h.left : 0, l ? l.right - l.left : 0);
        }
        function KL(h, l, u, p, _, x) {
          const A = xA(u, _, x), E = wA(u, p) * x;
          let M = 0;
          const O = vA(h) / 2;
          for (let N = 0; N < h.length - 1; N++) {
            const V = h[N], Y = h[N + 1], ee = V.dist(Y);
            if (M + ee > O) {
              const ie = (O - M) / ee, ue = ri.number(V.x, Y.x, ie), ve = ri.number(V.y, Y.y, ie), Re = new Ch(ue, ve, Y.angleTo(V), N);
              return Re._round(), !A || bA(h, Re, E, A, l) ? Re : void 0;
            }
            M += ee;
          }
        }
        function QL(h, l, u, p, _, x, A, E, M) {
          const O = xA(p, x, A), N = wA(p, _), V = N * A, Y = h[0].x === 0 || h[0].x === M || h[0].y === 0 || h[0].y === M;
          return l - V < l / 4 && (l = V + l / 4), AA(h, Y ? l / 2 * E % l : (N / 2 + 2 * x) * A * E % l, l, O, u, V, Y, !1, M);
        }
        function AA(h, l, u, p, _, x, A, E, M) {
          const O = x / 2, N = vA(h);
          let V = 0, Y = l - u, ee = [];
          for (let ie = 0; ie < h.length - 1; ie++) {
            const ue = h[ie], ve = h[ie + 1], Re = ue.dist(ve), it = ve.angleTo(ue);
            for (; Y + u < V + Re; ) {
              Y += u;
              const ze = (Y - V) / Re, Ze = ri.number(ue.x, ve.x, ze), yt = ri.number(ue.y, ve.y, ze);
              if (Ze >= 0 && Ze < M && yt >= 0 && yt < M && Y - O >= 0 && Y + O <= N) {
                const Pt = new Ch(Ze, yt, it, ie);
                Pt._round(), p && !bA(h, Pt, x, p, _) || ee.push(Pt);
              }
            }
            V += Re;
          }
          return E || ee.length || A || (ee = AA(h, V / 2, u, p, _, x, A, !0, M)), ee;
        }
        function TA(h, l, u, p) {
          const _ = [], x = h.image, A = x.pixelRatio, E = x.paddedRect.w - 2, M = x.paddedRect.h - 2;
          let O = { x1: h.left, y1: h.top, x2: h.right, y2: h.bottom };
          const N = x.stretchX || [[0, E]], V = x.stretchY || [[0, M]], Y = (Ft, Gr) => Ft + Gr[1] - Gr[0], ee = N.reduce(Y, 0), ie = V.reduce(Y, 0), ue = E - ee, ve = M - ie;
          let Re = 0, it = ee, ze = 0, Ze = ie, yt = 0, Pt = ue, Gt = 0, or = ve;
          if (x.content && p) {
            const Ft = x.content, Gr = Ft[2] - Ft[0], Xr = Ft[3] - Ft[1];
            (x.textFitWidth || x.textFitHeight) && (O = Qw(h)), Re = Um(N, 0, Ft[0]), ze = Um(V, 0, Ft[1]), it = Um(N, Ft[0], Ft[2]), Ze = Um(V, Ft[1], Ft[3]), yt = Ft[0] - Re, Gt = Ft[1] - ze, Pt = Gr - it, or = Xr - Ze;
          }
          const er = O.x1, nr = O.y1, Ar = O.x2 - er, ir = O.y2 - nr, sr = (Ft, Gr, Xr, kr) => {
            const br = zm(Ft.stretch - Re, it, Ar, er), yi = jm(Ft.fixed - yt, Pt, Ft.stretch, ee), Dn = zm(Gr.stretch - ze, Ze, ir, nr), _s = jm(Gr.fixed - Gt, or, Gr.stretch, ie), lo = zm(Xr.stretch - Re, it, Ar, er), Xa = jm(Xr.fixed - yt, Pt, Xr.stretch, ee), la = zm(kr.stretch - ze, Ze, ir, nr), qs = jm(kr.fixed - Gt, or, kr.stretch, ie), Mn = new d(br, Dn), Rs = new d(lo, Dn), Ws = new d(lo, la), Xs = new d(br, la), Bo = new d(yi / A, _s / A), Za = new d(Xa / A, qs / A), Ls = l * Math.PI / 180;
            if (Ls) {
              const Bs = Math.sin(Ls), ks = Math.cos(Ls), ss = [ks, -Bs, Bs, ks];
              Mn._matMult(ss), Rs._matMult(ss), Xs._matMult(ss), Ws._matMult(ss);
            }
            const ca = Ft.stretch + Ft.fixed, ys = Gr.stretch + Gr.fixed;
            return { tl: Mn, tr: Rs, bl: Xs, br: Ws, tex: { x: x.paddedRect.x + 1 + ca, y: x.paddedRect.y + 1 + ys, w: Xr.stretch + Xr.fixed - ca, h: kr.stretch + kr.fixed - ys }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Bo, pixelOffsetBR: Za, minFontScaleX: Pt / A / Ar, minFontScaleY: or / A / ir, isSDF: u };
          };
          if (p && (x.stretchX || x.stretchY)) {
            const Ft = SA(N, ue, ee), Gr = SA(V, ve, ie);
            for (let Xr = 0; Xr < Ft.length - 1; Xr++) {
              const kr = Ft[Xr], br = Ft[Xr + 1];
              for (let yi = 0; yi < Gr.length - 1; yi++) _.push(sr(kr, Gr[yi], br, Gr[yi + 1]));
            }
          } else _.push(sr({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: E + 1 }, { fixed: 0, stretch: M + 1 }));
          return _;
        }
        function Um(h, l, u) {
          let p = 0;
          for (const _ of h) p += Math.max(l, Math.min(u, _[1])) - Math.max(l, Math.min(u, _[0]));
          return p;
        }
        function SA(h, l, u) {
          const p = [{ fixed: -1, stretch: 0 }];
          for (const [_, x] of h) {
            const A = p[p.length - 1];
            p.push({ fixed: _ - A.stretch, stretch: A.stretch }), p.push({ fixed: _ - A.stretch, stretch: A.stretch + (x - _) });
          }
          return p.push({ fixed: l + 1, stretch: u }), p;
        }
        function zm(h, l, u, p) {
          return h / l * u + p;
        }
        function jm(h, l, u, p) {
          return h - l * u / p;
        }
        me("Anchor", Ch);
        class Vm {
          constructor(l, u, p, _, x, A, E, M, O, N) {
            var V;
            if (this.boxStartIndex = l.length, O) {
              let Y = A.top, ee = A.bottom;
              const ie = A.collisionPadding;
              ie && (Y -= ie[1], ee += ie[3]);
              let ue = ee - Y;
              ue > 0 && (ue = Math.max(10, ue), this.circleDiameter = ue);
            } else {
              const Y = !((V = A.image) === null || V === void 0) && V.content && (A.image.textFitWidth || A.image.textFitHeight) ? Qw(A) : { x1: A.left, y1: A.top, x2: A.right, y2: A.bottom };
              Y.y1 = Y.y1 * E - M[0], Y.y2 = Y.y2 * E + M[2], Y.x1 = Y.x1 * E - M[3], Y.x2 = Y.x2 * E + M[1];
              const ee = A.collisionPadding;
              if (ee && (Y.x1 -= ee[0] * E, Y.y1 -= ee[1] * E, Y.x2 += ee[2] * E, Y.y2 += ee[3] * E), N) {
                const ie = new d(Y.x1, Y.y1), ue = new d(Y.x2, Y.y1), ve = new d(Y.x1, Y.y2), Re = new d(Y.x2, Y.y2), it = N * Math.PI / 180;
                ie._rotate(it), ue._rotate(it), ve._rotate(it), Re._rotate(it), Y.x1 = Math.min(ie.x, ue.x, ve.x, Re.x), Y.x2 = Math.max(ie.x, ue.x, ve.x, Re.x), Y.y1 = Math.min(ie.y, ue.y, ve.y, Re.y), Y.y2 = Math.max(ie.y, ue.y, ve.y, Re.y);
              }
              l.emplaceBack(u.x, u.y, Y.x1, Y.y1, Y.x2, Y.y2, p, _, x);
            }
            this.boxEndIndex = l.length;
          }
        }
        class eB {
          constructor(l = [], u = (p, _) => p < _ ? -1 : p > _ ? 1 : 0) {
            if (this.data = l, this.length = this.data.length, this.compare = u, this.length > 0) for (let p = (this.length >> 1) - 1; p >= 0; p--) this._down(p);
          }
          push(l) {
            this.data.push(l), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const l = this.data[0], u = this.data.pop();
            return --this.length > 0 && (this.data[0] = u, this._down(0)), l;
          }
          peek() {
            return this.data[0];
          }
          _up(l) {
            const { data: u, compare: p } = this, _ = u[l];
            for (; l > 0; ) {
              const x = l - 1 >> 1, A = u[x];
              if (p(_, A) >= 0) break;
              u[l] = A, l = x;
            }
            u[l] = _;
          }
          _down(l) {
            const { data: u, compare: p } = this, _ = this.length >> 1, x = u[l];
            for (; l < _; ) {
              let A = 1 + (l << 1);
              const E = A + 1;
              if (E < this.length && p(u[E], u[A]) < 0 && (A = E), p(u[A], x) >= 0) break;
              u[l] = u[A], l = A;
            }
            u[l] = x;
          }
        }
        function tB(h, l = 1, u = !1) {
          const p = bf.fromPoints(h[0]), _ = Math.min(p.width(), p.height());
          let x = _ / 2;
          const A = new eB([], rB), { minX: E, minY: M, maxX: O, maxY: N } = p;
          if (_ === 0) return new d(E, M);
          for (let ee = E; ee < O; ee += _) for (let ie = M; ie < N; ie += _) A.push(new Rd(ee + x, ie + x, x, h));
          let V = function(ee) {
            let ie = 0, ue = 0, ve = 0;
            const Re = ee[0];
            for (let it = 0, ze = Re.length, Ze = ze - 1; it < ze; Ze = it++) {
              const yt = Re[it], Pt = Re[Ze], Gt = yt.x * Pt.y - Pt.x * yt.y;
              ue += (yt.x + Pt.x) * Gt, ve += (yt.y + Pt.y) * Gt, ie += 3 * Gt;
            }
            return new Rd(ue / ie, ve / ie, 0, ee);
          }(h), Y = A.length;
          for (; A.length; ) {
            const ee = A.pop();
            (ee.d > V.d || !V.d) && (V = ee, u && console.log("found best %d after %d probes", Math.round(1e4 * ee.d) / 1e4, Y)), ee.max - V.d <= l || (x = ee.h / 2, A.push(new Rd(ee.p.x - x, ee.p.y - x, x, h)), A.push(new Rd(ee.p.x + x, ee.p.y - x, x, h)), A.push(new Rd(ee.p.x - x, ee.p.y + x, x, h)), A.push(new Rd(ee.p.x + x, ee.p.y + x, x, h)), Y += 4);
          }
          return u && (console.log(`num probes: ${Y}`), console.log(`best distance: ${V.d}`)), V.p;
        }
        function rB(h, l) {
          return l.max - h.max;
        }
        function Rd(h, l, u, p) {
          this.p = new d(h, l), this.h = u, this.d = function(_, x) {
            let A = !1, E = 1 / 0;
            for (let M = 0; M < x.length; M++) {
              const O = x[M];
              for (let N = 0, V = O.length, Y = V - 1; N < V; Y = N++) {
                const ee = O[N], ie = O[Y];
                ee.y > _.y != ie.y > _.y && _.x < (ie.x - ee.x) * (_.y - ee.y) / (ie.y - ee.y) + ee.x && (A = !A), E = Math.min(E, uw(_, ee, ie));
              }
            }
            return (A ? 1 : -1) * Math.sqrt(E);
          }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
        }
        var ao;
        c.aE = void 0, (ao = c.aE || (c.aE = {}))[ao.center = 1] = "center", ao[ao.left = 2] = "left", ao[ao.right = 3] = "right", ao[ao.top = 4] = "top", ao[ao.bottom = 5] = "bottom", ao[ao["top-left"] = 6] = "top-left", ao[ao["top-right"] = 7] = "top-right", ao[ao["bottom-left"] = 8] = "bottom-left", ao[ao["bottom-right"] = 9] = "bottom-right";
        const q0 = Number.POSITIVE_INFINITY;
        function EA(h, l) {
          return l[1] !== q0 ? function(u, p, _) {
            let x = 0, A = 0;
            switch (p = Math.abs(p), _ = Math.abs(_), u) {
              case "top-right":
              case "top-left":
              case "top":
                A = _ - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                A = 7 - _;
            }
            switch (u) {
              case "top-right":
              case "bottom-right":
              case "right":
                x = -p;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                x = p;
            }
            return [x, A];
          }(h, l[0], l[1]) : function(u, p) {
            let _ = 0, x = 0;
            p < 0 && (p = 0);
            const A = p / Math.SQRT2;
            switch (u) {
              case "top-right":
              case "top-left":
                x = A - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                x = 7 - A;
                break;
              case "bottom":
                x = 7 - p;
                break;
              case "top":
                x = p - 7;
            }
            switch (u) {
              case "top-right":
              case "bottom-right":
                _ = -A;
                break;
              case "top-left":
              case "bottom-left":
                _ = A;
                break;
              case "left":
                _ = p;
                break;
              case "right":
                _ = -p;
            }
            return [_, x];
          }(h, l[0]);
        }
        function CA(h, l, u) {
          var p;
          const _ = h.layout, x = (p = _.get("text-variable-anchor-offset")) === null || p === void 0 ? void 0 : p.evaluate(l, {}, u);
          if (x) {
            const E = x.values, M = [];
            for (let O = 0; O < E.length; O += 2) {
              const N = M[O] = E[O], V = E[O + 1].map((Y) => Y * Ms);
              N.startsWith("top") ? V[1] -= 7 : N.startsWith("bottom") && (V[1] += 7), M[O + 1] = V;
            }
            return new on(M);
          }
          const A = _.get("text-variable-anchor");
          if (A) {
            let E;
            E = h._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [_.get("text-radial-offset").evaluate(l, {}, u) * Ms, q0] : _.get("text-offset").evaluate(l, {}, u).map((O) => O * Ms);
            const M = [];
            for (const O of A) M.push(O, EA(O, E));
            return new on(M);
          }
          return null;
        }
        function W0(h) {
          switch (h) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function iB(h, l, u, p, _, x, A, E, M, O, N, V) {
          let Y = x.textMaxSize.evaluate(l, {});
          Y === void 0 && (Y = A);
          const ee = h.layers[0].layout, ie = ee.get("icon-offset").evaluate(l, {}, N), ue = PA(u.horizontal), ve = A / 24, Re = h.tilePixelRatio * ve, it = h.tilePixelRatio * Y / 24, ze = h.tilePixelRatio * E, Ze = h.tilePixelRatio * ee.get("symbol-spacing"), yt = ee.get("text-padding") * h.tilePixelRatio, Pt = function(Xr, kr, br, yi = 1) {
            const Dn = Xr.get("icon-padding").evaluate(kr, {}, br), _s = Dn && Dn.values;
            return [_s[0] * yi, _s[1] * yi, _s[2] * yi, _s[3] * yi];
          }(ee, l, N, h.tilePixelRatio), Gt = ee.get("text-max-angle") / 180 * Math.PI, or = ee.get("text-rotation-alignment") !== "viewport" && ee.get("symbol-placement") !== "point", er = ee.get("icon-rotation-alignment") === "map" && ee.get("symbol-placement") !== "point", nr = ee.get("symbol-placement"), Ar = Ze / 2, ir = ee.get("icon-text-fit");
          let sr;
          p && ir !== "none" && (h.allowVerticalPlacement && u.vertical && (sr = eA(p, u.vertical, ir, ee.get("icon-text-fit-padding"), ie, ve)), ue && (p = eA(p, ue, ir, ee.get("icon-text-fit-padding"), ie, ve)));
          const Ft = N ? V.line.getGranularityForZoomLevel(N.z) : 1, Gr = (Xr, kr) => {
            kr.x < 0 || kr.x >= wt || kr.y < 0 || kr.y >= wt || function(br, yi, Dn, _s, lo, Xa, la, qs, Mn, Rs, Ws, Xs, Bo, Za, Ls, ca, ys, Bs, ks, ss, mn, oc, Ld, ac, oB) {
              const Bd = br.addToLineVertexArray(yi, Dn);
              let vf, kd, Od, Dd, BA = 0, kA = 0, OA = 0, DA = 0, tb = -1, rb = -1;
              const Xu = {};
              let NA = ru("");
              if (br.allowVerticalPlacement && _s.vertical) {
                const vo = qs.layout.get("text-rotate").evaluate(mn, {}, ac) + 90;
                Od = new Vm(Mn, yi, Rs, Ws, Xs, _s.vertical, Bo, Za, Ls, vo), la && (Dd = new Vm(Mn, yi, Rs, Ws, Xs, la, ys, Bs, Ls, vo));
              }
              if (lo) {
                const vo = qs.layout.get("icon-rotate").evaluate(mn, {}), Ya = qs.layout.get("icon-text-fit") !== "none", xf = TA(lo, vo, Ld, Ya), cc = la ? TA(la, vo, Ld, Ya) : void 0;
                kd = new Vm(Mn, yi, Rs, Ws, Xs, lo, ys, Bs, !1, vo), BA = 4 * xf.length;
                const wf = br.iconSizeData;
                let au = null;
                wf.kind === "source" ? (au = [Wu * qs.layout.get("icon-size").evaluate(mn, {})], au[0] > Sh && Ct(`${br.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : wf.kind === "composite" && (au = [Wu * oc.compositeIconSizes[0].evaluate(mn, {}, ac), Wu * oc.compositeIconSizes[1].evaluate(mn, {}, ac)], (au[0] > Sh || au[1] > Sh) && Ct(`${br.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), br.addSymbols(br.icon, xf, au, ss, ks, mn, c.ao.none, yi, Bd.lineStartIndex, Bd.lineLength, -1, ac), tb = br.icon.placedSymbolArray.length - 1, cc && (kA = 4 * cc.length, br.addSymbols(br.icon, cc, au, ss, ks, mn, c.ao.vertical, yi, Bd.lineStartIndex, Bd.lineLength, -1, ac), rb = br.icon.placedSymbolArray.length - 1);
              }
              const FA = Object.keys(_s.horizontal);
              for (const vo of FA) {
                const Ya = _s.horizontal[vo];
                if (!vf) {
                  NA = ru(Ya.text);
                  const cc = qs.layout.get("text-rotate").evaluate(mn, {}, ac);
                  vf = new Vm(Mn, yi, Rs, Ws, Xs, Ya, Bo, Za, Ls, cc);
                }
                const xf = Ya.positionedLines.length === 1;
                if (OA += IA(br, yi, Ya, Xa, qs, Ls, mn, ca, Bd, _s.vertical ? c.ao.horizontal : c.ao.horizontalOnly, xf ? FA : [vo], Xu, tb, oc, ac), xf) break;
              }
              _s.vertical && (DA += IA(br, yi, _s.vertical, Xa, qs, Ls, mn, ca, Bd, c.ao.vertical, ["vertical"], Xu, rb, oc, ac));
              const aB = vf ? vf.boxStartIndex : br.collisionBoxArray.length, lB = vf ? vf.boxEndIndex : br.collisionBoxArray.length, cB = Od ? Od.boxStartIndex : br.collisionBoxArray.length, uB = Od ? Od.boxEndIndex : br.collisionBoxArray.length, hB = kd ? kd.boxStartIndex : br.collisionBoxArray.length, fB = kd ? kd.boxEndIndex : br.collisionBoxArray.length, dB = Dd ? Dd.boxStartIndex : br.collisionBoxArray.length, pB = Dd ? Dd.boxEndIndex : br.collisionBoxArray.length;
              let lc = -1;
              const $m = (vo, Ya) => vo && vo.circleDiameter ? Math.max(vo.circleDiameter, Ya) : Ya;
              lc = $m(vf, lc), lc = $m(Od, lc), lc = $m(kd, lc), lc = $m(Dd, lc);
              const UA = lc > -1 ? 1 : 0;
              UA && (lc *= oB / Ms), br.glyphOffsetArray.length >= Pd.MAX_GLYPHS && Ct("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), mn.sortKey !== void 0 && br.addToSortKeyRanges(br.symbolInstances.length, mn.sortKey);
              const gB = CA(qs, mn, ac), [mB, _B] = function(vo, Ya) {
                const xf = vo.length, cc = Ya?.values;
                if (cc?.length > 0) for (let wf = 0; wf < cc.length; wf += 2) {
                  const au = cc[wf + 1];
                  vo.emplaceBack(c.aE[cc[wf]], au[0], au[1]);
                }
                return [xf, vo.length];
              }(br.textAnchorOffsets, gB);
              br.symbolInstances.emplaceBack(yi.x, yi.y, Xu.right >= 0 ? Xu.right : -1, Xu.center >= 0 ? Xu.center : -1, Xu.left >= 0 ? Xu.left : -1, Xu.vertical || -1, tb, rb, NA, aB, lB, cB, uB, hB, fB, dB, pB, Rs, OA, DA, BA, kA, UA, 0, Bo, lc, mB, _B);
            }(h, kr, Xr, u, p, _, sr, h.layers[0], h.collisionBoxArray, l.index, l.sourceLayerIndex, h.index, Re, [yt, yt, yt, yt], or, M, ze, Pt, er, ie, l, x, O, N, A);
          };
          if (nr === "line") for (const Xr of yA(l.geometry, 0, 0, wt, wt)) {
            const kr = yf(Xr, Ft), br = QL(kr, Ze, Gt, u.vertical || ue, p, 24, it, h.overscaling, wt);
            for (const yi of br) ue && nB(h, ue.text, Ar, yi) || Gr(kr, yi);
          }
          else if (nr === "line-center") {
            for (const Xr of l.geometry) if (Xr.length > 1) {
              const kr = yf(Xr, Ft), br = KL(kr, Gt, u.vertical || ue, p, 24, it);
              br && Gr(kr, br);
            }
          } else if (l.type === "Polygon") for (const Xr of yl(l.geometry, 0)) {
            const kr = tB(Xr, 16);
            Gr(yf(Xr[0], Ft, !0), new Ch(kr.x, kr.y, 0));
          }
          else if (l.type === "LineString") for (const Xr of l.geometry) {
            const kr = yf(Xr, Ft);
            Gr(kr, new Ch(kr[0].x, kr[0].y, 0));
          }
          else if (l.type === "Point") for (const Xr of l.geometry) for (const kr of Xr) Gr([kr], new Ch(kr.x, kr.y, 0));
        }
        function IA(h, l, u, p, _, x, A, E, M, O, N, V, Y, ee, ie) {
          const ue = function(it, ze, Ze, yt, Pt, Gt, or, er) {
            const nr = yt.layout.get("text-rotate").evaluate(Gt, {}) * Math.PI / 180, Ar = [];
            for (const ir of ze.positionedLines) for (const sr of ir.positionedGlyphs) {
              if (!sr.rect) continue;
              const Ft = sr.rect || {};
              let Gr = 4, Xr = !0, kr = 1, br = 0;
              const yi = (Pt || er) && sr.vertical, Dn = sr.metrics.advance * sr.scale / 2;
              if (er && ze.verticalizable && (br = ir.lineOffset / 2 - (sr.imageName ? -(Ms - sr.metrics.width * sr.scale) / 2 : (sr.scale - 1) * Ms)), sr.imageName) {
                const Bs = or[sr.imageName];
                Xr = Bs.sdf, kr = Bs.pixelRatio, Gr = 1 / kr;
              }
              const _s = Pt ? [sr.x + Dn, sr.y] : [0, 0];
              let lo = Pt ? [0, 0] : [sr.x + Dn + Ze[0], sr.y + Ze[1] - br], Xa = [0, 0];
              yi && (Xa = lo, lo = [0, 0]);
              const la = sr.metrics.isDoubleResolution ? 2 : 1, qs = (sr.metrics.left - Gr) * sr.scale - Dn + lo[0], Mn = (-sr.metrics.top - Gr) * sr.scale + lo[1], Rs = qs + Ft.w / la * sr.scale / kr, Ws = Mn + Ft.h / la * sr.scale / kr, Xs = new d(qs, Mn), Bo = new d(Rs, Mn), Za = new d(qs, Ws), Ls = new d(Rs, Ws);
              if (yi) {
                const Bs = new d(-Dn, Dn - -17), ks = -Math.PI / 2, ss = 12 - Dn, mn = new d(22 - ss, -(sr.imageName ? ss : 0)), oc = new d(...Xa);
                Xs._rotateAround(ks, Bs)._add(mn)._add(oc), Bo._rotateAround(ks, Bs)._add(mn)._add(oc), Za._rotateAround(ks, Bs)._add(mn)._add(oc), Ls._rotateAround(ks, Bs)._add(mn)._add(oc);
              }
              if (nr) {
                const Bs = Math.sin(nr), ks = Math.cos(nr), ss = [ks, -Bs, Bs, ks];
                Xs._matMult(ss), Bo._matMult(ss), Za._matMult(ss), Ls._matMult(ss);
              }
              const ca = new d(0, 0), ys = new d(0, 0);
              Ar.push({ tl: Xs, tr: Bo, bl: Za, br: Ls, tex: Ft, writingMode: ze.writingMode, glyphOffset: _s, sectionIndex: sr.sectionIndex, isSDF: Xr, pixelOffsetTL: ca, pixelOffsetBR: ys, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Ar;
          }(0, u, E, _, x, A, p, h.allowVerticalPlacement), ve = h.textSizeData;
          let Re = null;
          ve.kind === "source" ? (Re = [Wu * _.layout.get("text-size").evaluate(A, {})], Re[0] > Sh && Ct(`${h.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ve.kind === "composite" && (Re = [Wu * ee.compositeTextSizes[0].evaluate(A, {}, ie), Wu * ee.compositeTextSizes[1].evaluate(A, {}, ie)], (Re[0] > Sh || Re[1] > Sh) && Ct(`${h.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), h.addSymbols(h.text, ue, Re, E, x, A, O, l, M.lineStartIndex, M.lineLength, Y, ie);
          for (const it of N) V[it] = h.text.placedSymbolArray.length - 1;
          return 4 * ue.length;
        }
        function PA(h) {
          for (const l in h) return h[l];
          return null;
        }
        function nB(h, l, u, p) {
          const _ = h.compareText;
          if (l in _) {
            const x = _[l];
            for (let A = x.length - 1; A >= 0; A--) if (p.dist(x[A]) < u) return !0;
          } else _[l] = [];
          return _[l].push(p), !1;
        }
        const MA = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class X0 {
          static from(l) {
            if (!(l instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [u, p] = new Uint8Array(l, 0, 2);
            if (u !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const _ = p >> 4;
            if (_ !== 1) throw new Error(`Got v${_} data when expected v1.`);
            const x = MA[15 & p];
            if (!x) throw new Error("Unrecognized array type.");
            const [A] = new Uint16Array(l, 2, 1), [E] = new Uint32Array(l, 4, 1);
            return new X0(E, A, x, l);
          }
          constructor(l, u = 64, p = Float64Array, _) {
            if (isNaN(l) || l < 0) throw new Error(`Unpexpected numItems value: ${l}.`);
            this.numItems = +l, this.nodeSize = Math.min(Math.max(+u, 2), 65535), this.ArrayType = p, this.IndexArrayType = l < 65536 ? Uint16Array : Uint32Array;
            const x = MA.indexOf(this.ArrayType), A = 2 * l * this.ArrayType.BYTES_PER_ELEMENT, E = l * this.IndexArrayType.BYTES_PER_ELEMENT, M = (8 - E % 8) % 8;
            if (x < 0) throw new Error(`Unexpected typed array class: ${p}.`);
            _ && _ instanceof ArrayBuffer ? (this.data = _, this.ids = new this.IndexArrayType(this.data, 8, l), this.coords = new this.ArrayType(this.data, 8 + E + M, 2 * l), this._pos = 2 * l, this._finished = !0) : (this.data = new ArrayBuffer(8 + A + E + M), this.ids = new this.IndexArrayType(this.data, 8, l), this.coords = new this.ArrayType(this.data, 8 + E + M, 2 * l), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + x]), new Uint16Array(this.data, 2, 1)[0] = u, new Uint32Array(this.data, 4, 1)[0] = l);
          }
          add(l, u) {
            const p = this._pos >> 1;
            return this.ids[p] = p, this.coords[this._pos++] = l, this.coords[this._pos++] = u, p;
          }
          finish() {
            const l = this._pos >> 1;
            if (l !== this.numItems) throw new Error(`Added ${l} items when expected ${this.numItems}.`);
            return Z0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(l, u, p, _) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: x, coords: A, nodeSize: E } = this, M = [0, x.length - 1, 0], O = [];
            for (; M.length; ) {
              const N = M.pop() || 0, V = M.pop() || 0, Y = M.pop() || 0;
              if (V - Y <= E) {
                for (let ve = Y; ve <= V; ve++) {
                  const Re = A[2 * ve], it = A[2 * ve + 1];
                  Re >= l && Re <= p && it >= u && it <= _ && O.push(x[ve]);
                }
                continue;
              }
              const ee = Y + V >> 1, ie = A[2 * ee], ue = A[2 * ee + 1];
              ie >= l && ie <= p && ue >= u && ue <= _ && O.push(x[ee]), (N === 0 ? l <= ie : u <= ue) && (M.push(Y), M.push(ee - 1), M.push(1 - N)), (N === 0 ? p >= ie : _ >= ue) && (M.push(ee + 1), M.push(V), M.push(1 - N));
            }
            return O;
          }
          within(l, u, p) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: _, coords: x, nodeSize: A } = this, E = [0, _.length - 1, 0], M = [], O = p * p;
            for (; E.length; ) {
              const N = E.pop() || 0, V = E.pop() || 0, Y = E.pop() || 0;
              if (V - Y <= A) {
                for (let ve = Y; ve <= V; ve++) LA(x[2 * ve], x[2 * ve + 1], l, u) <= O && M.push(_[ve]);
                continue;
              }
              const ee = Y + V >> 1, ie = x[2 * ee], ue = x[2 * ee + 1];
              LA(ie, ue, l, u) <= O && M.push(_[ee]), (N === 0 ? l - p <= ie : u - p <= ue) && (E.push(Y), E.push(ee - 1), E.push(1 - N)), (N === 0 ? l + p >= ie : u + p >= ue) && (E.push(ee + 1), E.push(V), E.push(1 - N));
            }
            return M;
          }
        }
        function Z0(h, l, u, p, _, x) {
          if (_ - p <= u) return;
          const A = p + _ >> 1;
          RA(h, l, A, p, _, x), Z0(h, l, u, p, A - 1, 1 - x), Z0(h, l, u, A + 1, _, 1 - x);
        }
        function RA(h, l, u, p, _, x) {
          for (; _ > p; ) {
            if (_ - p > 600) {
              const O = _ - p + 1, N = u - p + 1, V = Math.log(O), Y = 0.5 * Math.exp(2 * V / 3), ee = 0.5 * Math.sqrt(V * Y * (O - Y) / O) * (N - O / 2 < 0 ? -1 : 1);
              RA(h, l, u, Math.max(p, Math.floor(u - N * Y / O + ee)), Math.min(_, Math.floor(u + (O - N) * Y / O + ee)), x);
            }
            const A = l[2 * u + x];
            let E = p, M = _;
            for (sg(h, l, p, u), l[2 * _ + x] > A && sg(h, l, p, _); E < M; ) {
              for (sg(h, l, E, M), E++, M--; l[2 * E + x] < A; ) E++;
              for (; l[2 * M + x] > A; ) M--;
            }
            l[2 * p + x] === A ? sg(h, l, p, M) : (M++, sg(h, l, M, _)), M <= u && (p = M + 1), u <= M && (_ = M - 1);
          }
        }
        function sg(h, l, u, p) {
          Y0(h, u, p), Y0(l, 2 * u, 2 * p), Y0(l, 2 * u + 1, 2 * p + 1);
        }
        function Y0(h, l, u) {
          const p = h[l];
          h[l] = h[u], h[u] = p;
        }
        function LA(h, l, u, p) {
          const _ = h - u, x = l - p;
          return _ * _ + x * x;
        }
        var J0;
        c.cx = void 0, (J0 = c.cx || (c.cx = {})).create = "create", J0.load = "load", J0.fullLoad = "fullLoad";
        let Gm = null, og = [];
        const K0 = 1e3 / 60, Q0 = "loadTime", eb = "fullLoadTime", sB = { mark(h) {
          performance.mark(h);
        }, frame(h) {
          const l = h;
          Gm != null && og.push(l - Gm), Gm = l;
        }, clearMetrics() {
          Gm = null, og = [], performance.clearMeasures(Q0), performance.clearMeasures(eb);
          for (const h in c.cx) performance.clearMarks(c.cx[h]);
        }, getPerformanceMetrics() {
          performance.measure(Q0, c.cx.create, c.cx.load), performance.measure(eb, c.cx.create, c.cx.fullLoad);
          const h = performance.getEntriesByName(Q0)[0].duration, l = performance.getEntriesByName(eb)[0].duration, u = og.length, p = 1 / (og.reduce((x, A) => x + A, 0) / u / 1e3), _ = og.filter((x) => x > K0).reduce((x, A) => x + (A - K0) / K0, 0);
          return { loadTime: h, fullLoadTime: l, fps: p, percentDroppedFrames: _ / (u + _) * 100, totalFrames: u };
        } };
        c.$ = wt, c.A = Z, c.B = function([h, l, u]) {
          return l += 90, l *= Math.PI / 180, u *= Math.PI / 180, { x: h * Math.cos(l) * Math.sin(u), y: h * Math.sin(l) * Math.sin(u), z: h * Math.cos(u) };
        }, c.C = ri, c.D = Qt, c.E = rr, c.F = Wr, c.G = W, c.H = Rr, c.I = O0, c.J = class {
          constructor(h, l) {
            this.target = h, this.mapId = l, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new ZL(() => this.process()), this.subscription = bi(this.target, "message", (u) => this.receive(u), !1), this.globalScope = ii(self) ? h : window;
          }
          registerMessageHandler(h, l) {
            this.messageHandlers[h] = l;
          }
          sendAsync(h, l) {
            return new Promise((u, p) => {
              const _ = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), x = l ? bi(l.signal, "abort", () => {
                x?.unsubscribe(), delete this.resolveRejects[_];
                const M = { id: _, type: "<cancel>", origin: location.origin, targetMapId: h.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(M);
              }, YL) : null;
              this.resolveRejects[_] = { resolve: (M) => {
                x?.unsubscribe(), u(M);
              }, reject: (M) => {
                x?.unsubscribe(), p(M);
              } };
              const A = [], E = Object.assign(Object.assign({}, h), { id: _, sourceMapId: this.mapId, origin: location.origin, data: st(h.data, A) });
              this.target.postMessage(E, { transfer: A });
            });
          }
          receive(h) {
            const l = h.data, u = l.id;
            if (!(l.origin !== "file://" && location.origin !== "file://" && l.origin !== "resource://android" && location.origin !== "resource://android" && l.origin !== location.origin || l.targetMapId && this.mapId !== l.targetMapId)) {
              if (l.type === "<cancel>") {
                delete this.tasks[u];
                const p = this.abortControllers[u];
                return delete this.abortControllers[u], void (p && p.abort());
              }
              if (ii(self) || l.mustQueue) return this.tasks[u] = l, this.taskQueue.push(u), void this.invoker.trigger();
              this.processTask(u, l);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const h = this.taskQueue.shift(), l = this.tasks[h];
            delete this.tasks[h], this.taskQueue.length > 0 && this.invoker.trigger(), l && this.processTask(h, l);
          }
          processTask(h, l) {
            return o(this, void 0, void 0, function* () {
              if (l.type === "<response>") {
                const _ = this.resolveRejects[h];
                return delete this.resolveRejects[h], _ ? void (l.error ? _.reject(ht(l.error)) : _.resolve(ht(l.data))) : void 0;
              }
              if (!this.messageHandlers[l.type]) return void this.completeTask(h, new Error(`Could not find a registered handler for ${l.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const u = ht(l.data), p = new AbortController();
              this.abortControllers[h] = p;
              try {
                const _ = yield this.messageHandlers[l.type](l.sourceMapId, u, p);
                this.completeTask(h, null, _);
              } catch (_) {
                this.completeTask(h, _);
              }
            });
          }
          completeTask(h, l, u) {
            const p = [];
            delete this.abortControllers[h];
            const _ = { id: h, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: l ? st(l) : null, data: st(u, p) };
            this.target.postMessage(_, { transfer: p });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, c.K = de, c.L = function() {
          var h = new Z(16);
          return Z != Float32Array && (h[1] = 0, h[2] = 0, h[3] = 0, h[4] = 0, h[6] = 0, h[7] = 0, h[8] = 0, h[9] = 0, h[11] = 0, h[12] = 0, h[13] = 0, h[14] = 0), h[0] = 1, h[5] = 1, h[10] = 1, h[15] = 1, h;
        }, c.M = function(h, l, u) {
          var p, _, x, A, E, M, O, N, V, Y, ee, ie, ue = u[0], ve = u[1], Re = u[2];
          return l === h ? (h[12] = l[0] * ue + l[4] * ve + l[8] * Re + l[12], h[13] = l[1] * ue + l[5] * ve + l[9] * Re + l[13], h[14] = l[2] * ue + l[6] * ve + l[10] * Re + l[14], h[15] = l[3] * ue + l[7] * ve + l[11] * Re + l[15]) : (_ = l[1], x = l[2], A = l[3], E = l[4], M = l[5], O = l[6], N = l[7], V = l[8], Y = l[9], ee = l[10], ie = l[11], h[0] = p = l[0], h[1] = _, h[2] = x, h[3] = A, h[4] = E, h[5] = M, h[6] = O, h[7] = N, h[8] = V, h[9] = Y, h[10] = ee, h[11] = ie, h[12] = p * ue + E * ve + V * Re + l[12], h[13] = _ * ue + M * ve + Y * Re + l[13], h[14] = x * ue + O * ve + ee * Re + l[14], h[15] = A * ue + N * ve + ie * Re + l[15]), h;
        }, c.N = function(h, l, u) {
          var p = u[0], _ = u[1], x = u[2];
          return h[0] = l[0] * p, h[1] = l[1] * p, h[2] = l[2] * p, h[3] = l[3] * p, h[4] = l[4] * _, h[5] = l[5] * _, h[6] = l[6] * _, h[7] = l[7] * _, h[8] = l[8] * x, h[9] = l[9] * x, h[10] = l[10] * x, h[11] = l[11] * x, h[12] = l[12], h[13] = l[13], h[14] = l[14], h[15] = l[15], h;
        }, c.O = function(h, l, u) {
          var p = l[0], _ = l[1], x = l[2], A = l[3], E = l[4], M = l[5], O = l[6], N = l[7], V = l[8], Y = l[9], ee = l[10], ie = l[11], ue = l[12], ve = l[13], Re = l[14], it = l[15], ze = u[0], Ze = u[1], yt = u[2], Pt = u[3];
          return h[0] = ze * p + Ze * E + yt * V + Pt * ue, h[1] = ze * _ + Ze * M + yt * Y + Pt * ve, h[2] = ze * x + Ze * O + yt * ee + Pt * Re, h[3] = ze * A + Ze * N + yt * ie + Pt * it, h[4] = (ze = u[4]) * p + (Ze = u[5]) * E + (yt = u[6]) * V + (Pt = u[7]) * ue, h[5] = ze * _ + Ze * M + yt * Y + Pt * ve, h[6] = ze * x + Ze * O + yt * ee + Pt * Re, h[7] = ze * A + Ze * N + yt * ie + Pt * it, h[8] = (ze = u[8]) * p + (Ze = u[9]) * E + (yt = u[10]) * V + (Pt = u[11]) * ue, h[9] = ze * _ + Ze * M + yt * Y + Pt * ve, h[10] = ze * x + Ze * O + yt * ee + Pt * Re, h[11] = ze * A + Ze * N + yt * ie + Pt * it, h[12] = (ze = u[12]) * p + (Ze = u[13]) * E + (yt = u[14]) * V + (Pt = u[15]) * ue, h[13] = ze * _ + Ze * M + yt * Y + Pt * ve, h[14] = ze * x + Ze * O + yt * ee + Pt * Re, h[15] = ze * A + Ze * N + yt * ie + Pt * it, h;
        }, c.P = d, c.Q = function(h, l) {
          const u = {};
          for (let p = 0; p < l.length; p++) {
            const _ = l[p];
            _ in h && (u[_] = h[_]);
          }
          return u;
        }, c.R = aa, c.S = Eh, c.T = S0, c.U = cA, c.V = lA, c.W = $, c.X = G, c.Y = hr, c.Z = Wa, c._ = o, c.a = K, c.a$ = Ve, c.a0 = function(h, l) {
          var u, p, _, x, A;
          if (!h) return l ?? {};
          if (!l) return h;
          let E = Object.assign({}, h);
          if (l.removeAll && (E = { removeAll: !0 }), l.remove) {
            const M = new Set(l.remove);
            E.add && (E.add = E.add.filter((N) => !M.has(N.id))), E.update && (E.update = E.update.filter((N) => !M.has(N.id)));
            const O = new Set(((u = h.add) !== null && u !== void 0 ? u : []).map((N) => N.id));
            l.remove = l.remove.filter((N) => !O.has(N));
          }
          if (l.remove) {
            const M = new Set(E.remove ? E.remove.concat(l.remove) : l.remove);
            E.remove = Array.from(M.values());
          }
          if (l.add) {
            const M = E.add ? E.add.concat(l.add) : l.add, O = new Map(M.map((N) => [N.id, N]));
            E.add = Array.from(O.values());
          }
          if (l.update) {
            const M = new Map((p = E.update) === null || p === void 0 ? void 0 : p.map((O) => [O.id, O]));
            for (const O of l.update) {
              const N = (_ = M.get(O.id)) !== null && _ !== void 0 ? _ : { id: O.id };
              O.newGeometry && (N.newGeometry = O.newGeometry), O.addOrUpdateProperties && (N.addOrUpdateProperties = ((x = N.addOrUpdateProperties) !== null && x !== void 0 ? x : []).concat(O.addOrUpdateProperties)), O.removeProperties && (N.removeProperties = ((A = N.removeProperties) !== null && A !== void 0 ? A : []).concat(O.removeProperties)), O.removeAllProperties && (N.removeAllProperties = !0), M.set(O.id, N);
            }
            E.update = Array.from(M.values());
          }
          return E.remove && E.add && (E.remove = E.remove.filter((M) => E.add.findIndex((O) => O.id === M) === -1)), E;
        }, c.a1 = ig, c.a2 = bf, c.a3 = 25, c.a4 = H0, c.a5 = (h) => {
          const l = window.document.createElement("video");
          return l.muted = !0, new Promise((u) => {
            l.onloadstart = () => {
              u(l);
            };
            for (const p of h) {
              const _ = window.document.createElement("source");
              Je(p) || (l.crossOrigin = "Anonymous"), _.src = p, l.appendChild(_);
            }
          });
        }, c.a6 = Lt, c.a7 = function() {
          return Tt++;
        }, c.a8 = U, c.a9 = Pd, c.aA = function(h) {
          let l = 1 / 0, u = 1 / 0, p = -1 / 0, _ = -1 / 0;
          for (const x of h) l = Math.min(l, x.x), u = Math.min(u, x.y), p = Math.max(p, x.x), _ = Math.max(_, x.y);
          return [l, u, p, _];
        }, c.aB = Ms, c.aC = Yt, c.aD = function(h, l, u, p, _ = !1) {
          if (!u[0] && !u[1]) return [0, 0];
          const x = _ ? p === "map" ? -h.bearingInRadians : 0 : p === "viewport" ? h.bearingInRadians : 0;
          if (x) {
            const A = Math.sin(x), E = Math.cos(x);
            u = [u[0] * E - u[1] * A, u[0] * A + u[1] * E];
          }
          return [_ ? u[0] : Yt(l, u[0], h.zoom), _ ? u[1] : Yt(l, u[1], h.zoom)];
        }, c.aF = F0, c.aG = W0, c.aH = N0, c.aI = X0, c.aJ = Ai, c.aK = Bm, c.aL = Le, c.aM = hi, c.aN = Vr, c.aO = at, c.aP = Fr, c.aQ = hA, c.aR = Ee, c.aS = oe, c.aT = function(h) {
          var l = new Z(3);
          return l[0] = h[0], l[1] = h[1], l[2] = h[2], l;
        }, c.aU = function(h, l, u) {
          return h[0] = l[0] - u[0], h[1] = l[1] - u[1], h[2] = l[2] - u[2], h;
        }, c.aV = function(h, l) {
          var u = l[0], p = l[1], _ = l[2], x = u * u + p * p + _ * _;
          return x > 0 && (x = 1 / Math.sqrt(x)), h[0] = l[0] * x, h[1] = l[1] * x, h[2] = l[2] * x, h;
        }, c.aW = le, c.aX = function(h, l) {
          return h[0] * l[0] + h[1] * l[1] + h[2] * l[2];
        }, c.aY = function(h, l, u) {
          return h[0] = l[0] * u[0], h[1] = l[1] * u[1], h[2] = l[2] * u[2], h[3] = l[3] * u[3], h;
        }, c.aZ = be, c.a_ = function(h, l, u) {
          const p = l[0] * u[0] + l[1] * u[1] + l[2] * u[2];
          return p === 0 ? null : (-(h[0] * u[0] + h[1] * u[1] + h[2] * u[2]) - u[3]) / p;
        }, c.aa = El, c.ab = mf, c.ac = gA, c.ad = function(h) {
          const l = {};
          if (h.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (u, p, _, x) => {
            const A = _ || x;
            return l[p] = !A || A.toLowerCase(), "";
          }), l["max-age"]) {
            const u = parseInt(l["max-age"], 10);
            isNaN(u) ? delete l["max-age"] : l["max-age"] = u;
          }
          return l;
        }, c.ae = rt, c.af = 85.051129, c.ag = Yr, c.ah = function(h) {
          return Math.pow(2, h);
        }, c.ai = J, c.aj = uA, c.ak = function(h) {
          return Math.log(h) / Math.LN2;
        }, c.al = function(h) {
          var l = h[0], u = h[1];
          return l * l + u * u;
        }, c.am = function(h) {
          if (!h.length) return /* @__PURE__ */ new Set();
          const l = Math.max(...h.map((M) => M.canonical.z));
          let u = 1 / 0, p = -1 / 0, _ = 1 / 0, x = -1 / 0;
          const A = [];
          for (const M of h) {
            const { x: O, y: N, z: V } = M.canonical, Y = Math.pow(2, l - V), ee = O * Y, ie = N * Y;
            A.push({ id: M, x: ee, y: ie }), ee < u && (u = ee), ee > p && (p = ee), ie < _ && (_ = ie), ie > x && (x = ie);
          }
          const E = /* @__PURE__ */ new Set();
          for (const M of A) M.x !== u && M.x !== p && M.y !== _ && M.y !== x || E.add(M.id);
          return E;
        }, c.an = function(h, l) {
          let u = 0, p = 0;
          if (h.kind === "constant") p = h.layoutSize;
          else if (h.kind !== "source") {
            const { interpolationType: _, minZoom: x, maxZoom: A } = h, E = _ ? rt(Ir.interpolationFactor(_, l, x, A), 0, 1) : 0;
            h.kind === "camera" ? p = ri.number(h.minSize, h.maxSize, E) : u = E;
          }
          return { uSizeT: u, uSize: p };
        }, c.ap = function(h, { uSize: l, uSizeT: u }, { lowerSize: p, upperSize: _ }) {
          return h.kind === "source" ? p / Wu : h.kind === "composite" ? ri.number(p / Wu, _ / Wu, u) : l;
        }, c.aq = function(h, l) {
          var u = l[0], p = l[1], _ = l[2], x = l[3], A = l[4], E = l[5], M = l[6], O = l[7], N = l[8], V = l[9], Y = l[10], ee = l[11], ie = l[12], ue = l[13], ve = l[14], Re = l[15], it = u * E - p * A, ze = u * M - _ * A, Ze = u * O - x * A, yt = p * M - _ * E, Pt = p * O - x * E, Gt = _ * O - x * M, or = N * ue - V * ie, er = N * ve - Y * ie, nr = N * Re - ee * ie, Ar = V * ve - Y * ue, ir = V * Re - ee * ue, sr = Y * Re - ee * ve, Ft = it * sr - ze * ir + Ze * Ar + yt * nr - Pt * er + Gt * or;
          return Ft ? (h[0] = (E * sr - M * ir + O * Ar) * (Ft = 1 / Ft), h[1] = (_ * ir - p * sr - x * Ar) * Ft, h[2] = (ue * Gt - ve * Pt + Re * yt) * Ft, h[3] = (Y * Pt - V * Gt - ee * yt) * Ft, h[4] = (M * nr - A * sr - O * er) * Ft, h[5] = (u * sr - _ * nr + x * er) * Ft, h[6] = (ve * Ze - ie * Gt - Re * ze) * Ft, h[7] = (N * Gt - Y * Ze + ee * ze) * Ft, h[8] = (A * ir - E * nr + O * or) * Ft, h[9] = (p * nr - u * ir - x * or) * Ft, h[10] = (ie * Pt - ue * Ze + Re * it) * Ft, h[11] = (V * Ze - N * Pt - ee * it) * Ft, h[12] = (E * er - A * Ar - M * or) * Ft, h[13] = (u * Ar - p * er + _ * or) * Ft, h[14] = (ue * ze - ie * yt - ve * it) * Ft, h[15] = (N * yt - V * ze + Y * it) * Ft, h) : null;
        }, c.ar = Mt, c.as = function(h) {
          var l = h[0], u = h[1];
          return Math.sqrt(l * l + u * u);
        }, c.at = function(h) {
          return h[0] = 0, h[1] = 0, h;
        }, c.au = function(h, l, u) {
          return h[0] = l[0] * u, h[1] = l[1] * u, h;
        }, c.av = U0, c.aw = Be, c.ax = function(h, l, u, p) {
          const _ = l.y - h.y, x = l.x - h.x, A = p.y - u.y, E = p.x - u.x, M = A * x - E * _;
          if (M === 0) return null;
          const O = (E * (h.y - u.y) - A * (h.x - u.x)) / M;
          return new d(h.x + O * x, h.y + O * _);
        }, c.ay = yA, c.az = lw, c.b = Jt, c.b$ = class extends oo {
          constructor(h, l) {
            super(h, l), this.current = new Array();
          }
          set(h) {
            if (h != this.current) {
              this.current = h;
              const l = new Float32Array(h);
              this.gl.uniform1fv(this.location, l);
            }
          }
        }, c.b0 = function(h, l, u) {
          return h[0] = l[0] * u, h[1] = l[1] * u, h[2] = l[2] * u, h[3] = l[3] * u, h;
        }, c.b1 = function(h, l) {
          return h[0] * l[0] + h[1] * l[1] + h[2] * l[2] + h[3];
        }, c.b2 = dA, c.b3 = Md, c.b4 = function(h, l, u, p, _) {
          var x = 1 / Math.tan(l / 2);
          if (h[0] = x / u, h[1] = 0, h[2] = 0, h[3] = 0, h[4] = 0, h[5] = x, h[6] = 0, h[7] = 0, h[8] = 0, h[9] = 0, h[11] = -1, h[12] = 0, h[13] = 0, h[15] = 0, _ != null && _ !== 1 / 0) {
            var A = 1 / (p - _);
            h[10] = (_ + p) * A, h[14] = 2 * _ * p * A;
          } else h[10] = -1, h[14] = -2 * p;
          return h;
        }, c.b5 = function(h) {
          var l = new Z(16);
          return l[0] = h[0], l[1] = h[1], l[2] = h[2], l[3] = h[3], l[4] = h[4], l[5] = h[5], l[6] = h[6], l[7] = h[7], l[8] = h[8], l[9] = h[9], l[10] = h[10], l[11] = h[11], l[12] = h[12], l[13] = h[13], l[14] = h[14], l[15] = h[15], l;
        }, c.b6 = function(h, l, u) {
          var p = Math.sin(u), _ = Math.cos(u), x = l[0], A = l[1], E = l[2], M = l[3], O = l[4], N = l[5], V = l[6], Y = l[7];
          return l !== h && (h[8] = l[8], h[9] = l[9], h[10] = l[10], h[11] = l[11], h[12] = l[12], h[13] = l[13], h[14] = l[14], h[15] = l[15]), h[0] = x * _ + O * p, h[1] = A * _ + N * p, h[2] = E * _ + V * p, h[3] = M * _ + Y * p, h[4] = O * _ - x * p, h[5] = N * _ - A * p, h[6] = V * _ - E * p, h[7] = Y * _ - M * p, h;
        }, c.b7 = function(h, l, u) {
          var p = Math.sin(u), _ = Math.cos(u), x = l[4], A = l[5], E = l[6], M = l[7], O = l[8], N = l[9], V = l[10], Y = l[11];
          return l !== h && (h[0] = l[0], h[1] = l[1], h[2] = l[2], h[3] = l[3], h[12] = l[12], h[13] = l[13], h[14] = l[14], h[15] = l[15]), h[4] = x * _ + O * p, h[5] = A * _ + N * p, h[6] = E * _ + V * p, h[7] = M * _ + Y * p, h[8] = O * _ - x * p, h[9] = N * _ - A * p, h[10] = V * _ - E * p, h[11] = Y * _ - M * p, h;
        }, c.b8 = function() {
          const h = new Float32Array(16);
          return J(h), h;
        }, c.b9 = function() {
          const h = new Float64Array(16);
          return J(h), h;
        }, c.bA = function(h, l) {
          const u = Dt(h, 360), p = Dt(l, 360), _ = p - u, x = p > u ? _ - 360 : _ + 360;
          return Math.abs(_) < Math.abs(x) ? _ : x;
        }, c.bB = function(h) {
          return h[0] = 0, h[1] = 0, h[2] = 0, h;
        }, c.bC = function(h, l, u, p) {
          const _ = Math.sqrt(h * h + l * l), x = Math.sqrt(u * u + p * p);
          h /= _, l /= _, u /= x, p /= x;
          const A = Math.acos(h * u + l * p);
          return -l * u + h * p > 0 ? A : -A;
        }, c.bD = function(h, l) {
          const u = Dt(h, 2 * Math.PI), p = Dt(l, 2 * Math.PI);
          return Math.min(Math.abs(u - p), Math.abs(u - p + 2 * Math.PI), Math.abs(u - p - 2 * Math.PI));
        }, c.bE = function() {
          const h = {}, l = We.$version;
          for (const u in We.$root) {
            const p = We.$root[u];
            if (p.required) {
              let _ = null;
              _ = u === "version" ? l : p.type === "array" ? [] : {}, _ != null && (h[u] = _);
            }
          }
          return h;
        }, c.bF = kt, c.bG = Pe, c.bH = function h(l, u) {
          if (Array.isArray(l)) {
            if (!Array.isArray(u) || l.length !== u.length) return !1;
            for (let p = 0; p < l.length; p++) if (!h(l[p], u[p])) return !1;
            return !0;
          }
          if (typeof l == "object" && l !== null && u !== null) {
            if (typeof u != "object" || Object.keys(l).length !== Object.keys(u).length) return !1;
            for (const p in l) if (!h(l[p], u[p])) return !1;
            return !0;
          }
          return l === u;
        }, c.bI = function(h) {
          h = h.slice();
          const l = /* @__PURE__ */ Object.create(null);
          for (let u = 0; u < h.length; u++) l[h[u].id] = h[u];
          for (let u = 0; u < h.length; u++) "ref" in h[u] && (h[u] = Li(h[u], l[h[u].ref]));
          return h;
        }, c.bJ = function(h, l) {
          if (h.type === "custom") return new XL(h, l);
          switch (h.type) {
            case "background":
              return new WL(h, l);
            case "circle":
              return new R4(h, l);
            case "color-relief":
              return new N4(h, l);
            case "fill":
              return new K4(h, l);
            case "fill-extrusion":
              return new cL(h, l);
            case "heatmap":
              return new B4(h, l);
            case "hillshade":
              return new O4(h, l);
            case "line":
              return new mL(h, l);
            case "raster":
              return new is(h, l);
            case "symbol":
              return new Fm(h, l);
          }
        }, c.bK = (h) => h.type === "raster", c.bL = ur, c.bM = function(h, l) {
          if (!h) return [{ command: "setStyle", args: [l] }];
          let u = [];
          try {
            if (!fr(h.version, l.version)) return [{ command: "setStyle", args: [l] }];
            fr(h.center, l.center) || u.push({ command: "setCenter", args: [l.center] }), fr(h.state, l.state) || u.push({ command: "setGlobalState", args: [l.state] }), fr(h.centerAltitude, l.centerAltitude) || u.push({ command: "setCenterAltitude", args: [l.centerAltitude] }), fr(h.zoom, l.zoom) || u.push({ command: "setZoom", args: [l.zoom] }), fr(h.bearing, l.bearing) || u.push({ command: "setBearing", args: [l.bearing] }), fr(h.pitch, l.pitch) || u.push({ command: "setPitch", args: [l.pitch] }), fr(h.roll, l.roll) || u.push({ command: "setRoll", args: [l.roll] }), fr(h.sprite, l.sprite) || u.push({ command: "setSprite", args: [l.sprite] }), fr(h.glyphs, l.glyphs) || u.push({ command: "setGlyphs", args: [l.glyphs] }), fr(h.transition, l.transition) || u.push({ command: "setTransition", args: [l.transition] }), fr(h.light, l.light) || u.push({ command: "setLight", args: [l.light] }), fr(h.terrain, l.terrain) || u.push({ command: "setTerrain", args: [l.terrain] }), fr(h.sky, l.sky) || u.push({ command: "setSky", args: [l.sky] }), fr(h.projection, l.projection) || u.push({ command: "setProjection", args: [l.projection] });
            const p = {}, _ = [];
            (function(A, E, M, O) {
              let N;
              for (N in E = E || {}, A = A || {}) Object.prototype.hasOwnProperty.call(A, N) && (Object.prototype.hasOwnProperty.call(E, N) || _r(N, M, O));
              for (N in E) Object.prototype.hasOwnProperty.call(E, N) && (Object.prototype.hasOwnProperty.call(A, N) ? fr(A[N], E[N]) || (A[N].type === "geojson" && E[N].type === "geojson" && nn(A, E, N) ? Hr(M, { command: "setGeoJSONSourceData", args: [N, E[N].data] }) : qi(N, E, M, O)) : li(N, E, M));
            })(h.sources, l.sources, _, p);
            const x = [];
            h.layers && h.layers.forEach((A) => {
              "source" in A && p[A.source] ? u.push({ command: "removeLayer", args: [A.id] }) : x.push(A);
            }), u = u.concat(_), function(A, E, M) {
              E = E || [];
              const O = (A = A || []).map(vi), N = E.map(vi), V = A.reduce(ci, {}), Y = E.reduce(ci, {}), ee = O.slice(), ie = /* @__PURE__ */ Object.create(null);
              let ue, ve, Re, it, ze;
              for (let Ze = 0, yt = 0; Ze < O.length; Ze++) ue = O[Ze], Object.prototype.hasOwnProperty.call(Y, ue) ? yt++ : (Hr(M, { command: "removeLayer", args: [ue] }), ee.splice(ee.indexOf(ue, yt), 1));
              for (let Ze = 0, yt = 0; Ze < N.length; Ze++) ue = N[N.length - 1 - Ze], ee[ee.length - 1 - Ze] !== ue && (Object.prototype.hasOwnProperty.call(V, ue) ? (Hr(M, { command: "removeLayer", args: [ue] }), ee.splice(ee.lastIndexOf(ue, ee.length - yt), 1)) : yt++, it = ee[ee.length - Ze], Hr(M, { command: "addLayer", args: [Y[ue], it] }), ee.splice(ee.length - Ze, 0, ue), ie[ue] = !0);
              for (let Ze = 0; Ze < N.length; Ze++) if (ue = N[Ze], ve = V[ue], Re = Y[ue], !ie[ue] && !fr(ve, Re)) if (fr(ve.source, Re.source) && fr(ve["source-layer"], Re["source-layer"]) && fr(ve.type, Re.type)) {
                for (ze in Ei(ve.layout, Re.layout, M, ue, null, "setLayoutProperty"), Ei(ve.paint, Re.paint, M, ue, null, "setPaintProperty"), fr(ve.filter, Re.filter) || Hr(M, { command: "setFilter", args: [ue, Re.filter] }), fr(ve.minzoom, Re.minzoom) && fr(ve.maxzoom, Re.maxzoom) || Hr(M, { command: "setLayerZoomRange", args: [ue, Re.minzoom, Re.maxzoom] }), ve) Object.prototype.hasOwnProperty.call(ve, ze) && ze !== "layout" && ze !== "paint" && ze !== "filter" && ze !== "metadata" && ze !== "minzoom" && ze !== "maxzoom" && (ze.indexOf("paint.") === 0 ? Ei(ve[ze], Re[ze], M, ue, ze.slice(6), "setPaintProperty") : fr(ve[ze], Re[ze]) || Hr(M, { command: "setLayerProperty", args: [ue, ze, Re[ze]] }));
                for (ze in Re) Object.prototype.hasOwnProperty.call(Re, ze) && !Object.prototype.hasOwnProperty.call(ve, ze) && ze !== "layout" && ze !== "paint" && ze !== "filter" && ze !== "metadata" && ze !== "minzoom" && ze !== "maxzoom" && (ze.indexOf("paint.") === 0 ? Ei(ve[ze], Re[ze], M, ue, ze.slice(6), "setPaintProperty") : fr(ve[ze], Re[ze]) || Hr(M, { command: "setLayerProperty", args: [ue, ze, Re[ze]] }));
              } else Hr(M, { command: "removeLayer", args: [ue] }), it = ee[ee.lastIndexOf(ue) + 1], Hr(M, { command: "addLayer", args: [Re, it] });
            }(x, l.layers, u);
          } catch (p) {
            console.warn("Unable to compute style diff:", p), u = [{ command: "setStyle", args: [l] }];
          }
          return u;
        }, c.bN = function(h) {
          const l = [], u = h.id;
          return u === void 0 && l.push({ message: `layers.${u}: missing required property "id"` }), h.render === void 0 && l.push({ message: `layers.${u}: missing required method "render"` }), h.renderingMode && h.renderingMode !== "2d" && h.renderingMode !== "3d" && l.push({ message: `layers.${u}: property "renderingMode" must be either "2d" or "3d"` }), l;
        }, c.bO = Vt, c.bP = tr, c.bQ = class extends oo {
          constructor(h, l) {
            super(h, l), this.current = 0;
          }
          set(h) {
            this.current !== h && (this.current = h, this.gl.uniform1i(this.location, h));
          }
        }, c.bR = ns, c.bS = class extends oo {
          constructor(h, l) {
            super(h, l), this.current = Ps;
          }
          set(h) {
            if (h[12] !== this.current[12] || h[0] !== this.current[0]) return this.current = h, void this.gl.uniformMatrix4fv(this.location, !1, h);
            for (let l = 1; l < 16; l++) if (h[l] !== this.current[l]) {
              this.current = h, this.gl.uniformMatrix4fv(this.location, !1, h);
              break;
            }
          }
        }, c.bT = Ah, c.bU = class extends oo {
          constructor(h, l) {
            super(h, l), this.current = [0, 0, 0];
          }
          set(h) {
            h[0] === this.current[0] && h[1] === this.current[1] && h[2] === this.current[2] || (this.current = h, this.gl.uniform3f(this.location, h[0], h[1], h[2]));
          }
        }, c.bV = class extends oo {
          constructor(h, l) {
            super(h, l), this.current = [0, 0];
          }
          set(h) {
            h[0] === this.current[0] && h[1] === this.current[1] || (this.current = h, this.gl.uniform2f(this.location, h[0], h[1]));
          }
        }, c.bW = H, c.bX = function(h, l) {
          var u = Math.sin(l), p = Math.cos(l);
          return h[0] = p, h[1] = u, h[2] = 0, h[3] = -u, h[4] = p, h[5] = 0, h[6] = 0, h[7] = 0, h[8] = 1, h;
        }, c.bY = function(h, l, u) {
          var p = l[0], _ = l[1], x = l[2];
          return h[0] = p * u[0] + _ * u[3] + x * u[6], h[1] = p * u[1] + _ * u[4] + x * u[7], h[2] = p * u[2] + _ * u[5] + x * u[8], h;
        }, c.bZ = function(h, l, u, p, _, x, A) {
          var E = 1 / (l - u), M = 1 / (p - _), O = 1 / (x - A);
          return h[0] = -2 * E, h[1] = 0, h[2] = 0, h[3] = 0, h[4] = 0, h[5] = -2 * M, h[6] = 0, h[7] = 0, h[8] = 0, h[9] = 0, h[10] = 2 * O, h[11] = 0, h[12] = (l + u) * E, h[13] = (_ + p) * M, h[14] = (A + x) * O, h[15] = 1, h;
        }, c.b_ = class extends oo {
          constructor(h, l) {
            super(h, l), this.current = new Array();
          }
          set(h) {
            if (h != this.current) {
              this.current = h;
              const l = new Float32Array(4 * h.length);
              for (let u = 0; u < h.length; u++) l[4 * u] = h[u].r, l[4 * u + 1] = h[u].g, l[4 * u + 2] = h[u].b, l[4 * u + 3] = h[u].a;
              this.gl.uniform4fv(this.location, l);
            }
          }
        }, c.ba = function() {
          return new Float64Array(16);
        }, c.bb = function(h, l, u) {
          const p = new Float64Array(4);
          return St(p, h, l - 90, u), p;
        }, c.bc = function(h, l, u, p) {
          var _, x, A, E, M, O = l[0], N = l[1], V = l[2], Y = l[3], ee = u[0], ie = u[1], ue = u[2], ve = u[3];
          return (x = O * ee + N * ie + V * ue + Y * ve) < 0 && (x = -x, ee = -ee, ie = -ie, ue = -ue, ve = -ve), 1 - x > te ? (_ = Math.acos(x), A = Math.sin(_), E = Math.sin((1 - p) * _) / A, M = Math.sin(p * _) / A) : (E = 1 - p, M = p), h[0] = E * O + M * ee, h[1] = E * N + M * ie, h[2] = E * V + M * ue, h[3] = E * Y + M * ve, h;
        }, c.bd = function(h) {
          const l = new Float64Array(9);
          var u, p, _, x, A, E, M, O, N, V, Y, ee, ie, ue, ve, Re, it, ze;
          V = (_ = (p = h)[0]) * (M = _ + _), Y = (x = p[1]) * M, ie = (A = p[2]) * M, ue = A * (O = x + x), Re = (E = p[3]) * M, it = E * O, ze = E * (N = A + A), (u = l)[0] = 1 - (ee = x * O) - (ve = A * N), u[3] = Y - ze, u[6] = ie + it, u[1] = Y + ze, u[4] = 1 - V - ve, u[7] = ue - Re, u[2] = ie - it, u[5] = ue + Re, u[8] = 1 - V - ee;
          const Ze = Fr(-Math.asin(rt(l[2], -1, 1)));
          let yt, Pt;
          return Math.hypot(l[5], l[8]) < 1e-3 ? (yt = 0, Pt = -Fr(Math.atan2(l[3], l[4]))) : (yt = Fr(l[5] === 0 && l[8] === 0 ? 0 : Math.atan2(l[5], l[8])), Pt = Fr(l[1] === 0 && l[0] === 0 ? 0 : Math.atan2(l[1], l[0]))), { roll: yt, pitch: Ze + 90, bearing: Pt };
        }, c.be = function(h, l) {
          return h.roll == l.roll && h.pitch == l.pitch && h.bearing == l.bearing;
        }, c.bf = jr, c.bg = Il, c.bh = Sd, c.bi = Jp, c.bj = Td, c.bk = fe, c.bl = De, c.bm = As, c.bn = function(h, l, u, p, _) {
          return fe(p, _, rt((h - l) / (u - l), 0, 1));
        }, c.bo = Dt, c.bp = function() {
          return new Float64Array(3);
        }, c.bq = function(h, l, u, p) {
          return h[0] = l[0] + u[0] * p, h[1] = l[1] + u[1] * p, h[2] = l[2] + u[2] * p, h;
        }, c.br = St, c.bs = function(h, l, u) {
          var p = u[0], _ = u[1], x = u[2], A = u[3], E = l[0], M = l[1], O = l[2], N = _ * O - x * M, V = x * E - p * O, Y = p * M - _ * E;
          return h[0] = E + A * (N += N) + _ * (Y += Y) - x * (V += V), h[1] = M + A * V + x * N - p * Y, h[2] = O + A * Y + p * V - _ * N, h;
        }, c.bt = function(h, l, u) {
          const p = (_ = [h[0], h[1], h[2], l[0], l[1], l[2], u[0], u[1], u[2]])[0] * ((N = _[8]) * (A = _[4]) - (E = _[5]) * (O = _[7])) + _[1] * (-N * (x = _[3]) + E * (M = _[6])) + _[2] * (O * x - A * M);
          var _, x, A, E, M, O, N;
          if (p === 0) return null;
          const V = le([], [l[0], l[1], l[2]], [u[0], u[1], u[2]]), Y = le([], [u[0], u[1], u[2]], [h[0], h[1], h[2]]), ee = le([], [h[0], h[1], h[2]], [l[0], l[1], l[2]]), ie = Ee([], V, -h[3]);
          return oe(ie, ie, Ee([], Y, -l[3])), oe(ie, ie, Ee([], ee, -u[3])), Ee(ie, ie, 1 / p), ie;
        }, c.bu = G0, c.bv = function() {
          return new Float64Array(4);
        }, c.bw = function(h, l, u, p) {
          var _ = [], x = [];
          return _[0] = l[0] - u[0], _[1] = l[1] - u[1], _[2] = l[2] - u[2], x[0] = _[0] * Math.cos(p) - _[1] * Math.sin(p), x[1] = _[0] * Math.sin(p) + _[1] * Math.cos(p), x[2] = _[2], h[0] = x[0] + u[0], h[1] = x[1] + u[1], h[2] = x[2] + u[2], h;
        }, c.bx = function(h, l, u, p) {
          var _ = [], x = [];
          return _[0] = l[0] - u[0], _[1] = l[1] - u[1], _[2] = l[2] - u[2], x[0] = _[0], x[1] = _[1] * Math.cos(p) - _[2] * Math.sin(p), x[2] = _[1] * Math.sin(p) + _[2] * Math.cos(p), h[0] = x[0] + u[0], h[1] = x[1] + u[1], h[2] = x[2] + u[2], h;
        }, c.by = function(h, l, u, p) {
          var _ = [], x = [];
          return _[0] = l[0] - u[0], _[1] = l[1] - u[1], _[2] = l[2] - u[2], x[0] = _[2] * Math.sin(p) + _[0] * Math.cos(p), x[1] = _[1], x[2] = _[2] * Math.cos(p) - _[0] * Math.sin(p), h[0] = x[0] + u[0], h[1] = x[1] + u[1], h[2] = x[2] + u[2], h;
        }, c.bz = function(h, l, u) {
          var p = Math.sin(u), _ = Math.cos(u), x = l[0], A = l[1], E = l[2], M = l[3], O = l[8], N = l[9], V = l[10], Y = l[11];
          return l !== h && (h[4] = l[4], h[5] = l[5], h[6] = l[6], h[7] = l[7], h[12] = l[12], h[13] = l[13], h[14] = l[14], h[15] = l[15]), h[0] = x * _ - O * p, h[1] = A * _ - N * p, h[2] = E * _ - V * p, h[3] = M * _ - Y * p, h[8] = x * p + O * _, h[9] = A * p + N * _, h[10] = E * p + V * _, h[11] = M * p + Y * _, h;
        }, c.c = Ue, c.c0 = class extends Aa {
        }, c.c1 = vL, c.c2 = class extends wh {
        }, c.c3 = T0, c.c4 = function(h) {
          return h <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(h) / Math.LN2));
        }, c.c5 = yw, c.c6 = function(h, l, u) {
          var p = l[0], _ = l[1], x = l[2], A = u[3] * p + u[7] * _ + u[11] * x + u[15];
          return h[0] = (u[0] * p + u[4] * _ + u[8] * x + u[12]) / (A = A || 1), h[1] = (u[1] * p + u[5] * _ + u[9] * x + u[13]) / A, h[2] = (u[2] * p + u[6] * _ + u[10] * x + u[14]) / A, h;
        }, c.c7 = class extends so {
        }, c.c8 = class extends S {
        }, c.c9 = function(h, l) {
          return h[0] === l[0] && h[1] === l[1] && h[2] === l[2] && h[3] === l[3] && h[4] === l[4] && h[5] === l[5] && h[6] === l[6] && h[7] === l[7] && h[8] === l[8] && h[9] === l[9] && h[10] === l[10] && h[11] === l[11] && h[12] === l[12] && h[13] === l[13] && h[14] === l[14] && h[15] === l[15];
        }, c.cA = function(h, l) {
          K.REGISTERED_PROTOCOLS[h] = l;
        }, c.cB = function(h) {
          delete K.REGISTERED_PROTOCOLS[h];
        }, c.cC = function(h, l) {
          const u = {};
          for (let _ = 0; _ < h.length; _++) {
            const x = l && l[h[_].id] || ba(h[_]);
            l && (l[h[_].id] = x);
            let A = u[x];
            A || (A = u[x] = []), A.push(h[_]);
          }
          const p = [];
          for (const _ in u) p.push(u[_]);
          return p;
        }, c.cD = me, c.cE = pA, c.cF = mA, c.cG = Ww, c.cH = function(h) {
          h.bucket.createArrays(), h.bucket.tilePixelRatio = wt / (512 * h.bucket.overscaling), h.bucket.compareText = {}, h.bucket.iconsNeedLinear = !1;
          const l = h.bucket.layers[0], u = l.layout, p = l._unevaluatedLayout._values, _ = { layoutIconSize: p["icon-size"].possiblyEvaluate(new Wr(h.bucket.zoom + 1), h.canonical), layoutTextSize: p["text-size"].possiblyEvaluate(new Wr(h.bucket.zoom + 1), h.canonical), textMaxSize: p["text-size"].possiblyEvaluate(new Wr(18)) };
          if (h.bucket.textSizeData.kind === "composite") {
            const { minZoom: O, maxZoom: N } = h.bucket.textSizeData;
            _.compositeTextSizes = [p["text-size"].possiblyEvaluate(new Wr(O), h.canonical), p["text-size"].possiblyEvaluate(new Wr(N), h.canonical)];
          }
          if (h.bucket.iconSizeData.kind === "composite") {
            const { minZoom: O, maxZoom: N } = h.bucket.iconSizeData;
            _.compositeIconSizes = [p["icon-size"].possiblyEvaluate(new Wr(O), h.canonical), p["icon-size"].possiblyEvaluate(new Wr(N), h.canonical)];
          }
          const x = u.get("text-line-height") * Ms, A = u.get("text-rotation-alignment") !== "viewport" && u.get("symbol-placement") !== "point", E = u.get("text-keep-upright"), M = u.get("text-size");
          for (const O of h.bucket.features) {
            const N = u.get("text-font").evaluate(O, {}, h.canonical).join(","), V = M.evaluate(O, {}, h.canonical), Y = _.layoutTextSize.evaluate(O, {}, h.canonical), ee = _.layoutIconSize.evaluate(O, {}, h.canonical), ie = { horizontal: {}, vertical: void 0 }, ue = O.text;
            let ve, Re = [0, 0];
            if (ue) {
              const Ze = ue.toString(), yt = u.get("text-letter-spacing").evaluate(O, {}, h.canonical) * Ms, Pt = jt(Ze) ? yt : 0, Gt = u.get("text-anchor").evaluate(O, {}, h.canonical), or = CA(l, O, h.canonical);
              if (!or) {
                const ir = u.get("text-radial-offset").evaluate(O, {}, h.canonical);
                Re = ir ? EA(Gt, [ir * Ms, q0]) : u.get("text-offset").evaluate(O, {}, h.canonical).map((sr) => sr * Ms);
              }
              let er = A ? "center" : u.get("text-justify").evaluate(O, {}, h.canonical);
              const nr = u.get("symbol-placement") === "point" ? u.get("text-max-width").evaluate(O, {}, h.canonical) * Ms : 1 / 0, Ar = () => {
                h.bucket.allowVerticalPlacement && Ot(Ze) && (ie.vertical = Om(ue, h.glyphMap, h.glyphPositions, h.imagePositions, N, nr, x, Gt, "left", Pt, Re, c.ao.vertical, !0, Y, V));
              };
              if (!A && or) {
                const ir = /* @__PURE__ */ new Set();
                if (er === "auto") for (let Ft = 0; Ft < or.values.length; Ft += 2) ir.add(W0(or.values[Ft]));
                else ir.add(er);
                let sr = !1;
                for (const Ft of ir) if (!ie.horizontal[Ft]) if (sr) ie.horizontal[Ft] = ie.horizontal[0];
                else {
                  const Gr = Om(ue, h.glyphMap, h.glyphPositions, h.imagePositions, N, nr, x, "center", Ft, Pt, Re, c.ao.horizontal, !1, Y, V);
                  Gr && (ie.horizontal[Ft] = Gr, sr = Gr.positionedLines.length === 1);
                }
                Ar();
              } else {
                er === "auto" && (er = W0(Gt));
                const ir = Om(ue, h.glyphMap, h.glyphPositions, h.imagePositions, N, nr, x, Gt, er, Pt, Re, c.ao.horizontal, !1, Y, V);
                ir && (ie.horizontal[er] = ir), Ar(), Ot(Ze) && A && E && (ie.vertical = Om(ue, h.glyphMap, h.glyphPositions, h.imagePositions, N, nr, x, Gt, er, Pt, Re, c.ao.vertical, !1, Y, V));
              }
            }
            let it = !1;
            if (O.icon && O.icon.name) {
              const Ze = h.imageMap[O.icon.name];
              Ze && (ve = VL(h.imagePositions[O.icon.name], u.get("icon-offset").evaluate(O, {}, h.canonical), u.get("icon-anchor").evaluate(O, {}, h.canonical)), it = !!Ze.sdf, h.bucket.sdfIcons === void 0 ? h.bucket.sdfIcons = it : h.bucket.sdfIcons !== it && Ct("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ze.pixelRatio !== h.bucket.pixelRatio || u.get("icon-rotate").constantOr(1) !== 0) && (h.bucket.iconsNeedLinear = !0));
            }
            const ze = PA(ie.horizontal) || ie.vertical;
            h.bucket.iconsInText = !!ze && ze.iconsInText, (ze || ve) && iB(h.bucket, O, ie, ve, h.imageMap, _, Y, ee, Re, it, h.canonical, h.subdivisionGranularity);
          }
          h.showCollisionBoxes && h.bucket.generateCollisionDebugBuffers();
        }, c.cI = P0, c.cJ = R0, c.cK = L0, c.cL = Bw, c.cM = k0, c.cN = class {
          constructor(h) {
            this._marks = { start: [h.url, "start"].join("#"), end: [h.url, "end"].join("#"), measure: h.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let h = performance.getEntriesByName(this._marks.measure);
            return h.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), h = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), h;
          }
        }, c.cO = function(h, l, u, p, _) {
          return o(this, void 0, void 0, function* () {
            if (G()) try {
              return yield hr(h, l, u, p, _);
            } catch {
            }
            return function(x, A, E, M, O) {
              const N = x.width, V = x.height;
              qr && xr || (qr = new OffscreenCanvas(N, V), xr = qr.getContext("2d", { willReadFrequently: !0 })), qr.width = N, qr.height = V, xr.drawImage(x, 0, 0, N, V);
              const Y = xr.getImageData(A, E, M, O);
              return xr.clearRect(0, 0, N, V), Y.data;
            }(h, l, u, p, _);
          });
        }, c.cP = xw, c.cQ = m, c.cR = Lw, c.cS = Ed, c.cT = qc, c.cU = function(h, l) {
          const u = /* @__PURE__ */ new Map();
          if (h != null) if (h.type === "Feature") u.set(ng(h, l), h);
          else for (const p of h.features) u.set(ng(p, l), p);
          return u;
        }, c.cV = function(h, l) {
          if (h == null) return !0;
          if (h.type === "Feature") return ng(h, l) != null;
          if (h.type === "FeatureCollection") {
            const u = /* @__PURE__ */ new Set();
            for (const p of h.features) {
              const _ = ng(p, l);
              if (_ == null || u.has(_)) return !1;
              u.add(_);
            }
            return !0;
          }
          return !1;
        }, c.cW = function(h, l, u) {
          var p, _, x, A;
          if (l.removeAll && h.clear(), l.remove) for (const E of l.remove) h.delete(E);
          if (l.add) for (const E of l.add) {
            const M = ng(E, u);
            M != null && h.set(M, E);
          }
          if (l.update) for (const E of l.update) {
            let M = h.get(E.id);
            if (M == null) continue;
            const O = !E.removeAllProperties && (((p = E.removeProperties) === null || p === void 0 ? void 0 : p.length) > 0 || ((_ = E.addOrUpdateProperties) === null || _ === void 0 ? void 0 : _.length) > 0);
            if ((E.newGeometry || E.removeAllProperties || O) && (M = Object.assign({}, M), h.set(E.id, M), O && (M.properties = Object.assign({}, M.properties))), E.newGeometry && (M.geometry = E.newGeometry), E.removeAllProperties) M.properties = {};
            else if (((x = E.removeProperties) === null || x === void 0 ? void 0 : x.length) > 0) for (const N of E.removeProperties) Object.prototype.hasOwnProperty.call(M.properties, N) && delete M.properties[N];
            if (((A = E.addOrUpdateProperties) === null || A === void 0 ? void 0 : A.length) > 0) for (const { key: N, value: V } of E.addOrUpdateProperties) M.properties[N] = V;
          }
        }, c.cX = lr, c.ca = function(h, l) {
          var u = h[0], p = h[1], _ = h[2], x = h[3], A = h[4], E = h[5], M = h[6], O = h[7], N = h[8], V = h[9], Y = h[10], ee = h[11], ie = h[12], ue = h[13], ve = h[14], Re = h[15], it = l[0], ze = l[1], Ze = l[2], yt = l[3], Pt = l[4], Gt = l[5], or = l[6], er = l[7], nr = l[8], Ar = l[9], ir = l[10], sr = l[11], Ft = l[12], Gr = l[13], Xr = l[14], kr = l[15];
          return Math.abs(u - it) <= te * Math.max(1, Math.abs(u), Math.abs(it)) && Math.abs(p - ze) <= te * Math.max(1, Math.abs(p), Math.abs(ze)) && Math.abs(_ - Ze) <= te * Math.max(1, Math.abs(_), Math.abs(Ze)) && Math.abs(x - yt) <= te * Math.max(1, Math.abs(x), Math.abs(yt)) && Math.abs(A - Pt) <= te * Math.max(1, Math.abs(A), Math.abs(Pt)) && Math.abs(E - Gt) <= te * Math.max(1, Math.abs(E), Math.abs(Gt)) && Math.abs(M - or) <= te * Math.max(1, Math.abs(M), Math.abs(or)) && Math.abs(O - er) <= te * Math.max(1, Math.abs(O), Math.abs(er)) && Math.abs(N - nr) <= te * Math.max(1, Math.abs(N), Math.abs(nr)) && Math.abs(V - Ar) <= te * Math.max(1, Math.abs(V), Math.abs(Ar)) && Math.abs(Y - ir) <= te * Math.max(1, Math.abs(Y), Math.abs(ir)) && Math.abs(ee - sr) <= te * Math.max(1, Math.abs(ee), Math.abs(sr)) && Math.abs(ie - Ft) <= te * Math.max(1, Math.abs(ie), Math.abs(Ft)) && Math.abs(ue - Gr) <= te * Math.max(1, Math.abs(ue), Math.abs(Gr)) && Math.abs(ve - Xr) <= te * Math.max(1, Math.abs(ve), Math.abs(Xr)) && Math.abs(Re - kr) <= te * Math.max(1, Math.abs(Re), Math.abs(kr));
        }, c.cb = function(h, l) {
          return h[0] = l[0], h[1] = l[1], h[2] = l[2], h[3] = l[3], h[4] = l[4], h[5] = l[5], h[6] = l[6], h[7] = l[7], h[8] = l[8], h[9] = l[9], h[10] = l[10], h[11] = l[11], h[12] = l[12], h[13] = l[13], h[14] = l[14], h[15] = l[15], h;
        }, c.cc = (h) => h.type === "symbol", c.cd = (h) => h.type === "circle", c.ce = (h) => h.type === "heatmap", c.cf = (h) => h.type === "line", c.cg = (h) => h.type === "fill", c.ch = (h) => h.type === "fill-extrusion", c.ci = (h) => h.type === "hillshade", c.cj = (h) => h.type === "color-relief", c.ck = (h) => h.type === "background", c.cl = (h) => h.type === "custom", c.cm = je, c.cn = function(h, l, u) {
          const p = mt(l.x - u.x, l.y - u.y), _ = mt(h.x - u.x, h.y - u.y);
          var x, A;
          return Fr(Math.atan2(p[0] * _[1] - p[1] * _[0], (x = p)[0] * (A = _)[0] + x[1] * A[1]));
        }, c.co = Ke, c.cp = function(h, l) {
          return Kr[l] && (h instanceof MouseEvent || h instanceof WheelEvent);
        }, c.cq = function(h, l) {
          return Ri[l] && "touches" in h;
        }, c.cr = function(h) {
          return Ri[h] || Kr[h];
        }, c.cs = function(h, l, u) {
          var p = l[0], _ = l[1];
          return h[0] = u[0] * p + u[4] * _ + u[12], h[1] = u[1] * p + u[5] * _ + u[13], h;
        }, c.ct = function(h, l) {
          const { x: u, y: p } = ig.fromLngLat(l);
          return !(h < 0 || h > 25 || p < 0 || p >= 1 || u < 0 || u >= 1);
        }, c.cu = function(h, l) {
          return h[0] = l[0], h[1] = 0, h[2] = 0, h[3] = 0, h[4] = 0, h[5] = l[1], h[6] = 0, h[7] = 0, h[8] = 0, h[9] = 0, h[10] = l[2], h[11] = 0, h[12] = 0, h[13] = 0, h[14] = 0, h[15] = 1, h;
        }, c.cv = class extends In {
        }, c.cw = sB, c.cy = function(h) {
          return h.message === wr;
        }, c.cz = Te, c.d = Je, c.e = Et, c.f = (h) => o(void 0, void 0, void 0, function* () {
          if (h.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const l = new Blob([new Uint8Array(h)], { type: "image/png" });
          try {
            return createImageBitmap(l);
          } catch (u) {
            throw new Error(`Could not load image because of ${u.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), c.g = ne, c.h = (h) => new Promise((l, u) => {
          const p = new Image();
          p.onload = () => {
            l(p), URL.revokeObjectURL(p.src), p.onload = null, window.requestAnimationFrame(() => {
              p.src = Sr;
            });
          }, p.onerror = () => u(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const _ = new Blob([new Uint8Array(h)], { type: "image/png" });
          p.src = h.byteLength ? URL.createObjectURL(_) : Sr;
        }), c.i = ii, c.j = (h, l) => qe(Et(h, { type: "json" }), l), c.k = It, c.l = Bt, c.m = qe, c.n = (h, l) => qe(Et(h, { type: "arrayBuffer" }), l), c.o = function(h) {
          return new k0(h).readFields(RL, []);
        }, c.p = qw, c.q = qp, c.r = ln, c.s = bi, c.t = Xn, c.u = tt, c.v = We, c.w = Ct, c.x = z, c.y = ge, c.z = L;
      }), n("worker", ["./shared"], function(c) {
        class o {
          constructor(K, ne) {
            this.keyCache = {}, K && this.replace(K, ne);
          }
          replace(K, ne) {
            this._layerConfigs = {}, this._layers = {}, this.update(K, [], ne);
          }
          update(K, ne, de) {
            for (const Pe of K) {
              this._layerConfigs[Pe.id] = Pe;
              const qe = this._layers[Pe.id] = c.bJ(Pe, de);
              qe._featureFilter = c.aa(qe.filter, de), this.keyCache[Pe.id] && delete this.keyCache[Pe.id];
            }
            for (const Pe of ne) delete this.keyCache[Pe], delete this._layerConfigs[Pe], delete this._layers[Pe];
            this.familiesBySource = {};
            const Te = c.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const Pe of Te) {
              const qe = Pe.map((rr) => this._layers[rr.id]), Je = qe[0];
              if (Je.visibility === "none") continue;
              const He = Je.source || "";
              let nt = this.familiesBySource[He];
              nt || (nt = this.familiesBySource[He] = {});
              const Bt = Je.sourceLayer || "_geojsonTileLayer";
              let It = nt[Bt];
              It || (It = nt[Bt] = []), It.push(qe);
            }
          }
        }
        class d {
          constructor(K) {
            const ne = {}, de = [];
            for (const Je in K) {
              const He = K[Je], nt = ne[Je] = {};
              for (const Bt in He) {
                const It = He[+Bt];
                if (!It || It.bitmap.width === 0 || It.bitmap.height === 0) continue;
                const rr = { x: 0, y: 0, w: It.bitmap.width + 2, h: It.bitmap.height + 2 };
                de.push(rr), nt[Bt] = { rect: rr, metrics: It.metrics };
              }
            }
            const { w: Te, h: Pe } = c.p(de), qe = new c.q({ width: Te || 1, height: Pe || 1 });
            for (const Je in K) {
              const He = K[Je];
              for (const nt in He) {
                const Bt = He[+nt];
                if (!Bt || Bt.bitmap.width === 0 || Bt.bitmap.height === 0) continue;
                const It = ne[Je][nt].rect;
                c.q.copy(Bt.bitmap, qe, { x: 0, y: 0 }, { x: It.x + 1, y: It.y + 1 }, Bt.bitmap);
              }
            }
            this.image = qe, this.positions = ne;
          }
        }
        c.cD("GlyphAtlas", d);
        class m {
          constructor(K) {
            this.tileID = new c.Z(K.tileID.overscaledZ, K.tileID.wrap, K.tileID.canonical.z, K.tileID.canonical.x, K.tileID.canonical.y), this.uid = K.uid, this.zoom = K.zoom, this.pixelRatio = K.pixelRatio, this.tileSize = K.tileSize, this.source = K.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = K.showCollisionBoxes, this.collectResourceTiming = !!K.collectResourceTiming, this.returnDependencies = !!K.returnDependencies, this.promoteId = K.promoteId, this.inFlightDependencies = [];
          }
          parse(K, ne, de, Te, Pe) {
            return c._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = K, this.collisionBoxArray = new c.a8();
              const qe = new c.cE(Object.keys(K.layers).sort()), Je = new c.cF(this.tileID, this.promoteId);
              Je.bucketLayerIDs = [];
              const He = {}, nt = { featureIndex: Je, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: de, subdivisionGranularity: Pe }, Bt = ne.familiesBySource[this.source];
              for (const Lt in Bt) {
                const pi = K.layers[Lt];
                if (!pi) continue;
                pi.version === 1 && c.w(`Vector tile source "${this.source}" layer "${Lt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Rn = qe.encode(Lt), eo = [];
                for (let sn = 0; sn < pi.length; sn++) {
                  const Xt = pi.feature(sn), Dr = Je.getId(Xt, Lt);
                  eo.push({ feature: Xt, id: Dr, index: sn, sourceLayerIndex: Rn });
                }
                for (const sn of Bt[Lt]) {
                  const Xt = sn[0];
                  Xt.source !== this.source && c.w(`layer.source = ${Xt.source} does not equal this.source = ${this.source}`), Xt.isHidden(this.zoom, !0) || (y(sn, this.zoom, de), (He[Xt.id] = Xt.createBucket({ index: Je.bucketLayerIDs.length, layers: sn, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Rn, sourceID: this.source })).populate(eo, nt, this.tileID.canonical), Je.bucketLayerIDs.push(sn.map((Dr) => Dr.id)));
                }
              }
              const It = c.bO(nt.glyphDependencies, (Lt) => Object.keys(Lt).map(Number));
              this.inFlightDependencies.forEach((Lt) => Lt?.abort()), this.inFlightDependencies = [];
              let rr = Promise.resolve({});
              if (Object.keys(It).length) {
                const Lt = new AbortController();
                this.inFlightDependencies.push(Lt), rr = Te.sendAsync({ type: "GG", data: { stacks: It, source: this.source, tileID: this.tileID, type: "glyphs" } }, Lt);
              }
              const We = Object.keys(nt.iconDependencies);
              let mr = Promise.resolve({});
              if (We.length) {
                const Lt = new AbortController();
                this.inFlightDependencies.push(Lt), mr = Te.sendAsync({ type: "GI", data: { icons: We, source: this.source, tileID: this.tileID, type: "icons" } }, Lt);
              }
              const Li = Object.keys(nt.patternDependencies);
              let fr = Promise.resolve({});
              if (Li.length) {
                const Lt = new AbortController();
                this.inFlightDependencies.push(Lt), fr = Te.sendAsync({ type: "GI", data: { icons: Li, source: this.source, tileID: this.tileID, type: "patterns" } }, Lt);
              }
              const Hr = nt.dashDependencies;
              let li = Promise.resolve({});
              if (Object.keys(Hr).length) {
                const Lt = new AbortController();
                this.inFlightDependencies.push(Lt), li = Te.sendAsync({ type: "GDA", data: { dashes: Hr } }, Lt);
              }
              const [_r, qi, nn, Ei] = yield Promise.all([rr, mr, fr, li]), vi = new d(_r), ci = new c.cG(qi, nn);
              for (const Lt in He) {
                const pi = He[Lt];
                pi instanceof c.a9 ? (y(pi.layers, this.zoom, de), c.cH({ bucket: pi, glyphMap: _r, glyphPositions: vi.positions, imageMap: qi, imagePositions: ci.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: nt.subdivisionGranularity })) : pi.hasDependencies && (pi instanceof c.cI || pi instanceof c.cJ || pi instanceof c.cK) && (y(pi.layers, this.zoom, de), pi.addFeatures(nt, this.tileID.canonical, ci.patternPositions, Ei));
              }
              return this.status = "done", { buckets: Object.values(He).filter((Lt) => !Lt.isEmpty()), featureIndex: Je, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: vi.image, imageAtlas: ci, dashPositions: Ei, glyphMap: this.returnDependencies ? _r : null, iconMap: this.returnDependencies ? qi : null, glyphPositions: this.returnDependencies ? vi.positions : null };
            });
          }
        }
        function y(Ue, K, ne) {
          const de = new c.F(K);
          for (const Te of Ue) Te.recalculate(de, ne);
        }
        class T {
          constructor(K, ne, de) {
            this.actor = K, this.layerIndex = ne, this.availableImages = de, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(K, ne) {
            return c._(this, void 0, void 0, function* () {
              const de = yield c.n(K.request, ne);
              try {
                return { vectorTile: new c.cL(new c.cM(de.data)), rawData: de.data, cacheControl: de.cacheControl, expires: de.expires };
              } catch (Te) {
                const Pe = new Uint8Array(de.data);
                let qe = `Unable to parse the tile at ${K.request.url}, `;
                throw qe += Pe[0] === 31 && Pe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${Te.message}`, new Error(qe);
              }
            });
          }
          loadTile(K) {
            return c._(this, void 0, void 0, function* () {
              const ne = K.uid, de = !!(K && K.request && K.request.collectResourceTiming) && new c.cN(K.request), Te = new m(K);
              this.loading[ne] = Te;
              const Pe = new AbortController();
              Te.abort = Pe;
              try {
                const qe = yield this.loadVectorTile(K, Pe);
                if (delete this.loading[ne], !qe) return null;
                const Je = qe.rawData, He = {};
                qe.expires && (He.expires = qe.expires), qe.cacheControl && (He.cacheControl = qe.cacheControl);
                const nt = {};
                if (de) {
                  const It = de.finish();
                  It && (nt.resourceTiming = JSON.parse(JSON.stringify(It)));
                }
                Te.vectorTile = qe.vectorTile;
                const Bt = Te.parse(qe.vectorTile, this.layerIndex, this.availableImages, this.actor, K.subdivisionGranularity);
                this.loaded[ne] = Te, this.fetching[ne] = { rawTileData: Je, cacheControl: He, resourceTiming: nt };
                try {
                  const It = yield Bt;
                  return c.e({ rawTileData: Je.slice(0) }, It, He, nt);
                } finally {
                  delete this.fetching[ne];
                }
              } catch (qe) {
                throw delete this.loading[ne], Te.status = "done", this.loaded[ne] = Te, qe;
              }
            });
          }
          reloadTile(K) {
            return c._(this, void 0, void 0, function* () {
              const ne = K.uid;
              if (!this.loaded || !this.loaded[ne]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const de = this.loaded[ne];
              if (de.showCollisionBoxes = K.showCollisionBoxes, de.status === "parsing") {
                const Te = yield de.parse(de.vectorTile, this.layerIndex, this.availableImages, this.actor, K.subdivisionGranularity);
                let Pe;
                if (this.fetching[ne]) {
                  const { rawTileData: qe, cacheControl: Je, resourceTiming: He } = this.fetching[ne];
                  delete this.fetching[ne], Pe = c.e({ rawTileData: qe.slice(0) }, Te, Je, He);
                } else Pe = Te;
                return Pe;
              }
              if (de.status === "done" && de.vectorTile) return de.parse(de.vectorTile, this.layerIndex, this.availableImages, this.actor, K.subdivisionGranularity);
            });
          }
          abortTile(K) {
            return c._(this, void 0, void 0, function* () {
              const ne = this.loading, de = K.uid;
              ne && ne[de] && ne[de].abort && (ne[de].abort.abort(), delete ne[de]);
            });
          }
          removeTile(K) {
            return c._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[K.uid] && delete this.loaded[K.uid];
            });
          }
        }
        class P {
          constructor() {
            this.loaded = {};
          }
          loadTile(K) {
            return c._(this, void 0, void 0, function* () {
              const { uid: ne, encoding: de, rawImageData: Te, redFactor: Pe, greenFactor: qe, blueFactor: Je, baseShift: He } = K, nt = Te.width + 2, Bt = Te.height + 2, It = c.b(Te) ? new c.R({ width: nt, height: Bt }, yield c.cO(Te, -1, -1, nt, Bt)) : Te, rr = new c.cP(ne, It, de, Pe, qe, Je, He);
              return this.loaded = this.loaded || {}, this.loaded[ne] = rr, rr;
            });
          }
          removeTile(K) {
            const ne = this.loaded, de = K.uid;
            ne && ne[de] && delete ne[de];
          }
        }
        var I, D, k = function() {
          if (D) return I;
          function Ue(ne, de) {
            if (ne.length !== 0) {
              K(ne[0], de);
              for (var Te = 1; Te < ne.length; Te++) K(ne[Te], !de);
            }
          }
          function K(ne, de) {
            for (var Te = 0, Pe = 0, qe = 0, Je = ne.length, He = Je - 1; qe < Je; He = qe++) {
              var nt = (ne[qe][0] - ne[He][0]) * (ne[He][1] + ne[qe][1]), Bt = Te + nt;
              Pe += Math.abs(Te) >= Math.abs(nt) ? Te - Bt + nt : nt - Bt + Te, Te = Bt;
            }
            Te + Pe >= 0 != !!de && ne.reverse();
          }
          return D = 1, I = function ne(de, Te) {
            var Pe, qe = de && de.type;
            if (qe === "FeatureCollection") for (Pe = 0; Pe < de.features.length; Pe++) ne(de.features[Pe], Te);
            else if (qe === "GeometryCollection") for (Pe = 0; Pe < de.geometries.length; Pe++) ne(de.geometries[Pe], Te);
            else if (qe === "Feature") ne(de.geometry, Te);
            else if (qe === "Polygon") Ue(de.coordinates, Te);
            else if (qe === "MultiPolygon") for (Pe = 0; Pe < de.coordinates.length; Pe++) Ue(de.coordinates[Pe], Te);
            return de;
          };
        }(), $ = c.cQ(k);
        class G extends c.cS {
          constructor(K, ne) {
            super(new c.cM(), 0, ne, [], []), this.feature = K, this.type = K.type, this.properties = K.tags ? K.tags : {}, "id" in K && (typeof K.id == "string" ? this.id = parseInt(K.id, 10) : typeof K.id != "number" || isNaN(K.id) || (this.id = K.id));
          }
          loadGeometry() {
            const K = [], ne = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const de of ne) {
              const Te = [];
              for (const Pe of de) Te.push(new c.P(Pe[0], Pe[1]));
              K.push(Te);
            }
            return K;
          }
        }
        class te extends c.cR {
          constructor(K, ne) {
            super(new c.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = ne ? ne.version : 1, this.extent = ne ? ne.extent : 4096, this.length = K.length, this.features = K;
          }
          feature(K) {
            return new G(this.features[K], this.extent);
          }
        }
        function Z(Ue, K) {
          K.writeVarintField(15, Ue.version || 1), K.writeStringField(1, Ue.name || ""), K.writeVarintField(5, Ue.extent || 4096);
          const ne = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let Pe = 0; Pe < Ue.length; Pe++) ne.feature = Ue.feature(Pe), K.writeMessage(2, H, ne);
          const de = ne.keys;
          for (const Pe of de) K.writeStringField(3, Pe);
          const Te = ne.values;
          for (const Pe of Te) K.writeMessage(4, oe, Pe);
        }
        function H(Ue, K) {
          if (!Ue.feature) return;
          const ne = Ue.feature;
          ne.id !== void 0 && K.writeVarintField(1, ne.id), K.writeMessage(2, J, Ue), K.writeVarintField(3, ne.type), K.writeMessage(4, pe, ne);
        }
        function J(Ue, K) {
          for (const ne in Ue.feature?.properties) {
            let de = Ue.feature.properties[ne], Te = Ue.keycache[ne];
            if (de === null) continue;
            Te === void 0 && (Ue.keys.push(ne), Te = Ue.keys.length - 1, Ue.keycache[ne] = Te), K.writeVarint(Te), typeof de != "string" && typeof de != "boolean" && typeof de != "number" && (de = JSON.stringify(de));
            const Pe = typeof de + ":" + de;
            let qe = Ue.valuecache[Pe];
            qe === void 0 && (Ue.values.push(de), qe = Ue.values.length - 1, Ue.valuecache[Pe] = qe), K.writeVarint(qe);
          }
        }
        function re(Ue, K) {
          return (K << 3) + (7 & Ue);
        }
        function be(Ue) {
          return Ue << 1 ^ Ue >> 31;
        }
        function pe(Ue, K) {
          const ne = Ue.loadGeometry(), de = Ue.type;
          let Te = 0, Pe = 0;
          for (const qe of ne) {
            let Je = 1;
            de === 1 && (Je = qe.length), K.writeVarint(re(1, Je));
            const He = de === 3 ? qe.length - 1 : qe.length;
            for (let nt = 0; nt < He; nt++) {
              nt === 1 && de !== 1 && K.writeVarint(re(2, He - 1));
              const Bt = qe[nt].x - Te, It = qe[nt].y - Pe;
              K.writeVarint(be(Bt)), K.writeVarint(be(It)), Te += Bt, Pe += It;
            }
            Ue.type === 3 && K.writeVarint(re(7, 1));
          }
        }
        function oe(Ue, K) {
          const ne = typeof Ue;
          ne === "string" ? K.writeStringField(1, Ue) : ne === "boolean" ? K.writeBooleanField(7, Ue) : ne === "number" && (Ue % 1 != 0 ? K.writeDoubleField(3, Ue) : Ue < 0 ? K.writeSVarintField(6, Ue) : K.writeVarintField(5, Ue));
        }
        const Ee = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (Ue) => Ue }, le = Math.fround || (_e = new Float32Array(1), (Ue) => (_e[0] = +Ue, _e[0]));
        var _e;
        class Ve {
          constructor(K) {
            this.options = Object.assign(Object.create(Ee), K), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(K) {
            const { log: ne, minZoom: de, maxZoom: Te } = this.options;
            ne && console.time("total time");
            const Pe = `prepare ${K.length} points`;
            ne && console.time(Pe), this.points = K;
            const qe = [];
            for (let He = 0; He < K.length; He++) {
              const nt = K[He];
              if (!nt.geometry) continue;
              const [Bt, It] = nt.geometry.coordinates, rr = le(St(Bt)), We = le(Mt(It));
              qe.push(rr, We, 1 / 0, He, -1, 1), this.options.reduce && qe.push(0);
            }
            let Je = this.trees[Te + 1] = this._createTree(qe);
            ne && console.timeEnd(Pe);
            for (let He = Te; He >= de; He--) {
              const nt = +Date.now();
              Je = this.trees[He] = this._createTree(this._cluster(Je, He)), ne && console.log("z%d: %d clusters in %dms", He, Je.numItems, +Date.now() - nt);
            }
            return ne && console.timeEnd("total time"), this;
          }
          getClusters(K, ne) {
            let de = ((K[0] + 180) % 360 + 360) % 360 - 180;
            const Te = Math.max(-90, Math.min(90, K[1]));
            let Pe = K[2] === 180 ? 180 : ((K[2] + 180) % 360 + 360) % 360 - 180;
            const qe = Math.max(-90, Math.min(90, K[3]));
            if (K[2] - K[0] >= 360) de = -180, Pe = 180;
            else if (de > Pe) {
              const It = this.getClusters([de, Te, 180, qe], ne), rr = this.getClusters([-180, Te, Pe, qe], ne);
              return It.concat(rr);
            }
            const Je = this.trees[this._limitZoom(ne)], He = Je.range(St(de), Mt(qe), St(Pe), Mt(Te)), nt = Je.data, Bt = [];
            for (const It of He) {
              const rr = this.stride * It;
              Bt.push(nt[rr + 5] > 1 ? Be(nt, rr, this.clusterProps) : this.points[nt[rr + 3]]);
            }
            return Bt;
          }
          getChildren(K) {
            const ne = this._getOriginId(K), de = this._getOriginZoom(K), Te = "No cluster with the specified id.", Pe = this.trees[de];
            if (!Pe) throw new Error(Te);
            const qe = Pe.data;
            if (ne * this.stride >= qe.length) throw new Error(Te);
            const Je = this.options.radius / (this.options.extent * Math.pow(2, de - 1)), He = Pe.within(qe[ne * this.stride], qe[ne * this.stride + 1], Je), nt = [];
            for (const Bt of He) {
              const It = Bt * this.stride;
              qe[It + 4] === K && nt.push(qe[It + 5] > 1 ? Be(qe, It, this.clusterProps) : this.points[qe[It + 3]]);
            }
            if (nt.length === 0) throw new Error(Te);
            return nt;
          }
          getLeaves(K, ne, de) {
            const Te = [];
            return this._appendLeaves(Te, K, ne = ne || 10, de = de || 0, 0), Te;
          }
          getTile(K, ne, de) {
            const Te = this.trees[this._limitZoom(K)], Pe = Math.pow(2, K), { extent: qe, radius: Je } = this.options, He = Je / qe, nt = (de - He) / Pe, Bt = (de + 1 + He) / Pe, It = { features: [] };
            return this._addTileFeatures(Te.range((ne - He) / Pe, nt, (ne + 1 + He) / Pe, Bt), Te.data, ne, de, Pe, It), ne === 0 && this._addTileFeatures(Te.range(1 - He / Pe, nt, 1, Bt), Te.data, Pe, de, Pe, It), ne === Pe - 1 && this._addTileFeatures(Te.range(0, nt, He / Pe, Bt), Te.data, -1, de, Pe, It), It.features.length ? It : null;
          }
          getClusterExpansionZoom(K) {
            let ne = this._getOriginZoom(K) - 1;
            for (; ne <= this.options.maxZoom; ) {
              const de = this.getChildren(K);
              if (ne++, de.length !== 1) break;
              K = de[0].properties.cluster_id;
            }
            return ne;
          }
          _appendLeaves(K, ne, de, Te, Pe) {
            const qe = this.getChildren(ne);
            for (const Je of qe) {
              const He = Je.properties;
              if (He && He.cluster ? Pe + He.point_count <= Te ? Pe += He.point_count : Pe = this._appendLeaves(K, He.cluster_id, de, Te, Pe) : Pe < Te ? Pe++ : K.push(Je), K.length === de) break;
            }
            return Pe;
          }
          _createTree(K) {
            const ne = new c.aI(K.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let de = 0; de < K.length; de += this.stride) ne.add(K[de], K[de + 1]);
            return ne.finish(), ne.data = K, ne;
          }
          _addTileFeatures(K, ne, de, Te, Pe, qe) {
            for (const Je of K) {
              const He = Je * this.stride, nt = ne[He + 5] > 1;
              let Bt, It, rr;
              if (nt) Bt = gt(ne, He, this.clusterProps), It = ne[He], rr = ne[He + 1];
              else {
                const Li = this.points[ne[He + 3]];
                Bt = Li.properties;
                const [fr, Hr] = Li.geometry.coordinates;
                It = St(fr), rr = Mt(Hr);
              }
              const We = { type: 1, geometry: [[Math.round(this.options.extent * (It * Pe - de)), Math.round(this.options.extent * (rr * Pe - Te))]], tags: Bt };
              let mr;
              mr = nt || this.options.generateId ? ne[He + 3] : this.points[ne[He + 3]].id, mr !== void 0 && (We.id = mr), qe.features.push(We);
            }
          }
          _limitZoom(K) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+K), this.options.maxZoom + 1));
          }
          _cluster(K, ne) {
            const { radius: de, extent: Te, reduce: Pe, minPoints: qe } = this.options, Je = de / (Te * Math.pow(2, ne)), He = K.data, nt = [], Bt = this.stride;
            for (let It = 0; It < He.length; It += Bt) {
              if (He[It + 2] <= ne) continue;
              He[It + 2] = ne;
              const rr = He[It], We = He[It + 1], mr = K.within(He[It], He[It + 1], Je), Li = He[It + 5];
              let fr = Li;
              for (const Hr of mr) {
                const li = Hr * Bt;
                He[li + 2] > ne && (fr += He[li + 5]);
              }
              if (fr > Li && fr >= qe) {
                let Hr, li = rr * Li, _r = We * Li, qi = -1;
                const nn = (It / Bt << 5) + (ne + 1) + this.points.length;
                for (const Ei of mr) {
                  const vi = Ei * Bt;
                  if (He[vi + 2] <= ne) continue;
                  He[vi + 2] = ne;
                  const ci = He[vi + 5];
                  li += He[vi] * ci, _r += He[vi + 1] * ci, He[vi + 4] = nn, Pe && (Hr || (Hr = this._map(He, It, !0), qi = this.clusterProps.length, this.clusterProps.push(Hr)), Pe(Hr, this._map(He, vi)));
                }
                He[It + 4] = nn, nt.push(li / fr, _r / fr, 1 / 0, nn, -1, fr), Pe && nt.push(qi);
              } else {
                for (let Hr = 0; Hr < Bt; Hr++) nt.push(He[It + Hr]);
                if (fr > 1) for (const Hr of mr) {
                  const li = Hr * Bt;
                  if (!(He[li + 2] <= ne)) {
                    He[li + 2] = ne;
                    for (let _r = 0; _r < Bt; _r++) nt.push(He[li + _r]);
                  }
                }
              }
            }
            return nt;
          }
          _getOriginId(K) {
            return K - this.points.length >> 5;
          }
          _getOriginZoom(K) {
            return (K - this.points.length) % 32;
          }
          _map(K, ne, de) {
            if (K[ne + 5] > 1) {
              const qe = this.clusterProps[K[ne + 6]];
              return de ? Object.assign({}, qe) : qe;
            }
            const Te = this.points[K[ne + 3]].properties, Pe = this.options.map(Te);
            return de && Pe === Te ? Object.assign({}, Pe) : Pe;
          }
        }
        function Be(Ue, K, ne) {
          return { type: "Feature", id: Ue[K + 3], properties: gt(Ue, K, ne), geometry: { type: "Point", coordinates: [(de = Ue[K], 360 * (de - 0.5)), mt(Ue[K + 1])] } };
          var de;
        }
        function gt(Ue, K, ne) {
          const de = Ue[K + 5], Te = de >= 1e4 ? `${Math.round(de / 1e3)}k` : de >= 1e3 ? Math.round(de / 100) / 10 + "k" : de, Pe = Ue[K + 6], qe = Pe === -1 ? {} : Object.assign({}, ne[Pe]);
          return Object.assign(qe, { cluster: !0, cluster_id: Ue[K + 3], point_count: de, point_count_abbreviated: Te });
        }
        function St(Ue) {
          return Ue / 360 + 0.5;
        }
        function Mt(Ue) {
          const K = Math.sin(Ue * Math.PI / 180), ne = 0.5 - 0.25 * Math.log((1 + K) / (1 - K)) / Math.PI;
          return ne < 0 ? 0 : ne > 1 ? 1 : ne;
        }
        function mt(Ue) {
          const K = (180 - 360 * Ue) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(K)) / Math.PI - 90;
        }
        function wt(Ue, K, ne, de) {
          let Te = de;
          const Pe = K + (ne - K >> 1);
          let qe, Je = ne - K;
          const He = Ue[K], nt = Ue[K + 1], Bt = Ue[ne], It = Ue[ne + 1];
          for (let rr = K + 3; rr < ne; rr += 3) {
            const We = Yt(Ue[rr], Ue[rr + 1], He, nt, Bt, It);
            if (We > Te) qe = rr, Te = We;
            else if (We === Te) {
              const mr = Math.abs(rr - Pe);
              mr < Je && (qe = rr, Je = mr);
            }
          }
          Te > de && (qe - K > 3 && wt(Ue, K, qe, de), Ue[qe + 2] = Te, ne - qe > 3 && wt(Ue, qe, ne, de));
        }
        function Yt(Ue, K, ne, de, Te, Pe) {
          let qe = Te - ne, Je = Pe - de;
          if (qe !== 0 || Je !== 0) {
            const He = ((Ue - ne) * qe + (K - de) * Je) / (qe * qe + Je * Je);
            He > 1 ? (ne = Te, de = Pe) : He > 0 && (ne += qe * He, de += Je * He);
          }
          return qe = Ue - ne, Je = K - de, qe * qe + Je * Je;
        }
        function Dt(Ue, K, ne, de) {
          const Te = { id: Ue ?? null, type: K, geometry: ne, tags: de, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (K === "Point" || K === "MultiPoint" || K === "LineString") fe(Te, ne);
          else if (K === "Polygon") fe(Te, ne[0]);
          else if (K === "MultiLineString") for (const Pe of ne) fe(Te, Pe);
          else if (K === "MultiPolygon") for (const Pe of ne) fe(Te, Pe[0]);
          return Te;
        }
        function fe(Ue, K) {
          for (let ne = 0; ne < K.length; ne += 3) Ue.minX = Math.min(Ue.minX, K[ne]), Ue.minY = Math.min(Ue.minY, K[ne + 1]), Ue.maxX = Math.max(Ue.maxX, K[ne]), Ue.maxY = Math.max(Ue.maxY, K[ne + 1]);
        }
        function De(Ue, K, ne, de) {
          if (!K.geometry) return;
          const Te = K.geometry.coordinates;
          if (Te && Te.length === 0) return;
          const Pe = K.geometry.type, qe = Math.pow(ne.tolerance / ((1 << ne.maxZoom) * ne.extent), 2);
          let Je = [], He = K.id;
          if (ne.promoteId ? He = K.properties[ne.promoteId] : ne.generateId && (He = de || 0), Pe === "Point") je(Te, Je);
          else if (Pe === "MultiPoint") for (const nt of Te) je(nt, Je);
          else if (Pe === "LineString") Ke(Te, Je, qe, !1);
          else if (Pe === "MultiLineString") {
            if (ne.lineMetrics) {
              for (const nt of Te) Je = [], Ke(nt, Je, qe, !1), Ue.push(Dt(He, "LineString", Je, K.properties));
              return;
            }
            rt(Te, Je, qe, !1);
          } else if (Pe === "Polygon") rt(Te, Je, qe, !0);
          else {
            if (Pe !== "MultiPolygon") {
              if (Pe === "GeometryCollection") {
                for (const nt of K.geometry.geometries) De(Ue, { id: He, geometry: nt, properties: K.properties }, ne, de);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const nt of Te) {
              const Bt = [];
              rt(nt, Bt, qe, !0), Je.push(Bt);
            }
          }
          Ue.push(Dt(He, Pe, Je, K.properties));
        }
        function je(Ue, K) {
          K.push(at(Ue[0]), Et(Ue[1]), 0);
        }
        function Ke(Ue, K, ne, de) {
          let Te, Pe, qe = 0;
          for (let He = 0; He < Ue.length; He++) {
            const nt = at(Ue[He][0]), Bt = Et(Ue[He][1]);
            K.push(nt, Bt, 0), He > 0 && (qe += de ? (Te * Bt - nt * Pe) / 2 : Math.sqrt(Math.pow(nt - Te, 2) + Math.pow(Bt - Pe, 2))), Te = nt, Pe = Bt;
          }
          const Je = K.length - 3;
          K[2] = 1, wt(K, 0, Je, ne), K[Je + 2] = 1, K.size = Math.abs(qe), K.start = 0, K.end = K.size;
        }
        function rt(Ue, K, ne, de) {
          for (let Te = 0; Te < Ue.length; Te++) {
            const Pe = [];
            Ke(Ue[Te], Pe, ne, de), K.push(Pe);
          }
        }
        function at(Ue) {
          return Ue / 360 + 0.5;
        }
        function Et(Ue) {
          const K = Math.sin(Ue * Math.PI / 180), ne = 0.5 - 0.25 * Math.log((1 + K) / (1 - K)) / Math.PI;
          return ne < 0 ? 0 : ne > 1 ? 1 : ne;
        }
        function Tt(Ue, K, ne, de, Te, Pe, qe, Je) {
          if (de /= K, Pe >= (ne /= K) && qe < de) return Ue;
          if (qe < ne || Pe >= de) return null;
          const He = [];
          for (const nt of Ue) {
            const Bt = nt.geometry;
            let It = nt.type;
            const rr = Te === 0 ? nt.minX : nt.minY, We = Te === 0 ? nt.maxX : nt.maxY;
            if (rr >= ne && We < de) {
              He.push(nt);
              continue;
            }
            if (We < ne || rr >= de) continue;
            let mr = [];
            if (It === "Point" || It === "MultiPoint") Vt(Bt, mr, ne, de, Te);
            else if (It === "LineString") tr(Bt, mr, ne, de, Te, !1, Je.lineMetrics);
            else if (It === "MultiLineString") dr(Bt, mr, ne, de, Te, !1);
            else if (It === "Polygon") dr(Bt, mr, ne, de, Te, !0);
            else if (It === "MultiPolygon") for (const Li of Bt) {
              const fr = [];
              dr(Li, fr, ne, de, Te, !0), fr.length && mr.push(fr);
            }
            if (mr.length) {
              if (Je.lineMetrics && It === "LineString") {
                for (const Li of mr) He.push(Dt(nt.id, It, Li, nt.tags));
                continue;
              }
              It !== "LineString" && It !== "MultiLineString" || (mr.length === 1 ? (It = "LineString", mr = mr[0]) : It = "MultiLineString"), It !== "Point" && It !== "MultiPoint" || (It = mr.length === 3 ? "Point" : "MultiPoint"), He.push(Dt(nt.id, It, mr, nt.tags));
            }
          }
          return He.length ? He : null;
        }
        function Vt(Ue, K, ne, de, Te) {
          for (let Pe = 0; Pe < Ue.length; Pe += 3) {
            const qe = Ue[Pe + Te];
            qe >= ne && qe <= de && Ct(K, Ue[Pe], Ue[Pe + 1], Ue[Pe + 2]);
          }
        }
        function tr(Ue, K, ne, de, Te, Pe, qe) {
          let Je = ur(Ue);
          const He = Te === 0 ? Oe : ii;
          let nt, Bt, It = Ue.start;
          for (let fr = 0; fr < Ue.length - 3; fr += 3) {
            const Hr = Ue[fr], li = Ue[fr + 1], _r = Ue[fr + 2], qi = Ue[fr + 3], nn = Ue[fr + 4], Ei = Te === 0 ? Hr : li, vi = Te === 0 ? qi : nn;
            let ci = !1;
            qe && (nt = Math.sqrt(Math.pow(Hr - qi, 2) + Math.pow(li - nn, 2))), Ei < ne ? vi > ne && (Bt = He(Je, Hr, li, qi, nn, ne), qe && (Je.start = It + nt * Bt)) : Ei > de ? vi < de && (Bt = He(Je, Hr, li, qi, nn, de), qe && (Je.start = It + nt * Bt)) : Ct(Je, Hr, li, _r), vi < ne && Ei >= ne && (Bt = He(Je, Hr, li, qi, nn, ne), ci = !0), vi > de && Ei <= de && (Bt = He(Je, Hr, li, qi, nn, de), ci = !0), !Pe && ci && (qe && (Je.end = It + nt * Bt), K.push(Je), Je = ur(Ue)), qe && (It += nt);
          }
          let rr = Ue.length - 3;
          const We = Ue[rr], mr = Ue[rr + 1], Li = Te === 0 ? We : mr;
          Li >= ne && Li <= de && Ct(Je, We, mr, Ue[rr + 2]), rr = Je.length - 3, Pe && rr >= 3 && (Je[rr] !== Je[0] || Je[rr + 1] !== Je[1]) && Ct(Je, Je[0], Je[1], Je[2]), Je.length && K.push(Je);
        }
        function ur(Ue) {
          const K = [];
          return K.size = Ue.size, K.start = Ue.start, K.end = Ue.end, K;
        }
        function dr(Ue, K, ne, de, Te, Pe) {
          for (const qe of Ue) tr(qe, K, ne, de, Te, Pe, !1);
        }
        function Ct(Ue, K, ne, de) {
          Ue.push(K, ne, de);
        }
        function Oe(Ue, K, ne, de, Te, Pe) {
          const qe = (Pe - K) / (de - K);
          return Ct(Ue, Pe, ne + (Te - ne) * qe, 1), qe;
        }
        function ii(Ue, K, ne, de, Te, Pe) {
          const qe = (Pe - ne) / (Te - ne);
          return Ct(Ue, K + (de - K) * qe, Pe, 1), qe;
        }
        function Zr(Ue, K) {
          const ne = [];
          for (let de = 0; de < Ue.length; de++) {
            const Te = Ue[de], Pe = Te.type;
            let qe;
            if (Pe === "Point" || Pe === "MultiPoint" || Pe === "LineString") qe = Rr(Te.geometry, K);
            else if (Pe === "MultiLineString" || Pe === "Polygon") {
              qe = [];
              for (const Je of Te.geometry) qe.push(Rr(Je, K));
            } else if (Pe === "MultiPolygon") {
              qe = [];
              for (const Je of Te.geometry) {
                const He = [];
                for (const nt of Je) He.push(Rr(nt, K));
                qe.push(He);
              }
            }
            ne.push(Dt(Te.id, Pe, qe, Te.tags));
          }
          return ne;
        }
        function Rr(Ue, K) {
          const ne = [];
          ne.size = Ue.size, Ue.start !== void 0 && (ne.start = Ue.start, ne.end = Ue.end);
          for (let de = 0; de < Ue.length; de += 3) ne.push(Ue[de] + K, Ue[de + 1], Ue[de + 2]);
          return ne;
        }
        function Jt(Ue, K) {
          if (Ue.transformed) return Ue;
          const ne = 1 << Ue.z, de = Ue.x, Te = Ue.y;
          for (const Pe of Ue.features) {
            const qe = Pe.geometry, Je = Pe.type;
            if (Pe.geometry = [], Je === 1) for (let He = 0; He < qe.length; He += 2) Pe.geometry.push(Sr(qe[He], qe[He + 1], K, ne, de, Te));
            else for (let He = 0; He < qe.length; He++) {
              const nt = [];
              for (let Bt = 0; Bt < qe[He].length; Bt += 2) nt.push(Sr(qe[He][Bt], qe[He][Bt + 1], K, ne, de, Te));
              Pe.geometry.push(nt);
            }
          }
          return Ue.transformed = !0, Ue;
        }
        function Sr(Ue, K, ne, de, Te, Pe) {
          return [Math.round(ne * (Ue * de - Te)), Math.round(ne * (K * de - Pe))];
        }
        function hr(Ue, K, ne, de, Te) {
          const Pe = K === Te.maxZoom ? 0 : Te.tolerance / ((1 << K) * Te.extent), qe = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Ue.length, source: null, x: ne, y: de, z: K, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const Je of Ue) qr(qe, Je, Pe, Te);
          return qe;
        }
        function qr(Ue, K, ne, de) {
          const Te = K.geometry, Pe = K.type, qe = [];
          if (Ue.minX = Math.min(Ue.minX, K.minX), Ue.minY = Math.min(Ue.minY, K.minY), Ue.maxX = Math.max(Ue.maxX, K.maxX), Ue.maxY = Math.max(Ue.maxY, K.maxY), Pe === "Point" || Pe === "MultiPoint") for (let Je = 0; Je < Te.length; Je += 3) qe.push(Te[Je], Te[Je + 1]), Ue.numPoints++, Ue.numSimplified++;
          else if (Pe === "LineString") xr(qe, Te, Ue, ne, !1, !1);
          else if (Pe === "MultiLineString" || Pe === "Polygon") for (let Je = 0; Je < Te.length; Je++) xr(qe, Te[Je], Ue, ne, Pe === "Polygon", Je === 0);
          else if (Pe === "MultiPolygon") for (let Je = 0; Je < Te.length; Je++) {
            const He = Te[Je];
            for (let nt = 0; nt < He.length; nt++) xr(qe, He[nt], Ue, ne, !0, nt === 0);
          }
          if (qe.length) {
            let Je = K.tags || null;
            if (Pe === "LineString" && de.lineMetrics) {
              Je = {};
              for (const nt in K.tags) Je[nt] = K.tags[nt];
              Je.mapbox_clip_start = Te.start / Te.size, Je.mapbox_clip_end = Te.end / Te.size;
            }
            const He = { geometry: qe, type: Pe === "Polygon" || Pe === "MultiPolygon" ? 3 : Pe === "LineString" || Pe === "MultiLineString" ? 2 : 1, tags: Je };
            K.id !== null && (He.id = K.id), Ue.features.push(He);
          }
        }
        function xr(Ue, K, ne, de, Te, Pe) {
          const qe = de * de;
          if (de > 0 && K.size < (Te ? qe : de)) return void (ne.numPoints += K.length / 3);
          const Je = [];
          for (let He = 0; He < K.length; He += 3) (de === 0 || K[He + 2] > qe) && (ne.numSimplified++, Je.push(K[He], K[He + 1])), ne.numPoints++;
          Te && function(He, nt) {
            let Bt = 0;
            for (let It = 0, rr = He.length, We = rr - 2; It < rr; We = It, It += 2) Bt += (He[It] - He[We]) * (He[It + 1] + He[We + 1]);
            if (Bt > 0 === nt) for (let It = 0, rr = He.length; It < rr / 2; It += 2) {
              const We = He[It], mr = He[It + 1];
              He[It] = He[rr - 2 - It], He[It + 1] = He[rr - 1 - It], He[rr - 2 - It] = We, He[rr - 1 - It] = mr;
            }
          }(Je, Pe), Ue.push(Je);
        }
        const bi = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class Yr {
          constructor(K, ne) {
            const de = (ne = this.options = function(Pe, qe) {
              for (const Je in qe) Pe[Je] = qe[Je];
              return Pe;
            }(Object.create(bi), ne)).debug;
            if (de && console.time("preprocess data"), ne.maxZoom < 0 || ne.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (ne.promoteId && ne.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let Te = function(Pe, qe) {
              const Je = [];
              if (Pe.type === "FeatureCollection") for (let He = 0; He < Pe.features.length; He++) De(Je, Pe.features[He], qe, He);
              else De(Je, Pe.type === "Feature" ? Pe : { geometry: Pe }, qe);
              return Je;
            }(K, ne);
            this.tiles = {}, this.tileCoords = [], de && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", ne.indexMaxZoom, ne.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Te = function(Pe, qe) {
              const Je = qe.buffer / qe.extent;
              let He = Pe;
              const nt = Tt(Pe, 1, -1 - Je, Je, 0, -1, 2, qe), Bt = Tt(Pe, 1, 1 - Je, 2 + Je, 0, -1, 2, qe);
              return (nt || Bt) && (He = Tt(Pe, 1, -Je, 1 + Je, 0, -1, 2, qe) || [], nt && (He = Zr(nt, 1).concat(He)), Bt && (He = He.concat(Zr(Bt, -1)))), He;
            }(Te, ne), Te.length && this.splitTile(Te, 0, 0, 0), de && (Te.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(K, ne, de, Te, Pe, qe, Je) {
            const He = [K, ne, de, Te], nt = this.options, Bt = nt.debug;
            for (; He.length; ) {
              Te = He.pop(), de = He.pop(), ne = He.pop(), K = He.pop();
              const It = 1 << ne, rr = Fr(ne, de, Te);
              let We = this.tiles[rr];
              if (!We && (Bt > 1 && console.time("creation"), We = this.tiles[rr] = hr(K, ne, de, Te, nt), this.tileCoords.push({ z: ne, x: de, y: Te }), Bt)) {
                Bt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", ne, de, Te, We.numFeatures, We.numPoints, We.numSimplified), console.timeEnd("creation"));
                const ci = `z${ne}`;
                this.stats[ci] = (this.stats[ci] || 0) + 1, this.total++;
              }
              if (We.source = K, Pe == null) {
                if (ne === nt.indexMaxZoom || We.numPoints <= nt.indexMaxPoints) continue;
              } else {
                if (ne === nt.maxZoom || ne === Pe) continue;
                if (Pe != null) {
                  const ci = Pe - ne;
                  if (de !== qe >> ci || Te !== Je >> ci) continue;
                }
              }
              if (We.source = null, K.length === 0) continue;
              Bt > 1 && console.time("clipping");
              const mr = 0.5 * nt.buffer / nt.extent, Li = 0.5 - mr, fr = 0.5 + mr, Hr = 1 + mr;
              let li = null, _r = null, qi = null, nn = null, Ei = Tt(K, It, de - mr, de + fr, 0, We.minX, We.maxX, nt), vi = Tt(K, It, de + Li, de + Hr, 0, We.minX, We.maxX, nt);
              K = null, Ei && (li = Tt(Ei, It, Te - mr, Te + fr, 1, We.minY, We.maxY, nt), _r = Tt(Ei, It, Te + Li, Te + Hr, 1, We.minY, We.maxY, nt), Ei = null), vi && (qi = Tt(vi, It, Te - mr, Te + fr, 1, We.minY, We.maxY, nt), nn = Tt(vi, It, Te + Li, Te + Hr, 1, We.minY, We.maxY, nt), vi = null), Bt > 1 && console.timeEnd("clipping"), He.push(li || [], ne + 1, 2 * de, 2 * Te), He.push(_r || [], ne + 1, 2 * de, 2 * Te + 1), He.push(qi || [], ne + 1, 2 * de + 1, 2 * Te), He.push(nn || [], ne + 1, 2 * de + 1, 2 * Te + 1);
            }
          }
          getTile(K, ne, de) {
            K = +K, ne = +ne, de = +de;
            const Te = this.options, { extent: Pe, debug: qe } = Te;
            if (K < 0 || K > 24) return null;
            const Je = 1 << K, He = Fr(K, ne = ne + Je & Je - 1, de);
            if (this.tiles[He]) return Jt(this.tiles[He], Pe);
            qe > 1 && console.log("drilling down to z%d-%d-%d", K, ne, de);
            let nt, Bt = K, It = ne, rr = de;
            for (; !nt && Bt > 0; ) Bt--, It >>= 1, rr >>= 1, nt = this.tiles[Fr(Bt, It, rr)];
            return nt && nt.source ? (qe > 1 && (console.log("found parent tile z%d-%d-%d", Bt, It, rr), console.time("drilling down")), this.splitTile(nt.source, Bt, It, rr, K, ne, de), qe > 1 && console.timeEnd("drilling down"), this.tiles[He] ? Jt(this.tiles[He], Pe) : null) : null;
          }
        }
        function Fr(Ue, K, ne) {
          return 32 * ((1 << Ue) * ne + K) + Ue;
        }
        class Ri extends T {
          constructor(K, ne, de, Te = Kr) {
            super(K, ne, de), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = Te;
          }
          loadVectorTile(K, ne) {
            return c._(this, void 0, void 0, function* () {
              const de = K.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const Te = this._geoJSONIndex.getTile(de.z, de.x, de.y);
              if (!Te) return null;
              const Pe = new te(Te.features, { version: 2, extent: c.$ });
              let qe = function(Je) {
                const He = new c.cM();
                return function(nt, Bt) {
                  for (const It in nt.layers) Bt.writeMessage(3, Z, nt.layers[It]);
                }(Je, He), He.finish();
              }(Pe);
              return qe.byteOffset === 0 && qe.byteLength === qe.buffer.byteLength || (qe = new Uint8Array(qe)), { vectorTile: Pe, rawData: qe.buffer };
            });
          }
          loadData(K) {
            return c._(this, void 0, void 0, function* () {
              var ne;
              (ne = this._pendingRequest) === null || ne === void 0 || ne.abort();
              const de = !!(K && K.request && K.request.collectResourceTiming) && new c.cN(K.request);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || K.request || K.data || K.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(K, this._pendingRequest));
                const Te = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(Te, K), this.loaded = {};
                const Pe = { data: Te };
                if (de) {
                  const qe = de.finish();
                  qe && (Pe.resourceTiming = {}, Pe.resourceTiming[K.source] = JSON.parse(JSON.stringify(qe)));
                }
                return Pe;
              } catch (Te) {
                if (delete this._pendingRequest, c.cy(Te)) return { abandoned: !0 };
                throw Te;
              }
            });
          }
          getData() {
            return c._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(K) {
            const ne = this.loaded;
            return ne && ne[K.uid] ? super.reloadTile(K) : this.loadTile(K);
          }
          loadAndProcessGeoJSON(K, ne) {
            return c._(this, void 0, void 0, function* () {
              let de = yield this.loadGeoJSON(K, ne);
              if (delete this._pendingRequest, typeof de != "object") throw new Error(`Input data given to '${K.source}' is not a valid GeoJSON object.`);
              if ($(de, !0), K.filter) {
                const Te = c.cT(K.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                if (Te.result === "error") throw new Error(Te.value.map((qe) => `${qe.key}: ${qe.message}`).join(", "));
                de = { type: "FeatureCollection", features: de.features.filter((qe) => Te.value.evaluate({ zoom: 0 }, qe)) };
              }
              return de;
            });
          }
          loadGeoJSON(K, ne) {
            return c._(this, void 0, void 0, function* () {
              const { promoteId: de } = K;
              if (K.request) {
                const Te = yield c.j(K.request, ne);
                return this._dataUpdateable = c.cV(Te.data, de) ? c.cU(Te.data, de) : void 0, Te.data;
              }
              if (typeof K.data == "string") try {
                const Te = JSON.parse(K.data);
                return this._dataUpdateable = c.cV(Te, de) ? c.cU(Te, de) : void 0, Te;
              } catch {
                throw new Error(`Input data given to '${K.source}' is not a valid GeoJSON object.`);
              }
              if (!K.dataDiff) throw new Error(`Input data given to '${K.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${K.source}`);
              return c.cW(this._dataUpdateable, K.dataDiff, de), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(K) {
            return c._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(K) {
            return this._geoJSONIndex.getClusterExpansionZoom(K.clusterId);
          }
          getClusterChildren(K) {
            return this._geoJSONIndex.getChildren(K.clusterId);
          }
          getClusterLeaves(K) {
            return this._geoJSONIndex.getLeaves(K.clusterId, K.limit, K.offset);
          }
        }
        function Kr(Ue, K) {
          return K.cluster ? new Ve(function({ superclusterOptions: ne, clusterProperties: de }) {
            if (!de || !ne) return ne;
            const Te = {}, Pe = {}, qe = { accumulated: null, zoom: 0 }, Je = { properties: null }, He = Object.keys(de);
            for (const nt of He) {
              const [Bt, It] = de[nt], rr = c.cT(It), We = c.cT(typeof Bt == "string" ? [Bt, ["accumulated"], ["get", nt]] : Bt);
              Te[nt] = rr.value, Pe[nt] = We.value;
            }
            return ne.map = (nt) => {
              Je.properties = nt;
              const Bt = {};
              for (const It of He) Bt[It] = Te[It].evaluate(qe, Je);
              return Bt;
            }, ne.reduce = (nt, Bt) => {
              Je.properties = Bt;
              for (const It of He) qe.accumulated = nt[It], nt[It] = Pe[It].evaluate(qe, Je);
            }, ne;
          }(K)).load(Ue.features) : function(ne, de) {
            return new Yr(ne, de);
          }(Ue, K.geojsonVtOptions);
        }
        class wr {
          constructor(K) {
            this.self = K, this.actor = new c.J(K), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (ne, de) => {
              if (this.externalWorkerSourceTypes[ne]) throw new Error(`Worker source with name "${ne}" already registered.`);
              this.externalWorkerSourceTypes[ne] = de;
            }, this.self.addProtocol = c.cA, this.self.removeProtocol = c.cB, this.self.registerRTLTextPlugin = (ne) => {
              c.cX.setMethods(ne);
            }, this.actor.registerMessageHandler("LDT", (ne, de) => this._getDEMWorkerSource(ne, de.source).loadTile(de)), this.actor.registerMessageHandler("RDT", (ne, de) => c._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(ne, de.source).removeTile(de);
            })), this.actor.registerMessageHandler("GCEZ", (ne, de) => c._(this, void 0, void 0, function* () {
              return this._getWorkerSource(ne, de.type, de.source).getClusterExpansionZoom(de);
            })), this.actor.registerMessageHandler("GCC", (ne, de) => c._(this, void 0, void 0, function* () {
              return this._getWorkerSource(ne, de.type, de.source).getClusterChildren(de);
            })), this.actor.registerMessageHandler("GCL", (ne, de) => c._(this, void 0, void 0, function* () {
              return this._getWorkerSource(ne, de.type, de.source).getClusterLeaves(de);
            })), this.actor.registerMessageHandler("LD", (ne, de) => this._getWorkerSource(ne, de.type, de.source).loadData(de)), this.actor.registerMessageHandler("GD", (ne, de) => this._getWorkerSource(ne, de.type, de.source).getData()), this.actor.registerMessageHandler("LT", (ne, de) => this._getWorkerSource(ne, de.type, de.source).loadTile(de)), this.actor.registerMessageHandler("RT", (ne, de) => this._getWorkerSource(ne, de.type, de.source).reloadTile(de)), this.actor.registerMessageHandler("AT", (ne, de) => this._getWorkerSource(ne, de.type, de.source).abortTile(de)), this.actor.registerMessageHandler("RMT", (ne, de) => this._getWorkerSource(ne, de.type, de.source).removeTile(de)), this.actor.registerMessageHandler("RS", (ne, de) => c._(this, void 0, void 0, function* () {
              if (!this.workerSources[ne] || !this.workerSources[ne][de.type] || !this.workerSources[ne][de.type][de.source]) return;
              const Te = this.workerSources[ne][de.type][de.source];
              delete this.workerSources[ne][de.type][de.source], Te.removeSource !== void 0 && Te.removeSource(de);
            })), this.actor.registerMessageHandler("RM", (ne) => c._(this, void 0, void 0, function* () {
              delete this.layerIndexes[ne], delete this.availableImages[ne], delete this.workerSources[ne], delete this.demWorkerSources[ne], this.globalStates.delete(ne);
            })), this.actor.registerMessageHandler("SR", (ne, de) => c._(this, void 0, void 0, function* () {
              this.referrer = de;
            })), this.actor.registerMessageHandler("SRPS", (ne, de) => this._syncRTLPluginState(ne, de)), this.actor.registerMessageHandler("IS", (ne, de) => c._(this, void 0, void 0, function* () {
              this.self.importScripts(de);
            })), this.actor.registerMessageHandler("SI", (ne, de) => this._setImages(ne, de)), this.actor.registerMessageHandler("UL", (ne, de) => c._(this, void 0, void 0, function* () {
              this._getLayerIndex(ne).update(de.layers, de.removedIds, this._getGlobalState(ne));
            })), this.actor.registerMessageHandler("UGS", (ne, de) => c._(this, void 0, void 0, function* () {
              const Te = this._getGlobalState(ne);
              for (const Pe in de) Te[Pe] = de[Pe];
            })), this.actor.registerMessageHandler("SL", (ne, de) => c._(this, void 0, void 0, function* () {
              this._getLayerIndex(ne).replace(de, this._getGlobalState(ne));
            }));
          }
          _getGlobalState(K) {
            let ne = this.globalStates.get(K);
            return ne || (ne = {}, this.globalStates.set(K, ne)), ne;
          }
          _setImages(K, ne) {
            return c._(this, void 0, void 0, function* () {
              this.availableImages[K] = ne;
              for (const de in this.workerSources[K]) {
                const Te = this.workerSources[K][de];
                for (const Pe in Te) Te[Pe].availableImages = ne;
              }
            });
          }
          _syncRTLPluginState(K, ne) {
            return c._(this, void 0, void 0, function* () {
              return yield c.cX.syncState(ne, this.self.importScripts);
            });
          }
          _getAvailableImages(K) {
            let ne = this.availableImages[K];
            return ne || (ne = []), ne;
          }
          _getLayerIndex(K) {
            let ne = this.layerIndexes[K];
            return ne || (ne = this.layerIndexes[K] = new o()), ne;
          }
          _getWorkerSource(K, ne, de) {
            if (this.workerSources[K] || (this.workerSources[K] = {}), this.workerSources[K][ne] || (this.workerSources[K][ne] = {}), !this.workerSources[K][ne][de]) {
              const Te = { sendAsync: (Pe, qe) => (Pe.targetMapId = K, this.actor.sendAsync(Pe, qe)) };
              switch (ne) {
                case "vector":
                  this.workerSources[K][ne][de] = new T(Te, this._getLayerIndex(K), this._getAvailableImages(K));
                  break;
                case "geojson":
                  this.workerSources[K][ne][de] = new Ri(Te, this._getLayerIndex(K), this._getAvailableImages(K));
                  break;
                default:
                  this.workerSources[K][ne][de] = new this.externalWorkerSourceTypes[ne](Te, this._getLayerIndex(K), this._getAvailableImages(K));
              }
            }
            return this.workerSources[K][ne][de];
          }
          _getDEMWorkerSource(K, ne) {
            return this.demWorkerSources[K] || (this.demWorkerSources[K] = {}), this.demWorkerSources[K][ne] || (this.demWorkerSources[K][ne] = new P()), this.demWorkerSources[K][ne];
          }
        }
        return c.i(self) && (self.worker = new wr(self)), wr;
      }), n("index", ["exports", "./shared"], function(c, o) {
        var d = "5.10.0";
        function m() {
          var v = new o.A(4);
          return o.A != Float32Array && (v[1] = 0, v[2] = 0), v[0] = 1, v[3] = 1, v;
        }
        let y, T;
        const P = { frame(v, a, f) {
          const g = requestAnimationFrame((w) => {
            b(), a(w);
          }), { unsubscribe: b } = o.s(v.signal, "abort", () => {
            b(), cancelAnimationFrame(g), f(o.c());
          }, !1);
        }, frameAsync(v) {
          return new Promise((a, f) => {
            this.frame(v, a, f);
          });
        }, getImageData(v, a = 0) {
          return this.getImageCanvasContext(v).getImageData(-a, -a, v.width + 2 * a, v.height + 2 * a);
        }, getImageCanvasContext(v) {
          const a = window.document.createElement("canvas"), f = a.getContext("2d", { willReadFrequently: !0 });
          if (!f) throw new Error("failed to create canvas 2d context");
          return a.width = v.width, a.height = v.height, f.drawImage(v, 0, 0, v.width, v.height), f;
        }, resolveURL: (v) => (y || (y = document.createElement("a")), y.href = v, y.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (T == null && (T = matchMedia("(prefers-reduced-motion: reduce)")), T.matches);
        } }, I = new class {
          constructor() {
            this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
          }
          getCurrentTime() {
            return this._frozenAt !== null ? this._frozenAt : this._realTime();
          }
          setNow(v) {
            this._frozenAt = v;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return this._frozenAt !== null;
          }
        }();
        function D() {
          return I.getCurrentTime();
        }
        class k {
          static testProp(a) {
            if (!k.docStyle) return a[0];
            for (let f = 0; f < a.length; f++) if (a[f] in k.docStyle) return a[f];
            return a[0];
          }
          static create(a, f, g) {
            const b = window.document.createElement(a);
            return f !== void 0 && (b.className = f), g && g.appendChild(b), b;
          }
          static createNS(a, f) {
            return window.document.createElementNS(a, f);
          }
          static disableDrag() {
            k.docStyle && k.selectProp && (k.userSelect = k.docStyle[k.selectProp], k.docStyle[k.selectProp] = "none");
          }
          static enableDrag() {
            k.docStyle && k.selectProp && (k.docStyle[k.selectProp] = k.userSelect);
          }
          static setTransform(a, f) {
            a.style[k.transformProp] = f;
          }
          static addEventListener(a, f, g, b = {}) {
            a.addEventListener(f, g, "passive" in b ? b : b.capture);
          }
          static removeEventListener(a, f, g, b = {}) {
            a.removeEventListener(f, g, "passive" in b ? b : b.capture);
          }
          static suppressClickInternal(a) {
            a.preventDefault(), a.stopPropagation(), window.removeEventListener("click", k.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", k.suppressClickInternal, !0), window.setTimeout(() => {
              window.removeEventListener("click", k.suppressClickInternal, !0);
            }, 0);
          }
          static getScale(a) {
            const f = a.getBoundingClientRect();
            return { x: f.width / a.offsetWidth || 1, y: f.height / a.offsetHeight || 1, boundingClientRect: f };
          }
          static getPoint(a, f, g) {
            const b = f.boundingClientRect;
            return new o.P((g.clientX - b.left) / f.x - a.clientLeft, (g.clientY - b.top) / f.y - a.clientTop);
          }
          static mousePos(a, f) {
            const g = k.getScale(a);
            return k.getPoint(a, g, f);
          }
          static touchPos(a, f) {
            const g = [], b = k.getScale(a);
            for (let w = 0; w < f.length; w++) g.push(k.getPoint(a, b, f[w]));
            return g;
          }
          static mouseButton(a) {
            return a.button;
          }
          static remove(a) {
            a.parentNode && a.parentNode.removeChild(a);
          }
          static sanitize(a) {
            const f = new DOMParser().parseFromString(a, "text/html").body || document.createElement("body"), g = f.querySelectorAll("script");
            for (const b of g) b.remove();
            return k.clean(f), f.innerHTML;
          }
          static isPossiblyDangerous(a, f) {
            const g = f.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(a) || !g.includes("javascript:") && !g.includes("data:")) || !!a.startsWith("on") || void 0;
          }
          static clean(a) {
            const f = a.children;
            for (const g of f) k.removeAttributes(g), k.clean(g);
          }
          static removeAttributes(a) {
            for (const { name: f, value: g } of a.attributes) k.isPossiblyDangerous(f, g) && a.removeAttribute(f);
          }
        }
        k.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, k.selectProp = k.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), k.transformProp = k.testProp(["transform", "WebkitTransform"]);
        const $ = { supported: !1, testSupport: function(v) {
          !Z && te && (H ? J(v) : G = v);
        } };
        let G, te, Z = !1, H = !1;
        function J(v) {
          const a = v.createTexture();
          v.bindTexture(v.TEXTURE_2D, a);
          try {
            if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, te), v.isContextLost()) return;
            $.supported = !0;
          } catch {
          }
          v.deleteTexture(a), Z = !0;
        }
        var re;
        typeof document < "u" && (te = document.createElement("img"), te.onload = () => {
          G && J(G), G = null, H = !0;
        }, te.onerror = () => {
          Z = !0, G = null;
        }, te.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(v) {
          let a, f, g, b;
          v.resetRequestQueue = () => {
            a = [], f = 0, g = 0, b = {};
          }, v.addThrottleControl = (B) => {
            const U = g++;
            return b[U] = B, U;
          }, v.removeThrottleControl = (B) => {
            delete b[B], S();
          }, v.getImage = (B, U, j = !0) => new Promise((X, q) => {
            $.supported && (B.headers || (B.headers = {}), B.headers.accept = "image/webp,*/*"), o.e(B, { type: "image" }), a.push({ abortController: U, requestParameters: B, supportImageRefresh: j, state: "queued", onError: (Q) => {
              q(Q);
            }, onSuccess: (Q) => {
              X(Q);
            } }), S();
          });
          const w = (B) => o._(this, void 0, void 0, function* () {
            B.state = "running";
            const { requestParameters: U, supportImageRefresh: j, onError: X, onSuccess: q, abortController: Q } = B, ce = j === !1 && !o.i(self) && !o.g(U.url) && (!U.headers || Object.keys(U.headers).reduce((Se, Me) => Se && Me === "accept", !0));
            f++;
            const we = ce ? R(U, Q) : o.m(U, Q);
            try {
              const Se = yield we;
              delete B.abortController, B.state = "completed", Se.data instanceof HTMLImageElement || o.b(Se.data) ? q(Se) : Se.data && q({ data: yield (Ae = Se.data, typeof createImageBitmap == "function" ? o.f(Ae) : o.h(Ae)), cacheControl: Se.cacheControl, expires: Se.expires });
            } catch (Se) {
              delete B.abortController, X(Se);
            } finally {
              f--, S();
            }
            var Ae;
          }), S = () => {
            const B = (() => {
              for (const U of Object.keys(b)) if (b[U]()) return !0;
              return !1;
            })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let U = f; U < B && a.length > 0; U++) {
              const j = a.shift();
              j.abortController.signal.aborted ? U-- : w(j);
            }
          }, R = (B, U) => new Promise((j, X) => {
            const q = new Image(), Q = B.url, ce = B.credentials;
            ce && ce === "include" ? q.crossOrigin = "use-credentials" : (ce && ce === "same-origin" || !o.d(Q)) && (q.crossOrigin = "anonymous"), U.signal.addEventListener("abort", () => {
              q.src = "", X(o.c());
            }), q.fetchPriority = "high", q.onload = () => {
              q.onerror = q.onload = null, j({ data: q });
            }, q.onerror = () => {
              q.onerror = q.onload = null, U.signal.aborted || X(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, q.src = Q;
          });
        }(re || (re = {})), re.resetRequestQueue();
        class be {
          constructor(a) {
            this._transformRequestFn = a ?? null;
          }
          transformRequest(a, f) {
            return this._transformRequestFn && this._transformRequestFn(a, f) || { url: a };
          }
          setTransformRequest(a) {
            this._transformRequestFn = a;
          }
        }
        function pe(v) {
          const a = [];
          if (typeof v == "string") a.push({ id: "default", url: v });
          else if (v && v.length > 0) {
            const f = [];
            for (const { id: g, url: b } of v) {
              const w = `${g}${b}`;
              f.indexOf(w) === -1 && (f.push(w), a.push({ id: g, url: b }));
            }
          }
          return a;
        }
        function oe(v, a, f) {
          try {
            const g = new URL(v);
            return g.pathname += `${a}${f}`, g.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function Ee(v) {
          const { userImage: a } = v;
          return !!(a && a.render && a.render()) && (v.data.replace(new Uint8Array(a.data.buffer)), !0);
        }
        class le extends o.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(a) {
            if (this.loaded !== a && (this.loaded = a, a)) {
              for (const { ids: f, promiseResolve: g } of this.requestors) g(this._getImagesForIds(f));
              this.requestors = [];
            }
          }
          getImage(a) {
            const f = this.images[a];
            if (f && !f.data && f.spriteData) {
              const g = f.spriteData;
              f.data = new o.R({ width: g.width, height: g.height }, g.context.getImageData(g.x, g.y, g.width, g.height).data), f.spriteData = null;
            }
            return f;
          }
          addImage(a, f) {
            if (this.images[a]) throw new Error(`Image id ${a} already exist, use updateImage instead`);
            this._validate(a, f) && (this.images[a] = f);
          }
          _validate(a, f) {
            let g = !0;
            const b = f.data || f.spriteData;
            return this._validateStretch(f.stretchX, b && b.width) || (this.fire(new o.k(new Error(`Image "${a}" has invalid "stretchX" value`))), g = !1), this._validateStretch(f.stretchY, b && b.height) || (this.fire(new o.k(new Error(`Image "${a}" has invalid "stretchY" value`))), g = !1), this._validateContent(f.content, f) || (this.fire(new o.k(new Error(`Image "${a}" has invalid "content" value`))), g = !1), g;
          }
          _validateStretch(a, f) {
            if (!a) return !0;
            let g = 0;
            for (const b of a) {
              if (b[0] < g || b[1] < b[0] || f < b[1]) return !1;
              g = b[1];
            }
            return !0;
          }
          _validateContent(a, f) {
            if (!a) return !0;
            if (a.length !== 4) return !1;
            const g = f.spriteData, b = g && g.width || f.data.width, w = g && g.height || f.data.height;
            return !(a[0] < 0 || b < a[0] || a[1] < 0 || w < a[1] || a[2] < 0 || b < a[2] || a[3] < 0 || w < a[3] || a[2] < a[0] || a[3] < a[1]);
          }
          updateImage(a, f, g = !0) {
            const b = this.getImage(a);
            if (g && (b.data.width !== f.data.width || b.data.height !== f.data.height)) throw new Error(`size mismatch between old image (${b.data.width}x${b.data.height}) and new image (${f.data.width}x${f.data.height}).`);
            f.version = b.version + 1, this.images[a] = f, this.updatedImages[a] = !0;
          }
          removeImage(a) {
            const f = this.images[a];
            delete this.images[a], delete this.patterns[a], f.userImage && f.userImage.onRemove && f.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(a) {
            return new Promise((f, g) => {
              let b = !0;
              if (!this.isLoaded()) for (const w of a) this.images[w] || (b = !1);
              this.isLoaded() || b ? f(this._getImagesForIds(a)) : this.requestors.push({ ids: a, promiseResolve: f });
            });
          }
          _getImagesForIds(a) {
            const f = {};
            for (const g of a) {
              let b = this.getImage(g);
              b || (this.fire(new o.l("styleimagemissing", { id: g })), b = this.getImage(g)), b ? f[g] = { data: b.data.clone(), pixelRatio: b.pixelRatio, sdf: b.sdf, version: b.version, stretchX: b.stretchX, stretchY: b.stretchY, content: b.content, textFitWidth: b.textFitWidth, textFitHeight: b.textFitHeight, hasRenderCallback: !!(b.userImage && b.userImage.render) } : o.w(`Image "${g}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return f;
          }
          getPixelSize() {
            const { width: a, height: f } = this.atlasImage;
            return { width: a, height: f };
          }
          getPattern(a) {
            const f = this.patterns[a], g = this.getImage(a);
            if (!g) return null;
            if (f && f.position.version === g.version) return f.position;
            if (f) f.position.version = g.version;
            else {
              const b = { w: g.data.width + 2, h: g.data.height + 2, x: 0, y: 0 }, w = new o.I(b, g);
              this.patterns[a] = { bin: b, position: w };
            }
            return this._updatePatternAtlas(), this.patterns[a].position;
          }
          bind(a) {
            const f = a.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.T(a, this.atlasImage, f.RGBA), this.atlasTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const a = [];
            for (const w in this.patterns) a.push(this.patterns[w].bin);
            const { w: f, h: g } = o.p(a), b = this.atlasImage;
            b.resize({ width: f || 1, height: g || 1 });
            for (const w in this.patterns) {
              const { bin: S } = this.patterns[w], R = S.x + 1, B = S.y + 1, U = this.getImage(w).data, j = U.width, X = U.height;
              o.R.copy(U, b, { x: 0, y: 0 }, { x: R, y: B }, { width: j, height: X }), o.R.copy(U, b, { x: 0, y: X - 1 }, { x: R, y: B - 1 }, { width: j, height: 1 }), o.R.copy(U, b, { x: 0, y: 0 }, { x: R, y: B + X }, { width: j, height: 1 }), o.R.copy(U, b, { x: j - 1, y: 0 }, { x: R - 1, y: B }, { width: 1, height: X }), o.R.copy(U, b, { x: 0, y: 0 }, { x: R + j, y: B }, { width: 1, height: X });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(a) {
            for (const f of a) {
              if (this.callbackDispatchedThisFrame[f]) continue;
              this.callbackDispatchedThisFrame[f] = !0;
              const g = this.getImage(f);
              g || o.w(`Image with ID: "${f}" was not found`), Ee(g) && this.updateImage(f, g);
            }
          }
        }
        const _e = 1e20;
        function Ve(v, a, f, g, b, w, S, R, B) {
          for (let U = a; U < a + g; U++) Be(v, f * w + U, w, b, S, R, B);
          for (let U = f; U < f + b; U++) Be(v, U * w + a, 1, g, S, R, B);
        }
        function Be(v, a, f, g, b, w, S) {
          w[0] = 0, S[0] = -_e, S[1] = _e, b[0] = v[a];
          for (let R = 1, B = 0, U = 0; R < g; R++) {
            b[R] = v[a + R * f];
            const j = R * R;
            do {
              const X = w[B];
              U = (b[R] - b[X] + j - X * X) / (R - X) / 2;
            } while (U <= S[B] && --B > -1);
            B++, w[B] = R, S[B] = U, S[B + 1] = _e;
          }
          for (let R = 0, B = 0; R < g; R++) {
            for (; S[B + 1] < R; ) B++;
            const U = w[B], j = R - U;
            v[a + R * f] = b[U] + j * j;
          }
        }
        class gt {
          constructor(a, f, g) {
            this.requestManager = a, this.localIdeographFontFamily = f, this.entries = {}, this.lang = g;
          }
          setURL(a) {
            this.url = a;
          }
          getGlyphs(a) {
            return o._(this, void 0, void 0, function* () {
              const f = [];
              for (const w in a) for (const S of a[w]) f.push(this._getAndCacheGlyphsPromise(w, S));
              const g = yield Promise.all(f), b = {};
              for (const { stack: w, id: S, glyph: R } of g) b[w] || (b[w] = {}), b[w][S] = R && { id: R.id, bitmap: R.bitmap.clone(), metrics: R.metrics };
              return b;
            });
          }
          _getAndCacheGlyphsPromise(a, f) {
            return o._(this, void 0, void 0, function* () {
              let g = this.entries[a];
              g || (g = this.entries[a] = { glyphs: {}, requests: {}, ranges: {} });
              let b = g.glyphs[f];
              if (b !== void 0) return { stack: a, id: f, glyph: b };
              if (b = this._tinySDF(g, a, f), b) return g.glyphs[f] = b, { stack: a, id: f, glyph: b };
              const w = Math.floor(f / 256);
              if (256 * w > 65535) throw new Error("glyphs > 65535 not supported");
              if (g.ranges[w]) return { stack: a, id: f, glyph: b };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!g.requests[w]) {
                const R = gt.loadGlyphRange(a, w, this.url, this.requestManager);
                g.requests[w] = R;
              }
              const S = yield g.requests[w];
              for (const R in S) this._doesCharSupportLocalGlyph(+R) || (g.glyphs[+R] = S[+R]);
              return g.ranges[w] = !0, { stack: a, id: f, glyph: S[f] || null };
            });
          }
          _doesCharSupportLocalGlyph(a) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(a)) || o.u["CJK Unified Ideographs"](a) || o.u["Hangul Syllables"](a) || o.u.Hiragana(a) || o.u.Katakana(a) || o.u["CJK Symbols and Punctuation"](a) || o.u["Halfwidth and Fullwidth Forms"](a));
          }
          _tinySDF(a, f, g) {
            const b = this.localIdeographFontFamily;
            if (!b || !this._doesCharSupportLocalGlyph(g)) return;
            let w = a.tinySDF;
            if (!w) {
              let R = "400";
              /bold/i.test(f) ? R = "900" : /medium/i.test(f) ? R = "500" : /light/i.test(f) && (R = "200"), w = a.tinySDF = new gt.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, lang: this.lang, fontFamily: b, fontWeight: R });
            }
            const S = w.draw(String.fromCharCode(g));
            return { id: g, bitmap: new o.q({ width: S.width || 60, height: S.height || 60 }, S.data), metrics: { width: S.glyphWidth / 2 || 24, height: S.glyphHeight / 2 || 24, left: S.glyphLeft / 2 + 0.5 || 0, top: S.glyphTop / 2 - 27.5 || -8, advance: S.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
        }
        gt.loadGlyphRange = function(v, a, f, g) {
          return o._(this, void 0, void 0, function* () {
            const b = 256 * a, w = b + 255, S = g.transformRequest(f.replace("{fontstack}", v).replace("{range}", `${b}-${w}`), "Glyphs"), R = yield o.n(S, new AbortController());
            if (!R || !R.data) throw new Error(`Could not load glyph range. range: ${a}, ${b}-${w}`);
            const B = {};
            for (const U of o.o(R.data)) B[U.id] = U;
            return B;
          });
        }, gt.TinySDF = class {
          constructor({ fontSize: v = 24, buffer: a = 3, radius: f = 8, cutoff: g = 0.25, fontFamily: b = "sans-serif", fontWeight: w = "normal", fontStyle: S = "normal", lang: R = null } = {}) {
            this.buffer = a, this.cutoff = g, this.radius = f, this.lang = R;
            const B = this.size = v + 4 * a, U = this._createCanvas(B), j = this.ctx = U.getContext("2d", { willReadFrequently: !0 });
            j.font = `${S} ${w} ${v}px ${b}`, j.textBaseline = "alphabetic", j.textAlign = "left", j.fillStyle = "black", this.gridOuter = new Float64Array(B * B), this.gridInner = new Float64Array(B * B), this.f = new Float64Array(B), this.z = new Float64Array(B + 1), this.v = new Uint16Array(B);
          }
          _createCanvas(v) {
            const a = document.createElement("canvas");
            return a.width = a.height = v, a;
          }
          draw(v) {
            const { width: a, actualBoundingBoxAscent: f, actualBoundingBoxDescent: g, actualBoundingBoxLeft: b, actualBoundingBoxRight: w } = this.ctx.measureText(v), S = Math.ceil(f), R = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(w - b))), B = Math.min(this.size - this.buffer, S + Math.ceil(g)), U = R + 2 * this.buffer, j = B + 2 * this.buffer, X = Math.max(U * j, 0), q = new Uint8ClampedArray(X), Q = { data: q, width: U, height: j, glyphWidth: R, glyphHeight: B, glyphTop: S, glyphLeft: 0, glyphAdvance: a };
            if (R === 0 || B === 0) return Q;
            const { ctx: ce, buffer: we, gridInner: Ae, gridOuter: Se } = this;
            this.lang && (ce.lang = this.lang), ce.clearRect(we, we, R, B), ce.fillText(v, we, we + S);
            const Me = ce.getImageData(we, we, R, B);
            Se.fill(_e, 0, X), Ae.fill(0, 0, X);
            for (let Ge = 0; Ge < B; Ge++) for (let Le = 0; Le < R; Le++) {
              const $e = Me.data[4 * (Ge * R + Le) + 3] / 255;
              if ($e === 0) continue;
              const Xe = (Ge + we) * U + Le + we;
              if ($e === 1) Se[Xe] = 0, Ae[Xe] = _e;
              else {
                const Fe = 0.5 - $e;
                Se[Xe] = Fe > 0 ? Fe * Fe : 0, Ae[Xe] = Fe < 0 ? Fe * Fe : 0;
              }
            }
            Ve(Se, 0, 0, U, j, U, this.f, this.v, this.z), Ve(Ae, we, we, R, B, U, this.f, this.v, this.z);
            for (let Ge = 0; Ge < X; Ge++) {
              const Le = Math.sqrt(Se[Ge]) - Math.sqrt(Ae[Ge]);
              q[Ge] = Math.round(255 - 255 * (Le / this.radius + this.cutoff));
            }
            return Q;
          }
        };
        class St {
          constructor() {
            this.specification = o.v.light.position;
          }
          possiblyEvaluate(a, f) {
            return o.B(a.expression.evaluate(f));
          }
          interpolate(a, f, g) {
            return { x: o.C.number(a.x, f.x, g), y: o.C.number(a.y, f.y, g), z: o.C.number(a.z, f.z, g) };
          }
        }
        let Mt;
        class mt extends o.E {
          constructor(a) {
            super(), Mt = Mt || new o.r({ anchor: new o.D(o.v.light.anchor), position: new St(), color: new o.D(o.v.light.color), intensity: new o.D(o.v.light.intensity) }), this._transitionable = new o.t(Mt, void 0), this.setLight(a), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(a, f = {}) {
            if (!this._validate(o.x, a, f)) for (const g in a) {
              const b = a[g];
              g.endsWith("-transition") ? this._transitionable.setTransition(g.slice(0, -11), b) : this._transitionable.setValue(g, b);
            }
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          _validate(a, f, g) {
            return (!g || g.validate !== !1) && o.y(this, a.call(o.z, { value: f, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v }));
          }
        }
        const wt = new o.r({ "sky-color": new o.D(o.v.sky["sky-color"]), "horizon-color": new o.D(o.v.sky["horizon-color"]), "fog-color": new o.D(o.v.sky["fog-color"]), "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]), "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]), "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"]) });
        class Yt extends o.E {
          constructor(a) {
            super(), this._transitionable = new o.t(wt, void 0), this.setSky(a), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0));
          }
          setSky(a, f = {}) {
            if (!this._validate(o.G, a, f)) {
              a || (a = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const g in a) {
                const b = a[g];
                g.endsWith("-transition") ? this._transitionable.setTransition(g.slice(0, -11), b) : this._transitionable.setValue(g, b);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          _validate(a, f, g = {}) {
            return g?.validate !== !1 && o.y(this, a.call(o.z, o.e({ value: f, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v })));
          }
          calculateFogBlendOpacity(a) {
            return a < 60 ? 0 : a < 70 ? (a - 60) / 10 : 1;
          }
        }
        class Dt {
          constructor(a, f) {
            this.width = a, this.height = f, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(a, f) {
            const g = a.join(",") + String(f);
            return this.dashEntry[g] || (this.dashEntry[g] = this.addDash(a, f)), this.dashEntry[g];
          }
          getDashRanges(a, f, g) {
            const b = [];
            let w = a.length % 2 == 1 ? -a[a.length - 1] * g : 0, S = a[0] * g, R = !0;
            b.push({ left: w, right: S, isDash: R, zeroLength: a[0] === 0 });
            let B = a[0];
            for (let U = 1; U < a.length; U++) {
              R = !R;
              const j = a[U];
              w = B * g, B += j, S = B * g, b.push({ left: w, right: S, isDash: R, zeroLength: j === 0 });
            }
            return b;
          }
          addRoundDash(a, f, g) {
            const b = f / 2;
            for (let w = -g; w <= g; w++) {
              const S = this.width * (this.nextRow + g + w);
              let R = 0, B = a[R];
              for (let U = 0; U < this.width; U++) {
                U / B.right > 1 && (B = a[++R]);
                const j = Math.abs(U - B.left), X = Math.abs(U - B.right), q = Math.min(j, X);
                let Q;
                const ce = w / g * (b + 1);
                if (B.isDash) {
                  const we = b - Math.abs(ce);
                  Q = Math.sqrt(q * q + we * we);
                } else Q = b - Math.sqrt(q * q + ce * ce);
                this.data[S + U] = Math.max(0, Math.min(255, Q + 128));
              }
            }
          }
          addRegularDash(a) {
            for (let R = a.length - 1; R >= 0; --R) {
              const B = a[R], U = a[R + 1];
              B.zeroLength ? a.splice(R, 1) : U && U.isDash === B.isDash && (U.left = B.left, a.splice(R, 1));
            }
            const f = a[0], g = a[a.length - 1];
            f.isDash === g.isDash && (f.left = g.left - this.width, g.right = f.right + this.width);
            const b = this.width * this.nextRow;
            let w = 0, S = a[w];
            for (let R = 0; R < this.width; R++) {
              R / S.right > 1 && (S = a[++w]);
              const B = Math.abs(R - S.left), U = Math.abs(R - S.right), j = Math.min(B, U);
              this.data[b + R] = Math.max(0, Math.min(255, (S.isDash ? j : -j) + 128));
            }
          }
          addDash(a, f) {
            const g = f ? 7 : 0, b = 2 * g + 1;
            if (this.nextRow + b > this.height) return o.w("LineAtlas out of space"), null;
            let w = 0;
            for (let R = 0; R < a.length; R++) w += a[R];
            if (w !== 0) {
              const R = this.width / w, B = this.getDashRanges(a, this.width, R);
              f ? this.addRoundDash(B, R, g) : this.addRegularDash(B);
            }
            const S = { y: this.nextRow + g, height: 2 * g, width: w };
            return this.nextRow += b, this.dirty = !0, S;
          }
          bind(a) {
            const f = a.gl;
            this.texture ? (f.bindTexture(f.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, this.width, this.height, f.ALPHA, f.UNSIGNED_BYTE, this.data))) : (this.texture = f.createTexture(), f.bindTexture(f.TEXTURE_2D, this.texture), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR), f.texImage2D(f.TEXTURE_2D, 0, f.ALPHA, this.width, this.height, 0, f.ALPHA, f.UNSIGNED_BYTE, this.data));
          }
        }
        const fe = "maplibre_preloaded_worker_pool";
        class De {
          constructor() {
            this.active = {};
          }
          acquire(a) {
            if (!this.workers) for (this.workers = []; this.workers.length < De.workerCount; ) this.workers.push(new Worker(o.a.WORKER_URL));
            return this.active[a] = !0, this.workers.slice();
          }
          release(a) {
            delete this.active[a], this.numActive() === 0 && (this.workers.forEach((f) => {
              f.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[fe];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const je = Math.floor(P.hardwareConcurrency / 2);
        let Ke, rt;
        function at() {
          return Ke || (Ke = new De()), Ke;
        }
        De.workerCount = o.H(globalThis) ? Math.max(Math.min(je, 3), 1) : 1;
        class Et {
          constructor(a, f) {
            this.workerPool = a, this.actors = [], this.currentActor = 0, this.id = f;
            const g = this.workerPool.acquire(f);
            for (let b = 0; b < g.length; b++) {
              const w = new o.J(g[b], f);
              w.name = `Worker ${b}`, this.actors.push(w);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(a, f) {
            const g = [];
            for (const b of this.actors) g.push(b.sendAsync({ type: a, data: f }));
            return Promise.all(g);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(a = !0) {
            this.actors.forEach((f) => {
              f.remove();
            }), this.actors = [], a && this.workerPool.release(this.id);
          }
          registerMessageHandler(a, f) {
            for (const g of this.actors) g.registerMessageHandler(a, f);
          }
        }
        function Tt() {
          return rt || (rt = new Et(at(), o.K), rt.registerMessageHandler("GR", (v, a, f) => o.m(a, f))), rt;
        }
        function Vt(v, a) {
          const f = o.L();
          return o.M(f, f, [1, 1, 0]), o.N(f, f, [0.5 * v.width, 0.5 * v.height, 1]), v.calculatePosMatrix ? o.O(f, f, v.calculatePosMatrix(a.toUnwrapped())) : f;
        }
        function tr(v, a, f, g, b, w, S) {
          var R;
          const B = function(q, Q, ce) {
            if (q) for (const we of q) {
              const Ae = Q[we];
              if (Ae && Ae.source === ce && Ae.type === "fill-extrusion") return !0;
            }
            else for (const we in Q) {
              const Ae = Q[we];
              if (Ae.source === ce && Ae.type === "fill-extrusion") return !0;
            }
            return !1;
          }((R = b?.layers) !== null && R !== void 0 ? R : null, a, v.id), U = w.maxPitchScaleFactor(), j = v.tilesIn(g, U, B);
          j.sort(ur);
          const X = [];
          for (const q of j) X.push({ wrappedTileID: q.tileID.wrapped().key, queryResults: q.tile.queryRenderedFeatures(a, f, v._state, q.queryGeometry, q.cameraQueryGeometry, q.scale, b, w, U, Vt(v.transform, q.tileID), S ? (Q, ce) => S(q.tileID, Q, ce) : void 0) });
          return function(q, Q) {
            for (const ce in q) for (const we of q[ce]) dr(we, Q);
            return q;
          }(function(q) {
            const Q = {}, ce = {};
            for (const we of q) {
              const Ae = we.queryResults, Se = we.wrappedTileID, Me = ce[Se] = ce[Se] || {};
              for (const Ge in Ae) {
                const Le = Ae[Ge], $e = Me[Ge] = Me[Ge] || {}, Xe = Q[Ge] = Q[Ge] || [];
                for (const Fe of Le) $e[Fe.featureIndex] || ($e[Fe.featureIndex] = !0, Xe.push(Fe));
              }
            }
            return Q;
          }(X), v);
        }
        function ur(v, a) {
          const f = v.tileID, g = a.tileID;
          return f.overscaledZ - g.overscaledZ || f.canonical.y - g.canonical.y || f.wrap - g.wrap || f.canonical.x - g.canonical.x;
        }
        function dr(v, a) {
          const f = v.feature, g = a.getFeatureState(f.layer["source-layer"], f.id);
          f.source = f.layer.source, f.layer["source-layer"] && (f.sourceLayer = f.layer["source-layer"]), f.state = g;
        }
        function Ct(v, a, f) {
          return o._(this, void 0, void 0, function* () {
            let g = v;
            if (v.url ? g = (yield o.j(a.transformRequest(v.url, "Source"), f)).data : yield P.frameAsync(f), !g) return null;
            const b = o.Q(o.e(g, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in g && g.vector_layers && (b.vectorLayerIds = g.vector_layers.map((w) => w.id)), b;
          });
        }
        class Oe {
          constructor(a, f) {
            a && (f ? this.setSouthWest(a).setNorthEast(f) : Array.isArray(a) && (a.length === 4 ? this.setSouthWest([a[0], a[1]]).setNorthEast([a[2], a[3]]) : this.setSouthWest(a[0]).setNorthEast(a[1])));
          }
          setNorthEast(a) {
            return this._ne = a instanceof o.S ? new o.S(a.lng, a.lat) : o.S.convert(a), this;
          }
          setSouthWest(a) {
            return this._sw = a instanceof o.S ? new o.S(a.lng, a.lat) : o.S.convert(a), this;
          }
          extend(a) {
            const f = this._sw, g = this._ne;
            let b, w;
            if (a instanceof o.S) b = a, w = a;
            else {
              if (!(a instanceof Oe)) return Array.isArray(a) ? a.length === 4 || a.every(Array.isArray) ? this.extend(Oe.convert(a)) : this.extend(o.S.convert(a)) : a && ("lng" in a || "lon" in a) && "lat" in a ? this.extend(o.S.convert(a)) : this;
              if (b = a._sw, w = a._ne, !b || !w) return this;
            }
            return f || g ? (f.lng = Math.min(b.lng, f.lng), f.lat = Math.min(b.lat, f.lat), g.lng = Math.max(w.lng, g.lng), g.lat = Math.max(w.lat, g.lat)) : (this._sw = new o.S(b.lng, b.lat), this._ne = new o.S(w.lng, w.lat)), this;
          }
          getCenter() {
            return new o.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new o.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new o.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(a) {
            const { lng: f, lat: g } = o.S.convert(a);
            let b = this._sw.lng <= f && f <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (b = this._sw.lng >= f && f >= this._ne.lng), this._sw.lat <= g && g <= this._ne.lat && b;
          }
          static convert(a) {
            return a instanceof Oe ? a : a && new Oe(a);
          }
          static fromLngLat(a, f = 0) {
            const g = 360 * f / 40075017, b = g / Math.cos(Math.PI / 180 * a.lat);
            return new Oe(new o.S(a.lng - b, a.lat - g), new o.S(a.lng + b, a.lat + g));
          }
          adjustAntiMeridian() {
            const a = new o.S(this._sw.lng, this._sw.lat), f = new o.S(this._ne.lng, this._ne.lat);
            return new Oe(a, a.lng > f.lng ? new o.S(f.lng + 360, f.lat) : f);
          }
        }
        class ii {
          constructor(a, f, g) {
            this.bounds = Oe.convert(this.validateBounds(a)), this.minzoom = f || 0, this.maxzoom = g || 24;
          }
          validateBounds(a) {
            return Array.isArray(a) && a.length === 4 ? [Math.max(-180, a[0]), Math.max(-90, a[1]), Math.min(180, a[2]), Math.min(90, a[3])] : [-180, -90, 180, 90];
          }
          contains(a) {
            const f = Math.pow(2, a.z), g = Math.floor(o.V(this.bounds.getWest()) * f), b = Math.floor(o.U(this.bounds.getNorth()) * f), w = Math.ceil(o.V(this.bounds.getEast()) * f), S = Math.ceil(o.U(this.bounds.getSouth()) * f);
            return a.x >= g && a.x < w && a.y >= b && a.y < S;
          }
        }
        class Zr extends o.E {
          constructor(a, f, g, b) {
            if (super(), this.id = a, this.dispatcher = g, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.Q(f, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({ type: "vector" }, f), this._collectResourceTiming = f.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(b);
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new o.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield Ct(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), a && (o.e(this, a), a.bounds && (this.tileBounds = new ii(a.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new o.k(a));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(a) {
            return !this.tileBounds || this.tileBounds.contains(a.canonical);
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          setSourceProperty(a) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), a(), this.load();
          }
          setTiles(a) {
            return this.setSourceProperty(() => {
              this._options.tiles = a;
            }), this;
          }
          setUrl(a) {
            return this.setSourceProperty(() => {
              this.url = a, this._options.url = a;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return o.e({}, this._options);
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const f = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), g = { request: this.map._requestManager.transformRequest(f, "Tile"), uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, tileSize: this.tileSize * a.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              g.request.collectResourceTiming = this._collectResourceTiming;
              let b = "RT";
              if (a.actor && a.state !== "expired") {
                if (a.state === "loading") return new Promise((w, S) => {
                  a.reloadPromise = { resolve: w, reject: S };
                });
              } else a.actor = this.dispatcher.getActor(), b = "LT";
              a.abortController = new AbortController();
              try {
                const w = yield a.actor.sendAsync({ type: b, data: g }, a.abortController);
                if (delete a.abortController, a.aborted) return;
                this._afterTileLoadWorkerResponse(a, w);
              } catch (w) {
                if (delete a.abortController, a.aborted) return;
                if (w && w.status !== 404) throw w;
                this._afterTileLoadWorkerResponse(a, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(a, f) {
            if (f && f.resourceTiming && (a.resourceTiming = f.resourceTiming), f && this.map._refreshExpiredTiles && a.setExpiryData(f), a.loadVectorData(f, this.map.painter), a.reloadPromise) {
              const g = a.reloadPromise;
              a.reloadPromise = null, this.loadTile(a).then(g.resolve).catch(g.reject);
            }
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController), a.actor && (yield a.actor.sendAsync({ type: "AT", data: { uid: a.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.unloadVectorData(), a.actor && (yield a.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Rr extends o.E {
          constructor(a, f, g, b) {
            super(), this.id = a, this.dispatcher = g, this.setEventedParent(b), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({ type: "raster" }, f), o.e(this, o.Q(f, ["url", "scheme", "tileSize"]));
          }
          load() {
            return o._(this, arguments, void 0, function* (a = !1) {
              this._loaded = !1, this.fire(new o.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const f = yield Ct(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, f && (o.e(this, f), f.bounds && (this.tileBounds = new ii(f.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: a })));
              } catch (f) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new o.k(f));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(a) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), a(), this.load(!0);
          }
          setTiles(a) {
            return this.setSourceProperty(() => {
              this._options.tiles = a;
            }), this;
          }
          setUrl(a) {
            return this.setSourceProperty(() => {
              this.url = a, this._options.url = a;
            }), this;
          }
          serialize() {
            return o.e({}, this._options);
          }
          hasTile(a) {
            return !this.tileBounds || this.tileBounds.contains(a.canonical);
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const f = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              a.abortController = new AbortController();
              try {
                const g = yield re.getImage(this.map._requestManager.transformRequest(f, "Tile"), a.abortController, this.map._refreshExpiredTiles);
                if (delete a.abortController, a.aborted) return void (a.state = "unloaded");
                if (g && g.data) {
                  this.map._refreshExpiredTiles && (g.cacheControl || g.expires) && a.setExpiryData({ cacheControl: g.cacheControl, expires: g.expires });
                  const b = this.map.painter.context, w = b.gl, S = g.data;
                  a.texture = this.map.painter.getTileTexture(S.width), a.texture ? a.texture.update(S, { useMipmap: !0 }) : (a.texture = new o.T(b, S, w.RGBA, { useMipmap: !0 }), a.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST)), a.state = "loaded";
                }
              } catch (g) {
                if (delete a.abortController, a.aborted) a.state = "unloaded";
                else if (g) throw a.state = "errored", g;
              }
            });
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController);
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.texture && this.map.painter.saveTileTexture(a.texture);
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Jt extends Rr {
          constructor(a, f, g, b) {
            super(a, f, g, b), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({ type: "raster-dem" }, f), this.encoding = f.encoding || "mapbox", this.redFactor = f.redFactor, this.greenFactor = f.greenFactor, this.blueFactor = f.blueFactor, this.baseShift = f.baseShift;
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const f = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), g = this.map._requestManager.transformRequest(f, "Tile");
              a.neighboringTiles = this._getNeighboringTiles(a.tileID), a.abortController = new AbortController();
              try {
                const b = yield re.getImage(g, a.abortController, this.map._refreshExpiredTiles);
                if (delete a.abortController, a.aborted) return void (a.state = "unloaded");
                if (b && b.data) {
                  const w = b.data;
                  this.map._refreshExpiredTiles && (b.cacheControl || b.expires) && a.setExpiryData({ cacheControl: b.cacheControl, expires: b.expires });
                  const S = o.b(w) && o.W() ? w : yield this.readImageNow(w), R = { type: this.type, uid: a.uid, source: this.id, rawImageData: S, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!a.actor || a.state === "expired") {
                    a.actor = this.dispatcher.getActor();
                    const B = yield a.actor.sendAsync({ type: "LDT", data: R });
                    a.dem = B, a.needsHillshadePrepare = !0, a.needsTerrainPrepare = !0, a.state = "loaded";
                  }
                }
              } catch (b) {
                if (delete a.abortController, a.aborted) a.state = "unloaded";
                else if (b) throw a.state = "errored", b;
              }
            });
          }
          readImageNow(a) {
            return o._(this, void 0, void 0, function* () {
              if (typeof VideoFrame < "u" && o.X()) {
                const f = a.width + 2, g = a.height + 2;
                try {
                  return new o.R({ width: f, height: g }, yield o.Y(a, -1, -1, f, g));
                } catch {
                }
              }
              return P.getImageData(a, 1);
            });
          }
          _getNeighboringTiles(a) {
            const f = a.canonical, g = Math.pow(2, f.z), b = (f.x - 1 + g) % g, w = f.x === 0 ? a.wrap - 1 : a.wrap, S = (f.x + 1 + g) % g, R = f.x + 1 === g ? a.wrap + 1 : a.wrap, B = {};
            return B[new o.Z(a.overscaledZ, w, f.z, b, f.y).key] = { backfilled: !1 }, B[new o.Z(a.overscaledZ, R, f.z, S, f.y).key] = { backfilled: !1 }, f.y > 0 && (B[new o.Z(a.overscaledZ, w, f.z, b, f.y - 1).key] = { backfilled: !1 }, B[new o.Z(a.overscaledZ, a.wrap, f.z, f.x, f.y - 1).key] = { backfilled: !1 }, B[new o.Z(a.overscaledZ, R, f.z, S, f.y - 1).key] = { backfilled: !1 }), f.y + 1 < g && (B[new o.Z(a.overscaledZ, w, f.z, b, f.y + 1).key] = { backfilled: !1 }, B[new o.Z(a.overscaledZ, a.wrap, f.z, f.x, f.y + 1).key] = { backfilled: !1 }, B[new o.Z(a.overscaledZ, R, f.z, S, f.y + 1).key] = { backfilled: !1 }), B;
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.demTexture && this.map.painter.saveTileTexture(a.demTexture), a.fbo && (a.fbo.destroy(), delete a.fbo), a.dem && delete a.dem, delete a.neighboringTiles, a.state = "unloaded", a.actor && (yield a.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: a.uid, source: this.id } }));
            });
          }
        }
        class Sr extends o.E {
          constructor(a, f, g, b) {
            super(), this.id = a, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: f.data }, this.actor = g.getActor(), this.setEventedParent(b), this._data = f.data, this._options = o.e({}, f), this._collectResourceTiming = f.collectResourceTiming, f.maxzoom !== void 0 && (this.maxzoom = f.maxzoom), f.type && (this.type = f.type), f.attribution && (this.attribution = f.attribution), this.promoteId = f.promoteId, f.clusterMaxZoom !== void 0 && this.maxzoom <= f.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${f.clusterMaxZoom}".`), this.workerOptions = o.e({ source: this.id, cluster: f.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(f.buffer !== void 0 ? f.buffer : 128), tolerance: this._pixelsToTileUnits(f.tolerance !== void 0 ? f.tolerance : 0.375), extent: o.$, maxZoom: this.maxzoom, lineMetrics: f.lineMetrics || !1, generateId: f.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(f.clusterMaxZoom), minPoints: Math.max(2, f.clusterMinPoints || 2), extent: o.$, radius: this._pixelsToTileUnits(f.clusterRadius || 50), log: !1, generateId: f.generateId || !1 }, clusterProperties: f.clusterProperties, filter: f.filter }, f.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
          }
          _pixelsToTileUnits(a) {
            return a * (o.$ / this.tileSize);
          }
          _getClusterMaxZoom(a) {
            const f = a ? Math.round(a) : this.maxzoom - 1;
            return Number.isInteger(a) || a === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${a}" rounded to "${f}"`), f;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          setData(a) {
            return this._data = a, this._pendingWorkerUpdate = { data: a }, this._updateWorkerData(), this;
          }
          updateData(a) {
            return this._pendingWorkerUpdate.diff = o.a0(this._pendingWorkerUpdate.diff, a), this._updateWorkerData(), this;
          }
          getData() {
            return o._(this, void 0, void 0, function* () {
              const a = o.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: a });
            });
          }
          getCoordinatesFromGeometry(a) {
            return a.type === "GeometryCollection" ? a.geometries.map((f) => f.coordinates).flat(1 / 0) : a.coordinates.flat(1 / 0);
          }
          getBounds() {
            return o._(this, void 0, void 0, function* () {
              const a = new Oe(), f = yield this.getData();
              let g;
              switch (f.type) {
                case "FeatureCollection":
                  g = f.features.map((b) => this.getCoordinatesFromGeometry(b.geometry)).flat(1 / 0);
                  break;
                case "Feature":
                  g = this.getCoordinatesFromGeometry(f.geometry);
                  break;
                default:
                  g = this.getCoordinatesFromGeometry(f);
              }
              if (g.length == 0) return a;
              for (let b = 0; b < g.length - 1; b += 2) a.extend([g[b], g[b + 1]]);
              return a;
            });
          }
          setClusterOptions(a) {
            return this.workerOptions.cluster = a.cluster, a.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(a.clusterRadius)), a.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(a.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(a) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: a, source: this.id } });
          }
          getClusterChildren(a) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: a, source: this.id } });
          }
          getClusterLeaves(a, f, g) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: a, limit: f, offset: g } });
          }
          _updateWorkerData() {
            return o._(this, void 0, void 0, function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void o.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const { data: a, diff: f } = this._pendingWorkerUpdate, g = o.e({ type: this.type }, this.workerOptions);
              a ? (typeof a == "string" ? (g.request = this.map._requestManager.transformRequest(P.resolveURL(a), "Source"), g.request.collectResourceTiming = this._collectResourceTiming) : g.data = JSON.stringify(a), this._pendingWorkerUpdate.data = void 0) : f && (g.dataDiff = f, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new o.l("dataloading", { dataType: "source" }));
              try {
                const b = yield this.actor.sendAsync({ type: "LD", data: g });
                if (this._isUpdatingWorker = !1, this._removed || b.abandoned) return void this.fire(new o.l("dataabort", { dataType: "source" }));
                this._data = b.data;
                let w = null;
                b.resourceTiming && b.resourceTiming[this.id] && (w = b.resourceTiming[this.id].slice(0));
                const S = { dataType: "source" };
                this._collectResourceTiming && w && w.length > 0 && o.e(S, { resourceTiming: w }), this.fire(new o.l("data", Object.assign(Object.assign({}, S), { sourceDataType: "metadata" }))), this.fire(new o.l("data", Object.assign(Object.assign({}, S), { sourceDataType: "content" })));
              } catch (b) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new o.l("dataabort", { dataType: "source" }));
                this.fire(new o.k(b));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            });
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const f = a.actor ? "RT" : "LT";
              a.actor = this.actor;
              const g = { type: this.type, uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              a.abortController = new AbortController();
              const b = yield this.actor.sendAsync({ type: f, data: g }, a.abortController);
              delete a.abortController, a.unloadVectorData(), a.aborted || a.loadVectorData(b, this.map.painter, f === "RT");
            });
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController), a.aborted = !0;
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return o.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        class hr extends o.E {
          constructor(a, f, g, b) {
            super(), this.flippedWindingOrder = !1, this.id = a, this.dispatcher = g, this.coordinates = f.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(b), this.options = f;
          }
          load(a) {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new o.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const f = yield re.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, f && f.data && (this.image = f.data, a && (this.coordinates = a), this._finishLoading());
              } catch (f) {
                this._request = null, this._loaded = !0, this.fire(new o.k(f));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(a) {
            return a.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = a.url, this.load(a.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(a) {
            this.coordinates = a;
            const f = a.map(o.a1.fromLngLat);
            var g;
            return this.tileID = function(b) {
              const w = o.a2.fromPoints(b), S = w.width(), R = w.height(), B = Math.max(S, R), U = Math.max(0, Math.floor(-Math.log(B) / Math.LN2)), j = Math.pow(2, U);
              return new o.a4(U, Math.floor((w.minX + w.maxX) / 2 * j), Math.floor((w.minY + w.maxY) / 2 * j));
            }(f), this.terrainTileRanges = this._getOverlappingTileRanges(f), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = f.map((b) => this.tileID.getTilePoint(b)._round()), this.flippedWindingOrder = ((g = this.tileCoords)[1].x - g[0].x) * (g[2].y - g[0].y) - (g[1].y - g[0].y) * (g[2].x - g[0].x) < 0, this.fire(new o.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const a = this.map.painter.context, f = a.gl;
            this.texture || (this.texture = new o.T(a, this.image, f.RGBA), this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE));
            let g = !1;
            for (const b in this.tiles) {
              const w = this.tiles[b];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, g = !0);
            }
            g && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(a.tileID.canonical) ? (this.tiles[String(a.tileID.wrap)] = a, a.buckets = {}) : a.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(a) {
            const { minX: f, minY: g, maxX: b, maxY: w } = o.a2.fromPoints(a), S = {};
            for (let R = 0; R <= o.a3; R++) {
              const B = Math.pow(2, R), U = Math.floor(f * B), j = Math.floor(g * B), X = Math.floor(b * B), q = Math.floor(w * B);
              S[R] = { minTileX: U, minTileY: j, maxTileX: X, maxTileY: q };
            }
            return S;
          }
        }
        class qr extends hr {
          constructor(a, f, g, b) {
            super(a, f, g, b), this.roundZoom = !0, this.type = "video", this.options = f;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1;
              const a = this.options;
              this.urls = [];
              for (const f of a.urls) this.urls.push(this.map._requestManager.transformRequest(f, "Source").url);
              try {
                const f = yield o.a5(this.urls);
                if (this._loaded = !0, !f) return;
                this.video = f, this.video.loop = !0, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (f) {
                this.fire(new o.k(f));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(a) {
            if (this.video) {
              const f = this.video.seekable;
              a < f.start(0) || a > f.end(0) ? this.fire(new o.k(new o.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${f.start(0)} and ${f.end(0)}-second mark.`))) : this.video.currentTime = a;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(a) {
            this.map || (this.map = a, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const a = this.map.painter.context, f = a.gl;
            this.texture ? this.video.paused || (this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE), f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, f.RGBA, f.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(a, this.video, f.RGBA), this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE));
            let g = !1;
            for (const b in this.tiles) {
              const w = this.tiles[b];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, g = !0);
            }
            g && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class xr extends hr {
          constructor(a, f, g, b) {
            super(a, f, g, b), f.coordinates ? Array.isArray(f.coordinates) && f.coordinates.length === 4 && !f.coordinates.some((w) => !Array.isArray(w) || w.length !== 2 || w.some((S) => typeof S != "number")) || this.fire(new o.k(new o.a6(`sources.${a}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a6(`sources.${a}`, null, 'missing required property "coordinates"'))), f.animate && typeof f.animate != "boolean" && this.fire(new o.k(new o.a6(`sources.${a}`, null, 'optional "animate" property must be a boolean value'))), f.canvas ? typeof f.canvas == "string" || f.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a6(`sources.${a}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a6(`sources.${a}`, null, 'missing required property "canvas"'))), this.options = f, this.animate = f.animate === void 0 || f.animate;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(a) {
            this.map = a, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let a = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, a = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, a = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const f = this.map.painter.context, g = f.gl;
            this.texture ? (a || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new o.T(f, this.canvas, g.RGBA, { premultiply: !0 });
            let b = !1;
            for (const w in this.tiles) {
              const S = this.tiles[w];
              S.state !== "loaded" && (S.state = "loaded", S.texture = this.texture, b = !0);
            }
            b && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const a of [this.canvas.width, this.canvas.height]) if (isNaN(a) || a <= 0) return !0;
            return !1;
          }
        }
        const bi = {}, Yr = (v) => {
          switch (v) {
            case "geojson":
              return Sr;
            case "image":
              return hr;
            case "raster":
              return Rr;
            case "raster-dem":
              return Jt;
            case "vector":
              return Zr;
            case "video":
              return qr;
            case "canvas":
              return xr;
          }
          return bi[v];
        }, Fr = "RTLPluginLoaded";
        class Ri extends o.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Tt();
          }
          _syncState(a) {
            return this.status = a, this.dispatcher.broadcast("SRPS", { pluginStatus: a, pluginURL: this.url }).catch((f) => {
              throw this.status = "error", f;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(a) {
            return o._(this, arguments, void 0, function* (f, g = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = P.resolveURL(f), !this.url) throw new Error(`requested url ${f} is invalid`);
              if (this.status === "unavailable") {
                if (!g) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            });
          }
          _requestImport() {
            return o._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new o.l(Fr));
            });
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Kr = null;
        function wr() {
          return Kr || (Kr = new Ri()), Kr;
        }
        var Ue, K;
        (function(v) {
          v[v.Base = 0] = "Base", v[v.Parent = 1] = "Parent";
        })(Ue || (Ue = {})), function(v) {
          v[v.Departing = 0] = "Departing", v[v.Incoming = 1] = "Incoming";
        }(K || (K = {}));
        class ne {
          constructor(a, f) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = a, this.uid = o.a7(), this.uses = 0, this.tileSize = f, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          isRenderable(a) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (a || !this.holdingForSymbolFade());
          }
          setCrossFadeLogic({ fadingRole: a, fadingDirection: f, fadingParentID: g, fadeEndTime: b }) {
            this.resetFadeLogic(), this.fadingRole = a, this.fadingDirection = f, this.fadingParentID = g, this.fadeEndTime = b;
          }
          setSelfFadeLogic(a) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = a;
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = D(), this.fadeEndTime = 0, this.fadeOpacity = 1;
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(a) {
            this.demTexture && a.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(a, f, g) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", a) {
              a.featureIndex && (this.latestFeatureIndex = a.featureIndex, a.rawTileData ? (this.latestRawTileData = a.rawTileData, this.latestFeatureIndex.rawTileData = a.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = a.collisionBoxArray, this.buckets = function(b, w) {
                const S = {};
                if (!w) return S;
                for (const R of b) {
                  const B = R.layerIds.map((U) => w.getLayer(U)).filter(Boolean);
                  if (B.length !== 0) {
                    R.layers = B, R.stateDependentLayerIds && (R.stateDependentLayers = R.stateDependentLayerIds.map((U) => B.filter((j) => j.id === U)[0]));
                    for (const U of B) S[U.id] = R;
                  }
                }
                return S;
              }(a.buckets, f?.style), this.hasSymbolBuckets = !1;
              for (const b in this.buckets) {
                const w = this.buckets[b];
                if (w instanceof o.a9) {
                  if (this.hasSymbolBuckets = !0, !g) break;
                  w.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const b in this.buckets) {
                const w = this.buckets[b];
                if (w instanceof o.a9 && w.hasRTLText) {
                  this.hasRTLText = !0, wr().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const b in this.buckets) {
                const w = this.buckets[b];
                this.queryPadding = Math.max(this.queryPadding, f.style.getLayer(b).queryRadius(w));
              }
              a.imageAtlas && (this.imageAtlas = a.imageAtlas), a.glyphAtlasImage && (this.glyphAtlasImage = a.glyphAtlasImage), this.dashPositions = a.dashPositions;
            } else this.collisionBoxArray = new o.a8();
          }
          unloadVectorData() {
            for (const a in this.buckets) this.buckets[a].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(a) {
            return this.buckets[a.id];
          }
          upload(a) {
            for (const g in this.buckets) {
              const b = this.buckets[g];
              b.uploadPending() && b.upload(a);
            }
            const f = a.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(a, this.imageAtlas.image, f.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(a, this.glyphAtlasImage, f.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(a) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(a, this.imageAtlasTexture);
          }
          queryRenderedFeatures(a, f, g, b, w, S, R, B, U, j, X) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: b, cameraQueryGeometry: w, scale: S, tileSize: this.tileSize, pixelPosMatrix: j, transform: B, params: R, queryPadding: this.queryPadding * U, getElevation: X }, a, f, g) : {};
          }
          querySourceFeatures(a, f) {
            const g = this.latestFeatureIndex;
            if (!g || !g.rawTileData) return;
            const b = g.loadVTLayers(), w = f && f.sourceLayer ? f.sourceLayer : "", S = b._geojsonTileLayer || b[w];
            if (!S) return;
            const R = o.aa(f?.filter, f?.globalState), { z: B, x: U, y: j } = this.tileID.canonical, X = { z: B, x: U, y: j };
            for (let q = 0; q < S.length; q++) {
              const Q = S.feature(q);
              if (R.needGeometry) {
                const Ae = o.ab(Q, !0);
                if (!R.filter(new o.F(this.tileID.overscaledZ), Ae, this.tileID.canonical)) continue;
              } else if (!R.filter(new o.F(this.tileID.overscaledZ), Q)) continue;
              const ce = g.getId(Q, w), we = new o.ac(Q, B, U, j, ce);
              we.tile = X, a.push(we);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(a) {
            const f = this.expirationTime;
            if (a.cacheControl) {
              const g = o.ad(a.cacheControl);
              g["max-age"] && (this.expirationTime = Date.now() + 1e3 * g["max-age"]);
            } else a.expires && (this.expirationTime = new Date(a.expires).getTime());
            if (this.expirationTime) {
              const g = Date.now();
              let b = !1;
              if (this.expirationTime > g) b = !1;
              else if (f)
                if (this.expirationTime < f) b = !0;
                else {
                  const w = this.expirationTime - f;
                  w ? this.expirationTime = g + Math.max(w, 3e4) : b = !0;
                }
              else b = !0;
              b ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(a, f) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(a).length === 0) return;
            const g = this.latestFeatureIndex.loadVTLayers();
            for (const b in this.buckets) {
              if (!f.style.hasLayer(b)) continue;
              const w = this.buckets[b], S = w.layers[0].sourceLayer || "_geojsonTileLayer", R = g[S], B = a[S];
              if (!R || !B || Object.keys(B).length === 0) continue;
              w.update(B, R, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const U = f && f.style && f.style.getLayer(b);
              U && (this.queryPadding = Math.max(this.queryPadding, U.queryRadius(w)));
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < D();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(a) {
            this.symbolFadeHoldUntil = D() + a;
          }
          setDependencies(a, f) {
            const g = {};
            for (const b of f) g[b] = !0;
            this.dependencies[a] = g;
          }
          hasDependency(a, f) {
            for (const g of a) {
              const b = this.dependencies[g];
              if (b) {
                for (const w of f) if (b[w]) return !0;
              }
            }
            return !1;
          }
        }
        class de {
          constructor(a, f) {
            this.max = a, this.onRemove = f, this.reset();
          }
          reset() {
            for (const a in this.data) for (const f of this.data[a]) f.timeout && clearTimeout(f.timeout), this.onRemove(f.value);
            return this.data = {}, this.order = [], this;
          }
          add(a, f, g) {
            const b = a.wrapped().key;
            this.data[b] === void 0 && (this.data[b] = []);
            const w = { value: f, timeout: void 0 };
            if (g !== void 0 && (w.timeout = setTimeout(() => {
              this.remove(a, w);
            }, g)), this.data[b].push(w), this.order.push(b), this.order.length > this.max) {
              const S = this._getAndRemoveByKey(this.order[0]);
              S && this.onRemove(S);
            }
            return this;
          }
          has(a) {
            return a.wrapped().key in this.data;
          }
          getAndRemove(a) {
            return this.has(a) ? this._getAndRemoveByKey(a.wrapped().key) : null;
          }
          _getAndRemoveByKey(a) {
            const f = this.data[a].shift();
            return f.timeout && clearTimeout(f.timeout), this.data[a].length === 0 && delete this.data[a], this.order.splice(this.order.indexOf(a), 1), f.value;
          }
          getByKey(a) {
            const f = this.data[a];
            return f ? f[0].value : null;
          }
          get(a) {
            return this.has(a) ? this.data[a.wrapped().key][0].value : null;
          }
          remove(a, f) {
            if (!this.has(a)) return this;
            const g = a.wrapped().key, b = f === void 0 ? 0 : this.data[g].indexOf(f), w = this.data[g][b];
            return this.data[g].splice(b, 1), w.timeout && clearTimeout(w.timeout), this.data[g].length === 0 && delete this.data[g], this.onRemove(w.value), this.order.splice(this.order.indexOf(g), 1), this;
          }
          setMaxSize(a) {
            for (this.max = a; this.order.length > this.max; ) {
              const f = this._getAndRemoveByKey(this.order[0]);
              f && this.onRemove(f);
            }
            return this;
          }
          filter(a) {
            const f = [];
            for (const g in this.data) for (const b of this.data[g]) a(b.value) || f.push(b);
            for (const g of f) this.remove(g.value.tileID, g);
          }
        }
        class Te {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(a, f, g) {
            const b = String(f);
            if (this.stateChanges[a] = this.stateChanges[a] || {}, this.stateChanges[a][b] = this.stateChanges[a][b] || {}, o.e(this.stateChanges[a][b], g), this.deletedStates[a] === null) {
              this.deletedStates[a] = {};
              for (const w in this.state[a]) w !== b && (this.deletedStates[a][w] = null);
            } else if (this.deletedStates[a] && this.deletedStates[a][b] === null) {
              this.deletedStates[a][b] = {};
              for (const w in this.state[a][b]) g[w] || (this.deletedStates[a][b][w] = null);
            } else for (const w in g) this.deletedStates[a] && this.deletedStates[a][b] && this.deletedStates[a][b][w] === null && delete this.deletedStates[a][b][w];
          }
          removeFeatureState(a, f, g) {
            if (this.deletedStates[a] === null) return;
            const b = String(f);
            if (this.deletedStates[a] = this.deletedStates[a] || {}, g && f !== void 0) this.deletedStates[a][b] !== null && (this.deletedStates[a][b] = this.deletedStates[a][b] || {}, this.deletedStates[a][b][g] = null);
            else if (f !== void 0)
              if (this.stateChanges[a] && this.stateChanges[a][b]) for (g in this.deletedStates[a][b] = {}, this.stateChanges[a][b]) this.deletedStates[a][b][g] = null;
              else this.deletedStates[a][b] = null;
            else this.deletedStates[a] = null;
          }
          getState(a, f) {
            const g = String(f), b = o.e({}, (this.state[a] || {})[g], (this.stateChanges[a] || {})[g]);
            if (this.deletedStates[a] === null) return {};
            if (this.deletedStates[a]) {
              const w = this.deletedStates[a][f];
              if (w === null) return {};
              for (const S in w) delete b[S];
            }
            return b;
          }
          initializeTileState(a, f) {
            a.setFeatureState(this.state, f);
          }
          coalesceChanges(a, f) {
            const g = {};
            for (const b in this.stateChanges) {
              this.state[b] = this.state[b] || {};
              const w = {};
              for (const S in this.stateChanges[b]) this.state[b][S] || (this.state[b][S] = {}), o.e(this.state[b][S], this.stateChanges[b][S]), w[S] = this.state[b][S];
              g[b] = w;
            }
            for (const b in this.deletedStates) {
              this.state[b] = this.state[b] || {};
              const w = {};
              if (this.deletedStates[b] === null) for (const S in this.state[b]) w[S] = {}, this.state[b][S] = {};
              else for (const S in this.deletedStates[b]) {
                if (this.deletedStates[b][S] === null) this.state[b][S] = {};
                else for (const R of Object.keys(this.deletedStates[b][S])) delete this.state[b][S][R];
                w[S] = this.state[b][S];
              }
              g[b] = g[b] || {}, o.e(g[b], w);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(g).length !== 0) for (const b in a) a[b].setFeatureState(g, f);
          }
        }
        const Pe = 89.25;
        function qe(v, a) {
          const f = o.ae(a.lat, -o.af, o.af);
          return new o.P(o.V(a.lng) * v, o.U(f) * v);
        }
        function Je(v, a) {
          return new o.a1(a.x / v, a.y / v).toLngLat();
        }
        function He(v) {
          return v.cameraToCenterDistance * Math.min(0.85 * Math.tan(o.ag(90 - v.pitch)), Math.tan(o.ag(Pe - v.pitch)));
        }
        function nt(v, a) {
          const f = v.canonical, g = a / o.ah(f.z), b = f.x + Math.pow(2, f.z) * v.wrap, w = o.ai(new Float64Array(16));
          return o.M(w, w, [b * g, f.y * g, 0]), o.N(w, w, [g / o.$, g / o.$, 1]), w;
        }
        function Bt(v, a, f, g, b) {
          const w = o.a1.fromLngLat(v, a), S = b * o.aj(1, v.lat), R = S * Math.cos(o.ag(f)), B = Math.sqrt(S * S - R * R), U = B * Math.sin(o.ag(-g)), j = B * Math.cos(o.ag(-g));
          return new o.a1(w.x + U, w.y + j, w.z + R);
        }
        function It(v, a, f) {
          const g = a.intersectsFrustum(v);
          if (!f || g === 0) return g;
          const b = a.intersectsPlane(f);
          return b === 0 ? 0 : g === 2 && b === 2 ? 2 : 1;
        }
        function rr(v, a, f) {
          let g = 0;
          const b = (f - a) / 10;
          for (let w = 0; w < 10; w++) g += b * Math.pow(Math.cos(a + (w + 0.5) / 10 * (f - a)), v);
          return g;
        }
        function We(v, a) {
          return function(f, g, b, w, S) {
            const R = 2 * ((v - 1) / o.ak(Math.cos(o.ag(Pe - S)) / Math.cos(o.ag(Pe))) - 1), B = Math.acos(b / w), U = 2 * rr(R - 1, 0, o.ag(S / 2)), j = Math.min(o.ag(Pe), B + o.ag(S / 2)), X = rr(R - 1, Math.min(j, B - o.ag(S / 2)), j), q = Math.atan(g / b), Q = Math.hypot(g, b);
            let ce = f;
            return ce += o.ak(w / Q / Math.max(0.5, Math.cos(o.ag(S / 2)))), ce += R * o.ak(Math.cos(q)) / 2, ce -= o.ak(Math.max(1, X / U / a)) / 2, ce;
          };
        }
        const mr = We(9.314, 3);
        function Li(v, a) {
          const f = (a.roundZoom ? Math.round : Math.floor)(v.zoom + o.ak(v.tileSize / a.tileSize));
          return Math.max(0, f);
        }
        function fr(v, a) {
          const f = v.getCameraFrustum(), g = v.getClippingPlane(), b = v.screenPointToMercatorCoordinate(v.getCameraPoint()), w = o.a1.fromLngLat(v.center, v.elevation);
          b.z = w.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
          const S = v.getCoveringTilesDetailsProvider(), R = S.allowVariableZoom(v, a), B = Li(v, a), U = a.minzoom || 0, j = a.maxzoom !== void 0 ? a.maxzoom : v.maxZoom, X = Math.min(Math.max(0, B), j), q = Math.pow(2, X), Q = [q * b.x, q * b.y, 0], ce = [q * w.x, q * w.y, 0], we = Math.hypot(w.x - b.x, w.y - b.y), Ae = Math.abs(w.z - b.z), Se = Math.hypot(we, Ae), Me = ($e) => ({ zoom: 0, x: 0, y: 0, wrap: $e, fullyVisible: !1 }), Ge = [], Le = [];
          if (v.renderWorldCopies && S.allowWorldCopies()) for (let $e = 1; $e <= 3; $e++) Ge.push(Me(-$e)), Ge.push(Me($e));
          for (Ge.push(Me(0)); Ge.length > 0; ) {
            const $e = Ge.pop(), Xe = $e.x, Fe = $e.y;
            let Qe = $e.fullyVisible;
            const At = { x: Xe, y: Fe, z: $e.zoom }, ft = S.getTileBoundingVolume(At, $e.wrap, v.elevation, a);
            if (!Qe) {
              const Zt = It(f, ft, g);
              if (Zt === 0) continue;
              Qe = Zt === 2;
            }
            const dt = S.distanceToTile2d(b.x, b.y, At, ft);
            let _t = B;
            R && (_t = (a.calculateTileZoom || mr)(v.zoom + o.ak(v.tileSize / a.tileSize), dt, Ae, Se, v.fov)), _t = (a.roundZoom ? Math.round : Math.floor)(_t), _t = Math.max(0, _t);
            const qt = Math.min(_t, j);
            if ($e.wrap = S.getWrap(w, At, $e.wrap), $e.zoom >= qt) {
              if ($e.zoom < U) continue;
              const Zt = X - $e.zoom, zt = Q[0] - 0.5 - (Xe << Zt), pr = Q[1] - 0.5 - (Fe << Zt), Vr = a.reparseOverscaled ? Math.max($e.zoom, _t) : $e.zoom;
              Le.push({ tileID: new o.Z($e.zoom === j ? Vr : $e.zoom, $e.wrap, $e.zoom, Xe, Fe), distanceSq: o.al([ce[0] - 0.5 - Xe, ce[1] - 0.5 - Fe]), tileDistanceToCamera: Math.sqrt(zt * zt + pr * pr) });
            } else for (let Zt = 0; Zt < 4; Zt++) Ge.push({ zoom: $e.zoom + 1, x: (Xe << 1) + Zt % 2, y: (Fe << 1) + (Zt >> 1), wrap: $e.wrap, fullyVisible: Qe });
          }
          return Le.sort(($e, Xe) => $e.distanceSq - Xe.distanceSq).map(($e) => $e.tileID);
        }
        const Hr = o.a2.fromPoints([new o.P(0, 0), new o.P(o.$, o.$)]);
        class li extends o.E {
          constructor(a, f, g) {
            super(), this.id = a, this.dispatcher = g, this.on("data", (b) => this._dataHandler(b)), this.on("dataloading", () => {
              this._sourceErrored = !1;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((b, w, S, R) => {
              const B = new (Yr(w.type))(b, w, S, R);
              if (B.id !== b) throw new Error(`Expected Source id to be ${b} instead of ${B.id}`);
              return B;
            })(a, f, g, this), this._tiles = {}, this._cache = new de(0, (b) => this._unloadTile(b)), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Te(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(a) {
            this.map = a, this._maxTileCacheSize = a ? a._maxTileCacheSize : null, this._maxTileCacheZoomLevels = a ? a._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(a);
          }
          onRemove(a) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(a);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const a in this._tiles) {
              const f = this._tiles[a];
              if (f.state !== "loaded" && f.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const a = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, a && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(a, f, g) {
            return o._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(a), this._tileLoaded(a, f, g);
              } catch (b) {
                a.state = "errored", b.status !== 404 ? this._source.fire(new o.k(b, { tile: a })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(a) {
            this._source.unloadTile && this._source.unloadTile(a);
          }
          _abortTile(a) {
            this._source.abortTile && this._source.abortTile(a), this._source.fire(new o.l("dataabort", { tile: a, coord: a.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(a) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const f in this._tiles) {
              const g = this._tiles[f];
              g.upload(a), g.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((a) => a.tileID).sort(_r).map((a) => a.key);
          }
          getRenderableIds(a) {
            const f = [];
            for (const g in this._tiles) this._isIdRenderable(g, a) && f.push(this._tiles[g]);
            return a ? f.sort((g, b) => {
              const w = g.tileID, S = b.tileID, R = new o.P(w.canonical.x, w.canonical.y)._rotate(-this.transform.bearingInRadians), B = new o.P(S.canonical.x, S.canonical.y)._rotate(-this.transform.bearingInRadians);
              return w.overscaledZ - S.overscaledZ || B.y - R.y || B.x - R.x;
            }).map((g) => g.tileID.key) : f.map((g) => g.tileID).sort(_r).map((g) => g.key);
          }
          hasRenderableParent(a) {
            const f = a.overscaledZ - 1;
            if (f >= this._source.minzoom) {
              const g = this._getLoadedTile(a.scaledTo(f));
              if (g) return this._isIdRenderable(g.tileID.key);
            }
            return !1;
          }
          _isIdRenderable(a, f = !1) {
            var g;
            return (g = this._tiles[a]) === null || g === void 0 ? void 0 : g.isRenderable(f);
          }
          reload(a) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const f in this._tiles) a ? this._reloadTile(f, "expired") : this._tiles[f].state !== "errored" && this._reloadTile(f, "reloading");
            }
          }
          _reloadTile(a, f) {
            return o._(this, void 0, void 0, function* () {
              const g = this._tiles[a];
              g && (g.state !== "loading" && (g.state = f), yield this._loadTile(g, a, f));
            });
          }
          _tileLoaded(a, f, g) {
            a.timeAdded = D(), g === "expired" && (a.refreshedUponExpiration = !0), this._setTileReloadTimer(f, a), this.getSource().type === "raster-dem" && a.dem && this._backfillDEM(a), this._state.initializeTileState(a, this.map ? this.map.painter : null), a.aborted || this._source.fire(new o.l("data", { dataType: "source", tile: a, coord: a.tileID }));
          }
          _backfillDEM(a) {
            const f = this.getRenderableIds();
            for (let b = 0; b < f.length; b++) {
              const w = f[b];
              if (a.neighboringTiles && a.neighboringTiles[w]) {
                const S = this.getTileByID(w);
                g(a, S), g(S, a);
              }
            }
            function g(b, w) {
              b.needsHillshadePrepare = !0, b.needsTerrainPrepare = !0;
              let S = w.tileID.canonical.x - b.tileID.canonical.x;
              const R = w.tileID.canonical.y - b.tileID.canonical.y, B = Math.pow(2, b.tileID.canonical.z), U = w.tileID.key;
              S === 0 && R === 0 || Math.abs(R) > 1 || (Math.abs(S) > 1 && (Math.abs(S + B) === 1 ? S += B : Math.abs(S - B) === 1 && (S -= B)), w.dem && b.dem && (b.dem.backfillBorder(w.dem, S, R), b.neighboringTiles && b.neighboringTiles[U] && (b.neighboringTiles[U].backfilled = !0)));
            }
          }
          getTile(a) {
            return this.getTileByID(a.key);
          }
          getTileByID(a) {
            return this._tiles[a];
          }
          _retainLoadedChildren(a, f) {
            const g = Object.values(a), b = this._getLoadedDescendents(g), w = {};
            for (const S of g) {
              const R = b[S.key];
              if (!R?.length) {
                w[S.key] = S;
                continue;
              }
              const B = S.overscaledZ + li.maxUnderzooming, U = R.filter((q) => q.tileID.overscaledZ <= B);
              if (!U.length) {
                w[S.key] = S;
                continue;
              }
              const j = Math.min(...U.map((q) => q.tileID.overscaledZ)), X = U.filter((q) => q.tileID.overscaledZ === j).map((q) => q.tileID);
              for (const q of X) f[q.key] = q;
              this._areDescendentsComplete(X, j, S.overscaledZ) || (w[S.key] = S);
            }
            return w;
          }
          _getLoadedDescendents(a) {
            var f;
            const g = {};
            for (const b in this._tiles) {
              const w = this._tiles[b];
              if (w.hasData()) for (const S of a) w.tileID.isChildOf(S) && (g[f = S.key] || (g[f] = [])).push(w);
            }
            return g;
          }
          _areDescendentsComplete(a, f, g) {
            return a.length === 1 && a[0].isOverscaled() ? a[0].overscaledZ === f : Math.pow(4, f - g) === a.length;
          }
          _getLoadedTile(a) {
            const f = this._tiles[a.key];
            return f?.hasData() ? f : null;
          }
          updateCacheSize(a) {
            const f = Math.ceil(a.width / this._source.tileSize) + 1, g = Math.ceil(a.height / this._source.tileSize) + 1, b = Math.floor(f * g * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), w = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, b) : b;
            this._cache.setMaxSize(w);
          }
          handleWrapJump(a) {
            const f = Math.round((a - (this._prevLng === void 0 ? a : this._prevLng)) / 360);
            if (this._prevLng = a, f) {
              const g = {};
              for (const b in this._tiles) {
                const w = this._tiles[b];
                w.tileID = w.tileID.unwrapTo(w.tileID.wrap + f), g[w.tileID.key] = w;
              }
              this._tiles = g, this._resetTileReloadTimers();
            }
          }
          update(a, f) {
            if (!this._sourceLoaded || this._paused) return;
            let g;
            this.transform = a, this.terrain = f, this.updateCacheSize(a), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? g = a.getVisibleUnwrappedCoordinates(this._source.tileID).map((B) => new o.Z(B.canonical.z, B.wrap, B.canonical.z, B.canonical.x, B.canonical.y)) : (g = fr(a, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: f, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (g = g.filter((B) => this._source.hasTile(B)))) : g = [], this.usedForTerrain && (g = this._addTerrainIdealTiles(g));
            const b = g.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, b && this.fire(new o.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const w = Li(a, this._source), S = this._updateRetainedTiles(g, w), R = qi(this._source.type);
            R && this._rasterFadeDuration > 0 && !f && this._updateFadingTiles(g, S), R ? this._cleanUpRasterTiles(S) : this._cleanUpVectorTiles(S);
          }
          _cleanUpRasterTiles(a) {
            for (const f in this._tiles) a[f] || this._removeTile(f);
          }
          _cleanUpVectorTiles(a) {
            for (const f in this._tiles) {
              const g = this._tiles[f];
              a[f] ? g.clearSymbolFadeHold() : g.hasSymbolBuckets ? g.holdingForSymbolFade() ? g.symbolFadeFinished() && this._removeTile(f) : g.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(f);
            }
          }
          _addTerrainIdealTiles(a) {
            const f = [];
            for (const g of a) if (g.canonical.z > this._source.minzoom) {
              const b = g.scaledTo(g.canonical.z - 1);
              f.push(b);
              const w = g.scaledTo(Math.max(this._source.minzoom, Math.min(g.canonical.z, 5)));
              f.push(w);
            }
            return a.concat(f);
          }
          releaseSymbolFadeTiles() {
            for (const a in this._tiles) this._tiles[a].holdingForSymbolFade() && this._removeTile(a);
          }
          _updateRetainedTiles(a, f) {
            var g;
            const b = {}, w = {}, S = Math.max(f - li.maxOverzooming, this._source.minzoom);
            let R = {};
            for (const B of a) {
              const U = this._addTile(B);
              b[B.key] = B, U.hasData() || (R[B.key] = B);
            }
            R = this._retainLoadedChildren(R, b);
            for (const B in R) {
              const U = R[B];
              let j = this._tiles[B], X = j?.wasRequested();
              for (let q = U.overscaledZ - 1; q >= S; --q) {
                const Q = U.scaledTo(q);
                if (w[Q.key]) break;
                if (w[Q.key] = !0, j = this.getTile(Q), !j && X && (j = this._addTile(Q)), j) {
                  const ce = j.hasData();
                  if ((ce || !(!((g = this.map) === null || g === void 0) && g.cancelPendingTileRequestsWhileZooming) || X) && (b[Q.key] = Q), X = j.wasRequested(), ce) break;
                }
              }
            }
            return b;
          }
          _updateFadingTiles(a, f) {
            const g = D(), b = o.am(a);
            for (const w of a) {
              const S = this._tiles[w.key];
              S.fadingDirection !== K.Departing && S.fadeOpacity !== 0 || S.resetFadeLogic(), this._updateFadingAncestor(S, f, g) || this._updateFadingDescendents(S, f, g) || this._updateFadingEdge(S, b, g) || S.resetFadeLogic();
            }
          }
          _updateFadingAncestor(a, f, g) {
            if (!a.hasData()) return !1;
            const { tileID: b, fadingRole: w, fadingDirection: S, fadingParentID: R } = a;
            if (w === Ue.Base && S === K.Incoming && R) return f[R.key] = R, !0;
            const B = Math.max(b.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let U = b.overscaledZ - 1; U >= B; U--) {
              const j = b.scaledTo(U), X = this._getLoadedTile(j);
              if (X) return a.setCrossFadeLogic({ fadingRole: Ue.Base, fadingDirection: K.Incoming, fadingParentID: X.tileID, fadeEndTime: g + this._rasterFadeDuration }), X.setCrossFadeLogic({ fadingRole: Ue.Parent, fadingDirection: K.Departing, fadeEndTime: g + this._rasterFadeDuration }), f[j.key] = j, !0;
            }
            return !1;
          }
          _updateFadingDescendents(a, f, g) {
            if (!a.hasData()) return !1;
            const b = a.tileID.children(this._source.maxzoom);
            let w = this._updateFadingChildren(a, b, f, g);
            if (w) return !0;
            for (const S of b) {
              const R = S.children(this._source.maxzoom);
              this._updateFadingChildren(a, R, f, g) && (w = !0);
            }
            return w;
          }
          _updateFadingChildren(a, f, g, b) {
            if (f[0].overscaledZ >= this._source.maxzoom) return !1;
            let w = !1;
            for (const S of f) {
              const R = this._getLoadedTile(S);
              if (!R) continue;
              const { fadingRole: B, fadingDirection: U, fadingParentID: j } = R;
              B === Ue.Base && U === K.Departing && j || (R.setCrossFadeLogic({ fadingRole: Ue.Base, fadingDirection: K.Departing, fadingParentID: a.tileID, fadeEndTime: b + this._rasterFadeDuration }), a.setCrossFadeLogic({ fadingRole: Ue.Parent, fadingDirection: K.Incoming, fadeEndTime: b + this._rasterFadeDuration })), g[S.key] = S, w = !0;
            }
            return w;
          }
          _updateFadingEdge(a, f, g) {
            const b = a.tileID;
            return !!a.selfFading || !a.hasData() && !!f.has(b) && (a.setSelfFadeLogic(g + this._rasterFadeDuration), !0);
          }
          _addTile(a) {
            let f = this._tiles[a.key];
            if (f) return f;
            f = this._cache.getAndRemove(a), f && (f.resetFadeLogic(), this._setTileReloadTimer(a.key, f), f.tileID = a, this._state.initializeTileState(f, this.map ? this.map.painter : null));
            const g = f;
            return f || (f = new ne(a, this._source.tileSize * a.overscaleFactor()), this._loadTile(f, a.key, f.state)), f.uses++, this._tiles[a.key] = f, g || this._source.fire(new o.l("dataloading", { tile: f, coord: f.tileID, dataType: "source" })), f;
          }
          _setTileReloadTimer(a, f) {
            this._clearTileReloadTimer(a);
            const g = f.getExpiryTimeout();
            g && (this._timers[a] = setTimeout(() => {
              this._reloadTile(a, "expired"), delete this._timers[a];
            }, g));
          }
          _clearTileReloadTimer(a) {
            const f = this._timers[a];
            f && (clearTimeout(f), delete this._timers[a]);
          }
          _resetTileReloadTimers() {
            for (const a in this._timers) clearTimeout(this._timers[a]), delete this._timers[a];
            for (const a in this._tiles) this._setTileReloadTimer(a, this._tiles[a]);
          }
          refreshTiles(a) {
            for (const f in this._tiles) (this._isIdRenderable(f) || this._tiles[f].state == "errored") && a.some((g) => g.equals(this._tiles[f].tileID.canonical)) && this._reloadTile(f, "expired");
          }
          _removeTile(a) {
            const f = this._tiles[a];
            f && (f.uses--, delete this._tiles[a], this._clearTileReloadTimer(a), f.uses > 0 || (f.hasData() && f.state !== "reloading" ? this._cache.add(f.tileID, f, f.getExpiryTimeout()) : (f.aborted = !0, this._abortTile(f), this._unloadTile(f))));
          }
          _dataHandler(a) {
            a.dataType === "source" && (a.sourceDataType !== "metadata" ? a.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(a.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const a in this._tiles) this._removeTile(a);
            this._cache.reset();
          }
          tilesIn(a, f, g) {
            const b = [], w = this.transform;
            if (!w) return b;
            const S = w.getCoveringTilesDetailsProvider().allowWorldCopies(), R = g ? w.getCameraQueryGeometry(a) : a, B = (Q) => w.screenPointToMercatorCoordinate(Q, this.terrain), U = this.transformBbox(a, B, !S), j = this.transformBbox(R, B, !S), X = this.getIds(), q = o.a2.fromPoints(j);
            for (let Q = 0; Q < X.length; Q++) {
              const ce = this._tiles[X[Q]];
              if (ce.holdingForSymbolFade()) continue;
              const we = S ? [ce.tileID] : [ce.tileID.unwrapTo(-1), ce.tileID.unwrapTo(0)], Ae = Math.pow(2, w.zoom - ce.tileID.overscaledZ), Se = f * ce.queryPadding * o.$ / ce.tileSize / Ae;
              for (const Me of we) {
                const Ge = q.map((Le) => Me.getTilePoint(new o.a1(Le.x, Le.y)));
                if (Ge.expandBy(Se), Ge.intersects(Hr)) {
                  const Le = U.map((Xe) => Me.getTilePoint(Xe)), $e = j.map((Xe) => Me.getTilePoint(Xe));
                  b.push({ tile: ce, tileID: S ? Me : Me.unwrapTo(0), queryGeometry: Le, cameraQueryGeometry: $e, scale: Ae });
                }
              }
            }
            return b;
          }
          transformBbox(a, f, g) {
            let b = a.map(f);
            if (g) {
              const w = o.a2.fromPoints(a);
              w.shrinkBy(1e-3 * Math.min(w.width(), w.height()));
              const S = w.map(f);
              o.a2.fromPoints(b).covers(S) || (b = b.map((R) => R.x > 0.5 ? new o.a1(R.x - 1, R.y, R.z) : R));
            }
            return b;
          }
          getVisibleCoordinates(a) {
            const f = this.getRenderableIds(a).map((g) => this._tiles[g].tileID);
            return this.transform && this.transform.populateCache(f), f;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (qi(this._source.type) && this._rasterFadeDuration > 0) {
              const a = D();
              for (const f in this._tiles) if (this._tiles[f].fadeEndTime >= a) return !0;
            }
            return !1;
          }
          setRasterFadeDuration(a) {
            this._rasterFadeDuration = a;
          }
          setFeatureState(a, f, g) {
            this._state.updateState(a = a || "_geojsonTileLayer", f, g);
          }
          removeFeatureState(a, f, g) {
            this._state.removeFeatureState(a = a || "_geojsonTileLayer", f, g);
          }
          getFeatureState(a, f) {
            return this._state.getState(a = a || "_geojsonTileLayer", f);
          }
          setDependencies(a, f, g) {
            const b = this._tiles[a];
            b && b.setDependencies(f, g);
          }
          reloadTilesForDependencies(a, f) {
            for (const g in this._tiles) this._tiles[g].hasDependency(a, f) && this._reloadTile(g, "reloading");
            this._cache.filter((g) => !g.hasDependency(a, f));
          }
        }
        function _r(v, a) {
          const f = Math.abs(2 * v.wrap) - +(v.wrap < 0), g = Math.abs(2 * a.wrap) - +(a.wrap < 0);
          return v.overscaledZ - a.overscaledZ || g - f || a.canonical.y - v.canonical.y || a.canonical.x - v.canonical.x;
        }
        function qi(v) {
          return v === "raster" || v === "image" || v === "video";
        }
        li.maxOverzooming = 10, li.maxUnderzooming = 3;
        class nn {
          constructor(a, f) {
            this.reset(a, f);
          }
          reset(a, f) {
            this.points = a || [], this._distances = [0];
            for (let g = 1; g < this.points.length; g++) this._distances[g] = this._distances[g - 1] + this.points[g].dist(this.points[g - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(f || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(a) {
            if (this.points.length === 1) return this.points[0];
            a = o.ae(a, 0, 1);
            let f = 1, g = this._distances[f];
            const b = a * this.paddedLength + this.padding;
            for (; g < b && f < this._distances.length; ) g = this._distances[++f];
            const w = f - 1, S = this._distances[w], R = g - S, B = R > 0 ? (b - S) / R : 0;
            return this.points[w].mult(1 - B).add(this.points[f].mult(B));
          }
        }
        function Ei(v, a) {
          let f = !0;
          return v === "always" || v !== "never" && a !== "never" || (f = !1), f;
        }
        class vi {
          constructor(a, f, g) {
            const b = this.boxCells = [], w = this.circleCells = [];
            this.xCellCount = Math.ceil(a / g), this.yCellCount = Math.ceil(f / g);
            for (let S = 0; S < this.xCellCount * this.yCellCount; S++) b.push([]), w.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = a, this.height = f, this.xScale = this.xCellCount / a, this.yScale = this.yCellCount / f, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(a, f, g, b, w) {
            this._forEachCell(f, g, b, w, this._insertBoxCell, this.boxUid++), this.boxKeys.push(a), this.bboxes.push(f), this.bboxes.push(g), this.bboxes.push(b), this.bboxes.push(w);
          }
          insertCircle(a, f, g, b) {
            this._forEachCell(f - b, g - b, f + b, g + b, this._insertCircleCell, this.circleUid++), this.circleKeys.push(a), this.circles.push(f), this.circles.push(g), this.circles.push(b);
          }
          _insertBoxCell(a, f, g, b, w, S) {
            this.boxCells[w].push(S);
          }
          _insertCircleCell(a, f, g, b, w, S) {
            this.circleCells[w].push(S);
          }
          _query(a, f, g, b, w, S, R) {
            if (g < 0 || a > this.width || b < 0 || f > this.height) return [];
            const B = [];
            if (a <= 0 && f <= 0 && this.width <= g && this.height <= b) {
              if (w) return [{ key: null, x1: a, y1: f, x2: g, y2: b }];
              for (let U = 0; U < this.boxKeys.length; U++) B.push({ key: this.boxKeys[U], x1: this.bboxes[4 * U], y1: this.bboxes[4 * U + 1], x2: this.bboxes[4 * U + 2], y2: this.bboxes[4 * U + 3] });
              for (let U = 0; U < this.circleKeys.length; U++) {
                const j = this.circles[3 * U], X = this.circles[3 * U + 1], q = this.circles[3 * U + 2];
                B.push({ key: this.circleKeys[U], x1: j - q, y1: X - q, x2: j + q, y2: X + q });
              }
            } else this._forEachCell(a, f, g, b, this._queryCell, B, { hitTest: w, overlapMode: S, seenUids: { box: {}, circle: {} } }, R);
            return B;
          }
          query(a, f, g, b) {
            return this._query(a, f, g, b, !1, null);
          }
          hitTest(a, f, g, b, w, S) {
            return this._query(a, f, g, b, !0, w, S).length > 0;
          }
          hitTestCircle(a, f, g, b, w) {
            const S = a - g, R = a + g, B = f - g, U = f + g;
            if (R < 0 || S > this.width || U < 0 || B > this.height) return !1;
            const j = [];
            return this._forEachCell(S, B, R, U, this._queryCellCircle, j, { hitTest: !0, overlapMode: b, circle: { x: a, y: f, radius: g }, seenUids: { box: {}, circle: {} } }, w), j.length > 0;
          }
          _queryCell(a, f, g, b, w, S, R, B) {
            const { seenUids: U, hitTest: j, overlapMode: X } = R, q = this.boxCells[w];
            if (q !== null) {
              const ce = this.bboxes;
              for (const we of q) if (!U.box[we]) {
                U.box[we] = !0;
                const Ae = 4 * we, Se = this.boxKeys[we];
                if (a <= ce[Ae + 2] && f <= ce[Ae + 3] && g >= ce[Ae + 0] && b >= ce[Ae + 1] && (!B || B(Se)) && (!j || !Ei(X, Se.overlapMode)) && (S.push({ key: Se, x1: ce[Ae], y1: ce[Ae + 1], x2: ce[Ae + 2], y2: ce[Ae + 3] }), j)) return !0;
              }
            }
            const Q = this.circleCells[w];
            if (Q !== null) {
              const ce = this.circles;
              for (const we of Q) if (!U.circle[we]) {
                U.circle[we] = !0;
                const Ae = 3 * we, Se = this.circleKeys[we];
                if (this._circleAndRectCollide(ce[Ae], ce[Ae + 1], ce[Ae + 2], a, f, g, b) && (!B || B(Se)) && (!j || !Ei(X, Se.overlapMode))) {
                  const Me = ce[Ae], Ge = ce[Ae + 1], Le = ce[Ae + 2];
                  if (S.push({ key: Se, x1: Me - Le, y1: Ge - Le, x2: Me + Le, y2: Ge + Le }), j) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(a, f, g, b, w, S, R, B) {
            const { circle: U, seenUids: j, overlapMode: X } = R, q = this.boxCells[w];
            if (q !== null) {
              const ce = this.bboxes;
              for (const we of q) if (!j.box[we]) {
                j.box[we] = !0;
                const Ae = 4 * we, Se = this.boxKeys[we];
                if (this._circleAndRectCollide(U.x, U.y, U.radius, ce[Ae + 0], ce[Ae + 1], ce[Ae + 2], ce[Ae + 3]) && (!B || B(Se)) && !Ei(X, Se.overlapMode)) return S.push(!0), !0;
              }
            }
            const Q = this.circleCells[w];
            if (Q !== null) {
              const ce = this.circles;
              for (const we of Q) if (!j.circle[we]) {
                j.circle[we] = !0;
                const Ae = 3 * we, Se = this.circleKeys[we];
                if (this._circlesCollide(ce[Ae], ce[Ae + 1], ce[Ae + 2], U.x, U.y, U.radius) && (!B || B(Se)) && !Ei(X, Se.overlapMode)) return S.push(!0), !0;
              }
            }
          }
          _forEachCell(a, f, g, b, w, S, R, B) {
            const U = this._convertToXCellCoord(a), j = this._convertToYCellCoord(f), X = this._convertToXCellCoord(g), q = this._convertToYCellCoord(b);
            for (let Q = U; Q <= X; Q++) for (let ce = j; ce <= q; ce++) if (w.call(this, a, f, g, b, this.xCellCount * ce + Q, S, R, B)) return;
          }
          _convertToXCellCoord(a) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(a * this.xScale)));
          }
          _convertToYCellCoord(a) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(a * this.yScale)));
          }
          _circlesCollide(a, f, g, b, w, S) {
            const R = b - a, B = w - f, U = g + S;
            return U * U > R * R + B * B;
          }
          _circleAndRectCollide(a, f, g, b, w, S, R) {
            const B = (S - b) / 2, U = Math.abs(a - (b + B));
            if (U > B + g) return !1;
            const j = (R - w) / 2, X = Math.abs(f - (w + j));
            if (X > j + g) return !1;
            if (U <= B || X <= j) return !0;
            const q = U - B, Q = X - j;
            return q * q + Q * Q <= g * g;
          }
        }
        function ci(v, a, f) {
          const g = o.L();
          if (!v) {
            const { vecSouth: X, vecEast: q } = pi(a), Q = m();
            Q[0] = q[0], Q[1] = q[1], Q[2] = X[0], Q[3] = X[1], b = Q, (j = (S = (w = Q)[0]) * (U = w[3]) - (B = w[2]) * (R = w[1])) && (b[0] = U * (j = 1 / j), b[1] = -R * j, b[2] = -B * j, b[3] = S * j), g[0] = Q[0], g[1] = Q[1], g[4] = Q[2], g[5] = Q[3];
          }
          var b, w, S, R, B, U, j;
          return o.N(g, g, [1 / f, 1 / f, 1]), g;
        }
        function Lt(v, a, f, g) {
          if (v) {
            const b = o.L();
            if (!a) {
              const { vecSouth: w, vecEast: S } = pi(f);
              b[0] = S[0], b[1] = S[1], b[4] = w[0], b[5] = w[1];
            }
            return o.N(b, b, [g, g, 1]), b;
          }
          return f.pixelsToClipSpaceMatrix;
        }
        function pi(v) {
          const a = Math.cos(v.rollInRadians), f = Math.sin(v.rollInRadians), g = Math.cos(v.pitchInRadians), b = Math.cos(v.bearingInRadians), w = Math.sin(v.bearingInRadians), S = o.ar();
          S[0] = -b * g * f - w * a, S[1] = -w * g * f + b * a;
          const R = o.as(S);
          R < 1e-9 ? o.at(S) : o.au(S, S, 1 / R);
          const B = o.ar();
          B[0] = b * g * a - w * f, B[1] = w * g * a + b * f;
          const U = o.as(B);
          return U < 1e-9 ? o.at(B) : o.au(B, B, 1 / U), { vecEast: B, vecSouth: S };
        }
        function Rn(v, a, f, g) {
          let b;
          g ? (b = [v, a, g(v, a), 1], o.aw(b, b, f)) : (b = [v, a, 0, 1], Qi(b, b, f));
          const w = b[3];
          return { point: new o.P(b[0] / w, b[1] / w), signedDistanceFromCamera: w, isOccluded: !1 };
        }
        function eo(v, a) {
          return 0.5 + v / a * 0.5;
        }
        function sn(v, a) {
          return v.x >= -a[0] && v.x <= a[0] && v.y >= -a[1] && v.y <= a[1];
        }
        function Xt(v, a, f, g, b, w, S, R, B, U, j, X, q) {
          const Q = f ? v.textSizeData : v.iconSizeData, ce = o.an(Q, a.transform.zoom), we = [256 / a.width * 2 + 1, 256 / a.height * 2 + 1], Ae = f ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
          Ae.clear();
          const Se = v.lineVertexArray, Me = f ? v.text.placedSymbolArray : v.icon.placedSymbolArray, Ge = a.transform.width / a.transform.height;
          let Le = !1;
          for (let $e = 0; $e < Me.length; $e++) {
            const Xe = Me.get($e);
            if (Xe.hidden || Xe.writingMode === o.ao.vertical && !Le) {
              Ao(Xe.numGlyphs, Ae);
              continue;
            }
            Le = !1;
            const Fe = new o.P(Xe.anchorX, Xe.anchorY), Qe = { getElevation: q, pitchedLabelPlaneMatrix: g, lineVertexArray: Se, pitchWithMap: w, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: a.transform, tileAnchorPoint: Fe, unwrappedTileID: B, width: U, height: j, translation: X }, At = Wo(Xe.anchorX, Xe.anchorY, Qe);
            if (!sn(At.point, we)) {
              Ao(Xe.numGlyphs, Ae);
              continue;
            }
            const ft = eo(a.transform.cameraToCenterDistance, At.signedDistanceFromCamera), dt = o.ap(Q, ce, Xe), _t = w ? dt * a.transform.getPitchedTextCorrection(Xe.anchorX, Xe.anchorY, B) / ft : dt * ft, qt = bn({ projectionContext: Qe, pitchedLabelPlaneMatrixInverse: b, symbol: Xe, fontSize: _t, flip: !1, keepUpright: S, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: Ae, aspectRatio: Ge, rotateToLine: R });
            Le = qt.useVertical, (qt.notEnoughRoom || Le || qt.needsFlipping && bn({ projectionContext: Qe, pitchedLabelPlaneMatrixInverse: b, symbol: Xe, fontSize: _t, flip: !0, keepUpright: S, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: Ae, aspectRatio: Ge, rotateToLine: R }).notEnoughRoom) && Ao(Xe.numGlyphs, Ae);
          }
          f ? v.text.dynamicLayoutVertexBuffer.updateData(Ae) : v.icon.dynamicLayoutVertexBuffer.updateData(Ae);
        }
        function Dr(v, a, f, g, b, w, S, R) {
          const B = w.glyphStartIndex + w.numGlyphs, U = w.lineStartIndex, j = w.lineStartIndex + w.lineLength, X = a.getoffsetX(w.glyphStartIndex), q = a.getoffsetX(B - 1), Q = Zo(v * X, f, g, b, w.segment, U, j, R, S);
          if (!Q) return null;
          const ce = Zo(v * q, f, g, b, w.segment, U, j, R, S);
          return ce ? R.projectionCache.anyProjectionOccluded ? null : { first: Q, last: ce } : null;
        }
        function zr(v, a, f, g) {
          return v === o.ao.horizontal && Math.abs(f.y - a.y) > Math.abs(f.x - a.x) * g ? { useVertical: !0 } : (v === o.ao.vertical ? a.y < f.y : a.x > f.x) ? { needsFlipping: !0 } : null;
        }
        function bn(v) {
          const { projectionContext: a, pitchedLabelPlaneMatrixInverse: f, symbol: g, fontSize: b, flip: w, keepUpright: S, glyphOffsetArray: R, dynamicLayoutVertexArray: B, aspectRatio: U, rotateToLine: j } = v, X = b / 24, q = g.lineOffsetX * X, Q = g.lineOffsetY * X;
          let ce;
          if (g.numGlyphs > 1) {
            const we = g.glyphStartIndex + g.numGlyphs, Ae = g.lineStartIndex, Se = g.lineStartIndex + g.lineLength, Me = Dr(X, R, q, Q, w, g, j, a);
            if (!Me) return { notEnoughRoom: !0 };
            const Ge = wo(Me.first.point.x, Me.first.point.y, a, f), Le = wo(Me.last.point.x, Me.last.point.y, a, f);
            if (S && !w) {
              const $e = zr(g.writingMode, Ge, Le, U);
              if ($e) return $e;
            }
            ce = [Me.first];
            for (let $e = g.glyphStartIndex + 1; $e < we - 1; $e++) {
              const Xe = Zo(X * R.getoffsetX($e), q, Q, w, g.segment, Ae, Se, a, j);
              if (!Xe) return { notEnoughRoom: !0 };
              ce.push(Xe);
            }
            ce.push(Me.last);
          } else {
            if (S && !w) {
              const Ae = Nr(a.tileAnchorPoint.x, a.tileAnchorPoint.y, a).point, Se = g.lineStartIndex + g.segment + 1, Me = new o.P(a.lineVertexArray.getx(Se), a.lineVertexArray.gety(Se)), Ge = Nr(Me.x, Me.y, a), Le = Ge.signedDistanceFromCamera > 0 ? Ge.point : qo(a.tileAnchorPoint, Me, Ae, 1, a), $e = wo(Ae.x, Ae.y, a, f), Xe = wo(Le.x, Le.y, a, f), Fe = zr(g.writingMode, $e, Xe, U);
              if (Fe) return Fe;
            }
            const we = Zo(X * R.getoffsetX(g.glyphStartIndex), q, Q, w, g.segment, g.lineStartIndex, g.lineStartIndex + g.lineLength, a, j);
            if (!we || a.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            ce = [we];
          }
          for (const we of ce) o.av(B, we.point, we.angle);
          return {};
        }
        function qo(v, a, f, g, b) {
          const w = v.add(v.sub(a)._unit()), S = Nr(w.x, w.y, b).point, R = f.sub(S);
          return f.add(R._mult(g / R.mag()));
        }
        function Qn(v, a, f) {
          const g = a.projectionCache;
          if (g.projections[v]) return g.projections[v];
          const b = new o.P(a.lineVertexArray.getx(v), a.lineVertexArray.gety(v)), w = Nr(b.x, b.y, a);
          if (w.signedDistanceFromCamera > 0) return g.projections[v] = w.point, g.anyProjectionOccluded = g.anyProjectionOccluded || w.isOccluded, w.point;
          const S = v - f.direction;
          return qo(f.distanceFromAnchor === 0 ? a.tileAnchorPoint : new o.P(a.lineVertexArray.getx(S), a.lineVertexArray.gety(S)), b, f.previousVertex, f.absOffsetX - f.distanceFromAnchor + 1, a);
        }
        function Nr(v, a, f) {
          const g = v + f.translation[0], b = a + f.translation[1];
          let w;
          return f.pitchWithMap ? (w = Rn(g, b, f.pitchedLabelPlaneMatrix, f.getElevation), w.isOccluded = !1) : (w = f.transform.projectTileCoordinates(g, b, f.unwrappedTileID, f.getElevation), w.point.x = (0.5 * w.point.x + 0.5) * f.width, w.point.y = (0.5 * -w.point.y + 0.5) * f.height), w;
        }
        function wo(v, a, f, g) {
          if (f.pitchWithMap) {
            const b = [v, a, 0, 1];
            return o.aw(b, b, g), f.transform.projectTileCoordinates(b[0] / b[3], b[1] / b[3], f.unwrappedTileID, f.getElevation).point;
          }
          return { x: v / f.width * 2 - 1, y: 1 - a / f.height * 2 };
        }
        function Wo(v, a, f) {
          return f.transform.projectTileCoordinates(v, a, f.unwrappedTileID, f.getElevation);
        }
        function Xo(v, a, f) {
          return v._unit()._perp()._mult(a * f);
        }
        function Ul(v, a, f, g, b, w, S, R, B) {
          if (R.projectionCache.offsets[v]) return R.projectionCache.offsets[v];
          const U = f.add(a);
          if (v + B.direction < g || v + B.direction >= b) return R.projectionCache.offsets[v] = U, U;
          const j = Qn(v + B.direction, R, B), X = Xo(j.sub(f), S, B.direction), q = f.add(X), Q = j.add(X);
          return R.projectionCache.offsets[v] = o.ax(w, U, q, Q) || U, R.projectionCache.offsets[v];
        }
        function Zo(v, a, f, g, b, w, S, R, B) {
          const U = g ? v - a : v + a;
          let j = U > 0 ? 1 : -1, X = 0;
          g && (j *= -1, X = Math.PI), j < 0 && (X += Math.PI);
          let q, Q = j > 0 ? w + b : w + b + 1;
          R.projectionCache.cachedAnchorPoint ? q = R.projectionCache.cachedAnchorPoint : (q = Nr(R.tileAnchorPoint.x, R.tileAnchorPoint.y, R).point, R.projectionCache.cachedAnchorPoint = q);
          let ce, we, Ae = q, Se = q, Me = 0, Ge = 0;
          const Le = Math.abs(U), $e = [];
          let Xe;
          for (; Me + Ge <= Le; ) {
            if (Q += j, Q < w || Q >= S) return null;
            Me += Ge, Se = Ae, we = ce;
            const At = { absOffsetX: Le, direction: j, distanceFromAnchor: Me, previousVertex: Se };
            if (Ae = Qn(Q, R, At), f === 0) $e.push(Se), Xe = Ae.sub(Se);
            else {
              let ft;
              const dt = Ae.sub(Se);
              ft = dt.mag() === 0 ? Xo(Qn(Q + j, R, At).sub(Ae), f, j) : Xo(dt, f, j), we || (we = Se.add(ft)), ce = Ul(Q, ft, Ae, w, S, we, f, R, At), $e.push(we), Xe = ce.sub(we);
            }
            Ge = Xe.mag();
          }
          const Fe = Xe._mult((Le - Me) / Ge)._add(we || Se), Qe = X + Math.atan2(Ae.y - Se.y, Ae.x - Se.x);
          return $e.push(Fe), { point: Fe, angle: B ? Qe : 0, path: $e };
        }
        const ol = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Ao(v, a) {
          for (let f = 0; f < v; f++) {
            const g = a.length;
            a.resize(g + 4), a.float32.set(ol, 3 * g);
          }
        }
        function Qi(v, a, f) {
          const g = a[0], b = a[1];
          return v[0] = f[0] * g + f[4] * b + f[12], v[1] = f[1] * g + f[5] * b + f[13], v[3] = f[3] * g + f[7] * b + f[15], v;
        }
        const ti = 100;
        class ch {
          constructor(a, f = new vi(a.width + 200, a.height + 200, 25), g = new vi(a.width + 200, a.height + 200, 25)) {
            this.transform = a, this.grid = f, this.ignoredGrid = g, this.pitchFactor = Math.cos(a.pitch * Math.PI / 180) * a.cameraToCenterDistance, this.screenRightBoundary = a.width + ti, this.screenBottomBoundary = a.height + ti, this.gridRightBoundary = a.width + 200, this.gridBottomBoundary = a.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(a, f, g, b, w, S, R, B, U, j, X, q) {
            const Q = this.projectAndGetPerspectiveRatio(a.anchorPointX + B[0], a.anchorPointY + B[1], w, j, q), ce = g * Q.perspectiveRatio;
            let we;
            if (S || R) we = this._projectCollisionBox(a, ce, b, w, S, R, B, Q, j, X, q);
            else {
              const Xe = Q.x + (X ? X.x * ce : 0), Fe = Q.y + (X ? X.y * ce : 0);
              we = { allPointsOccluded: !1, box: [Xe + a.x1 * ce, Fe + a.y1 * ce, Xe + a.x2 * ce, Fe + a.y2 * ce] };
            }
            const [Ae, Se, Me, Ge] = we.box, Le = S ? we.allPointsOccluded : Q.isOccluded;
            let $e = Le;
            return $e || ($e = Q.perspectiveRatio < this.perspectiveRatioCutoff), $e || ($e = !this.isInsideGrid(Ae, Se, Me, Ge)), $e || f !== "always" && this.grid.hitTest(Ae, Se, Me, Ge, f, U) ? { box: [Ae, Se, Me, Ge], placeable: !1, offscreen: !1, occluded: Le } : { box: [Ae, Se, Me, Ge], placeable: !0, offscreen: this.isOffscreen(Ae, Se, Me, Ge), occluded: Le };
          }
          placeCollisionCircles(a, f, g, b, w, S, R, B, U, j, X, q, Q, ce) {
            const we = [], Ae = new o.P(f.anchorX, f.anchorY), Se = this.getPerspectiveRatio(Ae.x, Ae.y, S, ce), Me = (U ? w * this.transform.getPitchedTextCorrection(f.anchorX, f.anchorY, S) / Se : w * Se) / o.aB, Ge = { getElevation: ce, pitchedLabelPlaneMatrix: R, lineVertexArray: g, pitchWithMap: U, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: Ae, unwrappedTileID: S, width: this.transform.width, height: this.transform.height, translation: Q }, Le = Dr(Me, b, f.lineOffsetX * Me, f.lineOffsetY * Me, !1, f, !1, Ge);
            let $e = !1, Xe = !1, Fe = !0;
            if (Le) {
              const Qe = 0.5 * X * Se + q, At = new o.P(-100, -100), ft = new o.P(this.screenRightBoundary, this.screenBottomBoundary), dt = new nn(), _t = Le.first, qt = Le.last;
              let Zt = [];
              for (let Vr = _t.path.length - 1; Vr >= 1; Vr--) Zt.push(_t.path[Vr]);
              for (let Vr = 1; Vr < qt.path.length; Vr++) Zt.push(qt.path[Vr]);
              const zt = 2.5 * Qe;
              if (U) {
                const Vr = this.projectPathToScreenSpace(Zt, Ge);
                Zt = Vr.some((Ti) => Ti.signedDistanceFromCamera <= 0) ? [] : Vr.map((Ti) => Ti.point);
              }
              let pr = [];
              if (Zt.length > 0) {
                const Vr = Zt[0].clone(), Ti = Zt[0].clone();
                for (let $i = 1; $i < Zt.length; $i++) Vr.x = Math.min(Vr.x, Zt[$i].x), Vr.y = Math.min(Vr.y, Zt[$i].y), Ti.x = Math.max(Ti.x, Zt[$i].x), Ti.y = Math.max(Ti.y, Zt[$i].y);
                pr = Vr.x >= At.x && Ti.x <= ft.x && Vr.y >= At.y && Ti.y <= ft.y ? [Zt] : Ti.x < At.x || Vr.x > ft.x || Ti.y < At.y || Vr.y > ft.y ? [] : o.ay([Zt], At.x, At.y, ft.x, ft.y);
              }
              for (const Vr of pr) {
                dt.reset(Vr, 0.25 * Qe);
                let Ti = 0;
                Ti = dt.length <= 0.5 * Qe ? 1 : Math.ceil(dt.paddedLength / zt) + 1;
                for (let $i = 0; $i < Ti; $i++) {
                  const cn = $i / Math.max(Ti - 1, 1), hi = dt.lerp(cn), en = hi.x + ti, ms = hi.y + ti;
                  we.push(en, ms, Qe, 0);
                  const Pn = en - Qe, Cs = ms - Qe, jn = en + Qe, Jn = ms + Qe;
                  if (Fe = Fe && this.isOffscreen(Pn, Cs, jn, Jn), Xe = Xe || this.isInsideGrid(Pn, Cs, jn, Jn), a !== "always" && this.grid.hitTestCircle(en, ms, Qe, a, j) && ($e = !0, !B)) return { circles: [], offscreen: !1, collisionDetected: $e };
                }
              }
            }
            return { circles: !B && $e || !Xe || Se < this.perspectiveRatioCutoff ? [] : we, offscreen: Fe, collisionDetected: $e };
          }
          projectPathToScreenSpace(a, f) {
            const g = function(b, w) {
              const S = o.L();
              return o.aq(S, w.pitchedLabelPlaneMatrix), b.map((R) => {
                const B = Rn(R.x, R.y, S, w.getElevation), U = w.transform.projectTileCoordinates(B.point.x, B.point.y, w.unwrappedTileID, w.getElevation);
                return U.point.x = (0.5 * U.point.x + 0.5) * w.width, U.point.y = (0.5 * -U.point.y + 0.5) * w.height, U;
              });
            }(a, f);
            return function(b) {
              let w = 0, S = 0, R = 0, B = 0;
              for (let U = 0; U < b.length; U++) b[U].isOccluded ? (R = U + 1, B = 0) : (B++, B > S && (S = B, w = R));
              return b.slice(w, w + S);
            }(g);
          }
          queryRenderedSymbols(a) {
            if (a.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const f = [], g = new o.a2();
            for (const X of a) {
              const q = new o.P(X.x + ti, X.y + ti);
              g.extend(q), f.push(q);
            }
            const { minX: b, minY: w, maxX: S, maxY: R } = g, B = this.grid.query(b, w, S, R).concat(this.ignoredGrid.query(b, w, S, R)), U = {}, j = {};
            for (const X of B) {
              const q = X.key;
              if (U[q.bucketInstanceId] === void 0 && (U[q.bucketInstanceId] = {}), U[q.bucketInstanceId][q.featureIndex]) continue;
              const Q = [new o.P(X.x1, X.y1), new o.P(X.x2, X.y1), new o.P(X.x2, X.y2), new o.P(X.x1, X.y2)];
              o.az(f, Q) && (U[q.bucketInstanceId][q.featureIndex] = !0, j[q.bucketInstanceId] === void 0 && (j[q.bucketInstanceId] = []), j[q.bucketInstanceId].push(q.featureIndex));
            }
            return j;
          }
          insertCollisionBox(a, f, g, b, w, S) {
            (g ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: b, featureIndex: w, collisionGroupID: S, overlapMode: f }, a[0], a[1], a[2], a[3]);
          }
          insertCollisionCircles(a, f, g, b, w, S) {
            const R = g ? this.ignoredGrid : this.grid, B = { bucketInstanceId: b, featureIndex: w, collisionGroupID: S, overlapMode: f };
            for (let U = 0; U < a.length; U += 4) R.insertCircle(B, a[U], a[U + 1], a[U + 2]);
          }
          projectAndGetPerspectiveRatio(a, f, g, b, w) {
            if (w) {
              let S;
              b ? (S = [a, f, b(a, f), 1], o.aw(S, S, w)) : (S = [a, f, 0, 1], Qi(S, S, w));
              const R = S[3];
              return { x: (S[0] / R + 1) / 2 * this.transform.width + ti, y: (-S[1] / R + 1) / 2 * this.transform.height + ti, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / R * 0.5, isOccluded: !1, signedDistanceFromCamera: R };
            }
            {
              const S = this.transform.projectTileCoordinates(a, f, g, b);
              return { x: (S.point.x + 1) / 2 * this.transform.width + ti, y: (1 - S.point.y) / 2 * this.transform.height + ti, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / S.signedDistanceFromCamera * 0.5, isOccluded: S.isOccluded, signedDistanceFromCamera: S.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(a, f, g, b) {
            const w = this.transform.projectTileCoordinates(a, f, g, b);
            return 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(a, f, g, b) {
            return g < ti || a >= this.screenRightBoundary || b < ti || f > this.screenBottomBoundary;
          }
          isInsideGrid(a, f, g, b) {
            return g >= 0 && a < this.gridRightBoundary && b >= 0 && f < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const a = o.ai([]);
            return o.M(a, a, [-100, -100, 0]), a;
          }
          _projectCollisionBox(a, f, g, b, w, S, R, B, U, j, X) {
            let q = 1, Q = 0, ce = 0, we = 1;
            const Ae = a.anchorPointX + R[0], Se = a.anchorPointY + R[1];
            if (S && !w) {
              const Zt = this.projectAndGetPerspectiveRatio(Ae + 1, Se, b, U, X), zt = Zt.x - B.x, pr = Math.atan((Zt.y - B.y) / zt) + (zt < 0 ? Math.PI : 0), Vr = Math.sin(pr), Ti = Math.cos(pr);
              q = Ti, Q = Vr, ce = -Vr, we = Ti;
            } else if (!S && w) {
              const Zt = pi(this.transform);
              q = Zt.vecEast[0], Q = Zt.vecEast[1], ce = Zt.vecSouth[0], we = Zt.vecSouth[1];
            }
            let Me = B.x, Ge = B.y, Le = f;
            w && (Me = Ae, Ge = Se, Le = Math.pow(2, -(this.transform.zoom - g.overscaledZ)), Le *= this.transform.getPitchedTextCorrection(Ae, Se, b), j || (Le *= o.ae(0.5 + B.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), j && (Me += q * j.x * Le + ce * j.y * Le, Ge += Q * j.x * Le + we * j.y * Le);
            const $e = a.x1 * Le, Xe = a.x2 * Le, Fe = ($e + Xe) / 2, Qe = a.y1 * Le, At = a.y2 * Le, ft = (Qe + At) / 2, dt = [{ offsetX: $e, offsetY: Qe }, { offsetX: Fe, offsetY: Qe }, { offsetX: Xe, offsetY: Qe }, { offsetX: Xe, offsetY: ft }, { offsetX: Xe, offsetY: At }, { offsetX: Fe, offsetY: At }, { offsetX: $e, offsetY: At }, { offsetX: $e, offsetY: ft }];
            let _t = [];
            for (const { offsetX: Zt, offsetY: zt } of dt) _t.push(new o.P(Me + q * Zt + ce * zt, Ge + Q * Zt + we * zt));
            let qt = !1;
            if (w) {
              const Zt = _t.map((zt) => this.projectAndGetPerspectiveRatio(zt.x, zt.y, b, U, X));
              qt = Zt.some((zt) => !zt.isOccluded), _t = Zt.map((zt) => new o.P(zt.x, zt.y));
            } else qt = !0;
            return { box: o.aA(_t), allPointsOccluded: !qt };
          }
        }
        class ha {
          constructor(a, f, g, b) {
            this.opacity = a ? Math.max(0, Math.min(1, a.opacity + (a.placed ? f : -f))) : b && g ? 1 : 0, this.placed = g;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class fa {
          constructor(a, f, g, b, w) {
            this.text = new ha(a ? a.text : null, f, g, w), this.icon = new ha(a ? a.icon : null, f, b, w);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Yo {
          constructor(a, f, g) {
            this.text = a, this.icon = f, this.skipFade = g;
          }
        }
        class Jo {
          constructor(a, f, g, b, w) {
            this.bucketInstanceId = a, this.featureIndex = f, this.sourceLayerIndex = g, this.bucketIndex = b, this.tileID = w;
          }
        }
        class zl {
          constructor(a) {
            this.crossSourceCollisions = a, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(a) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[a]) {
              const f = ++this.maxGroupID;
              this.collisionGroups[a] = { ID: f, predicate: (g) => g.collisionGroupID === f };
            }
            return this.collisionGroups[a];
          }
        }
        function Tu(v, a, f, g, b) {
          const { horizontalAlign: w, verticalAlign: S } = o.aH(v);
          return new o.P(-(w - 0.5) * a + g[0] * b, -(S - 0.5) * f + g[1] * b);
        }
        class Ln {
          constructor(a, f, g, b, w) {
            this.transform = a.clone(), this.terrain = f, this.collisionIndex = new ch(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = g, this.retainedQueryData = {}, this.collisionGroups = new zl(b), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = w, w && (w.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(a) {
            const f = this.terrain;
            return f ? (g, b) => f.getElevation(a, g, b) : null;
          }
          getBucketParts(a, f, g, b) {
            const w = g.getBucket(f), S = g.latestFeatureIndex;
            if (!w || !S || f.id !== w.layerIds[0]) return;
            const R = g.collisionBoxArray, B = w.layers[0].layout, U = w.layers[0].paint, j = Math.pow(2, this.transform.zoom - g.tileID.overscaledZ), X = g.tileSize / o.$, q = g.tileID.toUnwrapped(), Q = B.get("text-rotation-alignment") === "map", ce = o.aC(g, 1, this.transform.zoom), we = o.aD(this.collisionIndex.transform, g, U.get("text-translate"), U.get("text-translate-anchor")), Ae = o.aD(this.collisionIndex.transform, g, U.get("icon-translate"), U.get("icon-translate-anchor")), Se = ci(Q, this.transform, ce);
            this.retainedQueryData[w.bucketInstanceId] = new Jo(w.bucketInstanceId, S, w.sourceLayerIndex, w.index, g.tileID);
            const Me = { bucket: w, layout: B, translationText: we, translationIcon: Ae, unwrappedTileID: q, pitchedLabelPlaneMatrix: Se, scale: j, textPixelRatio: X, holdingForFade: g.holdingForSymbolFade(), collisionBoxArray: R, partiallyEvaluatedTextSize: o.an(w.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(w.sourceID) };
            if (b) for (const Ge of w.sortKeyRanges) {
              const { sortKey: Le, symbolInstanceStart: $e, symbolInstanceEnd: Xe } = Ge;
              a.push({ sortKey: Le, symbolInstanceStart: $e, symbolInstanceEnd: Xe, parameters: Me });
            }
            else a.push({ symbolInstanceStart: 0, symbolInstanceEnd: w.symbolInstances.length, parameters: Me });
          }
          attemptAnchorPlacement(a, f, g, b, w, S, R, B, U, j, X, q, Q, ce, we, Ae, Se, Me, Ge, Le) {
            const $e = o.aE[a.textAnchor], Xe = [a.textOffset0, a.textOffset1], Fe = Tu($e, g, b, Xe, w), Qe = this.collisionIndex.placeCollisionBox(f, q, B, U, j, R, S, Ae, X.predicate, Ge, Fe, Le);
            if ((!Me || this.collisionIndex.placeCollisionBox(Me, q, B, U, j, R, S, Se, X.predicate, Ge, Fe, Le).placeable) && Qe.placeable) {
              let At;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[Q.crossTileID] && this.prevPlacement.placements[Q.crossTileID] && this.prevPlacement.placements[Q.crossTileID].text && (At = this.prevPlacement.variableOffsets[Q.crossTileID].anchor), Q.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[Q.crossTileID] = { textOffset: Xe, width: g, height: b, anchor: $e, textBoxScale: w, prevAnchor: At }, this.markUsedJustification(ce, $e, Q, we), ce.allowVerticalPlacement && (this.markUsedOrientation(ce, we, Q), this.placedOrientations[Q.crossTileID] = we), { shift: Fe, placedGlyphBoxes: Qe };
            }
          }
          placeLayerBucketPart(a, f, g) {
            const { bucket: b, layout: w, translationText: S, translationIcon: R, unwrappedTileID: B, pitchedLabelPlaneMatrix: U, textPixelRatio: j, holdingForFade: X, collisionBoxArray: q, partiallyEvaluatedTextSize: Q, collisionGroup: ce } = a.parameters, we = w.get("text-optional"), Ae = w.get("icon-optional"), Se = o.aF(w, "text-overlap", "text-allow-overlap"), Me = Se === "always", Ge = o.aF(w, "icon-overlap", "icon-allow-overlap"), Le = Ge === "always", $e = w.get("text-rotation-alignment") === "map", Xe = w.get("text-pitch-alignment") === "map", Fe = w.get("icon-text-fit") !== "none", Qe = w.get("symbol-z-order") === "viewport-y", At = Me && (Le || !b.hasIconData() || Ae), ft = Le && (Me || !b.hasTextData() || we);
            !b.collisionArrays && q && b.deserializeCollisionBoxes(q);
            const dt = this.retainedQueryData[b.bucketInstanceId].tileID, _t = this._getTerrainElevationFunc(dt), qt = this.transform.getFastPathSimpleProjectionMatrix(dt), Zt = (zt, pr, Vr) => {
              var Ti, $i;
              if (f[zt.crossTileID]) return;
              if (X) return void (this.placements[zt.crossTileID] = new Yo(!1, !1, !1));
              let cn = !1, hi = !1, en = !0, ms = null, Pn = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Cs = { placeable: !1 }, jn = null, Jn = null, Is = null, eu = 0, tu = 0, $u = 0;
              pr.textFeatureIndex ? eu = pr.textFeatureIndex : zt.useRuntimeCollisionCircles && (eu = zt.featureIndex), pr.verticalTextFeatureIndex && (tu = pr.verticalTextFeatureIndex);
              const ru = pr.textBox;
              if (ru) {
                const bo = (ns) => {
                  let Ps = o.ao.horizontal;
                  if (b.allowVerticalPlacement && !ns && this.prevPlacement) {
                    const Lo = this.prevPlacement.placedOrientations[zt.crossTileID];
                    Lo && (this.placedOrientations[zt.crossTileID] = Lo, Ps = Lo, this.markUsedOrientation(b, Ps, zt));
                  }
                  return Ps;
                }, oo = (ns, Ps) => {
                  if (b.allowVerticalPlacement && zt.numVerticalGlyphVertices > 0 && pr.verticalTextBox) {
                    for (const Lo of b.writingModes) if (Lo === o.ao.vertical ? (Pn = Ps(), Cs = Pn) : Pn = ns(), Pn && Pn.placeable) break;
                  } else Pn = ns();
                }, Il = zt.textAnchorOffsetStartIndex, Ah = zt.textAnchorOffsetEndIndex;
                if (Ah === Il) {
                  const ns = (Ps, Lo) => {
                    const Vn = this.collisionIndex.placeCollisionBox(Ps, Se, j, dt, B, Xe, $e, S, ce.predicate, _t, void 0, qt);
                    return Vn && Vn.placeable && (this.markUsedOrientation(b, Lo, zt), this.placedOrientations[zt.crossTileID] = Lo), Vn;
                  };
                  oo(() => ns(ru, o.ao.horizontal), () => {
                    const Ps = pr.verticalTextBox;
                    return b.allowVerticalPlacement && zt.numVerticalGlyphVertices > 0 && Ps ? ns(Ps, o.ao.vertical) : { box: null, offscreen: null };
                  }), bo(Pn && Pn.placeable);
                } else {
                  let ns = o.aE[($i = (Ti = this.prevPlacement) === null || Ti === void 0 ? void 0 : Ti.variableOffsets[zt.crossTileID]) === null || $i === void 0 ? void 0 : $i.anchor];
                  const Ps = (Vn, qu, nc) => {
                    const qa = Vn.x2 - Vn.x1, nu = Vn.y2 - Vn.y1, Tm = zt.textBoxScale, Sm = Fe && Ge === "never" ? qu : null;
                    let su = null, ou = Se === "never" ? 1 : 2, Em = "never";
                    ns && ou++;
                    for (let $p = 0; $p < ou; $p++) {
                      for (let gf = Il; gf < Ah; gf++) {
                        const Hp = b.textAnchorOffsets.get(gf);
                        if (ns && Hp.textAnchor !== ns) continue;
                        const sc = this.attemptAnchorPlacement(Hp, Vn, qa, nu, Tm, $e, Xe, j, dt, B, ce, Em, zt, b, nc, S, R, Sm, _t);
                        if (sc && (su = sc.placedGlyphBoxes, su && su.placeable)) return cn = !0, ms = sc.shift, su;
                      }
                      ns ? ns = null : Em = Se;
                    }
                    return g && !su && (su = { box: this.collisionIndex.placeCollisionBox(ru, "always", j, dt, B, Xe, $e, S, ce.predicate, _t, void 0, qt).box, offscreen: !1, placeable: !1, occluded: !1 }), su;
                  };
                  oo(() => Ps(ru, pr.iconBox, o.ao.horizontal), () => {
                    const Vn = pr.verticalTextBox;
                    return b.allowVerticalPlacement && (!Pn || !Pn.placeable) && zt.numVerticalGlyphVertices > 0 && Vn ? Ps(Vn, pr.verticalIconBox, o.ao.vertical) : { box: null, occluded: !0, offscreen: null };
                  }), Pn && (cn = Pn.placeable, en = Pn.offscreen);
                  const Lo = bo(Pn && Pn.placeable);
                  if (!cn && this.prevPlacement) {
                    const Vn = this.prevPlacement.variableOffsets[zt.crossTileID];
                    Vn && (this.variableOffsets[zt.crossTileID] = Vn, this.markUsedJustification(b, Vn.anchor, zt, Lo));
                  }
                }
              }
              if (jn = Pn, cn = jn && jn.placeable, en = jn && jn.offscreen, zt.useRuntimeCollisionCircles && zt.centerJustifiedTextSymbolIndex >= 0) {
                const bo = b.text.placedSymbolArray.get(zt.centerJustifiedTextSymbolIndex), oo = o.ap(b.textSizeData, Q, bo), Il = w.get("text-padding");
                Jn = this.collisionIndex.placeCollisionCircles(Se, bo, b.lineVertexArray, b.glyphOffsetArray, oo, B, U, g, Xe, ce.predicate, zt.collisionCircleDiameter, Il, S, _t), Jn.circles.length && Jn.collisionDetected && !g && o.w("Collisions detected, but collision boxes are not shown"), cn = Me || Jn.circles.length > 0 && !Jn.collisionDetected, en = en && Jn.offscreen;
              }
              if (pr.iconFeatureIndex && ($u = pr.iconFeatureIndex), pr.iconBox) {
                const bo = (oo) => this.collisionIndex.placeCollisionBox(oo, Ge, j, dt, B, Xe, $e, R, ce.predicate, _t, Fe && ms ? ms : void 0, qt);
                Cs && Cs.placeable && pr.verticalIconBox ? (Is = bo(pr.verticalIconBox), hi = Is.placeable) : (Is = bo(pr.iconBox), hi = Is.placeable), en = en && Is.offscreen;
              }
              const Hu = we || zt.numHorizontalGlyphVertices === 0 && zt.numVerticalGlyphVertices === 0, pf = Ae || zt.numIconVertices === 0;
              Hu || pf ? pf ? Hu || (hi = hi && cn) : cn = hi && cn : hi = cn = hi && cn;
              const iu = hi && Is.placeable;
              if (cn && jn.placeable && this.collisionIndex.insertCollisionBox(jn.box, Se, w.get("text-ignore-placement"), b.bucketInstanceId, Cs && Cs.placeable && tu ? tu : eu, ce.ID), iu && this.collisionIndex.insertCollisionBox(Is.box, Ge, w.get("icon-ignore-placement"), b.bucketInstanceId, $u, ce.ID), Jn && cn && this.collisionIndex.insertCollisionCircles(Jn.circles, Se, w.get("text-ignore-placement"), b.bucketInstanceId, eu, ce.ID), g && this.storeCollisionData(b.bucketInstanceId, Vr, pr, jn, Is, Jn), zt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (b.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[zt.crossTileID] = new Yo((cn || At) && !jn?.occluded, (hi || ft) && !Is?.occluded, en || b.justReloaded), f[zt.crossTileID] = !0;
            };
            if (Qe) {
              if (a.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const zt = b.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let pr = zt.length - 1; pr >= 0; --pr) {
                const Vr = zt[pr];
                Zt(b.symbolInstances.get(Vr), b.collisionArrays[Vr], Vr);
              }
            } else for (let zt = a.symbolInstanceStart; zt < a.symbolInstanceEnd; zt++) Zt(b.symbolInstances.get(zt), b.collisionArrays[zt], zt);
            b.justReloaded = !1;
          }
          storeCollisionData(a, f, g, b, w, S) {
            if (g.textBox || g.iconBox) {
              let R, B;
              this.collisionBoxArrays.has(a) ? R = this.collisionBoxArrays.get(a) : (R = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(a, R)), R.has(f) ? B = R.get(f) : (B = { text: null, icon: null }, R.set(f, B)), g.textBox && (B.text = b.box), g.iconBox && (B.icon = w.box);
            }
            if (S) {
              let R = this.collisionCircleArrays[a];
              R === void 0 && (R = this.collisionCircleArrays[a] = []);
              for (let B = 0; B < S.circles.length; B += 4) R.push(S.circles[B + 0] - ti), R.push(S.circles[B + 1] - ti), R.push(S.circles[B + 2]), R.push(S.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(a, f, g, b) {
            let w;
            w = b === o.ao.vertical ? g.verticalPlacedTextSymbolIndex : { left: g.leftJustifiedTextSymbolIndex, center: g.centerJustifiedTextSymbolIndex, right: g.rightJustifiedTextSymbolIndex }[o.aG(f)];
            const S = [g.leftJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.rightJustifiedTextSymbolIndex, g.verticalPlacedTextSymbolIndex];
            for (const R of S) R >= 0 && (a.text.placedSymbolArray.get(R).crossTileID = w >= 0 && R !== w ? 0 : g.crossTileID);
          }
          markUsedOrientation(a, f, g) {
            const b = f === o.ao.horizontal || f === o.ao.horizontalOnly ? f : 0, w = f === o.ao.vertical ? f : 0, S = [g.leftJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.rightJustifiedTextSymbolIndex];
            for (const R of S) a.text.placedSymbolArray.get(R).placedOrientation = b;
            g.verticalPlacedTextSymbolIndex && (a.text.placedSymbolArray.get(g.verticalPlacedTextSymbolIndex).placedOrientation = w);
          }
          commit(a) {
            this.commitTime = a, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const f = this.prevPlacement;
            let g = !1;
            this.prevZoomAdjustment = f ? f.zoomAdjustment(this.transform.zoom) : 0;
            const b = f ? f.symbolFadeChange(a) : 1, w = f ? f.opacities : {}, S = f ? f.variableOffsets : {}, R = f ? f.placedOrientations : {};
            for (const B in this.placements) {
              const U = this.placements[B], j = w[B];
              j ? (this.opacities[B] = new fa(j, b, U.text, U.icon), g = g || U.text !== j.text.placed || U.icon !== j.icon.placed) : (this.opacities[B] = new fa(null, b, U.text, U.icon, U.skipFade), g = g || U.text || U.icon);
            }
            for (const B in w) {
              const U = w[B];
              if (!this.opacities[B]) {
                const j = new fa(U, b, !1, !1);
                j.isHidden() || (this.opacities[B] = j, g = g || U.text.placed || U.icon.placed);
              }
            }
            for (const B in S) this.variableOffsets[B] || !this.opacities[B] || this.opacities[B].isHidden() || (this.variableOffsets[B] = S[B]);
            for (const B in R) this.placedOrientations[B] || !this.opacities[B] || this.opacities[B].isHidden() || (this.placedOrientations[B] = R[B]);
            if (f && f.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            g ? this.lastPlacementChangeTime = a : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = f ? f.lastPlacementChangeTime : a);
          }
          updateLayerOpacities(a, f) {
            const g = {};
            for (const b of f) {
              const w = b.getBucket(a);
              w && b.latestFeatureIndex && a.id === w.layerIds[0] && this.updateBucketOpacities(w, b.tileID, g, b.collisionBoxArray);
            }
          }
          updateBucketOpacities(a, f, g, b) {
            a.hasTextData() && (a.text.opacityVertexArray.clear(), a.text.hasVisibleVertices = !1), a.hasIconData() && (a.icon.opacityVertexArray.clear(), a.icon.hasVisibleVertices = !1), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexArray.clear(), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexArray.clear();
            const w = a.layers[0], S = w.layout, R = new fa(null, 0, !1, !1, !0), B = S.get("text-allow-overlap"), U = S.get("icon-allow-overlap"), j = w._unevaluatedLayout.hasValue("text-variable-anchor") || w._unevaluatedLayout.hasValue("text-variable-anchor-offset"), X = S.get("text-rotation-alignment") === "map", q = S.get("text-pitch-alignment") === "map", Q = S.get("icon-text-fit") !== "none", ce = new fa(null, 0, B && (U || !a.hasIconData() || S.get("icon-optional")), U && (B || !a.hasTextData() || S.get("text-optional")), !0);
            !a.collisionArrays && b && (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) && a.deserializeCollisionBoxes(b);
            const we = (Se, Me, Ge) => {
              for (let Le = 0; Le < Me / 4; Le++) Se.opacityVertexArray.emplaceBack(Ge);
              Se.hasVisibleVertices = Se.hasVisibleVertices || Ge !== ll;
            }, Ae = this.collisionBoxArrays.get(a.bucketInstanceId);
            for (let Se = 0; Se < a.symbolInstances.length; Se++) {
              const Me = a.symbolInstances.get(Se), { numHorizontalGlyphVertices: Ge, numVerticalGlyphVertices: Le, crossTileID: $e } = Me;
              let Xe = this.opacities[$e];
              g[$e] ? Xe = R : Xe || (Xe = ce, this.opacities[$e] = Xe), g[$e] = !0;
              const Fe = Me.numIconVertices > 0, Qe = this.placedOrientations[Me.crossTileID], At = Qe === o.ao.vertical, ft = Qe === o.ao.horizontal || Qe === o.ao.horizontalOnly;
              if (Ge > 0 || Le > 0) {
                const _t = Bc(Xe.text);
                we(a.text, Ge, At ? ll : _t), we(a.text, Le, ft ? ll : _t);
                const qt = Xe.text.isHidden();
                [Me.rightJustifiedTextSymbolIndex, Me.centerJustifiedTextSymbolIndex, Me.leftJustifiedTextSymbolIndex].forEach((pr) => {
                  pr >= 0 && (a.text.placedSymbolArray.get(pr).hidden = qt || At ? 1 : 0);
                }), Me.verticalPlacedTextSymbolIndex >= 0 && (a.text.placedSymbolArray.get(Me.verticalPlacedTextSymbolIndex).hidden = qt || ft ? 1 : 0);
                const Zt = this.variableOffsets[Me.crossTileID];
                Zt && this.markUsedJustification(a, Zt.anchor, Me, Qe);
                const zt = this.placedOrientations[Me.crossTileID];
                zt && (this.markUsedJustification(a, "left", Me, zt), this.markUsedOrientation(a, zt, Me));
              }
              if (Fe) {
                const _t = Bc(Xe.icon), qt = !(Q && Me.verticalPlacedIconSymbolIndex && At);
                Me.placedIconSymbolIndex >= 0 && (we(a.icon, Me.numIconVertices, qt ? _t : ll), a.icon.placedSymbolArray.get(Me.placedIconSymbolIndex).hidden = Xe.icon.isHidden()), Me.verticalPlacedIconSymbolIndex >= 0 && (we(a.icon, Me.numVerticalIconVertices, qt ? ll : _t), a.icon.placedSymbolArray.get(Me.verticalPlacedIconSymbolIndex).hidden = Xe.icon.isHidden());
              }
              const dt = Ae && Ae.has(Se) ? Ae.get(Se) : { text: null, icon: null };
              if (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) {
                const _t = a.collisionArrays[Se];
                if (_t) {
                  let qt = new o.P(0, 0);
                  if (_t.textBox || _t.verticalTextBox) {
                    let Zt = !0;
                    if (j) {
                      const zt = this.variableOffsets[$e];
                      zt ? (qt = Tu(zt.anchor, zt.width, zt.height, zt.textOffset, zt.textBoxScale), X && qt._rotate(q ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Zt = !1;
                    }
                    if (_t.textBox || _t.verticalTextBox) {
                      let zt;
                      _t.textBox && (zt = At), _t.verticalTextBox && (zt = ft), da(a.textCollisionBox.collisionVertexArray, Xe.text.placed, !Zt || zt, dt.text, qt.x, qt.y);
                    }
                  }
                  if (_t.iconBox || _t.verticalIconBox) {
                    const Zt = !!(!ft && _t.verticalIconBox);
                    let zt;
                    _t.iconBox && (zt = Zt), _t.verticalIconBox && (zt = !Zt), da(a.iconCollisionBox.collisionVertexArray, Xe.icon.placed, zt, dt.icon, Q ? qt.x : 0, Q ? qt.y : 0);
                  }
                }
              }
            }
            if (a.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[a.bucketInstanceId] && (this.retainedQueryData[a.bucketInstanceId].featureSortOrder = a.featureSortOrder), a.hasTextData() && a.text.opacityVertexBuffer && a.text.opacityVertexBuffer.updateData(a.text.opacityVertexArray), a.hasIconData() && a.icon.opacityVertexBuffer && a.icon.opacityVertexBuffer.updateData(a.icon.opacityVertexArray), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexBuffer && a.iconCollisionBox.collisionVertexBuffer.updateData(a.iconCollisionBox.collisionVertexArray), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexBuffer && a.textCollisionBox.collisionVertexBuffer.updateData(a.textCollisionBox.collisionVertexArray), a.text.opacityVertexArray.length !== a.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${a.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${a.text.layoutVertexArray.length}) / 4`);
            if (a.icon.opacityVertexArray.length !== a.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${a.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${a.icon.layoutVertexArray.length}) / 4`);
            a.bucketInstanceId in this.collisionCircleArrays && (a.collisionCircleArray = this.collisionCircleArrays[a.bucketInstanceId], delete this.collisionCircleArrays[a.bucketInstanceId]);
          }
          symbolFadeChange(a) {
            return this.fadeDuration === 0 ? 1 : (a - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(a) {
            return Math.max(0, (this.transform.zoom - a) / 1.5);
          }
          hasTransitions(a) {
            return this.stale || a - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(a, f) {
            const g = this.zoomAtLastRecencyCheck === f ? 1 - this.zoomAdjustment(f) : 1;
            return this.zoomAtLastRecencyCheck = f, this.commitTime + this.fadeDuration * g > a;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function da(v, a, f, g, b, w) {
          g && g.length !== 0 || (g = [0, 0, 0, 0]);
          const S = g[0] - ti, R = g[1] - ti, B = g[2] - ti, U = g[3] - ti;
          v.emplaceBack(a ? 1 : 0, f ? 1 : 0, b || 0, w || 0, S, R), v.emplaceBack(a ? 1 : 0, f ? 1 : 0, b || 0, w || 0, B, R), v.emplaceBack(a ? 1 : 0, f ? 1 : 0, b || 0, w || 0, B, U), v.emplaceBack(a ? 1 : 0, f ? 1 : 0, b || 0, w || 0, S, U);
        }
        const Su = Math.pow(2, 25), La = Math.pow(2, 24), jl = Math.pow(2, 17), Ko = Math.pow(2, 16), al = Math.pow(2, 9), Sn = Math.pow(2, 8), Vl = Math.pow(2, 1);
        function Bc(v) {
          if (v.opacity === 0 && !v.placed) return 0;
          if (v.opacity === 1 && v.placed) return 4294967295;
          const a = v.placed ? 1 : 0, f = Math.floor(127 * v.opacity);
          return f * Su + a * La + f * jl + a * Ko + f * al + a * Sn + f * Vl + a;
        }
        const ll = 0;
        class Eu {
          constructor(a) {
            this._sortAcrossTiles = a.layout.get("symbol-z-order") !== "viewport-y" && !a.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(a, f, g, b, w) {
            const S = this._bucketParts;
            for (; this._currentTileIndex < a.length; ) if (f.getBucketParts(S, b, a[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, w()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, S.sort((R, B) => R.sortKey - B.sortKey)); this._currentPartIndex < S.length; ) if (f.placeLayerBucketPart(S[this._currentPartIndex], this._seenCrossTileIDs, g), this._currentPartIndex++, w()) return !0;
            return !1;
          }
        }
        class To {
          constructor(a, f, g, b, w, S, R, B) {
            this.placement = new Ln(a, f, S, R, B), this._currentPlacementIndex = g.length - 1, this._forceFullPlacement = b, this._showCollisionBoxes = w, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(a, f, g) {
            const b = D(), w = () => !this._forceFullPlacement && D() - b > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const S = f[a[this._currentPlacementIndex]], R = this.placement.collisionIndex.transform.zoom;
              if (S.type === "symbol" && (!S.minzoom || S.minzoom <= R) && (!S.maxzoom || S.maxzoom > R)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Eu(S)), this._inProgressLayer.continuePlacement(g[S.source], this.placement, this._showCollisionBoxes, S, w)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(a) {
            return this.placement.commit(a), this.placement;
          }
        }
        const cl = 512 / o.$ / 2;
        class ul {
          constructor(a, f, g) {
            this.tileID = a, this.bucketInstanceId = g, this._symbolsByKey = {};
            const b = /* @__PURE__ */ new Map();
            for (let w = 0; w < f.length; w++) {
              const S = f.get(w), R = S.key, B = b.get(R);
              B ? B.push(S) : b.set(R, [S]);
            }
            for (const [w, S] of b) {
              const R = { positions: S.map((B) => ({ x: Math.floor(B.anchorX * cl), y: Math.floor(B.anchorY * cl) })), crossTileIDs: S.map((B) => B.crossTileID) };
              if (R.positions.length > 128) {
                const B = new o.aI(R.positions.length, 16, Uint16Array);
                for (const { x: U, y: j } of R.positions) B.add(U, j);
                B.finish(), delete R.positions, R.index = B;
              }
              this._symbolsByKey[w] = R;
            }
          }
          getScaledCoordinates(a, f) {
            const { x: g, y: b, z: w } = this.tileID.canonical, { x: S, y: R, z: B } = f.canonical, U = cl / Math.pow(2, B - w), j = (R * o.$ + a.anchorY) * U, X = b * o.$ * cl;
            return { x: Math.floor((S * o.$ + a.anchorX) * U - g * o.$ * cl), y: Math.floor(j - X) };
          }
          findMatches(a, f, g) {
            const b = this.tileID.canonical.z < f.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - f.canonical.z);
            for (let w = 0; w < a.length; w++) {
              const S = a.get(w);
              if (S.crossTileID) continue;
              const R = this._symbolsByKey[S.key];
              if (!R) continue;
              const B = this.getScaledCoordinates(S, f);
              if (R.index) {
                const U = R.index.range(B.x - b, B.y - b, B.x + b, B.y + b).sort();
                for (const j of U) {
                  const X = R.crossTileIDs[j];
                  if (!g[X]) {
                    g[X] = !0, S.crossTileID = X;
                    break;
                  }
                }
              } else if (R.positions) for (let U = 0; U < R.positions.length; U++) {
                const j = R.positions[U], X = R.crossTileIDs[U];
                if (Math.abs(j.x - B.x) <= b && Math.abs(j.y - B.y) <= b && !g[X]) {
                  g[X] = !0, S.crossTileID = X;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: a }) => a);
          }
        }
        class Qo {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class kc {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(a) {
            const f = Math.round((a - this.lng) / 360);
            if (f !== 0) for (const g in this.indexes) {
              const b = this.indexes[g], w = {};
              for (const S in b) {
                const R = b[S];
                R.tileID = R.tileID.unwrapTo(R.tileID.wrap + f), w[R.tileID.key] = R;
              }
              this.indexes[g] = w;
            }
            this.lng = a;
          }
          addBucket(a, f, g) {
            if (this.indexes[a.overscaledZ] && this.indexes[a.overscaledZ][a.key]) {
              if (this.indexes[a.overscaledZ][a.key].bucketInstanceId === f.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(a.overscaledZ, this.indexes[a.overscaledZ][a.key]);
            }
            for (let w = 0; w < f.symbolInstances.length; w++) f.symbolInstances.get(w).crossTileID = 0;
            this.usedCrossTileIDs[a.overscaledZ] || (this.usedCrossTileIDs[a.overscaledZ] = {});
            const b = this.usedCrossTileIDs[a.overscaledZ];
            for (const w in this.indexes) {
              const S = this.indexes[w];
              if (Number(w) > a.overscaledZ) for (const R in S) {
                const B = S[R];
                B.tileID.isChildOf(a) && B.findMatches(f.symbolInstances, a, b);
              }
              else {
                const R = S[a.scaledTo(Number(w)).key];
                R && R.findMatches(f.symbolInstances, a, b);
              }
            }
            for (let w = 0; w < f.symbolInstances.length; w++) {
              const S = f.symbolInstances.get(w);
              S.crossTileID || (S.crossTileID = g.generate(), b[S.crossTileID] = !0);
            }
            return this.indexes[a.overscaledZ] === void 0 && (this.indexes[a.overscaledZ] = {}), this.indexes[a.overscaledZ][a.key] = new ul(a, f.symbolInstances, f.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(a, f) {
            for (const g of f.getCrossTileIDsLists()) for (const b of g) delete this.usedCrossTileIDs[a][b];
          }
          removeStaleBuckets(a) {
            let f = !1;
            for (const g in this.indexes) {
              const b = this.indexes[g];
              for (const w in b) a[b[w].bucketInstanceId] || (this.removeBucketCrossTileIDs(g, b[w]), delete b[w], f = !0);
            }
            return f;
          }
        }
        class Ba {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Qo(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(a, f, g) {
            let b = this.layerIndexes[a.id];
            b === void 0 && (b = this.layerIndexes[a.id] = new kc());
            let w = !1;
            const S = {};
            b.handleWrapJump(g);
            for (const R of f) {
              const B = R.getBucket(a);
              B && a.id === B.layerIds[0] && (B.bucketInstanceId || (B.bucketInstanceId = ++this.maxBucketInstanceId), b.addBucket(R.tileID, B, this.crossTileIDs) && (w = !0), S[B.bucketInstanceId] = !0);
            }
            return b.removeStaleBuckets(S) && (w = !0), w;
          }
          pruneUnusedLayers(a) {
            const f = {};
            a.forEach((g) => {
              f[g] = !0;
            });
            for (const g in this.layerIndexes) f[g] || delete this.layerIndexes[g];
          }
        }
        var Cu = "void main() {fragColor=vec4(1.0);}";
        const So = { prelude: Jr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Jr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Jr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Jr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Jr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Jr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Jr(Cu, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Jr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Jr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Jr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Jr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Jr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Jr(Cu, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Jr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Jr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Jr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Jr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Jr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Jr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Jr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Jr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Jr(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: Jr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: Jr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Jr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Jr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Jr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Jr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Jr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Jr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Jr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Jr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Jr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Jr(v, a) {
          const f = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, g = a.match(/in ([\w]+) ([\w]+)/g), b = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = a.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), S = w ? w.concat(b) : b, R = {};
          return { fragmentSource: v = v.replace(f, (B, U, j, X, q) => (R[q] = !0, U === "define" ? `
#ifndef HAS_UNIFORM_u_${q}
in ${j} ${X} ${q};
#else
uniform ${j} ${X} u_${q};
#endif
` : `
#ifdef HAS_UNIFORM_u_${q}
    ${j} ${X} ${q} = u_${q};
#endif
`)), vertexSource: a = a.replace(f, (B, U, j, X, q) => {
            const Q = X === "float" ? "vec2" : "vec4", ce = q.match(/color/) ? "color" : Q;
            return R[q] ? U === "define" ? `
#ifndef HAS_UNIFORM_u_${q}
uniform lowp float u_${q}_t;
in ${j} ${Q} a_${q};
out ${j} ${X} ${q};
#else
uniform ${j} ${X} u_${q};
#endif
` : ce === "vec4" ? `
#ifndef HAS_UNIFORM_u_${q}
    ${q} = a_${q};
#else
    ${j} ${X} ${q} = u_${q};
#endif
` : `
#ifndef HAS_UNIFORM_u_${q}
    ${q} = unpack_mix_${ce}(a_${q}, u_${q}_t);
#else
    ${j} ${X} ${q} = u_${q};
#endif
` : U === "define" ? `
#ifndef HAS_UNIFORM_u_${q}
uniform lowp float u_${q}_t;
in ${j} ${Q} a_${q};
#else
uniform ${j} ${X} u_${q};
#endif
` : ce === "vec4" ? `
#ifndef HAS_UNIFORM_u_${q}
    ${j} ${X} ${q} = a_${q};
#else
    ${j} ${X} ${q} = u_${q};
#endif
` : `
#ifndef HAS_UNIFORM_u_${q}
    ${j} ${X} ${q} = unpack_mix_${ce}(a_${q}, u_${q}_t);
#else
    ${j} ${X} ${q} = u_${q};
#endif
`;
          }), staticAttributes: g, staticUniforms: S };
        }
        class fs {
          constructor(a, f, g) {
            this.vertexBuffer = a, this.indexBuffer = f, this.segments = g;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var jr = o.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Oc = "#define PROJECTION_MERCATOR", hl = "mercator";
        class ka {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return hl;
          }
          get shaderDefine() {
            return Oc;
          }
          get shaderPreludeCode() {
            return So.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return So.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return o.aK.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(a) {
          }
          getMeshFromTileID(a, f, g, b, w) {
            if (this._cachedMesh) return this._cachedMesh;
            const S = new o.aL();
            S.emplaceBack(0, 0), S.emplaceBack(o.$, 0), S.emplaceBack(0, o.$), S.emplaceBack(o.$, o.$);
            const R = a.createVertexBuffer(S, jr.members), B = o.aM.simpleSegment(0, 0, 4, 2), U = new o.aN();
            U.emplaceBack(1, 0, 2), U.emplaceBack(1, 2, 3);
            const j = a.createIndexBuffer(U);
            return this._cachedMesh = new fs(R, j, B), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(a) {
          }
        }
        class Er {
          constructor(a = 0, f = 0, g = 0, b = 0) {
            if (isNaN(a) || a < 0 || isNaN(f) || f < 0 || isNaN(g) || g < 0 || isNaN(b) || b < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = a, this.bottom = f, this.left = g, this.right = b;
          }
          interpolate(a, f, g) {
            return f.top != null && a.top != null && (this.top = o.C.number(a.top, f.top, g)), f.bottom != null && a.bottom != null && (this.bottom = o.C.number(a.bottom, f.bottom, g)), f.left != null && a.left != null && (this.left = o.C.number(a.left, f.left, g)), f.right != null && a.right != null && (this.right = o.C.number(a.right, f.right, g)), this;
          }
          getCenter(a, f) {
            const g = o.ae((this.left + a - this.right) / 2, 0, a), b = o.ae((this.top + f - this.bottom) / 2, 0, f);
            return new o.P(g, b);
          }
          equals(a) {
            return this.top === a.top && this.bottom === a.bottom && this.left === a.left && this.right === a.right;
          }
          clone() {
            return new Er(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Fn(v, a) {
          if (!v.renderWorldCopies || v.lngRange) return;
          const f = a.lng - v.center.lng;
          a.lng += f > 180 ? -360 : f < -180 ? 360 : 0;
        }
        function es(v) {
          return Math.max(0, Math.floor(v));
        }
        class Bn {
          constructor(a, f) {
            var g;
            this._callbacks = a, this._tileSize = 512, this._renderWorldCopies = f?.renderWorldCopies === void 0 || !!f?.renderWorldCopies, this._minZoom = f?.minZoom || 0, this._maxZoom = f?.maxZoom || 22, this._minPitch = f?.minPitch == null ? 0 : f?.minPitch, this._maxPitch = f?.maxPitch == null ? 60 : f?.maxPitch, this._constrain = (g = f?.constrain) !== null && g !== void 0 ? g : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new o.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = es(this._zoom), this._scale = o.ah(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Er(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(a, f, g) {
            this._latRange = a.latRange, this._lngRange = a.lngRange, this._width = a.width, this._height = a.height, this._center = a.center, this._elevation = a.elevation, this._minElevationForCurrentTile = a.minElevationForCurrentTile, this._zoom = a.zoom, this._tileZoom = es(this._zoom), this._scale = o.ah(this._zoom), this._bearingInRadians = a.bearingInRadians, this._fovInRadians = a.fovInRadians, this._pitchInRadians = a.pitchInRadians, this._rollInRadians = a.rollInRadians, this._unmodified = a.unmodified, this._edgeInsets = new Er(a.padding.top, a.padding.bottom, a.padding.left, a.padding.right), this._minZoom = a.minZoom, this._maxZoom = a.maxZoom, this._minPitch = a.minPitch, this._maxPitch = a.maxPitch, this._renderWorldCopies = a.renderWorldCopies, this._cameraToCenterDistance = a.cameraToCenterDistance, this._nearZ = a.nearZ, this._farZ = a.farZ, this._autoCalculateNearFarZ = !g && a.autoCalculateNearFarZ, f && this.constrainInternal(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(a) {
            this._minElevationForCurrentTile = a;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(a) {
            this._minZoom !== a && (this._minZoom = a, this.setZoom(this.constrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(a) {
            this._maxZoom !== a && (this._maxZoom = a, this.setZoom(this.constrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(a) {
            this._minPitch !== a && (this._minPitch = a, this.setPitch(Math.max(this.pitch, a)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(a) {
            this._maxPitch !== a && (this._maxPitch = a, this.setPitch(Math.min(this.pitch, a)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(a) {
            a === void 0 ? a = !0 : a === null && (a = !1), this._renderWorldCopies = a;
          }
          get constrain() {
            return this._constrain;
          }
          setConstrain(a) {
            a || (a = this._callbacks.constrain), this._constrain = a, this.constrainInternal(), this._calcMatrices();
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new o.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(a) {
            const f = o.aO(a, -180, 180) * Math.PI / 180;
            var g, b, w, S, R, B, U, j, X;
            this._bearingInRadians !== f && (this._unmodified = !1, this._bearingInRadians = f, this._calcMatrices(), this._rotationMatrix = m(), g = this._rotationMatrix, w = -this._bearingInRadians, S = (b = this._rotationMatrix)[0], R = b[1], B = b[2], U = b[3], j = Math.sin(w), X = Math.cos(w), g[0] = S * X + B * j, g[1] = R * X + U * j, g[2] = S * -j + B * X, g[3] = R * -j + U * X);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(a) {
            const f = o.ae(a, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== f && (this._unmodified = !1, this._pitchInRadians = f, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(a) {
            const f = a / 180 * Math.PI;
            this._rollInRadians !== f && (this._unmodified = !1, this._rollInRadians = f, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return o.aP(this._fovInRadians);
          }
          setFov(a) {
            a = o.ae(a, 0.1, 150), this.fov !== a && (this._unmodified = !1, this._fovInRadians = o.ag(a), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(a) {
            const f = this.constrain(this._center, a).zoom;
            this._zoom !== f && (this._unmodified = !1, this._zoom = f, this._tileZoom = Math.max(0, Math.floor(f)), this._scale = o.ah(f), this.constrainInternal(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(a) {
            a.lat === this._center.lat && a.lng === this._center.lng || (this._unmodified = !1, this._center = a, this.constrainInternal(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(a) {
            a !== this._elevation && (this._elevation = a, this.constrainInternal(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(a) {
            this._edgeInsets.equals(a) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, a, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(a, f) {
            this._autoCalculateNearFarZ = !1, this._nearZ = a, this._farZ = f, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(a) {
            return this._edgeInsets.equals(a);
          }
          interpolatePadding(a, f, g) {
            this._unmodified = !1, this._edgeInsets.interpolate(a, f, g), this.constrainInternal(), this._calcMatrices();
          }
          resize(a, f, g = !0) {
            this._width = a, this._height = f, g && this.constrainInternal(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Oe([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(a) {
            a ? (this._lngRange = [a.getWest(), a.getEast()], this._latRange = [a.getSouth(), a.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-o.af, o.af]);
          }
          getCameraQueryGeometry(a, f) {
            if (f.length === 1) return [f[0], a];
            {
              const { minX: g, minY: b, maxX: w, maxY: S } = o.a2.fromPoints(f).extend(a);
              return [new o.P(g, b), new o.P(w, b), new o.P(w, S), new o.P(g, S), new o.P(g, b)];
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const a = this._unmodified, { center: f, zoom: g } = this.constrain(this.center, this.zoom);
            this.setCenter(f), this.setZoom(g), this._unmodified = a, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let a = o.ai(new Float64Array(16));
              o.N(a, a, [this._width / 2, -this._height / 2, 1]), o.M(a, a, [1, -1, 0]), this._clipSpaceToPixelsMatrix = a, a = o.ai(new Float64Array(16)), o.N(a, a, [1, -1, 1]), o.M(a, a, [-1, -1, 0]), o.N(a, a, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = a, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(a, f, g, b) {
            const w = g !== void 0 ? g : this.bearing, S = b = b !== void 0 ? b : this.pitch, R = o.a1.fromLngLat(a, f), B = -Math.cos(o.ag(S)), U = Math.sin(o.ag(S)), j = U * Math.sin(o.ag(w)), X = -U * Math.cos(o.ag(w));
            let q = this.elevation;
            const Q = f - q;
            let ce;
            B * Q >= 0 || Math.abs(B) < 0.1 ? (ce = 1e4, q = f + ce * B) : ce = -Q / B;
            let we, Ae, Se = o.aQ(1, R.y), Me = 0;
            do {
              if (Me += 1, Me > 10) break;
              Ae = ce / Se, we = new o.a1(R.x + j * Ae, R.y + X * Ae), Se = 1 / we.meterInMercatorCoordinateUnits();
            } while (Math.abs(ce - Ae * Se) > 1e-12);
            return { center: we.toLngLat(), elevation: q, zoom: o.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / Ae / this.tileSize) };
          }
          recalculateZoomAndCenter(a) {
            if (this.elevation - a == 0) return;
            const f = o.aj(1, this.center.lat) * this.worldSize, g = this.cameraToCenterDistance / f, b = o.a1.fromLngLat(this.center, this.elevation), w = Bt(this.center, this.elevation, this.pitch, this.bearing, g);
            this._elevation = a;
            const S = this.calculateCenterFromCameraLngLatAlt(w.toLngLat(), o.aQ(w.z, b.y), this.bearing, this.pitch);
            this._elevation = S.elevation, this._center = S.center, this.setZoom(S.zoom);
          }
          getCameraPoint() {
            const a = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new o.P(a * Math.sin(this.rollInRadians), a * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const a = o.aj(1, this.center.lat) * this.worldSize;
            return Bt(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / a).toLngLat();
          }
          getMercatorTileCoordinates(a) {
            if (!a) return [0, 0, 1, 1];
            const f = a.canonical.z >= 0 ? 1 << a.canonical.z : Math.pow(2, a.canonical.z);
            return [a.canonical.x / f, a.canonical.y / f, 1 / f / o.$, 1 / f / o.$];
          }
        }
        class ji {
          constructor(a, f) {
            this.min = a, this.max = f, this.center = o.aR([], o.aS([], this.min, this.max), 0.5);
          }
          quadrant(a) {
            const f = [a % 2 == 0, a < 2], g = o.aT(this.min), b = o.aT(this.max);
            for (let w = 0; w < f.length; w++) g[w] = f[w] ? this.min[w] : this.center[w], b[w] = f[w] ? this.center[w] : this.max[w];
            return b[2] = this.max[2], new ji(g, b);
          }
          distanceX(a) {
            return Math.max(Math.min(this.max[0], a[0]), this.min[0]) - a[0];
          }
          distanceY(a) {
            return Math.max(Math.min(this.max[1], a[1]), this.min[1]) - a[1];
          }
          intersectsFrustum(a) {
            let f = !0;
            for (let g = 0; g < a.planes.length; g++) {
              const b = this.intersectsPlane(a.planes[g]);
              if (b === 0) return 0;
              b === 1 && (f = !1);
            }
            return f ? 2 : a.aabb.min[0] > this.max[0] || a.aabb.min[1] > this.max[1] || a.aabb.min[2] > this.max[2] || a.aabb.max[0] < this.min[0] || a.aabb.max[1] < this.min[1] || a.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(a) {
            let f = a[3], g = a[3];
            for (let b = 0; b < 3; b++) a[b] > 0 ? (f += a[b] * this.min[b], g += a[b] * this.max[b]) : (g += a[b] * this.min[b], f += a[b] * this.max[b]);
            return f >= 0 ? 2 : g < 0 ? 0 : 1;
          }
        }
        class Oa {
          distanceToTile2d(a, f, g, b) {
            const w = b.distanceX([a, f]), S = b.distanceY([a, f]);
            return Math.hypot(w, S);
          }
          getWrap(a, f, g) {
            return g;
          }
          getTileBoundingVolume(a, f, g, b) {
            var w, S;
            let R = 0, B = 0;
            if (b?.terrain) {
              const j = new o.Z(a.z, f, a.z, a.x, a.y), X = b.terrain.getMinMaxElevation(j);
              R = (w = X.minElevation) !== null && w !== void 0 ? w : Math.min(0, g), B = (S = X.maxElevation) !== null && S !== void 0 ? S : Math.max(0, g);
            }
            const U = 1 << a.z;
            return new ji([f + a.x / U, a.y / U, R], [f + (a.x + 1) / U, (a.y + 1) / U, B]);
          }
          allowVariableZoom(a, f) {
            const g = a.fov * (Math.abs(Math.cos(a.rollInRadians)) * a.height + Math.abs(Math.sin(a.rollInRadians)) * a.width) / a.height, b = o.ae(78.5 - g / 2, 0, 60);
            return !!f.terrain || a.pitch > b;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class on {
          constructor(a, f, g) {
            this.points = a, this.planes = f, this.aabb = g;
          }
          static fromInvProjectionMatrix(a, f = 1, g = 0, b, w) {
            const S = w ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], R = Math.pow(2, g), B = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((q) => function(Q, ce, we, Ae) {
              const Se = o.aw([], Q, ce), Me = 1 / Se[3] / we * Ae;
              return o.aY(Se, Se, [Me, Me, 1 / Se[3], Me]);
            }(q, a, f, R));
            b && function(q, Q, ce, we) {
              const Ae = we ? 4 : 0, Se = we ? 0 : 4;
              let Me = 0;
              const Ge = [], Le = [];
              for (let Fe = 0; Fe < 4; Fe++) {
                const Qe = o.aU([], q[Fe + Se], q[Fe + Ae]), At = o.aZ(Qe);
                o.aR(Qe, Qe, 1 / At), Ge.push(At), Le.push(Qe);
              }
              for (let Fe = 0; Fe < 4; Fe++) {
                const Qe = o.a_(q[Fe + Ae], Le[Fe], ce);
                Me = Qe !== null && Qe >= 0 ? Math.max(Me, Qe) : Math.max(Me, Ge[Fe]);
              }
              const $e = function(Fe, Qe) {
                const At = o.aU([], Fe[Qe[0]], Fe[Qe[1]]), ft = o.aU([], Fe[Qe[2]], Fe[Qe[1]]), dt = [0, 0, 0, 0];
                return o.aV(dt, o.aW([], At, ft)), dt[3] = -o.aX(dt, Fe[Qe[0]]), dt;
              }(q, Q), Xe = function(Fe, Qe) {
                const At = o.a$(Fe), ft = o.b0([], Fe, 1 / At), dt = o.aU([], Qe, o.aR([], ft, o.aX(Qe, ft))), _t = o.a$(dt);
                if (_t > 0) {
                  const qt = Math.sqrt(1 - ft[3] * ft[3]), Zt = o.aR([], ft, -ft[3]), zt = o.aS([], Zt, o.aR([], dt, qt / _t));
                  return o.b1(Qe, zt);
                }
                return null;
              }(ce, $e);
              if (Xe !== null) {
                const Fe = Xe / o.aX(Le[0], $e);
                Me = Math.min(Me, Fe);
              }
              for (let Fe = 0; Fe < 4; Fe++) {
                const Qe = Math.min(Me, Ge[Fe]);
                q[Fe + Se] = [q[Fe + Ae][0] + Le[Fe][0] * Qe, q[Fe + Ae][1] + Le[Fe][1] * Qe, q[Fe + Ae][2] + Le[Fe][2] * Qe, 1];
              }
            }(B, S[0], b, w);
            const U = S.map((q) => {
              const Q = o.aU([], B[q[0]], B[q[1]]), ce = o.aU([], B[q[2]], B[q[1]]), we = o.aV([], o.aW([], Q, ce)), Ae = -o.aX(we, B[q[1]]);
              return we.concat(Ae);
            }), j = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], X = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const q of B) for (let Q = 0; Q < 3; Q++) j[Q] = Math.min(j[Q], q[Q]), X[Q] = Math.max(X[Q], q[Q]);
            return new on(B, U, new ji(j, X));
          }
        }
        class Hn {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, f, g) {
            return this._helper.interpolatePadding(a, f, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, f, g = !0) {
            this._helper.resize(a, f, g);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          setConstrain(a) {
            this._helper.setConstrain(a);
          }
          overrideNearFarZ(a, f) {
            this._helper.overrideNearFarZ(a, f);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(a, f) {
          }
          constructor(a) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (f, g) => {
              g = o.ae(+g, this.minZoom, this.maxZoom);
              const b = { center: new o.S(f.lng, f.lat), zoom: g };
              let w = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && w === null) {
                const Le = 179.9999999999;
                w = [-Le, Le];
              }
              const S = this.tileSize * o.ah(b.zoom);
              let R = 0, B = S, U = 0, j = S, X = 0, q = 0;
              const { x: Q, y: ce } = this.size;
              if (this._helper._latRange) {
                const Le = this._helper._latRange;
                R = o.U(Le[1]) * S, B = o.U(Le[0]) * S, B - R < ce && (X = ce / (B - R));
              }
              w && (U = o.aO(o.V(w[0]) * S, 0, S), j = o.aO(o.V(w[1]) * S, 0, S), j < U && (j += S), j - U < Q && (q = Q / (j - U)));
              const { x: we, y: Ae } = qe(S, f);
              let Se, Me;
              const Ge = Math.max(q || 0, X || 0);
              if (Ge) {
                const Le = new o.P(q ? (j + U) / 2 : we, X ? (B + R) / 2 : Ae);
                return b.center = Je(S, Le).wrap(), b.zoom += o.ak(Ge), b;
              }
              if (this._helper._latRange) {
                const Le = ce / 2;
                Ae - Le < R && (Me = R + Le), Ae + Le > B && (Me = B - Le);
              }
              if (w) {
                const Le = (U + j) / 2;
                let $e = we;
                this._helper._renderWorldCopies && ($e = o.aO(we, Le - S / 2, Le + S / 2));
                const Xe = Q / 2;
                $e - Xe < U && (Se = U + Xe), $e + Xe > j && (Se = j - Xe);
              }
              if (Se !== void 0 || Me !== void 0) {
                const Le = new o.P(Se ?? we, Me ?? Ae);
                b.center = Je(S, Le).wrap();
              }
              return b;
            }, this._helper = new Bn({ calcMatrices: () => {
              this._calcMatrices();
            }, constrain: (f, g) => this.defaultConstrain(f, g) }, a), this._coveringTilesDetailsProvider = new Oa();
          }
          clone() {
            const a = new Hn();
            return a.apply(this), a;
          }
          apply(a, f, g) {
            this._helper.apply(a, f, g);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(a) {
            const f = [new o.b2(0, a)];
            if (this._helper._renderWorldCopies) {
              const g = this.screenPointToMercatorCoordinate(new o.P(0, 0)), b = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, 0)), w = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, this._helper._height)), S = this.screenPointToMercatorCoordinate(new o.P(0, this._helper._height)), R = Math.floor(Math.min(g.x, b.x, w.x, S.x)), B = Math.floor(Math.max(g.x, b.x, w.x, S.x)), U = 1;
              for (let j = R - U; j <= B + U; j++) j !== 0 && f.push(new o.b2(j, a));
            }
            return f;
          }
          getCameraFrustum() {
            return on.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(a) {
            const f = this.screenPointToLocation(this.centerPoint, a), g = a ? a.getElevationForLngLatZoom(f, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(g);
          }
          setLocationAtPoint(a, f) {
            const g = o.aj(this.elevation, this.center.lat), b = this.screenPointToMercatorCoordinateAtZ(f, g), w = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, g), S = o.a1.fromLngLat(a), R = new o.a1(S.x - (b.x - w.x), S.y - (b.y - w.y));
            this.setCenter(R?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(a, f) {
            return f ? this.coordinatePoint(o.a1.fromLngLat(a), f.getElevationForLngLatZoom(a, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a1.fromLngLat(a));
          }
          screenPointToLocation(a, f) {
            var g;
            return (g = this.screenPointToMercatorCoordinate(a, f)) === null || g === void 0 ? void 0 : g.toLngLat();
          }
          screenPointToMercatorCoordinate(a, f) {
            if (f) {
              const g = f.pointCoordinate(a);
              if (g != null) return g;
            }
            return this.screenPointToMercatorCoordinateAtZ(a);
          }
          screenPointToMercatorCoordinateAtZ(a, f) {
            const g = f || 0, b = [a.x, a.y, 0, 1], w = [a.x, a.y, 1, 1];
            o.aw(b, b, this._pixelMatrixInverse), o.aw(w, w, this._pixelMatrixInverse);
            const S = b[3], R = w[3], B = b[1] / S, U = w[1] / R, j = b[2] / S, X = w[2] / R, q = j === X ? 0 : (g - j) / (X - j);
            return new o.a1(o.C.number(b[0] / S, w[0] / R, q) / this.worldSize, o.C.number(B, U, q) / this.worldSize, g);
          }
          coordinatePoint(a, f = 0, g = this._pixelMatrix) {
            const b = [a.x * this.worldSize, a.y * this.worldSize, f, 1];
            return o.aw(b, b, g), new o.P(b[0] / b[3], b[1] / b[3]);
          }
          getBounds() {
            const a = Math.max(0, this._helper._height / 2 - He(this));
            return new Oe().extend(this.screenPointToLocation(new o.P(0, a))).extend(this.screenPointToLocation(new o.P(this._helper._width, a))).extend(this.screenPointToLocation(new o.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new o.P(0, this._helper._height)));
          }
          isPointOnMapSurface(a, f) {
            return f ? f.pointCoordinate(a) != null : a.y > this.height / 2 - He(this);
          }
          calculatePosMatrix(a, f = !1, g) {
            var b;
            const w = (b = a.key) !== null && b !== void 0 ? b : o.b3(a.wrap, a.canonical.z, a.canonical.z, a.canonical.x, a.canonical.y), S = f ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (S.has(w)) {
              const U = S.get(w);
              return g ? U.f32 : U.f64;
            }
            const R = nt(a, this.worldSize);
            o.O(R, f ? this._alignedProjMatrix : this._viewProjMatrix, R);
            const B = { f64: R, f32: new Float32Array(R) };
            return S.set(w, B), g ? B.f32 : B.f64;
          }
          calculateFogMatrix(a) {
            const f = a.key, g = this._fogMatrixCacheF32;
            if (g.has(f)) return g.get(f);
            const b = nt(a, this.worldSize);
            return o.O(b, this._fogMatrix, b), g.set(f, new Float32Array(b)), g.get(f);
          }
          calculateCenterFromCameraLngLatAlt(a, f, g, b) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, f, g, b);
          }
          _calculateNearFarZIfNeeded(a, f, g) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const b = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), w = a - b * this._helper._pixelPerMeter / Math.cos(f), S = b < 0 ? w : a, R = Math.PI / 2 + this.pitchInRadians, B = o.ag(this.fov) * (Math.abs(Math.cos(o.ag(this.roll))) * this.height + Math.abs(Math.sin(o.ag(this.roll))) * this.width) / this.height * (0.5 + g.y / this.height), U = Math.sin(B) * S / Math.sin(o.ae(Math.PI - R - B, 0.01, Math.PI - 0.01)), j = He(this), X = Math.atan(j / this._helper.cameraToCenterDistance), q = o.ag(0.75), Q = X > q ? 2 * X * (0.5 + g.y / (2 * j)) : q, ce = Math.sin(Q) * S / Math.sin(o.ae(Math.PI - R - Q, 0.01, Math.PI - 0.01)), we = Math.min(U, ce);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - f) * we + S), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const a = this.centerOffset, f = qe(this.worldSize, this.center), g = f.x, b = f.y;
            this._helper._pixelPerMeter = o.aj(1, this.center.lat) * this.worldSize;
            const w = o.ag(Math.min(this.pitch, Pe)), S = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(w));
            let R;
            this._calculateNearFarZIfNeeded(S, w, a), R = new Float64Array(16), o.b4(R, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), o.aq(this._invProjMatrix, R), R[8] = 2 * -a.x / this._helper._width, R[9] = 2 * a.y / this._helper._height, this._projectionMatrix = o.b5(R), o.N(R, R, [1, -1, 1]), o.M(R, R, [0, 0, -this._helper.cameraToCenterDistance]), o.b6(R, R, -this.rollInRadians), o.b7(R, R, this.pitchInRadians), o.b6(R, R, -this.bearingInRadians), o.M(R, R, [-g, -b, 0]), this._mercatorMatrix = o.N([], R, [this.worldSize, this.worldSize, this.worldSize]), o.N(R, R, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, R), o.M(R, R, [0, 0, -this.elevation]), this._viewProjMatrix = R, this._invViewProjMatrix = o.aq([], R);
            const B = [0, 0, -1, 1];
            o.aw(B, B, this._invViewProjMatrix), this._cameraPosition = [B[0] / B[3], B[1] / B[3], B[2] / B[3]], this._fogMatrix = new Float64Array(16), o.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, S, this._helper._farZ), this._fogMatrix[8] = 2 * -a.x / this.width, this._fogMatrix[9] = 2 * a.y / this.height, o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), o.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), o.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), o.M(this._fogMatrix, this._fogMatrix, [-g, -b, 0]), o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, R);
            const U = this._helper._width % 2 / 2, j = this._helper._height % 2 / 2, X = Math.cos(this.bearingInRadians), q = Math.sin(-this.bearingInRadians), Q = g - Math.round(g) + X * U + q * j, ce = b - Math.round(b) + X * j + q * U, we = new Float64Array(R);
            if (o.M(we, we, [Q > 0.5 ? Q - 1 : Q, ce > 0.5 ? ce - 1 : ce, 0]), this._alignedProjMatrix = we, R = o.aq(new Float64Array(16), this._pixelMatrix), !R) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = R, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const a = this.screenPointToMercatorCoordinate(new o.P(0, 0)), f = [a.x * this.worldSize, a.y * this.worldSize, 0, 1];
            return o.aw(f, f, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const a = o.aj(1, this.center.lat) * this.worldSize;
            return Bt(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / a).toLngLat();
          }
          lngLatToCameraDepth(a, f) {
            const g = o.a1.fromLngLat(a), b = [g.x * this.worldSize, g.y * this.worldSize, f, 1];
            return o.aw(b, b, this._viewProjMatrix), b[2] / b[3];
          }
          getProjectionData(a) {
            const { overscaledTileID: f, aligned: g, applyTerrainMatrix: b } = a, w = this._helper.getMercatorTileCoordinates(f), S = f ? this.calculatePosMatrix(f, g, !0) : null;
            let R;
            return R = f && f.terrainRttPosMatrix32f && b ? f.terrainRttPosMatrix32f : S || o.b8(), { mainMatrix: R, tileMercatorCoords: w, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: R };
          }
          isLocationOccluded(a) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(a, f, g) {
            return 1;
          }
          transformLightDirection(a) {
            return o.aT(a);
          }
          getRayDirectionFromPixel(a) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(a, f, g, b) {
            const w = this.calculatePosMatrix(g);
            let S;
            b ? (S = [a, f, b(a, f), 1], o.aw(S, S, w)) : (S = [a, f, 0, 1], Qi(S, S, w));
            const R = S[3];
            return { point: new o.P(S[0] / R, S[1] / R), signedDistanceFromCamera: R, isOccluded: !1 };
          }
          populateCache(a) {
            for (const f of a) this.calculatePosMatrix(f);
          }
          getMatrixForModel(a, f) {
            const g = o.a1.fromLngLat(a, f), b = g.meterInMercatorCoordinateUnits(), w = o.b9();
            return o.M(w, w, [g.x, g.y, g.z]), o.b6(w, w, Math.PI), o.b7(w, w, Math.PI / 2), o.N(w, w, [-b, b, b]), w;
          }
          getProjectionDataForCustomLayer(a = !0) {
            const f = new o.Z(0, 0, 0, 0, 0), g = this.getProjectionData({ overscaledTileID: f, applyGlobeMatrix: a }), b = nt(f, this.worldSize);
            o.O(b, this._viewProjMatrix, b), g.tileMercatorCoords = [0, 0, 1, 1];
            const w = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter], S = o.ba();
            return o.N(S, b, w), g.fallbackMatrix = S, g.mainMatrix = S, g;
          }
          getFastPathSimpleProjectionMatrix(a) {
            return this.calculatePosMatrix(a);
          }
        }
        function As() {
          o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function fl(v) {
          if (v.useSlerp)
            if (v.k < 1) {
              const a = o.bb(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing), f = o.bb(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing), g = new Float64Array(4);
              o.bc(g, a, f, v.k);
              const b = o.bd(g);
              v.tr.setRoll(b.roll), v.tr.setPitch(b.pitch), v.tr.setBearing(b.bearing);
            } else v.tr.setRoll(v.endEulerAngles.roll), v.tr.setPitch(v.endEulerAngles.pitch), v.tr.setBearing(v.endEulerAngles.bearing);
          else v.tr.setRoll(o.C.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)), v.tr.setPitch(o.C.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)), v.tr.setBearing(o.C.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k));
        }
        function pa(v, a, f, g, b) {
          const w = b.padding, S = qe(b.worldSize, f.getNorthWest()), R = qe(b.worldSize, f.getNorthEast()), B = qe(b.worldSize, f.getSouthEast()), U = qe(b.worldSize, f.getSouthWest()), j = o.ag(-g), X = S.rotate(j), q = R.rotate(j), Q = B.rotate(j), ce = U.rotate(j), we = new o.P(Math.max(X.x, q.x, ce.x, Q.x), Math.max(X.y, q.y, ce.y, Q.y)), Ae = new o.P(Math.min(X.x, q.x, ce.x, Q.x), Math.min(X.y, q.y, ce.y, Q.y)), Se = we.sub(Ae), Me = (b.width - (w.left + w.right + a.left + a.right)) / Se.x, Ge = (b.height - (w.top + w.bottom + a.top + a.bottom)) / Se.y;
          if (Ge < 0 || Me < 0) return void As();
          const Le = Math.min(o.ak(b.scale * Math.min(Me, Ge)), v.maxZoom), $e = o.P.convert(v.offset), Xe = new o.P((a.left - a.right) / 2, (a.top - a.bottom) / 2).rotate(o.ag(g)), Fe = $e.add(Xe).mult(b.scale / o.ah(Le));
          return { center: Je(b.worldSize, S.add(B).div(2).sub(Fe)), zoom: Le, bearing: g };
        }
        class ki {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(a, f) {
            const g = a.mag(), b = Math.abs(He(f));
            return { easingOffset: a.mult(Math.min(0.75 * b / g, 1)), easingCenter: f.center };
          }
          handleMapControlsRollPitchBearingZoom(a, f) {
            a.bearingDelta && f.setBearing(f.bearing + a.bearingDelta), a.pitchDelta && f.setPitch(f.pitch + a.pitchDelta), a.rollDelta && f.setRoll(f.roll + a.rollDelta), a.zoomDelta && f.setZoom(f.zoom + a.zoomDelta);
          }
          handleMapControlsPan(a, f, g) {
            a.around.distSqr(f.centerPoint) < 0.01 || f.setLocationAtPoint(g, a.around);
          }
          cameraForBoxAndBearing(a, f, g, b, w) {
            return pa(a, f, g, b, w);
          }
          handleJumpToCenterZoom(a, f) {
            a.zoom !== (f.zoom !== void 0 ? +f.zoom : a.zoom) && a.setZoom(+f.zoom), f.center !== void 0 && a.setCenter(o.S.convert(f.center));
          }
          handleEaseTo(a, f) {
            const g = a.zoom, b = a.padding, w = { roll: a.roll, pitch: a.pitch, bearing: a.bearing }, S = { roll: f.roll === void 0 ? a.roll : f.roll, pitch: f.pitch === void 0 ? a.pitch : f.pitch, bearing: f.bearing === void 0 ? a.bearing : f.bearing }, R = f.zoom !== void 0, B = !a.isPaddingEqual(f.padding);
            let U = !1;
            const j = R ? +f.zoom : a.zoom;
            let X = a.centerPoint.add(f.offsetAsPoint);
            const q = a.screenPointToLocation(X), { center: Q, zoom: ce } = a.constrain(o.S.convert(f.center || q), j ?? g);
            Fn(a, Q);
            const we = qe(a.worldSize, q), Ae = qe(a.worldSize, Q).sub(we), Se = o.ah(ce - g);
            return U = ce !== g, { easeFunc: (Me) => {
              if (U && a.setZoom(o.C.number(g, ce, Me)), o.be(w, S) || fl({ startEulerAngles: w, endEulerAngles: S, tr: a, k: Me, useSlerp: w.roll != S.roll }), B && (a.interpolatePadding(b, f.padding, Me), X = a.centerPoint.add(f.offsetAsPoint)), f.around) a.setLocationAtPoint(f.around, f.aroundPoint);
              else {
                const Ge = o.ah(a.zoom - g), Le = ce > g ? Math.min(2, Se) : Math.max(0.5, Se), $e = Math.pow(Le, 1 - Me), Xe = Je(a.worldSize, we.add(Ae.mult(Me * $e)).mult(Ge));
                a.setLocationAtPoint(a.renderWorldCopies ? Xe.wrap() : Xe, X);
              }
            }, isZooming: U, elevationCenter: Q };
          }
          handleFlyTo(a, f) {
            const g = f.zoom !== void 0, b = a.zoom, w = a.constrain(o.S.convert(f.center || f.locationAtOffset), g ? +f.zoom : b), S = w.center, R = w.zoom;
            Fn(a, S);
            const B = qe(a.worldSize, f.locationAtOffset), U = qe(a.worldSize, S).sub(B), j = U.mag(), X = o.ah(R - b);
            let q;
            if (f.minZoom !== void 0) {
              const Q = Math.min(+f.minZoom, b, R), ce = a.constrain(S, Q).zoom;
              q = o.ah(ce - b);
            }
            return { easeFunc: (Q, ce, we, Ae) => {
              a.setZoom(Q === 1 ? R : b + o.ak(ce));
              const Se = Q === 1 ? S : Je(a.worldSize, B.add(U.mult(we)).mult(ce));
              a.setLocationAtPoint(a.renderWorldCopies ? Se.wrap() : Se, Ae);
            }, scaleOfZoom: X, targetCenter: S, scaleOfMinZoom: q, pixelPathLength: j };
          }
        }
        class Si {
          constructor(a, f, g) {
            this.blendFunction = a, this.blendColor = f, this.mask = g;
          }
        }
        Si.Replace = [1, 0], Si.disabled = new Si(Si.Replace, o.bf.transparent, [!1, !1, !1, !1]), Si.unblended = new Si(Si.Replace, o.bf.transparent, [!0, !0, !0, !0]), Si.alphaBlended = new Si([1, 771], o.bf.transparent, [!0, !0, !0, !0]);
        const to = 2305;
        class fi {
          constructor(a, f, g) {
            this.enable = a, this.mode = f, this.frontFace = g;
          }
        }
        fi.disabled = new fi(!1, 1029, to), fi.backCCW = new fi(!0, 1029, to), fi.frontCCW = new fi(!0, 1028, to);
        class Or {
          constructor(a, f, g) {
            this.func = a, this.mask = f, this.range = g;
          }
        }
        Or.ReadOnly = !1, Or.ReadWrite = !0, Or.disabled = new Or(519, Or.ReadOnly, [0, 1]);
        const dl = 7680;
        class Qr {
          constructor(a, f, g, b, w, S) {
            this.test = a, this.ref = f, this.mask = g, this.fail = b, this.depthFail = w, this.pass = S;
          }
        }
        Qr.disabled = new Qr({ func: 519, mask: 0 }, 0, 0, dl, dl, dl);
        const Da = /* @__PURE__ */ new WeakMap();
        function ro(v) {
          var a;
          if (Da.has(v)) return Da.get(v);
          {
            const f = (a = v.getParameter(v.VERSION)) === null || a === void 0 ? void 0 : a.startsWith("WebGL 2.0");
            return Da.set(v, f), f;
          }
        }
        class ea {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(a) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = a;
            const f = a.context, g = f.gl;
            this._texFormat = g.RGBA, this._texType = g.UNSIGNED_BYTE;
            const b = new o.aL();
            b.emplaceBack(-1, -1), b.emplaceBack(2, -1), b.emplaceBack(-1, 2);
            const w = new o.aN();
            w.emplaceBack(0, 1, 2), this._fullscreenTriangle = new fs(f.createVertexBuffer(b, jr.members), f.createIndexBuffer(w), o.aM.simpleSegment(0, 0, b.length, w.length)), this._resultBuffer = new Uint8Array(4), f.activeTexture.set(g.TEXTURE1);
            const S = g.createTexture();
            g.bindTexture(g.TEXTURE_2D, S), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.NEAREST), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.NEAREST), g.texImage2D(g.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = f.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(S), ro(g) && (this._pbo = g.createBuffer(), g.bindBuffer(g.PIXEL_PACK_BUFFER, this._pbo), g.bufferData(g.PIXEL_PACK_BUFFER, 4, g.STREAM_READ), g.bindBuffer(g.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const a = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), a.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(a, f) {
            const g = this._updateCount;
            return this._readbackQueue ? g >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : g >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(a, f), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const a = this._cachedRenderContext.context, f = a.gl;
            a.activeTexture.set(f.TEXTURE1), f.bindTexture(f.TEXTURE_2D, this._fbo.colorAttachment.get()), a.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(a, f) {
            const g = this._cachedRenderContext.context, b = g.gl;
            if (this._bindFramebuffer(), g.viewport.set([0, 0, this._texWidth, this._texHeight]), g.clear({ color: o.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(g, b.TRIANGLES, Or.disabled, Qr.disabled, Si.unblended, fi.disabled, /* @__PURE__ */ ((w, S) => ({ u_input: w, u_output_expected: S }))(a, f), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ro(b)) {
              b.bindBuffer(b.PIXEL_PACK_BUFFER, this._pbo), b.readBuffer(b.COLOR_ATTACHMENT0), b.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), b.bindBuffer(b.PIXEL_PACK_BUFFER, null);
              const w = b.fenceSync(b.SYNC_GPU_COMMANDS_COMPLETE, 0);
              b.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: w };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const a = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && ro(a)) {
              const f = a.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (f === a.WAIT_FAILED) return o.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (f === a.TIMEOUT_EXPIRED) return;
              a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo), a.getBufferSubData(a.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), a.bindBuffer(a.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), a.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = ea._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(a) {
            let f = 0;
            return f += a[0] / 256, f += a[1] / 65536, f += a[2] / 16777216, a[3] < 127 && (f = -f), f / 128;
          }
        }
        const ta = o.$ / 128;
        function ra(v, a) {
          const f = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1, g = f + (v.generateBorders ? 2 : 0), b = f + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0), w = g + 1, S = b + 1, R = v.generateBorders ? -1 : 0, B = v.generateBorders || v.extendToNorthPole ? -1 : 0, U = f + (v.generateBorders ? 1 : 0), j = f + (v.generateBorders || v.extendToSouthPole ? 1 : 0), X = w * S, q = g * b * 6, Q = w * S > 65536;
          if (Q && a === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const ce = Q || a === "32bit", we = new Int16Array(2 * X);
          let Ae = 0;
          for (let Ge = B; Ge <= j; Ge++) for (let Le = R; Le <= U; Le++) {
            let $e = Le / f * o.$;
            Le === -1 && ($e = -ta), Le === f + 1 && ($e = o.$ + ta);
            let Xe = Ge / f * o.$;
            Ge === -1 && (Xe = v.extendToNorthPole ? o.bh : -ta), Ge === f + 1 && (Xe = v.extendToSouthPole ? o.bi : o.$ + ta), we[Ae++] = $e, we[Ae++] = Xe;
          }
          const Se = ce ? new Uint32Array(q) : new Uint16Array(q);
          let Me = 0;
          for (let Ge = 0; Ge < b; Ge++) for (let Le = 0; Le < g; Le++) {
            const $e = Le + 1 + Ge * w, Xe = Le + (Ge + 1) * w, Fe = Le + 1 + (Ge + 1) * w;
            Se[Me++] = Le + Ge * w, Se[Me++] = Xe, Se[Me++] = $e, Se[Me++] = $e, Se[Me++] = Xe, Se[Me++] = Fe;
          }
          return { vertices: we.buffer.slice(0), indices: Se.buffer.slice(0), uses32bitIndices: ce };
        }
        const Na = new o.aK({ fill: new o.bj(128, 2), line: new o.bj(512, 0), tile: new o.bj(128, 32), stencil: new o.bj(128, 1), circle: 3 });
        class pl {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return So.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return So.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Na;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(a) {
            this._errorMeasurement || (this._errorMeasurement = new ea(a));
            const f = o.U(this._errorQueryLatitudeDegrees), g = 2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) - 0.5 * Math.PI, b = this._errorMeasurement.updateErrorLoop(f, g), w = D();
            b !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = b, this._errorMeasurementLastChangeTime = w);
            const S = Math.min(Math.max((w - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = o.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bl(S));
          }
          _getMeshKey(a) {
            return `${a.granularity.toString(36)}_${a.generateBorders ? "b" : ""}${a.extendToNorthPole ? "n" : ""}${a.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(a, f, g, b, w) {
            const S = (w === "stencil" ? Na.stencil : Na.tile).getGranularityForZoomLevel(f.z);
            return this._getMesh(a, { granularity: S, generateBorders: g, extendToNorthPole: f.y === 0 && b, extendToSouthPole: f.y === (1 << f.z) - 1 && b });
          }
          _getMesh(a, f) {
            const g = this._getMeshKey(f);
            if (g in this._tileMeshCache) return this._tileMeshCache[g];
            const b = function(w, S) {
              const R = ra(S, "16bit"), B = o.aL.deserialize({ arrayBuffer: R.vertices, length: R.vertices.byteLength / 2 / 2 }), U = o.aN.deserialize({ arrayBuffer: R.indices, length: R.indices.byteLength / 2 / 3 });
              return new fs(w.createVertexBuffer(B, jr.members), w.createIndexBuffer(U), o.aM.simpleSegment(0, 0, B.length, U.length));
            }(a, f);
            return this._tileMeshCache[g] = b, b;
          }
          recalculate(a) {
          }
          hasTransition() {
            const a = D();
            let f = !1;
            return f = f || (a - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, f = f || this._errorMeasurement && this._errorMeasurement.awaitingQuery, f;
          }
          setErrorQueryLatitudeDegrees(a) {
            this._errorQueryLatitudeDegrees = a;
          }
        }
        const Ts = new o.r({ type: new o.D(o.v.projection.type) });
        class po extends o.E {
          constructor(a) {
            super(), this._transitionable = new o.t(Ts, void 0), this.setProjection(a), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0)), this._mercatorProjection = new ka(), this._verticalPerspectiveProjection = new pl();
          }
          get transitionState() {
            const a = this.properties.get("type");
            if (typeof a == "string" && a === "mercator") return 0;
            if (typeof a == "string" && a === "vertical-perspective") return 1;
            if (a instanceof o.bm) {
              if (a.from === "vertical-perspective" && a.to === "mercator") return 1 - a.transition;
              if (a.from === "mercator" && a.to === "vertical-perspective") return a.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(a) {
            this._mercatorProjection.updateGPUdependent(a), this._verticalPerspectiveProjection.updateGPUdependent(a);
          }
          getMeshFromTileID(a, f, g, b, w) {
            return this.currentProjection.getMeshFromTileID(a, f, g, b, w);
          }
          setProjection(a) {
            this._transitionable.setValue("type", a?.type || "mercator");
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          setErrorQueryLatitudeDegrees(a) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(a), this._mercatorProjection.setErrorQueryLatitudeDegrees(a);
          }
        }
        function F(v) {
          const a = Ye(v.worldSize, v.center.lat);
          return 2 * Math.PI * a;
        }
        function se(v, a, f, g, b) {
          const w = 1 / (1 << b), S = a / o.$ * w + g * w, R = o.bo((v / o.$ * w + f * w) * Math.PI * 2 + Math.PI, 2 * Math.PI), B = 2 * Math.atan(Math.exp(Math.PI - S * Math.PI * 2)) - 0.5 * Math.PI, U = Math.cos(B), j = new Float64Array(3);
          return j[0] = Math.sin(R) * U, j[1] = Math.sin(B), j[2] = Math.cos(R) * U, j;
        }
        function Ie(v) {
          return function(a, f) {
            const g = Math.cos(f), b = new Float64Array(3);
            return b[0] = Math.sin(a) * g, b[1] = Math.sin(f), b[2] = Math.cos(a) * g, b;
          }(v.lng * Math.PI / 180, v.lat * Math.PI / 180);
        }
        function Ye(v, a) {
          return v / (2 * Math.PI) / Math.cos(a * Math.PI / 180);
        }
        function ut(v) {
          const a = Math.asin(v[1]) / Math.PI * 180, f = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
          if (f > 1e-6) {
            const g = v[0] / f, b = Math.acos(v[2] / f), w = (g > 0 ? b : -b) / Math.PI * 180;
            return new o.S(o.aO(w, -180, 180), a);
          }
          return new o.S(0, a);
        }
        function Nt(v) {
          return Math.cos(v * Math.PI / 180);
        }
        function Ut(v, a) {
          const f = Nt(v), g = Nt(a);
          return o.ak(g / f);
        }
        function vr(v, a) {
          const f = v.rotate(a.bearingInRadians), g = a.zoom + Ut(a.center.lat, 0), b = o.bk(1 / Nt(a.center.lat), 1 / Nt(Math.min(Math.abs(a.center.lat), 60)), o.bn(g, 7, 3, 0, 1)), w = 360 / F({ worldSize: a.worldSize, center: { lat: a.center.lat } });
          return new o.S(a.center.lng - f.x * w * b, o.ae(a.center.lat + f.y * w, -o.af, o.af));
        }
        function Cr(v) {
          const a = 0.5 * v, f = Math.sin(a), g = Math.cos(a);
          return Math.log(f + g) - Math.log(g - f);
        }
        function Ir(v, a, f, g) {
          const b = v.lat + f * g;
          if (Math.abs(f) > 1) {
            const w = (Math.sign(v.lat + f) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180, S = Math.abs(v.lat + f) * Math.PI / 180, R = Cr(w + g * (S - w)), B = Cr(w), U = Cr(S);
            return new o.S(v.lng + a * ((R - B) / (U - B)), b);
          }
          return new o.S(v.lng + a * g, b);
        }
        class ni {
          constructor(a) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = a;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const a = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = a, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(a, f, g, b) {
            const w = `${a.z}_${a.x}_${a.y}_${b?.terrain ? "t" : ""}`, S = this._cache.get(w);
            if (S) return S;
            const R = this._cachePrevious.get(w);
            if (R) return this._cache.set(w, R), R;
            const B = this._boundingVolumeFactory(a, f, g, b);
            return this._cache.set(w, B), this._hadAnyChanges = !0, B;
          }
        }
        class ri {
          constructor(a, f, g, b) {
            this.min = g, this.max = b, this.points = a, this.planes = f;
          }
          static fromAabb(a, f) {
            const g = [];
            for (let b = 0; b < 8; b++) g.push([1 & ~b ? a[0] : f[0], (b >> 1 & 1) == 1 ? f[1] : a[1], (b >> 2 & 1) == 1 ? f[2] : a[2]]);
            return new ri(g, [[-1, 0, 0, f[0]], [1, 0, 0, -a[0]], [0, -1, 0, f[1]], [0, 1, 0, -a[1]], [0, 0, -1, f[2]], [0, 0, 1, -a[2]]], a, f);
          }
          static fromCenterSizeAngles(a, f, g) {
            const b = o.br([], g[0], g[1], g[2]), w = o.bs([], [f[0], 0, 0], b), S = o.bs([], [0, f[1], 0], b), R = o.bs([], [0, 0, f[2]], b), B = [...a], U = [...a];
            for (let X = 0; X < 8; X++) for (let q = 0; q < 3; q++) {
              const Q = a[q] + w[q] * (1 & ~X ? -1 : 1) + S[q] * ((X >> 1 & 1) == 1 ? 1 : -1) + R[q] * ((X >> 2 & 1) == 1 ? 1 : -1);
              B[q] = Math.min(B[q], Q), U[q] = Math.max(U[q], Q);
            }
            const j = [];
            for (let X = 0; X < 8; X++) {
              const q = [...a];
              o.aS(q, q, o.aR([], w, 1 & ~X ? -1 : 1)), o.aS(q, q, o.aR([], S, (X >> 1 & 1) == 1 ? 1 : -1)), o.aS(q, q, o.aR([], R, (X >> 2 & 1) == 1 ? 1 : -1)), j.push(q);
            }
            return new ri(j, [[...w, -o.aX(w, j[0])], [...S, -o.aX(S, j[0])], [...R, -o.aX(R, j[0])], [-w[0], -w[1], -w[2], -o.aX(w, j[7])], [-S[0], -S[1], -S[2], -o.aX(S, j[7])], [-R[0], -R[1], -R[2], -o.aX(R, j[7])]], B, U);
          }
          intersectsFrustum(a) {
            let f = !0;
            const g = this.points.length, b = this.planes.length, w = a.planes.length, S = a.points.length;
            for (let R = 0; R < w; R++) {
              const B = a.planes[R];
              let U = 0;
              for (let j = 0; j < g; j++) {
                const X = this.points[j];
                B[0] * X[0] + B[1] * X[1] + B[2] * X[2] + B[3] >= 0 && U++;
              }
              if (U === 0) return 0;
              U < g && (f = !1);
            }
            if (f) return 2;
            for (let R = 0; R < b; R++) {
              const B = this.planes[R];
              let U = 0;
              for (let j = 0; j < S; j++) {
                const X = a.points[j];
                B[0] * X[0] + B[1] * X[1] + B[2] * X[2] + B[3] >= 0 && U++;
              }
              if (U === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(a) {
            const f = this.points.length;
            let g = 0;
            for (let b = 0; b < f; b++) {
              const w = this.points[b];
              a[0] * w[0] + a[1] * w[1] + a[2] * w[2] + a[3] >= 0 && g++;
            }
            return g === f ? 2 : g === 0 ? 0 : 1;
          }
        }
        function Fi(v, a, f) {
          const g = v - a;
          return g < 0 ? -g : Math.max(0, g - f);
        }
        function En(v, a, f, g, b) {
          const w = v - f;
          let S;
          return S = w < 0 ? Math.min(-w, 1 + w - b) : w > 1 ? Math.min(Math.max(w - b, 0), 1 - w) : 0, Math.max(S, Fi(a, g, b));
        }
        class Ui {
          constructor() {
            this._boundingVolumeCache = new ni(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(a, f, g, b) {
            const w = 1 << g.z, S = 1 / w, R = g.x / w, B = g.y / w;
            let U = 2;
            return U = Math.min(U, En(a, f, R, B, S)), U = Math.min(U, En(a, f, R + 0.5, -B - S, S)), U = Math.min(U, En(a, f, R + 0.5, 2 - B - S, S)), U;
          }
          getWrap(a, f, g) {
            const b = 1 << f.z, w = 1 / b, S = f.x / b, R = Fi(a.x, S, w), B = Fi(a.x, S - 1, w), U = Fi(a.x, S + 1, w), j = Math.min(R, B, U);
            return j === U ? 1 : j === B ? -1 : 0;
          }
          allowVariableZoom(a, f) {
            return Li(a, f) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(a, f, g, b) {
            return this._boundingVolumeCache.getTileBoundingVolume(a, f, g, b);
          }
          _computeTileBoundingVolume(a, f, g, b) {
            var w, S;
            let R = 0, B = 0;
            if (b?.terrain) {
              const U = new o.Z(a.z, f, a.z, a.x, a.y), j = b.terrain.getMinMaxElevation(U);
              R = (w = j.minElevation) !== null && w !== void 0 ? w : Math.min(0, g), B = (S = j.maxElevation) !== null && S !== void 0 ? S : Math.max(0, g);
            }
            if (R /= o.bu, B /= o.bu, R += 1, B += 1, a.z <= 0) return ri.fromAabb([-B, -B, -B], [B, B, B]);
            if (a.z === 1) return ri.fromAabb([a.x === 0 ? -B : 0, a.y === 0 ? 0 : -B, -B], [a.x === 0 ? 0 : B, a.y === 0 ? B : 0, B]);
            {
              const U = [se(0, 0, a.x, a.y, a.z), se(o.$, 0, a.x, a.y, a.z), se(o.$, o.$, a.x, a.y, a.z), se(0, o.$, a.x, a.y, a.z)], j = [];
              for (const dt of U) j.push(o.aR([], dt, B));
              if (B !== R) for (const dt of U) j.push(o.aR([], dt, R));
              a.y === 0 && j.push([0, 1, 0]), a.y === (1 << a.z) - 1 && j.push([0, -1, 0]);
              const X = [1, 1, 1], q = [-1, -1, -1];
              for (const dt of j) for (let _t = 0; _t < 3; _t++) X[_t] = Math.min(X[_t], dt[_t]), q[_t] = Math.max(q[_t], dt[_t]);
              const Q = se(o.$ / 2, o.$ / 2, a.x, a.y, a.z), ce = o.aW([], [0, 1, 0], Q);
              o.aV(ce, ce);
              const we = o.aW([], Q, ce);
              o.aV(we, we);
              const Ae = o.aW([], U[2], U[1]);
              o.aV(Ae, Ae);
              const Se = o.aW([], U[0], U[3]);
              o.aV(Se, Se), j.push(o.aR([], Q, B)), a.y >= (1 << a.z) / 2 && j.push(o.aR([], se(o.$ / 2, 0, a.x, a.y, a.z), B)), a.y < (1 << a.z) / 2 && j.push(o.aR([], se(o.$ / 2, o.$, a.x, a.y, a.z), B));
              const Me = an(Q, j), Ge = an(we, j), Le = [-Q[0], -Q[1], -Q[2], Me.max], $e = [Q[0], Q[1], Q[2], -Me.min], Xe = [-we[0], -we[1], -we[2], Ge.max], Fe = [we[0], we[1], we[2], -Ge.min], Qe = [...Ae, 0], At = [...Se, 0], ft = [];
              return a.y === 0 ? ft.push(o.bt(At, Qe, Le), o.bt(At, Qe, $e)) : ft.push(o.bt(Xe, Qe, Le), o.bt(Xe, Qe, $e), o.bt(Xe, At, Le), o.bt(Xe, At, $e)), a.y === (1 << a.z) - 1 ? ft.push(o.bt(At, Qe, Le), o.bt(At, Qe, $e)) : ft.push(o.bt(Fe, Qe, Le), o.bt(Fe, Qe, $e), o.bt(Fe, At, Le), o.bt(Fe, At, $e)), new ri(ft, [Le, $e, Xe, Fe, Qe, At], X, q);
            }
          }
        }
        function an(v, a) {
          let f = 1 / 0, g = -1 / 0;
          for (const b of a) {
            const w = o.aX(v, b);
            f = Math.min(f, w), g = Math.max(g, w);
          }
          return { min: f, max: g };
        }
        class vn {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, f, g) {
            return this._helper.interpolatePadding(a, f, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, f) {
            this._helper.resize(a, f);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          setConstrain(a) {
            this._helper.setConstrain(a);
          }
          overrideNearFarZ(a, f) {
            this._helper.overrideNearFarZ(a, f);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(a) {
          }
          constructor(a) {
            this._cachedClippingPlane = o.bv(), this._projectionMatrix = o.b9(), this._globeViewProjMatrix32f = o.b8(), this._globeViewProjMatrixNoCorrection = o.b9(), this._globeViewProjMatrixNoCorrectionInverted = o.b9(), this._globeProjMatrixInverted = o.b9(), this._cameraPosition = o.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (f, g) => {
              const b = o.ae(f.lat, -o.af, o.af), w = o.ae(+g, this.minZoom + Ut(0, b), this.maxZoom);
              return { center: new o.S(f.lng, b), zoom: w };
            }, this._helper = new Bn({ calcMatrices: () => {
              this._calcMatrices();
            }, constrain: (f, g) => this.defaultConstrain(f, g) }, a), this._coveringTilesDetailsProvider = new Ui();
          }
          clone() {
            const a = new vn();
            return a.apply(this), a;
          }
          apply(a, f) {
            this._globeLatitudeErrorCorrectionRadians = f || 0, this._helper.apply(a);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const a = o.bp();
            return a[0] = this._cameraPosition[0], a[1] = this._cameraPosition[1], a[2] = this._cameraPosition[2], a;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(a) {
            const { overscaledTileID: f, applyGlobeMatrix: g } = a, b = this._helper.getMercatorTileCoordinates(f);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: b, clippingPlane: this._cachedClippingPlane, projectionTransition: g ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(a) {
            const f = this.pitchInRadians, g = this.cameraToCenterDistance / a, b = Math.sin(f) * g, w = Math.cos(f) * g + 1, S = 1 / Math.sqrt(b * b + w * w) * 1;
            let R = -b, B = w;
            const U = Math.sqrt(R * R + B * B);
            R /= U, B /= U;
            const j = [0, R, B];
            o.bw(j, j, [0, 0, 0], -this.bearingInRadians), o.bx(j, j, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), o.by(j, j, [0, 0, 0], this.center.lng * Math.PI / 180);
            const X = 1 / o.aZ(j);
            return o.aR(j, j, X), [...j, -S * X];
          }
          isLocationOccluded(a) {
            return !this.isSurfacePointVisible(Ie(a));
          }
          transformLightDirection(a) {
            const f = this._helper._center.lng * Math.PI / 180, g = this._helper._center.lat * Math.PI / 180, b = Math.cos(g), w = [Math.sin(f) * b, Math.sin(g), Math.cos(f) * b], S = [w[2], 0, -w[0]], R = [0, 0, 0];
            o.aW(R, S, w), o.aV(S, S), o.aV(R, R);
            const B = [0, 0, 0];
            return o.aV(B, [S[0] * a[0] + R[0] * a[1] + w[0] * a[2], S[1] * a[0] + R[1] * a[1] + w[1] * a[2], S[2] * a[0] + R[2] * a[1] + w[2] * a[2]]), B;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(a, f, g) {
            const b = function(R, B, U) {
              const j = 1 / (1 << U.z);
              return new o.a1(R / o.$ * j + U.x * j, B / o.$ * j + U.y * j);
            }(a, f, g.canonical), w = (S = b.y, [o.bo(b.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - S * Math.PI * 2)) - 0.5 * Math.PI]);
            var S;
            return this.getCircleRadiusCorrection() / Math.cos(w[1]);
          }
          projectTileCoordinates(a, f, g, b) {
            const w = g.canonical, S = se(a, f, w.x, w.y, w.z), R = 1 + (b ? b(a, f) : 0) / o.bu, B = [S[0] * R, S[1] * R, S[2] * R, 1];
            o.aw(B, B, this._globeViewProjMatrixNoCorrection);
            const U = this._cachedClippingPlane, j = U[0] * S[0] + U[1] * S[1] + U[2] * S[2] + U[3] < 0;
            return { point: new o.P(B[0] / B[3], B[1] / B[3]), signedDistanceFromCamera: B[3], isOccluded: j };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const a = Ye(this.worldSize, this.center.lat), f = o.ba(), g = o.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * a), o.b4(f, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const b = this.centerOffset;
            f[8] = 2 * -b.x / this._helper._width, f[9] = 2 * b.y / this._helper._height, this._projectionMatrix = o.b5(f), this._globeProjMatrixInverted = o.ba(), o.aq(this._globeProjMatrixInverted, f), o.M(f, f, [0, 0, -this.cameraToCenterDistance]), o.b6(f, f, this.rollInRadians), o.b7(f, f, -this.pitchInRadians), o.b6(f, f, this.bearingInRadians), o.M(f, f, [0, 0, -a]);
            const w = o.bp();
            w[0] = a, w[1] = a, w[2] = a, o.b7(g, f, this.center.lat * Math.PI / 180), o.bz(g, g, -this.center.lng * Math.PI / 180), o.N(g, g, w), this._globeViewProjMatrixNoCorrection = g, o.b7(f, f, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), o.bz(f, f, -this.center.lng * Math.PI / 180), o.N(f, f, w), this._globeViewProjMatrix32f = new Float32Array(f), this._globeViewProjMatrixNoCorrectionInverted = o.ba(), o.aq(this._globeViewProjMatrixNoCorrectionInverted, g);
            const S = o.bp();
            this._cameraPosition = o.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / a, o.bw(this._cameraPosition, this._cameraPosition, S, -this.rollInRadians), o.bx(this._cameraPosition, this._cameraPosition, S, this.pitchInRadians), o.bw(this._cameraPosition, this._cameraPosition, S, -this.bearingInRadians), o.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), o.bx(this._cameraPosition, this._cameraPosition, S, -this.center.lat * Math.PI / 180), o.by(this._cameraPosition, this._cameraPosition, S, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(a);
            const R = o.b5(this._globeViewProjMatrixNoCorrectionInverted);
            o.N(R, R, [1, 1, -1]), this._cachedFrustum = on.fromInvProjectionMatrix(R, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(a) {
            o.w("calculateFogMatrix is not supported on globe projection.");
            const f = o.ba();
            return o.ai(f), f;
          }
          getVisibleUnwrappedCoordinates(a) {
            return [new o.b2(0, a)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(a) {
            a && o.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(a, f) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const g = Ie(a);
            o.aR(g, g, 1 + f / o.bu);
            const b = o.bv();
            return o.aw(b, [g[0], g[1], g[2], 1], this._globeViewProjMatrixNoCorrection), b[2] / b[3];
          }
          populateCache(a) {
          }
          getBounds() {
            const a = 0.5 * this.width, f = 0.5 * this.height, g = [new o.P(0, 0), new o.P(a, 0), new o.P(this.width, 0), new o.P(this.width, f), new o.P(this.width, this.height), new o.P(a, this.height), new o.P(0, this.height), new o.P(0, f)], b = [];
            for (const X of g) b.push(this.unprojectScreenPoint(X));
            let w = 0, S = 0, R = 0, B = 0;
            const U = this.center;
            for (const X of b) {
              const q = o.bA(U.lng, X.lng), Q = o.bA(U.lat, X.lat);
              q < S && (S = q), q > w && (w = q), Q < B && (B = Q), Q > R && (R = Q);
            }
            const j = [U.lng + S, U.lat + B, U.lng + w, U.lat + R];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (j[3] = 90, j[0] = -180, j[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (j[1] = -90, j[0] = -180, j[2] = 180), new Oe(j);
          }
          calculateCenterFromCameraLngLatAlt(a, f, g, b) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, f, g, b);
          }
          setLocationAtPoint(a, f) {
            const g = Ie(this.unprojectScreenPoint(f)), b = Ie(a), w = o.bp();
            o.bB(w);
            const S = o.bp();
            o.by(S, g, w, -this.center.lng * Math.PI / 180), o.bx(S, S, w, this.center.lat * Math.PI / 180);
            const R = b[0] * b[0] + b[2] * b[2], B = S[0] * S[0];
            if (R < B) return;
            const U = Math.sqrt(R - B), j = -U, X = o.bC(b[0], b[2], S[0], U), q = o.bC(b[0], b[2], S[0], j), Q = o.bp();
            o.by(Q, b, w, -X);
            const ce = o.bC(Q[1], Q[2], S[1], S[2]), we = o.bp();
            o.by(we, b, w, -q);
            const Ae = o.bC(we[1], we[2], S[1], S[2]), Se = 0.5 * Math.PI, Me = ce >= -Se && ce <= Se, Ge = Ae >= -Se && Ae <= Se;
            let Le, $e;
            if (Me && Ge) {
              const At = this.center.lng * Math.PI / 180, ft = this.center.lat * Math.PI / 180;
              o.bD(X, At) + o.bD(ce, ft) < o.bD(q, At) + o.bD(Ae, ft) ? (Le = X, $e = ce) : (Le = q, $e = Ae);
            } else if (Me) Le = X, $e = ce;
            else {
              if (!Ge) return;
              Le = q, $e = Ae;
            }
            const Xe = Le / Math.PI * 180, Fe = $e / Math.PI * 180, Qe = this.center.lat;
            this.setCenter(new o.S(Xe, o.ae(Fe, -90, 90))), this.setZoom(this.zoom + Ut(Qe, this.center.lat));
          }
          locationToScreenPoint(a, f) {
            const g = Ie(a);
            if (f) {
              const b = f.getElevationForLngLatZoom(a, this._helper._tileZoom);
              o.aR(g, g, 1 + b / o.bu);
            }
            return this._projectSurfacePointToScreen(g);
          }
          _projectSurfacePointToScreen(a) {
            const f = o.bv();
            return o.aw(f, [...a, 1], this._globeViewProjMatrixNoCorrection), f[0] /= f[3], f[1] /= f[3], new o.P((0.5 * f[0] + 0.5) * this.width, (0.5 * -f[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(a, f) {
            if (f) {
              const g = f.pointCoordinate(a);
              if (g) return g;
            }
            return o.a1.fromLngLat(this.unprojectScreenPoint(a));
          }
          screenPointToLocation(a, f) {
            var g;
            return (g = this.screenPointToMercatorCoordinate(a, f)) === null || g === void 0 ? void 0 : g.toLngLat();
          }
          isPointOnMapSurface(a, f) {
            const g = this._cameraPosition, b = this.getRayDirectionFromPixel(a);
            return !!this.rayPlanetIntersection(g, b);
          }
          getRayDirectionFromPixel(a) {
            const f = o.bv();
            f[0] = a.x / this.width * 2 - 1, f[1] = -1 * (a.y / this.height * 2 - 1), f[2] = 1, f[3] = 1, o.aw(f, f, this._globeViewProjMatrixNoCorrectionInverted), f[0] /= f[3], f[1] /= f[3], f[2] /= f[3];
            const g = o.bp();
            g[0] = f[0] - this._cameraPosition[0], g[1] = f[1] - this._cameraPosition[1], g[2] = f[2] - this._cameraPosition[2];
            const b = o.bp();
            return o.aV(b, g), b;
          }
          isSurfacePointVisible(a) {
            const f = this._cachedClippingPlane;
            return f[0] * a[0] + f[1] * a[1] + f[2] * a[2] + f[3] >= 0;
          }
          isSurfacePointOnScreen(a) {
            if (!this.isSurfacePointVisible(a)) return !1;
            const f = o.bv();
            return o.aw(f, [...a, 1], this._globeViewProjMatrixNoCorrection), f[0] /= f[3], f[1] /= f[3], f[2] /= f[3], f[0] > -1 && f[0] < 1 && f[1] > -1 && f[1] < 1 && f[2] > -1 && f[2] < 1;
          }
          rayPlanetIntersection(a, f) {
            const g = o.aX(a, f), b = o.bp(), w = o.bp();
            o.aR(w, f, g), o.aU(b, a, w);
            const S = 1 - o.aX(b, b);
            if (S < 0) return null;
            const R = o.aX(a, a) - 1, B = -g + (g < 0 ? 1 : -1) * Math.sqrt(S), U = R / B, j = B;
            return { tMin: Math.min(U, j), tMax: Math.max(U, j) };
          }
          unprojectScreenPoint(a) {
            const f = this._cameraPosition, g = this.getRayDirectionFromPixel(a), b = this.rayPlanetIntersection(f, g);
            if (b) {
              const j = o.bp();
              o.aS(j, f, [g[0] * b.tMin, g[1] * b.tMin, g[2] * b.tMin]);
              const X = o.bp();
              return o.aV(X, j), ut(X);
            }
            const w = this._cachedClippingPlane, S = w[0] * g[0] + w[1] * g[1] + w[2] * g[2], R = -o.b1(w, f) / S, B = o.bp();
            if (R > 0) o.aS(B, f, [g[0] * R, g[1] * R, g[2] * R]);
            else {
              const j = o.bp();
              o.aS(j, f, [2 * g[0], 2 * g[1], 2 * g[2]]);
              const X = o.b1(this._cachedClippingPlane, j);
              o.aU(B, j, [this._cachedClippingPlane[0] * X, this._cachedClippingPlane[1] * X, this._cachedClippingPlane[2] * X]);
            }
            const U = function(j) {
              const X = o.bp();
              return X[0] = j[0] * -j[3], X[1] = j[1] * -j[3], X[2] = j[2] * -j[3], { center: X, radius: Math.sqrt(1 - j[3] * j[3]) };
            }(w);
            return ut(function(j, X, q) {
              const Q = o.bp();
              o.aU(Q, q, j);
              const ce = o.bp();
              return o.bq(ce, j, Q, X / o.a$(Q)), ce;
            }(U.center, U.radius, B));
          }
          getMatrixForModel(a, f) {
            const g = o.S.convert(a), b = 1 / o.bu, w = o.b9();
            return o.bz(w, w, g.lng / 180 * Math.PI), o.b7(w, w, -g.lat / 180 * Math.PI), o.M(w, w, [0, 0, 1 + f / o.bu]), o.b7(w, w, 0.5 * Math.PI), o.N(w, w, [b, b, b]), w;
          }
          getProjectionDataForCustomLayer(a = !0) {
            const f = this.getProjectionData({ overscaledTileID: new o.Z(0, 0, 0, 0, 0), applyGlobeMatrix: a });
            return f.tileMercatorCoords = [0, 0, 1, 1], f;
          }
          getFastPathSimpleProjectionMatrix(a) {
          }
        }
        class Un {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, f, g) {
            return this._helper.interpolatePadding(a, f, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, f, g = !0) {
            this._helper.resize(a, f, g);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          setConstrain(a) {
            this._helper.setConstrain(a);
          }
          overrideNearFarZ(a, f) {
            this._helper.overrideNearFarZ(a, f);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(a, f) {
            this._globeness = a, this._globeLatitudeErrorCorrectionRadians = f, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor(a) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (f, g) => this.currentTransform.defaultConstrain(f, g), this._helper = new Bn({ calcMatrices: () => {
              this._calcMatrices();
            }, constrain: (f, g) => this.defaultConstrain(f, g) }, a), this._globeness = 1, this._mercatorTransform = new Hn(), this._verticalPerspectiveTransform = new vn();
          }
          clone() {
            const a = new Un();
            return a._globeness = this._globeness, a._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, a.apply(this), a;
          }
          apply(a) {
            this._helper.apply(a), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(a) {
            const f = this._mercatorTransform.getProjectionData(a), g = this._verticalPerspectiveTransform.getProjectionData(a);
            return { mainMatrix: this.isGlobeRendering ? g.mainMatrix : f.mainMatrix, clippingPlane: g.clippingPlane, tileMercatorCoords: g.tileMercatorCoords, projectionTransition: a.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: f.fallbackMatrix };
          }
          isLocationOccluded(a) {
            return this.currentTransform.isLocationOccluded(a);
          }
          transformLightDirection(a) {
            return this.currentTransform.transformLightDirection(a);
          }
          getPixelScale() {
            return o.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return o.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(a, f, g) {
            const b = this._mercatorTransform.getPitchedTextCorrection(a, f, g), w = this._verticalPerspectiveTransform.getPitchedTextCorrection(a, f, g);
            return o.bk(b, w, this._globeness);
          }
          projectTileCoordinates(a, f, g, b) {
            return this.currentTransform.projectTileCoordinates(a, f, g, b);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(a) {
            return this.currentTransform.calculateFogMatrix(a);
          }
          getVisibleUnwrappedCoordinates(a) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(a);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(a) {
            this._mercatorTransform.recalculateZoomAndCenter(a), this._verticalPerspectiveTransform.recalculateZoomAndCenter(a);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(a, f) {
            return this.currentTransform.lngLatToCameraDepth(a, f);
          }
          populateCache(a) {
            this._mercatorTransform.populateCache(a), this._verticalPerspectiveTransform.populateCache(a);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(a, f, g, b) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, f, g, b);
          }
          setLocationAtPoint(a, f) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(a, f), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(a, f), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(a, f) {
            return this.currentTransform.locationToScreenPoint(a, f);
          }
          screenPointToMercatorCoordinate(a, f) {
            return this.currentTransform.screenPointToMercatorCoordinate(a, f);
          }
          screenPointToLocation(a, f) {
            return this.currentTransform.screenPointToLocation(a, f);
          }
          isPointOnMapSurface(a, f) {
            return this.currentTransform.isPointOnMapSurface(a, f);
          }
          getRayDirectionFromPixel(a) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(a);
          }
          getMatrixForModel(a, f) {
            return this.currentTransform.getMatrixForModel(a, f);
          }
          getProjectionDataForCustomLayer(a = !0) {
            const f = this._mercatorTransform.getProjectionDataForCustomLayer(a);
            if (!this.isGlobeRendering) return f;
            const g = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(a);
            return g.fallbackMatrix = f.mainMatrix, g;
          }
          getFastPathSimpleProjectionMatrix(a) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(a);
          }
        }
        class qn {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(a, f) {
            const g = vr(a, f);
            return Math.abs(g.lng - f.center.lng) > 180 && (g.lng = f.center.lng + 179.5 * Math.sign(g.lng - f.center.lng)), { easingCenter: g, easingOffset: new o.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(a, f) {
            const g = a.around, b = f.screenPointToLocation(g);
            a.bearingDelta && f.setBearing(f.bearing + a.bearingDelta), a.pitchDelta && f.setPitch(f.pitch + a.pitchDelta), a.rollDelta && f.setRoll(f.roll + a.rollDelta);
            const w = f.zoom;
            a.zoomDelta && f.setZoom(f.zoom + a.zoomDelta);
            const S = f.zoom - w;
            if (S === 0) return;
            const R = o.bA(f.center.lng, b.lng), B = R / (Math.abs(R / 180) + 1), U = o.bA(f.center.lat, b.lat), j = f.getRayDirectionFromPixel(g), X = f.cameraPosition, q = -1 * o.aX(X, j), Q = o.bp();
            o.aS(Q, X, [j[0] * q, j[1] * q, j[2] * q]);
            const ce = o.aZ(Q) - 1, we = Math.exp(0.5 * -Math.max(ce - 0.3, 0)), Ae = Ye(f.worldSize, f.center.lat) / Math.min(f.width, f.height), Se = o.bn(Ae, 0.9, 0.5, 1, 0.25), Me = (1 - o.ah(-S)) * Math.min(we, Se), Ge = f.center.lat, Le = f.zoom, $e = new o.S(f.center.lng + B * Me, o.ae(f.center.lat + U * Me, -o.af, o.af));
            f.setLocationAtPoint(b, g);
            const Xe = f.center, Fe = o.bn(Math.abs(R), 45, 85, 0, 1), Qe = o.bn(Ae, 0.75, 0.35, 0, 1), At = Math.pow(Math.max(Fe, Qe), 0.25), ft = o.bA(Xe.lng, $e.lng), dt = o.bA(Xe.lat, $e.lat);
            f.setCenter(new o.S(Xe.lng + ft * At, Xe.lat + dt * At).wrap()), f.setZoom(Le + Ut(Ge, f.center.lat));
          }
          handleMapControlsPan(a, f, g) {
            if (!a.panDelta) return;
            const b = f.center.lat, w = f.zoom;
            f.setCenter(vr(a.panDelta, f).wrap()), f.setZoom(w + Ut(b, f.center.lat));
          }
          cameraForBoxAndBearing(a, f, g, b, w) {
            const S = pa(a, f, g, b, w), R = f.left / w.width * 2 - 1, B = (w.width - f.right) / w.width * 2 - 1, U = f.top / w.height * -2 + 1, j = (w.height - f.bottom) / w.height * -2 + 1, X = o.bA(g.getWest(), g.getEast()) < 0, q = X ? g.getEast() : g.getWest(), Q = X ? g.getWest() : g.getEast(), ce = Math.max(g.getNorth(), g.getSouth()), we = Math.min(g.getNorth(), g.getSouth()), Ae = q + 0.5 * o.bA(q, Q), Se = ce + 0.5 * o.bA(ce, we), Me = w.clone();
            Me.setCenter(S.center), Me.setBearing(S.bearing), Me.setPitch(0), Me.setRoll(0), Me.setZoom(S.zoom);
            const Ge = Me.modelViewProjectionMatrix, Le = [Ie(g.getNorthWest()), Ie(g.getNorthEast()), Ie(g.getSouthWest()), Ie(g.getSouthEast()), Ie(new o.S(Q, Se)), Ie(new o.S(q, Se)), Ie(new o.S(Ae, ce)), Ie(new o.S(Ae, we))], $e = Ie(S.center);
            let Xe = Number.POSITIVE_INFINITY;
            for (const Fe of Le) R < 0 && (Xe = qn.getLesserNonNegativeNonNull(Xe, qn.solveVectorScale(Fe, $e, Ge, "x", R))), B > 0 && (Xe = qn.getLesserNonNegativeNonNull(Xe, qn.solveVectorScale(Fe, $e, Ge, "x", B))), U > 0 && (Xe = qn.getLesserNonNegativeNonNull(Xe, qn.solveVectorScale(Fe, $e, Ge, "y", U))), j < 0 && (Xe = qn.getLesserNonNegativeNonNull(Xe, qn.solveVectorScale(Fe, $e, Ge, "y", j)));
            if (Number.isFinite(Xe) && Xe !== 0) return S.zoom = Me.zoom + o.ak(Xe), S;
            As();
          }
          handleJumpToCenterZoom(a, f) {
            const g = a.center.lat, b = a.constrain(f.center ? o.S.convert(f.center) : a.center, a.zoom).center;
            a.setCenter(b.wrap());
            const w = f.zoom !== void 0 ? +f.zoom : a.zoom + Ut(g, b.lat);
            a.zoom !== w && a.setZoom(w);
          }
          handleEaseTo(a, f) {
            const g = a.zoom, b = a.center, w = a.padding, S = { roll: a.roll, pitch: a.pitch, bearing: a.bearing }, R = { roll: f.roll === void 0 ? a.roll : f.roll, pitch: f.pitch === void 0 ? a.pitch : f.pitch, bearing: f.bearing === void 0 ? a.bearing : f.bearing }, B = f.zoom !== void 0, U = !a.isPaddingEqual(f.padding);
            let j = !1;
            const X = f.center ? o.S.convert(f.center) : b, q = a.constrain(X, g).center;
            Fn(a, q);
            const Q = a.clone();
            Q.setCenter(q), Q.setZoom(B ? +f.zoom : g + Ut(b.lat, X.lat)), Q.setBearing(f.bearing);
            const ce = new o.P(o.ae(a.centerPoint.x + f.offsetAsPoint.x, 0, a.width), o.ae(a.centerPoint.y + f.offsetAsPoint.y, 0, a.height));
            Q.setLocationAtPoint(q, ce);
            const we = (f.offset && f.offsetAsPoint.mag()) > 0 ? Q.center : q, Ae = B ? +f.zoom : g + Ut(b.lat, we.lat), Se = g + Ut(b.lat, 0), Me = Ae + Ut(we.lat, 0), Ge = o.bA(b.lng, we.lng), Le = o.bA(b.lat, we.lat), $e = o.ah(Me - Se);
            return j = Ae !== g, { easeFunc: (Xe) => {
              if (o.be(S, R) || fl({ startEulerAngles: S, endEulerAngles: R, tr: a, k: Xe, useSlerp: S.roll != R.roll }), U && a.interpolatePadding(w, f.padding, Xe), f.around) o.w("Easing around a point is not supported under globe projection."), a.setLocationAtPoint(f.around, f.aroundPoint);
              else {
                const Fe = Me > Se ? Math.min(2, $e) : Math.max(0.5, $e), Qe = Math.pow(Fe, 1 - Xe), At = Ir(b, Ge, Le, Xe * Qe);
                a.setCenter(At.wrap());
              }
              if (j) {
                const Fe = o.C.number(Se, Me, Xe) + Ut(0, a.center.lat);
                a.setZoom(Fe);
              }
            }, isZooming: j, elevationCenter: we };
          }
          handleFlyTo(a, f) {
            const g = f.zoom !== void 0, b = a.center, w = a.zoom, S = a.padding, R = !a.isPaddingEqual(f.padding), B = a.constrain(o.S.convert(f.center || f.locationAtOffset), w).center, U = g ? +f.zoom : a.zoom + Ut(a.center.lat, B.lat), j = a.clone();
            j.setCenter(B), j.setZoom(U), j.setBearing(f.bearing);
            const X = new o.P(o.ae(a.centerPoint.x + f.offsetAsPoint.x, 0, a.width), o.ae(a.centerPoint.y + f.offsetAsPoint.y, 0, a.height));
            j.setLocationAtPoint(B, X);
            const q = j.center;
            Fn(a, q);
            const Q = function(Le, $e, Xe) {
              const Fe = Ie($e), Qe = Ie(Xe), At = o.aX(Fe, Qe), ft = Math.acos(At), dt = F(Le);
              return ft / (2 * Math.PI) * dt;
            }(a, b, q), ce = w + Ut(b.lat, 0), we = U + Ut(q.lat, 0), Ae = o.ah(we - ce);
            let Se;
            if (typeof f.minZoom == "number") {
              const Le = +f.minZoom + Ut(q.lat, 0), $e = Math.min(Le, ce, we) + Ut(0, q.lat), Xe = a.constrain(q, $e).zoom + Ut(q.lat, 0);
              Se = o.ah(Xe - ce);
            }
            const Me = o.bA(b.lng, q.lng), Ge = o.bA(b.lat, q.lat);
            return { easeFunc: (Le, $e, Xe, Fe) => {
              const Qe = Ir(b, Me, Ge, Xe);
              R && a.interpolatePadding(S, f.padding, Le);
              const At = Le === 1 ? q : Qe;
              a.setCenter(At.wrap());
              const ft = ce + o.ak($e);
              a.setZoom(Le === 1 ? U : ft + Ut(0, At.lat));
            }, scaleOfZoom: Ae, targetCenter: q, scaleOfMinZoom: Se, pixelPathLength: Q };
          }
          static solveVectorScale(a, f, g, b, w) {
            const S = b === "x" ? [g[0], g[4], g[8], g[12]] : [g[1], g[5], g[9], g[13]], R = [g[3], g[7], g[11], g[15]], B = a[0] * S[0] + a[1] * S[1] + a[2] * S[2], U = a[0] * R[0] + a[1] * R[1] + a[2] * R[2], j = f[0] * S[0] + f[1] * S[1] + f[2] * S[2], X = f[0] * R[0] + f[1] * R[1] + f[2] * R[2];
            return j + w * U === B + w * X || R[3] * (B - j) + S[3] * (X - U) + B * X == j * U ? null : (j + S[3] - w * X - w * R[3]) / (j - B - w * X + w * U);
          }
          static getLesserNonNegativeNonNull(a, f) {
            return f !== null && f >= 0 && f < a ? f : a;
          }
        }
        class Fa {
          constructor(a) {
            this._globe = a, this._mercatorCameraHelper = new ki(), this._verticalPerspectiveCameraHelper = new qn();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(a, f) {
            return this.currentHelper.handlePanInertia(a, f);
          }
          handleMapControlsRollPitchBearingZoom(a, f) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(a, f);
          }
          handleMapControlsPan(a, f, g) {
            this.currentHelper.handleMapControlsPan(a, f, g);
          }
          cameraForBoxAndBearing(a, f, g, b, w) {
            return this.currentHelper.cameraForBoxAndBearing(a, f, g, b, w);
          }
          handleJumpToCenterZoom(a, f) {
            this.currentHelper.handleJumpToCenterZoom(a, f);
          }
          handleEaseTo(a, f) {
            return this.currentHelper.handleEaseTo(a, f);
          }
          handleFlyTo(a, f) {
            return this.currentHelper.handleFlyTo(a, f);
          }
        }
        const Dc = (v, a) => o.y(v, a && a.filter((f) => f.identifier !== "source.canvas")), uh = o.bE();
        class Eo extends o.E {
          constructor(a, f = {}) {
            var g, b;
            super(), this._rtlPluginLoaded = () => {
              for (const S in this.sourceCaches) {
                const R = this.sourceCaches[S].getSource().type;
                R !== "vector" && R !== "geojson" || this.sourceCaches[S].reload();
              }
            }, this.map = a, this.dispatcher = new Et(at(), a._getMapId()), this.dispatcher.registerMessageHandler("GG", (S, R) => this.getGlyphs(S, R)), this.dispatcher.registerMessageHandler("GI", (S, R) => this.getImages(S, R)), this.dispatcher.registerMessageHandler("GDA", (S, R) => this.getDashes(S, R)), this.imageManager = new le(), this.imageManager.setEventedParent(this);
            const w = ((g = a._container) === null || g === void 0 ? void 0 : g.lang) || typeof document < "u" && ((b = document.documentElement) === null || b === void 0 ? void 0 : b.lang) || void 0;
            this.glyphManager = new gt(a._requestManager, f.localIdeographFontFamily, w), this.lineAtlas = new Dt(256, 512), this.crossTileSymbolIndex = new Ba(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.bF(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", o.bG()), wr().on(Fr, this._rtlPluginLoaded), this.on("data", (S) => {
              if (S.dataType !== "source" || S.sourceDataType !== "metadata") return;
              const R = this.sourceCaches[S.sourceId];
              if (!R) return;
              const B = R.getSource();
              if (B && B.vectorLayerIds) for (const U in this._layers) {
                const j = this._layers[U];
                j.source === B.id && this._validateLayer(j);
              }
            });
          }
          setGlobalStateProperty(a, f) {
            var g, b, w;
            this._checkLoaded();
            const S = f === null ? (w = (b = (g = this.stylesheet.state) === null || g === void 0 ? void 0 : g[a]) === null || b === void 0 ? void 0 : b.default) !== null && w !== void 0 ? w : null : f;
            if (o.bH(S, this._globalState[a])) return this;
            this._globalState[a] = S, this._applyGlobalStateChanges([a]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(a) {
            this._checkLoaded();
            const f = [];
            for (const g in a) !o.bH(this._globalState[g], a[g].default) && (f.push(g), this._globalState[g] = a[g].default);
            this._applyGlobalStateChanges(f);
          }
          _applyGlobalStateChanges(a) {
            if (a.length === 0) return;
            const f = /* @__PURE__ */ new Set(), g = {};
            for (const b of a) {
              g[b] = this._globalState[b];
              for (const w in this._layers) {
                const S = this._layers[w], R = S.getLayoutAffectingGlobalStateRefs(), B = S.getPaintAffectingGlobalStateRefs();
                if (R.has(b) && f.add(S.source), B.has(b)) for (const { name: U, value: j } of B.get(b)) this._updatePaintProperty(S, U, j);
              }
            }
            this.dispatcher.broadcast("UGS", g);
            for (const b in this.sourceCaches) f.has(b) && (this._reloadSource(b), this._changed = !0);
          }
          loadURL(a, f = {}, g) {
            this.fire(new o.l("dataloading", { dataType: "style" })), f.validate = typeof f.validate != "boolean" || f.validate;
            const b = this.map._requestManager.transformRequest(a, "Style");
            this._loadStyleRequest = new AbortController();
            const w = this._loadStyleRequest;
            o.j(b, this._loadStyleRequest).then((S) => {
              this._loadStyleRequest = null, this._load(S.data, f, g);
            }).catch((S) => {
              this._loadStyleRequest = null, S && !w.signal.aborted && this.fire(new o.k(S));
            });
          }
          loadJSON(a, f = {}, g) {
            this.fire(new o.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), P.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, f.validate = f.validate !== !1, this._load(a, f, g);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new o.l("dataloading", { dataType: "style" })), this._load(uh, { validate: !1 });
          }
          _load(a, f, g) {
            var b, w;
            let S = f.transformStyle ? f.transformStyle(g, a) : a;
            if (!f.validate || !Dc(this, o.z(S))) {
              S = Object.assign({}, S), this._loaded = !0, this.stylesheet = S;
              for (const R in S.sources) this.addSource(R, S.sources[R], { validate: !1 });
              S.sprite ? this._loadSprite(S.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(S.glyphs), this._createLayers(), this.light = new mt(this.stylesheet.light), this._setProjectionInternal(((b = this.stylesheet.projection) === null || b === void 0 ? void 0 : b.type) || "mercator"), this.sky = new Yt(this.stylesheet.sky), this.map.setTerrain((w = this.stylesheet.terrain) !== null && w !== void 0 ? w : null), this.fire(new o.l("data", { dataType: "style" })), this.fire(new o.l("style.load"));
            }
          }
          _createLayers() {
            var a, f, g;
            const b = o.bI(this.stylesheet.layers);
            this.setGlobalState((a = this.stylesheet.state) !== null && a !== void 0 ? a : null), this.dispatcher.broadcast("SL", b), this._order = b.map((w) => w.id), this._layers = {}, this._serializedLayers = null;
            for (const w of b) {
              const S = o.bJ(w, this._globalState);
              if (S.setEventedParent(this, { layer: { id: w.id } }), this._layers[w.id] = S, o.bK(S) && this.sourceCaches[S.source]) {
                const R = (g = (f = w.paint) === null || f === void 0 ? void 0 : f["raster-fade-duration"]) !== null && g !== void 0 ? g : S.paint.get("raster-fade-duration");
                this.sourceCaches[S.source].setRasterFadeDuration(R);
              }
            }
          }
          _loadSprite(a, f = !1, g = void 0) {
            let b;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(w, S, R, B) {
              return o._(this, void 0, void 0, function* () {
                const U = pe(w), j = R > 1 ? "@2x" : "", X = {}, q = {};
                for (const { id: Q, url: ce } of U) {
                  const we = S.transformRequest(oe(ce, j, ".json"), "SpriteJSON");
                  X[Q] = o.j(we, B);
                  const Ae = S.transformRequest(oe(ce, j, ".png"), "SpriteImage");
                  q[Q] = re.getImage(Ae, B);
                }
                return yield Promise.all([...Object.values(X), ...Object.values(q)]), function(Q, ce) {
                  return o._(this, void 0, void 0, function* () {
                    const we = {};
                    for (const Ae in Q) {
                      we[Ae] = {};
                      const Se = P.getImageCanvasContext((yield ce[Ae]).data), Me = (yield Q[Ae]).data;
                      for (const Ge in Me) {
                        const { width: Le, height: $e, x: Xe, y: Fe, sdf: Qe, pixelRatio: At, stretchX: ft, stretchY: dt, content: _t, textFitWidth: qt, textFitHeight: Zt } = Me[Ge];
                        we[Ae][Ge] = { data: null, pixelRatio: At, sdf: Qe, stretchX: ft, stretchY: dt, content: _t, textFitWidth: qt, textFitHeight: Zt, spriteData: { width: Le, height: $e, x: Xe, y: Fe, context: Se } };
                      }
                    }
                    return we;
                  });
                }(X, q);
              });
            }(a, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((w) => {
              if (this._spriteRequest = null, w) for (const S in w) {
                this._spritesImagesIds[S] = [];
                const R = this._spritesImagesIds[S] ? this._spritesImagesIds[S].filter((B) => !(B in w)) : [];
                for (const B of R) this.imageManager.removeImage(B), this._changedImages[B] = !0;
                for (const B in w[S]) {
                  const U = S === "default" ? B : `${S}:${B}`;
                  this._spritesImagesIds[S].push(U), U in this.imageManager.images ? this.imageManager.updateImage(U, w[S][B], !1) : this.imageManager.addImage(U, w[S][B]), f && (this._changedImages[U] = !0);
                }
              }
            }).catch((w) => {
              this._spriteRequest = null, b = w, this.fire(new o.k(b));
            }).finally(() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), f && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" })), g && g(b);
            });
          }
          _unloadSprite() {
            for (const a of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(a), this._changedImages[a] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
          }
          _validateLayer(a) {
            const f = this.sourceCaches[a.source];
            if (!f) return;
            const g = a.sourceLayer;
            if (!g) return;
            const b = f.getSource();
            (b.type === "geojson" || b.vectorLayerIds && b.vectorLayerIds.indexOf(g) === -1) && this.fire(new o.k(new Error(`Source layer "${g}" does not exist on source "${b.id}" as specified by style layer "${a.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const a in this.sourceCaches) if (!this.sourceCaches[a].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(a, f = !1) {
            const g = this._serializedAllLayers();
            if (!a || a.length === 0) return Object.values(f ? o.bL(g) : g);
            const b = [];
            for (const w of a) if (g[w]) {
              const S = f ? o.bL(g[w]) : g[w];
              b.push(S);
            }
            return b;
          }
          _serializedAllLayers() {
            let a = this._serializedLayers;
            if (a) return a;
            a = this._serializedLayers = {};
            const f = Object.keys(this._layers);
            for (const g of f) {
              const b = this._layers[g];
              b.type !== "custom" && (a[g] = b.serialize());
            }
            return a;
          }
          hasTransitions() {
            var a, f, g;
            if (!((a = this.light) === null || a === void 0) && a.hasTransition() || !((f = this.sky) === null || f === void 0) && f.hasTransition() || !((g = this.projection) === null || g === void 0) && g.hasTransition()) return !0;
            for (const b in this.sourceCaches) if (this.sourceCaches[b].hasTransition()) return !0;
            for (const b in this._layers) if (this._layers[b].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(a) {
            if (!this._loaded) return;
            const f = this._changed;
            if (f) {
              const b = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              (b.length || w.length) && this._updateWorkerLayers(b, w);
              for (const S in this._updatedSources) {
                const R = this._updatedSources[S];
                if (R === "reload") this._reloadSource(S);
                else {
                  if (R !== "clear") throw new Error(`Invalid action ${R}`);
                  this._clearSource(S);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const S in this._updatedPaintProps) this._layers[S].updateTransitions(a);
              this.light.updateTransitions(a), this.sky.updateTransitions(a), this._resetUpdates();
            }
            const g = {};
            for (const b in this.sourceCaches) {
              const w = this.sourceCaches[b];
              g[b] = w.used, w.used = !1;
            }
            for (const b of this._order) {
              const w = this._layers[b];
              w.recalculate(a, this._availableImages), !w.isHidden(a.zoom) && w.source && (this.sourceCaches[w.source].used = !0);
            }
            for (const b in g) {
              const w = this.sourceCaches[b];
              !!g[b] != !!w.used && w.fire(new o.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: b }));
            }
            this.light.recalculate(a), this.sky.recalculate(a), this.projection.recalculate(a), this.z = a.zoom, f && this.fire(new o.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const a = Object.keys(this._changedImages);
            if (a.length) {
              for (const f in this.sourceCaches) this.sourceCaches[f].reloadTilesForDependencies(["icons", "patterns"], a);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const a in this.sourceCaches) this.sourceCaches[a].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(a, f) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(a, !1), removedIds: f });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(a, f = {}) {
            var g;
            this._checkLoaded();
            const b = this.serialize();
            if (a = f.transformStyle ? f.transformStyle(b, a) : a, ((g = f.validate) === null || g === void 0 || g) && Dc(this, o.z(a))) return !1;
            (a = o.bL(a)).layers = o.bI(a.layers);
            const w = o.bM(b, a), S = this._getOperationsToPerform(w);
            if (S.unimplemented.length > 0) throw new Error(`Unimplemented: ${S.unimplemented.join(", ")}.`);
            if (S.operations.length === 0) return !1;
            for (const R of S.operations) R();
            return this.stylesheet = a, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(a) {
            const f = [], g = [];
            for (const b of a) switch (b.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                f.push(() => this.addLayer.apply(this, b.args));
                break;
              case "removeLayer":
                f.push(() => this.removeLayer.apply(this, b.args));
                break;
              case "setPaintProperty":
                f.push(() => this.setPaintProperty.apply(this, b.args));
                break;
              case "setLayoutProperty":
                f.push(() => this.setLayoutProperty.apply(this, b.args));
                break;
              case "setFilter":
                f.push(() => this.setFilter.apply(this, b.args));
                break;
              case "addSource":
                f.push(() => this.addSource.apply(this, b.args));
                break;
              case "removeSource":
                f.push(() => this.removeSource.apply(this, b.args));
                break;
              case "setLayerZoomRange":
                f.push(() => this.setLayerZoomRange.apply(this, b.args));
                break;
              case "setLight":
                f.push(() => this.setLight.apply(this, b.args));
                break;
              case "setGeoJSONSourceData":
                f.push(() => this.setGeoJSONSourceData.apply(this, b.args));
                break;
              case "setGlyphs":
                f.push(() => this.setGlyphs.apply(this, b.args));
                break;
              case "setSprite":
                f.push(() => this.setSprite.apply(this, b.args));
                break;
              case "setTerrain":
                f.push(() => this.map.setTerrain.apply(this, b.args));
                break;
              case "setSky":
                f.push(() => this.setSky.apply(this, b.args));
                break;
              case "setProjection":
                this.setProjection.apply(this, b.args);
                break;
              case "setGlobalState":
                f.push(() => this.setGlobalState.apply(this, b.args));
                break;
              case "setTransition":
                f.push(() => {
                });
                break;
              default:
                g.push(b.command);
            }
            return { operations: f, unimplemented: g };
          }
          addImage(a, f) {
            if (this.getImage(a)) return this.fire(new o.k(new Error(`An image named "${a}" already exists.`)));
            this.imageManager.addImage(a, f), this._afterImageUpdated(a);
          }
          updateImage(a, f) {
            this.imageManager.updateImage(a, f);
          }
          getImage(a) {
            return this.imageManager.getImage(a);
          }
          removeImage(a) {
            if (!this.getImage(a)) return this.fire(new o.k(new Error(`An image named "${a}" does not exist.`)));
            this.imageManager.removeImage(a), this._afterImageUpdated(a);
          }
          _afterImageUpdated(a) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[a] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(a, f, g = {}) {
            if (this._checkLoaded(), this.sourceCaches[a] !== void 0) throw new Error(`Source "${a}" already exists.`);
            if (!f.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(f).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(f.type) >= 0 && this._validate(o.z.source, `sources.${a}`, f, null, g)) return;
            this.map && this.map._collectResourceTiming && (f.collectResourceTiming = !0);
            const b = this.sourceCaches[a] = new li(a, f, this.dispatcher);
            b.style = this, b.setEventedParent(this, () => ({ isSourceLoaded: b.loaded(), source: b.serialize(), sourceId: a })), b.onAdd(this.map), this._changed = !0;
          }
          removeSource(a) {
            if (this._checkLoaded(), this.sourceCaches[a] === void 0) throw new Error("There is no source with this ID");
            for (const g in this._layers) if (this._layers[g].source === a) return this.fire(new o.k(new Error(`Source "${a}" cannot be removed while layer "${g}" is using it.`)));
            const f = this.sourceCaches[a];
            delete this.sourceCaches[a], delete this._updatedSources[a], f.fire(new o.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: a })), f.setEventedParent(null), f.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(a, f) {
            if (this._checkLoaded(), this.sourceCaches[a] === void 0) throw new Error(`There is no source with this ID=${a}`);
            const g = this.sourceCaches[a].getSource();
            if (g.type !== "geojson") throw new Error(`geojsonSource.type is ${g.type}, which is !== 'geojson`);
            g.setData(f), this._changed = !0;
          }
          getSource(a) {
            return this.sourceCaches[a] && this.sourceCaches[a].getSource();
          }
          addLayer(a, f, g = {}) {
            this._checkLoaded();
            const b = a.id;
            if (this.getLayer(b)) return void this.fire(new o.k(new Error(`Layer "${b}" already exists on this map.`)));
            let w;
            if (a.type === "custom") {
              if (Dc(this, o.bN(a))) return;
              w = o.bJ(a, this._globalState);
            } else {
              if ("source" in a && typeof a.source == "object" && (this.addSource(b, a.source), a = o.bL(a), a = o.e(a, { source: b })), this._validate(o.z.layer, `layers.${b}`, a, { arrayIndex: -1 }, g)) return;
              w = o.bJ(a, this._globalState), this._validateLayer(w), w.setEventedParent(this, { layer: { id: b } });
            }
            const S = f ? this._order.indexOf(f) : this._order.length;
            if (f && S === -1) this.fire(new o.k(new Error(`Cannot add layer "${b}" before non-existing layer "${f}".`)));
            else {
              if (this._order.splice(S, 0, b), this._layerOrderChanged = !0, this._layers[b] = w, this._removedLayers[b] && w.source && w.type !== "custom") {
                const R = this._removedLayers[b];
                delete this._removedLayers[b], R.type !== w.type ? this._updatedSources[w.source] = "clear" : (this._updatedSources[w.source] = "reload", this.sourceCaches[w.source].pause());
              }
              this._updateLayer(w), w.onAdd && w.onAdd(this.map);
            }
          }
          moveLayer(a, f) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[a]) return void this.fire(new o.k(new Error(`The layer '${a}' does not exist in the map's style and cannot be moved.`)));
            if (a === f) return;
            const g = this._order.indexOf(a);
            this._order.splice(g, 1);
            const b = f ? this._order.indexOf(f) : this._order.length;
            f && b === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${a}" before non-existing layer "${f}".`))) : (this._order.splice(b, 0, a), this._layerOrderChanged = !0);
          }
          removeLayer(a) {
            this._checkLoaded();
            const f = this._layers[a];
            if (!f) return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${a}".`)));
            f.setEventedParent(null);
            const g = this._order.indexOf(a);
            this._order.splice(g, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[a] = f, delete this._layers[a], this._serializedLayers && delete this._serializedLayers[a], delete this._updatedLayers[a], delete this._updatedPaintProps[a], f.onRemove && f.onRemove(this.map);
          }
          getLayer(a) {
            return this._layers[a];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(a) {
            return a in this._layers;
          }
          setLayerZoomRange(a, f, g) {
            this._checkLoaded();
            const b = this.getLayer(a);
            b ? b.minzoom === f && b.maxzoom === g || (f != null && (b.minzoom = f), g != null && (b.maxzoom = g), this._updateLayer(b)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${a}".`)));
          }
          setFilter(a, f, g = {}) {
            this._checkLoaded();
            const b = this.getLayer(a);
            if (b) {
              if (!o.bH(b.filter, f)) return f == null ? (b.setFilter(void 0), void this._updateLayer(b)) : void (this._validate(o.z.filter, `layers.${b.id}.filter`, f, null, g) || (b.setFilter(o.bL(f)), this._updateLayer(b)));
            } else this.fire(new o.k(new Error(`Cannot filter non-existing layer "${a}".`)));
          }
          getFilter(a) {
            return o.bL(this.getLayer(a).filter);
          }
          setLayoutProperty(a, f, g, b = {}) {
            this._checkLoaded();
            const w = this.getLayer(a);
            w ? o.bH(w.getLayoutProperty(f), g) || (w.setLayoutProperty(f, g, b), this._updateLayer(w)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${a}".`)));
          }
          getLayoutProperty(a, f) {
            const g = this.getLayer(a);
            if (g) return g.getLayoutProperty(f);
            this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${a}".`)));
          }
          setPaintProperty(a, f, g, b = {}) {
            this._checkLoaded();
            const w = this.getLayer(a);
            w ? o.bH(w.getPaintProperty(f), g) || this._updatePaintProperty(w, f, g, b) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${a}".`)));
          }
          _updatePaintProperty(a, f, g, b = {}) {
            a.setPaintProperty(f, g, b) && this._updateLayer(a), o.bK(a) && f === "raster-fade-duration" && this.sourceCaches[a.source].setRasterFadeDuration(g), this._changed = !0, this._updatedPaintProps[a.id] = !0, this._serializedLayers = null;
          }
          getPaintProperty(a, f) {
            return this.getLayer(a).getPaintProperty(f);
          }
          setFeatureState(a, f) {
            this._checkLoaded();
            const g = a.source, b = a.sourceLayer, w = this.sourceCaches[g];
            if (w === void 0) return void this.fire(new o.k(new Error(`The source '${g}' does not exist in the map's style.`)));
            const S = w.getSource().type;
            S === "geojson" && b ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : S !== "vector" || b ? (a.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), w.setFeatureState(b, a.id, f)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(a, f) {
            this._checkLoaded();
            const g = a.source, b = this.sourceCaches[g];
            if (b === void 0) return void this.fire(new o.k(new Error(`The source '${g}' does not exist in the map's style.`)));
            const w = b.getSource().type, S = w === "vector" ? a.sourceLayer : void 0;
            w !== "vector" || S ? f && typeof a.id != "string" && typeof a.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : b.removeFeatureState(S, a.id, f) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(a) {
            this._checkLoaded();
            const f = a.source, g = a.sourceLayer, b = this.sourceCaches[f];
            if (b !== void 0) return b.getSource().type !== "vector" || g ? (a.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), b.getFeatureState(g, a.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new o.k(new Error(`The source '${f}' does not exist in the map's style.`)));
          }
          getTransition() {
            return o.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const a = o.bO(this.sourceCaches, (w) => w.serialize()), f = this._serializeByIds(this._order, !0), g = this.map.getTerrain() || void 0, b = this.stylesheet;
            return o.bP({ version: b.version, name: b.name, metadata: b.metadata, light: b.light, sky: b.sky, center: b.center, zoom: b.zoom, bearing: b.bearing, pitch: b.pitch, sprite: b.sprite, glyphs: b.glyphs, transition: b.transition, projection: b.projection, sources: a, layers: f, terrain: g }, (w) => w !== void 0);
          }
          _updateLayer(a) {
            this._updatedLayers[a.id] = !0, a.source && !this._updatedSources[a.source] && this.sourceCaches[a.source].getSource().type !== "raster" && (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(a) {
            const f = (S) => this._layers[S].type === "fill-extrusion", g = {}, b = [];
            for (let S = this._order.length - 1; S >= 0; S--) {
              const R = this._order[S];
              if (f(R)) {
                g[R] = S;
                for (const B of a) {
                  const U = B[R];
                  if (U) for (const j of U) b.push(j);
                }
              }
            }
            b.sort((S, R) => R.intersectionZ - S.intersectionZ);
            const w = [];
            for (let S = this._order.length - 1; S >= 0; S--) {
              const R = this._order[S];
              if (f(R)) for (let B = b.length - 1; B >= 0; B--) {
                const U = b[B].feature;
                if (g[U.layer.id] < S) break;
                w.push(U), b.pop();
              }
              else for (const B of a) {
                const U = B[R];
                if (U) for (const j of U) w.push(j.feature);
              }
            }
            return w;
          }
          queryRenderedFeatures(a, f, g) {
            f && f.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", f.filter, null, f);
            const b = {};
            if (f && f.layers) {
              if (!(Array.isArray(f.layers) || f.layers instanceof Set)) return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const U of f.layers) {
                const j = this._layers[U];
                if (!j) return this.fire(new o.k(new Error(`The layer '${U}' does not exist in the map's style and cannot be queried for features.`))), [];
                b[j.source] = !0;
              }
            }
            const w = [];
            f.availableImages = this._availableImages;
            const S = this._serializedAllLayers(), R = f.layers instanceof Set ? f.layers : Array.isArray(f.layers) ? new Set(f.layers) : null, B = Object.assign(Object.assign({}, f), { layers: R, globalState: this._globalState });
            for (const U in this.sourceCaches) f.layers && !b[U] || w.push(tr(this.sourceCaches[U], this._layers, S, a, B, g, this.map.terrain ? (j, X, q) => this.map.terrain.getElevation(j, X, q) : void 0));
            return this.placement && w.push(function(U, j, X, q, Q, ce, we) {
              const Ae = {}, Se = ce.queryRenderedSymbols(q), Me = [];
              for (const Ge of Object.keys(Se).map(Number)) Me.push(we[Ge]);
              Me.sort(ur);
              for (const Ge of Me) {
                const Le = Ge.featureIndex.lookupSymbolFeatures(Se[Ge.bucketInstanceId], j, Ge.bucketIndex, Ge.sourceLayerIndex, { filterSpec: Q.filter, globalState: Q.globalState }, Q.layers, Q.availableImages, U);
                for (const $e in Le) {
                  const Xe = Ae[$e] = Ae[$e] || [], Fe = Le[$e];
                  Fe.sort((Qe, At) => {
                    const ft = Ge.featureSortOrder;
                    if (ft) {
                      const dt = ft.indexOf(Qe.featureIndex);
                      return ft.indexOf(At.featureIndex) - dt;
                    }
                    return At.featureIndex - Qe.featureIndex;
                  });
                  for (const Qe of Fe) Xe.push(Qe);
                }
              }
              return function(Ge, Le, $e) {
                for (const Xe in Ge) for (const Fe of Ge[Xe]) dr(Fe, $e[Le[Xe].source]);
                return Ge;
              }(Ae, U, X);
            }(this._layers, S, this.sourceCaches, a, B, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(w);
          }
          querySourceFeatures(a, f) {
            f?.filter && this._validate(o.z.filter, "querySourceFeatures.filter", f.filter, null, f);
            const g = this.sourceCaches[a];
            return g ? function(b, w) {
              const S = b.getRenderableIds().map((U) => b.getTileByID(U)), R = [], B = {};
              for (let U = 0; U < S.length; U++) {
                const j = S[U], X = j.tileID.canonical.key;
                B[X] || (B[X] = !0, j.querySourceFeatures(R, w));
              }
              return R;
            }(g, f ? Object.assign(Object.assign({}, f), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(a, f = {}) {
            this._checkLoaded();
            const g = this.light.getLight();
            let b = !1;
            for (const S in a) if (!o.bH(a[S], g[S])) {
              b = !0;
              break;
            }
            if (!b) return;
            const w = { now: D(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(a, f), this.light.updateTransitions(w);
          }
          getProjection() {
            var a;
            return (a = this.stylesheet) === null || a === void 0 ? void 0 : a.projection;
          }
          setProjection(a) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === a.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = a, this._setProjectionInternal(a.type);
          }
          getSky() {
            var a;
            return (a = this.stylesheet) === null || a === void 0 ? void 0 : a.sky;
          }
          setSky(a, f = {}) {
            this._checkLoaded();
            const g = this.getSky();
            let b = !1;
            if (!a && !g) return;
            if (a && !g) b = !0;
            else if (!a && g) b = !0;
            else for (const S in a) if (!o.bH(a[S], g[S])) {
              b = !0;
              break;
            }
            if (!b) return;
            const w = { now: D(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = a, this.sky.setSky(a, f), this.sky.updateTransitions(w);
          }
          _setProjectionInternal(a) {
            const f = function(g, b) {
              const w = { constrain: b };
              if (Array.isArray(g)) {
                const S = new po({ type: g });
                return { projection: S, transform: new Un(w), cameraHelper: new Fa(S) };
              }
              switch (g) {
                case "mercator":
                  return { projection: new ka(), transform: new Hn(w), cameraHelper: new ki() };
                case "globe": {
                  const S = new po({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: S, transform: new Un(w), cameraHelper: new Fa(S) };
                }
                case "vertical-perspective":
                  return { projection: new pl(), transform: new vn(w), cameraHelper: new qn() };
                default:
                  return o.w(`Unknown projection name: ${g}. Falling back to mercator projection.`), { projection: new ka(), transform: new Hn(w), cameraHelper: new ki() };
              }
            }(a, this.map.transformConstrain);
            this.projection = f.projection, this.map.migrateProjection(f.transform, f.cameraHelper);
            for (const g in this.sourceCaches) this.sourceCaches[g].reload();
          }
          _validate(a, f, g, b, w = {}) {
            return (!w || w.validate !== !1) && Dc(this, a.call(o.z, o.e({ key: f, style: this.serialize(), value: g, styleSpec: o.v }, b)));
          }
          _remove(a = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), wr().off(Fr, this._rtlPluginLoaded);
            for (const f in this._layers) this._layers[f].setEventedParent(null);
            for (const f in this.sourceCaches) {
              const g = this.sourceCaches[f];
              g.setEventedParent(null), g.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), a && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(a);
          }
          _clearSource(a) {
            this.sourceCaches[a].clearTiles();
          }
          _reloadSource(a) {
            this.sourceCaches[a].resume(), this.sourceCaches[a].reload();
          }
          _updateSources(a) {
            for (const f in this.sourceCaches) this.sourceCaches[f].update(a, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const a in this.sourceCaches) this._reloadSource(a);
          }
          _updatePlacement(a, f, g, b, w = !1) {
            let S = !1, R = !1;
            const B = {};
            for (const U of this._order) {
              const j = this._layers[U];
              if (j.type !== "symbol") continue;
              if (!B[j.source]) {
                const q = this.sourceCaches[j.source];
                B[j.source] = q.getRenderableIds(!0).map((Q) => q.getTileByID(Q)).sort((Q, ce) => ce.tileID.overscaledZ - Q.tileID.overscaledZ || (Q.tileID.isLessThan(ce.tileID) ? -1 : 1));
              }
              const X = this.crossTileSymbolIndex.addLayer(j, B[j.source], a.center.lng);
              S = S || X;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((w = w || this._layerOrderChanged || g === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(D(), a.zoom)) && (this.pauseablePlacement = new To(a, this.map.terrain, this._order, w, f, g, b, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, B), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(D()), R = !0), S && this.pauseablePlacement.placement.setStale()), R || S) for (const U of this._order) {
              const j = this._layers[U];
              j.type === "symbol" && this.placement.updateLayerOpacities(j, B[j.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(D());
          }
          _releaseSymbolFadeTiles() {
            for (const a in this.sourceCaches) this.sourceCaches[a].releaseSymbolFadeTiles();
          }
          getImages(a, f) {
            return o._(this, void 0, void 0, function* () {
              const g = yield this.imageManager.getImages(f.icons);
              this._updateTilesForChangedImages();
              const b = this.sourceCaches[f.source];
              return b && b.setDependencies(f.tileID.key, f.type, f.icons), g;
            });
          }
          getGlyphs(a, f) {
            return o._(this, void 0, void 0, function* () {
              const g = yield this.glyphManager.getGlyphs(f.stacks), b = this.sourceCaches[f.source];
              return b && b.setDependencies(f.tileID.key, f.type, [""]), g;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(a, f = {}) {
            this._checkLoaded(), a && this._validate(o.z.glyphs, "glyphs", a, null, f) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = a, this.glyphManager.entries = {}, this.glyphManager.setURL(a));
          }
          getDashes(a, f) {
            return o._(this, void 0, void 0, function* () {
              const g = {};
              for (const [b, w] of Object.entries(f.dashes)) g[b] = this.lineAtlas.getDash(w.dasharray, w.round);
              return g;
            });
          }
          addSprite(a, f, g = {}, b) {
            this._checkLoaded();
            const w = [{ id: a, url: f }], S = [...pe(this.stylesheet.sprite), ...w];
            this._validate(o.z.sprite, "sprite", S, null, g) || (this.stylesheet.sprite = S, this._loadSprite(w, !0, b));
          }
          removeSprite(a) {
            this._checkLoaded();
            const f = pe(this.stylesheet.sprite);
            if (f.find((g) => g.id === a)) {
              if (this._spritesImagesIds[a]) for (const g of this._spritesImagesIds[a]) this.imageManager.removeImage(g), this._changedImages[g] = !0;
              f.splice(f.findIndex((g) => g.id === a), 1), this.stylesheet.sprite = f.length > 0 ? f : void 0, delete this._spritesImagesIds[a], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
            } else this.fire(new o.k(new Error(`Sprite "${a}" doesn't exists on this map.`)));
          }
          getSprite() {
            return pe(this.stylesheet.sprite);
          }
          setSprite(a, f = {}, g) {
            this._checkLoaded(), a && this._validate(o.z.sprite, "sprite", a, null, f) || (this.stylesheet.sprite = a, a ? this._loadSprite(a, !0, g) : (this._unloadSprite(), g && g(null)));
          }
        }
        var go = o.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class gl {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(a, f, g, b, w, S, R, B, U) {
            this.context = a;
            let j = this.boundPaintVertexBuffers.length !== b.length;
            for (let X = 0; !j && X < b.length; X++) this.boundPaintVertexBuffers[X] !== b[X] && (j = !0);
            !this.vao || this.boundProgram !== f || this.boundLayoutVertexBuffer !== g || j || this.boundIndexBuffer !== w || this.boundVertexOffset !== S || this.boundDynamicVertexBuffer !== R || this.boundDynamicVertexBuffer2 !== B || this.boundDynamicVertexBuffer3 !== U ? this.freshBind(f, g, b, w, S, R, B, U) : (a.bindVertexArray.set(this.vao), R && R.bind(), w && w.dynamicDraw && w.bind(), B && B.bind(), U && U.bind());
          }
          freshBind(a, f, g, b, w, S, R, B) {
            const U = a.numAttributes, j = this.context, X = j.gl;
            this.vao && this.destroy(), this.vao = j.createVertexArray(), j.bindVertexArray.set(this.vao), this.boundProgram = a, this.boundLayoutVertexBuffer = f, this.boundPaintVertexBuffers = g, this.boundIndexBuffer = b, this.boundVertexOffset = w, this.boundDynamicVertexBuffer = S, this.boundDynamicVertexBuffer2 = R, this.boundDynamicVertexBuffer3 = B, f.enableAttributes(X, a);
            for (const q of g) q.enableAttributes(X, a);
            S && S.enableAttributes(X, a), R && R.enableAttributes(X, a), B && B.enableAttributes(X, a), f.bind(), f.setVertexAttribPointers(X, a, w);
            for (const q of g) q.bind(), q.setVertexAttribPointers(X, a, w);
            S && (S.bind(), S.setVertexAttribPointers(X, a, w)), b && b.bind(), R && (R.bind(), R.setVertexAttribPointers(X, a, w)), B && (B.bind(), B.setVertexAttribPointers(X, a, w)), j.currentNumAttributes = U;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const ml = (v, a, f, g, b) => ({ u_texture: 0, u_ele_delta: v, u_fog_matrix: a, u_fog_color: f ? f.properties.get("fog-color") : o.bf.white, u_fog_ground_blend: f ? f.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: b ? 0 : f ? f.calculateFogBlendOpacity(g) : 0, u_horizon_color: f ? f.properties.get("horizon-color") : o.bf.white, u_horizon_fog_blend: f ? f.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: b ? 1 : 0 }), ga = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function Oi(v) {
          const a = [];
          for (let f = 0; f < v.length; f++) {
            if (v[f] === null) continue;
            const g = v[f].split(" ");
            a.push(g.pop());
          }
          return a;
        }
        class Ua {
          constructor(a, f, g, b, w, S, R, B, U = []) {
            const j = a.gl;
            this.program = j.createProgram();
            const X = Oi(f.staticAttributes), q = g ? g.getBinderAttributes() : [], Q = X.concat(q), ce = So.prelude.staticUniforms ? Oi(So.prelude.staticUniforms) : [], we = R.staticUniforms ? Oi(R.staticUniforms) : [], Ae = f.staticUniforms ? Oi(f.staticUniforms) : [], Se = g ? g.getBinderUniforms() : [], Me = ce.concat(we).concat(Ae).concat(Se), Ge = [];
            for (const ft of Me) Ge.indexOf(ft) < 0 && Ge.push(ft);
            const Le = g ? g.defines() : [];
            ro(j) && Le.unshift("#version 300 es"), w && Le.push("#define OVERDRAW_INSPECTOR;"), S && Le.push("#define TERRAIN3D;"), B && Le.push(B), U && Le.push(...U);
            let $e = Le.concat(So.prelude.fragmentSource, R.fragmentSource, f.fragmentSource).join(`
`), Xe = Le.concat(So.prelude.vertexSource, R.vertexSource, f.vertexSource).join(`
`);
            ro(j) || ($e = function(ft) {
              return ft.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            }($e), Xe = function(ft) {
              return ft.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            }(Xe));
            const Fe = j.createShader(j.FRAGMENT_SHADER);
            if (j.isContextLost()) return void (this.failedToCreate = !0);
            if (j.shaderSource(Fe, $e), j.compileShader(Fe), !j.getShaderParameter(Fe, j.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${j.getShaderInfoLog(Fe)}`);
            j.attachShader(this.program, Fe);
            const Qe = j.createShader(j.VERTEX_SHADER);
            if (j.isContextLost()) return void (this.failedToCreate = !0);
            if (j.shaderSource(Qe, Xe), j.compileShader(Qe), !j.getShaderParameter(Qe, j.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${j.getShaderInfoLog(Qe)}`);
            j.attachShader(this.program, Qe), this.attributes = {};
            const At = {};
            this.numAttributes = Q.length;
            for (let ft = 0; ft < this.numAttributes; ft++) Q[ft] && (j.bindAttribLocation(this.program, ft, Q[ft]), this.attributes[Q[ft]] = ft);
            if (j.linkProgram(this.program), !j.getProgramParameter(this.program, j.LINK_STATUS)) throw new Error(`Program failed to link: ${j.getProgramInfoLog(this.program)}`);
            j.deleteShader(Qe), j.deleteShader(Fe);
            for (let ft = 0; ft < Ge.length; ft++) {
              const dt = Ge[ft];
              if (dt && !At[dt]) {
                const _t = j.getUniformLocation(this.program, dt);
                _t && (At[dt] = _t);
              }
            }
            this.fixedUniforms = b(a, At), this.terrainUniforms = ((ft, dt) => ({ u_depth: new o.bQ(ft, dt.u_depth), u_terrain: new o.bQ(ft, dt.u_terrain), u_terrain_dim: new o.bg(ft, dt.u_terrain_dim), u_terrain_matrix: new o.bS(ft, dt.u_terrain_matrix), u_terrain_unpack: new o.bT(ft, dt.u_terrain_unpack), u_terrain_exaggeration: new o.bg(ft, dt.u_terrain_exaggeration) }))(a, At), this.projectionUniforms = ((ft, dt) => ({ u_projection_matrix: new o.bS(ft, dt.u_projection_matrix), u_projection_tile_mercator_coords: new o.bT(ft, dt.u_projection_tile_mercator_coords), u_projection_clipping_plane: new o.bT(ft, dt.u_projection_clipping_plane), u_projection_transition: new o.bg(ft, dt.u_projection_transition), u_projection_fallback_matrix: new o.bS(ft, dt.u_projection_fallback_matrix) }))(a, At), this.binderUniforms = g ? g.getUniforms(a, At) : [];
          }
          draw(a, f, g, b, w, S, R, B, U, j, X, q, Q, ce, we, Ae, Se, Me, Ge) {
            const Le = a.gl;
            if (this.failedToCreate) return;
            if (a.program.set(this.program), a.setDepthMode(g), a.setStencilMode(b), a.setColorMode(w), a.setCullFace(S), B) {
              a.activeTexture.set(Le.TEXTURE2), Le.bindTexture(Le.TEXTURE_2D, B.depthTexture), a.activeTexture.set(Le.TEXTURE3), Le.bindTexture(Le.TEXTURE_2D, B.texture);
              for (const Xe in this.terrainUniforms) this.terrainUniforms[Xe].set(B[Xe]);
            }
            if (U) for (const Xe in U) this.projectionUniforms[ga[Xe]].set(U[Xe]);
            if (R) for (const Xe in this.fixedUniforms) this.fixedUniforms[Xe].set(R[Xe]);
            Ae && Ae.setUniforms(a, this.binderUniforms, ce, { zoom: we });
            let $e = 0;
            switch (f) {
              case Le.LINES:
                $e = 2;
                break;
              case Le.TRIANGLES:
                $e = 3;
                break;
              case Le.LINE_STRIP:
                $e = 1;
            }
            for (const Xe of Q.get()) {
              const Fe = Xe.vaos || (Xe.vaos = {});
              (Fe[j] || (Fe[j] = new gl())).bind(a, this, X, Ae ? Ae.getPaintVertexBuffers() : [], q, Xe.vertexOffset, Se, Me, Ge), Le.drawElements(f, Xe.primitiveLength * $e, Le.UNSIGNED_SHORT, Xe.primitiveOffset * $e * 2);
            }
          }
        }
        function Co(v, a, f) {
          const g = 1 / o.aC(f, 1, a.transform.tileZoom), b = Math.pow(2, f.tileID.overscaledZ), w = f.tileSize * Math.pow(2, a.transform.tileZoom) / b, S = w * (f.tileID.canonical.x + f.tileID.wrap * b), R = w * f.tileID.canonical.y;
          return { u_image: 0, u_texsize: f.imageAtlasTexture.size, u_scale: [g, v.fromScale, v.toScale], u_fade: v.t, u_pixel_coord_upper: [S >> 16, R >> 16], u_pixel_coord_lower: [65535 & S, 65535 & R] };
        }
        const ia = (v, a, f, g) => {
          const b = v.style.light, w = b.properties.get("position"), S = [w.x, w.y, w.z], R = o.bW();
          b.properties.get("anchor") === "viewport" && o.bX(R, v.transform.bearingInRadians), o.bY(S, S, R);
          const B = v.transform.transformLightDirection(S), U = b.properties.get("color");
          return { u_lightpos: S, u_lightpos_globe: B, u_lightintensity: b.properties.get("intensity"), u_lightcolor: [U.r, U.g, U.b], u_vertical_gradient: +a, u_opacity: f, u_fill_translate: g };
        }, za = (v, a, f, g, b, w, S) => o.e(ia(v, a, f, g), Co(w, v, S), { u_height_factor: -Math.pow(2, b.overscaledZ) / S.tileSize / 8 }), Ss = (v, a, f, g) => o.e(Co(a, v, f), { u_fill_translate: g }), Gl = (v, a) => ({ u_world: v, u_fill_translate: a }), Nc = (v, a, f, g, b) => o.e(Ss(v, a, f, b), { u_world: g }), ja = (v, a, f, g, b) => {
          const w = v.transform;
          let S, R, B = 0;
          if (f.paint.get("circle-pitch-alignment") === "map") {
            const U = o.aC(a, 1, w.zoom);
            S = !0, R = [U, U], B = U / (o.$ * Math.pow(2, a.tileID.overscaledZ)) * 2 * Math.PI * b;
          } else S = !1, R = w.pixelsToGLUnits;
          return { u_camera_to_center_distance: w.cameraToCenterDistance, u_scale_with_map: +(f.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +S, u_device_pixel_ratio: v.pixelRatio, u_extrude_scale: R, u_globe_extrude_scale: B, u_translate: g };
        }, ts = (v) => ({ u_pixel_extrude_scale: [1 / v.width, 1 / v.height] }), mo = (v) => ({ u_viewport_size: [v.width, v.height] }), Fc = (v, a = 1) => ({ u_color: v, u_overlay: 0, u_overlay_scale: a }), $l = (v, a, f, g) => {
          const b = o.aC(v, 1, a) / (o.$ * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * g;
          return { u_extrude_scale: o.aC(v, 1, a), u_intensity: f, u_globe_extrude_scale: b };
        }, na = (v, a, f, g) => {
          const b = o.L();
          o.bZ(b, 0, v.width, v.height, 0, 0, 1);
          const w = v.context.gl;
          return { u_matrix: b, u_world: [w.drawingBufferWidth, w.drawingBufferHeight], u_image: f, u_color_ramp: g, u_opacity: a.paint.get("heatmap-opacity") };
        }, Hl = (v, a, f) => {
          const g = f.paint.get("hillshade-accent-color");
          let b;
          switch (f.paint.get("hillshade-method")) {
            case "basic":
              b = 4;
              break;
            case "combined":
              b = 1;
              break;
            case "igor":
              b = 2;
              break;
            case "multidirectional":
              b = 3;
              break;
            default:
              b = 0;
          }
          const w = f.getIlluminationProperties();
          for (let S = 0; S < w.directionRadians.length; S++) f.paint.get("hillshade-illumination-anchor") === "viewport" && (w.directionRadians[S] += v.transform.bearingInRadians);
          return { u_image: 0, u_latrange: js(0, a.tileID), u_exaggeration: f.paint.get("hillshade-exaggeration"), u_altitudes: w.altitudeRadians, u_azimuths: w.directionRadians, u_accent: g, u_method: b, u_highlights: w.highlightColor, u_shadows: w.shadowColor };
        }, zs = (v, a) => {
          const f = a.stride, g = o.L();
          return o.bZ(g, 0, o.$, -o.$, 0, 0, 1), o.M(g, g, [0, -o.$, 0]), { u_matrix: g, u_image: 1, u_dimension: [f, f], u_zoom: v.overscaledZ, u_unpack: a.getUnpackVector() };
        };
        function js(v, a) {
          const f = Math.pow(2, a.canonical.z), g = a.canonical.y;
          return [new o.a1(0, g / f).toLngLat().lat, new o.a1(0, (g + 1) / f).toLngLat().lat];
        }
        const _l = (v, a, f = 0) => ({ u_image: 0, u_unpack: a.getUnpackVector(), u_dimension: [a.stride, a.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: f, u_opacity: v.paint.get("color-relief-opacity") }), Wn = (v, a, f, g) => {
          const b = v.transform;
          return { u_translation: sa(v, a, f), u_ratio: g / o.aC(a, 1, b.zoom), u_device_pixel_ratio: v.pixelRatio, u_units_to_pixels: [1 / b.pixelsToGLUnits[0], 1 / b.pixelsToGLUnits[1]] };
        }, Va = (v, a, f, g, b) => o.e(Wn(v, a, f, g), { u_image: 0, u_image_height: b }), Uc = (v, a, f, g, b) => {
          const w = v.transform, S = yl(a, w);
          return { u_translation: sa(v, a, f), u_texsize: a.imageAtlasTexture.size, u_ratio: g / o.aC(a, 1, w.zoom), u_device_pixel_ratio: v.pixelRatio, u_image: 0, u_scale: [S, b.fromScale, b.toScale], u_fade: b.t, u_units_to_pixels: [1 / w.pixelsToGLUnits[0], 1 / w.pixelsToGLUnits[1]] };
        }, Io = (v, a, f, g, b) => {
          const w = yl(a, v.transform);
          return o.e(Wn(v, a, f, g), { u_tileratio: w, u_crossfade_from: b.fromScale, u_crossfade_to: b.toScale, u_image: 0, u_mix: b.t, u_lineatlas_width: v.lineAtlas.width, u_lineatlas_height: v.lineAtlas.height });
        }, kn = (v, a, f, g, b, w) => {
          const S = yl(a, v.transform);
          return o.e(Wn(v, a, f, g), { u_image: 0, u_image_height: w, u_tileratio: S, u_crossfade_from: b.fromScale, u_crossfade_to: b.toScale, u_image_dash: 1, u_mix: b.t, u_lineatlas_width: v.lineAtlas.width, u_lineatlas_height: v.lineAtlas.height });
        };
        function yl(v, a) {
          return 1 / o.aC(v, 1, a.tileZoom);
        }
        function sa(v, a, f) {
          return o.aD(v.transform, a, f.paint.get("line-translate"), f.paint.get("line-translate-anchor"));
        }
        const ma = (v, a, f, g, b) => {
          return { u_tl_parent: v, u_scale_parent: a, u_buffer_scale: 1, u_fade_t: f.mix, u_opacity: f.opacity * g.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: g.paint.get("raster-brightness-min"), u_brightness_high: g.paint.get("raster-brightness-max"), u_saturation_factor: (S = g.paint.get("raster-saturation"), S > 0 ? 1 - 1 / (1.001 - S) : -S), u_contrast_factor: (w = g.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: ql(g.paint.get("raster-hue-rotate")), u_coords_top: [b[0].x, b[0].y, b[1].x, b[1].y], u_coords_bottom: [b[3].x, b[3].y, b[2].x, b[2].y] };
          var w, S;
        };
        function ql(v) {
          v *= Math.PI / 180;
          const a = Math.sin(v), f = Math.cos(v);
          return [(2 * f + 1) / 3, (-Math.sqrt(3) * a - f + 1) / 3, (Math.sqrt(3) * a - f + 1) / 3];
        }
        const Wl = (v, a, f, g, b, w, S, R, B, U, j, X, q) => {
          const Q = S.transform;
          return { u_is_size_zoom_constant: +(v === "constant" || v === "source"), u_is_size_feature_constant: +(v === "constant" || v === "camera"), u_size_t: a ? a.uSizeT : 0, u_size: a ? a.uSize : 0, u_camera_to_center_distance: Q.cameraToCenterDistance, u_pitch: Q.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +f, u_aspect_ratio: Q.width / Q.height, u_fade_change: S.options.fadeDuration ? S.symbolFadeChange : 1, u_label_plane_matrix: R, u_coord_matrix: B, u_is_text: +j, u_pitch_with_map: +g, u_is_along_line: b, u_is_variable_anchor: w, u_texsize: X, u_texture: 0, u_translation: U, u_pitched_scale: q };
        }, bl = (v, a, f, g, b, w, S, R, B, U, j, X, q, Q) => {
          const ce = S.transform;
          return o.e(Wl(v, a, f, g, b, w, S, R, B, U, j, X, Q), { u_gamma_scale: g ? Math.cos(ce.pitch * Math.PI / 180) * ce.cameraToCenterDistance : 1, u_device_pixel_ratio: S.pixelRatio, u_is_halo: 1 });
        }, vl = (v, a, f, g, b, w, S, R, B, U, j, X, q) => o.e(bl(v, a, f, g, b, w, S, R, B, U, !0, j, 0, q), { u_texsize_icon: X, u_texture_icon: 1 }), xl = (v, a) => ({ u_opacity: v, u_color: a }), _a = (v, a, f, g, b) => o.e(function(w, S, R, B) {
          const U = R.imageManager.getPattern(w.from.toString()), j = R.imageManager.getPattern(w.to.toString()), { width: X, height: q } = R.imageManager.getPixelSize(), Q = Math.pow(2, B.tileID.overscaledZ), ce = B.tileSize * Math.pow(2, R.transform.tileZoom) / Q, we = ce * (B.tileID.canonical.x + B.tileID.wrap * Q), Ae = ce * B.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: U.tl, u_pattern_br_a: U.br, u_pattern_tl_b: j.tl, u_pattern_br_b: j.br, u_texsize: [X, q], u_mix: S.t, u_pattern_size_a: U.displaySize, u_pattern_size_b: j.displaySize, u_scale_a: S.fromScale, u_scale_b: S.toScale, u_tile_units_to_pixels: 1 / o.aC(B, 1, R.transform.tileZoom), u_pixel_coord_upper: [we >> 16, Ae >> 16], u_pixel_coord_lower: [65535 & we, 65535 & Ae] };
        }(f, b, a, g), { u_opacity: v }), rs = (v, a) => {
        }, Xl = { fillExtrusion: (v, a) => ({ u_lightpos: new o.bU(v, a.u_lightpos), u_lightpos_globe: new o.bU(v, a.u_lightpos_globe), u_lightintensity: new o.bg(v, a.u_lightintensity), u_lightcolor: new o.bU(v, a.u_lightcolor), u_vertical_gradient: new o.bg(v, a.u_vertical_gradient), u_opacity: new o.bg(v, a.u_opacity), u_fill_translate: new o.bV(v, a.u_fill_translate) }), fillExtrusionPattern: (v, a) => ({ u_lightpos: new o.bU(v, a.u_lightpos), u_lightpos_globe: new o.bU(v, a.u_lightpos_globe), u_lightintensity: new o.bg(v, a.u_lightintensity), u_lightcolor: new o.bU(v, a.u_lightcolor), u_vertical_gradient: new o.bg(v, a.u_vertical_gradient), u_height_factor: new o.bg(v, a.u_height_factor), u_opacity: new o.bg(v, a.u_opacity), u_fill_translate: new o.bV(v, a.u_fill_translate), u_image: new o.bQ(v, a.u_image), u_texsize: new o.bV(v, a.u_texsize), u_pixel_coord_upper: new o.bV(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bV(v, a.u_pixel_coord_lower), u_scale: new o.bU(v, a.u_scale), u_fade: new o.bg(v, a.u_fade) }), fill: (v, a) => ({ u_fill_translate: new o.bV(v, a.u_fill_translate) }), fillPattern: (v, a) => ({ u_image: new o.bQ(v, a.u_image), u_texsize: new o.bV(v, a.u_texsize), u_pixel_coord_upper: new o.bV(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bV(v, a.u_pixel_coord_lower), u_scale: new o.bU(v, a.u_scale), u_fade: new o.bg(v, a.u_fade), u_fill_translate: new o.bV(v, a.u_fill_translate) }), fillOutline: (v, a) => ({ u_world: new o.bV(v, a.u_world), u_fill_translate: new o.bV(v, a.u_fill_translate) }), fillOutlinePattern: (v, a) => ({ u_world: new o.bV(v, a.u_world), u_image: new o.bQ(v, a.u_image), u_texsize: new o.bV(v, a.u_texsize), u_pixel_coord_upper: new o.bV(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bV(v, a.u_pixel_coord_lower), u_scale: new o.bU(v, a.u_scale), u_fade: new o.bg(v, a.u_fade), u_fill_translate: new o.bV(v, a.u_fill_translate) }), circle: (v, a) => ({ u_camera_to_center_distance: new o.bg(v, a.u_camera_to_center_distance), u_scale_with_map: new o.bQ(v, a.u_scale_with_map), u_pitch_with_map: new o.bQ(v, a.u_pitch_with_map), u_extrude_scale: new o.bV(v, a.u_extrude_scale), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_globe_extrude_scale: new o.bg(v, a.u_globe_extrude_scale), u_translate: new o.bV(v, a.u_translate) }), collisionBox: (v, a) => ({ u_pixel_extrude_scale: new o.bV(v, a.u_pixel_extrude_scale) }), collisionCircle: (v, a) => ({ u_viewport_size: new o.bV(v, a.u_viewport_size) }), debug: (v, a) => ({ u_color: new o.bR(v, a.u_color), u_overlay: new o.bQ(v, a.u_overlay), u_overlay_scale: new o.bg(v, a.u_overlay_scale) }), depth: rs, clippingMask: rs, heatmap: (v, a) => ({ u_extrude_scale: new o.bg(v, a.u_extrude_scale), u_intensity: new o.bg(v, a.u_intensity), u_globe_extrude_scale: new o.bg(v, a.u_globe_extrude_scale) }), heatmapTexture: (v, a) => ({ u_matrix: new o.bS(v, a.u_matrix), u_world: new o.bV(v, a.u_world), u_image: new o.bQ(v, a.u_image), u_color_ramp: new o.bQ(v, a.u_color_ramp), u_opacity: new o.bg(v, a.u_opacity) }), hillshade: (v, a) => ({ u_image: new o.bQ(v, a.u_image), u_latrange: new o.bV(v, a.u_latrange), u_exaggeration: new o.bg(v, a.u_exaggeration), u_altitudes: new o.b$(v, a.u_altitudes), u_azimuths: new o.b$(v, a.u_azimuths), u_accent: new o.bR(v, a.u_accent), u_method: new o.bQ(v, a.u_method), u_shadows: new o.b_(v, a.u_shadows), u_highlights: new o.b_(v, a.u_highlights) }), hillshadePrepare: (v, a) => ({ u_matrix: new o.bS(v, a.u_matrix), u_image: new o.bQ(v, a.u_image), u_dimension: new o.bV(v, a.u_dimension), u_zoom: new o.bg(v, a.u_zoom), u_unpack: new o.bT(v, a.u_unpack) }), colorRelief: (v, a) => ({ u_image: new o.bQ(v, a.u_image), u_unpack: new o.bT(v, a.u_unpack), u_dimension: new o.bV(v, a.u_dimension), u_elevation_stops: new o.bQ(v, a.u_elevation_stops), u_color_stops: new o.bQ(v, a.u_color_stops), u_color_ramp_size: new o.bQ(v, a.u_color_ramp_size), u_opacity: new o.bg(v, a.u_opacity) }), line: (v, a) => ({ u_translation: new o.bV(v, a.u_translation), u_ratio: new o.bg(v, a.u_ratio), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bV(v, a.u_units_to_pixels) }), lineGradient: (v, a) => ({ u_translation: new o.bV(v, a.u_translation), u_ratio: new o.bg(v, a.u_ratio), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bV(v, a.u_units_to_pixels), u_image: new o.bQ(v, a.u_image), u_image_height: new o.bg(v, a.u_image_height) }), linePattern: (v, a) => ({ u_translation: new o.bV(v, a.u_translation), u_texsize: new o.bV(v, a.u_texsize), u_ratio: new o.bg(v, a.u_ratio), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_image: new o.bQ(v, a.u_image), u_units_to_pixels: new o.bV(v, a.u_units_to_pixels), u_scale: new o.bU(v, a.u_scale), u_fade: new o.bg(v, a.u_fade) }), lineSDF: (v, a) => ({ u_translation: new o.bV(v, a.u_translation), u_ratio: new o.bg(v, a.u_ratio), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bV(v, a.u_units_to_pixels), u_image: new o.bQ(v, a.u_image), u_mix: new o.bg(v, a.u_mix), u_tileratio: new o.bg(v, a.u_tileratio), u_crossfade_from: new o.bg(v, a.u_crossfade_from), u_crossfade_to: new o.bg(v, a.u_crossfade_to), u_lineatlas_width: new o.bg(v, a.u_lineatlas_width), u_lineatlas_height: new o.bg(v, a.u_lineatlas_height) }), lineGradientSDF: (v, a) => ({ u_translation: new o.bV(v, a.u_translation), u_ratio: new o.bg(v, a.u_ratio), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bV(v, a.u_units_to_pixels), u_image: new o.bQ(v, a.u_image), u_image_height: new o.bg(v, a.u_image_height), u_tileratio: new o.bg(v, a.u_tileratio), u_crossfade_from: new o.bg(v, a.u_crossfade_from), u_crossfade_to: new o.bg(v, a.u_crossfade_to), u_image_dash: new o.bQ(v, a.u_image_dash), u_mix: new o.bg(v, a.u_mix), u_lineatlas_width: new o.bg(v, a.u_lineatlas_width), u_lineatlas_height: new o.bg(v, a.u_lineatlas_height) }), raster: (v, a) => ({ u_tl_parent: new o.bV(v, a.u_tl_parent), u_scale_parent: new o.bg(v, a.u_scale_parent), u_buffer_scale: new o.bg(v, a.u_buffer_scale), u_fade_t: new o.bg(v, a.u_fade_t), u_opacity: new o.bg(v, a.u_opacity), u_image0: new o.bQ(v, a.u_image0), u_image1: new o.bQ(v, a.u_image1), u_brightness_low: new o.bg(v, a.u_brightness_low), u_brightness_high: new o.bg(v, a.u_brightness_high), u_saturation_factor: new o.bg(v, a.u_saturation_factor), u_contrast_factor: new o.bg(v, a.u_contrast_factor), u_spin_weights: new o.bU(v, a.u_spin_weights), u_coords_top: new o.bT(v, a.u_coords_top), u_coords_bottom: new o.bT(v, a.u_coords_bottom) }), symbolIcon: (v, a) => ({ u_is_size_zoom_constant: new o.bQ(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bQ(v, a.u_is_size_feature_constant), u_size_t: new o.bg(v, a.u_size_t), u_size: new o.bg(v, a.u_size), u_camera_to_center_distance: new o.bg(v, a.u_camera_to_center_distance), u_pitch: new o.bg(v, a.u_pitch), u_rotate_symbol: new o.bQ(v, a.u_rotate_symbol), u_aspect_ratio: new o.bg(v, a.u_aspect_ratio), u_fade_change: new o.bg(v, a.u_fade_change), u_label_plane_matrix: new o.bS(v, a.u_label_plane_matrix), u_coord_matrix: new o.bS(v, a.u_coord_matrix), u_is_text: new o.bQ(v, a.u_is_text), u_pitch_with_map: new o.bQ(v, a.u_pitch_with_map), u_is_along_line: new o.bQ(v, a.u_is_along_line), u_is_variable_anchor: new o.bQ(v, a.u_is_variable_anchor), u_texsize: new o.bV(v, a.u_texsize), u_texture: new o.bQ(v, a.u_texture), u_translation: new o.bV(v, a.u_translation), u_pitched_scale: new o.bg(v, a.u_pitched_scale) }), symbolSDF: (v, a) => ({ u_is_size_zoom_constant: new o.bQ(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bQ(v, a.u_is_size_feature_constant), u_size_t: new o.bg(v, a.u_size_t), u_size: new o.bg(v, a.u_size), u_camera_to_center_distance: new o.bg(v, a.u_camera_to_center_distance), u_pitch: new o.bg(v, a.u_pitch), u_rotate_symbol: new o.bQ(v, a.u_rotate_symbol), u_aspect_ratio: new o.bg(v, a.u_aspect_ratio), u_fade_change: new o.bg(v, a.u_fade_change), u_label_plane_matrix: new o.bS(v, a.u_label_plane_matrix), u_coord_matrix: new o.bS(v, a.u_coord_matrix), u_is_text: new o.bQ(v, a.u_is_text), u_pitch_with_map: new o.bQ(v, a.u_pitch_with_map), u_is_along_line: new o.bQ(v, a.u_is_along_line), u_is_variable_anchor: new o.bQ(v, a.u_is_variable_anchor), u_texsize: new o.bV(v, a.u_texsize), u_texture: new o.bQ(v, a.u_texture), u_gamma_scale: new o.bg(v, a.u_gamma_scale), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_is_halo: new o.bQ(v, a.u_is_halo), u_translation: new o.bV(v, a.u_translation), u_pitched_scale: new o.bg(v, a.u_pitched_scale) }), symbolTextAndIcon: (v, a) => ({ u_is_size_zoom_constant: new o.bQ(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bQ(v, a.u_is_size_feature_constant), u_size_t: new o.bg(v, a.u_size_t), u_size: new o.bg(v, a.u_size), u_camera_to_center_distance: new o.bg(v, a.u_camera_to_center_distance), u_pitch: new o.bg(v, a.u_pitch), u_rotate_symbol: new o.bQ(v, a.u_rotate_symbol), u_aspect_ratio: new o.bg(v, a.u_aspect_ratio), u_fade_change: new o.bg(v, a.u_fade_change), u_label_plane_matrix: new o.bS(v, a.u_label_plane_matrix), u_coord_matrix: new o.bS(v, a.u_coord_matrix), u_is_text: new o.bQ(v, a.u_is_text), u_pitch_with_map: new o.bQ(v, a.u_pitch_with_map), u_is_along_line: new o.bQ(v, a.u_is_along_line), u_is_variable_anchor: new o.bQ(v, a.u_is_variable_anchor), u_texsize: new o.bV(v, a.u_texsize), u_texsize_icon: new o.bV(v, a.u_texsize_icon), u_texture: new o.bQ(v, a.u_texture), u_texture_icon: new o.bQ(v, a.u_texture_icon), u_gamma_scale: new o.bg(v, a.u_gamma_scale), u_device_pixel_ratio: new o.bg(v, a.u_device_pixel_ratio), u_is_halo: new o.bQ(v, a.u_is_halo), u_translation: new o.bV(v, a.u_translation), u_pitched_scale: new o.bg(v, a.u_pitched_scale) }), background: (v, a) => ({ u_opacity: new o.bg(v, a.u_opacity), u_color: new o.bR(v, a.u_color) }), backgroundPattern: (v, a) => ({ u_opacity: new o.bg(v, a.u_opacity), u_image: new o.bQ(v, a.u_image), u_pattern_tl_a: new o.bV(v, a.u_pattern_tl_a), u_pattern_br_a: new o.bV(v, a.u_pattern_br_a), u_pattern_tl_b: new o.bV(v, a.u_pattern_tl_b), u_pattern_br_b: new o.bV(v, a.u_pattern_br_b), u_texsize: new o.bV(v, a.u_texsize), u_mix: new o.bg(v, a.u_mix), u_pattern_size_a: new o.bV(v, a.u_pattern_size_a), u_pattern_size_b: new o.bV(v, a.u_pattern_size_b), u_scale_a: new o.bg(v, a.u_scale_a), u_scale_b: new o.bg(v, a.u_scale_b), u_pixel_coord_upper: new o.bV(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bV(v, a.u_pixel_coord_lower), u_tile_units_to_pixels: new o.bg(v, a.u_tile_units_to_pixels) }), terrain: (v, a) => ({ u_texture: new o.bQ(v, a.u_texture), u_ele_delta: new o.bg(v, a.u_ele_delta), u_fog_matrix: new o.bS(v, a.u_fog_matrix), u_fog_color: new o.bR(v, a.u_fog_color), u_fog_ground_blend: new o.bg(v, a.u_fog_ground_blend), u_fog_ground_blend_opacity: new o.bg(v, a.u_fog_ground_blend_opacity), u_horizon_color: new o.bR(v, a.u_horizon_color), u_horizon_fog_blend: new o.bg(v, a.u_horizon_fog_blend), u_is_globe_mode: new o.bg(v, a.u_is_globe_mode) }), terrainDepth: (v, a) => ({ u_ele_delta: new o.bg(v, a.u_ele_delta) }), terrainCoords: (v, a) => ({ u_texture: new o.bQ(v, a.u_texture), u_terrain_coords_id: new o.bg(v, a.u_terrain_coords_id), u_ele_delta: new o.bg(v, a.u_ele_delta) }), projectionErrorMeasurement: (v, a) => ({ u_input: new o.bg(v, a.u_input), u_output_expected: new o.bg(v, a.u_output_expected) }), atmosphere: (v, a) => ({ u_sun_pos: new o.bU(v, a.u_sun_pos), u_atmosphere_blend: new o.bg(v, a.u_atmosphere_blend), u_globe_position: new o.bU(v, a.u_globe_position), u_globe_radius: new o.bg(v, a.u_globe_radius), u_inv_proj_matrix: new o.bS(v, a.u_inv_proj_matrix) }), sky: (v, a) => ({ u_sky_color: new o.bR(v, a.u_sky_color), u_horizon_color: new o.bR(v, a.u_horizon_color), u_horizon: new o.bV(v, a.u_horizon), u_horizon_normal: new o.bV(v, a.u_horizon_normal), u_sky_horizon_blend: new o.bg(v, a.u_sky_horizon_blend), u_sky_blend: new o.bg(v, a.u_sky_blend) }) };
        class Vs {
          constructor(a, f, g) {
            this.context = a;
            const b = a.gl;
            this.buffer = b.createBuffer(), this.dynamicDraw = !!g, this.context.unbindVAO(), a.bindElementBuffer.set(this.buffer), b.bufferData(b.ELEMENT_ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? b.DYNAMIC_DRAW : b.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(a) {
            const f = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), f.bufferSubData(f.ELEMENT_ARRAY_BUFFER, 0, a.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Po = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Wi {
          constructor(a, f, g, b) {
            this.length = f.length, this.attributes = g, this.itemSize = f.bytesPerElement, this.dynamicDraw = b, this.context = a;
            const w = a.gl;
            this.buffer = w.createBuffer(), a.bindVertexBuffer.set(this.buffer), w.bufferData(w.ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? w.DYNAMIC_DRAW : w.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(a) {
            if (a.length !== this.length) throw new Error(`Length of new data is ${a.length}, which doesn't match current length of ${this.length}`);
            const f = this.context.gl;
            this.bind(), f.bufferSubData(f.ARRAY_BUFFER, 0, a.arrayBuffer);
          }
          enableAttributes(a, f) {
            for (let g = 0; g < this.attributes.length; g++) {
              const b = f.attributes[this.attributes[g].name];
              b !== void 0 && a.enableVertexAttribArray(b);
            }
          }
          setVertexAttribPointers(a, f, g) {
            for (let b = 0; b < this.attributes.length; b++) {
              const w = this.attributes[b], S = f.attributes[w.name];
              S !== void 0 && a.vertexAttribPointer(S, w.components, a[Po[w.type]], !1, this.itemSize, w.offset + this.itemSize * (g || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Lr {
          constructor(a) {
            this.gl = a.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(a) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Xi extends Lr {
          getDefault() {
            return o.bf.transparent;
          }
          set(a) {
            const f = this.current;
            (a.r !== f.r || a.g !== f.g || a.b !== f.b || a.a !== f.a || this.dirty) && (this.gl.clearColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
          }
        }
        class xn extends Lr {
          getDefault() {
            return 1;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.clearDepth(a), this.current = a, this.dirty = !1);
          }
        }
        class Ga extends Lr {
          getDefault() {
            return 0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.clearStencil(a), this.current = a, this.dirty = !1);
          }
        }
        class zc extends Lr {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(a) {
            const f = this.current;
            (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || a[3] !== f[3] || this.dirty) && (this.gl.colorMask(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
          }
        }
        class ya extends Lr {
          getDefault() {
            return !0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.depthMask(a), this.current = a, this.dirty = !1);
          }
        }
        class Iu extends Lr {
          getDefault() {
            return 255;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.stencilMask(a), this.current = a, this.dirty = !1);
          }
        }
        class Kh extends Lr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(a) {
            const f = this.current;
            (a.func !== f.func || a.ref !== f.ref || a.mask !== f.mask || this.dirty) && (this.gl.stencilFunc(a.func, a.ref, a.mask), this.current = a, this.dirty = !1);
          }
        }
        class dd extends Lr {
          getDefault() {
            const a = this.gl;
            return [a.KEEP, a.KEEP, a.KEEP];
          }
          set(a) {
            const f = this.current;
            (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || this.dirty) && (this.gl.stencilOp(a[0], a[1], a[2]), this.current = a, this.dirty = !1);
          }
        }
        class Qh extends Lr {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            a ? f.enable(f.STENCIL_TEST) : f.disable(f.STENCIL_TEST), this.current = a, this.dirty = !1;
          }
        }
        class Pu extends Lr {
          getDefault() {
            return [0, 1];
          }
          set(a) {
            const f = this.current;
            (a[0] !== f[0] || a[1] !== f[1] || this.dirty) && (this.gl.depthRange(a[0], a[1]), this.current = a, this.dirty = !1);
          }
        }
        class Mu extends Lr {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            a ? f.enable(f.DEPTH_TEST) : f.disable(f.DEPTH_TEST), this.current = a, this.dirty = !1;
          }
        }
        class Ru extends Lr {
          getDefault() {
            return this.gl.LESS;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.depthFunc(a), this.current = a, this.dirty = !1);
          }
        }
        class hh extends Lr {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            a ? f.enable(f.BLEND) : f.disable(f.BLEND), this.current = a, this.dirty = !1;
          }
        }
        class wl extends Lr {
          getDefault() {
            const a = this.gl;
            return [a.ONE, a.ZERO];
          }
          set(a) {
            const f = this.current;
            (a[0] !== f[0] || a[1] !== f[1] || this.dirty) && (this.gl.blendFunc(a[0], a[1]), this.current = a, this.dirty = !1);
          }
        }
        class jc extends Lr {
          getDefault() {
            return o.bf.transparent;
          }
          set(a) {
            const f = this.current;
            (a.r !== f.r || a.g !== f.g || a.b !== f.b || a.a !== f.a || this.dirty) && (this.gl.blendColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
          }
        }
        class Zl extends Lr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.blendEquation(a), this.current = a, this.dirty = !1);
          }
        }
        class _o extends Lr {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            a ? f.enable(f.CULL_FACE) : f.disable(f.CULL_FACE), this.current = a, this.dirty = !1;
          }
        }
        class ef extends Lr {
          getDefault() {
            return this.gl.BACK;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.cullFace(a), this.current = a, this.dirty = !1);
          }
        }
        class Vc extends Lr {
          getDefault() {
            return this.gl.CCW;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.frontFace(a), this.current = a, this.dirty = !1);
          }
        }
        class fh extends Lr {
          getDefault() {
            return null;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.useProgram(a), this.current = a, this.dirty = !1);
          }
        }
        class Al extends Lr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.activeTexture(a), this.current = a, this.dirty = !1);
          }
        }
        class Lu extends Lr {
          getDefault() {
            const a = this.gl;
            return [0, 0, a.drawingBufferWidth, a.drawingBufferHeight];
          }
          set(a) {
            const f = this.current;
            (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || a[3] !== f[3] || this.dirty) && (this.gl.viewport(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
          }
        }
        class Bu extends Lr {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            f.bindFramebuffer(f.FRAMEBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Gc extends Lr {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            f.bindRenderbuffer(f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class ku extends Lr {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            f.bindTexture(f.TEXTURE_2D, a), this.current = a, this.dirty = !1;
          }
        }
        class tf extends Lr {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            f.bindBuffer(f.ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Yl extends Lr {
          getDefault() {
            return null;
          }
          set(a) {
            const f = this.gl;
            f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Tl extends Lr {
          getDefault() {
            return null;
          }
          set(a) {
            var f;
            if (a === this.current && !this.dirty) return;
            const g = this.gl;
            ro(g) ? g.bindVertexArray(a) : (f = g.getExtension("OES_vertex_array_object")) === null || f === void 0 || f.bindVertexArrayOES(a), this.current = a, this.dirty = !1;
          }
        }
        class Ou extends Lr {
          getDefault() {
            return 4;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            f.pixelStorei(f.UNPACK_ALIGNMENT, a), this.current = a, this.dirty = !1;
          }
        }
        class Gs extends Lr {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a), this.current = a, this.dirty = !1;
          }
        }
        class $r extends Lr {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const f = this.gl;
            f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, a), this.current = a, this.dirty = !1;
          }
        }
        class $a extends Lr {
          constructor(a, f) {
            super(a), this.context = a, this.parent = f;
          }
          getDefault() {
            return null;
          }
        }
        class dh extends $a {
          setDirty() {
            this.dirty = !0;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const f = this.gl;
            f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, a, 0), this.current = a, this.dirty = !1;
          }
        }
        class rf extends $a {
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const f = this.gl;
            f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Sl extends $a {
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const f = this.gl;
            f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        const Du = "Framebuffer is not complete";
        class nf {
          constructor(a, f, g, b, w) {
            this.context = a, this.width = f, this.height = g;
            const S = a.gl, R = this.framebuffer = S.createFramebuffer();
            if (this.colorAttachment = new dh(a, R), b) this.depthAttachment = w ? new Sl(a, R) : new rf(a, R);
            else if (w) throw new Error("Stencil cannot be set without depth");
            if (S.checkFramebufferStatus(S.FRAMEBUFFER) !== S.FRAMEBUFFER_COMPLETE) throw new Error(Du);
          }
          destroy() {
            const a = this.context.gl, f = this.colorAttachment.get();
            if (f && a.deleteTexture(f), this.depthAttachment) {
              const g = this.depthAttachment.get();
              g && a.deleteRenderbuffer(g);
            }
            a.deleteFramebuffer(this.framebuffer);
          }
        }
        class sf {
          constructor(a) {
            var f, g;
            if (this.gl = a, this.clearColor = new Xi(this), this.clearDepth = new xn(this), this.clearStencil = new Ga(this), this.colorMask = new zc(this), this.depthMask = new ya(this), this.stencilMask = new Iu(this), this.stencilFunc = new Kh(this), this.stencilOp = new dd(this), this.stencilTest = new Qh(this), this.depthRange = new Pu(this), this.depthTest = new Mu(this), this.depthFunc = new Ru(this), this.blend = new hh(this), this.blendFunc = new wl(this), this.blendColor = new jc(this), this.blendEquation = new Zl(this), this.cullFace = new _o(this), this.cullFaceSide = new ef(this), this.frontFace = new Vc(this), this.program = new fh(this), this.activeTexture = new Al(this), this.viewport = new Lu(this), this.bindFramebuffer = new Bu(this), this.bindRenderbuffer = new Gc(this), this.bindTexture = new ku(this), this.bindVertexBuffer = new tf(this), this.bindElementBuffer = new Yl(this), this.bindVertexArray = new Tl(this), this.pixelStoreUnpack = new Ou(this), this.pixelStoreUnpackPremultiplyAlpha = new Gs(this), this.pixelStoreUnpackFlipY = new $r(this), this.extTextureFilterAnisotropic = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = a.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), ro(a)) {
              this.HALF_FLOAT = a.HALF_FLOAT;
              const b = a.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (f = a.RGBA16F) !== null && f !== void 0 ? f : b?.RGBA16F_EXT, this.RGB16F = (g = a.RGB16F) !== null && g !== void 0 ? g : b?.RGB16F_EXT, a.getExtension("EXT_color_buffer_float");
            } else {
              a.getExtension("EXT_color_buffer_half_float"), a.getExtension("OES_texture_half_float_linear");
              const b = a.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = b?.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(a, f) {
            return new Vs(this, a, f);
          }
          createVertexBuffer(a, f, g) {
            return new Wi(this, a, f, g);
          }
          createRenderbuffer(a, f, g) {
            const b = this.gl, w = b.createRenderbuffer();
            return this.bindRenderbuffer.set(w), b.renderbufferStorage(b.RENDERBUFFER, a, f, g), this.bindRenderbuffer.set(null), w;
          }
          createFramebuffer(a, f, g, b) {
            return new nf(this, a, f, g, b);
          }
          clear({ color: a, depth: f, stencil: g }) {
            const b = this.gl;
            let w = 0;
            a && (w |= b.COLOR_BUFFER_BIT, this.clearColor.set(a), this.colorMask.set([!0, !0, !0, !0])), f !== void 0 && (w |= b.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(f), this.depthMask.set(!0)), g !== void 0 && (w |= b.STENCIL_BUFFER_BIT, this.clearStencil.set(g), this.stencilMask.set(255)), b.clear(w);
          }
          setCullFace(a) {
            a.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(a.mode), this.frontFace.set(a.frontFace));
          }
          setDepthMode(a) {
            a.func !== this.gl.ALWAYS || a.mask ? (this.depthTest.set(!0), this.depthFunc.set(a.func), this.depthMask.set(a.mask), this.depthRange.set(a.range)) : this.depthTest.set(!1);
          }
          setStencilMode(a) {
            a.test.func !== this.gl.ALWAYS || a.mask ? (this.stencilTest.set(!0), this.stencilMask.set(a.mask), this.stencilOp.set([a.fail, a.depthFail, a.pass]), this.stencilFunc.set({ func: a.test.func, ref: a.ref, mask: a.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(a) {
            o.bH(a.blendFunction, Si.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(a.blendFunction), this.blendColor.set(a.blendColor)), this.colorMask.set(a.mask);
          }
          createVertexArray() {
            var a;
            return ro(this.gl) ? this.gl.createVertexArray() : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.createVertexArrayOES();
          }
          deleteVertexArray(a) {
            var f;
            return ro(this.gl) ? this.gl.deleteVertexArray(a) : (f = this.gl.getExtension("OES_vertex_array_object")) === null || f === void 0 ? void 0 : f.deleteVertexArrayOES(a);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let $c;
        function Hc(v, a, f, g, b) {
          const w = v.context, S = v.transform, R = w.gl, B = v.useProgram("collisionBox"), U = [];
          let j = 0, X = 0;
          for (let Se = 0; Se < g.length; Se++) {
            const Me = g[Se], Ge = a.getTile(Me).getBucket(f);
            if (!Ge) continue;
            const Le = b ? Ge.textCollisionBox : Ge.iconCollisionBox, $e = Ge.collisionCircleArray;
            $e.length > 0 && (U.push({ circleArray: $e, circleOffset: X, coord: Me }), j += $e.length / 4, X = j), Le && B.draw(w, R.LINES, Or.disabled, Qr.disabled, v.colorModeForRenderPass(), fi.disabled, ts(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(Me), S.getProjectionData({ overscaledTileID: Me, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), f.id, Le.layoutVertexBuffer, Le.indexBuffer, Le.segments, null, v.transform.zoom, null, null, Le.collisionVertexBuffer);
          }
          if (!b || !U.length) return;
          const q = v.useProgram("collisionCircle"), Q = new o.c0();
          Q.resize(4 * j), Q._trim();
          let ce = 0;
          for (const Se of U) for (let Me = 0; Me < Se.circleArray.length / 4; Me++) {
            const Ge = 4 * Me, Le = Se.circleArray[Ge + 0], $e = Se.circleArray[Ge + 1], Xe = Se.circleArray[Ge + 2], Fe = Se.circleArray[Ge + 3];
            Q.emplace(ce++, Le, $e, Xe, Fe, 0), Q.emplace(ce++, Le, $e, Xe, Fe, 1), Q.emplace(ce++, Le, $e, Xe, Fe, 2), Q.emplace(ce++, Le, $e, Xe, Fe, 3);
          }
          (!$c || $c.length < 2 * j) && ($c = function(Se) {
            const Me = 2 * Se, Ge = new o.c2();
            Ge.resize(Me), Ge._trim();
            for (let Le = 0; Le < Me; Le++) {
              const $e = 6 * Le;
              Ge.uint16[$e + 0] = 4 * Le + 0, Ge.uint16[$e + 1] = 4 * Le + 1, Ge.uint16[$e + 2] = 4 * Le + 2, Ge.uint16[$e + 3] = 4 * Le + 2, Ge.uint16[$e + 4] = 4 * Le + 3, Ge.uint16[$e + 5] = 4 * Le + 0;
            }
            return Ge;
          }(j));
          const we = w.createIndexBuffer($c, !0), Ae = w.createVertexBuffer(Q, o.c1.members, !0);
          for (const Se of U) {
            const Me = mo(v.transform);
            q.draw(w, R.TRIANGLES, Or.disabled, Qr.disabled, v.colorModeForRenderPass(), fi.disabled, Me, v.style.map.terrain && v.style.map.terrain.getTerrainData(Se.coord), null, f.id, Ae, we, o.aM.simpleSegment(0, 2 * Se.circleOffset, Se.circleArray.length, Se.circleArray.length / 2), null, v.transform.zoom, null, null, null);
          }
          Ae.destroy(), we.destroy();
        }
        const Jl = o.ai(new Float32Array(16));
        function qc(v, a, f, g, b, w) {
          const { horizontalAlign: S, verticalAlign: R } = o.aH(v);
          return new o.P((-(S - 0.5) * a / b + g[0]) * w, (-(R - 0.5) * f / b + g[1]) * w);
        }
        function ph(v, a, f, g, b, w) {
          const S = a.tileAnchorPoint.add(new o.P(a.translation[0], a.translation[1]));
          if (a.pitchWithMap) {
            let R = g.mult(w);
            f || (R = R.rotate(-b));
            const B = S.add(R);
            return Rn(B.x, B.y, a.pitchedLabelPlaneMatrix, a.getElevation).point;
          }
          if (f) {
            const R = Nr(a.tileAnchorPoint.x + 1, a.tileAnchorPoint.y, a).point.sub(v), B = Math.atan(R.y / R.x) + (R.x < 0 ? Math.PI : 0);
            return v.add(g.rotate(B));
          }
          return v.add(g);
        }
        function of(v, a, f, g, b, w, S, R, B, U, j, X) {
          const q = v.text.placedSymbolArray, Q = v.text.dynamicLayoutVertexArray, ce = v.icon.dynamicLayoutVertexArray, we = {};
          Q.clear();
          for (let Ae = 0; Ae < q.length; Ae++) {
            const Se = q.get(Ae), Me = Se.hidden || !Se.crossTileID || v.allowVerticalPlacement && !Se.placedOrientation ? null : g[Se.crossTileID];
            if (Me) {
              const Ge = new o.P(Se.anchorX, Se.anchorY), Le = { getElevation: X, width: b.width, height: b.height, pitchedLabelPlaneMatrix: w, pitchWithMap: f, transform: b, tileAnchorPoint: Ge, translation: U, unwrappedTileID: j }, $e = f ? Wo(Ge.x, Ge.y, Le) : Nr(Ge.x, Ge.y, Le), Xe = eo(b.cameraToCenterDistance, $e.signedDistanceFromCamera);
              let Fe = o.ap(v.textSizeData, R, Se) * Xe / o.aB;
              f && (Fe *= v.tilePixelRatio / S);
              const { width: Qe, height: At, anchor: ft, textOffset: dt, textBoxScale: _t } = Me, qt = qc(ft, Qe, At, dt, _t, Fe), Zt = b.getPitchedTextCorrection(Ge.x + U[0], Ge.y + U[1], j), zt = ph($e.point, Le, a, qt, -b.bearingInRadians, Zt), pr = v.allowVerticalPlacement && Se.placedOrientation === o.ao.vertical ? Math.PI / 2 : 0;
              for (let Vr = 0; Vr < Se.numGlyphs; Vr++) o.av(Q, zt, pr);
              B && Se.associatedIconIndex >= 0 && (we[Se.associatedIconIndex] = { shiftedAnchor: zt, angle: pr });
            } else Ao(Se.numGlyphs, Q);
          }
          if (B) {
            ce.clear();
            const Ae = v.icon.placedSymbolArray;
            for (let Se = 0; Se < Ae.length; Se++) {
              const Me = Ae.get(Se);
              if (Me.hidden) Ao(Me.numGlyphs, ce);
              else {
                const Ge = we[Se];
                if (Ge) for (let Le = 0; Le < Me.numGlyphs; Le++) o.av(ce, Ge.shiftedAnchor, Ge.angle);
                else Ao(Me.numGlyphs, ce);
              }
            }
            v.icon.dynamicLayoutVertexBuffer.updateData(ce);
          }
          v.text.dynamicLayoutVertexBuffer.updateData(Q);
        }
        function af(v, a, f) {
          return f.iconsInText && a ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon";
        }
        function Nu(v, a, f, g, b, w, S, R, B, U, j, X, q) {
          const Q = v.context, ce = Q.gl, we = v.transform, Ae = R === "map", Se = B === "map", Me = R !== "viewport" && f.layout.get("symbol-placement") !== "point", Ge = Ae && !Se && !Me, Le = !f.layout.get("symbol-sort-key").isConstant();
          let $e = !1;
          const Xe = v.getDepthModeForSublayer(0, Or.ReadOnly), Fe = f._unevaluatedLayout.hasValue("text-variable-anchor") || f._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Qe = [], At = we.getCircleRadiusCorrection();
          for (const ft of g) {
            const dt = a.getTile(ft), _t = dt.getBucket(f);
            if (!_t) continue;
            const qt = b ? _t.text : _t.icon;
            if (!qt || !qt.segments.get().length || !qt.hasVisibleVertices) continue;
            const Zt = qt.programConfigurations.get(f.id), zt = b || _t.sdfIcons, pr = b ? _t.textSizeData : _t.iconSizeData, Vr = Se || we.pitch !== 0, Ti = v.useProgram(af(zt, b, _t), Zt), $i = o.an(pr, we.zoom), cn = v.style.map.terrain && v.style.map.terrain.getTerrainData(ft);
            let hi, en, ms, Pn, Cs = [0, 0], jn = null;
            if (b) en = dt.glyphAtlasTexture, ms = ce.LINEAR, hi = dt.glyphAtlasTexture.size, _t.iconsInText && (Cs = dt.imageAtlasTexture.size, jn = dt.imageAtlasTexture, Pn = Vr || v.options.rotating || v.options.zooming || pr.kind === "composite" || pr.kind === "camera" ? ce.LINEAR : ce.NEAREST);
            else {
              const ns = f.layout.get("icon-size").constantOr(0) !== 1 || _t.iconsNeedLinear;
              en = dt.imageAtlasTexture, ms = zt || v.options.rotating || v.options.zooming || ns || Vr ? ce.LINEAR : ce.NEAREST, hi = dt.imageAtlasTexture.size;
            }
            const Jn = o.aC(dt, 1, v.transform.zoom), Is = ci(Ae, v.transform, Jn), eu = o.L();
            o.aq(eu, Is);
            const tu = Lt(Se, Ae, v.transform, Jn), $u = o.aD(we, dt, w, S), ru = we.getProjectionData({ overscaledTileID: ft, applyGlobeMatrix: !q, applyTerrainMatrix: !0 }), Hu = Fe && _t.hasTextData(), pf = f.layout.get("icon-text-fit") !== "none" && Hu && _t.hasIconData();
            if (Me) {
              const ns = v.style.map.terrain ? (Lo, Vn) => v.style.map.terrain.getElevation(ft, Lo, Vn) : null, Ps = f.layout.get("text-rotation-alignment") === "map";
              Xt(_t, v, b, Is, eu, Se, U, Ps, ft.toUnwrapped(), we.width, we.height, $u, ns);
            }
            const iu = b && Fe || pf, bo = Me || iu ? Jl : Se ? Is : v.transform.clipSpaceToPixelsMatrix, oo = zt && f.paint.get(b ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Il;
            Il = zt ? _t.iconsInText ? vl(pr.kind, $i, Ge, Se, Me, iu, v, bo, tu, $u, hi, Cs, At) : bl(pr.kind, $i, Ge, Se, Me, iu, v, bo, tu, $u, b, hi, 0, At) : Wl(pr.kind, $i, Ge, Se, Me, iu, v, bo, tu, $u, b, hi, At);
            const Ah = { program: Ti, buffers: qt, uniformValues: Il, projectionData: ru, atlasTexture: en, atlasTextureIcon: jn, atlasInterpolation: ms, atlasInterpolationIcon: Pn, isSDF: zt, hasHalo: oo };
            if (Le && _t.canOverlap) {
              $e = !0;
              const ns = qt.segments.get();
              for (const Ps of ns) Qe.push({ segments: new o.aM([Ps]), sortKey: Ps.sortKey, state: Ah, terrainData: cn });
            } else Qe.push({ segments: qt.segments, sortKey: 0, state: Ah, terrainData: cn });
          }
          $e && Qe.sort((ft, dt) => ft.sortKey - dt.sortKey);
          for (const ft of Qe) {
            const dt = ft.state;
            if (Q.activeTexture.set(ce.TEXTURE0), dt.atlasTexture.bind(dt.atlasInterpolation, ce.CLAMP_TO_EDGE), dt.atlasTextureIcon && (Q.activeTexture.set(ce.TEXTURE1), dt.atlasTextureIcon && dt.atlasTextureIcon.bind(dt.atlasInterpolationIcon, ce.CLAMP_TO_EDGE)), dt.isSDF) {
              const _t = dt.uniformValues;
              dt.hasHalo && (_t.u_is_halo = 1, Fu(dt.buffers, ft.segments, f, v, dt.program, Xe, j, X, _t, dt.projectionData, ft.terrainData)), _t.u_is_halo = 0;
            }
            Fu(dt.buffers, ft.segments, f, v, dt.program, Xe, j, X, dt.uniformValues, dt.projectionData, ft.terrainData);
          }
        }
        function Fu(v, a, f, g, b, w, S, R, B, U, j) {
          const X = g.context;
          b.draw(X, X.gl.TRIANGLES, w, S, R, fi.backCCW, B, j, U, f.id, v.layoutVertexBuffer, v.indexBuffer, a, f.paint, g.transform.zoom, v.programConfigurations.get(f.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer);
        }
        function gh(v, a, f, g, b) {
          const w = v.context, S = w.gl, R = Qr.disabled, B = new Si([S.ONE, S.ONE], o.bf.transparent, [!0, !0, !0, !0]), U = a.getBucket(f);
          if (!U) return;
          const j = g.key;
          let X = f.heatmapFbos.get(j);
          X || (X = mh(w, a.tileSize, a.tileSize), f.heatmapFbos.set(j, X)), w.bindFramebuffer.set(X.framebuffer), w.viewport.set([0, 0, a.tileSize, a.tileSize]), w.clear({ color: o.bf.transparent });
          const q = U.programConfigurations.get(f.id), Q = v.useProgram("heatmap", q, !b), ce = v.transform.getProjectionData({ overscaledTileID: a.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), we = v.style.map.terrain.getTerrainData(g);
          Q.draw(w, S.TRIANGLES, Or.disabled, R, B, fi.disabled, $l(a, v.transform.zoom, f.paint.get("heatmap-intensity"), 1), we, ce, f.id, U.layoutVertexBuffer, U.indexBuffer, U.segments, f.paint, v.transform.zoom, q);
        }
        function Wc(v, a, f, g, b) {
          const w = v.context, S = w.gl, R = v.transform;
          w.setColorMode(v.colorModeForRenderPass());
          const B = _h(w, a), U = f.key, j = a.heatmapFbos.get(U);
          if (!j) return;
          w.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, j.colorAttachment.get()), w.activeTexture.set(S.TEXTURE1), B.bind(S.LINEAR, S.CLAMP_TO_EDGE);
          const X = R.getProjectionData({ overscaledTileID: f, applyTerrainMatrix: b, applyGlobeMatrix: !g });
          v.useProgram("heatmapTexture").draw(w, S.TRIANGLES, Or.disabled, Qr.disabled, v.colorModeForRenderPass(), fi.disabled, na(v, a, 0, 1), null, X, a.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, a.paint, R.zoom), j.destroy(), a.heatmapFbos.delete(U);
        }
        function mh(v, a, f) {
          var g, b;
          const w = v.gl, S = w.createTexture();
          w.bindTexture(w.TEXTURE_2D, S), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, w.LINEAR), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, w.LINEAR);
          const R = (g = v.HALF_FLOAT) !== null && g !== void 0 ? g : w.UNSIGNED_BYTE, B = (b = v.RGBA16F) !== null && b !== void 0 ? b : w.RGBA;
          w.texImage2D(w.TEXTURE_2D, 0, B, a, f, 0, w.RGBA, R, null);
          const U = v.createFramebuffer(a, f, !1, !1);
          return U.colorAttachment.set(S), U;
        }
        function _h(v, a) {
          return a.colorRampTexture || (a.colorRampTexture = new o.T(v, a.colorRamp, v.gl.RGBA)), a.colorRampTexture;
        }
        function El(v, a, f, g, b, w, S, R) {
          let B = 256;
          if (b.stepInterpolant) {
            const U = a.getSource().maxzoom, j = S.canonical.z === U ? Math.ceil(1 << v.transform.maxZoom - S.canonical.z) : 1;
            B = o.ae(o.c4(w.maxLineLength / o.$ * 1024 * j), 256, f.maxTextureSize);
          }
          return R.gradient = o.c5({ expression: b.gradientExpression(), evaluationKey: "lineProgress", resolution: B, image: R.gradient || void 0, clips: w.lineClipsArray }), R.texture ? R.texture.update(R.gradient) : R.texture = new o.T(f, R.gradient, g.RGBA), R.version = b.gradientVersion, R.texture;
        }
        function Uu(v, a, f, g, b) {
          v.activeTexture.set(a.TEXTURE0), f.imageAtlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), g.updatePaintBuffers(b);
        }
        function pd(v, a, f, g, b, w) {
          (b || v.lineAtlas.dirty) && (a.activeTexture.set(f.TEXTURE0), v.lineAtlas.bind(a)), g.updatePaintBuffers(w);
        }
        function yh(v, a, f, g, b, w, S) {
          const R = w.gradients[b.id];
          let B = R.texture;
          b.gradientVersion !== R.version && (B = El(v, a, f, g, b, w, S, R)), f.activeTexture.set(g.TEXTURE0), B.bind(b.stepInterpolant ? g.NEAREST : g.LINEAR, g.CLAMP_TO_EDGE);
        }
        function bh(v, a, f, g, b, w, S, R, B) {
          const U = w.gradients[b.id];
          let j = U.texture;
          b.gradientVersion !== U.version && (j = El(v, a, f, g, b, w, S, U)), f.activeTexture.set(g.TEXTURE0), j.bind(b.stepInterpolant ? g.NEAREST : g.LINEAR, g.CLAMP_TO_EDGE), f.activeTexture.set(g.TEXTURE1), v.lineAtlas.bind(f), R.updatePaintBuffers(B);
        }
        function lf(v, a, f, g, b) {
          if (!f || !g || !g.imageAtlas) return;
          const w = g.imageAtlas.patternPositions;
          let S = w[f.to.toString()], R = w[f.from.toString()];
          if (!S && R && (S = R), !R && S && (R = S), !S || !R) {
            const B = b.getPaintProperty(a);
            S = w[B], R = w[B];
          }
          S && R && v.setConstantPatternPositions(S, R);
        }
        function cf(v, a, f, g, b, w, S, R) {
          const B = v.context.gl, U = "fill-pattern", j = f.paint.get(U), X = j && j.constantOr(1), q = f.getCrossfadeParameters();
          let Q, ce, we, Ae, Se;
          const Me = v.transform, Ge = f.paint.get("fill-translate"), Le = f.paint.get("fill-translate-anchor");
          S ? (ce = X && !f.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", Q = B.LINES) : (ce = X ? "fillPattern" : "fill", Q = B.TRIANGLES);
          const $e = j.constantOr(null);
          for (const Xe of g) {
            const Fe = a.getTile(Xe);
            if (X && !Fe.patternsLoaded()) continue;
            const Qe = Fe.getBucket(f);
            if (!Qe) continue;
            const At = Qe.programConfigurations.get(f.id), ft = v.useProgram(ce, At), dt = v.style.map.terrain && v.style.map.terrain.getTerrainData(Xe);
            X && (v.context.activeTexture.set(B.TEXTURE0), Fe.imageAtlasTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE), At.updatePaintBuffers(q)), lf(At, U, $e, Fe, f);
            const _t = Me.getProjectionData({ overscaledTileID: Xe, applyGlobeMatrix: !R, applyTerrainMatrix: !0 }), qt = o.aD(Me, Fe, Ge, Le);
            if (S) {
              Ae = Qe.indexBuffer2, Se = Qe.segments2;
              const zt = [B.drawingBufferWidth, B.drawingBufferHeight];
              we = ce === "fillOutlinePattern" && X ? Nc(v, q, Fe, zt, qt) : Gl(zt, qt);
            } else Ae = Qe.indexBuffer, Se = Qe.segments, we = X ? Ss(v, q, Fe, qt) : { u_fill_translate: qt };
            const Zt = v.stencilModeForClipping(Xe);
            ft.draw(v.context, Q, b, Zt, w, fi.backCCW, we, dt, _t, f.id, Qe.layoutVertexBuffer, Ae, Se, f.paint, v.transform.zoom, At);
          }
        }
        function Xc(v, a, f, g, b, w, S, R) {
          const B = v.context, U = B.gl, j = "fill-extrusion-pattern", X = f.paint.get(j), q = X.constantOr(1), Q = f.getCrossfadeParameters(), ce = f.paint.get("fill-extrusion-opacity"), we = X.constantOr(null), Ae = v.transform;
          for (const Se of g) {
            const Me = a.getTile(Se), Ge = Me.getBucket(f);
            if (!Ge) continue;
            const Le = v.style.map.terrain && v.style.map.terrain.getTerrainData(Se), $e = Ge.programConfigurations.get(f.id), Xe = v.useProgram(q ? "fillExtrusionPattern" : "fillExtrusion", $e);
            q && (v.context.activeTexture.set(U.TEXTURE0), Me.imageAtlasTexture.bind(U.LINEAR, U.CLAMP_TO_EDGE), $e.updatePaintBuffers(Q));
            const Fe = Ae.getProjectionData({ overscaledTileID: Se, applyGlobeMatrix: !R, applyTerrainMatrix: !0 });
            lf($e, j, we, Me, f);
            const Qe = o.aD(Ae, Me, f.paint.get("fill-extrusion-translate"), f.paint.get("fill-extrusion-translate-anchor")), At = f.paint.get("fill-extrusion-vertical-gradient"), ft = q ? za(v, At, ce, Qe, Se, Q, Me) : ia(v, At, ce, Qe);
            Xe.draw(B, B.gl.TRIANGLES, b, w, S, fi.backCCW, ft, Le, Fe, f.id, Ge.layoutVertexBuffer, Ge.indexBuffer, Ge.segments, f.paint, v.transform.zoom, $e, v.style.map.terrain && Ge.centroidVertexBuffer);
          }
        }
        function zu(v, a, f, g, b, w, S, R, B) {
          var U;
          const j = v.style.projection, X = v.context, q = v.transform, Q = X.gl, ce = [`#define NUM_ILLUMINATION_SOURCES ${f.paint.get("hillshade-highlight-color").values.length}`], we = v.useProgram("hillshade", null, !1, ce), Ae = !v.options.moving;
          for (const Se of g) {
            const Me = a.getTile(Se), Ge = Me.fbo;
            if (!Ge) continue;
            const Le = j.getMeshFromTileID(X, Se.canonical, R, !0, "raster"), $e = (U = v.style.map.terrain) === null || U === void 0 ? void 0 : U.getTerrainData(Se);
            X.activeTexture.set(Q.TEXTURE0), Q.bindTexture(Q.TEXTURE_2D, Ge.colorAttachment.get());
            const Xe = q.getProjectionData({ overscaledTileID: Se, aligned: Ae, applyGlobeMatrix: !B, applyTerrainMatrix: !0 });
            we.draw(X, Q.TRIANGLES, w, b[Se.overscaledZ], S, fi.backCCW, Hl(v, Me, f), $e, Xe, f.id, Le.vertexBuffer, Le.indexBuffer, Le.segments);
          }
        }
        function ba(v, a, f, g, b, w, S, R, B) {
          var U;
          const j = v.style.projection, X = v.context, q = v.transform, Q = X.gl, ce = v.useProgram("colorRelief"), we = !v.options.moving;
          let Ae = !0, Se = 0;
          for (const Me of g) {
            const Ge = a.getTile(Me), Le = Ge.dem;
            if (Ae) {
              const ft = Q.getParameter(Q.MAX_TEXTURE_SIZE), { elevationTexture: dt, colorTexture: _t } = f.getColorRampTextures(X, ft, Le.getUnpackVector());
              X.activeTexture.set(Q.TEXTURE1), dt.bind(Q.NEAREST, Q.CLAMP_TO_EDGE), X.activeTexture.set(Q.TEXTURE4), _t.bind(Q.LINEAR, Q.CLAMP_TO_EDGE), Ae = !1, Se = dt.size[0];
            }
            if (!Le || !Le.data) continue;
            const $e = Le.stride, Xe = Le.getPixels();
            if (X.activeTexture.set(Q.TEXTURE0), X.pixelStoreUnpackPremultiplyAlpha.set(!1), Ge.demTexture = Ge.demTexture || v.getTileTexture($e), Ge.demTexture) {
              const ft = Ge.demTexture;
              ft.update(Xe, { premultiply: !1 }), ft.bind(Q.LINEAR, Q.CLAMP_TO_EDGE);
            } else Ge.demTexture = new o.T(X, Xe, Q.RGBA, { premultiply: !1 }), Ge.demTexture.bind(Q.LINEAR, Q.CLAMP_TO_EDGE);
            const Fe = j.getMeshFromTileID(X, Me.canonical, R, !0, "raster"), Qe = (U = v.style.map.terrain) === null || U === void 0 ? void 0 : U.getTerrainData(Me), At = q.getProjectionData({ overscaledTileID: Me, aligned: we, applyGlobeMatrix: !B, applyTerrainMatrix: !0 });
            ce.draw(X, Q.TRIANGLES, w, b[Me.overscaledZ], S, fi.backCCW, _l(f, Ge.dem, Se), Qe, At, f.id, Fe.vertexBuffer, Fe.indexBuffer, Fe.segments);
          }
        }
        const io = [new o.P(0, 0), new o.P(o.$, 0), new o.P(o.$, o.$), new o.P(0, o.$)];
        function Ci(v, a, f, g, b, w, S, R, B = !1, U = !1) {
          const j = g[g.length - 1].overscaledZ, X = v.context, q = X.gl, Q = v.useProgram("raster"), ce = v.transform, we = v.style.projection, Ae = v.colorModeForRenderPass(), Se = !v.options.moving, Me = f.paint.get("raster-opacity"), Ge = f.paint.get("raster-resampling"), Le = f.paint.get("raster-fade-duration"), $e = !!v.style.map.terrain;
          for (const Xe of g) {
            const Fe = v.getDepthModeForSublayer(Xe.overscaledZ - j, Me === 1 ? Or.ReadWrite : Or.ReadOnly, q.LESS), Qe = a.getTile(Xe), At = Ge === "nearest" ? q.NEAREST : q.LINEAR;
            X.activeTexture.set(q.TEXTURE0), Qe.texture.bind(At, q.CLAMP_TO_EDGE, q.LINEAR_MIPMAP_NEAREST), X.activeTexture.set(q.TEXTURE1);
            const { parentTile: ft, parentScaleBy: dt, parentTopLeft: _t, fadeValues: qt } = Kl(Qe, a, Le, $e);
            Qe.fadeOpacity = qt.tileOpacity, ft ? (ft.fadeOpacity = qt.parentTileOpacity, ft.texture.bind(At, q.CLAMP_TO_EDGE, q.LINEAR_MIPMAP_NEAREST)) : Qe.texture.bind(At, q.CLAMP_TO_EDGE, q.LINEAR_MIPMAP_NEAREST), Qe.texture.useMipmap && X.extTextureFilterAnisotropic && v.transform.pitch > 20 && q.texParameterf(q.TEXTURE_2D, X.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, X.extTextureFilterAnisotropicMax);
            const Zt = v.style.map.terrain && v.style.map.terrain.getTerrainData(Xe), zt = ce.getProjectionData({ overscaledTileID: Xe, aligned: Se, applyGlobeMatrix: !U, applyTerrainMatrix: !0 }), pr = ma(_t, dt, qt.fadeMix, f, R), Vr = we.getMeshFromTileID(X, Xe.canonical, w, S, "raster");
            Q.draw(X, q.TRIANGLES, Fe, b ? b[Xe.overscaledZ] : Qr.disabled, Ae, B ? fi.frontCCW : fi.backCCW, pr, Zt, zt, f.id, Vr.vertexBuffer, Vr.indexBuffer, Vr.segments);
          }
        }
        function Kl(v, a, f, g) {
          const b = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
          if (f === 0 || g) return b;
          if (v.fadingParentID) {
            const w = a._getLoadedTile(v.fadingParentID);
            if (!w) return b;
            const S = Math.pow(2, w.tileID.overscaledZ - v.tileID.overscaledZ), R = [v.tileID.canonical.x * S % 1, v.tileID.canonical.y * S % 1], B = function(U, j, X) {
              const q = D(), Q = (q - j.timeAdded) / X, ce = U.fadingDirection === K.Incoming, we = o.ae((q - U.timeAdded) / X, 0, 1), Ae = o.ae(1 - Q, 0, 1), Se = ce ? we : Ae;
              return { tileOpacity: Se, parentTileOpacity: ce ? Ae : we, fadeMix: { opacity: 1, mix: 1 - Se } };
            }(v, w, f);
            return { parentTile: w, parentScaleBy: S, parentTopLeft: R, fadeValues: B };
          }
          if (v.selfFading) {
            const w = function(S, R) {
              const B = (D() - S.timeAdded) / R, U = o.ae(B, 0, 1);
              return { tileOpacity: U, fadeMix: { opacity: U, mix: 0 } };
            }(v, f);
            return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: w };
          }
          return b;
        }
        const yo = new o.bf(1, 0, 0, 1), va = new o.bf(0, 1, 0, 1), $s = new o.bf(0, 0, 1, 1), gd = new o.bf(1, 0, 1, 1), Zc = new o.bf(0, 1, 1, 1);
        function ju(v, a, f, g) {
          ec(v, 0, a + f / 2, v.transform.width, f, g);
        }
        function Ql(v, a, f, g) {
          ec(v, a - f / 2, 0, f, v.transform.height, g);
        }
        function ec(v, a, f, g, b, w) {
          const S = v.context, R = S.gl;
          R.enable(R.SCISSOR_TEST), R.scissor(a * v.pixelRatio, f * v.pixelRatio, g * v.pixelRatio, b * v.pixelRatio), S.clear({ color: w }), R.disable(R.SCISSOR_TEST);
        }
        function uf(v, a, f) {
          const g = v.context, b = g.gl, w = v.useProgram("debug"), S = Or.disabled, R = Qr.disabled, B = v.colorModeForRenderPass(), U = "$debug", j = v.style.map.terrain && v.style.map.terrain.getTerrainData(f);
          g.activeTexture.set(b.TEXTURE0);
          const X = a.getTileByID(f.key).latestRawTileData, q = Math.floor((X && X.byteLength || 0) / 1024), Q = a.getTile(f).tileSize, ce = 512 / Math.min(Q, 512) * (f.overscaledZ / v.transform.zoom) * 0.5;
          let we = f.canonical.toString();
          f.overscaledZ !== f.canonical.z && (we += ` => ${f.overscaledZ}`), function(Se, Me) {
            Se.initDebugOverlayCanvas();
            const Ge = Se.debugOverlayCanvas, Le = Se.context.gl, $e = Se.debugOverlayCanvas.getContext("2d");
            $e.clearRect(0, 0, Ge.width, Ge.height), $e.shadowColor = "white", $e.shadowBlur = 2, $e.lineWidth = 1.5, $e.strokeStyle = "white", $e.textBaseline = "top", $e.font = "bold 36px Open Sans, sans-serif", $e.fillText(Me, 5, 5), $e.strokeText(Me, 5, 5), Se.debugOverlayTexture.update(Ge), Se.debugOverlayTexture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE);
          }(v, `${we} ${q}kB`);
          const Ae = v.transform.getProjectionData({ overscaledTileID: f, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          w.draw(g, b.TRIANGLES, S, R, Si.alphaBlended, fi.disabled, Fc(o.bf.transparent, ce), null, Ae, U, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments), w.draw(g, b.LINE_STRIP, S, R, B, fi.disabled, Fc(o.bf.red), j, Ae, U, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments);
        }
        function hf(v, a, f, g) {
          const { isRenderingGlobe: b } = g, w = v.context, S = w.gl, R = v.transform, B = v.colorModeForRenderPass(), U = v.getDepthModeFor3D(), j = v.useProgram("terrain");
          w.bindFramebuffer.set(null), w.viewport.set([0, 0, v.width, v.height]);
          for (const X of f) {
            const q = a.getTerrainMesh(X.tileID), Q = v.renderToTexture.getTexture(X), ce = a.getTerrainData(X.tileID);
            w.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, Q.texture);
            const we = a.getMeshFrameDelta(R.zoom), Ae = R.calculateFogMatrix(X.tileID.toUnwrapped()), Se = ml(we, Ae, v.style.sky, R.pitch, b), Me = R.getProjectionData({ overscaledTileID: X.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            j.draw(w, S.TRIANGLES, U, Qr.disabled, B, fi.backCCW, Se, ce, Me, "terrain", q.vertexBuffer, q.indexBuffer, q.segments);
          }
        }
        function Yc(v, a) {
          if (!a.mesh) {
            const f = new o.aL();
            f.emplaceBack(-1, -1), f.emplaceBack(1, -1), f.emplaceBack(1, 1), f.emplaceBack(-1, 1);
            const g = new o.aN();
            g.emplaceBack(0, 1, 2), g.emplaceBack(0, 2, 3), a.mesh = new fs(v.createVertexBuffer(f, jr.members), v.createIndexBuffer(g), o.aM.simpleSegment(0, 0, f.length, g.length));
          }
          return a.mesh;
        }
        class Vu {
          constructor(a, f) {
            this.context = new sf(a), this.transform = f, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: o.ai(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = li.maxUnderzooming + li.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ba();
          }
          resize(a, f, g) {
            if (this.width = Math.floor(a * g), this.height = Math.floor(f * g), this.pixelRatio = g, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const b of this.style._order) this.style._layers[b].resize();
          }
          setup() {
            const a = this.context, f = new o.aL();
            f.emplaceBack(0, 0), f.emplaceBack(o.$, 0), f.emplaceBack(0, o.$), f.emplaceBack(o.$, o.$), this.tileExtentBuffer = a.createVertexBuffer(f, jr.members), this.tileExtentSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const g = new o.aL();
            g.emplaceBack(0, 0), g.emplaceBack(o.$, 0), g.emplaceBack(0, o.$), g.emplaceBack(o.$, o.$), this.debugBuffer = a.createVertexBuffer(g, jr.members), this.debugSegments = o.aM.simpleSegment(0, 0, 4, 5);
            const b = new o.c7();
            b.emplaceBack(0, 0, 0, 0), b.emplaceBack(o.$, 0, o.$, 0), b.emplaceBack(0, o.$, 0, o.$), b.emplaceBack(o.$, o.$, o.$, o.$), this.rasterBoundsBuffer = a.createVertexBuffer(b, go.members), this.rasterBoundsSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const w = new o.aL();
            w.emplaceBack(0, 0), w.emplaceBack(o.$, 0), w.emplaceBack(0, o.$), w.emplaceBack(o.$, o.$), this.rasterBoundsBufferPosOnly = a.createVertexBuffer(w, jr.members), this.rasterBoundsSegmentsPosOnly = o.aM.simpleSegment(0, 0, 4, 5);
            const S = new o.aL();
            S.emplaceBack(0, 0), S.emplaceBack(1, 0), S.emplaceBack(0, 1), S.emplaceBack(1, 1), this.viewportBuffer = a.createVertexBuffer(S, jr.members), this.viewportSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const R = new o.c8();
            R.emplaceBack(0), R.emplaceBack(1), R.emplaceBack(3), R.emplaceBack(2), R.emplaceBack(0), this.tileBorderIndexBuffer = a.createIndexBuffer(R);
            const B = new o.aN();
            B.emplaceBack(1, 0, 2), B.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = a.createIndexBuffer(B);
            const U = this.context.gl;
            this.stencilClearMode = new Qr({ func: U.ALWAYS, mask: 0 }, 0, 255, U.ZERO, U.ZERO, U.ZERO), this.tileExtentMesh = new fs(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const a = this.context, f = a.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const g = o.L();
            o.bZ(g, 0, this.width, this.height, 0, 0, 1), o.N(g, g, [f.drawingBufferWidth, f.drawingBufferHeight, 0]);
            const b = { mainMatrix: g, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: g };
            this.useProgram("clippingMask", null, !0).draw(a, f.TRIANGLES, Or.disabled, this.stencilClearMode, Si.disabled, fi.disabled, null, null, b, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(a, f, g) {
            if (this.currentStencilSource === a.source || !a.isTileClipped() || !f || !f.length) return;
            this.currentStencilSource = a.source, this.nextStencilID + f.length > 256 && this.clearStencil();
            const b = this.context;
            b.setColorMode(Si.disabled), b.setDepthMode(Or.disabled);
            const w = {};
            for (const S of f) w[S.key] = this.nextStencilID++;
            this._renderTileMasks(w, f, g, !0), this._renderTileMasks(w, f, g, !1), this._tileClippingMaskIDs = w;
          }
          _renderTileMasks(a, f, g, b) {
            const w = this.context, S = w.gl, R = this.style.projection, B = this.transform, U = this.useProgram("clippingMask");
            for (const j of f) {
              const X = a[j.key], q = this.style.map.terrain && this.style.map.terrain.getTerrainData(j), Q = R.getMeshFromTileID(this.context, j.canonical, b, !0, "stencil"), ce = B.getProjectionData({ overscaledTileID: j, applyGlobeMatrix: !g, applyTerrainMatrix: !0 });
              U.draw(w, S.TRIANGLES, Or.disabled, new Qr({ func: S.ALWAYS, mask: 0 }, X, 255, S.KEEP, S.KEEP, S.REPLACE), Si.disabled, g ? fi.disabled : fi.backCCW, null, q, ce, "$clipping", Q.vertexBuffer, Q.indexBuffer, Q.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const a = this.context, f = a.gl, g = this.style.projection, b = this.transform, w = this.useProgram("depth"), S = this.getDepthModeFor3D(), R = fr(b, { tileSize: b.tileSize });
            for (const B of R) {
              const U = this.style.map.terrain && this.style.map.terrain.getTerrainData(B), j = g.getMeshFromTileID(this.context, B.canonical, !0, !0, "raster"), X = b.getProjectionData({ overscaledTileID: B, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              w.draw(a, f.TRIANGLES, S, Qr.disabled, Si.disabled, fi.backCCW, null, U, X, "$clipping", j.vertexBuffer, j.indexBuffer, j.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const a = this.nextStencilID++, f = this.context.gl;
            return new Qr({ func: f.NOTEQUAL, mask: 255 }, a, 255, f.KEEP, f.KEEP, f.REPLACE);
          }
          stencilModeForClipping(a) {
            const f = this.context.gl;
            return new Qr({ func: f.EQUAL, mask: 255 }, this._tileClippingMaskIDs[a.key], 0, f.KEEP, f.KEEP, f.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(a) {
            const f = this.context.gl, g = a.sort((S, R) => R.overscaledZ - S.overscaledZ), b = g[g.length - 1].overscaledZ, w = g[0].overscaledZ - b + 1;
            if (w > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
              const S = {};
              for (let R = 0; R < w; R++) S[R + b] = new Qr({ func: f.GEQUAL, mask: 255 }, R + this.nextStencilID, 255, f.KEEP, f.KEEP, f.REPLACE);
              return this.nextStencilID += w, [S, g];
            }
            return [{ [b]: Qr.disabled }, g];
          }
          stencilConfigForOverlapTwoPass(a) {
            const f = this.context.gl, g = a.sort((S, R) => R.overscaledZ - S.overscaledZ), b = g[g.length - 1].overscaledZ, w = g[0].overscaledZ - b + 1;
            if (this.clearStencil(), w > 1) {
              const S = {}, R = {};
              for (let B = 0; B < w; B++) S[B + b] = new Qr({ func: f.GREATER, mask: 255 }, w + 1 + B, 255, f.KEEP, f.KEEP, f.REPLACE), R[B + b] = new Qr({ func: f.GREATER, mask: 255 }, 1 + B, 255, f.KEEP, f.KEEP, f.REPLACE);
              return this.nextStencilID = 2 * w + 1, [S, R, g];
            }
            return this.nextStencilID = 3, [{ [b]: new Qr({ func: f.GREATER, mask: 255 }, 2, 255, f.KEEP, f.KEEP, f.REPLACE) }, { [b]: new Qr({ func: f.GREATER, mask: 255 }, 1, 255, f.KEEP, f.KEEP, f.REPLACE) }, g];
          }
          colorModeForRenderPass() {
            const a = this.context.gl;
            return this._showOverdrawInspector ? new Si([a.CONSTANT_COLOR, a.ONE], new o.bf(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Si.unblended : Si.alphaBlended;
          }
          getDepthModeForSublayer(a, f, g) {
            if (!this.opaquePassEnabledForLayer()) return Or.disabled;
            const b = 1 - ((1 + this.currentLayer) * this.numSublayers + a) * this.depthEpsilon;
            return new Or(g || this.context.gl.LEQUAL, f, [b, b]);
          }
          getDepthModeFor3D() {
            return new Or(this.context.gl.LEQUAL, Or.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(a, f) {
            var g, b;
            this.style = a, this.options = f, this.lineAtlas = a.lineAtlas, this.imageManager = a.imageManager, this.glyphManager = a.glyphManager, this.symbolFadeChange = a.placement.symbolFadeChange(D()), this.imageManager.beginFrame();
            const w = this.style._order, S = this.style.sourceCaches, R = {}, B = {}, U = {}, j = { isRenderingToTexture: !1, isRenderingGlobe: ((g = a.projection) === null || g === void 0 ? void 0 : g.transitionState) > 0 };
            for (const q in S) {
              const Q = S[q];
              Q.used && Q.prepare(this.context), R[q] = Q.getVisibleCoordinates(!1), B[q] = R[q].slice().reverse(), U[q] = Q.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let q = 0; q < w.length; q++) if (this.style._layers[w[q]].is3D()) {
              this.opaquePassCutoff = q;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const q of w) {
              const Q = this.style._layers[q];
              if (!Q.hasOffscreenPass() || Q.isHidden(this.transform.zoom)) continue;
              const ce = B[Q.source];
              (Q.type === "custom" || ce.length) && this.renderLayer(this, S[Q.source], Q, ce, j);
            }
            if ((b = this.style.projection) === null || b === void 0 || b.updateGPUdependent({ context: this.context, useProgram: (q) => this.useProgram(q) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: f.showOverdrawInspector ? o.bf.black : o.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(q, Q) {
              const ce = q.context, we = ce.gl, Ae = ((Xe, Fe, Qe) => {
                const At = Math.cos(Fe.rollInRadians), ft = Math.sin(Fe.rollInRadians), dt = He(Fe), _t = Fe.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: Xe.properties.get("sky-color"), u_horizon_color: Xe.properties.get("horizon-color"), u_horizon: [(Fe.width / 2 - dt * ft) * Qe, (Fe.height / 2 + dt * At) * Qe], u_horizon_normal: [-ft, At], u_sky_horizon_blend: Xe.properties.get("sky-horizon-blend") * Fe.height / 2 * Qe, u_sky_blend: _t };
              })(Q, q.style.map.transform, q.pixelRatio), Se = new Or(we.LEQUAL, Or.ReadWrite, [0, 1]), Me = Qr.disabled, Ge = q.colorModeForRenderPass(), Le = q.useProgram("sky"), $e = Yc(ce, Q);
              Le.draw(ce, we.TRIANGLES, Se, Me, Ge, fi.disabled, Ae, null, void 0, "sky", $e.vertexBuffer, $e.indexBuffer, $e.segments);
            }(this, this.style.sky), this._showOverdrawInspector = f.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (a._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = w.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const q = this.style._layers[w[this.currentLayer]], Q = S[q.source], ce = R[q.source];
              this._renderTileClippingMasks(q, ce, !1), this.renderLayer(this, Q, q, ce, j);
            }
            this.renderPass = "translucent";
            let X = !1;
            for (this.currentLayer = 0; this.currentLayer < w.length; this.currentLayer++) {
              const q = this.style._layers[w[this.currentLayer]], Q = S[q.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(q, j)) continue;
              this.opaquePassEnabledForLayer() || X || (X = !0, j.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const ce = (q.type === "symbol" ? U : B)[q.source];
              this._renderTileClippingMasks(q, R[q.source], !!this.renderToTexture), this.renderLayer(this, Q, q, ce, j);
            }
            if (j.isRenderingGlobe && function(q, Q, ce) {
              const we = q.context, Ae = we.gl, Se = q.useProgram("atmosphere"), Me = new Or(Ae.LEQUAL, Or.ReadOnly, [0, 1]), Ge = q.transform, Le = function(_t, qt) {
                const Zt = _t.properties.get("position"), zt = [-Zt.x, -Zt.y, -Zt.z], pr = o.ai(new Float64Array(16));
                return _t.properties.get("anchor") === "map" && (o.b6(pr, pr, qt.rollInRadians), o.b7(pr, pr, -qt.pitchInRadians), o.b6(pr, pr, qt.bearingInRadians), o.b7(pr, pr, qt.center.lat * Math.PI / 180), o.bz(pr, pr, -qt.center.lng * Math.PI / 180)), o.c6(zt, zt, pr), zt;
              }(ce, q.transform), $e = Ge.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Xe = Q.properties.get("atmosphere-blend") * $e.projectionTransition;
              if (Xe === 0) return;
              const Fe = Ye(Ge.worldSize, Ge.center.lat), Qe = Ge.inverseProjectionMatrix, At = new Float64Array(4);
              At[3] = 1, o.aw(At, At, Ge.modelViewProjectionMatrix), At[0] /= At[3], At[1] /= At[3], At[2] /= At[3], At[3] = 1, o.aw(At, At, Qe), At[0] /= At[3], At[1] /= At[3], At[2] /= At[3], At[3] = 1;
              const ft = /* @__PURE__ */ ((_t, qt, Zt, zt, pr) => ({ u_sun_pos: _t, u_atmosphere_blend: qt, u_globe_position: Zt, u_globe_radius: zt, u_inv_proj_matrix: pr }))(Le, Xe, [At[0], At[1], At[2]], Fe, Qe), dt = Yc(we, Q);
              Se.draw(we, Ae.TRIANGLES, Me, Qr.disabled, Si.alphaBlended, fi.disabled, ft, null, null, "atmosphere", dt.vertexBuffer, dt.indexBuffer, dt.segments);
            }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const q = function(Q, ce) {
                let we = null;
                const Ae = Object.values(Q._layers).flatMap((Le) => Le.source && !Le.isHidden(ce) ? [Q.sourceCaches[Le.source]] : []), Se = Ae.filter((Le) => Le.getSource().type === "vector"), Me = Ae.filter((Le) => Le.getSource().type !== "vector"), Ge = (Le) => {
                  (!we || we.getSource().maxzoom < Le.getSource().maxzoom) && (we = Le);
                };
                return Se.forEach((Le) => Ge(Le)), we || Me.forEach((Le) => Ge(Le)), we;
              }(this.style, this.transform.zoom);
              q && function(Q, ce, we) {
                for (let Ae = 0; Ae < we.length; Ae++) uf(Q, ce, we[Ae]);
              }(this, q, q.getVisibleCoordinates());
            }
            this.options.showPadding && function(q) {
              const Q = q.transform.padding;
              ju(q, q.transform.height - (Q.top || 0), 3, yo), ju(q, Q.bottom || 0, 3, va), Ql(q, Q.left || 0, 3, $s), Ql(q, q.transform.width - (Q.right || 0), 3, gd);
              const ce = q.transform.centerPoint;
              (function(we, Ae, Se, Me) {
                ec(we, Ae - 1, Se - 10, 2, 20, Me), ec(we, Ae - 10, Se - 1, 20, 2, Me);
              })(q, ce.x, q.transform.height - ce.y, Zc);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(a) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const f = this.terrainFacilitator.matrix, g = this.transform.modelViewProjectionMatrix;
            let b = this.terrainFacilitator.dirty;
            b || (b = a ? !o.c9(f, g) : !o.ca(f, g)), b || (b = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), b && (o.cb(f, g), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(w, S) {
              const R = w.context, B = R.gl, U = w.transform, j = Si.unblended, X = new Or(B.LEQUAL, Or.ReadWrite, [0, 1]), q = S.sourceCache.getRenderableTiles(), Q = w.useProgram("terrainDepth");
              R.bindFramebuffer.set(S.getFramebuffer("depth").framebuffer), R.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), R.clear({ color: o.bf.transparent, depth: 1 });
              for (const ce of q) {
                const we = S.getTerrainMesh(ce.tileID), Ae = S.getTerrainData(ce.tileID), Se = U.getProjectionData({ overscaledTileID: ce.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), Me = { u_ele_delta: S.getMeshFrameDelta(U.zoom) };
                Q.draw(R, B.TRIANGLES, X, Qr.disabled, j, fi.backCCW, Me, Ae, Se, "terrain", we.vertexBuffer, we.indexBuffer, we.segments);
              }
              R.bindFramebuffer.set(null), R.viewport.set([0, 0, w.width, w.height]);
            }(this, this.style.map.terrain), function(w, S) {
              const R = w.context, B = R.gl, U = w.transform, j = Si.unblended, X = new Or(B.LEQUAL, Or.ReadWrite, [0, 1]), q = S.getCoordsTexture(), Q = S.sourceCache.getRenderableTiles(), ce = w.useProgram("terrainCoords");
              R.bindFramebuffer.set(S.getFramebuffer("coords").framebuffer), R.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), R.clear({ color: o.bf.transparent, depth: 1 }), S.coordsIndex = [];
              for (const we of Q) {
                const Ae = S.getTerrainMesh(we.tileID), Se = S.getTerrainData(we.tileID);
                R.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_2D, q.texture);
                const Me = { u_terrain_coords_id: (255 - S.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: S.getMeshFrameDelta(U.zoom) }, Ge = U.getProjectionData({ overscaledTileID: we.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                ce.draw(R, B.TRIANGLES, X, Qr.disabled, j, fi.backCCW, Me, Se, Ge, "terrain", Ae.vertexBuffer, Ae.indexBuffer, Ae.segments), S.coordsIndex.push(we.tileID.key);
              }
              R.bindFramebuffer.set(null), R.viewport.set([0, 0, w.width, w.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(a, f, g, b, w) {
            g.isHidden(this.transform.zoom) || (g.type === "background" || g.type === "custom" || (b || []).length) && (this.id = g.id, o.cc(g) ? function(S, R, B, U, j, X) {
              if (S.renderPass !== "translucent") return;
              const { isRenderingToTexture: q } = X, Q = Qr.disabled, ce = S.colorModeForRenderPass();
              (B._unevaluatedLayout.hasValue("text-variable-anchor") || B._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(we, Ae, Se, Me, Ge, Le, $e, Xe, Fe) {
                const Qe = Ae.transform, At = Ae.style.map.terrain, ft = Ge === "map", dt = Le === "map";
                for (const _t of we) {
                  const qt = Me.getTile(_t), Zt = qt.getBucket(Se);
                  if (!Zt || !Zt.text || !Zt.text.segments.get().length) continue;
                  const zt = o.an(Zt.textSizeData, Qe.zoom), pr = o.aC(qt, 1, Ae.transform.zoom), Vr = ci(ft, Ae.transform, pr), Ti = Se.layout.get("icon-text-fit") !== "none" && Zt.hasIconData();
                  if (zt) {
                    const $i = Math.pow(2, Qe.zoom - qt.tileID.overscaledZ), cn = At ? (hi, en) => At.getElevation(_t, hi, en) : null;
                    of(Zt, ft, dt, Fe, Qe, Vr, $i, zt, Ti, o.aD(Qe, qt, $e, Xe), _t.toUnwrapped(), cn);
                  }
                }
              }(U, S, B, R, B.layout.get("text-rotation-alignment"), B.layout.get("text-pitch-alignment"), B.paint.get("text-translate"), B.paint.get("text-translate-anchor"), j), B.paint.get("icon-opacity").constantOr(1) !== 0 && Nu(S, R, B, U, !1, B.paint.get("icon-translate"), B.paint.get("icon-translate-anchor"), B.layout.get("icon-rotation-alignment"), B.layout.get("icon-pitch-alignment"), B.layout.get("icon-keep-upright"), Q, ce, q), B.paint.get("text-opacity").constantOr(1) !== 0 && Nu(S, R, B, U, !0, B.paint.get("text-translate"), B.paint.get("text-translate-anchor"), B.layout.get("text-rotation-alignment"), B.layout.get("text-pitch-alignment"), B.layout.get("text-keep-upright"), Q, ce, q), R.map.showCollisionBoxes && (Hc(S, R, B, U, !0), Hc(S, R, B, U, !1));
            }(a, f, g, b, this.style.placement.variableOffsets, w) : o.cd(g) ? function(S, R, B, U, j) {
              if (S.renderPass !== "translucent") return;
              const { isRenderingToTexture: X } = j, q = B.paint.get("circle-opacity"), Q = B.paint.get("circle-stroke-width"), ce = B.paint.get("circle-stroke-opacity"), we = !B.layout.get("circle-sort-key").isConstant();
              if (q.constantOr(1) === 0 && (Q.constantOr(1) === 0 || ce.constantOr(1) === 0)) return;
              const Ae = S.context, Se = Ae.gl, Me = S.transform, Ge = S.getDepthModeForSublayer(0, Or.ReadOnly), Le = Qr.disabled, $e = S.colorModeForRenderPass(), Xe = [], Fe = Me.getCircleRadiusCorrection();
              for (let Qe = 0; Qe < U.length; Qe++) {
                const At = U[Qe], ft = R.getTile(At), dt = ft.getBucket(B);
                if (!dt) continue;
                const _t = B.paint.get("circle-translate"), qt = B.paint.get("circle-translate-anchor"), Zt = o.aD(Me, ft, _t, qt), zt = dt.programConfigurations.get(B.id), pr = S.useProgram("circle", zt), Vr = dt.layoutVertexBuffer, Ti = dt.indexBuffer, $i = S.style.map.terrain && S.style.map.terrain.getTerrainData(At), cn = { programConfiguration: zt, program: pr, layoutVertexBuffer: Vr, indexBuffer: Ti, uniformValues: ja(S, ft, B, Zt, Fe), terrainData: $i, projectionData: Me.getProjectionData({ overscaledTileID: At, applyGlobeMatrix: !X, applyTerrainMatrix: !0 }) };
                if (we) {
                  const hi = dt.segments.get();
                  for (const en of hi) Xe.push({ segments: new o.aM([en]), sortKey: en.sortKey, state: cn });
                } else Xe.push({ segments: dt.segments, sortKey: 0, state: cn });
              }
              we && Xe.sort((Qe, At) => Qe.sortKey - At.sortKey);
              for (const Qe of Xe) {
                const { programConfiguration: At, program: ft, layoutVertexBuffer: dt, indexBuffer: _t, uniformValues: qt, terrainData: Zt, projectionData: zt } = Qe.state;
                ft.draw(Ae, Se.TRIANGLES, Ge, Le, $e, fi.backCCW, qt, Zt, zt, B.id, dt, _t, Qe.segments, B.paint, S.transform.zoom, At);
              }
            }(a, f, g, b, w) : o.ce(g) ? function(S, R, B, U, j) {
              if (B.paint.get("heatmap-opacity") === 0) return;
              const X = S.context, { isRenderingToTexture: q, isRenderingGlobe: Q } = j;
              if (S.style.map.terrain) {
                for (const ce of U) {
                  const we = R.getTile(ce);
                  R.hasRenderableParent(ce) || (S.renderPass === "offscreen" ? gh(S, we, B, ce, Q) : S.renderPass === "translucent" && Wc(S, B, ce, q, Q));
                }
                X.viewport.set([0, 0, S.width, S.height]);
              } else S.renderPass === "offscreen" ? function(ce, we, Ae, Se) {
                const Me = ce.context, Ge = Me.gl, Le = ce.transform, $e = Qr.disabled, Xe = new Si([Ge.ONE, Ge.ONE], o.bf.transparent, [!0, !0, !0, !0]);
                (function(Fe, Qe, At) {
                  const ft = Fe.gl;
                  Fe.activeTexture.set(ft.TEXTURE1), Fe.viewport.set([0, 0, Qe.width / 4, Qe.height / 4]);
                  let dt = At.heatmapFbos.get(o.c3);
                  dt ? (ft.bindTexture(ft.TEXTURE_2D, dt.colorAttachment.get()), Fe.bindFramebuffer.set(dt.framebuffer)) : (dt = mh(Fe, Qe.width / 4, Qe.height / 4), At.heatmapFbos.set(o.c3, dt));
                })(Me, ce, Ae), Me.clear({ color: o.bf.transparent });
                for (let Fe = 0; Fe < Se.length; Fe++) {
                  const Qe = Se[Fe];
                  if (we.hasRenderableParent(Qe)) continue;
                  const At = we.getTile(Qe), ft = At.getBucket(Ae);
                  if (!ft) continue;
                  const dt = ft.programConfigurations.get(Ae.id), _t = ce.useProgram("heatmap", dt), qt = Le.getProjectionData({ overscaledTileID: Qe, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), Zt = Le.getCircleRadiusCorrection();
                  _t.draw(Me, Ge.TRIANGLES, Or.disabled, $e, Xe, fi.backCCW, $l(At, Le.zoom, Ae.paint.get("heatmap-intensity"), Zt), null, qt, Ae.id, ft.layoutVertexBuffer, ft.indexBuffer, ft.segments, Ae.paint, Le.zoom, dt);
                }
                Me.viewport.set([0, 0, ce.width, ce.height]);
              }(S, R, B, U) : S.renderPass === "translucent" && function(ce, we) {
                const Ae = ce.context, Se = Ae.gl;
                Ae.setColorMode(ce.colorModeForRenderPass());
                const Me = we.heatmapFbos.get(o.c3);
                Me && (Ae.activeTexture.set(Se.TEXTURE0), Se.bindTexture(Se.TEXTURE_2D, Me.colorAttachment.get()), Ae.activeTexture.set(Se.TEXTURE1), _h(Ae, we).bind(Se.LINEAR, Se.CLAMP_TO_EDGE), ce.useProgram("heatmapTexture").draw(Ae, Se.TRIANGLES, Or.disabled, Qr.disabled, ce.colorModeForRenderPass(), fi.disabled, na(ce, we, 0, 1), null, null, we.id, ce.viewportBuffer, ce.quadTriangleIndexBuffer, ce.viewportSegments, we.paint, ce.transform.zoom));
              }(S, B);
            }(a, f, g, b, w) : o.cf(g) ? function(S, R, B, U, j) {
              if (S.renderPass !== "translucent") return;
              const { isRenderingToTexture: X } = j, q = B.paint.get("line-opacity"), Q = B.paint.get("line-width");
              if (q.constantOr(1) === 0 || Q.constantOr(1) === 0) return;
              const ce = S.getDepthModeForSublayer(0, Or.ReadOnly), we = S.colorModeForRenderPass(), Ae = B.paint.get("line-dasharray"), Se = Ae.constantOr(1), Me = B.paint.get("line-pattern"), Ge = Me.constantOr(1), Le = B.paint.get("line-gradient"), $e = B.getCrossfadeParameters();
              let Xe;
              Xe = Ge ? "linePattern" : Se && Le ? "lineGradientSDF" : Se ? "lineSDF" : Le ? "lineGradient" : "line";
              const Fe = S.context, Qe = Fe.gl, At = S.transform;
              let ft = !0;
              for (const dt of U) {
                const _t = R.getTile(dt);
                if (Ge && !_t.patternsLoaded()) continue;
                const qt = _t.getBucket(B);
                if (!qt) continue;
                const Zt = qt.programConfigurations.get(B.id), zt = S.context.program.get(), pr = S.useProgram(Xe, Zt), Vr = ft || pr.program !== zt, Ti = S.style.map.terrain && S.style.map.terrain.getTerrainData(dt), $i = Me.constantOr(null), cn = Ae && Ae.constantOr(null);
                if ($i && _t.imageAtlas) {
                  const Cs = _t.imageAtlas, jn = Cs.patternPositions[$i.to.toString()], Jn = Cs.patternPositions[$i.from.toString()];
                  jn && Jn && Zt.setConstantPatternPositions(jn, Jn);
                } else if (cn) {
                  const Cs = B.layout.get("line-cap") === "round", jn = S.lineAtlas.getDash(cn.to, Cs), Jn = S.lineAtlas.getDash(cn.from, Cs);
                  Zt.setConstantDashPositions(jn, Jn);
                }
                const hi = At.getProjectionData({ overscaledTileID: dt, applyGlobeMatrix: !X, applyTerrainMatrix: !0 }), en = At.getPixelScale();
                let ms;
                Ge ? (ms = Uc(S, _t, B, en, $e), Uu(Fe, Qe, _t, Zt, $e)) : Se && Le ? (ms = kn(S, _t, B, en, $e, qt.lineClipsArray.length), bh(S, R, Fe, Qe, B, qt, dt, Zt, $e)) : Se ? (ms = Io(S, _t, B, en, $e), pd(S, Fe, Qe, Zt, Vr, $e)) : Le ? (ms = Va(S, _t, B, en, qt.lineClipsArray.length), yh(S, R, Fe, Qe, B, qt, dt)) : ms = Wn(S, _t, B, en);
                const Pn = S.stencilModeForClipping(dt);
                pr.draw(Fe, Qe.TRIANGLES, ce, Pn, we, fi.disabled, ms, Ti, hi, B.id, qt.layoutVertexBuffer, qt.indexBuffer, qt.segments, B.paint, S.transform.zoom, Zt, qt.layoutVertexBuffer2), ft = !1;
              }
            }(a, f, g, b, w) : o.cg(g) ? function(S, R, B, U, j) {
              const X = B.paint.get("fill-color"), q = B.paint.get("fill-opacity");
              if (q.constantOr(1) === 0) return;
              const { isRenderingToTexture: Q } = j, ce = S.colorModeForRenderPass(), we = B.paint.get("fill-pattern"), Ae = S.opaquePassEnabledForLayer() && !we.constantOr(1) && X.constantOr(o.bf.transparent).a === 1 && q.constantOr(0) === 1 ? "opaque" : "translucent";
              if (S.renderPass === Ae) {
                const Se = S.getDepthModeForSublayer(1, S.renderPass === "opaque" ? Or.ReadWrite : Or.ReadOnly);
                cf(S, R, B, U, Se, ce, !1, Q);
              }
              if (S.renderPass === "translucent" && B.paint.get("fill-antialias")) {
                const Se = S.getDepthModeForSublayer(B.getPaintProperty("fill-outline-color") ? 2 : 0, Or.ReadOnly);
                cf(S, R, B, U, Se, ce, !0, Q);
              }
            }(a, f, g, b, w) : o.ch(g) ? function(S, R, B, U, j) {
              const X = B.paint.get("fill-extrusion-opacity");
              if (X === 0) return;
              const { isRenderingToTexture: q } = j;
              if (S.renderPass === "translucent") {
                const Q = new Or(S.context.gl.LEQUAL, Or.ReadWrite, S.depthRangeFor3D);
                if (X !== 1 || B.paint.get("fill-extrusion-pattern").constantOr(1)) Xc(S, R, B, U, Q, Qr.disabled, Si.disabled, q), Xc(S, R, B, U, Q, S.stencilModeFor3D(), S.colorModeForRenderPass(), q);
                else {
                  const ce = S.colorModeForRenderPass();
                  Xc(S, R, B, U, Q, Qr.disabled, ce, q);
                }
              }
            }(a, f, g, b, w) : o.ci(g) ? function(S, R, B, U, j) {
              if (S.renderPass !== "offscreen" && S.renderPass !== "translucent") return;
              const { isRenderingToTexture: X } = j, q = S.context, Q = S.style.projection.useSubdivision, ce = S.getDepthModeForSublayer(0, Or.ReadOnly), we = S.colorModeForRenderPass();
              if (S.renderPass === "offscreen") (function(Ae, Se, Me, Ge, Le, $e, Xe) {
                const Fe = Ae.context, Qe = Fe.gl;
                for (const At of Me) {
                  const ft = Se.getTile(At), dt = ft.dem;
                  if (!dt || !dt.data || !ft.needsHillshadePrepare) continue;
                  const _t = dt.dim, qt = dt.stride, Zt = dt.getPixels();
                  if (Fe.activeTexture.set(Qe.TEXTURE1), Fe.pixelStoreUnpackPremultiplyAlpha.set(!1), ft.demTexture = ft.demTexture || Ae.getTileTexture(qt), ft.demTexture) {
                    const pr = ft.demTexture;
                    pr.update(Zt, { premultiply: !1 }), pr.bind(Qe.NEAREST, Qe.CLAMP_TO_EDGE);
                  } else ft.demTexture = new o.T(Fe, Zt, Qe.RGBA, { premultiply: !1 }), ft.demTexture.bind(Qe.NEAREST, Qe.CLAMP_TO_EDGE);
                  Fe.activeTexture.set(Qe.TEXTURE0);
                  let zt = ft.fbo;
                  if (!zt) {
                    const pr = new o.T(Fe, { width: _t, height: _t, data: null }, Qe.RGBA);
                    pr.bind(Qe.LINEAR, Qe.CLAMP_TO_EDGE), zt = ft.fbo = Fe.createFramebuffer(_t, _t, !0, !1), zt.colorAttachment.set(pr.texture);
                  }
                  Fe.bindFramebuffer.set(zt.framebuffer), Fe.viewport.set([0, 0, _t, _t]), Ae.useProgram("hillshadePrepare").draw(Fe, Qe.TRIANGLES, Le, $e, Xe, fi.disabled, zs(ft.tileID, dt), null, null, Ge.id, Ae.rasterBoundsBuffer, Ae.quadTriangleIndexBuffer, Ae.rasterBoundsSegments), ft.needsHillshadePrepare = !1;
                }
              })(S, R, U, B, ce, Qr.disabled, we), q.viewport.set([0, 0, S.width, S.height]);
              else if (S.renderPass === "translucent") if (Q) {
                const [Ae, Se, Me] = S.stencilConfigForOverlapTwoPass(U);
                zu(S, R, B, Me, Ae, ce, we, !1, X), zu(S, R, B, Me, Se, ce, we, !0, X);
              } else {
                const [Ae, Se] = S.getStencilConfigForOverlapAndUpdateStencilID(U);
                zu(S, R, B, Se, Ae, ce, we, !1, X);
              }
            }(a, f, g, b, w) : o.cj(g) ? function(S, R, B, U, j) {
              if (S.renderPass !== "translucent" || !U.length) return;
              const { isRenderingToTexture: X } = j, q = S.style.projection.useSubdivision, Q = S.getDepthModeForSublayer(0, Or.ReadOnly), ce = S.colorModeForRenderPass();
              if (q) {
                const [we, Ae, Se] = S.stencilConfigForOverlapTwoPass(U);
                ba(S, R, B, Se, we, Q, ce, !1, X), ba(S, R, B, Se, Ae, Q, ce, !0, X);
              } else {
                const [we, Ae] = S.getStencilConfigForOverlapAndUpdateStencilID(U);
                ba(S, R, B, Ae, we, Q, ce, !1, X);
              }
            }(a, f, g, b, w) : o.bK(g) ? function(S, R, B, U, j) {
              if (S.renderPass !== "translucent" || B.paint.get("raster-opacity") === 0 || !U.length) return;
              const { isRenderingToTexture: X } = j, q = R.getSource(), Q = S.style.projection.useSubdivision;
              if (q instanceof hr) Ci(S, R, B, U, null, !1, !1, q.tileCoords, q.flippedWindingOrder, X);
              else if (Q) {
                const [ce, we, Ae] = S.stencilConfigForOverlapTwoPass(U);
                Ci(S, R, B, Ae, ce, !1, !0, io, !1, X), Ci(S, R, B, Ae, we, !0, !0, io, !1, X);
              } else {
                const [ce, we] = S.getStencilConfigForOverlapAndUpdateStencilID(U);
                Ci(S, R, B, we, ce, !1, !0, io, !1, X);
              }
            }(a, f, g, b, w) : o.ck(g) ? function(S, R, B, U, j) {
              const X = B.paint.get("background-color"), q = B.paint.get("background-opacity");
              if (q === 0) return;
              const { isRenderingToTexture: Q } = j, ce = S.context, we = ce.gl, Ae = S.style.projection, Se = S.transform, Me = Se.tileSize, Ge = B.paint.get("background-pattern");
              if (S.isPatternMissing(Ge)) return;
              const Le = !Ge && X.a === 1 && q === 1 && S.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (S.renderPass !== Le) return;
              const $e = Qr.disabled, Xe = S.getDepthModeForSublayer(0, Le === "opaque" ? Or.ReadWrite : Or.ReadOnly), Fe = S.colorModeForRenderPass(), Qe = S.useProgram(Ge ? "backgroundPattern" : "background"), At = U || fr(Se, { tileSize: Me, terrain: S.style.map.terrain });
              Ge && (ce.activeTexture.set(we.TEXTURE0), S.imageManager.bind(S.context));
              const ft = B.getCrossfadeParameters();
              for (const dt of At) {
                const _t = Se.getProjectionData({ overscaledTileID: dt, applyGlobeMatrix: !Q, applyTerrainMatrix: !0 }), qt = Ge ? _a(q, S, Ge, { tileID: dt, tileSize: Me }, ft) : xl(q, X), Zt = S.style.map.terrain && S.style.map.terrain.getTerrainData(dt), zt = Ae.getMeshFromTileID(ce, dt.canonical, !1, !0, "raster");
                Qe.draw(ce, we.TRIANGLES, Xe, $e, Fe, fi.backCCW, qt, Zt, _t, B.id, zt.vertexBuffer, zt.indexBuffer, zt.segments);
              }
            }(a, 0, g, b, w) : o.cl(g) && function(S, R, B, U) {
              const { isRenderingGlobe: j } = U, X = S.context, q = B.implementation, Q = S.style.projection, ce = S.transform, we = ce.getProjectionDataForCustomLayer(j), Ae = { farZ: ce.farZ, nearZ: ce.nearZ, fov: ce.fov * Math.PI / 180, modelViewProjectionMatrix: ce.modelViewProjectionMatrix, projectionMatrix: ce.projectionMatrix, shaderData: { variantName: Q.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${Q.shaderPreludeCode.vertexSource}`, define: Q.shaderDefine }, defaultProjectionData: we }, Se = q.renderingMode ? q.renderingMode : "2d";
              if (S.renderPass === "offscreen") {
                const Me = q.prerender;
                Me && (S.setCustomLayerDefaults(), X.setColorMode(S.colorModeForRenderPass()), Me.call(q, X.gl, Ae), X.setDirty(), S.setBaseState());
              } else if (S.renderPass === "translucent") {
                S.setCustomLayerDefaults(), X.setColorMode(S.colorModeForRenderPass()), X.setStencilMode(Qr.disabled);
                const Me = Se === "3d" ? S.getDepthModeFor3D() : S.getDepthModeForSublayer(0, Or.ReadOnly);
                X.setDepthMode(Me), q.render(X.gl, Ae), X.setDirty(), S.setBaseState(), X.bindFramebuffer.set(null);
              }
            }(a, 0, g, w));
          }
          saveTileTexture(a) {
            const f = this._tileTextures[a.size[0]];
            f ? f.push(a) : this._tileTextures[a.size[0]] = [a];
          }
          getTileTexture(a) {
            const f = this._tileTextures[a];
            return f && f.length > 0 ? f.pop() : null;
          }
          isPatternMissing(a) {
            if (!a) return !1;
            if (!a.from || !a.to) return !0;
            const f = this.imageManager.getPattern(a.from.toString()), g = this.imageManager.getPattern(a.to.toString());
            return !f || !g;
          }
          useProgram(a, f, g = !1, b = []) {
            this.cache = this.cache || {};
            const w = !!this.style.map.terrain, S = this.style.projection, R = g ? So.projectionMercator : S.shaderPreludeCode, B = g ? Oc : S.shaderDefine, U = a + (f ? f.cacheKey : "") + `/${g ? hl : S.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (w ? "/terrain" : "") + (b ? `/${b.join("/")}` : "");
            return this.cache[U] || (this.cache[U] = new Ua(this.context, So[a], f, Xl[a], this._showOverdrawInspector, w, R, B, b)), this.cache[U];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const a = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(a.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: a, drawingBufferHeight: f } = this.context.gl;
            return this.width !== a || this.height !== f;
          }
        }
        function tc(v, a) {
          let f, g = !1, b = null, w = null;
          const S = () => {
            b = null, g && (v.apply(w, f), b = setTimeout(S, a), g = !1);
          };
          return (...R) => (g = !0, w = this, f = R, b || S(), b);
        }
        class xa {
          constructor(a) {
            this._getCurrentHash = () => {
              const f = window.location.hash.replace("#", "");
              if (this._hashName) {
                let g;
                return f.split("&").map((b) => b.split("=")).forEach((b) => {
                  b[0] === this._hashName && (g = b);
                }), (g && g[1] || "").split("/");
              }
              return f.split("/");
            }, this._onHashChange = () => {
              const f = this._getCurrentHash();
              if (!this._isValidHash(f)) return !1;
              const g = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(f[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+f[2], +f[1]], zoom: +f[0], bearing: g, pitch: +(f[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const f = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, f);
            }, this._removeHash = () => {
              const f = this._getCurrentHash();
              if (f.length === 0) return;
              const g = f.join("/");
              let b = g;
              b.split("&").length > 0 && (b = b.split("&")[0]), this._hashName && (b = `${this._hashName}=${g}`);
              let w = window.location.hash.replace(b, "");
              w.startsWith("#&") ? w = w.slice(0, 1) + w.slice(2) : w === "#" && (w = "");
              let S = window.location.href.replace(/(#.+)?$/, w);
              S = S.replace("&&", "&"), window.history.replaceState(window.history.state, null, S);
            }, this._updateHash = tc(this._updateHashUnthrottled, 300), this._hashName = a && encodeURIComponent(a);
          }
          addTo(a) {
            return this._map = a, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(a) {
            const f = this._map.getCenter(), g = Math.round(100 * this._map.getZoom()) / 100, b = Math.ceil((g * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), w = Math.pow(10, b), S = Math.round(f.lng * w) / w, R = Math.round(f.lat * w) / w, B = this._map.getBearing(), U = this._map.getPitch();
            let j = "";
            if (j += a ? `/${S}/${R}/${g}` : `${g}/${R}/${S}`, (B || U) && (j += "/" + Math.round(10 * B) / 10), U && (j += `/${Math.round(U)}`), this._hashName) {
              const X = this._hashName;
              let q = !1;
              const Q = window.location.hash.slice(1).split("&").map((ce) => {
                const we = ce.split("=")[0];
                return we === X ? (q = !0, `${we}=${j}`) : ce;
              }).filter((ce) => ce);
              return q || Q.push(`${X}=${j}`), `#${Q.join("&")}`;
            }
            return `#${j}`;
          }
          _isValidHash(a) {
            if (a.length < 3 || a.some(isNaN)) return !1;
            try {
              new o.S(+a[2], +a[1]);
            } catch {
              return !1;
            }
            const f = +a[0], g = +(a[3] || 0), b = +(a[4] || 0);
            return f >= this._map.getMinZoom() && f <= this._map.getMaxZoom() && g >= -180 && g <= 180 && b >= this._map.getMinPitch() && b <= this._map.getMaxPitch();
          }
        }
        const Jc = { linearity: 0.3, easing: o.cm(0, 0, 0.3, 1) }, ff = o.e({ deceleration: 2500, maxSpeed: 1400 }, Jc), md = o.e({ deceleration: 20, maxSpeed: 1400 }, Jc), _d = o.e({ deceleration: 1e3, maxSpeed: 360 }, Jc), yd = o.e({ deceleration: 1e3, maxSpeed: 90 }, Jc), bd = o.e({ deceleration: 1e3, maxSpeed: 360 }, Jc);
        class vd {
          constructor(a) {
            this._map = a, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(a) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: D(), settings: a });
          }
          _drainInertiaBuffer() {
            const a = this._inertiaBuffer, f = D();
            for (; a.length > 0 && f - a[0].time > 160; ) a.shift();
          }
          _onMoveEnd(a) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const f = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new o.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: w } of this._inertiaBuffer) f.zoom += w.zoomDelta || 0, f.bearing += w.bearingDelta || 0, f.pitch += w.pitchDelta || 0, f.roll += w.rollDelta || 0, w.panDelta && f.pan._add(w.panDelta), w.around && (f.around = w.around), w.pinchAround && (f.pinchAround = w.pinchAround);
            const g = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, b = {};
            if (f.pan.mag()) {
              const w = Ha(f.pan.mag(), g, o.e({}, ff, a || {})), S = f.pan.mult(w.amount / f.pan.mag()), R = this._map.cameraHelper.handlePanInertia(S, this._map.transform);
              b.center = R.easingCenter, b.offset = R.easingOffset, Kc(b, w);
            }
            if (f.zoom) {
              const w = Ha(f.zoom, g, md);
              b.zoom = this._map.transform.zoom + w.amount, Kc(b, w);
            }
            if (f.bearing) {
              const w = Ha(f.bearing, g, _d);
              b.bearing = this._map.transform.bearing + o.ae(w.amount, -179, 179), Kc(b, w);
            }
            if (f.pitch) {
              const w = Ha(f.pitch, g, yd);
              b.pitch = this._map.transform.pitch + w.amount, Kc(b, w);
            }
            if (f.roll) {
              const w = Ha(f.roll, g, bd);
              b.roll = this._map.transform.roll + o.ae(w.amount, -179, 179), Kc(b, w);
            }
            if (b.zoom || b.bearing) {
              const w = f.pinchAround === void 0 ? f.around : f.pinchAround;
              b.around = w ? this._map.unproject(w) : this._map.getCenter();
            }
            return this.clear(), o.e(b, { noMoveStart: !0 });
          }
        }
        function Kc(v, a) {
          (!v.duration || v.duration < a.duration) && (v.duration = a.duration, v.easing = a.easing);
        }
        function Ha(v, a, f) {
          const { maxSpeed: g, linearity: b, deceleration: w } = f, S = o.ae(v * b / (a / 1e3), -g, g), R = Math.abs(S) / (w * b);
          return { easing: f.easing, duration: 1e3 * R, amount: S * (R / 2) };
        }
        class ds extends o.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, f, g, b = {}) {
            g = g instanceof MouseEvent ? g : new MouseEvent(a, g);
            const w = k.mousePos(f.getCanvas(), g), S = f.unproject(w);
            super(a, o.e({ point: w, lngLat: S, originalEvent: g }, b)), this._defaultPrevented = !1, this.target = f;
          }
        }
        class Es extends o.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, f, g) {
            const b = a === "touchend" ? g.changedTouches : g.touches, w = k.touchPos(f.getCanvasContainer(), b), S = w.map((B) => f.unproject(B)), R = w.reduce((B, U, j, X) => B.add(U.div(X.length)), new o.P(0, 0));
            super(a, { points: w, point: R, lngLats: S, lngLat: f.unproject(R), originalEvent: g }), this._defaultPrevented = !1;
          }
        }
        class Mo extends o.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, f, g) {
            super(a, { originalEvent: g }), this._defaultPrevented = !1;
          }
        }
        class df {
          constructor(a, f) {
            this._map = a, this._clickTolerance = f.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(a) {
            return this._firePreventable(new Mo(a.type, this._map, a));
          }
          mousedown(a, f) {
            return this._mousedownPos = f, this._firePreventable(new ds(a.type, this._map, a));
          }
          mouseup(a) {
            this._map.fire(new ds(a.type, this._map, a));
          }
          click(a, f) {
            this._mousedownPos && this._mousedownPos.dist(f) >= this._clickTolerance || this._map.fire(new ds(a.type, this._map, a));
          }
          dblclick(a) {
            return this._firePreventable(new ds(a.type, this._map, a));
          }
          mouseover(a) {
            this._map.fire(new ds(a.type, this._map, a));
          }
          mouseout(a) {
            this._map.fire(new ds(a.type, this._map, a));
          }
          touchstart(a) {
            return this._firePreventable(new Es(a.type, this._map, a));
          }
          touchmove(a) {
            this._map.fire(new Es(a.type, this._map, a));
          }
          touchend(a) {
            this._map.fire(new Es(a.type, this._map, a));
          }
          touchcancel(a) {
            this._map.fire(new Es(a.type, this._map, a));
          }
          _firePreventable(a) {
            if (this._map.fire(a), a.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class C {
          constructor(a) {
            this._map = a;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(a) {
            this._map.fire(new ds(a.type, this._map, a));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ds("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(a) {
            this._delayContextMenu ? this._contextMenuEvent = a : this._ignoreContextMenu || this._map.fire(new ds(a.type, this._map, a)), this._map.listens("contextmenu") && a.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class L {
          constructor(a) {
            this._map = a;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(a) {
            return this.transform.screenPointToLocation(o.P.convert(a), this._map.terrain);
          }
        }
        class z {
          constructor(a, f) {
            this._map = a, this._tr = new L(a), this._el = a.getCanvasContainer(), this._container = a.getContainer(), this._clickTolerance = f.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(a, f) {
            this.isEnabled() && a.shiftKey && a.button === 0 && (k.disableDrag(), this._startPos = this._lastPos = f, this._active = !0);
          }
          mousemoveWindow(a, f) {
            if (!this._active) return;
            const g = f;
            if (this._lastPos.equals(g) || !this._box && g.dist(this._startPos) < this._clickTolerance) return;
            const b = this._startPos;
            this._lastPos = g, this._box || (this._box = k.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", a));
            const w = Math.min(b.x, g.x), S = Math.max(b.x, g.x), R = Math.min(b.y, g.y), B = Math.max(b.y, g.y);
            k.setTransform(this._box, `translate(${w}px,${R}px)`), this._box.style.width = S - w + "px", this._box.style.height = B - R + "px";
          }
          mouseupWindow(a, f) {
            if (!this._active || a.button !== 0) return;
            const g = this._startPos, b = f;
            if (this.reset(), k.suppressClick(), g.x !== b.x || g.y !== b.y) return this._map.fire(new o.l("boxzoomend", { originalEvent: a })), { cameraAnimation: (w) => w.fitScreenCoordinates(g, b, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", a);
          }
          keydown(a) {
            this._active && a.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", a));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (k.remove(this._box), this._box = null), k.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(a, f) {
            return this._map.fire(new o.l(a, { originalEvent: f }));
          }
        }
        function W(v, a) {
          if (v.length !== a.length) throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${a.length}`);
          const f = {};
          for (let g = 0; g < v.length; g++) f[v[g].identifier] = a[g];
          return f;
        }
        class ae {
          constructor(a) {
            this.reset(), this.numTouches = a.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(a, f, g) {
            (this.centroid || g.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = a.timeStamp), g.length === this.numTouches && (this.centroid = function(b) {
              const w = new o.P(0, 0);
              for (const S of b) w._add(S);
              return w.div(b.length);
            }(f), this.touches = W(g, f)));
          }
          touchmove(a, f, g) {
            if (this.aborted || !this.centroid) return;
            const b = W(g, f);
            for (const w in this.touches) {
              const S = b[w];
              (!S || S.dist(this.touches[w]) > 30) && (this.aborted = !0);
            }
          }
          touchend(a, f, g) {
            if ((!this.centroid || a.timeStamp - this.startTime > 500) && (this.aborted = !0), g.length === 0) {
              const b = !this.aborted && this.centroid;
              if (this.reset(), b) return b;
            }
          }
        }
        class he {
          constructor(a) {
            this.singleTap = new ae(a), this.numTaps = a.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(a, f, g) {
            this.singleTap.touchstart(a, f, g);
          }
          touchmove(a, f, g) {
            this.singleTap.touchmove(a, f, g);
          }
          touchend(a, f, g) {
            const b = this.singleTap.touchend(a, f, g);
            if (b) {
              const w = a.timeStamp - this.lastTime < 500, S = !this.lastTap || this.lastTap.dist(b) < 30;
              if (w && S || this.reset(), this.count++, this.lastTime = a.timeStamp, this.lastTap = b, this.count === this.numTaps) return this.reset(), b;
            }
          }
        }
        class ge {
          constructor(a) {
            this._tr = new L(a), this._zoomIn = new he({ numTouches: 1, numTaps: 2 }), this._zoomOut = new he({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(a, f, g) {
            this._zoomIn.touchstart(a, f, g), this._zoomOut.touchstart(a, f, g);
          }
          touchmove(a, f, g) {
            this._zoomIn.touchmove(a, f, g), this._zoomOut.touchmove(a, f, g);
          }
          touchend(a, f, g) {
            const b = this._zoomIn.touchend(a, f, g), w = this._zoomOut.touchend(a, f, g), S = this._tr;
            return b ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (R) => R.easeTo({ duration: 300, zoom: S.zoom + 1, around: S.unproject(b) }, { originalEvent: a }) }) : w ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (R) => R.easeTo({ duration: 300, zoom: S.zoom - 1, around: S.unproject(w) }, { originalEvent: a }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ye {
          constructor(a) {
            this._enabled = !!a.enable, this._moveStateManager = a.moveStateManager, this._clickTolerance = a.clickTolerance || 1, this._moveFunction = a.move, this._activateOnStart = !!a.activateOnStart, a.assignEvents(this), this.reset();
          }
          reset(a) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(a);
          }
          _move(...a) {
            const f = this._moveFunction(...a);
            if (f.bearingDelta || f.pitchDelta || f.rollDelta || f.around || f.panDelta) return this._active = !0, f;
          }
          dragStart(a, f) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(a) && (this._moveStateManager.startMove(a), this._lastPoint = Array.isArray(f) ? f[0] : f, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(a, f) {
            if (!this.isEnabled()) return;
            const g = this._lastPoint;
            if (!g) return;
            if (a.preventDefault(), !this._moveStateManager.isValidMoveEvent(a)) return void this.reset(a);
            const b = Array.isArray(f) ? f[0] : f;
            return !this._moved && b.dist(g) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = b, this._move(g, b));
          }
          dragEnd(a) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(a) && (this._moved && k.suppressClick(), this.reset(a));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const xe = 0, me = 2, et = { [xe]: 1, [me]: 2 };
        class bt {
          constructor(a) {
            this._correctEvent = a.checkCorrectEvent;
          }
          startMove(a) {
            const f = k.mouseButton(a);
            this._eventButton = f;
          }
          endMove(a) {
            delete this._eventButton;
          }
          isValidStartEvent(a) {
            return this._correctEvent(a);
          }
          isValidMoveEvent(a) {
            return !function(f, g) {
              const b = et[g];
              return f.buttons === void 0 || (f.buttons & b) !== b;
            }(a, this._eventButton);
          }
          isValidEndEvent(a) {
            return k.mouseButton(a) === this._eventButton;
          }
        }
        class ke {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(a) {
            return a.targetTouches.length === 1;
          }
          _isSameTouchEvent(a) {
            return a.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(a) {
            this._firstTouch = a.targetTouches[0].identifier;
          }
          endMove(a) {
            delete this._firstTouch;
          }
          isValidStartEvent(a) {
            return this._isOneFingerTouch(a);
          }
          isValidMoveEvent(a) {
            return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
          }
          isValidEndEvent(a) {
            return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
          }
        }
        class st {
          constructor(a = new bt({ checkCorrectEvent: () => !0 }), f = new ke()) {
            this.mouseMoveStateManager = a, this.oneFingerTouchMoveStateManager = f;
          }
          _executeRelevantHandler(a, f, g) {
            return a instanceof MouseEvent ? f(a) : typeof TouchEvent < "u" && a instanceof TouchEvent ? g(a) : void 0;
          }
          startMove(a) {
            this._executeRelevantHandler(a, (f) => this.mouseMoveStateManager.startMove(f), (f) => this.oneFingerTouchMoveStateManager.startMove(f));
          }
          endMove(a) {
            this._executeRelevantHandler(a, (f) => this.mouseMoveStateManager.endMove(f), (f) => this.oneFingerTouchMoveStateManager.endMove(f));
          }
          isValidStartEvent(a) {
            return this._executeRelevantHandler(a, (f) => this.mouseMoveStateManager.isValidStartEvent(f), (f) => this.oneFingerTouchMoveStateManager.isValidStartEvent(f));
          }
          isValidMoveEvent(a) {
            return this._executeRelevantHandler(a, (f) => this.mouseMoveStateManager.isValidMoveEvent(f), (f) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(f));
          }
          isValidEndEvent(a) {
            return this._executeRelevantHandler(a, (f) => this.mouseMoveStateManager.isValidEndEvent(f), (f) => this.oneFingerTouchMoveStateManager.isValidEndEvent(f));
          }
        }
        const ht = (v) => {
          v.mousedown = v.dragStart, v.mousemoveWindow = v.dragMove, v.mouseup = v.dragEnd, v.contextmenu = (a) => {
            a.preventDefault();
          };
        };
        class kt {
          constructor(a, f) {
            this._clickTolerance = a.clickTolerance || 1, this._map = f, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new o.P(0, 0);
          }
          _shouldBePrevented(a) {
            return a < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(a, f, g) {
            return this._calculateTransform(a, f, g);
          }
          touchmove(a, f, g) {
            if (this._active) {
              if (!this._shouldBePrevented(g.length)) return a.preventDefault(), this._calculateTransform(a, f, g);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", a);
            }
          }
          touchend(a, f, g) {
            this._calculateTransform(a, f, g), this._active && this._shouldBePrevented(g.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(a, f, g) {
            g.length > 0 && (this._active = !0);
            const b = W(g, f), w = new o.P(0, 0), S = new o.P(0, 0);
            let R = 0;
            for (const U in b) {
              const j = b[U], X = this._touches[U];
              X && (w._add(j), S._add(j.sub(X)), R++, b[U] = j);
            }
            if (this._touches = b, this._shouldBePrevented(R) || !S.mag()) return;
            const B = S.div(R);
            return this._sum._add(B), this._sum.mag() < this._clickTolerance ? void 0 : { around: w.div(R), panDelta: B };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class tt {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(a, f, g) {
            this._firstTwoTouches || g.length < 2 || (this._firstTwoTouches = [g[0].identifier, g[1].identifier], this._start([f[0], f[1]]));
          }
          touchmove(a, f, g) {
            if (!this._firstTwoTouches) return;
            a.preventDefault();
            const [b, w] = this._firstTwoTouches, S = Ot(g, f, b), R = Ot(g, f, w);
            if (!S || !R) return;
            const B = this._aroundCenter ? null : S.add(R).div(2);
            return this._move([S, R], B, a);
          }
          touchend(a, f, g) {
            if (!this._firstTwoTouches) return;
            const [b, w] = this._firstTwoTouches, S = Ot(g, f, b), R = Ot(g, f, w);
            S && R || (this._active && k.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(a) {
            this._enabled = !0, this._aroundCenter = !!a && a.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Ot(v, a, f) {
          for (let g = 0; g < v.length; g++) if (v[g].identifier === f) return a[g];
        }
        function jt(v, a) {
          return Math.log(v / a) / Math.LN2;
        }
        class Kt extends tt {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(a) {
            this._startDistance = this._distance = a[0].dist(a[1]);
          }
          _move(a, f) {
            const g = this._distance;
            if (this._distance = a[0].dist(a[1]), this._active || !(Math.abs(jt(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: jt(this._distance, g), pinchAround: f };
          }
        }
        function Wt(v, a) {
          return 180 * v.angleWith(a) / Math.PI;
        }
        class Br extends tt {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(a) {
            this._startVector = this._vector = a[0].sub(a[1]), this._minDiameter = a[0].dist(a[1]);
          }
          _move(a, f, g) {
            const b = this._vector;
            if (this._vector = a[0].sub(a[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: Wt(this._vector, b), pinchAround: f };
          }
          _isBelowThreshold(a) {
            this._minDiameter = Math.min(this._minDiameter, a.mag());
            const f = 25 / (Math.PI * this._minDiameter) * 360, g = Wt(a, this._startVector);
            return Math.abs(g) < f;
          }
        }
        function yr(v) {
          return Math.abs(v.y) > Math.abs(v.x);
        }
        class si extends tt {
          constructor(a) {
            super(), this._currentTouchCount = 0, this._map = a;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(a, f, g) {
            super.touchstart(a, f, g), this._currentTouchCount = g.length;
          }
          _start(a) {
            this._lastPoints = a, yr(a[0].sub(a[1])) && (this._valid = !1);
          }
          _move(a, f, g) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const b = a[0].sub(this._lastPoints[0]), w = a[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(b, w, g.timeStamp), this._valid ? (this._lastPoints = a, this._active = !0, { pitchDelta: (b.y + w.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(a, f, g) {
            if (this._valid !== void 0) return this._valid;
            const b = a.mag() >= 2, w = f.mag() >= 2;
            if (!b && !w) return;
            if (!b || !w) return this._firstMove === void 0 && (this._firstMove = g), g - this._firstMove < 100 && void 0;
            const S = a.y > 0 == f.y > 0;
            return yr(a) && yr(f) && S;
          }
        }
        const Tr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class xi {
          constructor(a) {
            this._tr = new L(a);
            const f = Tr;
            this._panStep = f.panStep, this._bearingStep = f.bearingStep, this._pitchStep = f.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(a) {
            if (a.altKey || a.ctrlKey || a.metaKey) return;
            let f = 0, g = 0, b = 0, w = 0, S = 0;
            switch (a.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                f = 1;
                break;
              case 189:
              case 109:
              case 173:
                f = -1;
                break;
              case 37:
                a.shiftKey ? g = -1 : (a.preventDefault(), w = -1);
                break;
              case 39:
                a.shiftKey ? g = 1 : (a.preventDefault(), w = 1);
                break;
              case 38:
                a.shiftKey ? b = 1 : (a.preventDefault(), S = -1);
                break;
              case 40:
                a.shiftKey ? b = -1 : (a.preventDefault(), S = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (g = 0, b = 0), { cameraAnimation: (R) => {
              const B = this._tr;
              R.easeTo({ duration: 300, easeId: "keyboardHandler", easing: zn, zoom: f ? Math.round(B.zoom) + f * (a.shiftKey ? 2 : 1) : B.zoom, bearing: B.bearing + g * this._bearingStep, pitch: B.pitch + b * this._pitchStep, offset: [-w * this._panStep, -S * this._panStep], center: B.center }, { originalEvent: a });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function zn(v) {
          return v * (2 - v);
        }
        const ui = 4.000244140625, Pr = 1 / 450;
        class lr {
          constructor(a, f) {
            this._onTimeout = (g) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(g);
            }, this._map = a, this._tr = new L(a), this._triggerRenderFrame = f, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Pr;
          }
          setZoomRate(a) {
            this._defaultZoomRate = a;
          }
          setWheelZoomRate(a) {
            this._wheelZoomRate = a;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(a) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!a && a.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(a) {
            return !!this._map.cooperativeGestures.isEnabled() && !(a.ctrlKey || this._map.cooperativeGestures.isBypassed(a));
          }
          wheel(a) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(a)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", a);
            let f = a.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * a.deltaY : a.deltaY;
            const g = D(), b = g - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = g, f !== 0 && f % ui == 0 ? this._type = "wheel" : f !== 0 && Math.abs(f) < 4 ? this._type = "trackpad" : b > 400 ? (this._type = null, this._lastValue = f, this._timeout = setTimeout(this._onTimeout, 40, a)) : this._type || (this._type = Math.abs(b * f) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, f += this._lastValue)), a.shiftKey && f && (f /= 4), this._type && (this._lastWheelEvent = a, this._delta -= f, this._active || this._start(a)), a.preventDefault();
          }
          _start(a) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const f = k.mousePos(this._map.getCanvas(), a), g = this._tr;
            this._aroundPoint = this._aroundCenter ? g.transform.locationToScreenPoint(o.S.convert(g.center)) : f, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const a = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const R = a.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += R), typeof this._targetZoom == "number" && (this._targetZoom += R);
            }
            if (this._delta !== 0) {
              const R = this._type === "wheel" && Math.abs(this._delta) > ui ? this._wheelZoomRate : this._defaultZoomRate;
              let B = 2 / (1 + Math.exp(-Math.abs(this._delta * R)));
              this._delta < 0 && B !== 0 && (B = 1 / B);
              const U = typeof this._targetZoom != "number" ? a.scale : o.ah(this._targetZoom);
              this._targetZoom = a.constrain(a.getCameraLngLat(), o.ak(U * B)).zoom, this._type === "wheel" && (this._startZoom = a.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const f = typeof this._targetZoom != "number" ? a.zoom : this._targetZoom, g = this._startZoom, b = this._easing;
            let w, S = !1;
            if (this._type === "wheel" && g && b) {
              const R = D() - this._lastWheelEventTime, B = Math.min((R + 5) / 200, 1), U = b(B);
              w = o.C.number(g, f, U), B < 1 ? this._frameId || (this._frameId = !0) : S = !0;
            } else w = f, S = !0;
            return this._active = !0, S && (this._active = !1, this._finishTimeout = setTimeout(() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }, 200)), this._lastExpectedZoom = w, { noInertia: !0, needsRenderFrame: !S, zoomDelta: w - a.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(a) {
            let f = o.co;
            if (this._prevEase) {
              const g = this._prevEase, b = (D() - g.start) / g.duration, w = g.easing(b + 0.01) - g.easing(b), S = 0.27 / Math.sqrt(w * w + 1e-4) * 0.01, R = Math.sqrt(0.0729 - S * S);
              f = o.cm(S, R, 0.25, 1);
            }
            return this._prevEase = { start: D(), duration: a, easing: f }, f;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Wr {
          constructor(a, f) {
            this._clickZoom = a, this._tapZoom = f;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class oi {
          constructor(a) {
            this._tr = new L(a), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(a, f) {
            return a.preventDefault(), { cameraAnimation: (g) => {
              g.easeTo({ duration: 300, zoom: this._tr.zoom + (a.shiftKey ? -1 : 1), around: this._tr.unproject(f) }, { originalEvent: a });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class _i {
          constructor() {
            this._tap = new he({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(a, f, g) {
            if (!this._swipePoint) if (this._tapTime) {
              const b = f[0], w = a.timeStamp - this._tapTime < 500, S = this._tapPoint.dist(b) < 30;
              w && S ? g.length > 0 && (this._swipePoint = b, this._swipeTouch = g[0].identifier) : this.reset();
            } else this._tap.touchstart(a, f, g);
          }
          touchmove(a, f, g) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (g[0].identifier !== this._swipeTouch) return;
                const b = f[0], w = b.y - this._swipePoint.y;
                return this._swipePoint = b, a.preventDefault(), this._active = !0, { zoomDelta: w / 128 };
              }
            } else this._tap.touchmove(a, f, g);
          }
          touchend(a, f, g) {
            if (this._tapTime) this._swipePoint && g.length === 0 && this.reset();
            else {
              const b = this._tap.touchend(a, f, g);
              b && (this._tapTime = a.timeStamp, this._tapPoint = b);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Vi {
          constructor(a, f, g) {
            this._el = a, this._mousePan = f, this._touchPan = g;
          }
          enable(a) {
            this._inertiaOptions = a || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Xn {
          constructor(a, f, g, b) {
            this._pitchWithRotate = a.pitchWithRotate, this._rollEnabled = a.rollEnabled, this._mouseRotate = f, this._mousePitch = g, this._mouseRoll = b;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class ps {
          constructor(a, f, g, b) {
            this._el = a, this._touchZoom = f, this._touchRotate = g, this._tapDragZoom = b, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(a) {
            this._touchZoom.enable(a), this._rotationDisabled || this._touchRotate.enable(a), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class fn {
          constructor(a, f) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = a, this._options = f, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const a = this._map.getCanvasContainer();
            a.classList.add("maplibregl-cooperative-gestures"), this._container = k.create("div", "maplibregl-cooperative-gesture-screen", a);
            let f = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (f = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const g = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), b = document.createElement("div");
            b.className = "maplibregl-desktop-message", b.textContent = f, this._container.appendChild(b);
            const w = document.createElement("div");
            w.className = "maplibregl-mobile-message", w.textContent = g, this._container.appendChild(w), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (k.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(a) {
            return a[this._bypassKey];
          }
          notifyGestureBlocked(a, f) {
            this._enabled && (this._map.fire(new o.l("cooperativegestureprevented", { gestureType: a, originalEvent: f })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const Zn = (v) => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
        class dn extends o.l {
        }
        function pn(v) {
          return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta;
        }
        class Qt {
          constructor(a, f) {
            this.handleWindowEvent = (b) => {
              this.handleEvent(b, `${b.type}Window`);
            }, this.handleEvent = (b, w) => {
              if (b.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const S = b.type === "renderFrame" ? void 0 : b, R = { needsRenderFrame: !1 }, B = {}, U = {};
              for (const { handlerName: q, handler: Q, allowed: ce } of this._handlers) {
                if (!Q.isEnabled()) continue;
                let we;
                if (this._blockedByActive(U, ce, q)) Q.reset();
                else if (Q[w || b.type]) {
                  if (o.cp(b, w || b.type)) {
                    const Ae = k.mousePos(this._map.getCanvas(), b);
                    we = Q[w || b.type](b, Ae);
                  } else if (o.cq(b, w || b.type)) {
                    const Ae = this._getMapTouches(b.touches), Se = k.touchPos(this._map.getCanvas(), Ae);
                    we = Q[w || b.type](b, Se, Ae);
                  } else o.cr(w || b.type) || (we = Q[w || b.type](b));
                  this.mergeHandlerResult(R, B, we, q, S), we && we.needsRenderFrame && this._triggerRenderFrame();
                }
                (we || Q.isActive()) && (U[q] = Q);
              }
              const j = {};
              for (const q in this._previousActiveHandlers) U[q] || (j[q] = S);
              this._previousActiveHandlers = U, (Object.keys(j).length || pn(R)) && (this._changes.push([R, B, j]), this._triggerRenderFrame()), (Object.keys(U).length || pn(R)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: X } = R;
              X && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], X(this._map));
            }, this._map = a, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new vd(a), this._bearingSnap = f.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(f);
            const g = this._el;
            this._listeners = [[g, "touchstart", { passive: !0 }], [g, "touchmove", { passive: !1 }], [g, "touchend", void 0], [g, "touchcancel", void 0], [g, "mousedown", void 0], [g, "mousemove", void 0], [g, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [g, "mouseover", void 0], [g, "mouseout", void 0], [g, "dblclick", void 0], [g, "click", void 0], [g, "keydown", { capture: !1 }], [g, "keyup", void 0], [g, "wheel", { passive: !1 }], [g, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [b, w, S] of this._listeners) k.addEventListener(b, w, b === document ? this.handleWindowEvent : this.handleEvent, S);
          }
          destroy() {
            for (const [a, f, g] of this._listeners) k.removeEventListener(a, f, a === document ? this.handleWindowEvent : this.handleEvent, g);
          }
          _addDefaultHandlers(a) {
            const f = this._map, g = f.getCanvasContainer();
            this._add("mapEvent", new df(f, a));
            const b = f.boxZoom = new z(f, a);
            this._add("boxZoom", b), a.interactive && a.boxZoom && b.enable();
            const w = f.cooperativeGestures = new fn(f, a.cooperativeGestures);
            this._add("cooperativeGestures", w), a.cooperativeGestures && w.enable();
            const S = new ge(f), R = new oi(f);
            f.doubleClickZoom = new Wr(R, S), this._add("tapZoom", S), this._add("clickZoom", R), a.interactive && a.doubleClickZoom && f.doubleClickZoom.enable();
            const B = new _i();
            this._add("tapDragZoom", B);
            const U = f.touchPitch = new si(f);
            this._add("touchPitch", U), a.interactive && a.touchPitch && f.touchPitch.enable(a.touchPitch);
            const j = () => f.project(f.getCenter()), X = function({ enable: Le, clickTolerance: $e, aroundCenter: Xe = !0, minPixelCenterThreshold: Fe = 100, rotateDegreesPerPixelMoved: Qe = 0.8 }, At) {
              const ft = new bt({ checkCorrectEvent: (dt) => k.mouseButton(dt) === 0 && dt.ctrlKey || k.mouseButton(dt) === 2 && !dt.ctrlKey });
              return new ye({ clickTolerance: $e, move: (dt, _t) => {
                const qt = At();
                if (Xe && Math.abs(qt.y - dt.y) > Fe) return { bearingDelta: o.cn(new o.P(dt.x, _t.y), _t, qt) };
                let Zt = (_t.x - dt.x) * Qe;
                return Xe && _t.y < qt.y && (Zt = -Zt), { bearingDelta: Zt };
              }, moveStateManager: ft, enable: Le, assignEvents: ht });
            }(a, j), q = function({ enable: Le, clickTolerance: $e, pitchDegreesPerPixelMoved: Xe = -0.5 }) {
              const Fe = new bt({ checkCorrectEvent: (Qe) => k.mouseButton(Qe) === 0 && Qe.ctrlKey || k.mouseButton(Qe) === 2 });
              return new ye({ clickTolerance: $e, move: (Qe, At) => ({ pitchDelta: (At.y - Qe.y) * Xe }), moveStateManager: Fe, enable: Le, assignEvents: ht });
            }(a), Q = function({ enable: Le, clickTolerance: $e, rollDegreesPerPixelMoved: Xe = 0.3 }, Fe) {
              const Qe = new bt({ checkCorrectEvent: (At) => k.mouseButton(At) === 2 && At.ctrlKey });
              return new ye({ clickTolerance: $e, move: (At, ft) => {
                const dt = Fe();
                let _t = (ft.x - At.x) * Xe;
                return ft.y < dt.y && (_t = -_t), { rollDelta: _t };
              }, moveStateManager: Qe, enable: Le, assignEvents: ht });
            }(a, j);
            f.dragRotate = new Xn(a, X, q, Q), this._add("mouseRotate", X, ["mousePitch"]), this._add("mousePitch", q, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", Q, ["mousePitch"]), a.interactive && a.dragRotate && f.dragRotate.enable();
            const ce = function({ enable: Le, clickTolerance: $e }) {
              const Xe = new bt({ checkCorrectEvent: (Fe) => k.mouseButton(Fe) === 0 && !Fe.ctrlKey });
              return new ye({ clickTolerance: $e, move: (Fe, Qe) => ({ around: Qe, panDelta: Qe.sub(Fe) }), activateOnStart: !0, moveStateManager: Xe, enable: Le, assignEvents: ht });
            }(a), we = new kt(a, f);
            f.dragPan = new Vi(g, ce, we), this._add("mousePan", ce), this._add("touchPan", we, ["touchZoom", "touchRotate"]), a.interactive && a.dragPan && f.dragPan.enable(a.dragPan);
            const Ae = new Br(), Se = new Kt();
            f.touchZoomRotate = new ps(g, Se, Ae, B), this._add("touchRotate", Ae, ["touchPan", "touchZoom"]), this._add("touchZoom", Se, ["touchPan", "touchRotate"]), a.interactive && a.touchZoomRotate && f.touchZoomRotate.enable(a.touchZoomRotate), this._add("blockableMapEvent", new C(f));
            const Me = f.scrollZoom = new lr(f, () => this._triggerRenderFrame());
            this._add("scrollZoom", Me, ["mousePan"]), a.interactive && a.scrollZoom && f.scrollZoom.enable(a.scrollZoom);
            const Ge = f.keyboard = new xi(f);
            this._add("keyboard", Ge), a.interactive && a.keyboard && f.keyboard.enable();
          }
          _add(a, f, g) {
            this._handlers.push({ handlerName: a, handler: f, allowed: g }), this._handlersById[a] = f;
          }
          stop(a) {
            if (!this._updatingCamera) {
              for (const { handler: f } of this._handlers) f.reset();
              this._inertia.clear(), this._fireEvents({}, {}, a), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: a } of this._handlers) if (a.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Zn(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(a, f, g) {
            for (const b in a) if (b !== g && (!f || f.indexOf(b) < 0)) return !0;
            return !1;
          }
          _getMapTouches(a) {
            const f = [];
            for (const g of a) this._el.contains(g.target) && f.push(g);
            return f;
          }
          mergeHandlerResult(a, f, g, b, w) {
            if (!g) return;
            o.e(a, g);
            const S = { handlerName: b, originalEvent: g.originalEvent || w };
            g.zoomDelta !== void 0 && (f.zoom = S), g.panDelta !== void 0 && (f.drag = S), g.rollDelta !== void 0 && (f.roll = S), g.pitchDelta !== void 0 && (f.pitch = S), g.bearingDelta !== void 0 && (f.rotate = S);
          }
          _applyChanges() {
            const a = {}, f = {}, g = {};
            for (const [b, w, S] of this._changes) b.panDelta && (a.panDelta = (a.panDelta || new o.P(0, 0))._add(b.panDelta)), b.zoomDelta && (a.zoomDelta = (a.zoomDelta || 0) + b.zoomDelta), b.bearingDelta && (a.bearingDelta = (a.bearingDelta || 0) + b.bearingDelta), b.pitchDelta && (a.pitchDelta = (a.pitchDelta || 0) + b.pitchDelta), b.rollDelta && (a.rollDelta = (a.rollDelta || 0) + b.rollDelta), b.around !== void 0 && (a.around = b.around), b.pinchAround !== void 0 && (a.pinchAround = b.pinchAround), b.noInertia && (a.noInertia = b.noInertia), o.e(f, w), o.e(g, S);
            this._updateMapTransform(a, f, g), this._changes = [];
          }
          _updateMapTransform(a, f, g) {
            const b = this._map, w = b._getTransformForUpdate(), S = b.terrain;
            if (!(pn(a) || S && this._terrainMovement)) return this._fireEvents(f, g, !0);
            b._stop(!0);
            let { panDelta: R, zoomDelta: B, bearingDelta: U, pitchDelta: j, rollDelta: X, around: q, pinchAround: Q } = a;
            Q !== void 0 && (q = Q), q = q || b.transform.centerPoint, S && !w.isPointOnMapSurface(q) && (q = w.centerPoint);
            const ce = { panDelta: R, zoomDelta: B, rollDelta: X, pitchDelta: j, bearingDelta: U, around: q };
            this._map.cameraHelper.useGlobeControls && !w.isPointOnMapSurface(q) && (q = w.centerPoint);
            const we = q.distSqr(w.centerPoint) < 0.01 ? w.center : w.screenPointToLocation(R ? q.sub(R) : q);
            this._handleMapControls({ terrain: S, tr: w, deltasForHelper: ce, preZoomAroundLoc: we, combinedEventsInProgress: f, panDelta: R }), b._applyUpdatedTransform(w), this._map._update(), a.noInertia || this._inertia.record(a), this._fireEvents(f, g, !0);
          }
          _handleMapControls({ terrain: a, tr: f, deltasForHelper: g, preZoomAroundLoc: b, combinedEventsInProgress: w, panDelta: S }) {
            const R = this._map.cameraHelper;
            if (R.handleMapControlsRollPitchBearingZoom(g, f), a) return R.useGlobeControls ? (this._terrainMovement || !w.drag && !w.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void R.handleMapControlsPan(g, f, b)) : this._terrainMovement || !w.drag && !w.zoom ? void (w.drag && this._terrainMovement && S ? f.setCenter(f.screenPointToLocation(f.centerPoint.sub(S))) : R.handleMapControlsPan(g, f, b)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void R.handleMapControlsPan(g, f, b));
            R.handleMapControlsPan(g, f, b);
          }
          _fireEvents(a, f, g) {
            const b = Zn(this._eventsInProgress), w = Zn(a), S = {};
            for (const X in a) {
              const { originalEvent: q } = a[X];
              this._eventsInProgress[X] || (S[`${X}start`] = q), this._eventsInProgress[X] = a[X];
            }
            !b && w && this._fireEvent("movestart", w.originalEvent);
            for (const X in S) this._fireEvent(X, S[X]);
            w && this._fireEvent("move", w.originalEvent);
            for (const X in a) {
              const { originalEvent: q } = a[X];
              this._fireEvent(X, q);
            }
            const R = {};
            let B;
            for (const X in this._eventsInProgress) {
              const { handlerName: q, originalEvent: Q } = this._eventsInProgress[X];
              this._handlersById[q].isActive() || (delete this._eventsInProgress[X], B = f[q] || Q, R[`${X}end`] = B);
            }
            for (const X in R) this._fireEvent(X, R[X]);
            const U = Zn(this._eventsInProgress), j = (b || w) && !U;
            if (j && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const X = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && X.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(X);
            }
            if (g && j) {
              this._updatingCamera = !0;
              const X = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), q = (Q) => Q !== 0 && -this._bearingSnap < Q && Q < this._bearingSnap;
              !X || !X.essential && P.prefersReducedMotion ? (this._map.fire(new o.l("moveend", { originalEvent: B })), q(this._map.getBearing()) && this._map.resetNorth()) : (q(X.bearing || this._map.getBearing()) && (X.bearing = 0), X.freezeElevation = !0, this._map.easeTo(X, { originalEvent: B })), this._updatingCamera = !1;
            }
          }
          _fireEvent(a, f) {
            this._map.fire(new o.l(a, f ? { originalEvent: f } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((a) => {
              delete this._frameId, this.handleEvent(new dn("renderFrame", { timeStamp: a })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class cr extends o.E {
          constructor(a, f, g) {
            super(), this._renderFrameCallback = () => {
              const b = Math.min((D() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(b)), b < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = a, this._bearingSnap = g.bearingSnap, this.cameraHelper = f, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          migrateProjection(a, f) {
            a.apply(this.transform), this.transform = a, this.cameraHelper = f;
          }
          getCenter() {
            return new o.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(a, f) {
            return this.jumpTo({ center: a }, f);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(a, f) {
            return this.jumpTo({ elevation: a }, f), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(a) {
            this._centerClampedToGround = a;
          }
          panBy(a, f, g) {
            return a = o.P.convert(a).mult(-1), this.panTo(this.transform.center, o.e({ offset: a }, f), g);
          }
          panTo(a, f, g) {
            return this.easeTo(o.e({ center: a }, f), g);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(a, f) {
            return this.jumpTo({ zoom: a }, f), this;
          }
          zoomTo(a, f, g) {
            return this.easeTo(o.e({ zoom: a }, f), g);
          }
          zoomIn(a, f) {
            return this.zoomTo(this.getZoom() + 1, a, f), this;
          }
          zoomOut(a, f) {
            return this.zoomTo(this.getZoom() - 1, a, f), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(a, f) {
            return a != this.transform.fov && (this.transform.setFov(a), this.fire(new o.l("movestart", f)).fire(new o.l("move", f)).fire(new o.l("moveend", f))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(a, f) {
            return this.jumpTo({ bearing: a }, f), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(a, f) {
            return this.jumpTo({ padding: a }, f), this;
          }
          rotateTo(a, f, g) {
            return this.easeTo(o.e({ bearing: a }, f), g);
          }
          resetNorth(a, f) {
            return this.rotateTo(0, o.e({ duration: 1e3 }, a), f), this;
          }
          resetNorthPitch(a, f) {
            return this.easeTo(o.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, a), f), this;
          }
          snapToNorth(a, f) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(a, f) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(a, f) {
            return this.jumpTo({ pitch: a }, f), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(a, f) {
            return this.jumpTo({ roll: a }, f), this;
          }
          cameraForBounds(a, f) {
            a = Oe.convert(a).adjustAntiMeridian();
            const g = f && f.bearing || 0;
            return this._cameraForBoxAndBearing(a.getNorthWest(), a.getSouthEast(), g, f);
          }
          _cameraForBoxAndBearing(a, f, g, b) {
            const w = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (b = o.e({ padding: w, offset: [0, 0], maxZoom: this.transform.maxZoom }, b)).padding == "number") {
              const U = b.padding;
              b.padding = { top: U, bottom: U, right: U, left: U };
            }
            const S = o.e(w, b.padding);
            b.padding = S;
            const R = this.transform, B = new Oe(a, f);
            return this.cameraHelper.cameraForBoxAndBearing(b, S, B, g, R);
          }
          fitBounds(a, f, g) {
            return this._fitInternal(this.cameraForBounds(a, f), f, g);
          }
          fitScreenCoordinates(a, f, g, b, w) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(a)), this.transform.screenPointToLocation(o.P.convert(f)), g, b), b, w);
          }
          _fitInternal(a, f, g) {
            return a ? (delete (f = o.e(a, f)).padding, f.linear ? this.easeTo(f, g) : this.flyTo(f, g)) : this;
          }
          jumpTo(a, f) {
            this.stop();
            const g = this._getTransformForUpdate();
            let b = !1, w = !1, S = !1;
            const R = g.zoom;
            this.cameraHelper.handleJumpToCenterZoom(g, a);
            const B = g.zoom !== R;
            return "elevation" in a && g.elevation !== +a.elevation && g.setElevation(+a.elevation), "bearing" in a && g.bearing !== +a.bearing && (b = !0, g.setBearing(+a.bearing)), "pitch" in a && g.pitch !== +a.pitch && (w = !0, g.setPitch(+a.pitch)), "roll" in a && g.roll !== +a.roll && (S = !0, g.setRoll(+a.roll)), a.padding == null || g.isPaddingEqual(a.padding) || g.setPadding(a.padding), this._applyUpdatedTransform(g), this.fire(new o.l("movestart", f)).fire(new o.l("move", f)), B && this.fire(new o.l("zoomstart", f)).fire(new o.l("zoom", f)).fire(new o.l("zoomend", f)), b && this.fire(new o.l("rotatestart", f)).fire(new o.l("rotate", f)).fire(new o.l("rotateend", f)), w && this.fire(new o.l("pitchstart", f)).fire(new o.l("pitch", f)).fire(new o.l("pitchend", f)), S && this.fire(new o.l("rollstart", f)).fire(new o.l("roll", f)).fire(new o.l("rollend", f)), this.fire(new o.l("moveend", f));
          }
          calculateCameraOptionsFromTo(a, f, g, b = 0) {
            const w = o.a1.fromLngLat(a, f), S = o.a1.fromLngLat(g, b), R = S.x - w.x, B = S.y - w.y, U = S.z - w.z, j = Math.hypot(R, B, U);
            if (j === 0) throw new Error("Can't calculate camera options with same From and To");
            const X = Math.hypot(R, B), q = o.ak(this.transform.cameraToCenterDistance / j / this.transform.tileSize), Q = 180 * Math.atan2(R, -B) / Math.PI;
            let ce = 180 * Math.acos(X / j) / Math.PI;
            return ce = U < 0 ? 90 - ce : 90 + ce, { center: S.toLngLat(), elevation: b, zoom: q, pitch: ce, bearing: Q };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(a, f, g, b, w) {
            const S = this.transform.calculateCenterFromCameraLngLatAlt(a, f, g, b);
            return { center: S.center, elevation: S.elevation, zoom: S.zoom, bearing: g, pitch: b, roll: w };
          }
          easeTo(a, f) {
            this._stop(!1, a.easeId), ((a = o.e({ offset: [0, 0], duration: 500, easing: o.co }, a)).animate === !1 || !a.essential && P.prefersReducedMotion) && (a.duration = 0);
            const g = this._getTransformForUpdate(), b = this.getBearing(), w = g.pitch, S = g.roll, R = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b, B = "pitch" in a ? +a.pitch : w, U = "roll" in a ? this._normalizeBearing(a.roll, S) : S, j = "padding" in a ? a.padding : g.padding, X = o.P.convert(a.offset);
            let q, Q;
            a.around && (q = o.S.convert(a.around), Q = g.locationToScreenPoint(q));
            const ce = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, we = this.cameraHelper.handleEaseTo(g, { bearing: R, pitch: B, roll: U, padding: j, around: q, aroundPoint: Q, offsetAsPoint: X, offset: a.offset, zoom: a.zoom, center: a.center });
            return this._rotating = this._rotating || b !== R, this._pitching = this._pitching || B !== w, this._rolling = this._rolling || U !== S, this._padding = !g.isPaddingEqual(j), this._zooming = this._zooming || we.isZooming, this._easeId = a.easeId, this._prepareEase(f, a.noMoveStart, ce), this.terrain && this._prepareElevation(we.elevationCenter), this._ease((Ae) => {
              we.easeFunc(Ae), this.terrain && !a.freezeElevation && this._updateElevation(Ae), this._applyUpdatedTransform(g), this._fireMoveEvents(f);
            }, (Ae) => {
              this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(f, Ae);
            }, a), this;
          }
          _prepareEase(a, f, g = {}) {
            this._moving = !0, f || g.moving || this.fire(new o.l("movestart", a)), this._zooming && !g.zooming && this.fire(new o.l("zoomstart", a)), this._rotating && !g.rotating && this.fire(new o.l("rotatestart", a)), this._pitching && !g.pitching && this.fire(new o.l("pitchstart", a)), this._rolling && !g.rolling && this.fire(new o.l("rollstart", a));
          }
          _prepareElevation(a) {
            this._elevationCenter = a, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(a) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const f = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (a < 1 && f !== this._elevationTarget) {
              const g = this._elevationTarget - this._elevationStart;
              this._elevationStart += a * (g - (f - (g * a + this._elevationStart)) / (1 - a)), this._elevationTarget = f;
            }
            this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, a));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(a) {
            if (!this.terrain && a.elevation >= 0 && a.pitch <= 90) return {};
            const f = a.getCameraLngLat(), g = a.getCameraAltitude(), b = this.terrain ? this.terrain.getElevationForLngLatZoom(f, a.zoom) : 0;
            if (g < b) {
              const w = this.calculateCameraOptionsFromTo(f, b, a.center, a.elevation);
              return { pitch: w.pitch, zoom: w.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(a) {
            const f = [];
            if (f.push((b) => this._elevateCameraIfInsideTerrain(b)), this.transformCameraUpdate && f.push((b) => this.transformCameraUpdate(b)), !f.length) return;
            const g = a.clone();
            for (const b of f) {
              const w = g.clone(), { center: S, zoom: R, roll: B, pitch: U, bearing: j, elevation: X } = b(w);
              S && w.setCenter(S), X !== void 0 && w.setElevation(X), R !== void 0 && w.setZoom(R), B !== void 0 && w.setRoll(B), U !== void 0 && w.setPitch(U), j !== void 0 && w.setBearing(j), g.apply(w);
            }
            this.transform.apply(g);
          }
          _fireMoveEvents(a) {
            this.fire(new o.l("move", a)), this._zooming && this.fire(new o.l("zoom", a)), this._rotating && this.fire(new o.l("rotate", a)), this._pitching && this.fire(new o.l("pitch", a)), this._rolling && this.fire(new o.l("roll", a));
          }
          _afterEase(a, f) {
            if (this._easeId && f && this._easeId === f) return;
            delete this._easeId;
            const g = this._zooming, b = this._rotating, w = this._pitching, S = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, g && this.fire(new o.l("zoomend", a)), b && this.fire(new o.l("rotateend", a)), w && this.fire(new o.l("pitchend", a)), S && this.fire(new o.l("rollend", a)), this.fire(new o.l("moveend", a));
          }
          flyTo(a, f) {
            if (!a.essential && P.prefersReducedMotion) {
              const _t = o.Q(a, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(_t, f);
            }
            this.stop(), a = o.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.co }, a);
            const g = this._getTransformForUpdate(), b = g.bearing, w = g.pitch, S = g.roll, R = g.padding, B = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b, U = "pitch" in a ? +a.pitch : w, j = "roll" in a ? this._normalizeBearing(a.roll, S) : S, X = "padding" in a ? a.padding : g.padding, q = o.P.convert(a.offset);
            let Q = g.centerPoint.add(q);
            const ce = g.screenPointToLocation(Q), we = this.cameraHelper.handleFlyTo(g, { bearing: B, pitch: U, roll: j, padding: X, locationAtOffset: ce, offsetAsPoint: q, center: a.center, minZoom: a.minZoom, zoom: a.zoom });
            let Ae = a.curve;
            const Se = Math.max(g.width, g.height), Me = Se / we.scaleOfZoom, Ge = we.pixelPathLength;
            typeof we.scaleOfMinZoom == "number" && (Ae = Math.sqrt(Se / we.scaleOfMinZoom / Ge * 2));
            const Le = Ae * Ae;
            function $e(_t) {
              const qt = (Me * Me - Se * Se + (_t ? -1 : 1) * Le * Le * Ge * Ge) / (2 * (_t ? Me : Se) * Le * Ge);
              return Math.log(Math.sqrt(qt * qt + 1) - qt);
            }
            function Xe(_t) {
              return (Math.exp(_t) - Math.exp(-_t)) / 2;
            }
            function Fe(_t) {
              return (Math.exp(_t) + Math.exp(-_t)) / 2;
            }
            const Qe = $e(!1);
            let At = function(_t) {
              return Fe(Qe) / Fe(Qe + Ae * _t);
            }, ft = function(_t) {
              return Se * ((Fe(Qe) * (Xe(qt = Qe + Ae * _t) / Fe(qt)) - Xe(Qe)) / Le) / Ge;
              var qt;
            }, dt = ($e(!0) - Qe) / Ae;
            if (Math.abs(Ge) < 2e-6 || !isFinite(dt)) {
              if (Math.abs(Se - Me) < 1e-6) return this.easeTo(a, f);
              const _t = Me < Se ? -1 : 1;
              dt = Math.abs(Math.log(Me / Se)) / Ae, ft = () => 0, At = (qt) => Math.exp(_t * Ae * qt);
            }
            return a.duration = "duration" in a ? +a.duration : 1e3 * dt / ("screenSpeed" in a ? +a.screenSpeed / Ae : +a.speed), a.maxDuration && a.duration > a.maxDuration && (a.duration = 0), this._zooming = !0, this._rotating = b !== B, this._pitching = U !== w, this._rolling = j !== S, this._padding = !g.isPaddingEqual(X), this._prepareEase(f, !1), this.terrain && this._prepareElevation(we.targetCenter), this._ease((_t) => {
              const qt = _t * dt, Zt = 1 / At(qt), zt = ft(qt);
              this._rotating && g.setBearing(o.C.number(b, B, _t)), this._pitching && g.setPitch(o.C.number(w, U, _t)), this._rolling && g.setRoll(o.C.number(S, j, _t)), this._padding && (g.interpolatePadding(R, X, _t), Q = g.centerPoint.add(q)), we.easeFunc(_t, Zt, zt, Q), this.terrain && !a.freezeElevation && this._updateElevation(_t), this._applyUpdatedTransform(g), this._fireMoveEvents(f);
            }, () => {
              this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(f);
            }, a), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(a, f) {
            var g;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const b = this._onEaseEnd;
              delete this._onEaseEnd, b.call(this, f);
            }
            return a || (g = this.handlers) === null || g === void 0 || g.stop(!1), this;
          }
          _ease(a, f, g) {
            g.animate === !1 || g.duration === 0 ? (a(1), f()) : (this._easeStart = D(), this._easeOptions = g, this._onEaseFrame = a, this._onEaseEnd = f, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(a, f) {
            a = o.aO(a, -180, 180);
            const g = Math.abs(a - f);
            return Math.abs(a - 360 - f) < g && (a -= 360), Math.abs(a + 360 - f) < g && (a += 360), a;
          }
          queryTerrainElevation(a) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(a), this.transform.tileZoom) : null;
          }
        }
        const Zi = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Bi {
          constructor(a = Zi) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (f) => {
              !f || f.sourceDataType !== "metadata" && f.sourceDataType !== "visibility" && f.dataType !== "style" && f.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = a;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(a) {
            return this._map = a, this._compact = this.options.compact, this._container = k.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = k.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = k.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            k.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(a, f) {
            const g = this._map._getUIString(`AttributionControl.${f}`);
            a.title = g, a.setAttribute("aria-label", g);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let a = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? a = a.concat(this.options.customAttribution.map((b) => typeof b != "string" ? "" : b)) : typeof this.options.customAttribution == "string" && a.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const b = this._map.style.stylesheet;
              this.styleOwner = b.owner, this.styleId = b.id;
            }
            const f = this._map.style.sourceCaches;
            for (const b in f) {
              const w = f[b];
              if (w.used || w.usedForTerrain) {
                const S = w.getSource();
                S.attribution && a.indexOf(S.attribution) < 0 && a.push(S.attribution);
              }
            }
            a = a.filter((b) => String(b).trim()), a.sort((b, w) => b.length - w.length), a = a.filter((b, w) => {
              for (let S = w + 1; S < a.length; S++) if (a[S].indexOf(b) >= 0) return !1;
              return !0;
            });
            const g = a.join(" | ");
            g !== this._attribHTML && (this._attribHTML = g, a.length ? (this._innerContainer.innerHTML = k.sanitize(g), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class On {
          constructor(a = {}) {
            this._updateCompact = () => {
              const f = this._container.children;
              if (f.length) {
                const g = f[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && g.classList.add("maplibregl-compact") : g.classList.remove("maplibregl-compact");
              }
            }, this.options = a;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(a) {
            this._map = a, this._compact = this.options && this.options.compact, this._container = k.create("div", "maplibregl-ctrl");
            const f = k.create("a", "maplibregl-ctrl-logo");
            return f.target = "_blank", f.rel = "noopener nofollow", f.href = "https://maplibre.org/", f.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), f.setAttribute("rel", "noopener nofollow"), this._container.appendChild(f), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            k.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class ln {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(a) {
            const f = ++this._id;
            return this._queue.push({ callback: a, id: f, cancelled: !1 }), f;
          }
          remove(a) {
            const f = this._currentlyRunning, g = f ? this._queue.concat(f) : this._queue;
            for (const b of g) if (b.id === a) return void (b.cancelled = !0);
          }
          run(a = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const f = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const g of f) if (!g.cancelled && (g.callback(a), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var Cn = o.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class gn extends o.E {
          constructor(a) {
            super(), this._lastTilesetChange = D(), this.sourceCache = a, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = a._source.tileSize * 2 ** this.deltaZoom, a.usedForTerrain = !0, a.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(a, f) {
            this.sourceCache.update(a, f), this._renderableTilesKeys = [];
            const g = {};
            for (const b of fr(a, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: f, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) g[b.key] = !0, this._renderableTilesKeys.push(b.key), this._tiles[b.key] || (b.terrainRttPosMatrix32f = new Float64Array(16), o.bZ(b.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1), this._tiles[b.key] = new ne(b, this.tileSize), this._lastTilesetChange = D());
            for (const b in this._tiles) g[b] || delete this._tiles[b];
          }
          freeRtt(a) {
            for (const f in this._tiles) {
              const g = this._tiles[f];
              (!a || g.tileID.equals(a) || g.tileID.isChildOf(a) || a.isChildOf(g.tileID)) && (g.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((a) => this.getTileByID(a));
          }
          getTileByID(a) {
            return this._tiles[a];
          }
          getTerrainCoords(a, f) {
            return f ? this._getTerrainCoordsForTileRanges(a, f) : this._getTerrainCoordsForRegularTile(a);
          }
          _getTerrainCoordsForRegularTile(a) {
            const f = {};
            for (const g of this._renderableTilesKeys) {
              const b = this._tiles[g].tileID, w = a.clone(), S = o.ba();
              if (b.canonical.equals(a.canonical)) o.bZ(S, 0, o.$, o.$, 0, 0, 1);
              else if (b.canonical.isChildOf(a.canonical)) {
                const R = b.canonical.z - a.canonical.z, B = b.canonical.x - (b.canonical.x >> R << R), U = b.canonical.y - (b.canonical.y >> R << R), j = o.$ >> R;
                o.bZ(S, 0, j, j, 0, 0, 1), o.M(S, S, [-B * j, -U * j, 0]);
              } else {
                if (!a.canonical.isChildOf(b.canonical)) continue;
                {
                  const R = a.canonical.z - b.canonical.z, B = a.canonical.x - (a.canonical.x >> R << R), U = a.canonical.y - (a.canonical.y >> R << R), j = o.$ >> R;
                  o.bZ(S, 0, o.$, o.$, 0, 0, 1), o.M(S, S, [B * j, U * j, 0]), o.N(S, S, [1 / 2 ** R, 1 / 2 ** R, 0]);
                }
              }
              w.terrainRttPosMatrix32f = new Float32Array(S), f[g] = w;
            }
            return f;
          }
          _getTerrainCoordsForTileRanges(a, f) {
            const g = {};
            for (const b of this._renderableTilesKeys) {
              const w = this._tiles[b].tileID;
              if (!this._isWithinTileRanges(w, f)) continue;
              const S = a.clone(), R = o.ba();
              if (w.canonical.z === a.canonical.z) {
                const B = a.canonical.x - w.canonical.x, U = a.canonical.y - w.canonical.y;
                o.bZ(R, 0, o.$, o.$, 0, 0, 1), o.M(R, R, [B * o.$, U * o.$, 0]);
              } else if (w.canonical.z > a.canonical.z) {
                const B = w.canonical.z - a.canonical.z, U = w.canonical.x - (w.canonical.x >> B << B), j = w.canonical.y - (w.canonical.y >> B << B), X = a.canonical.x - (w.canonical.x >> B), q = a.canonical.y - (w.canonical.y >> B), Q = o.$ >> B;
                o.bZ(R, 0, Q, Q, 0, 0, 1), o.M(R, R, [-U * Q + X * o.$, -j * Q + q * o.$, 0]);
              } else {
                const B = a.canonical.z - w.canonical.z, U = a.canonical.x - (a.canonical.x >> B << B), j = a.canonical.y - (a.canonical.y >> B << B), X = (a.canonical.x >> B) - w.canonical.x, q = (a.canonical.y >> B) - w.canonical.y, Q = o.$ << B;
                o.bZ(R, 0, Q, Q, 0, 0, 1), o.M(R, R, [U * o.$ + X * Q, j * o.$ + q * Q, 0]);
              }
              S.terrainRttPosMatrix32f = new Float32Array(R), g[b] = S;
            }
            return g;
          }
          getSourceTile(a, f) {
            const g = this.sourceCache._source;
            let b = a.overscaledZ - this.deltaZoom;
            if (b > g.maxzoom && (b = g.maxzoom), b < g.minzoom) return null;
            this._sourceTileCache[a.key] || (this._sourceTileCache[a.key] = a.scaledTo(b).key);
            let w = this.sourceCache.getTileByID(this._sourceTileCache[a.key]);
            if ((!w || !w.dem) && f) for (; b >= g.minzoom && (!w || !w.dem); ) w = this.sourceCache.getTileByID(a.scaledTo(b--).key);
            return w;
          }
          anyTilesAfterTime(a = Date.now()) {
            return this._lastTilesetChange >= a;
          }
          _isWithinTileRanges(a, f) {
            return f[a.canonical.z] && a.canonical.x >= f[a.canonical.z].minTileX && a.canonical.x <= f[a.canonical.z].maxTileX && a.canonical.y >= f[a.canonical.z].minTileY && a.canonical.y <= f[a.canonical.z].maxTileY;
          }
        }
        class Gi {
          constructor(a, f, g) {
            this._meshCache = {}, this.painter = a, this.sourceCache = new gn(f), this.options = g, this.exaggeration = typeof g.exaggeration == "number" ? g.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(a, f, g, b = o.$) {
            var w;
            if (!(f >= 0 && f < b && g >= 0 && g < b)) return 0;
            const S = this.getTerrainData(a), R = (w = S.tile) === null || w === void 0 ? void 0 : w.dem;
            if (!R) return 0;
            const B = o.cs([], [f / b * o.$, g / b * o.$], S.u_terrain_matrix), U = [B[0] * R.dim, B[1] * R.dim], j = Math.floor(U[0]), X = Math.floor(U[1]), q = U[0] - j, Q = U[1] - X;
            return R.get(j, X) * (1 - q) * (1 - Q) + R.get(j + 1, X) * q * (1 - Q) + R.get(j, X + 1) * (1 - q) * Q + R.get(j + 1, X + 1) * q * Q;
          }
          getElevationForLngLatZoom(a, f) {
            if (!o.ct(f, a.wrap())) return 0;
            const { tileID: g, mercatorX: b, mercatorY: w } = this._getOverscaledTileIDFromLngLatZoom(a, f);
            return this.getElevation(g, b % o.$, w % o.$, o.$);
          }
          getElevation(a, f, g, b = o.$) {
            return this.getDEMElevation(a, f, g, b) * this.exaggeration;
          }
          getTerrainData(a) {
            if (!this._emptyDemTexture) {
              const b = this.painter.context, w = new o.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new o.T(b, w, b.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new o.T(b, new o.R({ width: 1, height: 1 }), b.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(b.gl.NEAREST, b.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.ai([]);
            }
            const f = this.sourceCache.getSourceTile(a, !0);
            if (f && f.dem && (!f.demTexture || f.needsTerrainPrepare)) {
              const b = this.painter.context;
              f.demTexture = this.painter.getTileTexture(f.dem.stride), f.demTexture ? f.demTexture.update(f.dem.getPixels(), { premultiply: !1 }) : f.demTexture = new o.T(b, f.dem.getPixels(), b.gl.RGBA, { premultiply: !1 }), f.demTexture.bind(b.gl.NEAREST, b.gl.CLAMP_TO_EDGE), f.needsTerrainPrepare = !1;
            }
            const g = f && f + f.tileID.key + a.key;
            if (g && !this._demMatrixCache[g]) {
              const b = this.sourceCache.sourceCache._source.maxzoom;
              let w = a.canonical.z - f.tileID.canonical.z;
              a.overscaledZ > a.canonical.z && (a.canonical.z >= b ? w = a.canonical.z - b : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const S = a.canonical.x - (a.canonical.x >> w << w), R = a.canonical.y - (a.canonical.y >> w << w), B = o.cu(new Float64Array(16), [1 / (o.$ << w), 1 / (o.$ << w), 0]);
              o.M(B, B, [S * o.$, R * o.$, 0]), this._demMatrixCache[a.key] = { matrix: B, coord: a };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: f && f.dem && f.dem.dim || 1, u_terrain_matrix: g ? this._demMatrixCache[a.key].matrix : this._emptyDemMatrix, u_terrain_unpack: f && f.dem && f.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (f && f.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: f };
          }
          getFramebuffer(a) {
            const f = this.painter, g = f.width / devicePixelRatio, b = f.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === g && this._fbo.height === b || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(f.context, { width: g, height: b, data: null }, f.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(f.context.gl.NEAREST, f.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new o.T(f.context, { width: g, height: b, data: null }, f.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(f.context.gl.NEAREST, f.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = f.context.createFramebuffer(g, b, !0, !1), this._fbo.depthAttachment.set(f.context.createRenderbuffer(f.context.gl.DEPTH_COMPONENT16, g, b))), this._fbo.colorAttachment.set(a === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const a = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const f = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let w = 0, S = 0; w < this._coordsTextureSize; w++) for (let R = 0; R < this._coordsTextureSize; R++, S += 4) f[S + 0] = 255 & R, f[S + 1] = 255 & w, f[S + 2] = R >> 8 << 4 | w >> 8, f[S + 3] = 0;
            const g = new o.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(f.buffer)), b = new o.T(a, g, a.gl.RGBA, { premultiply: !1 });
            return b.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE), this._coordsTexture = b, b;
          }
          pointCoordinate(a) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const f = new Uint8Array(4), g = this.painter.context, b = g.gl, w = Math.round(a.x * this.painter.pixelRatio / devicePixelRatio), S = Math.round(a.y * this.painter.pixelRatio / devicePixelRatio), R = Math.round(this.painter.height / devicePixelRatio);
            g.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), b.readPixels(w, R - S - 1, 1, 1, b.RGBA, b.UNSIGNED_BYTE, f), g.bindFramebuffer.set(null);
            const B = f[0] + (f[2] >> 4 << 8), U = f[1] + ((15 & f[2]) << 8), j = this.coordsIndex[255 - f[3]], X = j && this.sourceCache.getTileByID(j);
            if (!X) return null;
            const q = this._coordsTextureSize, Q = (1 << X.tileID.canonical.z) * q;
            return new o.a1((X.tileID.canonical.x * q + B) / Q + X.tileID.wrap, (X.tileID.canonical.y * q + U) / Q, this.getElevation(X.tileID, B, U, q));
          }
          depthAtPoint(a) {
            const f = new Uint8Array(4), g = this.painter.context, b = g.gl;
            return g.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), b.readPixels(a.x, this.painter.height / devicePixelRatio - a.y - 1, 1, 1, b.RGBA, b.UNSIGNED_BYTE, f), g.bindFramebuffer.set(null), (f[0] / 16777216 + f[1] / 65536 + f[2] / 256 + f[3]) / 256;
          }
          getTerrainMesh(a) {
            var f;
            const g = ((f = this.painter.style.projection) === null || f === void 0 ? void 0 : f.transitionState) > 0, b = g && a.canonical.y === 0, w = g && a.canonical.y === (1 << a.canonical.z) - 1, S = `m_${b ? "n" : ""}_${w ? "s" : ""}`;
            if (this._meshCache[S]) return this._meshCache[S];
            const R = this.painter.context, B = new o.cv(), U = new o.aN(), j = this.meshSize, X = o.$ / j, q = j * j;
            for (let Fe = 0; Fe <= j; Fe++) for (let Qe = 0; Qe <= j; Qe++) B.emplaceBack(Qe * X, Fe * X, 0);
            for (let Fe = 0; Fe < q; Fe += j + 1) for (let Qe = 0; Qe < j; Qe++) U.emplaceBack(Qe + Fe, j + Qe + Fe + 1, j + Qe + Fe + 2), U.emplaceBack(Qe + Fe, j + Qe + Fe + 2, Qe + Fe + 1);
            const Q = B.length, ce = Q + (j + 1), we = (j + 1) * j, Ae = b ? o.bh : 0, Se = b ? 0 : 1, Me = w ? o.bi : o.$, Ge = w ? 0 : 1;
            for (let Fe = 0; Fe <= j; Fe++) B.emplaceBack(Fe * X, Ae, Se);
            for (let Fe = 0; Fe <= j; Fe++) B.emplaceBack(Fe * X, Me, Ge);
            for (let Fe = 0; Fe < j; Fe++) U.emplaceBack(we + Fe, ce + Fe, ce + Fe + 1), U.emplaceBack(we + Fe, ce + Fe + 1, we + Fe + 1), U.emplaceBack(0 + Fe, Q + Fe + 1, Q + Fe), U.emplaceBack(0 + Fe, 0 + Fe + 1, Q + Fe + 1);
            const Le = B.length, $e = Le + 2 * (j + 1);
            for (const Fe of [0, 1]) for (let Qe = 0; Qe <= j; Qe++) for (const At of [0, 1]) B.emplaceBack(Fe * o.$, Qe * X, At);
            for (let Fe = 0; Fe < 2 * j; Fe += 2) U.emplaceBack(Le + Fe, Le + Fe + 1, Le + Fe + 3), U.emplaceBack(Le + Fe, Le + Fe + 3, Le + Fe + 2), U.emplaceBack($e + Fe, $e + Fe + 3, $e + Fe + 1), U.emplaceBack($e + Fe, $e + Fe + 2, $e + Fe + 3);
            const Xe = new fs(R.createVertexBuffer(B, Cn.members), R.createIndexBuffer(U), o.aM.simpleSegment(0, 0, B.length, U.length));
            return this._meshCache[S] = Xe, Xe;
          }
          getMeshFrameDelta(a) {
            return 2 * Math.PI * o.bu / Math.pow(2, Math.max(a, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(a, f) {
            var g;
            const { tileID: b } = this._getOverscaledTileIDFromLngLatZoom(a, f);
            return (g = this.getMinMaxElevation(b).minElevation) !== null && g !== void 0 ? g : 0;
          }
          getMinMaxElevation(a) {
            const f = this.getTerrainData(a).tile, g = { minElevation: null, maxElevation: null };
            return f && f.dem && (g.minElevation = f.dem.min * this.exaggeration, g.maxElevation = f.dem.max * this.exaggeration), g;
          }
          _getOverscaledTileIDFromLngLatZoom(a, f) {
            const g = o.a1.fromLngLat(a.wrap()), b = (1 << f) * o.$, w = g.x * b, S = g.y * b, R = Math.floor(w / o.$), B = Math.floor(S / o.$);
            return { tileID: new o.Z(f, 0, f, R, B), mercatorX: w, mercatorY: S };
          }
        }
        class Yn {
          constructor(a, f, g) {
            this._context = a, this._size = f, this._tileSize = g, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const a of this._objects) a.texture.destroy(), a.fbo.destroy();
          }
          _createObject(a) {
            const f = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), g = new o.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return g.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), f.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), f.colorAttachment.set(g.texture), { id: a, fbo: f, texture: g, stamp: -1, inUse: !1 };
          }
          getObjectForId(a) {
            return this._objects[a];
          }
          useObject(a) {
            a.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((f) => a.id !== f), this._recentlyUsed.push(a.id);
          }
          stampObject(a) {
            a.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const f of this._recentlyUsed) if (!this._objects[f].inUse) return this._objects[f];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const a = this._createObject(this._objects.length);
            return this._objects.push(a), a;
          }
          freeObject(a) {
            a.inUse = !1;
          }
          freeAllObjects() {
            for (const a of this._objects) this.freeObject(a);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((a) => !a.inUse) === !1;
          }
        }
        const is = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class Hs {
          constructor(a, f) {
            this.painter = a, this.terrain = f, this.pool = new Yn(a.context, 30, f.sourceCache.tileSize * f.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(a) {
            return this.pool.getObjectForId(a.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(a, f) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = a._order.filter((g) => !a._layers[g].isHidden(f)), this._coordsAscending = {};
            for (const g in a.sourceCaches) {
              this._coordsAscending[g] = {};
              const b = a.sourceCaches[g].getVisibleCoordinates(), w = a.sourceCaches[g].getSource(), S = w instanceof hr ? w.terrainTileRanges : null;
              for (const R of b) {
                const B = this.terrain.sourceCache.getTerrainCoords(R, S);
                for (const U in B) this._coordsAscending[g][U] || (this._coordsAscending[g][U] = []), this._coordsAscending[g][U].push(B[U]);
              }
            }
            this._coordsAscendingStr = {};
            for (const g of a._order) {
              const b = a._layers[g], w = b.source;
              if (is[b.type] && !this._coordsAscendingStr[w]) {
                this._coordsAscendingStr[w] = {};
                for (const S in this._coordsAscending[w]) this._coordsAscendingStr[w][S] = this._coordsAscending[w][S].map((R) => R.key).sort().join();
              }
            }
            for (const g of this._renderableTiles) for (const b in this._coordsAscendingStr) {
              const w = this._coordsAscendingStr[b][g.tileID.key];
              w && w !== g.rttCoords[b] && (g.rtt = []);
            }
          }
          renderLayer(a, f) {
            if (a.isHidden(this.painter.transform.zoom)) return !1;
            const g = Object.assign(Object.assign({}, f), { isRenderingToTexture: !0 }), b = a.type, w = this.painter, S = this._renderableLayerIds[this._renderableLayerIds.length - 1] === a.id;
            if (is[b] && (this._prevType && is[this._prevType] || this._stacks.push([]), this._prevType = b, this._stacks[this._stacks.length - 1].push(a.id), !S)) return !0;
            if (is[this._prevType] || is[b] && S) {
              this._prevType = b;
              const R = this._stacks.length - 1, B = this._stacks[R] || [];
              for (const U of this._renderableTiles) {
                if (this.pool.isFull() && (hf(this.painter, this.terrain, this._rttTiles, g), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(U), U.rtt[R]) {
                  const X = this.pool.getObjectForId(U.rtt[R].id);
                  if (X.stamp === U.rtt[R].stamp) {
                    this.pool.useObject(X);
                    continue;
                  }
                }
                const j = this.pool.getOrCreateFreeObject();
                this.pool.useObject(j), this.pool.stampObject(j), U.rtt[R] = { id: j.id, stamp: j.stamp }, w.context.bindFramebuffer.set(j.fbo.framebuffer), w.context.clear({ color: o.bf.transparent, stencil: 0 }), w.currentStencilSource = void 0;
                for (let X = 0; X < B.length; X++) {
                  const q = w.style._layers[B[X]], Q = q.source ? this._coordsAscending[q.source][U.tileID.key] : [U.tileID];
                  w.context.viewport.set([0, 0, j.fbo.width, j.fbo.height]), w._renderTileClippingMasks(q, Q, !0), w.renderLayer(w, w.style.sourceCaches[q.source], q, Q, g), q.source && (U.rttCoords[q.source] = this._coordsAscendingStr[q.source][U.tileID.key]);
                }
              }
              return hf(this.painter, this.terrain, this._rttTiles, g), this._rttTiles = [], this.pool.freeAllObjects(), is[b];
            }
            return !1;
          }
        }
        const gs = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, wi = d, Ai = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: Zi, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, no = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class Di {
          constructor(a, f, g = !1) {
            this.mousedown = (w) => {
              this.startMove(w, k.mousePos(this.element, w)), k.addEventListener(window, "mousemove", this.mousemove), k.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (w) => {
              this.move(w, k.mousePos(this.element, w));
            }, this.mouseup = (w) => {
              this._rotatePitchHandler.dragEnd(w), this.offTemp();
            }, this.touchstart = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = k.touchPos(this.element, w.targetTouches)[0], this.startMove(w, this._startPos), k.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), k.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._lastPos = k.touchPos(this.element, w.targetTouches)[0], this.move(w, this._lastPos));
            }, this.touchend = (w) => {
              w.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = f;
            const b = new st();
            this._rotatePitchHandler = new ye({ clickTolerance: 3, move: (w, S) => {
              const R = f.getBoundingClientRect(), B = new o.P((R.bottom - R.top) / 2, (R.right - R.left) / 2);
              return { bearingDelta: o.cn(new o.P(w.x, S.y), S, B), pitchDelta: g ? -0.5 * (S.y - w.y) : void 0 };
            }, moveStateManager: b, enable: !0, assignEvents: () => {
            } }), this.map = a, k.addEventListener(f, "mousedown", this.mousedown), k.addEventListener(f, "touchstart", this.touchstart, { passive: !1 }), k.addEventListener(f, "touchcancel", this.reset);
          }
          startMove(a, f) {
            this._rotatePitchHandler.dragStart(a, f), k.disableDrag();
          }
          move(a, f) {
            const g = this.map, { bearingDelta: b, pitchDelta: w } = this._rotatePitchHandler.dragMove(a, f) || {};
            b && g.setBearing(g.getBearing() + b), w && g.setPitch(g.getPitch() + w);
          }
          off() {
            const a = this.element;
            k.removeEventListener(a, "mousedown", this.mousedown), k.removeEventListener(a, "touchstart", this.touchstart, { passive: !1 }), k.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), k.removeEventListener(window, "touchend", this.touchend), k.removeEventListener(a, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            k.enableDrag(), k.removeEventListener(window, "mousemove", this.mousemove), k.removeEventListener(window, "mouseup", this.mouseup), k.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), k.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let In;
        function so(v, a, f, g = !1) {
          if (g || !f.getCoveringTilesDetailsProvider().allowWorldCopies()) return v?.wrap();
          const b = new o.S(v.lng, v.lat);
          if (v = new o.S(v.lng, v.lat), a) {
            const w = new o.S(v.lng - 360, v.lat), S = new o.S(v.lng + 360, v.lat), R = f.locationToScreenPoint(v).distSqr(a);
            f.locationToScreenPoint(w).distSqr(a) < R ? v = w : f.locationToScreenPoint(S).distSqr(a) < R && (v = S);
          }
          for (; Math.abs(v.lng - f.center.lng) > 180; ) {
            const w = f.locationToScreenPoint(v);
            if (w.x >= 0 && w.y >= 0 && w.x <= f.width && w.y <= f.height) break;
            v.lng > f.center.lng ? v.lng -= 360 : v.lng += 360;
          }
          return v.lng !== b.lng && f.isPointOnMapSurface(f.locationToScreenPoint(v)) ? v : b;
        }
        const oa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Ro(v, a, f) {
          const g = v.classList;
          for (const b in oa) g.remove(`maplibregl-${f}-anchor-${b}`);
          g.add(`maplibregl-${f}-anchor-${a}`);
        }
        class wn extends o.E {
          constructor(a) {
            if (super(), this._onKeyPress = (f) => {
              const g = f.code, b = f.charCode || f.keyCode;
              g !== "Space" && g !== "Enter" && b !== 32 && b !== 13 || this.togglePopup();
            }, this._onMapClick = (f) => {
              const g = f.originalEvent.target, b = this._element;
              this._popup && (g === b || b.contains(g)) && this.togglePopup();
            }, this._update = (f) => {
              if (!this._map) return;
              const g = this._map.loaded() && !this._map.isMoving();
              (f?.type === "terrain" || f?.type === "render" && !g) && this._map.once("render", this._update), this._lngLat = so(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let b = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? b = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (b = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let w = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? w = "rotateX(0deg)" : this._pitchAlignment === "map" && (w = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || f && f.type !== "moveend" || (this._pos = this._pos.round()), k.setTransform(this._element, `${oa[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${w} ${b}`), P.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(f && f.type === "moveend");
              }).catch(() => {
              });
            }, this._onMove = (f) => {
              if (!this._isDragging) {
                const g = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = f.point.dist(this._pointerdownPos) >= g;
              }
              this._isDragging && (this._pos = f.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.l("dragstart"))), this.fire(new o.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (f) => {
              this._element.contains(f.originalEvent.target) && (f.preventDefault(), this._positionDelta = f.point.sub(this._pos).add(this._offset), this._pointerdownPos = f.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = a && a.anchor || "center", this._color = a && a.color || "#3FB1CE", this._scale = a && a.scale || 1, this._draggable = a && a.draggable || !1, this._clickTolerance = a && a.clickTolerance || 0, this._subpixelPositioning = a && a.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = a && a.rotation || 0, this._rotationAlignment = a && a.rotationAlignment || "auto", this._pitchAlignment = a && a.pitchAlignment && a.pitchAlignment !== "auto" ? a.pitchAlignment : this._rotationAlignment, this.setOpacity(a?.opacity, a?.opacityWhenCovered), a && a.element) this._element = a.element, this._offset = o.P.convert(a && a.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = k.create("div");
              const f = k.createNS("http://www.w3.org/2000/svg", "svg"), g = 41, b = 27;
              f.setAttributeNS(null, "display", "block"), f.setAttributeNS(null, "height", `${g}px`), f.setAttributeNS(null, "width", `${b}px`), f.setAttributeNS(null, "viewBox", `0 0 ${b} ${g}`);
              const w = k.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
              const S = k.createNS("http://www.w3.org/2000/svg", "g");
              S.setAttributeNS(null, "fill-rule", "nonzero");
              const R = k.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), R.setAttributeNS(null, "fill", "#000000");
              const B = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const Se of B) {
                const Me = k.createNS("http://www.w3.org/2000/svg", "ellipse");
                Me.setAttributeNS(null, "opacity", "0.04"), Me.setAttributeNS(null, "cx", "10.5"), Me.setAttributeNS(null, "cy", "5.80029008"), Me.setAttributeNS(null, "rx", Se.rx), Me.setAttributeNS(null, "ry", Se.ry), R.appendChild(Me);
              }
              const U = k.createNS("http://www.w3.org/2000/svg", "g");
              U.setAttributeNS(null, "fill", this._color);
              const j = k.createNS("http://www.w3.org/2000/svg", "path");
              j.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), U.appendChild(j);
              const X = k.createNS("http://www.w3.org/2000/svg", "g");
              X.setAttributeNS(null, "opacity", "0.25"), X.setAttributeNS(null, "fill", "#000000");
              const q = k.createNS("http://www.w3.org/2000/svg", "path");
              q.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), X.appendChild(q);
              const Q = k.createNS("http://www.w3.org/2000/svg", "g");
              Q.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Q.setAttributeNS(null, "fill", "#FFFFFF");
              const ce = k.createNS("http://www.w3.org/2000/svg", "g");
              ce.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const we = k.createNS("http://www.w3.org/2000/svg", "circle");
              we.setAttributeNS(null, "fill", "#000000"), we.setAttributeNS(null, "opacity", "0.25"), we.setAttributeNS(null, "cx", "5.5"), we.setAttributeNS(null, "cy", "5.5"), we.setAttributeNS(null, "r", "5.4999962");
              const Ae = k.createNS("http://www.w3.org/2000/svg", "circle");
              Ae.setAttributeNS(null, "fill", "#FFFFFF"), Ae.setAttributeNS(null, "cx", "5.5"), Ae.setAttributeNS(null, "cy", "5.5"), Ae.setAttributeNS(null, "r", "5.4999962"), ce.appendChild(we), ce.appendChild(Ae), S.appendChild(R), S.appendChild(U), S.appendChild(X), S.appendChild(Q), S.appendChild(ce), f.appendChild(S), f.setAttributeNS(null, "height", g * this._scale + "px"), f.setAttributeNS(null, "width", b * this._scale + "px"), this._element.appendChild(f), this._offset = o.P.convert(a && a.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (f) => {
              f.preventDefault();
            }), this._element.addEventListener("mousedown", (f) => {
              f.preventDefault();
            }), Ro(this._element, this._anchor, "marker"), a && a.className) for (const f of a.className.split(" ")) this._element.classList.add(f);
            this._popup = null;
          }
          addTo(a) {
            return this.remove(), this._map = a, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", a._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), a.getCanvasContainer().appendChild(this._element), a.on("move", this._update), a.on("moveend", this._update), a.on("terrain", this._update), a.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), k.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(a) {
            return this._lngLat = o.S.convert(a), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(a) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), a) {
              if (!("offset" in a.options)) {
                const b = Math.abs(13.5) / Math.SQRT2;
                a.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [b, -1 * (38.1 - 13.5 + b)], "bottom-right": [-b, -1 * (38.1 - 13.5 + b)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = a, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(a) {
            return this._subpixelPositioning = a, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const a = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : a ? (a.isOpen() ? a.remove() : (a.setLngLat(this._lngLat), a.addTo(this._map)), this) : this;
          }
          _updateOpacity(a = !1) {
            var f, g;
            const b = (f = this._map) === null || f === void 0 ? void 0 : f.terrain, w = this._map.transform.isLocationOccluded(this._lngLat);
            if (!b || w) {
              const Q = w ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== Q && (this._element.style.opacity = Q));
            }
            if (a) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const S = this._map, R = S.terrain.depthAtPoint(this._pos), B = S.terrain.getElevationForLngLatZoom(this._lngLat, S.transform.tileZoom);
            if (S.transform.lngLatToCameraDepth(this._lngLat, B) - R < 6e-3) return void (this._element.style.opacity = this._opacity);
            const U = -this._offset.y / S.transform.pixelsPerMeter, j = Math.sin(S.getPitch() * Math.PI / 180) * U, X = S.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)), q = S.transform.lngLatToCameraDepth(this._lngLat, B + j) - X > 6e-3;
            !((g = this._popup) === null || g === void 0) && g.isOpen() && q && this._popup.remove(), this._element.style.opacity = q ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(a) {
            return this._offset = o.P.convert(a), this._update(), this;
          }
          addClassName(a) {
            this._element.classList.add(a);
          }
          removeClassName(a) {
            this._element.classList.remove(a);
          }
          toggleClassName(a) {
            return this._element.classList.toggle(a);
          }
          setDraggable(a) {
            return this._draggable = !!a, this._map && (a ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(a) {
            return this._rotation = a || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(a) {
            return this._rotationAlignment = a || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(a) {
            return this._pitchAlignment = a && a !== "auto" ? a : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(a, f) {
            return (this._opacity === void 0 || a === void 0 && f === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), a !== void 0 && (this._opacity = a), f !== void 0 && (this._opacityWhenCovered = f), this._map && this._updateOpacity(!0), this;
          }
        }
        const Qc = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let Cl = 0, wa = !1;
        const rc = { maxWidth: 100, unit: "metric" };
        function vh(v, a, f) {
          const g = f && f.maxWidth || 100, b = v._container.clientHeight / 2, w = v._container.clientWidth / 2, S = v.unproject([w - g / 2, b]), R = v.unproject([w + g / 2, b]), B = Math.round(v.project(R).x - v.project(S).x), U = Math.min(g, B, v._container.clientWidth), j = S.distanceTo(R);
          if (f && f.unit === "imperial") {
            const X = 3.2808 * j;
            X > 5280 ? ic(a, U, X / 5280, v._getUIString("ScaleControl.Miles")) : ic(a, U, X, v._getUIString("ScaleControl.Feet"));
          } else f && f.unit === "nautical" ? ic(a, U, j / 1852, v._getUIString("ScaleControl.NauticalMiles")) : j >= 1e3 ? ic(a, U, j / 1e3, v._getUIString("ScaleControl.Kilometers")) : ic(a, U, j, v._getUIString("ScaleControl.Meters"));
        }
        function ic(v, a, f, g) {
          const b = function(w) {
            const S = Math.pow(10, `${Math.floor(w)}`.length - 1);
            let R = w / S;
            return R = R >= 10 ? 10 : R >= 5 ? 5 : R >= 3 ? 3 : R >= 2 ? 2 : R >= 1 ? 1 : function(B) {
              const U = Math.pow(10, Math.ceil(-Math.log(B) / Math.LN10));
              return Math.round(B * U) / U;
            }(R), S * R;
          }(f);
          v.style.width = a * (b / f) + "px", v.innerHTML = `${b}&nbsp;${g}`;
        }
        const Gu = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, Aa = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function xh(v) {
          if (v) {
            if (typeof v == "number") {
              const a = Math.round(Math.abs(v) / Math.SQRT2);
              return { center: new o.P(0, 0), top: new o.P(0, v), "top-left": new o.P(a, a), "top-right": new o.P(-a, a), bottom: new o.P(0, -v), "bottom-left": new o.P(a, -a), "bottom-right": new o.P(-a, -a), left: new o.P(v, 0), right: new o.P(-v, 0) };
            }
            if (v instanceof o.P || Array.isArray(v)) {
              const a = o.P.convert(v);
              return { center: a, top: a, "top-left": a, "top-right": a, bottom: a, "bottom-left": a, "bottom-right": a, left: a, right: a };
            }
            return { center: o.P.convert(v.center || [0, 0]), top: o.P.convert(v.top || [0, 0]), "top-left": o.P.convert(v["top-left"] || [0, 0]), "top-right": o.P.convert(v["top-right"] || [0, 0]), bottom: o.P.convert(v.bottom || [0, 0]), "bottom-left": o.P.convert(v["bottom-left"] || [0, 0]), "bottom-right": o.P.convert(v["bottom-right"] || [0, 0]), left: o.P.convert(v.left || [0, 0]), right: o.P.convert(v.right || [0, 0]) };
          }
          return xh(new o.P(0, 0));
        }
        const wh = d;
        c.AJAXError = o.cz, c.Event = o.l, c.Evented = o.E, c.LngLat = o.S, c.MercatorCoordinate = o.a1, c.Point = o.P, c.addProtocol = o.cA, c.config = o.a, c.removeProtocol = o.cB, c.AttributionControl = Bi, c.BoxZoomHandler = z, c.CanvasSource = xr, c.CooperativeGesturesHandler = fn, c.DoubleClickZoomHandler = Wr, c.DragPanHandler = Vi, c.DragRotateHandler = Xn, c.EdgeInsets = Er, c.FullscreenControl = class extends o.E {
          constructor(v = {}) {
            super(), this._onFullscreenChange = () => {
              var a;
              let f = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((a = f?.shadowRoot) === null || a === void 0) && a.fullscreenElement; ) f = f.shadowRoot.fullscreenElement;
              f === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(v) {
            return this._map = v, this._container || (this._container = this._map.getContainer()), this._controlContainer = k.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            k.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const v = this._fullscreenButton = k.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            k.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"), v.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const v = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", v), this._fullscreenButton.title = v;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, c.GeoJSONSource = Sr, c.GeolocateControl = class extends o.E {
          constructor(v) {
            super(), this._onSuccess = (a) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(a)) return this._setErrorState(), this.fire(new o.l("outofmaxbounds", a)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = a, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(a), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(a), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.l("geolocate", a)), this._finish();
              }
            }, this._updateCamera = (a) => {
              const f = new o.S(a.coords.longitude, a.coords.latitude), g = a.coords.accuracy, b = this._map.getBearing(), w = o.e({ bearing: b }, this.options.fitBoundsOptions), S = Oe.fromLngLat(f, g);
              this._map.fitBounds(S, w, { geolocateSource: !0 });
            }, this._updateMarker = (a) => {
              if (a) {
                const f = new o.S(a.coords.longitude, a.coords.latitude);
                this._accuracyCircleMarker.setLngLat(f).addTo(this._map), this._userLocationDotMarker.setLngLat(f).addTo(this._map), this._accuracy = a.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (a) => {
              if (this._map) {
                if (a.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const f = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = f, this._geolocateButton.setAttribute("aria-label", f), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (a.code === 3 && wa) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.l("error", a)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this._geolocateButton = k.create("button", "maplibregl-ctrl-geolocate", this._container), k.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (a) => {
              if (this._map) {
                if (a === !1) {
                  o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const f = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = f, this._geolocateButton.setAttribute("aria-label", f);
                } else {
                  const f = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = f, this._geolocateButton.setAttribute("aria-label", f);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = k.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new wn({ element: this._dotElement }), this._circleElement = k.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new wn({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (f) => {
                  const g = f?.[0] instanceof ResizeObserverEntry;
                  f.geolocateSource || this._watchState !== "ACTIVE_LOCK" || g || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.l("trackuserlocationend")), this.fire(new o.l("userlocationlostfocus")));
                });
              }
            }, this.options = o.e({}, Qc, v);
          }
          onAdd(v) {
            return this._map = v, this._container = k.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
              return o._(this, arguments, void 0, function* (a = !1) {
                if (In !== void 0 && !a) return In;
                if (window.navigator.permissions === void 0) return In = !!window.navigator.geolocation, In;
                try {
                  In = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  In = !!window.navigator.geolocation;
                }
                return In;
              });
            }().then((a) => this._finishSetupUI(a)), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), k.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Cl = 0, wa = !1;
          }
          _isOutOfMapMaxBounds(v) {
            const a = this._map.getMaxBounds(), f = v.coords;
            return a && (f.longitude < a.getWest() || f.longitude > a.getEast() || f.latitude < a.getSouth() || f.latitude > a.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const v = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && v)) return;
            const a = this._map.project(v), f = this._map.unproject([a.x + 100, a.y]), g = v.distanceTo(f) / 100, b = 2 * this._accuracy / g;
            this._circleElement.style.width = `${b.toFixed(2)}px`, this._circleElement.style.height = `${b.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Cl--, wa = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.l("trackuserlocationstart")), this.fire(new o.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let v;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Cl++, Cl > 1 ? (v = { maximumAge: 6e5, timeout: 0 }, wa = !0) : (v = this.options.positionOptions, wa = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, c.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var v;
              const a = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
              this._map.setProjection(a !== "mercator" && a ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var v;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(v) {
            return this._map = v, this._container = k.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = k.create("button", "maplibregl-ctrl-globe", this._container), k.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            k.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, c.Hash = xa, c.ImageSource = hr, c.KeyboardHandler = xi, c.LngLatBounds = Oe, c.LogoControl = On, c.Map = class extends cr {
          constructor(v) {
            var a, f;
            o.cw.mark(o.cx.create);
            const g = Object.assign(Object.assign(Object.assign({}, Ai), v), { canvasContextAttributes: Object.assign(Object.assign({}, Ai.canvasContextAttributes), v.canvasContextAttributes) });
            if (g.minZoom != null && g.maxZoom != null && g.minZoom > g.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (g.minPitch != null && g.maxPitch != null && g.minPitch > g.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (g.minPitch != null && g.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (g.maxPitch != null && g.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const b = new Hn(), w = new ki();
            if (g.minZoom !== void 0 && b.setMinZoom(g.minZoom), g.maxZoom !== void 0 && b.setMaxZoom(g.maxZoom), g.minPitch !== void 0 && b.setMinPitch(g.minPitch), g.maxPitch !== void 0 && b.setMaxPitch(g.maxPitch), g.renderWorldCopies !== void 0 && b.setRenderWorldCopies(g.renderWorldCopies), g.transformConstrain !== null && b.setConstrain(g.transformConstrain), super(b, w, { bearingSnap: g.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new ln(), this._controls = [], this._mapId = o.a7(), this._contextLost = (R) => {
              R.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.l("webglcontextlost", { originalEvent: R }));
            }, this._contextRestored = (R) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new o.l("webglcontextrestored", { originalEvent: R }));
            }, this._onMapScroll = (R) => {
              if (R.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = g.interactive, this._maxTileCacheSize = g.maxTileCacheSize, this._maxTileCacheZoomLevels = g.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, g.canvasContextAttributes), this._trackResize = g.trackResize === !0, this._bearingSnap = g.bearingSnap, this._centerClampedToGround = g.centerClampedToGround, this._refreshExpiredTiles = g.refreshExpiredTiles === !0, this._fadeDuration = g.fadeDuration, this._crossSourceCollisions = g.crossSourceCollisions === !0, this._collectResourceTiming = g.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, gs), g.locale), this._clickTolerance = g.clickTolerance, this._overridePixelRatio = g.pixelRatio, this._maxCanvasSize = g.maxCanvasSize, this.transformCameraUpdate = g.transformCameraUpdate, this.transformConstrain = g.transformConstrain, this.cancelPendingTileRequestsWhileZooming = g.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = re.addThrottleControl(() => this.isMoving()), this._requestManager = new be(g.transformRequest), typeof g.container == "string") {
              if (this._container = document.getElementById(g.container), !this._container) throw new Error(`Container '${g.container}' not found.`);
            } else {
              if (!(g.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = g.container;
            }
            if (g.maxBounds && this.setMaxBounds(g.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            }), this.once("idle", () => {
              this._idleTriggered = !0;
            }), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let R = !1;
              const B = tc((U) => {
                this._trackResize && !this._removed && (this.resize(U), this.redraw());
              }, 50);
              this._resizeObserver = new ResizeObserver((U) => {
                R ? B(U) : R = !0;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Qt(this, g), this._hash = g.hash && new xa(typeof g.hash == "string" && g.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: g.center, elevation: g.elevation, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch, roll: g.roll }), g.bounds && (this.resize(), this.fitBounds(g.bounds, o.e({}, g.fitBoundsOptions, { duration: 0 }))));
            const S = typeof g.style == "string" || ((f = (a = g.style) === null || a === void 0 ? void 0 : a.projection) === null || f === void 0 ? void 0 : f.type) !== "globe";
            this.resize(null, S), this._localIdeographFontFamily = g.localIdeographFontFamily, this._validateStyle = g.validateStyle, g.style && this.setStyle(g.style, { localIdeographFontFamily: g.localIdeographFontFamily }), g.attributionControl && this.addControl(new Bi(typeof g.attributionControl == "boolean" ? void 0 : g.attributionControl)), g.maplibreLogo && this.addControl(new On(), g.logoPosition), this.on("style.load", () => {
              if (S || this._resizeTransform(), this.transform.unmodified) {
                const R = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(R);
              }
            }), this.on("data", (R) => {
              this._update(R.dataType === "style"), this.fire(new o.l(`${R.dataType}data`, R));
            }), this.on("dataloading", (R) => {
              this.fire(new o.l(`${R.dataType}dataloading`, R));
            }), this.on("dataabort", (R) => {
              this.fire(new o.l("sourcedataabort", R));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(v, a) {
            return this.style.setGlobalStateProperty(v, a), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(v, a) {
            if (a === void 0 && (a = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"), !v || !v.onAdd) return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const f = v.onAdd(this);
            this._controls.push(v);
            const g = this._controlPositions[a];
            return a.indexOf("bottom") !== -1 ? g.insertBefore(f, g.firstChild) : g.appendChild(f), this;
          }
          removeControl(v) {
            if (!v || !v.onRemove) return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = this._controls.indexOf(v);
            return a > -1 && this._controls.splice(a, 1), v.onRemove(this), this;
          }
          hasControl(v) {
            return this._controls.indexOf(v) > -1;
          }
          coveringTiles(v) {
            return fr(this.transform, v);
          }
          calculateCameraOptionsFromTo(v, a, f, g) {
            return g == null && this.terrain && (g = this.terrain.getElevationForLngLatZoom(f, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(v, a, f, g);
          }
          resize(v, a = !0) {
            const [f, g] = this._containerDimensions(), b = this._getClampedPixelRatio(f, g);
            if (this._resizeCanvas(f, g, b), this.painter.resize(f, g, b), this.painter.overLimit()) {
              const S = this.painter.context.gl;
              this._maxCanvasSize = [S.drawingBufferWidth, S.drawingBufferHeight];
              const R = this._getClampedPixelRatio(f, g);
              this._resizeCanvas(f, g, R), this.painter.resize(f, g, R);
            }
            this._resizeTransform(a);
            const w = !this._moving;
            return w && (this.stop(), this.fire(new o.l("movestart", v)).fire(new o.l("move", v))), this.fire(new o.l("resize", v)), w && this.fire(new o.l("moveend", v)), this;
          }
          _resizeTransform(v = !0) {
            var a;
            const [f, g] = this._containerDimensions();
            this.transform.resize(f, g, v), (a = this._requestedCameraState) === null || a === void 0 || a.resize(f, g, v);
          }
          _getClampedPixelRatio(v, a) {
            const { 0: f, 1: g } = this._maxCanvasSize, b = this.getPixelRatio(), w = v * b, S = a * b;
            return Math.min(w > f ? f / w : 1, S > g ? g / S : 1) * b;
          }
          getPixelRatio() {
            var v;
            return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio;
          }
          setPixelRatio(v) {
            this._overridePixelRatio = v, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(v) {
            return this.transform.setMaxBounds(Oe.convert(v)), this._update();
          }
          setMinZoom(v) {
            if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom) return this.transform.setMinZoom(v), this._update(), this.getZoom() < v && this.setZoom(v), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(v) {
            if ((v = v ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(v), this._update(), this.getZoom() > v && this.setZoom(v), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(v) {
            if ((v = v ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (v >= 0 && v <= this.transform.maxPitch) return this.transform.setMinPitch(v), this._update(), this.getPitch() < v && this.setPitch(v), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(v) {
            if ((v = v ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (v >= this.transform.minPitch) return this.transform.setMaxPitch(v), this._update(), this.getPitch() > v && this.setPitch(v), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(v) {
            return this.transform.setRenderWorldCopies(v), this._update();
          }
          setTransformConstrain(v) {
            return this.transform.setConstrain(v), this._update();
          }
          project(v) {
            return this.transform.locationToScreenPoint(o.S.convert(v), this.style && this.terrain);
          }
          unproject(v) {
            return this.transform.screenPointToLocation(o.P.convert(v), this.terrain);
          }
          isMoving() {
            var v;
            return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving());
          }
          isZooming() {
            var v;
            return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming());
          }
          isRotating() {
            var v;
            return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating());
          }
          _createDelegatedListener(v, a, f) {
            if (v === "mouseenter" || v === "mouseover") {
              let g = !1;
              return { layers: a, listener: f, delegates: { mousemove: (w) => {
                const S = a.filter((B) => this.getLayer(B)), R = S.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: S }) : [];
                R.length ? g || (g = !0, f.call(this, new ds(v, this, w.originalEvent, { features: R }))) : g = !1;
              }, mouseout: () => {
                g = !1;
              } } };
            }
            if (v === "mouseleave" || v === "mouseout") {
              let g = !1;
              return { layers: a, listener: f, delegates: { mousemove: (S) => {
                const R = a.filter((B) => this.getLayer(B));
                (R.length !== 0 ? this.queryRenderedFeatures(S.point, { layers: R }) : []).length ? g = !0 : g && (g = !1, f.call(this, new ds(v, this, S.originalEvent)));
              }, mouseout: (S) => {
                g && (g = !1, f.call(this, new ds(v, this, S.originalEvent)));
              } } };
            }
            {
              const g = (b) => {
                const w = a.filter((R) => this.getLayer(R)), S = w.length !== 0 ? this.queryRenderedFeatures(b.point, { layers: w }) : [];
                S.length && (b.features = S, f.call(this, b), delete b.features);
              };
              return { layers: a, listener: f, delegates: { [v]: g } };
            }
          }
          _saveDelegatedListener(v, a) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[v] = this._delegatedListeners[v] || [], this._delegatedListeners[v].push(a);
          }
          _removeDelegatedListener(v, a, f) {
            if (!this._delegatedListeners || !this._delegatedListeners[v]) return;
            const g = this._delegatedListeners[v];
            for (let b = 0; b < g.length; b++) {
              const w = g[b];
              if (w.listener === f && w.layers.length === a.length && w.layers.every((S) => a.includes(S))) {
                for (const S in w.delegates) this.off(S, w.delegates[S]);
                return void g.splice(b, 1);
              }
            }
          }
          on(v, a, f) {
            if (f === void 0) return super.on(v, a);
            const g = typeof a == "string" ? [a] : a, b = this._createDelegatedListener(v, g, f);
            this._saveDelegatedListener(v, b);
            for (const w in b.delegates) this.on(w, b.delegates[w]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(v, g, f);
            } };
          }
          once(v, a, f) {
            if (f === void 0) return super.once(v, a);
            const g = typeof a == "string" ? [a] : a, b = this._createDelegatedListener(v, g, f);
            for (const w in b.delegates) {
              const S = b.delegates[w];
              b.delegates[w] = (...R) => {
                this._removeDelegatedListener(v, g, f), S(...R);
              };
            }
            this._saveDelegatedListener(v, b);
            for (const w in b.delegates) this.once(w, b.delegates[w]);
            return this;
          }
          off(v, a, f) {
            return f === void 0 ? super.off(v, a) : (this._removeDelegatedListener(v, typeof a == "string" ? [a] : a, f), this);
          }
          queryRenderedFeatures(v, a) {
            if (!this.style) return [];
            let f;
            const g = v instanceof o.P || Array.isArray(v), b = g ? v : [[0, 0], [this.transform.width, this.transform.height]];
            if (a = a || (g ? {} : v) || {}, b instanceof o.P || typeof b[0] == "number") f = [o.P.convert(b)];
            else {
              const w = o.P.convert(b[0]), S = o.P.convert(b[1]);
              f = [w, new o.P(S.x, w.y), S, new o.P(w.x, S.y), w];
            }
            return this.style.queryRenderedFeatures(f, a, this.transform);
          }
          querySourceFeatures(v, a) {
            return this.style.querySourceFeatures(v, a);
          }
          setStyle(v, a) {
            return (a = o.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, a)).diff !== !1 && a.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, a), this) : (this._localIdeographFontFamily = a.localIdeographFontFamily, this._updateStyle(v, a));
          }
          setTransformRequest(v) {
            return this._requestManager.setTransformRequest(v), this;
          }
          _getUIString(v) {
            const a = this._locale[v];
            if (a == null) throw new Error(`Missing UI string '${v}'`);
            return a;
          }
          _updateStyle(v, a) {
            var f, g;
            if (a.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(v, a));
            const b = this.style && a.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!v)), v ? (this.style = new Eo(this, a || {}), this.style.setEventedParent(this, { style: this.style }), typeof v == "string" ? this.style.loadURL(v, a, b) : this.style.loadJSON(v, a, b), this) : ((g = (f = this.style) === null || f === void 0 ? void 0 : f.projection) === null || g === void 0 || g.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Eo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(v, a) {
            if (typeof v == "string") {
              const f = this._requestManager.transformRequest(v, "Style");
              o.j(f, new AbortController()).then((g) => {
                this._updateDiff(g.data, a);
              }).catch((g) => {
                g && this.fire(new o.k(g));
              });
            } else typeof v == "object" && this._updateDiff(v, a);
          }
          _updateDiff(v, a) {
            try {
              this.style.setState(v, a) && this._update(!0);
            } catch (f) {
              o.w(`Unable to perform style diff: ${f.message || f.error || f}.  Rebuilding the style from scratch.`), this._updateStyle(v, a);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : o.w("There is no style added to the map.");
          }
          addSource(v, a) {
            return this._lazyInitEmptyStyle(), this.style.addSource(v, a), this._update(!0);
          }
          isSourceLoaded(v) {
            const a = this.style && this.style.sourceCaches[v];
            if (a !== void 0) return a.loaded();
            this.fire(new o.k(new Error(`There is no source with ID '${v}'`)));
          }
          setTerrain(v) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), v) {
              const a = this.style.sourceCaches[v.source];
              if (!a) throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
              this.terrain === null && a.reload();
              for (const f in this.style._layers) {
                const g = this.style._layers[f];
                g.type === "hillshade" && g.source === v.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), g.type === "color-relief" && g.source === v.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Gi(this.painter, a, v), this.painter.renderToTexture = new Hs(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (f) => {
                var g;
                f.dataType === "style" ? this.terrain.sourceCache.freeRtt() : f.dataType === "source" && f.tile && (f.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((g = f.source) === null || g === void 0 ? void 0 : g.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(f.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new o.l("terrain", { terrain: v })), this;
          }
          getTerrain() {
            var v, a;
            return (a = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && a !== void 0 ? a : null;
          }
          areTilesLoaded() {
            const v = this.style && this.style.sourceCaches;
            for (const a in v) {
              const f = v[a]._tiles;
              for (const g in f) {
                const b = f[g];
                if (b.state !== "loaded" && b.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(v) {
            return this.style.removeSource(v), this._update(!0);
          }
          getSource(v) {
            return this.style.getSource(v);
          }
          setSourceTileLodParams(v, a, f) {
            if (f) {
              const g = this.getSource(f);
              if (!g) throw new Error(`There is no source with ID "${f}", cannot set LOD parameters`);
              g.calculateTileZoom = We(Math.max(1, v), Math.max(1, a));
            } else for (const g in this.style.sourceCaches) this.style.sourceCaches[g].getSource().calculateTileZoom = We(Math.max(1, v), Math.max(1, a));
            return this._update(!0), this;
          }
          refreshTiles(v, a) {
            const f = this.style.sourceCaches[v];
            if (!f) throw new Error(`There is no source cache with ID "${v}", cannot refresh tile`);
            a === void 0 ? f.reload(!0) : f.refreshTiles(a.map((g) => new o.a4(g.z, g.x, g.y)));
          }
          addImage(v, a, f = {}) {
            const { pixelRatio: g = 1, sdf: b = !1, stretchX: w, stretchY: S, content: R, textFitWidth: B, textFitHeight: U } = f;
            if (this._lazyInitEmptyStyle(), !(a instanceof HTMLImageElement || o.b(a))) {
              if (a.width === void 0 || a.height === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: j, height: X, data: q } = a, Q = a;
                return this.style.addImage(v, { data: new o.R({ width: j, height: X }, new Uint8Array(q)), pixelRatio: g, stretchX: w, stretchY: S, content: R, textFitWidth: B, textFitHeight: U, sdf: b, version: 0, userImage: Q }), Q.onAdd && Q.onAdd(this, v), this;
              }
            }
            {
              const { width: j, height: X, data: q } = P.getImageData(a);
              this.style.addImage(v, { data: new o.R({ width: j, height: X }, q), pixelRatio: g, stretchX: w, stretchY: S, content: R, textFitWidth: B, textFitHeight: U, sdf: b, version: 0 });
            }
          }
          updateImage(v, a) {
            const f = this.style.getImage(v);
            if (!f) return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const g = a instanceof HTMLImageElement || o.b(a) ? P.getImageData(a) : a, { width: b, height: w, data: S } = g;
            if (b === void 0 || w === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (b !== f.data.width || w !== f.data.height) return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const R = !(a instanceof HTMLImageElement || o.b(a));
            return f.data.replace(S, R), this.style.updateImage(v, f), this;
          }
          getImage(v) {
            return this.style.getImage(v);
          }
          hasImage(v) {
            return v ? !!this.style.getImage(v) : (this.fire(new o.k(new Error("Missing required image id"))), !1);
          }
          removeImage(v) {
            this.style.removeImage(v);
          }
          loadImage(v) {
            return re.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(v, a) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(v, a), this._update(!0);
          }
          moveLayer(v, a) {
            return this.style.moveLayer(v, a), this._update(!0);
          }
          removeLayer(v) {
            return this.style.removeLayer(v), this._update(!0);
          }
          getLayer(v) {
            return this.style.getLayer(v);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(v, a, f) {
            return this.style.setLayerZoomRange(v, a, f), this._update(!0);
          }
          setFilter(v, a, f = {}) {
            return this.style.setFilter(v, a, f), this._update(!0);
          }
          getFilter(v) {
            return this.style.getFilter(v);
          }
          setPaintProperty(v, a, f, g = {}) {
            return this.style.setPaintProperty(v, a, f, g), this._update(!0);
          }
          getPaintProperty(v, a) {
            return this.style.getPaintProperty(v, a);
          }
          setLayoutProperty(v, a, f, g = {}) {
            return this.style.setLayoutProperty(v, a, f, g), this._update(!0);
          }
          getLayoutProperty(v, a) {
            return this.style.getLayoutProperty(v, a);
          }
          setGlyphs(v, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(v, a), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(v, a, f = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(v, a, f, (g) => {
              g || this._update(!0);
            }), this;
          }
          removeSprite(v) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(v), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(v, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(v, a, (f) => {
              f || this._update(!0);
            }), this;
          }
          setLight(v, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(v, a), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(v, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(v, a), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(v, a) {
            return this.style.setFeatureState(v, a), this._update();
          }
          removeFeatureState(v, a) {
            return this.style.removeFeatureState(v, a), this._update();
          }
          getFeatureState(v) {
            return this.style.getFeatureState(v);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let v = 0, a = 0;
            return this._container && (v = this._container.clientWidth || 400, a = this._container.clientHeight || 300), [v, a];
          }
          _setupContainer() {
            const v = this._container;
            v.classList.add("maplibregl-map");
            const a = this._canvasContainer = k.create("div", "maplibregl-canvas-container", v);
            this._interactive && a.classList.add("maplibregl-interactive"), this._canvas = k.create("canvas", "maplibregl-canvas", a), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const f = this._containerDimensions(), g = this._getClampedPixelRatio(f[0], f[1]);
            this._resizeCanvas(f[0], f[1], g);
            const b = this._controlContainer = k.create("div", "maplibregl-control-container", v), w = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((S) => {
              w[S] = k.create("div", `maplibregl-ctrl-${S} `, b);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(v, a, f) {
            this._canvas.width = Math.floor(f * v), this._canvas.height = Math.floor(f * a), this._canvas.style.width = `${v}px`, this._canvas.style.height = `${a}px`;
          }
          _setupPainter() {
            const v = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let a = null;
            this._canvas.addEventListener("webglcontextcreationerror", (g) => {
              a = { requestedAttributes: v }, g && (a.statusMessage = g.statusMessage, a.type = g.type);
            }, { once: !0 });
            let f = null;
            if (f = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v), !f) {
              const g = "Failed to initialize WebGL";
              throw a ? (a.message = g, new Error(JSON.stringify(a))) : new Error(g);
            }
            this.painter = new Vu(f, this.transform), $.testSupport(f);
          }
          migrateProjection(v, a) {
            super.migrateProjection(v, a), this.painter.transform = v, this.fire(new o.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(v) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(v) {
            return this._update(), this._renderTaskQueue.add(v);
          }
          _cancelRenderFrame(v) {
            this._renderTaskQueue.remove(v);
          }
          _render(v) {
            var a, f, g, b, w;
            const S = this._idleTriggered ? this._fadeDuration : 0, R = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(v), this._removed) return;
            let B = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const X = this.transform.zoom, q = D();
              this.style.zoomHistory.update(X, q);
              const Q = new o.F(X, { now: q, fadeDuration: S, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), ce = Q.crossFadingFactor();
              ce === 1 && ce === this._crossFadingFactor || (B = !0, this._crossFadingFactor = ce), this.style.update(Q);
            }
            const U = ((f = this.style.projection) === null || f === void 0 ? void 0 : f.transitionState) > 0 !== R;
            (g = this.style.projection) === null || g === void 0 || g.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((b = this.style.projection) === null || b === void 0 ? void 0 : b.transitionState, (w = this.style.projection) === null || w === void 0 ? void 0 : w.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || U) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, S, this._crossSourceCollisions, U), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: S, showPadding: this.showPadding }), this.fire(new o.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.cw.mark(o.cx.load), this.fire(new o.l("load"))), this.style && (this.style.hasTransitions() || B) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const j = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return j || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")), !this._loaded || this._fullyLoaded || j || (this._fullyLoaded = !0, o.cw.mark(o.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var v;
            this._hash && this._hash.remove();
            for (const f of this._controls) f.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), re.removeThrottleControl(this._imageQueueHandle), (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
            const a = this.painter.context.gl.getExtension("WEBGL_lose_context");
            a?.loseContext && a.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), k.remove(this._canvasContainer), k.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), o.cw.clearMetrics(), this._removed = !0, this.fire(new o.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), P.frame(this._frameRequest, (v) => {
              o.cw.frame(v), this._frameRequest = null;
              try {
                this._render(v);
              } catch (a) {
                if (!o.cy(a) && !function(f) {
                  return f.message === Du;
                }(a)) throw a;
              }
            }, () => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(v) {
            this._showTileBoundaries !== v && (this._showTileBoundaries = v, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(v) {
            this._showPadding !== v && (this._showPadding = v, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(v) {
            this._showCollisionBoxes !== v && (this._showCollisionBoxes = v, v ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(v) {
            this._showOverdrawInspector !== v && (this._showOverdrawInspector = v, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(v) {
            this._repaint !== v && (this._repaint = v, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(v) {
            this._vertices = v, this._update();
          }
          get version() {
            return wi;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(v) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(v), this._update(!0);
          }
        }, c.MapMouseEvent = ds, c.MapTouchEvent = Es, c.MapWheelEvent = Mo, c.Marker = wn, c.NavigationControl = class {
          constructor(v) {
            this._updateZoomButtons = () => {
              const a = this._map.getZoom(), f = a === this._map.getMaxZoom(), g = a === this._map.getMinZoom();
              this._zoomInButton.disabled = f, this._zoomOutButton.disabled = g, this._zoomInButton.setAttribute("aria-disabled", f.toString()), this._zoomOutButton.setAttribute("aria-disabled", g.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (a, f) => {
              const g = this._map._getUIString(`NavigationControl.${f}`);
              a.title = g, a.setAttribute("aria-label", g);
            }, this.options = o.e({}, no, v), this._container = k.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (a) => this._map.zoomIn({}, { originalEvent: a })), k.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (a) => this._map.zoomOut({}, { originalEvent: a })), k.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (a) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: a }) : this._map.resetNorth({}, { originalEvent: a });
            }), this._compassIcon = k.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(v) {
            return this._map = v, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Di(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            k.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(v, a) {
            const f = k.create("button", v, this._container);
            return f.type = "button", f.addEventListener("click", a), f;
          }
        }, c.Popup = class extends o.E {
          constructor(v) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && k.remove(this._content), this._container && (k.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.l("close"))), this), this._onMouseUp = (a) => {
              this._update(a.point);
            }, this._onMouseMove = (a) => {
              this._update(a.point);
            }, this._onDrag = (a) => {
              this._update(a.point);
            }, this._update = (a) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = k.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = k.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const S of this.options.className.split(" ")) this._container.classList.add(S);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = so(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !a) return;
              const f = this._flatPos = this._pos = this._trackPointer && a ? a : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && a ? a : this._map.transform.locationToScreenPoint(this._lngLat));
              let g = this.options.anchor;
              const b = xh(this.options.offset);
              if (!g) {
                const S = this._container.offsetWidth, R = this._container.offsetHeight;
                let B;
                B = f.y + b.bottom.y < R ? ["top"] : f.y > this._map.transform.height - R ? ["bottom"] : [], f.x < S / 2 ? B.push("left") : f.x > this._map.transform.width - S / 2 && B.push("right"), g = B.length === 0 ? "bottom" : B.join("-");
              }
              let w = f.add(b[g]);
              this.options.subpixelPositioning || (w = w.round()), k.setTransform(this._container, `${oa[g]} translate(${w.x}px,${w.y}px)`), Ro(this._container, g, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = o.e(Object.create(Gu), v);
          }
          addTo(v) {
            return this._map && this.remove(), this._map = v, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(v) {
            return this._lngLat = o.S.convert(v), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(v) {
            return this.setDOMContent(document.createTextNode(v));
          }
          setHTML(v) {
            const a = document.createDocumentFragment(), f = document.createElement("body");
            let g;
            for (f.innerHTML = v; g = f.firstChild, g; ) a.appendChild(g);
            return this.setDOMContent(a);
          }
          getMaxWidth() {
            var v;
            return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth;
          }
          setMaxWidth(v) {
            return this.options.maxWidth = v, this._update(), this;
          }
          setDOMContent(v) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = k.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(v), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(v) {
            return this._container && this._container.classList.add(v), this;
          }
          removeClassName(v) {
            return this._container && this._container.classList.remove(v), this;
          }
          setOffset(v) {
            return this.options.offset = v, this._update(), this;
          }
          toggleClassName(v) {
            if (this._container) return this._container.classList.toggle(v);
          }
          setSubpixelPositioning(v) {
            this.options.subpixelPositioning = v;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = k.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const v = this._container.querySelector(Aa);
            v && v.focus();
          }
        }, c.RasterDEMTileSource = Jt, c.RasterTileSource = Rr, c.ScaleControl = class {
          constructor(v) {
            this._onMove = () => {
              vh(this._map, this._container, this.options);
            }, this.setUnit = (a) => {
              this.options.unit = a, vh(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, rc), v);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(v) {
            return this._map = v, this._container = k.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            k.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, c.ScrollZoomHandler = lr, c.Style = Eo, c.TerrainControl = class {
          constructor(v) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = v;
          }
          onAdd(v) {
            return this._map = v, this._container = k.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = k.create("button", "maplibregl-ctrl-terrain", this._container), k.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            k.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, c.TwoFingersTouchPitchHandler = si, c.TwoFingersTouchRotateHandler = Br, c.TwoFingersTouchZoomHandler = Kt, c.TwoFingersTouchZoomRotateHandler = ps, c.VectorTileSource = Zr, c.VideoSource = qr, c.addSourceType = (v, a) => o._(void 0, void 0, void 0, function* () {
          if (Yr(v)) throw new Error(`A source type called "${v}" already exists.`);
          ((f, g) => {
            bi[f] = g;
          })(v, a);
        }), c.clearPrewarmedResources = function() {
          const v = Ke;
          v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(fe), Ke = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, c.createTileMesh = ra, c.getMaxParallelImageRequests = function() {
          return o.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, c.getRTLTextPluginStatus = function() {
          return wr().getRTLTextPluginStatus();
        }, c.getVersion = function() {
          return wh;
        }, c.getWorkerCount = function() {
          return De.workerCount;
        }, c.getWorkerUrl = function() {
          return o.a.WORKER_URL;
        }, c.importScriptInWorkers = function(v) {
          return Tt().broadcast("IS", v);
        }, c.isTimeFrozen = function() {
          return I.isFrozen();
        }, c.prewarm = function() {
          at().acquire(fe);
        }, c.restoreNow = function() {
          I.restoreNow();
        }, c.setMaxParallelImageRequests = function(v) {
          o.a.MAX_PARALLEL_IMAGE_REQUESTS = v;
        }, c.setNow = function(v) {
          I.setNow(v);
        }, c.setRTLTextPlugin = function(v, a) {
          return wr().setRTLTextPlugin(v, a);
        }, c.setWorkerCount = function(v) {
          De.workerCount = v;
        }, c.setWorkerUrl = function(v) {
          o.a.WORKER_URL = v;
        };
      });
      var s = t;
      return s;
    });
  }(F_)), F_.exports;
}
var g5 = bB();
const Zs = /* @__PURE__ */ p2(g5), Bf = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]), nh = 4, ag = 4, lg = 4, lm = 4, Dh = new Int32Array(2), jA = new Float32Array(Dh.buffer), VA = new Float64Array(Dh.buffer), Hm = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var Q1;
(function(r) {
  r[r.UTF8_BYTES = 1] = "UTF8_BYTES", r[r.UTF16_STRING = 2] = "UTF16_STRING";
})(Q1 || (Q1 = {}));
class ah {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(e) {
    this.bytes_ = e, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(e) {
    return new ah(new Uint8Array(e));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(e) {
    this.position_ = e;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(e) {
    return this.readUint8(e) << 24 >> 24;
  }
  readUint8(e) {
    return this.bytes_[e];
  }
  readInt16(e) {
    return this.readUint16(e) << 16 >> 16;
  }
  readUint16(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8;
  }
  readInt32(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
  }
  readUint32(e) {
    return this.readInt32(e) >>> 0;
  }
  readInt64(e) {
    return BigInt.asIntN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readUint64(e) {
    return BigInt.asUintN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readFloat32(e) {
    return Dh[0] = this.readInt32(e), jA[0];
  }
  readFloat64(e) {
    return Dh[Hm ? 0 : 1] = this.readInt32(e), Dh[Hm ? 1 : 0] = this.readInt32(e + 4), VA[0];
  }
  writeInt8(e, t) {
    this.bytes_[e] = t;
  }
  writeUint8(e, t) {
    this.bytes_[e] = t;
  }
  writeInt16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeUint16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeInt32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeUint32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeInt64(e, t) {
    this.writeInt32(e, Number(BigInt.asIntN(32, t))), this.writeInt32(e + 4, Number(BigInt.asIntN(32, t >> BigInt(32))));
  }
  writeUint64(e, t) {
    this.writeUint32(e, Number(BigInt.asUintN(32, t))), this.writeUint32(e + 4, Number(BigInt.asUintN(32, t >> BigInt(32))));
  }
  writeFloat32(e, t) {
    jA[0] = t, this.writeInt32(e, Dh[0]);
  }
  writeFloat64(e, t) {
    VA[0] = t, this.writeInt32(e, Dh[Hm ? 0 : 1]), this.writeInt32(e + 4, Dh[Hm ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + ag + lg)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let e = "";
    for (let t = 0; t < lg; t++)
      e += String.fromCharCode(this.readInt8(this.position_ + ag + t));
    return e;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(e, t) {
    const i = e - this.readInt32(e);
    return t < this.readInt16(i) ? this.readInt16(i + t) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(e, t) {
    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(e, t) {
    e += this.readInt32(e);
    const i = this.readInt32(e);
    e += ag;
    const n = this.bytes_.subarray(e, e + i);
    return t === Q1.UTF8_BYTES ? n : this.text_decoder_.decode(n);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(e, t) {
    return typeof e == "string" ? this.__string(t) : this.__union(e, t);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(e) {
    return e + this.readInt32(e);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(e) {
    return e + this.readInt32(e) + ag;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(e) {
    return this.readInt32(e + this.readInt32(e));
  }
  __has_identifier(e) {
    if (e.length != lg)
      throw new Error("FlatBuffers: file identifier must be length " + lg);
    for (let t = 0; t < lg; t++)
      if (e.charCodeAt(t) != this.readInt8(this.position() + ag + t))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(e, t) {
    const i = [];
    for (let n = 0; n < t; ++n) {
      const s = e(n);
      s !== null && i.push(s);
    }
    return i;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(e, t) {
    const i = [];
    for (let n = 0; n < t; ++n) {
      const s = e(n);
      s !== null && i.push(s.unpack());
    }
    return i;
  }
}
var Yi, xo = ((Yi = {})[Yi.Byte = 0] = "Byte", Yi[Yi.UByte = 1] = "UByte", Yi[Yi.Bool = 2] = "Bool", Yi[Yi.Short = 3] = "Short", Yi[Yi.UShort = 4] = "UShort", Yi[Yi.Int = 5] = "Int", Yi[Yi.UInt = 6] = "UInt", Yi[Yi.Long = 7] = "Long", Yi[Yi.ULong = 8] = "ULong", Yi[Yi.Float = 9] = "Float", Yi[Yi.Double = 10] = "Double", Yi[Yi.String = 11] = "String", Yi[Yi.Json = 12] = "Json", Yi[Yi.DateTime = 13] = "DateTime", Yi[Yi.Binary = 14] = "Binary", Yi);
class uo {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsColumn(e, t) {
    return (t || new uo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsColumn(e, t) {
    return e.setPosition(e.position() + lm), (t || new uo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readUint8(this.bb_pos + e) : xo.Byte;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  width() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  precision() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  scale() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  nullable() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return !e || !!this.bb.readInt8(this.bb_pos + e);
  }
  unique() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  primaryKey() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startColumn(e) {
    e.startObject(11);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addType(e, t) {
    e.addFieldInt8(1, t, xo.Byte);
  }
  static addTitle(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWidth(e, t) {
    e.addFieldInt32(4, t, -1);
  }
  static addPrecision(e, t) {
    e.addFieldInt32(5, t, -1);
  }
  static addScale(e, t) {
    e.addFieldInt32(6, t, -1);
  }
  static addNullable(e, t) {
    e.addFieldInt8(7, +t, 1);
  }
  static addUnique(e, t) {
    e.addFieldInt8(8, +t, 0);
  }
  static addPrimaryKey(e, t) {
    e.addFieldInt8(9, +t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static endColumn(e) {
    let t = e.endObject();
    return e.requiredField(t, 4), t;
  }
  static createColumn(e, t, i, n, s, c, o, d, m, y, T, P) {
    return uo.startColumn(e), uo.addName(e, t), uo.addType(e, i), uo.addTitle(e, n), uo.addDescription(e, s), uo.addWidth(e, c), uo.addPrecision(e, o), uo.addScale(e, d), uo.addNullable(e, m), uo.addUnique(e, y), uo.addPrimaryKey(e, T), uo.addMetadata(e, P), uo.endColumn(e);
  }
}
var Ii, zo = ((Ii = {})[Ii.Unknown = 0] = "Unknown", Ii[Ii.Point = 1] = "Point", Ii[Ii.LineString = 2] = "LineString", Ii[Ii.Polygon = 3] = "Polygon", Ii[Ii.MultiPoint = 4] = "MultiPoint", Ii[Ii.MultiLineString = 5] = "MultiLineString", Ii[Ii.MultiPolygon = 6] = "MultiPolygon", Ii[Ii.GeometryCollection = 7] = "GeometryCollection", Ii[Ii.CircularString = 8] = "CircularString", Ii[Ii.CompoundCurve = 9] = "CompoundCurve", Ii[Ii.CurvePolygon = 10] = "CurvePolygon", Ii[Ii.MultiCurve = 11] = "MultiCurve", Ii[Ii.MultiSurface = 12] = "MultiSurface", Ii[Ii.Curve = 13] = "Curve", Ii[Ii.Surface = 14] = "Surface", Ii[Ii.PolyhedralSurface = 15] = "PolyhedralSurface", Ii[Ii.TIN = 16] = "TIN", Ii[Ii.Triangle = 17] = "Triangle", Ii);
let vB = class Sa {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsGeometry(e, t) {
    return (t || new Sa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsGeometry(e, t) {
    return e.setPosition(e.position() + lm), (t || new Sa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  ends(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;
  }
  endsLength() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  endsArray() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  xy(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  xyLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  xyArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  z(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  zLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  zArray() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  m(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  mLength() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  mArray() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  t(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  tLength() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  tArray() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  tm(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + 8 * e) : BigInt(0);
  }
  tmLength() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readUint8(this.bb_pos + e) : zo.Unknown;
  }
  parts(e, t) {
    let i = this.bb.__offset(this.bb_pos, 18);
    return i ? (t || new Sa()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * e), this.bb) : null;
  }
  partsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startGeometry(e) {
    e.startObject(8);
  }
  static addEnds(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static createEndsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--) e.addInt32(t[i]);
    return e.endVector();
  }
  static startEndsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addXy(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createXyVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--) e.addFloat64(t[i]);
    return e.endVector();
  }
  static startXyVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addZ(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createZVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--) e.addFloat64(t[i]);
    return e.endVector();
  }
  static startZVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addM(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static createMVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--) e.addFloat64(t[i]);
    return e.endVector();
  }
  static startMVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addT(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static createTVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--) e.addFloat64(t[i]);
    return e.endVector();
  }
  static startTVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addTm(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static createTmVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--) e.addInt64(t[i]);
    return e.endVector();
  }
  static startTmVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addType(e, t) {
    e.addFieldInt8(6, t, zo.Unknown);
  }
  static addParts(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createPartsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--) e.addOffset(t[i]);
    return e.endVector();
  }
  static startPartsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endGeometry(e) {
    return e.endObject();
  }
  static createGeometry(e, t, i, n, s, c, o, d, m) {
    return Sa.startGeometry(e), Sa.addEnds(e, t), Sa.addXy(e, i), Sa.addZ(e, n), Sa.addM(e, s), Sa.addT(e, c), Sa.addTm(e, o), Sa.addType(e, d), Sa.addParts(e, m), Sa.endGeometry(e);
  }
};
class _c {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsFeature(e, t) {
    return (t || new _c()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsFeature(e, t) {
    return e.setPosition(e.position() + lm), (t || new _c()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  geometry(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? (e || new vB()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  properties(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
  }
  propertiesLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  propertiesArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  columns(e, t) {
    let i = this.bb.__offset(this.bb_pos, 8);
    return i ? (t || new uo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startFeature(e) {
    e.startObject(3);
  }
  static addGeometry(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addProperties(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createPropertiesVector(e, t) {
    e.startVector(1, t.length, 1);
    for (let i = t.length - 1; i >= 0; i--) e.addInt8(t[i]);
    return e.endVector();
  }
  static startPropertiesVector(e, t) {
    e.startVector(1, t, 1);
  }
  static addColumns(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--) e.addOffset(t[i]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endFeature(e) {
    return e.endObject();
  }
  static finishFeatureBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedFeatureBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
  static createFeature(e, t, i, n) {
    return _c.startFeature(e), _c.addGeometry(e, t), _c.addProperties(e, i), _c.addColumns(e, n), _c.endFeature(e);
  }
}
function ib(r, e) {
  let t = [];
  for (let i = 0; i < r.length; i += 2) {
    let n = [r[i], r[i + 1]];
    e && n.push(e[i >> 1]), t.push(n);
  }
  return t;
}
new TextEncoder();
let GA = new TextDecoder();
function xB(r, e) {
  let t = {};
  if (!e || e.length === 0) return t;
  let i = r.propertiesArray();
  if (!i) return t;
  let n = new DataView(i.buffer, i.byteOffset), s = r.propertiesLength(), c = 0;
  for (; c < s; ) {
    let o = n.getUint16(c, !0);
    c += 2;
    let d = e[o], m = d.name;
    switch (d.type) {
      case xo.Bool:
        t[m] = !!n.getUint8(c), c += 1;
        break;
      case xo.Byte:
        t[m] = n.getInt8(c), c += 1;
        break;
      case xo.UByte:
        t[m] = n.getUint8(c), c += 1;
        break;
      case xo.Short:
        t[m] = n.getInt16(c, !0), c += 2;
        break;
      case xo.UShort:
        t[m] = n.getUint16(c, !0), c += 2;
        break;
      case xo.Int:
        t[m] = n.getInt32(c, !0), c += 4;
        break;
      case xo.UInt:
        t[m] = n.getUint32(c, !0), c += 4;
        break;
      case xo.Long:
        t[m] = Number(n.getBigInt64(c, !0)), c += 8;
        break;
      case xo.ULong:
        t[m] = Number(n.getBigUint64(c, !0)), c += 8;
        break;
      case xo.Float:
        t[m] = n.getFloat32(c, !0), c += 4;
        break;
      case xo.Double:
        t[m] = n.getFloat64(c, !0), c += 8;
        break;
      case xo.DateTime:
      case xo.String: {
        let y = n.getUint32(c, !0);
        c += 4, t[m] = GA.decode(i.subarray(c, c + y)), c += y;
        break;
      }
      case xo.Json: {
        let y = n.getUint32(c, !0);
        c += 4;
        let T = GA.decode(i.subarray(c, c + y));
        t[m] = JSON.parse(T), c += y;
        break;
      }
      case xo.Binary: {
        let y = n.getUint32(c, !0);
        c += 4, t[m] = i.subarray(c, c + y), c += y;
        break;
      }
      default:
        throw Error(`Unknown type ${d.type}`);
    }
  }
  return t;
}
const g2 = new Uint8Array(0);
function wB() {
  return this._source.cancel();
}
function AB(r, e) {
  if (!r.length) return e;
  if (!e.length) return r;
  var t = new Uint8Array(r.length + e.length);
  return t.set(r), t.set(e, r.length), t;
}
function TB() {
  var r = this, e = r._array.subarray(r._index);
  return r._source.read().then(function(t) {
    return r._array = g2, r._index = 0, t.done ? e.length > 0 ? {
      done: !1,
      value: e
    } : {
      done: !0,
      value: void 0
    } : {
      done: !1,
      value: AB(e, t.value)
    };
  });
}
function SB(r) {
  if ((r |= 0) < 0) throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + r <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += r));
  var i = new Uint8Array(r);
  return i.set(this._array.subarray(this._index)), function n() {
    return e._source.read().then(function(s) {
      return s.done ? (e._array = g2, e._index = 0, t > 0 ? i.subarray(0, t) : null) : t + s.value.length >= r ? (e._array = s.value, e._index = r - t, i.set(s.value.subarray(0, r - t), t), i) : (i.set(s.value, t), t += s.value.length, n());
    });
  }();
}
function EB(r) {
  return typeof r.slice == "function" ? r : new Wy(typeof r.read == "function" ? r : r.getReader());
}
function Wy(r) {
  this._source = r, this._array = g2, this._index = 0;
}
Wy.prototype.read = TB;
Wy.prototype.slice = SB;
Wy.prototype.cancel = wB;
class Pl {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsCrs(e, t) {
    return (t || new Pl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsCrs(e, t) {
    return e.setPosition(e.position() + lm), (t || new Pl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  org(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  code() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  wkt(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  codeString(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startCrs(e) {
    e.startObject(6);
  }
  static addOrg(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addCode(e, t) {
    e.addFieldInt32(1, t, 0);
  }
  static addName(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWkt(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static addCodeString(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static endCrs(e) {
    return e.endObject();
  }
  static createCrs(e, t, i, n, s, c, o) {
    return Pl.startCrs(e), Pl.addOrg(e, t), Pl.addCode(e, i), Pl.addName(e, n), Pl.addDescription(e, s), Pl.addWkt(e, c), Pl.addCodeString(e, o), Pl.endCrs(e);
  }
}
class uy {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsHeader(e, t) {
    return (t || new uy()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsHeader(e, t) {
    return e.setPosition(e.position() + lm), (t || new uy()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  envelope(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  envelopeLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  envelopeArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  geometryType() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.readUint8(this.bb_pos + e) : zo.Unknown;
  }
  hasZ() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasM() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasT() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasTm() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  columns(e, t) {
    let i = this.bb.__offset(this.bb_pos, 18);
    return i ? (t || new uo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  featuresCount() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return e ? this.bb.readUint64(this.bb_pos + e) : BigInt("0");
  }
  indexNodeSize() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return e ? this.bb.readUint16(this.bb_pos + e) : 16;
  }
  crs(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? (e || new Pl()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 28);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 30);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startHeader(e) {
    e.startObject(14);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addEnvelope(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createEnvelopeVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--) e.addFloat64(t[i]);
    return e.endVector();
  }
  static startEnvelopeVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addGeometryType(e, t) {
    e.addFieldInt8(2, t, zo.Unknown);
  }
  static addHasZ(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static addHasM(e, t) {
    e.addFieldInt8(4, +t, 0);
  }
  static addHasT(e, t) {
    e.addFieldInt8(5, +t, 0);
  }
  static addHasTm(e, t) {
    e.addFieldInt8(6, +t, 0);
  }
  static addColumns(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--) e.addOffset(t[i]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addFeaturesCount(e, t) {
    e.addFieldInt64(8, t, BigInt("0"));
  }
  static addIndexNodeSize(e, t) {
    e.addFieldInt16(9, t, 16);
  }
  static addCrs(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static addTitle(e, t) {
    e.addFieldOffset(11, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(12, t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(13, t, 0);
  }
  static endHeader(e) {
    return e.endObject();
  }
  static finishHeaderBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedHeaderBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
function m2(r) {
  let e = uy.getRootAsHeader(r), t = e.featuresCount(), i = e.indexNodeSize(), n = [];
  for (let o = 0; o < e.columnsLength(); o++) {
    let d = e.columns(o);
    if (!d) throw Error("Column unexpectedly missing");
    if (!d.name()) throw Error("Column name unexpectedly missing");
    n.push({
      name: d.name(),
      type: d.type(),
      title: d.title(),
      description: d.description(),
      width: d.width(),
      precision: d.precision(),
      scale: d.scale(),
      nullable: d.nullable(),
      unique: d.unique(),
      primary_key: d.primaryKey()
    });
  }
  let s = e.crs(), c = s ? {
    org: s.org(),
    code: s.code(),
    name: s.name(),
    description: s.description(),
    wkt: s.wkt(),
    code_string: s.codeString()
  } : null;
  return {
    geometryType: e.geometryType(),
    columns: n,
    envelope: null,
    featuresCount: Number(t),
    indexNodeSize: i,
    crs: c,
    title: e.title(),
    description: e.description(),
    metadata: e.metadata()
  };
}
let m5 = class _5 {
  static global = new _5();
  _extraRequestThreshold = 262144;
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e) {
    if (e < 0) throw Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e;
  }
};
const CB = 40, IB = 16;
function _2(r, e) {
  e = Math.min(Math.max(+e, 2), 65535);
  let t = r, i = t;
  do
    i += t = Math.ceil(t / e);
  while (t !== 1);
  return 40 * i;
}
function PB(r, e) {
  if (e < 2) throw Error("Node size must be at least 2");
  if (r === 0) throw Error("Number of items must be greater than 0");
  let t = r, i = t, n = [t];
  do
    i += t = Math.ceil(t / e), n.push(t);
  while (t !== 1);
  let s = [];
  for (let o of (t = i, n)) s.push(t - o), t -= o;
  let c = [];
  for (let o = 0; o < n.length; o++) c.push([s[o], s[o] + n[o]]);
  return c;
}
async function* MB(r, e, t, i) {
  class n {
    _level;
    nodes;
    constructor(I, D) {
      this._level = D, this.nodes = I;
    }
    level() {
      return this._level;
    }
    startNodeIdx() {
      return this.nodes[0];
    }
    endNodeIdx() {
      return this.nodes[1];
    }
    extendEndNodeIdx(I) {
      this.nodes[1] = I;
    }
    toString() {
      return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;
    }
  }
  let {
    minX: s,
    minY: c,
    maxX: o,
    maxY: d
  } = t, m = PB(r, e), y = m[0][0], T = [new n([0, 1], m.length - 1)];
  for (; T.length !== 0; ) {
    let P = T.shift(), I = P.startNodeIdx(), D = I >= y, k = (() => {
      let [, te] = m[P.level()], Z = Math.min(P.endNodeIdx() + e, te);
      return D && Z < te ? Z + 1 : Z;
    })(), $ = k - I, G = new DataView(await i(40 * I, 40 * $));
    for (let te = I; te < k; te++) {
      let Z = te - I, H = 40 * Z;
      if (o < G.getFloat64(H + 0, !0) || d < G.getFloat64(H + 8, !0) || s > G.getFloat64(H + 16, !0) || c > G.getFloat64(H + 24, !0)) continue;
      let J = G.getBigUint64(H + 32, !0);
      if (D) {
        let oe = (() => {
          if (te < r - 1) {
            let le = (Z + 1) * 40;
            return G.getBigUint64(le + 32, !0) - J;
          }
          return null;
        })(), Ee = te - y;
        yield [Number(J), Ee, Number(oe)];
        continue;
      }
      let re = m5.global.extraRequestThreshold() / 40, be = T[T.length - 1];
      if (be !== void 0 && be.level() === P.level() - 1 && J < be.endNodeIdx() + re) {
        be.extendEndNodeIdx(Number(J));
        continue;
      }
      let pe = (() => {
        let oe = P.level() - 1;
        return new n([Number(J), Number(J) + 1], oe);
      })();
      be !== void 0 && (be.level(), pe.level()), T.push(pe);
    }
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ev = function(r, e) {
  return ev = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i) i.hasOwnProperty(n) && (t[n] = i[n]);
  }, ev(r, e);
};
function RB(r, e) {
  ev(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function vp(r, e, t, i) {
  function n(s) {
    return s instanceof t ? s : new t(function(c) {
      c(s);
    });
  }
  return new (t || (t = Promise))(function(s, c) {
    function o(y) {
      try {
        m(i.next(y));
      } catch (T) {
        c(T);
      }
    }
    function d(y) {
      try {
        m(i.throw(y));
      } catch (T) {
        c(T);
      }
    }
    function m(y) {
      y.done ? s(y.value) : n(y.value).then(o, d);
    }
    m((i = i.apply(r, [])).next());
  });
}
function Hh(r, e) {
  var t = {
    label: 0,
    sent: function() {
      if (s[0] & 1) throw s[1];
      return s[1];
    },
    trys: [],
    ops: []
  }, i, n, s, c;
  return c = {
    next: o(0),
    throw: o(1),
    return: o(2)
  }, typeof Symbol == "function" && (c[Symbol.iterator] = function() {
    return this;
  }), c;
  function o(m) {
    return function(y) {
      return d([m, y]);
    };
  }
  function d(m) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (i = 1, n && (s = m[0] & 2 ? n.return : m[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, m[1])).done) return s;
      switch (n = 0, s && (m = [m[0] & 2, s.value]), m[0]) {
        case 0:
        case 1:
          s = m;
          break;
        case 4:
          return t.label++, {
            value: m[1],
            done: !1
          };
        case 5:
          t.label++, n = m[1], m = [0];
          continue;
        case 7:
          m = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (m[0] === 6 || m[0] === 2)) {
            t = 0;
            continue;
          }
          if (m[0] === 3 && (!s || m[1] > s[0] && m[1] < s[3])) {
            t.label = m[1];
            break;
          }
          if (m[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = m;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(m);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      m = e.call(r, t);
    } catch (y) {
      m = [6, y], n = 0;
    } finally {
      i = s = 0;
    }
    if (m[0] & 5) throw m[1];
    return {
      value: m[0] ? m[1] : void 0,
      done: !0
    };
  }
}
function Lp(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], i = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && i >= r.length && (r = void 0), {
        value: r && r[i++],
        done: !r
      };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function qg(r) {
  return this instanceof qg ? (this.v = r, this) : new qg(r);
}
function LB(r, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = t.apply(r, e || []), n, s = [];
  return n = {}, c("next"), c("throw"), c("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n;
  function c(P) {
    i[P] && (n[P] = function(I) {
      return new Promise(function(D, k) {
        s.push([P, I, D, k]) > 1 || o(P, I);
      });
    });
  }
  function o(P, I) {
    try {
      d(i[P](I));
    } catch (D) {
      T(s[0][3], D);
    }
  }
  function d(P) {
    P.value instanceof qg ? Promise.resolve(P.value.v).then(m, y) : T(s[0][2], P);
  }
  function m(P) {
    o("next", P);
  }
  function y(P) {
    o("throw", P);
  }
  function T(P, I) {
    P(I), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
var y5 = (
  /** @class */
  function(r) {
    RB(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return Object.defineProperty(i, "name", {
        value: "RepeaterOverflowError",
        enumerable: !1
      }), typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(i, i.constructor.prototype) : i.__proto__ = i.constructor.prototype, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(i, i.constructor), i;
    }
    return e;
  }(Error)
);
(function() {
  function r(e) {
    if (e < 0)
      throw new RangeError("Capacity may not be less than 0");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    if (this.full)
      throw new Error("Buffer full");
    this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
(function() {
  function r(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    for (; this._q.length >= this._c; )
      this._q.shift();
    this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
(function() {
  function r(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    this._q.length < this._c && this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
function tv(r) {
  r != null && typeof r.then == "function" && r.then(dy, dy);
}
var nb = 0, $A = 1, Zf = 2, hy = 3, rv = 4, fy = 1024, dy = function() {
};
function cp(r) {
  var e = r.err, t = Promise.resolve(r.execution).then(function(i) {
    if (e != null)
      throw e;
    return i;
  });
  return r.err = void 0, r.execution = t.then(function() {
  }, function() {
  }), r.pending === void 0 ? t : r.pending.then(function() {
    return t;
  });
}
function Pf(r, e) {
  var t = r.state >= hy;
  return Promise.resolve(e).then(function(i) {
    return !t && r.state >= rv ? cp(r).then(function(n) {
      return {
        value: n,
        done: !0
      };
    }) : {
      value: i,
      done: t
    };
  });
}
function y2(r, e) {
  var t, i;
  if (!(r.state >= Zf))
    if (r.state = Zf, r.onnext(), r.onstop(), r.err == null && (r.err = e), r.pushes.length === 0 && (typeof r.buffer > "u" || r.buffer.empty))
      Mg(r);
    else
      try {
        for (var n = Lp(r.pushes), s = n.next(); !s.done; s = n.next()) {
          var c = s.value;
          c.resolve();
        }
      } catch (o) {
        t = {
          error: o
        };
      } finally {
        try {
          s && !s.done && (i = n.return) && i.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
}
function Mg(r) {
  var e, t;
  if (!(r.state >= hy)) {
    r.state < Zf && y2(r), r.state = hy, r.buffer = void 0;
    try {
      for (var i = Lp(r.nexts), n = i.next(); !n.done; n = i.next()) {
        var s = n.value, c = r.pending === void 0 ? cp(r) : r.pending.then(function() {
          return cp(r);
        });
        s.resolve(Pf(r, c));
      }
    } catch (o) {
      e = {
        error: o
      };
    } finally {
      try {
        n && !n.done && (t = i.return) && t.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    r.pushes = [], r.nexts = [];
  }
}
function HA(r) {
  r.state >= rv || (r.state < hy && Mg(r), r.state = rv);
}
function BB(r, e) {
  if (tv(e), r.pushes.length >= fy)
    throw new y5("No more than " + fy + " pending calls to push are allowed on a single repeater.");
  if (r.state >= Zf)
    return Promise.resolve(void 0);
  var t = r.pending === void 0 ? Promise.resolve(e) : r.pending.then(function() {
    return e;
  });
  t = t.catch(function(d) {
    r.state < Zf && (r.err = d), HA(r);
  });
  var i;
  if (r.nexts.length) {
    var n = r.nexts.shift();
    n.resolve(Pf(r, t)), r.nexts.length ? i = Promise.resolve(r.nexts[0].value) : typeof r.buffer < "u" && !r.buffer.full ? i = Promise.resolve(void 0) : i = new Promise(function(d) {
      return r.onnext = d;
    });
  } else typeof r.buffer < "u" && !r.buffer.full ? (r.buffer.add(t), i = Promise.resolve(void 0)) : i = new Promise(function(d) {
    return r.pushes.push({
      resolve: d,
      value: t
    });
  });
  var s = !0, c = {}, o = i.catch(function(d) {
    if (s)
      throw d;
  });
  return c.then = function(d, m) {
    return s = !1, Promise.prototype.then.call(i, d, m);
  }, c.catch = function(d) {
    return s = !1, Promise.prototype.catch.call(i, d);
  }, c.finally = i.finally.bind(i), r.pending = t.then(function() {
    return o;
  }).catch(function(d) {
    r.err = d, HA(r);
  }), c;
}
function kB(r) {
  var e = y2.bind(null, r), t = new Promise(function(i) {
    return r.onstop = i;
  });
  return e.then = t.then.bind(t), e.catch = t.catch.bind(t), e.finally = t.finally.bind(t), e;
}
function OB(r) {
  if (!(r.state >= $A)) {
    r.state = $A;
    var e = BB.bind(null, r), t = kB(r);
    r.execution = new Promise(function(i) {
      return i(r.executor(e, t));
    }), r.execution.catch(function() {
      return y2(r);
    });
  }
}
var qm = /* @__PURE__ */ new WeakMap(), cm = (
  /** @class */
  function() {
    function r(e, t) {
      qm.set(this, {
        executor: e,
        buffer: t,
        err: void 0,
        state: nb,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: dy,
        onstop: dy
      });
    }
    return r.prototype.next = function(e) {
      tv(e);
      var t = qm.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      if (t.nexts.length >= fy)
        throw new y5("No more than " + fy + " pending calls to next are allowed on a single repeater.");
      if (t.state <= nb && OB(t), t.onnext(e), typeof t.buffer < "u" && !t.buffer.empty) {
        var i = Pf(t, t.buffer.remove());
        if (t.pushes.length) {
          var n = t.pushes.shift();
          t.buffer.add(n.value), t.onnext = n.resolve;
        }
        return i;
      } else if (t.pushes.length) {
        var s = t.pushes.shift();
        return t.onnext = s.resolve, Pf(t, s.value);
      } else if (t.state >= Zf)
        return Mg(t), Pf(t, cp(t));
      return new Promise(function(c) {
        return t.nexts.push({
          resolve: c,
          value: e
        });
      });
    }, r.prototype.return = function(e) {
      tv(e);
      var t = qm.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return Mg(t), t.execution = Promise.resolve(t.execution).then(function() {
        return e;
      }), Pf(t, cp(t));
    }, r.prototype.throw = function(e) {
      var t = qm.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return t.state <= nb || t.state >= Zf || typeof t.buffer < "u" && !t.buffer.empty ? (Mg(t), t.err == null && (t.err = e), Pf(t, cp(t))) : this.next(Promise.reject(e));
    }, r.prototype[Symbol.asyncIterator] = function() {
      return this;
    }, r.race = DB, r.merge = NB, r.zip = FB, r.latest = UB, r;
  }()
);
function Xy(r, e) {
  var t, i, n = [], s = function(m) {
    m != null && typeof m[Symbol.asyncIterator] == "function" ? n.push(m[Symbol.asyncIterator]()) : m != null && typeof m[Symbol.iterator] == "function" ? n.push(m[Symbol.iterator]()) : n.push(function() {
      return LB(this, arguments, function() {
        return Hh(this, function(P) {
          switch (P.label) {
            case 0:
              return e.yieldValues ? [4, qg(m)] : [3, 3];
            case 1:
              return [4, P.sent()];
            case 2:
              P.sent(), P.label = 3;
            case 3:
              return e.returnValues ? [4, qg(m)] : [3, 5];
            case 4:
              return [2, P.sent()];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }());
  };
  try {
    for (var c = Lp(r), o = c.next(); !o.done; o = c.next()) {
      var d = o.value;
      s(d);
    }
  } catch (m) {
    t = {
      error: m
    };
  } finally {
    try {
      o && !o.done && (i = c.return) && i.call(c);
    } finally {
      if (t) throw t.error;
    }
  }
  return n;
}
function DB(r) {
  var e = this, t = Xy(r, {
    returnValues: !0
  });
  return new cm(function(i, n) {
    return vp(e, void 0, void 0, function() {
      var s, c, o, d, m, y;
      return Hh(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return n(), [
                2
                /*return*/
              ];
            c = !1, n.then(function() {
              s(), c = !0;
            }), T.label = 1;
          case 1:
            T.trys.push([1, , 5, 7]), d = void 0, m = 0, y = function() {
              var P, I, D, k, $, G;
              return Hh(this, function(te) {
                switch (te.label) {
                  case 0:
                    P = m;
                    try {
                      for (I = ($ = void 0, Lp(t)), D = I.next(); !D.done; D = I.next())
                        k = D.value, Promise.resolve(k.next()).then(function(Z) {
                          Z.done ? (n(), o === void 0 && (o = Z)) : m === P && (m++, s(Z));
                        }, function(Z) {
                          return n(Z);
                        });
                    } catch (Z) {
                      $ = {
                        error: Z
                      };
                    } finally {
                      try {
                        D && !D.done && (G = I.return) && G.call(I);
                      } finally {
                        if ($) throw $.error;
                      }
                    }
                    return [4, new Promise(function(Z) {
                      return s = Z;
                    })];
                  case 1:
                    return d = te.sent(), d === void 0 ? [3, 3] : [4, i(d.value)];
                  case 2:
                    te.sent(), te.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            }, T.label = 2;
          case 2:
            return c ? [3, 4] : [5, y()];
          case 3:
            return T.sent(), [3, 2];
          case 4:
            return [2, o && o.value];
          case 5:
            return n(), [4, Promise.race(t.map(function(P) {
              return P.return && P.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function NB(r) {
  var e = this, t = Xy(r, {
    yieldValues: !0
  });
  return new cm(function(i, n) {
    return vp(e, void 0, void 0, function() {
      var s, c, o, d = this;
      return Hh(this, function(m) {
        switch (m.label) {
          case 0:
            if (!t.length)
              return n(), [
                2
                /*return*/
              ];
            s = [], c = !1, n.then(function() {
              var y, T;
              c = !0;
              try {
                for (var P = Lp(s), I = P.next(); !I.done; I = P.next()) {
                  var D = I.value;
                  D();
                }
              } catch (k) {
                y = {
                  error: k
                };
              } finally {
                try {
                  I && !I.done && (T = P.return) && T.call(P);
                } finally {
                  if (y) throw y.error;
                }
              }
            }), m.label = 1;
          case 1:
            return m.trys.push([1, , 3, 4]), [4, Promise.all(t.map(function(y, T) {
              return vp(d, void 0, void 0, function() {
                var P, I;
                return Hh(this, function(D) {
                  switch (D.label) {
                    case 0:
                      D.trys.push([0, , 6, 9]), D.label = 1;
                    case 1:
                      return c ? [3, 5] : (Promise.resolve(y.next()).then(function(k) {
                        return s[T](k);
                      }, function(k) {
                        return n(k);
                      }), [4, new Promise(function(k) {
                        s[T] = k;
                      })]);
                    case 2:
                      return P = D.sent(), P === void 0 ? [3, 4] : P.done ? (o = P, [
                        2
                        /*return*/
                      ]) : [4, i(P.value)];
                    case 3:
                      D.sent(), D.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      return I = y.return, I ? [4, y.return()] : [3, 8];
                    case 7:
                      I = D.sent(), D.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            return m.sent(), [2, o && o.value];
          case 3:
            return n(), [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function FB(r) {
  var e = this, t = Xy(r, {
    returnValues: !0
  });
  return new cm(function(i, n) {
    return vp(e, void 0, void 0, function() {
      var s, c, o, d;
      return Hh(this, function(m) {
        switch (m.label) {
          case 0:
            if (!t.length)
              return n(), [2, []];
            c = !1, n.then(function() {
              s(), c = !0;
            }), m.label = 1;
          case 1:
            m.trys.push([1, , 6, 8]), m.label = 2;
          case 2:
            return c ? [3, 5] : (Promise.all(t.map(function(y) {
              return y.next();
            })).then(function(y) {
              return s(y);
            }, function(y) {
              return n(y);
            }), [4, new Promise(function(y) {
              return s = y;
            })]);
          case 3:
            return o = m.sent(), o === void 0 ? [
              2
              /*return*/
            ] : (d = o.map(function(y) {
              return y.value;
            }), o.some(function(y) {
              return y.done;
            }) ? [2, d] : [4, i(d)]);
          case 4:
            return m.sent(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return n(), [4, Promise.all(t.map(function(y) {
              return y.return && y.return();
            }))];
          case 7:
            return m.sent(), [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function UB(r) {
  var e = this, t = Xy(r, {
    yieldValues: !0,
    returnValues: !0
  });
  return new cm(function(i, n) {
    return vp(e, void 0, void 0, function() {
      var s, c, o, d, m, y = this;
      return Hh(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return n(), [2, []];
            c = [], o = !1, n.then(function() {
              var P, I;
              s();
              try {
                for (var D = Lp(c), k = D.next(); !k.done; k = D.next()) {
                  var $ = k.value;
                  $();
                }
              } catch (G) {
                P = {
                  error: G
                };
              } finally {
                try {
                  k && !k.done && (I = D.return) && I.call(D);
                } finally {
                  if (P) throw P.error;
                }
              }
              o = !0;
            }), T.label = 1;
          case 1:
            return T.trys.push([1, , 5, 7]), Promise.all(t.map(function(P) {
              return P.next();
            })).then(function(P) {
              return s(P);
            }, function(P) {
              return n(P);
            }), [4, new Promise(function(P) {
              return s = P;
            })];
          case 2:
            return d = T.sent(), d === void 0 ? [
              2
              /*return*/
            ] : (m = d.map(function(P) {
              return P.value;
            }), d.every(function(P) {
              return P.done;
            }) ? [2, m] : [4, i(m.slice())]);
          case 3:
            return T.sent(), [4, Promise.all(t.map(function(P, I) {
              return vp(y, void 0, void 0, function() {
                var D;
                return Hh(this, function(k) {
                  switch (k.label) {
                    case 0:
                      if (d[I].done)
                        return [2, d[I].value];
                      k.label = 1;
                    case 1:
                      return o ? [3, 4] : (Promise.resolve(P.next()).then(function($) {
                        return c[I]($);
                      }, function($) {
                        return n($);
                      }), [4, new Promise(function($) {
                        return c[I] = $;
                      })]);
                    case 2:
                      return D = k.sent(), D === void 0 ? [2, d[I].value] : D.done ? [2, D.value] : (m[I] = D.value, [4, i(m.slice())]);
                    case 3:
                      return k.sent(), [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, T.sent()];
          case 5:
            return n(), [4, Promise.all(t.map(function(P) {
              return P.return && P.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
class b2 {
  headerClient;
  header;
  headerLength;
  indexLength;
  nocache;
  headers;
  constructor(e, t, i, n, s, c = {}) {
    this.headerClient = e, this.header = t, this.headerLength = i, this.indexLength = n, this.nocache = s, this.headers = c;
  }
  static async open(e, t, i = {}) {
    let n, s = new qA(e, t, i), c = 2024 + (() => {
      let y, T = 0;
      for (y = 0; y < 3; y++) T += IB ** y * CB;
      return T;
    })();
    if (!new Uint8Array(await s.getRange(0, 8, c, "header")).subarray(0, 3).every((y, T) => Bf[T] === y)) throw Error("Not a FlatGeobuf file");
    if ((n = new DataView(await s.getRange(8, 4, c, "header")).getUint32(0, !0)) > 10485760 || n < 8) throw Error("Invalid header size");
    let o = await s.getRange(12, n, c, "header"), d = m2(new ah(new Uint8Array(o)));
    if (d.indexNodeSize === 0) throw Error("No index found, cannot read features filtered by bbox");
    let m = _2(d.featuresCount, d.indexNodeSize);
    return new b2(s, d, n, m, t, i);
  }
  async *selectBbox(e) {
    let t = this.lengthBeforeTree(), i = this.headerClient, n = async (d, m) => i.getRange(t + d, m, 0, "index"), s = [], c = [];
    for await (let d of MB(this.header.featuresCount, this.header.indexNodeSize, e, n)) {
      let [m, y] = d, [, , T] = d;
      if (T || (T = 4), c.length === 0) {
        c.push([m, T, y]);
        continue;
      }
      let P = c[c.length - 1];
      m - (P[0] + P[1]) > m5.global.extraRequestThreshold() && (s.push(c), c = []), c.push([m, T, y]);
    }
    this.headerClient.logUsage("header+index"), c.length > 0 && s.push(c);
    let o = s.flatMap((d) => this.readFeatureBatch(d, this.nocache));
    yield* cm.merge(o);
  }
  lengthBeforeTree() {
    return Bf.length + nh + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  buildFeatureClient(e) {
    return new qA(this.headerClient.httpClient, e, this.headers);
  }
  async *readFeatureBatch(e, t) {
    let [i] = e[0], [n, s] = e[e.length - 1], c = this.buildFeatureClient(t), o = n + s - i;
    for (let [d, , m] of e) {
      let y = await this.readFeature(c, d, o);
      yield {
        id: m,
        feature: y
      }, o = 0;
    }
    c.logUsage("feature");
  }
  async readFeature(e, t, i) {
    let n, s = t + this.lengthBeforeFeatures();
    n = new DataView(await e.getRange(s, 4, i, "feature length")).getUint32(0, !0);
    let c = new Uint8Array(await e.getRange(s + 4, n, i, "feature data")), o = new Uint8Array(n + nh);
    o.set(c, nh);
    let d = new ah(o);
    return d.setPosition(nh), _c.getRootAsFeature(d);
  }
}
let qA = class {
  httpClient;
  bytesEverUsed = 0;
  bytesEverFetched = 0;
  buffer = new ArrayBuffer(0);
  head = 0;
  constructor(e, t, i = {}) {
    if (typeof e == "string") this.httpClient = new WA(e, t, i);
    else if (e instanceof WA) this.httpClient = e;
    else throw Error("Unknown source");
  }
  async getRange(e, t, i, n) {
    this.bytesEverUsed += t;
    let s = e - this.head, c = s + t;
    if (s >= 0 && c <= this.buffer.byteLength) return this.buffer.slice(s, c);
    let o = Math.max(t, i);
    return this.bytesEverFetched += o, this.buffer = await this.httpClient.getRange(e, o, n), this.head = e, this.buffer.slice(0, t);
  }
  logUsage(e) {
    e.split(" ")[0], (100 * this.bytesEverUsed / this.bytesEverFetched).toFixed(2);
  }
}, WA = class {
  url;
  nocache;
  headers;
  requestsEverMade = 0;
  bytesEverRequested = 0;
  constructor(e, t, i = {}) {
    this.url = e, this.nocache = t, this.headers = i;
  }
  async getRange(e, t, i) {
    this.requestsEverMade += 1, this.bytesEverRequested += t;
    let n = `bytes=${e}-${e + t - 1}`, s = new Headers(this.headers);
    return s.set("Range", n), this.nocache && s.set("Cache-Control", "no-cache, no-store"), await (await fetch(this.url, {
      headers: s
    })).arrayBuffer();
  }
};
async function* zB(r, e, t, i) {
  if (!r.subarray(0, 3).every((T, P) => Bf[P] === T)) throw Error("Not a FlatGeobuf file");
  let n = new ah(r), s = n.readUint32(Bf.length);
  n.setPosition(Bf.length + nh);
  let c = m2(n), o = Bf.length + nh + s, {
    indexNodeSize: d,
    featuresCount: m
  } = c;
  d > 0 && (o += _2(m, d));
  let y = 0;
  for (; o < n.capacity(); ) {
    let T = n.readUint32(o);
    n.setPosition(o + nh);
    let P = _c.getRootAsFeature(n);
    yield e(y++, P, c), o += nh + T;
  }
}
async function* jB(r, e, t) {
  let i, n = EB(r), s = async (I) => await n.slice(I), c = new Uint8Array(await s(8));
  if (!c.subarray(0, 3).every((I, D) => Bf[D] === I)) throw Error("Not a FlatGeobuf file");
  c = new Uint8Array(await s(4));
  let o = new ah(c), d = o.readUint32(0);
  c = new Uint8Array(await s(d));
  let m = m2(o = new ah(c)), {
    indexNodeSize: y,
    featuresCount: T
  } = m;
  if (y > 0) {
    let I = _2(T, y);
    await s(I);
  }
  let P = 0;
  for (; i = await GB(s, m, e, P++); ) yield i;
}
async function* VB(r, e, t, i, n = !1, s = {}) {
  let c = await b2.open(r, n, s);
  for await (let o of c.selectBbox(e)) yield t(o.id, o.feature, c.header);
}
async function GB(r, e, t, i) {
  let n = new Uint8Array(await r(4, "feature length"));
  if (n.byteLength === 0) return;
  let s = new ah(n), c = s.readUint32(0);
  n = new Uint8Array(await r(c, "feature data"));
  let o = new Uint8Array(c + 4);
  return o.set(n, 4), (s = new ah(o)).setPosition(nh), t(i, _c.getRootAsFeature(s), e);
}
function iv(r, e) {
  let t = e;
  if (t === zo.Unknown && (t = r.type()), t === zo.GeometryCollection) {
    let n = [];
    for (let s = 0; s < r.partsLength(); s++) {
      let c = r.parts(s), o = c.type();
      n.push(iv(c, o));
    }
    return {
      type: zo[t],
      geometries: n
    };
  }
  if (t === zo.MultiPolygon) {
    let n = [];
    for (let s = 0; s < r.partsLength(); s++) n.push(iv(r.parts(s), zo.Polygon));
    return {
      type: zo[t],
      coordinates: n.map((s) => s.coordinates)
    };
  }
  let i = function(n, s) {
    let c = n.xyArray(), o = n.zArray();
    switch (s) {
      case zo.Point: {
        let d = Array.from(c);
        return o && d.push(o[0]), d;
      }
      case zo.MultiPoint:
      case zo.LineString:
        return ib(c, o);
      case zo.MultiLineString:
      case zo.Polygon:
        return function(d, m, y) {
          let T;
          if (!y || y.length === 0) return [ib(d, m)];
          let P = 0, I = Array.from(y).map((D) => d.slice(P, P = D << 1));
          return m && (P = 0, T = Array.from(y).map((D) => m.slice(P, P = D))), I.map((D, k) => ib(D, T ? T[k] : void 0));
        }(c, o, n.endsArray());
    }
  }(r, t);
  return {
    type: zo[t],
    coordinates: i
  };
}
function v2(r, e, t) {
  let i = t.columns;
  return {
    type: "Feature",
    id: r,
    geometry: iv(e.geometry(), t.geometryType),
    properties: xB(e, i)
  };
}
async function* $B(r, e, t) {
  yield* zB(r, v2);
}
function HB(r, e) {
  return jB(r, v2);
}
function qB(r, e, t, i = !1, n = {}) {
  return VB(r, e, v2, t, i, n);
}
function XA(r, e, t, i = !1, n = {}) {
  return r instanceof Uint8Array ? $B(r) : r instanceof ReadableStream ? HB(r) : qB(r, e, t, i, n);
}
class WB {
  constructor() {
    this._bearing = 0, this._pitch = 60, this._minpitchzoom = null;
  }
  onAdd(e) {
    this._map = e;
    let t = this;
    return this._btn = document.createElement("button"), this._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d", this._btn.id = "bt3D", this._btn.type = "button", this._btn["aria-label"] = "Vista 3D", this._btn.onclick = function() {
      if (t._btn.className.indexOf("3d") != -1) {
        let m = {
          pitch: t._pitch,
          bearing: t._bearing
        };
        t._minpitchzoom && e.getZoom() > t._minpitchzoom && (m.zoom = t._minpitchzoom);
        var i = 0, n = 38.5, s = 6, c = 62.33, {
          longitude: o,
          latitude: d
        } = e.getCenter();
        e.getZoom() < 10 ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }) : o >= i && o <= s && d >= n && d <= c ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.2
        }) : e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }), e.easeTo(m), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d";
      } else
        e.setTerrain(null), e.easeTo({
          pitch: 0,
          bearing: 0
        }), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-3d";
    }, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl maplibregl-ctrl-group", this._container.title = "Vista 3D", this._container.appendChild(this._btn), this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function py(r, e) {
  if (!r)
    throw new Error(e || "loader assertion failed.");
}
const x2 = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), ZA = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
ZA && parseFloat(ZA[1]);
const YA = globalThis, JA = globalThis.process || {}, XB = globalThis.navigator || {};
function b5(r) {
  if (typeof window < "u" && window.process?.type === "renderer" || typeof process < "u" && process.versions?.electron)
    return !0;
  const t = typeof navigator < "u" && navigator.userAgent;
  return !!(t && t.indexOf("Electron") >= 0);
}
function ad() {
  return !// @ts-expect-error
  (typeof process == "object" && String(process) === "[object process]" && !process?.browser) || b5();
}
function ZB(r) {
  return ad() ? b5() ? "Electron" : (XB.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const v5 = "4.1.0";
function YB(r) {
  try {
    const e = window[r], t = "__storage_test__";
    return e.setItem(t, t), e.removeItem(t), e;
  } catch {
    return null;
  }
}
class JB {
  constructor(e, t, i = "sessionStorage") {
    this.storage = YB(i), this.id = e, this.config = t, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const t = JSON.stringify(this.config);
      this.storage.setItem(this.id, t);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const t = this.storage.getItem(this.id);
      e = t ? JSON.parse(t) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function KB(r) {
  let e;
  return r < 10 ? e = `${r.toFixed(2)}ms` : r < 100 ? e = `${r.toFixed(1)}ms` : r < 1e3 ? e = `${r.toFixed(0)}ms` : e = `${(r / 1e3).toFixed(2)}s`, e;
}
function QB(r, e = 8) {
  const t = Math.max(e - r.length, 0);
  return `${" ".repeat(t)}${r}`;
}
var gy;
(function(r) {
  r[r.BLACK = 30] = "BLACK", r[r.RED = 31] = "RED", r[r.GREEN = 32] = "GREEN", r[r.YELLOW = 33] = "YELLOW", r[r.BLUE = 34] = "BLUE", r[r.MAGENTA = 35] = "MAGENTA", r[r.CYAN = 36] = "CYAN", r[r.WHITE = 37] = "WHITE", r[r.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", r[r.BRIGHT_RED = 91] = "BRIGHT_RED", r[r.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", r[r.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", r[r.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", r[r.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", r[r.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", r[r.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(gy || (gy = {}));
const ek = 10;
function KA(r) {
  return typeof r != "string" ? r : (r = r.toUpperCase(), gy[r] || gy.WHITE);
}
function tk(r, e, t) {
  return !ad && typeof r == "string" && (e && (r = `\x1B[${KA(e)}m${r}\x1B[39m`), t && (r = `\x1B[${KA(t) + ek}m${r}\x1B[49m`)), r;
}
function rk(r, e = ["constructor"]) {
  const t = Object.getPrototypeOf(r), i = Object.getOwnPropertyNames(t), n = r;
  for (const s of i) {
    const c = n[s];
    typeof c == "function" && (e.find((o) => s === o) || (n[s] = c.bind(r)));
  }
}
function w2(r, e) {
  if (!r)
    throw new Error("Assertion failed");
}
function Nd() {
  let r;
  if (ad() && YA.performance)
    r = YA?.performance?.now?.();
  else if ("hrtime" in JA) {
    const e = JA?.hrtime?.();
    r = e[0] * 1e3 + e[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
const Fd = {
  debug: ad() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, ik = {
  enabled: !0,
  level: 0
};
function Ud() {
}
const QA = {}, eT = {
  once: !0
};
class Bp {
  constructor({
    id: e
  } = {
    id: ""
  }) {
    this.VERSION = v5, this._startTs = Nd(), this._deltaTs = Nd(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new JB(`__probe-${this.id}__`, ik), this.timeStamp(`${this.id} started`), rk(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((Nd() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((Nd() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(e) {
    this.level = e;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(e = !0) {
    return this._storage.setConfiguration({
      enabled: e
    }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({
      level: e
    }), this;
  }
  /** return the current status of the setting */
  get(e) {
    return this._storage.config[e];
  }
  // update the status of the setting
  set(e, t) {
    this._storage.setConfiguration({
      [e]: t
    });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(e, t) {
    if (!e)
      throw new Error(t || "Assertion failed");
  }
  warn(e) {
    return this._getLogFunction(0, e, Fd.warn, arguments, eT);
  }
  error(e) {
    return this._getLogFunction(0, e, Fd.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(e, t) {
    return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${t}\` instead`);
  }
  /** Print a removal warning */
  removed(e, t) {
    return this.error(`\`${e}\` has been removed. Use \`${t}\` instead`);
  }
  probe(e, t) {
    return this._getLogFunction(e, t, Fd.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, t) {
    return this._getLogFunction(e, t, Fd.debug, arguments);
  }
  info(e, t) {
    return this._getLogFunction(e, t, console.info, arguments);
  }
  once(e, t) {
    return this._getLogFunction(e, t, Fd.debug || Fd.info, arguments, eT);
  }
  /** Logs an object as a table */
  table(e, t, i) {
    return t ? this._getLogFunction(e, t, console.table || Ud, i && [i], {
      tag: sk(t)
    }) : Ud;
  }
  time(e, t) {
    return this._getLogFunction(e, t, console.time ? console.time : console.info);
  }
  timeEnd(e, t) {
    return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, t) {
    return this._getLogFunction(e, t, console.timeStamp || Ud);
  }
  group(e, t, i = {
    collapsed: !1
  }) {
    const n = tT({
      logLevel: e,
      message: t,
      opts: i
    }), {
      collapsed: s
    } = i;
    return n.method = (s ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(n);
  }
  groupCollapsed(e, t, i = {}) {
    return this.group(e, t, Object.assign({}, i, {
      collapsed: !0
    }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || Ud);
  }
  // EXPERIMENTAL
  withGroup(e, t, i) {
    this.group(e, t)();
    try {
      i();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= x5(e);
  }
  _getLogFunction(e, t, i, n, s) {
    if (this._shouldLog(e)) {
      s = tT({
        logLevel: e,
        message: t,
        args: n,
        opts: s
      }), i = i || s.method, w2(i), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = Nd();
      const c = s.tag || s.message;
      if (s.once && c)
        if (!QA[c])
          QA[c] = Nd();
        else
          return Ud;
      return t = nk(this.id, s.message, s), i.bind(console, t, ...s.args);
    }
    return Ud;
  }
}
Bp.VERSION = v5;
function x5(r) {
  if (!r)
    return 0;
  let e;
  switch (typeof r) {
    case "number":
      e = r;
      break;
    case "object":
      e = r.logLevel || r.priority || 0;
      break;
    default:
      return 0;
  }
  return w2(Number.isFinite(e) && e >= 0), e;
}
function tT(r) {
  const {
    logLevel: e,
    message: t
  } = r;
  r.logLevel = x5(e);
  const i = r.args ? Array.from(r.args) : [];
  for (; i.length && i.shift() !== t; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      t !== void 0 && i.unshift(t), r.message = e;
      break;
    case "object":
      Object.assign(r, e);
      break;
  }
  typeof r.message == "function" && (r.message = r.message());
  const n = typeof r.message;
  return w2(n === "string" || n === "object"), Object.assign(r, {
    args: i
  }, r.opts);
}
function nk(r, e, t) {
  if (typeof e == "string") {
    const i = t.time ? QB(KB(t.total)) : "";
    e = t.time ? `${r}: ${i}  ${e}` : `${r}: ${e}`, e = tk(e, t.color, t.background);
  }
  return e;
}
function sk(r) {
  for (const e in r)
    for (const t in r[e])
      return t || "untitled";
  return "empty";
}
globalThis.probe = {};
const w5 = new Bp({
  id: "@probe.gl/log"
}), sb = "4.3.2", ok = sb[0] >= "0" && sb[0] <= "9" ? `v${sb}` : "";
function ak() {
  const r = new Bp({
    id: "loaders.gl"
  });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = r, globalThis.loaders.version = ok, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = r, r;
}
const lk = ak();
function ck(r, e) {
  return A5(r || {}, e);
}
function A5(r, e, t = 0) {
  if (t > 3)
    return e;
  const i = {
    ...r
  };
  for (const [n, s] of Object.entries(e))
    s && typeof s == "object" && !Array.isArray(s) ? i[n] = A5(i[n] || {}, e[n], t + 1) : i[n] = e[n];
  return i;
}
const uk = "latest";
function hk() {
  return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.2"), globalThis._loadersgl_.version;
}
const fk = hk();
function qh(r, e) {
  if (!r)
    throw new Error(e || "loaders.gl assertion failed.");
}
const Vf = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), dk = typeof window < "u" && typeof window.orientation < "u", rT = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
rT && parseFloat(rT[1]);
class pk {
  name;
  workerThread;
  isRunning = !0;
  /** Promise that resolves when Job is done */
  result;
  _resolve = () => {
  };
  _reject = () => {
  };
  constructor(e, t) {
    this.name = e, this.workerThread = t, this.result = new Promise((i, n) => {
      this._resolve = i, this._reject = n;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(e, t) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: e,
      payload: t
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(e) {
    qh(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(e) {
    qh(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
class ob {
  terminate() {
  }
}
const ab = /* @__PURE__ */ new Map();
function gk(r) {
  qh(r.source && !r.url || !r.source && r.url);
  let e = ab.get(r.source || r.url);
  return e || (r.url && (e = mk(r.url), ab.set(r.url, e)), r.source && (e = T5(r.source), ab.set(r.source, e))), qh(e), e;
}
function mk(r) {
  if (!r.startsWith("http"))
    return r;
  const e = _k(r);
  return T5(e);
}
function T5(r) {
  const e = new Blob([r], {
    type: "application/javascript"
  });
  return URL.createObjectURL(e);
}
function _k(r) {
  return `try {
  importScripts('${r}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function S5(r, e = !0, t) {
  const i = t || /* @__PURE__ */ new Set();
  if (r) {
    if (iT(r))
      i.add(r);
    else if (iT(r.buffer))
      i.add(r.buffer);
    else if (!ArrayBuffer.isView(r)) {
      if (e && typeof r == "object")
        for (const n in r)
          S5(r[n], e, i);
    }
  }
  return t === void 0 ? Array.from(i) : [];
}
function iT(r) {
  return r ? r instanceof ArrayBuffer || typeof MessagePort < "u" && r instanceof MessagePort || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas : !1;
}
const lb = () => {
};
class nv {
  name;
  source;
  url;
  terminated = !1;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && Vf || typeof ob < "u" && !Vf;
  }
  constructor(e) {
    const {
      name: t,
      source: i,
      url: n
    } = e;
    qh(i || n), this.name = t, this.source = i, this.url = n, this.onMessage = lb, this.onError = (s) => console.log(s), this.worker = Vf ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = lb, this.onError = lb, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(e, t) {
    t = t || S5(e), this.worker.postMessage(e, t);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(e) {
    let t = "Failed to load ";
    return t += `worker ${this.name} from ${this.url}. `, e.message && (t += `${e.message} in `), e.lineno && (t += `:${e.lineno}:${e.colno}`), new Error(t);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = gk({
      source: this.source,
      url: this.url
    });
    const e = new Worker(this._loadableURL, {
      name: this.name
    });
    return e.onmessage = (t) => {
      t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
    }, e.onerror = (t) => {
      this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
    }, e.onmessageerror = (t) => console.error(t), e;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let e;
    if (this.url) {
      const i = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      e = new ob(i, {
        eval: !1
      });
    } else if (this.source)
      e = new ob(this.source, {
        eval: !0
      });
    else
      throw new Error("no worker");
    return e.on("message", (t) => {
      this.onMessage(t);
    }), e.on("error", (t) => {
      this.onError(t);
    }), e.on("exit", (t) => {
    }), e;
  }
}
class yk {
  name = "unnamed";
  source;
  // | Function;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {
  };
  reuseWorkers = !0;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = !1;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return nv.isSupported();
  }
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(e) {
    this.source = e.source, this.url = e.url, this.setProps(e);
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e, t = (n, s, c) => n.done(c), i = (n, s) => n.error(s)) {
    const n = new Promise((s) => (this.jobQueue.push({
      name: e,
      onMessage: t,
      onError: i,
      onStart: s
    }), this));
    return this._startQueuedJob(), await n;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const t = this.jobQueue.shift();
    if (t) {
      this.onDebug({
        message: "Starting job",
        name: t.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const i = new pk(t.name, e);
      e.onMessage = (n) => t.onMessage(i, n.type, n.payload), e.onError = (n) => t.onError(i, n), t.onStart(i);
      try {
        await i.result;
      } catch (n) {
        console.error(`Worker exception: ${n}`);
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(e) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !Vf || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new nv({
        name: e,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return dk ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const bk = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class Fh {
  props;
  workerPools = /* @__PURE__ */ new Map();
  // singleton
  static _workerFarm;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return nv.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(e = {}) {
    return Fh._workerFarm = Fh._workerFarm || new Fh({}), Fh._workerFarm.setProps(e), Fh._workerFarm;
  }
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(e) {
    this.props = {
      ...bk
    }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    };
    for (const t of this.workerPools.values())
      t.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(e) {
    const {
      name: t,
      source: i,
      url: n
    } = e;
    let s = this.workerPools.get(t);
    return s || (s = new yk({
      name: t,
      source: i,
      url: n
    }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, s)), s;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
function vk(r, e = {}) {
  const t = e[r.id] || {}, i = Vf ? `${r.id}-worker.js` : `${r.id}-worker-node.js`;
  let n = t.workerUrl;
  if (!n && r.id === "compression" && (n = e.workerUrl), e._workerType === "test" && (Vf ? n = `modules/${r.module}/dist/${i}` : n = `modules/${r.module}/src/workers/${r.id}-worker-node.ts`), !n) {
    let s = r.version;
    s === "latest" && (s = uk);
    const c = s ? `@${s}` : "";
    n = `https://unpkg.com/@loaders.gl/${r.module}${c}/dist/${i}`;
  }
  return qh(n), n;
}
function xk(r, e = fk) {
  qh(r, "no worker provided");
  const t = r.version;
  return !(!e || !t);
}
function wk(r, e) {
  return !Fh.isSupported() || !Vf && !e?._nodeWorkers ? !1 : r.worker && e?.worker;
}
async function Ak(r, e, t, i, n) {
  const s = r.id, c = vk(r, t), d = Fh.getWorkerFarm(t).getWorkerPool({
    name: s,
    url: c
  });
  t = JSON.parse(JSON.stringify(t)), i = JSON.parse(JSON.stringify(i || {}));
  const m = await d.startJob(
    "process-on-worker",
    // @ts-expect-error
    Tk.bind(null, n)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return m.postMessage("process", {
    // @ts-ignore
    input: e,
    options: t,
    context: i
  }), await (await m.result).result;
}
async function Tk(r, e, t, i) {
  switch (t) {
    case "done":
      e.done(i);
      break;
    case "error":
      e.error(new Error(i.error));
      break;
    case "process":
      const {
        id: n,
        input: s,
        options: c
      } = i;
      try {
        const o = await r(s, c);
        e.postMessage("done", {
          id: n,
          result: o
        });
      } catch (o) {
        const d = o instanceof Error ? o.message : "unknown error";
        e.postMessage("error", {
          id: n,
          error: d
        });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${t}`);
  }
}
function Sk(r, e, t) {
  if (t = t || r.byteLength, r.byteLength < t || e.byteLength < t)
    return !1;
  const i = new Uint8Array(r), n = new Uint8Array(e);
  for (let s = 0; s < i.length; ++s)
    if (i[s] !== n[s])
      return !1;
  return !0;
}
function Ek(...r) {
  return Ck(r);
}
function Ck(r) {
  const e = r.map((s) => s instanceof ArrayBuffer ? new Uint8Array(s) : s), t = e.reduce((s, c) => s + c.byteLength, 0), i = new Uint8Array(t);
  let n = 0;
  for (const s of e)
    i.set(s, n), n += s.byteLength;
  return i.buffer;
}
async function Ik(r) {
  const e = [];
  for await (const t of r)
    e.push(t);
  return Ek(...e);
}
function nT() {
  let r;
  if (typeof window < "u" && window.performance)
    r = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    r = e[0] * 1e3 + e[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
class sT {
  constructor(e, t) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = t, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = nT(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(nT() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class kp {
  constructor(e) {
    this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(e, t = "count") {
    return this._getOrCreate({
      name: e,
      type: t
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const e of Object.values(this.stats))
      e.reset();
    return this;
  }
  forEach(e) {
    for (const t of Object.values(this.stats))
      e(t);
  }
  getTable() {
    const e = {};
    return this.forEach((t) => {
      e[t.name] = {
        time: t.time || 0,
        count: t.count || 0,
        average: t.getAverageTime() || 0,
        hz: t.getHz() || 0
      };
    }), e;
  }
  _initializeStats(e = []) {
    e.forEach((t) => this._getOrCreate(t));
  }
  _getOrCreate(e) {
    const {
      name: t,
      type: i
    } = e;
    let n = this.stats[t];
    return n || (e instanceof sT ? n = e : n = new sT(t, i), this.stats[t] = n), n;
  }
}
let Pk = "";
const oT = {};
function Mk(r) {
  for (const e in oT)
    if (r.startsWith(e)) {
      const t = oT[e];
      r = r.replace(e, t);
    }
  return !r.startsWith("http://") && !r.startsWith("https://") && (r = `${Pk}${r}`), r;
}
function Rk(r) {
  return r && typeof r == "object" && r.isBuffer;
}
function E5(r) {
  if (Rk(r))
    return r;
  if (r instanceof ArrayBuffer)
    return r;
  if (ArrayBuffer.isView(r))
    return r.byteOffset === 0 && r.byteLength === r.buffer.byteLength ? r.buffer : r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
  if (typeof r == "string") {
    const e = r;
    return new TextEncoder().encode(e).buffer;
  }
  if (r && typeof r == "object" && r._toArrayBuffer)
    return r._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function C5(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(e + 1) : "";
}
function Lk(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(0, e) : "";
}
const Bk = (r) => typeof r == "boolean", Rg = (r) => typeof r == "function", um = (r) => r !== null && typeof r == "object", aT = (r) => um(r) && r.constructor === {}.constructor, kk = (r) => !!r && typeof r[Symbol.iterator] == "function", Ok = (r) => r && typeof r[Symbol.asyncIterator] == "function", ld = (r) => typeof Response < "u" && r instanceof Response || r && r.arrayBuffer && r.text && r.json, cd = (r) => typeof Blob < "u" && r instanceof Blob, Dk = (r) => r && typeof r == "object" && r.isBuffer, Nk = (r) => typeof ReadableStream < "u" && r instanceof ReadableStream || um(r) && Rg(r.tee) && Rg(r.cancel) && Rg(r.getReader), Fk = (r) => um(r) && Rg(r.read) && Rg(r.pipe) && Bk(r.readable), I5 = (r) => Nk(r) || Fk(r);
class Uk extends Error {
  constructor(e, t) {
    super(e), this.reason = t.reason, this.url = t.url, this.response = t.response;
  }
  /** A best effort reason for why the fetch failed */
  reason;
  /** The URL that failed to load. Empty string if not available. */
  url;
  /** The Response object, if any. */
  response;
}
const zk = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, jk = /^([-\w.]+\/[-\w.+]+)/;
function lT(r, e) {
  return r.toLowerCase() === e.toLowerCase();
}
function Vk(r) {
  const e = jk.exec(r);
  return e ? e[1] : r;
}
function cT(r) {
  const e = zk.exec(r);
  return e ? e[1] : "";
}
const P5 = /\?.*/;
function Gk(r) {
  const e = r.match(P5);
  return e && e[0];
}
function A2(r) {
  return r.replace(P5, "");
}
function $k(r) {
  if (r.length < 50)
    return r;
  const e = r.slice(r.length - 15);
  return `${r.substr(0, 32)}...${e}`;
}
function Zy(r) {
  return ld(r) ? r.url : cd(r) ? r.name || "" : typeof r == "string" ? r : "";
}
function T2(r) {
  if (ld(r)) {
    const e = r, t = e.headers.get("content-type") || "", i = A2(e.url);
    return Vk(t) || cT(i);
  }
  return cd(r) ? r.type || "" : typeof r == "string" ? cT(r) : "";
}
function Hk(r) {
  return ld(r) ? r.headers["content-length"] || -1 : cd(r) ? r.size : typeof r == "string" ? r.length : r instanceof ArrayBuffer || ArrayBuffer.isView(r) ? r.byteLength : -1;
}
async function M5(r) {
  if (ld(r))
    return r;
  const e = {}, t = Hk(r);
  t >= 0 && (e["content-length"] = String(t));
  const i = Zy(r), n = T2(r);
  n && (e["content-type"] = n);
  const s = await Xk(r);
  s && (e["x-first-bytes"] = s), typeof r == "string" && (r = new TextEncoder().encode(r));
  const c = new Response(r, {
    headers: e
  });
  return Object.defineProperty(c, "url", {
    value: i
  }), c;
}
async function qk(r) {
  if (!r.ok)
    throw await Wk(r);
}
async function Wk(r) {
  const e = $k(r.url);
  let t = `Failed to fetch resource (${r.status}) ${r.statusText}: ${e}`;
  t = t.length > 100 ? `${t.slice(0, 100)}...` : t;
  const i = {
    reason: r.statusText,
    url: r.url,
    response: r
  };
  try {
    const n = r.headers.get("Content-Type");
    i.reason = !r.bodyUsed && n?.includes("application/json") ? await r.json() : await r.text();
  } catch {
  }
  return new Uk(t, i);
}
async function Xk(r) {
  if (typeof r == "string")
    return `data:,${r.slice(0, 5)}`;
  if (r instanceof Blob) {
    const t = r.slice(0, 5);
    return await new Promise((i) => {
      const n = new FileReader();
      n.onload = (s) => i(s?.target?.result), n.readAsDataURL(t);
    });
  }
  if (r instanceof ArrayBuffer) {
    const t = r.slice(0, 5);
    return `data:base64,${Zk(t)}`;
  }
  return null;
}
function Zk(r) {
  let e = "";
  const t = new Uint8Array(r);
  for (let i = 0; i < t.byteLength; i++)
    e += String.fromCharCode(t[i]);
  return btoa(e);
}
function Yk(r) {
  return !Jk(r) && !Kk(r);
}
function Jk(r) {
  return r.startsWith("http:") || r.startsWith("https:");
}
function Kk(r) {
  return r.startsWith("data:");
}
async function uT(r, e) {
  if (typeof r == "string") {
    const t = Mk(r);
    return Yk(t) && globalThis.loaders?.fetchNode ? globalThis.loaders?.fetchNode(t, e) : await fetch(t, e);
  }
  return await M5(r);
}
const hT = new Bp({
  id: "loaders.gl"
});
class Qk {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class e6 {
  console;
  constructor() {
    this.console = console;
  }
  log(...e) {
    return this.console.log.bind(this.console, ...e);
  }
  info(...e) {
    return this.console.info.bind(this.console, ...e);
  }
  warn(...e) {
    return this.console.warn.bind(this.console, ...e);
  }
  error(...e) {
    return this.console.error.bind(this.console, ...e);
  }
}
const R5 = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new e6(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: x2,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, t6 = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function L5() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders: r
  } = globalThis;
  return r._state || (r._state = {}), r._state;
}
function B5() {
  const r = L5();
  return r.globalOptions = r.globalOptions || {
    ...R5
  }, r.globalOptions;
}
function r6(r, e, t, i) {
  return t = t || [], t = Array.isArray(t) ? t : [t], i6(r, t), s6(e, r, i);
}
function i6(r, e) {
  fT(r, null, R5, t6, e);
  for (const t of e) {
    const i = r && r[t.id] || {}, n = t.options && t.options[t.id] || {}, s = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
    fT(i, t.id, n, s, e);
  }
}
function fT(r, e, t, i, n) {
  const s = e || "Top level", c = e ? `${e}.` : "";
  for (const o in r) {
    const d = !e && um(r[o]), m = o === "baseUri" && !e, y = o === "workerUrl" && e;
    if (!(o in t) && !m && !y) {
      if (o in i)
        hT.warn(`${s} loader option '${c}${o}' no longer supported, use '${i[o]}'`)();
      else if (!d) {
        const T = n6(o, n);
        hT.warn(`${s} loader option '${c}${o}' not recognized. ${T}`)();
      }
    }
  }
}
function n6(r, e) {
  const t = r.toLowerCase();
  let i = "";
  for (const n of e)
    for (const s in n.options) {
      if (r === s)
        return `Did you mean '${n.id}.${s}'?`;
      const c = s.toLowerCase();
      (t.startsWith(c) || c.startsWith(t)) && (i = i || `Did you mean '${n.id}.${s}'?`);
    }
  return i;
}
function s6(r, e, t) {
  const n = {
    ...r.options || {}
  };
  return o6(n, t), n.log === null && (n.log = new Qk()), dT(n, B5()), dT(n, e), n;
}
function dT(r, e) {
  for (const t in e)
    if (t in e) {
      const i = e[t];
      aT(i) && aT(r[t]) ? r[t] = {
        ...r[t],
        ...e[t]
      } : r[t] = e[t];
    }
}
function o6(r, e) {
  e && !("baseUri" in r) && (r.baseUri = e);
}
function S2(r) {
  return r ? (Array.isArray(r) && (r = r[0]), Array.isArray(r?.extensions)) : !1;
}
function E2(r) {
  py(r, "null loader"), py(S2(r), "invalid loader");
  let e;
  return Array.isArray(r) && (e = r[1], r = r[0], r = {
    ...r,
    options: {
      ...r.options,
      ...e
    }
  }), (r?.parseTextSync || r?.parseText) && (r.text = !0), r.text || (r.binary = !0), r;
}
const k5 = () => {
  const r = L5();
  return r.loaderRegistry = r.loaderRegistry || [], r.loaderRegistry;
};
function a6(r) {
  const e = k5();
  r = Array.isArray(r) ? r : [r];
  for (const t of r) {
    const i = E2(t);
    e.find((n) => i === n) || e.unshift(i);
  }
}
function l6() {
  return k5();
}
const c6 = /\.([^.]+)$/;
async function u6(r, e = [], t, i) {
  if (!O5(r))
    return null;
  let n = pT(r, e, {
    ...t,
    nothrow: !0
  }, i);
  if (n)
    return n;
  if (cd(r) && (r = await r.slice(0, 10).arrayBuffer(), n = pT(r, e, t, i)), !n && !t?.nothrow)
    throw new Error(D5(r));
  return n;
}
function pT(r, e = [], t, i) {
  if (!O5(r))
    return null;
  if (e && !Array.isArray(e))
    return E2(e);
  let n = [];
  e && (n = n.concat(e)), t?.ignoreRegisteredLoaders || n.push(...l6()), f6(n);
  const s = h6(r, n, t, i);
  if (!s && !t?.nothrow)
    throw new Error(D5(r));
  return s;
}
function h6(r, e, t, i) {
  const n = Zy(r), s = T2(r), c = A2(n) || i?.url;
  let o = null, d = "";
  return t?.mimeType && (o = cb(e, t?.mimeType), d = `match forced by supplied MIME type ${t?.mimeType}`), o = o || d6(e, c), d = d || (o ? `matched url ${c}` : ""), o = o || cb(e, s), d = d || (o ? `matched MIME type ${s}` : ""), o = o || g6(e, r), d = d || (o ? `matched initial data ${N5(r)}` : ""), t?.fallbackMimeType && (o = o || cb(e, t?.fallbackMimeType), d = d || (o ? `matched fallback MIME type ${s}` : "")), d && lk.log(1, `selectLoader selected ${o?.name}: ${d}.`), o;
}
function O5(r) {
  return !(r instanceof Response && r.status === 204);
}
function D5(r) {
  const e = Zy(r), t = T2(r);
  let i = "No valid loader found (";
  i += e ? `${C5(e)}, ` : "no url provided, ", i += `MIME type: ${t ? `"${t}"` : "not provided"}, `;
  const n = r ? N5(r) : "";
  return i += n ? ` first bytes: "${n}"` : "first bytes: not available", i += ")", i;
}
function f6(r) {
  for (const e of r)
    E2(e);
}
function d6(r, e) {
  const t = e && c6.exec(e), i = t && t[1];
  return i ? p6(r, i) : null;
}
function p6(r, e) {
  e = e.toLowerCase();
  for (const t of r)
    for (const i of t.extensions)
      if (i.toLowerCase() === e)
        return t;
  return null;
}
function cb(r, e) {
  for (const t of r)
    if (t.mimeTypes?.some((i) => lT(e, i)) || lT(e, `application/x.${t.id}`))
      return t;
  return null;
}
function g6(r, e) {
  if (!e)
    return null;
  for (const t of r)
    if (typeof e == "string") {
      if (m6(e, t))
        return t;
    } else if (ArrayBuffer.isView(e)) {
      if (gT(e.buffer, e.byteOffset, t))
        return t;
    } else if (e instanceof ArrayBuffer && gT(e, 0, t))
      return t;
  return null;
}
function m6(r, e) {
  return e.testText ? e.testText(r) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((i) => r.startsWith(i));
}
function gT(r, e, t) {
  return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((n) => _6(r, e, t, n));
}
function _6(r, e, t, i) {
  if (i instanceof ArrayBuffer)
    return Sk(i, r, i.byteLength);
  switch (typeof i) {
    case "function":
      return i(r);
    case "string":
      const n = sv(r, e, i.length);
      return i === n;
    default:
      return !1;
  }
}
function N5(r, e = 5) {
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? sv(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? sv(r, 0, e) : "";
}
function sv(r, e, t) {
  if (r.byteLength < e + t)
    return "";
  const i = new DataView(r);
  let n = "";
  for (let s = 0; s < t; s++)
    n += String.fromCharCode(i.getUint8(e + s));
  return n;
}
const y6 = 256 * 1024;
function* b6(r, e) {
  const t = e?.chunkSize || y6;
  let i = 0;
  const n = new TextEncoder();
  for (; i < r.length; ) {
    const s = Math.min(r.length - i, t), c = r.slice(i, i + s);
    i += s, yield n.encode(c);
  }
}
const v6 = 256 * 1024;
function* x6(r, e = {}) {
  const {
    chunkSize: t = v6
  } = e;
  let i = 0;
  for (; i < r.byteLength; ) {
    const n = Math.min(r.byteLength - i, t), s = new ArrayBuffer(n), c = new Uint8Array(r, i, n);
    new Uint8Array(s).set(c), i += n, yield s;
  }
}
const w6 = 1024 * 1024;
async function* A6(r, e) {
  const t = e?.chunkSize || w6;
  let i = 0;
  for (; i < r.size; ) {
    const n = i + t, s = await r.slice(i, n).arrayBuffer();
    i = n, yield s;
  }
}
function mT(r, e) {
  return x2 ? T6(r, e) : S6(r);
}
async function* T6(r, e) {
  const t = r.getReader();
  let i;
  try {
    for (; ; ) {
      const n = i || t.read();
      e?._streamReadAhead && (i = t.read());
      const {
        done: s,
        value: c
      } = await n;
      if (s)
        return;
      yield E5(c);
    }
  } catch {
    t.releaseLock();
  }
}
async function* S6(r, e) {
  for await (const t of r)
    yield E5(t);
}
function E6(r, e) {
  if (typeof r == "string")
    return b6(r, e);
  if (r instanceof ArrayBuffer)
    return x6(r, e);
  if (cd(r))
    return A6(r, e);
  if (I5(r))
    return mT(r, e);
  if (ld(r))
    return mT(r.body, e);
  throw new Error("makeIterator");
}
const F5 = "Cannot convert supplied data type";
function C6(r, e, t) {
  if (e.text && typeof r == "string")
    return r;
  if (Dk(r) && (r = r.buffer), r instanceof ArrayBuffer) {
    const i = r;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(i) : i;
  }
  if (ArrayBuffer.isView(r)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(r);
    let i = r.buffer;
    const n = r.byteLength || r.length;
    return (r.byteOffset !== 0 || n !== i.byteLength) && (i = i.slice(r.byteOffset, r.byteOffset + n)), i;
  }
  throw new Error(F5);
}
async function I6(r, e, t) {
  const i = r instanceof ArrayBuffer || ArrayBuffer.isView(r);
  if (typeof r == "string" || i)
    return C6(r, e);
  if (cd(r) && (r = await M5(r)), ld(r)) {
    const n = r;
    return await qk(n), e.binary ? await n.arrayBuffer() : await n.text();
  }
  if (I5(r) && (r = E6(r, t)), kk(r) || Ok(r))
    return Ik(r);
  throw new Error(F5);
}
function U5(r, e) {
  const t = B5(), i = r || t;
  return typeof i.fetch == "function" ? i.fetch : um(i.fetch) ? (n) => uT(n, i.fetch) : e?.fetch ? e?.fetch : uT;
}
function P6(r, e, t) {
  if (t)
    return t;
  const i = {
    fetch: U5(e, r),
    ...r
  };
  if (i.url) {
    const n = A2(i.url);
    i.baseUrl = n, i.queryString = Gk(i.url), i.filename = C5(n), i.baseUrl = Lk(n);
  }
  return Array.isArray(i.loaders) || (i.loaders = null), i;
}
function M6(r, e) {
  if (r && !Array.isArray(r))
    return r;
  let t;
  if (r && (t = Array.isArray(r) ? r : [r]), e && e.loaders) {
    const i = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    t = t ? [...t, ...i] : i;
  }
  return t && t.length ? t : void 0;
}
async function my(r, e, t, i) {
  e && !Array.isArray(e) && !S2(e) && (i = void 0, t = e, e = void 0), r = await r, t = t || {};
  const n = Zy(r), c = M6(e, i), o = await u6(r, c, t);
  return o ? (t = r6(t, o, c, n), i = P6(
    // @ts-expect-error
    {
      url: n,
      _parse: my,
      loaders: c
    },
    t,
    i || null
  ), await R6(o, r, t, i)) : null;
}
async function R6(r, e, t, i) {
  if (xk(r), t = ck(r.options, t), ld(e)) {
    const s = e, {
      ok: c,
      redirected: o,
      status: d,
      statusText: m,
      type: y,
      url: T
    } = s, P = Object.fromEntries(s.headers.entries());
    i.response = {
      headers: P,
      ok: c,
      redirected: o,
      status: d,
      statusText: m,
      type: y,
      url: T
    };
  }
  e = await I6(e, r, t);
  const n = r;
  if (n.parseTextSync && typeof e == "string")
    return n.parseTextSync(e, t, i);
  if (wk(r, t))
    return await Ak(r, e, t, i, my);
  if (n.parseText && typeof e == "string")
    return await n.parseText(e, t, i);
  if (n.parse)
    return await n.parse(e, t, i);
  throw qh(!n.parseSync), new Error(`${r.id} loader - no parser found and worker is disabled`);
}
function L6(r) {
  let e = 1 / 0, t = 1 / 0, i = 1 / 0, n = -1 / 0, s = -1 / 0, c = -1 / 0;
  const o = r.POSITION ? r.POSITION.value : [], d = o && o.length;
  for (let m = 0; m < d; m += 3) {
    const y = o[m], T = o[m + 1], P = o[m + 2];
    e = y < e ? y : e, t = T < t ? T : t, i = P < i ? P : i, n = y > n ? y : n, s = T > s ? T : s, c = P > c ? P : c;
  }
  return [[e, t, i], [n, s, c]];
}
async function Wh(r, e, t, i) {
  let n, s;
  !Array.isArray(e) && !S2(e) ? (n = [], s = e) : (n = e, s = t);
  const c = U5(s);
  let o = r;
  return typeof r == "string" && (o = await c(r)), cd(r) && (o = await c(r)), Array.isArray(n) ? await my(o, n, s) : await my(o, n, s);
}
const B6 = "4.3.2", k6 = globalThis.loaders?.parseImageNode, ov = typeof Image < "u", av = typeof ImageBitmap < "u", O6 = !!k6, lv = x2 ? !0 : O6;
function D6(r) {
  switch (r) {
    case "auto":
      return av || ov || lv;
    case "imagebitmap":
      return av;
    case "image":
      return ov;
    case "data":
      return lv;
    default:
      throw new Error(`@loaders.gl/images: image ${r} not supported in this environment`);
  }
}
function N6() {
  if (av)
    return "imagebitmap";
  if (ov)
    return "image";
  if (lv)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function F6(r) {
  const e = z6(r);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function U6(r) {
  switch (F6(r)) {
    case "data":
      return r;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = r.width, e.height = r.height, t.drawImage(r, 0, 0), t.getImageData(0, 0, r.width, r.height);
    default:
      throw new Error("getImageData");
  }
}
function z6(r) {
  return typeof ImageBitmap < "u" && r instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && r instanceof Image ? "image" : r && typeof r == "object" && r.data && r.width && r.height ? "data" : null;
}
const j6 = /^data:image\/svg\+xml/, V6 = /\.svg((\?|#).*)?$/;
function C2(r) {
  return r && (j6.test(r) || V6.test(r));
}
function G6(r, e) {
  if (C2(e)) {
    let i = new TextDecoder().decode(r);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (i = unescape(encodeURIComponent(i)));
    } catch (s) {
      throw new Error(s.message);
    }
    return `data:image/svg+xml;base64,${btoa(i)}`;
  }
  return z5(r, e);
}
function z5(r, e) {
  if (C2(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(r)]);
}
async function j5(r, e, t) {
  const i = G6(r, t), n = self.URL || self.webkitURL, s = typeof i != "string" && n.createObjectURL(i);
  try {
    return await $6(s || i, e);
  } finally {
    s && n.revokeObjectURL(s);
  }
}
async function $6(r, e) {
  const t = new Image();
  return t.src = r, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((i, n) => {
    try {
      t.onload = () => i(t), t.onerror = (s) => {
        const c = s instanceof Error ? s.message : "error";
        n(new Error(c));
      };
    } catch (s) {
      n(s);
    }
  });
}
const H6 = {};
let _T = !0;
async function q6(r, e, t) {
  let i;
  C2(t) ? i = await j5(r, e, t) : i = z5(r, t);
  const n = e && e.imagebitmap;
  return await W6(i, n);
}
async function W6(r, e = null) {
  if ((X6(e) || !_T) && (e = null), e)
    try {
      return await createImageBitmap(r, e);
    } catch (t) {
      console.warn(t), _T = !1;
    }
  return await createImageBitmap(r);
}
function X6(r) {
  for (const e in r || H6)
    return !1;
  return !0;
}
function Z6(r) {
  return !Q6(r, "ftyp", 4) || (r[8] & 96) === 0 ? null : Y6(r);
}
function Y6(r) {
  switch (J6(r, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function J6(r, e, t) {
  return String.fromCharCode(...r.slice(e, t));
}
function K6(r) {
  return [...r].map((e) => e.charCodeAt(0));
}
function Q6(r, e, t = 0) {
  const i = K6(e);
  for (let n = 0; n < i.length; ++n)
    if (i[n] !== r[n + t])
      return !1;
  return !0;
}
const mu = !1, Lg = !0;
function V5(r) {
  const e = hm(r);
  return tO(e) || nO(e) || rO(e) || iO(e) || eO(e);
}
function eO(r) {
  const e = new Uint8Array(r instanceof DataView ? r.buffer : r), t = Z6(e);
  return t ? {
    mimeType: t.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function tO(r) {
  const e = hm(r);
  return e.byteLength >= 24 && e.getUint32(0, mu) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, mu),
    height: e.getUint32(20, mu)
  } : null;
}
function rO(r) {
  const e = hm(r);
  return e.byteLength >= 10 && e.getUint32(0, mu) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, Lg),
    height: e.getUint16(8, Lg)
  } : null;
}
function iO(r) {
  const e = hm(r);
  return e.byteLength >= 14 && e.getUint16(0, mu) === 16973 && e.getUint32(2, Lg) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, Lg),
    height: e.getUint32(22, Lg)
  } : null;
}
function nO(r) {
  const e = hm(r);
  if (!(e.byteLength >= 3 && e.getUint16(0, mu) === 65496 && e.getUint8(2) === 255))
    return null;
  const {
    tableMarkers: i,
    sofMarkers: n
  } = sO();
  let s = 2;
  for (; s + 9 < e.byteLength; ) {
    const c = e.getUint16(s, mu);
    if (n.has(c))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(s + 5, mu),
        // Number of lines
        width: e.getUint16(s + 7, mu)
        // Number of pixels per line
      };
    if (!i.has(c))
      return null;
    s += 2, s += e.getUint16(s, mu);
  }
  return null;
}
function sO() {
  const r = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    r.add(t);
  return {
    tableMarkers: r,
    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
  };
}
function hm(r) {
  if (r instanceof DataView)
    return r;
  if (ArrayBuffer.isView(r))
    return new DataView(r.buffer);
  if (r instanceof ArrayBuffer)
    return new DataView(r);
  throw new Error("toDataView");
}
async function oO(r, e) {
  const {
    mimeType: t
  } = V5(r) || {}, i = globalThis.loaders?.parseImageNode;
  return py(i), await i(r, t);
}
async function aO(r, e, t) {
  e = e || {};
  const n = (e.image || {}).type || "auto", {
    url: s
  } = t || {}, c = lO(n);
  let o;
  switch (c) {
    case "imagebitmap":
      o = await q6(r, e, s);
      break;
    case "image":
      o = await j5(r, e, s);
      break;
    case "data":
      o = await oO(r);
      break;
    default:
      py(!1);
  }
  return n === "data" && (o = U6(o)), o;
}
function lO(r) {
  switch (r) {
    case "auto":
    case "data":
      return N6();
    default:
      return D6(r), r;
  }
}
const cO = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], uO = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], hO = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, fO = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: B6,
  mimeTypes: uO,
  extensions: cO,
  parse: aO,
  // TODO: byteOffset, byteLength;
  tests: [(r) => !!V5(new DataView(r))],
  options: hO
}, Ni = new Bp({
  id: "deck"
}), Ih = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
}, ub = 1, cg = 2, hb = 3, fb = 4, dO = 2, pO = (r) => ({
  /* Layer events */
  "layer.changeFlag": (e, t, i) => {
    r.log(hb, `${e.id} ${t}: `, i[t])();
  },
  "layer.initialize": (e) => {
    r.log(ub, `Initializing ${e}`)();
  },
  "layer.update": (e, t) => {
    if (t) {
      const i = e.getChangeFlags();
      r.log(cg, `Updating ${e} because: ${Object.keys(i).filter((n) => i[n]).join(", ")}`)();
    } else
      r.log(fb, `${e} does not need update`)();
  },
  "layer.matched": (e, t) => {
    t && r.log(fb, `Matched ${e}, state transfered`)();
  },
  "layer.finalize": (e) => {
    r.log(ub, `Finalizing ${e}`)();
  },
  /* CompositeLayer events */
  "compositeLayer.renderLayers": (e, t, i) => {
    t ? r.log(cg, `Composite layer rendered new subLayers ${e}`, i)() : r.log(fb, `Composite layer reused subLayers ${e}`, i)();
  },
  /* LayerManager events */
  "layerManager.setLayers": (e, t, i) => {
    t && r.log(cg, `Updating ${i.length} deck layers`)();
  },
  "layerManager.activateViewport": (e, t) => {
    r.log(hb, "Viewport changed", t)();
  },
  /* AttributeManager events */
  "attributeManager.invalidate": (e, t, i) => {
    r.log(ub, i ? `invalidated attributes ${i} (${t}) for ${e.id}` : `invalidated all attributes for ${e.id}`)();
  },
  "attributeManager.updateStart": (e) => {
    Ih.attributeUpdateMessages.length = 0, Ih.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (e, t) => {
    const i = Math.round(Date.now() - Ih.attributeManagerUpdateStart);
    r.groupCollapsed(cg, `Updated attributes for ${t} instances in ${e.id} in ${i}ms`)();
    for (const n of Ih.attributeUpdateMessages)
      r.log(hb, n)();
    r.groupEnd(cg)();
  },
  /* Attribute events */
  "attribute.updateStart": (e) => {
    Ih.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (e, t) => {
    const i = `${e.id} allocated ${t}`;
    Ih.attributeUpdateMessages.push(i);
  },
  "attribute.updateEnd": (e, t) => {
    const i = Math.round(Date.now() - Ih.attributeUpdateStart), n = `${e.id} updated ${t} in ${i}ms`;
    Ih.attributeUpdateMessages.push(n);
  },
  /* Render events */
  "deckRenderer.renderLayers": (e, t, i) => {
    const {
      pass: n,
      redrawReason: s,
      stats: c
    } = i;
    for (const o of t) {
      const {
        totalCount: d,
        visibleCount: m,
        compositeCount: y,
        pickableCount: T
      } = o, I = d - y - m;
      r.log(dO, `RENDER #${e.renderCount}   ${m} (of ${d} layers) to ${n} because ${s}   (${I} hidden, ${y} composite ${T} pickable)`)(), c && c.get("Redraw Layers").add(m);
    }
  }
});
var gO = {};
let _y = {};
gO.NODE_ENV !== "production" && (_y = pO(Ni));
function mO(r) {
  _y = r;
}
function Vo(r, e, t, i) {
  Ni.level > 0 && _y[r] && _y[r].call(null, e, t, i);
}
function _O(r) {
  const e = r[0], t = r[r.length - 1];
  return e === "{" && t === "}" || e === "[" && t === "]";
}
const yO = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: _O,
  parseTextSync: JSON.parse
};
function bO() {
  const r = "9.2.2", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== r)
    throw new Error(`deck.gl - multiple versions detected: ${e} vs ${r}`);
  return e || (Ni.log(1, `deck.gl ${r}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: r,
    version: r,
    log: Ni,
    // experimental
    _registerLoggers: mO
  }, a6([
    yO,
    // @ts-expect-error non-standard Loader format
    [fO, {
      imagebitmap: {
        premultiplyAlpha: "none"
      }
    }]
  ])), r;
}
const vO = bO();
function I2(r, e) {
  if (!r)
    throw new Error(e || "shadertools: assertion failed.");
}
const db = {
  number: {
    type: "number",
    validate(r, e) {
      return Number.isFinite(r) && typeof e == "object" && (e.max === void 0 || r <= e.max) && (e.min === void 0 || r >= e.min);
    }
  },
  array: {
    type: "array",
    validate(r, e) {
      return Array.isArray(r) || ArrayBuffer.isView(r);
    }
  }
};
function xO(r) {
  const e = {};
  for (const [t, i] of Object.entries(r))
    e[t] = wO(i);
  return e;
}
function wO(r) {
  let e = yT(r);
  if (e !== "object")
    return {
      value: r,
      ...db[e],
      type: e
    };
  if (typeof r == "object")
    return r ? r.type !== void 0 ? {
      ...r,
      ...db[r.type],
      type: r.type
    } : r.value === void 0 ? {
      type: "object",
      value: r
    } : (e = yT(r.value), {
      ...r,
      ...db[e],
      type: e
    }) : {
      type: "object",
      value: null
    };
  throw new Error("props");
}
function yT(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) ? "array" : typeof r;
}
const AO = (
  /* glsl */
  `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
), TO = (
  /* glsl */
  `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
), SO = {
  vertex: AO,
  fragment: TO
}, bT = /void\s+main\s*\([^)]*\)\s*\{\n?/, vT = /}\n?[^{}]*$/, pb = [], U_ = "__LUMA_INJECT_DECLARATIONS__";
function EO(r) {
  const e = {
    vertex: {},
    fragment: {}
  };
  for (const t in r) {
    let i = r[t];
    const n = CO(t);
    typeof i == "string" && (i = {
      order: 0,
      injection: i
    }), e[n][t] = i;
  }
  return e;
}
function CO(r) {
  const e = r.slice(0, 2);
  switch (e) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(e);
  }
}
function yy(r, e, t, i = !1) {
  const n = e === "vertex";
  for (const s in t) {
    const c = t[s];
    c.sort((d, m) => d.order - m.order), pb.length = c.length;
    for (let d = 0, m = c.length; d < m; ++d)
      pb[d] = c[d].injection;
    const o = `${pb.join(`
`)}
`;
    switch (s) {
      // declarations are injected before the main function
      case "vs:#decl":
        n && (r = r.replace(U_, o));
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        n && (r = r.replace(bT, (d) => d + o));
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        n && (r = r.replace(vT, (d) => o + d));
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        n || (r = r.replace(U_, o));
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        n || (r = r.replace(bT, (d) => d + o));
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        n || (r = r.replace(vT, (d) => o + d));
        break;
      default:
        r = r.replace(s, (d) => d + o);
    }
  }
  return r = r.replace(U_, ""), i && (r = r.replace(/\}\s*$/, (s) => s + SO[e])), r;
}
function by(r) {
  r.map((e) => IO(e));
}
function IO(r) {
  if (r.instance)
    return;
  by(r.dependencies || []);
  const {
    propTypes: e = {},
    deprecations: t = [],
    // defines = {},
    inject: i = {}
  } = r, n = {
    normalizedInjections: EO(i),
    parsedDeprecations: PO(t)
  };
  e && (n.propValidators = xO(e)), r.instance = n;
  let s = {};
  e && (s = Object.entries(e).reduce((c, [o, d]) => {
    const m = d?.value;
    return m && (c[o] = m), c;
  }, {})), r.defaultUniforms = {
    ...r.defaultUniforms,
    ...s
  };
}
function G5(r, e, t) {
  r.deprecations?.forEach((i) => {
    i.regex?.test(e) && (i.deprecated ? t.deprecated(i.old, i.new)() : t.removed(i.old, i.new)());
  });
}
function PO(r) {
  return r.forEach((e) => {
    switch (e.type) {
      case "function":
        e.regex = new RegExp(`\\b${e.old}\\(`);
        break;
      default:
        e.regex = new RegExp(`${e.type} ${e.old};`);
    }
  }), r;
}
function P2(r) {
  by(r);
  const e = {}, t = {};
  $5({
    modules: r,
    level: 0,
    moduleMap: e,
    moduleDepth: t
  });
  const i = Object.keys(t).sort((n, s) => t[s] - t[n]).map((n) => e[n]);
  return by(i), i;
}
function $5(r) {
  const {
    modules: e,
    level: t,
    moduleMap: i,
    moduleDepth: n
  } = r;
  if (t >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const s of e)
    i[s.name] = s, (n[s.name] === void 0 || n[s.name] < t) && (n[s.name] = t);
  for (const s of e)
    s.dependencies && $5({
      modules: s.dependencies,
      level: t + 1,
      moduleMap: i,
      moduleDepth: n
    });
}
function MO(r) {
  switch (r?.gpu.toLowerCase()) {
    case "apple":
      return (
        /* glsl */
        `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "nvidia":
      return (
        /* glsl */
        `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
      );
    case "intel":
      return (
        /* glsl */
        `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "amd":
      return (
        /* glsl */
        `#define AMD_GPU
`
      );
    default:
      return (
        /* glsl */
        `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
  }
}
function RO(r, e) {
  if (Number(r.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (e) {
    case "vertex":
      return r = xT(r, LO), r;
    case "fragment":
      return r = xT(r, BO), r;
    default:
      throw new Error(e);
  }
}
const H5 = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], LO = [
  ...H5,
  // `attribute` keyword replaced with `in`
  [cv("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [cv("varying"), "out $1"]
], BO = [
  ...H5,
  // `varying` keyword replaced with `in`
  [cv("varying"), "in $1"]
];
function xT(r, e) {
  for (const [t, i] of e)
    r = r.replace(t, i);
  return r;
}
function cv(r) {
  return new RegExp(`\\b${r}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function q5(r, e) {
  let t = "";
  for (const i in r) {
    const n = r[i];
    if (t += `void ${n.signature} {
`, n.header && (t += `  ${n.header}`), e[i]) {
      const s = e[i];
      s.sort((c, o) => c.order - o.order);
      for (const c of s)
        t += `  ${c.injection}
`;
    }
    n.footer && (t += `  ${n.footer}`), t += `}
`;
  }
  return t;
}
function W5(r) {
  const e = {
    vertex: {},
    fragment: {}
  };
  for (const t of r) {
    let i, n;
    typeof t != "string" ? (i = t, n = i.hook) : (i = {}, n = t), n = n.trim();
    const [s, c] = n.split(":"), o = n.replace(/\(.+/, ""), d = Object.assign(i, {
      signature: c
    });
    switch (s) {
      case "vs":
        e.vertex[o] = d;
        break;
      case "fs":
        e.fragment[o] = d;
        break;
      default:
        throw new Error(s);
    }
  }
  return e;
}
function kO(r, e) {
  return {
    name: OO(r, e),
    language: "glsl",
    version: DO(r)
  };
}
function OO(r, e = "unnamed") {
  const i = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(r);
  return i ? i[1] : e;
}
function DO(r) {
  let e = 100;
  const t = r.match(/[^\s]+/g);
  if (t && t.length >= 2 && t[0] === "#version") {
    const i = parseInt(t[1], 10);
    Number.isFinite(i) && (e = i);
  }
  if (e !== 100 && e !== 300)
    throw new Error(`Invalid GLSL version ${e}`);
  return e;
}
const X5 = `

${U_}
`, NO = (
  /* glsl */
  `precision highp float;
`
);
function FO(r) {
  const e = P2(r.modules || []);
  return {
    source: zO(r.platformInfo, {
      ...r,
      source: r.source,
      stage: "vertex",
      modules: e
    }),
    getUniforms: Z5(e)
  };
}
function UO(r) {
  const {
    vs: e,
    fs: t
  } = r, i = P2(r.modules || []);
  return {
    vs: wT(r.platformInfo, {
      ...r,
      source: e,
      stage: "vertex",
      modules: i
    }),
    fs: wT(r.platformInfo, {
      ...r,
      // @ts-expect-error
      source: t,
      stage: "fragment",
      modules: i
    }),
    getUniforms: Z5(i)
  };
}
function zO(r, e) {
  const {
    // id,
    source: t,
    stage: i,
    modules: n,
    // defines = {},
    hookFunctions: s = [],
    inject: c = {},
    log: o
  } = e;
  I2(typeof t == "string", "shader source must be a string");
  const d = t;
  let m = "";
  const y = W5(s), T = {}, P = {}, I = {};
  for (const k in c) {
    const $ = typeof c[k] == "string" ? {
      injection: c[k],
      order: 0
    } : c[k], G = /^(v|f)s:(#)?([\w-]+)$/.exec(k);
    if (G) {
      const te = G[2], Z = G[3];
      te ? Z === "decl" ? P[k] = [$] : I[k] = [$] : T[k] = [$];
    } else
      I[k] = [$];
  }
  const D = n;
  for (const k of D) {
    o && G5(k, d, o);
    const $ = Y5(k, "wgsl");
    m += $;
    const G = k.injections?.[i] || {};
    for (const te in G) {
      const Z = /^(v|f)s:#([\w-]+)$/.exec(te);
      if (Z) {
        const J = Z[2] === "decl" ? P : I;
        J[te] = J[te] || [], J[te].push(G[te]);
      } else
        T[te] = T[te] || [], T[te].push(G[te]);
    }
  }
  return m += X5, m = yy(m, i, P), m += q5(y[i], T), m += d, m = yy(m, i, I), m;
}
function wT(r, e) {
  const {
    source: t,
    stage: i,
    language: n = "glsl",
    modules: s,
    defines: c = {},
    hookFunctions: o = [],
    inject: d = {},
    prologue: m = !0,
    log: y
  } = e;
  I2(typeof t == "string", "shader source must be a string");
  const T = n === "glsl" ? kO(t).version : -1, P = r.shaderLanguageVersion, I = T === 100 ? "#version 100" : "#version 300 es", k = t.split(`
`).slice(1).join(`
`), $ = {};
  s.forEach((re) => {
    Object.assign($, re.defines);
  }), Object.assign($, c);
  let G = "";
  switch (n) {
    case "wgsl":
      break;
    case "glsl":
      G = m ? `${I}

// ----- PROLOGUE -------------------------
${`#define SHADER_TYPE_${i.toUpperCase()}`}

${MO(r)}
${i === "fragment" ? NO : ""}

// ----- APPLICATION DEFINES -------------------------

${jO($)}

` : `${I}
`;
      break;
  }
  const te = W5(o), Z = {}, H = {}, J = {};
  for (const re in d) {
    const be = typeof d[re] == "string" ? {
      injection: d[re],
      order: 0
    } : d[re], pe = /^(v|f)s:(#)?([\w-]+)$/.exec(re);
    if (pe) {
      const oe = pe[2], Ee = pe[3];
      oe ? Ee === "decl" ? H[re] = [be] : J[re] = [be] : Z[re] = [be];
    } else
      J[re] = [be];
  }
  for (const re of s) {
    y && G5(re, k, y);
    const be = Y5(re, i);
    G += be;
    const pe = re.instance?.normalizedInjections[i] || {};
    for (const oe in pe) {
      const Ee = /^(v|f)s:#([\w-]+)$/.exec(oe);
      if (Ee) {
        const _e = Ee[2] === "decl" ? H : J;
        _e[oe] = _e[oe] || [], _e[oe].push(pe[oe]);
      } else
        Z[oe] = Z[oe] || [], Z[oe].push(pe[oe]);
    }
  }
  return G += "// ----- MAIN SHADER SOURCE -------------------------", G += X5, G = yy(G, i, H), G += q5(te[i], Z), G += k, G = yy(G, i, J), n === "glsl" && T !== P && (G = RO(G, i)), G.trim();
}
function Z5(r) {
  return function(t) {
    const i = {};
    for (const n of r) {
      const s = n.getUniforms?.(t, i);
      Object.assign(i, s);
    }
    return i;
  };
}
function jO(r = {}) {
  let e = "";
  for (const t in r) {
    const i = r[t];
    (i || Number.isFinite(i)) && (e += `#define ${t.toUpperCase()} ${r[t]}
`);
  }
  return e;
}
function Y5(r, e) {
  let t;
  switch (e) {
    case "vertex":
      t = r.vs || "";
      break;
    case "fragment":
      t = r.fs || "";
      break;
    case "wgsl":
      t = r.source || "";
      break;
    default:
      I2(!1);
  }
  if (!r.name)
    throw new Error("Shader module must have a name");
  const i = r.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
  let n = `// ----- MODULE ${r.name} ---------------

`;
  return e !== "wgsl" && (n += `#define MODULE_${i}
`), n += `${t}
`, n;
}
const VO = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/, GO = /^\s*\#\s*endif\s*$/;
function $O(r, e) {
  const t = r.split(`
`), i = [];
  let n = !0, s = null;
  for (const c of t) {
    const o = c.match(VO), d = c.match(GO);
    o ? (s = o[1], n = !!e?.defines?.[s]) : d ? n = !0 : n && i.push(c);
  }
  return i.join(`
`);
}
class kf {
  /** Default ShaderAssembler instance */
  static defaultShaderAssembler;
  /** Hook functions */
  _hookFunctions = [];
  /** Shader modules */
  _defaultModules = [];
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return kf.defaultShaderAssembler = kf.defaultShaderAssembler || new kf(), kf.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(e) {
    this._defaultModules.find((t) => t.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(e) {
    const t = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((i) => i.name !== t);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(e, t) {
    t && (e = Object.assign(t, {
      hook: e
    })), this._hookFunctions.push(e);
  }
  /**
   * Assemble a WGSL unified shader
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleWGSLShader(e) {
    const t = this._getModuleList(e.modules), i = this._hookFunctions, {
      source: n,
      getUniforms: s
    } = FO({
      ...e,
      // @ts-expect-error
      source: e.source,
      modules: t,
      hookFunctions: i
    });
    return {
      source: e.platformInfo.shaderLanguage === "wgsl" ? $O(n) : n,
      getUniforms: s,
      modules: t
    };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleGLSLShaderPair(e) {
    const t = this._getModuleList(e.modules), i = this._hookFunctions;
    return {
      ...UO({
        ...e,
        // @ts-expect-error
        vs: e.vs,
        // @ts-expect-error
        fs: e.fs,
        modules: t,
        hookFunctions: i
      }),
      modules: t
    };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(e = []) {
    const t = new Array(this._defaultModules.length + e.length), i = {};
    let n = 0;
    for (let s = 0, c = this._defaultModules.length; s < c; ++s) {
      const o = this._defaultModules[s], d = o.name;
      t[n++] = o, i[d] = !0;
    }
    for (let s = 0, c = e.length; s < c; ++s) {
      const o = e[s], d = o.name;
      i[d] || (t[n++] = o, i[d] = !0);
    }
    return t.length = n, by(t), t;
  }
}
const HO = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
), qO = `#version 300 es
${HO}`;
function WO(r) {
  const {
    input: e,
    inputChannels: t,
    output: i
  } = {};
  if (!e)
    return qO;
  if (!t)
    throw new Error("inputChannels");
  const n = XO(t), s = ZO(e, t);
  return `#version 300 es
in ${n} ${e};
out vec4 ${i};
void main() {
  ${i} = ${s};
}`;
}
function XO(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${r}`);
  }
}
function ZO(r, e) {
  switch (e) {
    case 1:
      return `vec4(${r}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${r}, 0.0, 1.0)`;
    case 3:
      return `vec4(${r}, 1.0)`;
    case 4:
      return r;
    default:
      throw new Error(`invalid channels: ${e}`);
  }
}
class YO {
  stats = /* @__PURE__ */ new Map();
  getStats(e) {
    return this.get(e);
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new kp({
      id: e
    })), this.stats.get(e);
  }
}
const J5 = new YO(), Ht = new Bp({
  id: "luma.gl"
}), gb = {};
function Yy(r = "id") {
  gb[r] = gb[r] || 1;
  const e = gb[r]++;
  return `${r}-${e}`;
}
let yn = class {
  /** Default properties for resource */
  static defaultProps = {
    id: "undefined",
    handle: void 0,
    userData: void 0
  };
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
  }
  /** props.id, for debugging. */
  id;
  props;
  userData = {};
  _device;
  /** Whether this resource has been destroyed */
  destroyed = !1;
  /** For resources that allocate GPU memory */
  allocatedBytes = 0;
  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
  _attachedResources = /* @__PURE__ */ new Set();
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(e, t, i) {
    if (!e)
      throw new Error("no device");
    this._device = e, this.props = JO(t, i);
    const n = this.props.id !== "undefined" ? this.props.id : Yy(this[Symbol.toStringTag]);
    this.props.id = n, this.id = n, this.userData = this.props.userData || {}, this.addStats();
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(e) {
    this._attachedResources.add(e);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(e) {
    this._attachedResources.delete(e);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(e) {
    this._attachedResources.delete(e) && e.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const e of Object.values(this._attachedResources))
      e.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get(`${t}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(e, t = this[Symbol.toStringTag]) {
    const i = this._device.statsManager.getStats("Resource Counts");
    i.get("GPU Memory").addCount(e), i.get(`${t} Memory`).addCount(e), this.allocatedBytes = e;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
    const t = this._device.statsManager.getStats("Resource Counts");
    t.get("GPU Memory").subtractCount(this.allocatedBytes), t.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get("Resources Created").incrementCount(), e.get(`${t}s Created`).incrementCount(), e.get(`${t}s Active`).incrementCount();
  }
};
function JO(r, e) {
  const t = {
    ...e
  };
  for (const i in r)
    r[i] !== void 0 && (t[i] = r[i]);
  return t;
}
let us = class z_ extends yn {
  /** Index buffer */
  static INDEX = 16;
  /** Vertex buffer */
  static VERTEX = 32;
  /** Uniform buffer */
  static UNIFORM = 64;
  /** Storage buffer */
  static STORAGE = 128;
  static INDIRECT = 256;
  static QUERY_RESOLVE = 512;
  // Usage Flags
  static MAP_READ = 1;
  static MAP_WRITE = 2;
  static COPY_SRC = 4;
  static COPY_DST = 8;
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /** The usage with which this buffer was created */
  usage;
  /** For index buffers, whether indices are 16 or 32 bit */
  indexType;
  /** "Time" of last update, can be used to check if redraw is needed */
  updateTimestamp;
  constructor(e, t) {
    const i = {
      ...t
    };
    (t.usage || 0) & z_.INDEX && !t.indexType && (t.data instanceof Uint32Array ? i.indexType = "uint32" : t.data instanceof Uint16Array && (i.indexType = "uint16")), delete i.data, super(e, i, z_.defaultProps), this.usage = i.usage || 0, this.indexType = i.indexType, this.updateTimestamp = e.incrementTimestamp();
  }
  /**
   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
   * @note Does not copy contents of the cloned Buffer.
   */
  clone(e) {
    return this.device.createBuffer({
      ...this.props,
      ...e
    });
  }
  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
  /** Max amount of debug data saved. Two vec4's */
  static DEBUG_DATA_MAX_LENGTH = 32;
  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
  debugData = new ArrayBuffer(0);
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(e, t, i) {
    const n = ArrayBuffer.isView(e) ? e.buffer : e, s = Math.min(e ? e.byteLength : i, z_.DEBUG_DATA_MAX_LENGTH);
    n === null ? this.debugData = new ArrayBuffer(s) : t === 0 && i === n.byteLength ? this.debugData = n.slice(0, s) : this.debugData = n.slice(t, t + s);
  }
  static defaultProps = {
    ...yn.defaultProps,
    usage: 0,
    // Buffer.COPY_DST | Buffer.COPY_SRC
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    onMapped: void 0
  };
};
function K5(r) {
  const [e, t, i] = L2[r], n = r.includes("norm"), s = !n && !r.startsWith("float"), c = r.startsWith("s");
  return {
    signedType: e,
    primitiveType: t,
    byteLength: i,
    normalized: n,
    integer: s,
    signed: c
  };
}
function KO(r) {
  const e = r;
  switch (e) {
    case "uint8":
      return "unorm8";
    case "sint8":
      return "snorm8";
    case "uint16":
      return "unorm16";
    case "sint16":
      return "snorm16";
    default:
      return e;
  }
}
function QO(r, e) {
  switch (e) {
    case 1:
      return r;
    // Pad upwards to even multiple of 2
    case 2:
      return r + r % 2;
    // Pad upwards to even multiple of 2
    default:
      return r + (4 - r % 4) % 4;
  }
}
function M2(r) {
  const e = ArrayBuffer.isView(r) ? r.constructor : r;
  if (e === Uint8ClampedArray)
    return "uint8";
  const t = Object.values(L2).find((i) => e === i[4]);
  if (!t)
    throw new Error(e.name);
  return t[0];
}
function R2(r) {
  const [, , , , e] = L2[r];
  return e;
}
const L2 = {
  uint8: ["uint8", "u32", 1, !1, Uint8Array],
  sint8: ["sint8", "i32", 1, !1, Int8Array],
  unorm8: ["uint8", "f32", 1, !0, Uint8Array],
  snorm8: ["sint8", "f32", 1, !0, Int8Array],
  uint16: ["uint16", "u32", 2, !1, Uint16Array],
  sint16: ["sint16", "i32", 2, !1, Int16Array],
  unorm16: ["uint16", "u32", 2, !0, Uint16Array],
  snorm16: ["sint16", "i32", 2, !0, Int16Array],
  float16: ["float16", "f16", 2, !1, Uint16Array],
  float32: ["float32", "f32", 4, !1, Float32Array],
  uint32: ["uint32", "u32", 4, !1, Uint32Array],
  sint32: ["sint32", "i32", 4, !1, Int32Array]
};
function B2(r) {
  let e;
  r.endsWith("-webgl") && (r.replace("-webgl", ""), e = !0);
  const [t, i] = r.split("x"), n = t, s = i ? parseInt(i) : 1, c = K5(n), o = {
    type: n,
    components: s,
    byteLength: c.byteLength * s,
    integer: c.integer,
    signed: c.signed,
    normalized: c.normalized
  };
  return e && (o.webglOnly = !0), o;
}
function eD(r, e, t) {
  const i = t ? KO(r) : r;
  switch (i) {
    // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below
    case "unorm8":
      return e === 1 ? "unorm8" : e === 3 ? "unorm8x3-webgl" : `${i}x${e}`;
    case "snorm8":
    case "uint8":
    case "sint8":
    // WebGPU 8 bit formats must be aligned to 16 bit boundaries');
    // fall through
    case "uint16":
    case "sint16":
    case "unorm16":
    case "snorm16":
    case "float16":
      if (e === 1 || e === 3)
        throw new Error(`size: ${e}`);
      return `${i}x${e}`;
    default:
      return e === 1 ? i : `${i}x${e}`;
  }
}
function tD(r, e, t) {
  if (!e || e > 4)
    throw new Error(`size ${e}`);
  const i = e, n = M2(r);
  return eD(n, i, t);
}
function rD(r) {
  let e;
  switch (r.primitiveType) {
    case "f32":
      e = "float32";
      break;
    case "i32":
      e = "sint32";
      break;
    case "u32":
      e = "uint32";
      break;
    case "f16":
      return r.components <= 2 ? "float16x2" : "float16x4";
  }
  return r.components === 1 ? e : `${e}x${r.components}`;
}
const ko = "texture-compression-bc", _n = "texture-compression-astc", lu = "texture-compression-etc2", iD = "texture-compression-etc1-webgl", Wm = "texture-compression-pvrtc-webgl", mb = "texture-compression-atc-webgl", Xm = "float32-renderable-webgl", _b = "float16-renderable-webgl", nD = "rgb9e5ufloat-renderable-webgl", yb = "snorm8-renderable-webgl", ug = "norm16-renderable-webgl", bb = "snorm16-renderable-webgl", Zm = "float32-filterable", AT = "float16-filterable-webgl";
function Q5(r) {
  const e = aD[r];
  if (!e)
    throw new Error(`Unsupported texture format ${r}`);
  return e;
}
const sD = {
  // 8-bit formats
  r8unorm: {},
  rg8unorm: {},
  "rgb8unorm-webgl": {},
  rgba8unorm: {},
  "rgba8unorm-srgb": {},
  r8snorm: {
    render: yb
  },
  rg8snorm: {
    render: yb
  },
  "rgb8snorm-webgl": {},
  rgba8snorm: {
    render: yb
  },
  r8uint: {},
  rg8uint: {},
  rgba8uint: {},
  r8sint: {},
  rg8sint: {},
  rgba8sint: {},
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  r16unorm: {
    f: ug
  },
  rg16unorm: {
    render: ug
  },
  "rgb16unorm-webgl": {
    f: ug
  },
  // rgb not renderable
  rgba16unorm: {
    render: ug
  },
  r16snorm: {
    f: bb
  },
  rg16snorm: {
    render: bb
  },
  "rgb16snorm-webgl": {
    f: ug
  },
  // rgb not renderable
  rgba16snorm: {
    render: bb
  },
  r16uint: {},
  rg16uint: {},
  rgba16uint: {},
  r16sint: {},
  rg16sint: {},
  rgba16sint: {},
  r16float: {
    render: _b,
    filter: "float16-filterable-webgl"
  },
  rg16float: {
    render: _b,
    filter: AT
  },
  rgba16float: {
    render: _b,
    filter: AT
  },
  r32uint: {},
  rg32uint: {},
  rgba32uint: {},
  r32sint: {},
  rg32sint: {},
  rgba32sint: {},
  r32float: {
    render: Xm,
    filter: Zm
  },
  rg32float: {
    render: !1,
    filter: Zm
  },
  "rgb32float-webgl": {
    render: Xm,
    filter: Zm
  },
  rgba32float: {
    render: Xm,
    filter: Zm
  },
  // Packed 16-bit formats
  "rgba4unorm-webgl": {
    channels: "rgba",
    bitsPerChannel: [4, 4, 4, 4],
    packed: !0
  },
  "rgb565unorm-webgl": {
    channels: "rgb",
    bitsPerChannel: [5, 6, 5, 0],
    packed: !0
  },
  "rgb5a1unorm-webgl": {
    channels: "rgba",
    bitsPerChannel: [5, 5, 5, 1],
    packed: !0
  },
  // Packed 32 bit formats
  rgb9e5ufloat: {
    channels: "rgb",
    packed: !0,
    render: nD
  },
  // , filter: true},
  rg11b10ufloat: {
    channels: "rgb",
    bitsPerChannel: [11, 11, 10, 0],
    packed: !0,
    p: 1,
    render: Xm
  },
  rgb10a2unorm: {
    channels: "rgba",
    bitsPerChannel: [10, 10, 10, 2],
    packed: !0,
    p: 1
  },
  rgb10a2uint: {
    channels: "rgba",
    bitsPerChannel: [10, 10, 10, 2],
    packed: !0,
    p: 1
  },
  // Depth/stencil Formats
  // Depth and stencil formats
  stencil8: {
    attachment: "stencil",
    bitsPerChannel: [8, 0, 0, 0],
    dataType: "uint8"
  },
  depth16unorm: {
    attachment: "depth",
    bitsPerChannel: [16, 0, 0, 0],
    dataType: "uint16"
  },
  depth24plus: {
    attachment: "depth",
    bitsPerChannel: [24, 0, 0, 0],
    dataType: "uint32"
  },
  depth32float: {
    attachment: "depth",
    bitsPerChannel: [32, 0, 0, 0],
    dataType: "float32"
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    attachment: "depth-stencil",
    bitsPerChannel: [24, 8, 0, 0],
    packed: !0
  },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": {
    attachment: "depth-stencil",
    bitsPerChannel: [32, 8, 0, 0],
    packed: !0
  }
}, oD = {
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": {
    f: ko
  },
  "bc1-rgb-unorm-srgb-webgl": {
    f: ko
  },
  "bc1-rgba-unorm": {
    f: ko
  },
  "bc1-rgba-unorm-srgb": {
    f: ko
  },
  "bc2-rgba-unorm": {
    f: ko
  },
  "bc2-rgba-unorm-srgb": {
    f: ko
  },
  "bc3-rgba-unorm": {
    f: ko
  },
  "bc3-rgba-unorm-srgb": {
    f: ko
  },
  "bc4-r-unorm": {
    f: ko
  },
  "bc4-r-snorm": {
    f: ko
  },
  "bc5-rg-unorm": {
    f: ko
  },
  "bc5-rg-snorm": {
    f: ko
  },
  "bc6h-rgb-ufloat": {
    f: ko
  },
  "bc6h-rgb-float": {
    f: ko
  },
  "bc7-rgba-unorm": {
    f: ko
  },
  "bc7-rgba-unorm-srgb": {
    f: ko
  },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": {
    f: lu
  },
  "etc2-rgb8unorm-srgb": {
    f: lu
  },
  "etc2-rgb8a1unorm": {
    f: lu
  },
  "etc2-rgb8a1unorm-srgb": {
    f: lu
  },
  "etc2-rgba8unorm": {
    f: lu
  },
  "etc2-rgba8unorm-srgb": {
    f: lu
  },
  "eac-r11unorm": {
    f: lu
  },
  "eac-r11snorm": {
    f: lu
  },
  "eac-rg11unorm": {
    f: lu
  },
  "eac-rg11snorm": {
    f: lu
  },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": {
    f: _n
  },
  "astc-4x4-unorm-srgb": {
    f: _n
  },
  "astc-5x4-unorm": {
    f: _n
  },
  "astc-5x4-unorm-srgb": {
    f: _n
  },
  "astc-5x5-unorm": {
    f: _n
  },
  "astc-5x5-unorm-srgb": {
    f: _n
  },
  "astc-6x5-unorm": {
    f: _n
  },
  "astc-6x5-unorm-srgb": {
    f: _n
  },
  "astc-6x6-unorm": {
    f: _n
  },
  "astc-6x6-unorm-srgb": {
    f: _n
  },
  "astc-8x5-unorm": {
    f: _n
  },
  "astc-8x5-unorm-srgb": {
    f: _n
  },
  "astc-8x6-unorm": {
    f: _n
  },
  "astc-8x6-unorm-srgb": {
    f: _n
  },
  "astc-8x8-unorm": {
    f: _n
  },
  "astc-8x8-unorm-srgb": {
    f: _n
  },
  "astc-10x5-unorm": {
    f: _n
  },
  "astc-10x5-unorm-srgb": {
    f: _n
  },
  "astc-10x6-unorm": {
    f: _n
  },
  "astc-10x6-unorm-srgb": {
    f: _n
  },
  "astc-10x8-unorm": {
    f: _n
  },
  "astc-10x8-unorm-srgb": {
    f: _n
  },
  "astc-10x10-unorm": {
    f: _n
  },
  "astc-10x10-unorm-srgb": {
    f: _n
  },
  "astc-12x10-unorm": {
    f: _n
  },
  "astc-12x10-unorm-srgb": {
    f: _n
  },
  "astc-12x12-unorm": {
    f: _n
  },
  "astc-12x12-unorm-srgb": {
    f: _n
  },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": {
    f: Wm
  },
  "pvrtc-rgba4unorm-webgl": {
    f: Wm
  },
  "pvrtc-rbg2unorm-webgl": {
    f: Wm
  },
  "pvrtc-rgba2unorm-webgl": {
    f: Wm
  },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": {
    f: iD
  },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": {
    f: mb
  },
  "atc-rgba-unorm-webgl": {
    f: mb
  },
  "atc-rgbai-unorm-webgl": {
    f: mb
  }
}, aD = {
  ...sD,
  ...oD
}, lD = ["bc1", "bc2", "bc3", "bc4", "bc5", "bc6", "bc7", "etc1", "etc2", "eac", "atc", "astc", "pvrtc"], cD = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
class uD {
  /** Returns information about a texture format, e.g. attatchment type, components, byte length and flags (integer, signed, normalized) */
  getInfo(e) {
    return TT(e);
  }
  /** Checks if a texture format is color */
  isColor(e) {
    return e.startsWith("rgba") || e.startsWith("bgra") || e.startsWith("rgb");
  }
  /** Checks if a texture format is depth or stencil */
  isDepthStencil(e) {
    return e.startsWith("depth") || e.startsWith("stencil");
  }
  /** Checks if a texture format is compressed */
  isCompressed(e) {
    return lD.some((t) => e.startsWith(t));
  }
  /**
   * Returns the "static" capabilities of a texture format.
   * @note Needs to be checked against current device
   */
  getCapabilities(e) {
    const t = Q5(e), i = {
      format: e,
      create: t.f ?? !0,
      render: t.render ?? !0,
      filter: t.filter ?? !0,
      blend: t.blend ?? !0,
      store: t.store ?? !0
    }, n = TT(e), s = e.startsWith("depth") || e.startsWith("stencil"), c = n?.signed, o = n?.integer, d = n?.webgl;
    return i.render &&= !c, i.filter &&= !s && !c && !o && !d, i;
  }
}
const up = new uD();
function TT(r) {
  let e = hD(r);
  if (up.isCompressed(r)) {
    e.channels = "rgb", e.components = 3, e.bytesPerPixel = 1, e.srgb = !1, e.compressed = !0;
    const i = fD(r);
    i && (e.blockWidth = i.blockWidth, e.blockHeight = i.blockHeight);
  }
  const t = cD.exec(r);
  if (t) {
    const [, i, n, s, c, o] = t, d = `${s}${n}`, m = K5(d), y = m.byteLength * 8, T = i.length, P = [y, T >= 2 ? y : 0, T >= 3 ? y : 0, T >= 4 ? y : 0];
    e = {
      format: r,
      attachment: e.attachment,
      dataType: m.signedType,
      components: T,
      channels: i,
      integer: m.integer,
      signed: m.signed,
      normalized: m.normalized,
      bitsPerChannel: P,
      bytesPerPixel: m.byteLength * i.length,
      packed: e.packed,
      srgb: e.srgb
    }, o === "-webgl" && (e.webgl = !0), c === "-srgb" && (e.srgb = !0);
  }
  return r.endsWith("-webgl") && (e.webgl = !0), r.endsWith("-srgb") && (e.srgb = !0), e;
}
function hD(r) {
  const e = Q5(r), t = e.bytesPerPixel || 1, i = e.bitsPerChannel || [8, 8, 8, 8];
  return delete e.bitsPerChannel, delete e.bytesPerPixel, delete e.f, delete e.render, delete e.filter, delete e.blend, delete e.store, {
    ...e,
    format: r,
    attachment: e.attachment || "color",
    channels: e.channels || "r",
    components: e.components || e.channels?.length || 1,
    bytesPerPixel: t,
    bitsPerChannel: i,
    dataType: e.dataType || "uint8",
    srgb: e.srgb ?? !1,
    packed: e.packed ?? !1,
    webgl: e.webgl ?? !1,
    integer: e.integer ?? !1,
    signed: e.signed ?? !1,
    normalized: e.normalized ?? !1,
    compressed: e.compressed ?? !1
  };
}
function fD(r) {
  const t = /.*-(\d+)x(\d+)-.*/.exec(r);
  if (t) {
    const [, i, n] = t;
    return {
      blockWidth: Number(i),
      blockHeight: Number(n)
    };
  }
  return null;
}
function dD(r) {
  return typeof ImageData < "u" && r instanceof ImageData || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement || typeof VideoFrame < "u" && r instanceof VideoFrame || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas;
}
function pD(r) {
  if (typeof ImageData < "u" && r instanceof ImageData || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas)
    return {
      width: r.width,
      height: r.height
    };
  if (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement)
    return {
      width: r.naturalWidth,
      height: r.naturalHeight
    };
  if (typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement)
    return {
      width: r.videoWidth,
      height: r.videoHeight
    };
  if (typeof VideoFrame < "u" && r instanceof VideoFrame)
    return {
      width: r.displayWidth,
      height: r.displayHeight
    };
  throw new Error("Unknown image type");
}
class gD {
}
class mD {
  features;
  disabledFeatures;
  constructor(e = [], t) {
    this.features = new Set(e), this.disabledFeatures = t || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(e) {
    return !this.disabledFeatures?.[e] && this.features.has(e);
  }
}
class Yf {
  static defaultProps = {
    id: null,
    powerPreference: "high-performance",
    failIfMajorPerformanceCaveat: !1,
    createCanvasContext: void 0,
    // WebGL specific
    webgl: {},
    // Callbacks
    // eslint-disable-next-line handle-callback-err
    onError: (e, t) => {
    },
    onResize: (e, t) => {
      const [i, n] = e.getDevicePixelSize();
      Ht.log(1, `${e} resized => ${i}x${n}px`)();
    },
    onPositionChange: (e, t) => {
      const [i, n] = e.getPosition();
      Ht.log(1, `${e} repositioned => ${i},${n}`)();
    },
    onVisibilityChange: (e) => Ht.log(1, `${e} Visibility changed ${e.isVisible}`)(),
    onDevicePixelRatioChange: (e, t) => Ht.log(1, `${e} DPR changed ${t.oldRatio} => ${e.devicePixelRatio}`)(),
    // Debug flags
    debug: Ht.get("debug") || void 0,
    debugShaders: Ht.get("debug-shaders") || void 0,
    debugFramebuffers: !!Ht.get("debug-framebuffers"),
    debugFactories: !!Ht.get("debug-factories"),
    debugWebGL: !!Ht.get("debug-webgl"),
    debugSpectorJS: void 0,
    // Note: log setting is queried by the spector.js code
    debugSpectorJSUrl: void 0,
    // Experimental
    _reuseDevices: !1,
    _requestMaxLimits: !0,
    _cacheShaders: !1,
    _cachePipelines: !1,
    _cacheDestroyPolicy: "unused",
    // TODO - Change these after confirming things work as expected
    _initializeFeatures: !0,
    _disabledFeatures: {
      "compilation-status-async-webgl": !0
    },
    // INTERNAL
    _handle: void 0
  };
  get [Symbol.toStringTag]() {
    return "Device";
  }
  toString() {
    return `Device(${this.id})`;
  }
  /** id of this device, primarily for debugging */
  id;
  /** A copy of the device props  */
  props;
  /** Available for the application to store data on the device */
  userData = {};
  /** stats */
  statsManager = J5;
  /** An abstract timestamp used for change tracking */
  timestamp = 0;
  /** True if this device has been reused during device creation (app has multiple references) */
  _reused = !1;
  /** Used by other luma.gl modules to store data on the device */
  _lumaData = {};
  _textureCaps = {};
  constructor(e) {
    this.props = {
      ...Yf.defaultProps,
      ...e
    }, this.id = this.props.id || Yy(this[Symbol.toStringTag].toLowerCase());
  }
  getVertexFormatInfo(e) {
    return B2(e);
  }
  isVertexFormatSupported(e) {
    return !0;
  }
  /** Returns information about a texture format, such as data type, channels, bits per channel, compression etc */
  getTextureFormatInfo(e) {
    return up.getInfo(e);
  }
  /** Determines what operations are supported on a texture format on this particular device (checks against supported device features) */
  getTextureFormatCapabilities(e) {
    let t = this._textureCaps[e];
    if (!t) {
      const i = this._getDeviceTextureFormatCapabilities(e);
      t = this._getDeviceSpecificTextureFormatCapabilities(i), this._textureCaps[e] = t;
    }
    return t;
  }
  /** Calculates the number of mip levels for a texture of width, height and in case of 3d textures only, depth */
  getMipLevelCount(e, t, i = 1) {
    const n = Math.max(e, t, i);
    return 1 + Math.floor(Math.log2(n));
  }
  /** Check if data is an external image */
  isExternalImage(e) {
    return dD(e);
  }
  /** Get the size of an external image */
  getExternalImageSize(e) {
    return pD(e);
  }
  /** Check if device supports a specific texture format (creation and `nearest` sampling) */
  isTextureFormatSupported(e) {
    return this.getTextureFormatCapabilities(e).create;
  }
  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
  isTextureFormatFilterable(e) {
    return this.getTextureFormatCapabilities(e).filter;
  }
  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
  isTextureFormatRenderable(e) {
    return this.getTextureFormatCapabilities(e).render;
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(e) {
    return up.isCompressed(e);
  }
  // DEBUG METHODS
  pushDebugGroup(e) {
    this.commandEncoder.pushDebugGroup(e);
  }
  popDebugGroup() {
    this.commandEncoder?.popDebugGroup();
  }
  insertDebugMarker(e) {
    this.commandEncoder?.insertDebugMarker(e);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  /**
   * Reports Device errors in a way that optimizes for developer experience / debugging.
   * - Logs so that the console error links directly to the source code that generated the error.
   * - Includes the object that reported the error in the log message, even if the error is asynchronous.
   *
   * Conventions when calling reportError():
   * - Always call the returned function - to ensure error is logged, at the error site
   * - Follow with a call to device.debug() - to ensure that the debugger breaks at the error site
   *
   * @param error - the error to report. If needed, just create a new Error object with the appropriate message.
   * @param context - pass `this` as context, otherwise it may not be available in the debugger for async errors.
   * @returns the logger function returned by device.props.onError() so that it can be called from the error site.
   *
   * @example
   *   device.reportError(new Error(...), this)();
   *   device.debug();
   */
  reportError(e, t, ...i) {
    return this.props.onError(e, t) ? () => {
    } : Ht.error(e.message, t, ...i);
  }
  /** Break in the debugger - if device.props.debug is true */
  debug() {
    if (this.props.debug)
      debugger;
    else
      Ht.once(0, `'Type luma.log.set({debug: true}) in console to enable debug breakpoints',
or create a device with the 'debug: true' prop.`)();
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getDefaultCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
    return this.canvasContext;
  }
  /** Create a RenderPass using the default CommandEncoder */
  beginRenderPass(e) {
    return this.commandEncoder.beginRenderPass(e);
  }
  /** Create a ComputePass using the default CommandEncoder*/
  beginComputePass(e) {
    return this.commandEncoder.beginComputePass(e);
  }
  // DEPRECATED METHODS
  /** @deprecated Use getDefaultCanvasContext() */
  getCanvasContext() {
    return this.getDefaultCanvasContext();
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  // IMPLEMENTATION
  /** Helper to get the canvas context props */
  static _getCanvasContextProps(e) {
    return e.createCanvasContext === !0 ? {} : e.createCanvasContext;
  }
  _getDeviceTextureFormatCapabilities(e) {
    const t = up.getCapabilities(e), i = (s) => (typeof s == "string" ? this.features.has(s) : s) ?? !0, n = i(t.create);
    return {
      format: e,
      create: n,
      render: n && i(t.render),
      filter: n && i(t.filter),
      blend: n && i(t.blend),
      store: n && i(t.store)
    };
  }
  /** Subclasses use this to support .createBuffer() overloads */
  _normalizeBufferProps(e) {
    (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = {
      data: e
    });
    const t = {
      ...e
    };
    if ((e.usage || 0) & us.INDEX && (e.indexType || (e.data instanceof Uint32Array ? t.indexType = "uint32" : e.data instanceof Uint16Array && (t.indexType = "uint16")), !t.indexType))
      throw new Error("indices buffer content must be of type uint16 or uint32");
    return t;
  }
}
const _D = "set luma.log.level=1 (or higher) to trace rendering", ST = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
class vy {
  static defaultProps = {
    ...Yf.defaultProps,
    type: "best-available",
    adapters: void 0,
    waitForPageLoad: !0
  };
  /** Global stats for all devices */
  stats = J5;
  /**
   * Global log
   *
   * Assign luma.log.level in console to control logging: \
   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
   */
  log = Ht;
  /** Version of luma.gl */
  VERSION = (
    // Version detection using build plugin
    // @ts-expect-error no-undef
    "9.2.3"
  );
  spector;
  preregisteredAdapters = /* @__PURE__ */ new Map();
  constructor() {
    if (globalThis.luma) {
      if (globalThis.luma.VERSION !== this.VERSION)
        throw Ht.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(), Ht.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(), new Error("luma.gl - multiple versions detected: see console log");
      Ht.error("This version of luma.gl has already been initialized")();
    }
    Ht.log(1, `${this.VERSION} - ${_D}`)(), globalThis.luma = this;
  }
  /** Creates a device. Asynchronously. */
  async createDevice(e = {}) {
    const t = {
      ...vy.defaultProps,
      ...e
    }, i = this.selectAdapter(t.type, t.adapters);
    if (!i)
      throw new Error(ST);
    return t.waitForPageLoad && await i.pageLoaded, await i.create(t);
  }
  /**
   * Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice).
   * @param handle Externally created WebGL context or WebGPU device
   */
  async attachDevice(e, t) {
    const i = this._getTypeFromHandle(e, t.adapters), n = i && this.selectAdapter(i, t.adapters);
    if (!n)
      throw new Error(ST);
    return await n?.attach?.(e, t);
  }
  /**
   * Global adapter registration.
   * @deprecated Use props.adapters instead
   */
  registerAdapters(e) {
    for (const t of e)
      this.preregisteredAdapters.set(t.type, t);
  }
  /** Get type strings for supported Devices */
  getSupportedAdapters(e = []) {
    const t = this._getAdapterMap(e);
    return Array.from(t).map(([, i]) => i).filter((i) => i.isSupported?.()).map((i) => i.type);
  }
  /** Get type strings for best available Device */
  getBestAvailableAdapterType(e = []) {
    const t = ["webgpu", "webgl", "null"], i = this._getAdapterMap(e);
    for (const n of t)
      if (i.get(n)?.isSupported?.())
        return n;
    return null;
  }
  /** Select adapter of type from registered adapters */
  selectAdapter(e, t = []) {
    let i = e;
    e === "best-available" && (i = this.getBestAvailableAdapterType(t));
    const n = this._getAdapterMap(t);
    return i && n.get(i) || null;
  }
  /**
   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
   */
  enforceWebGL2(e = !0, t = []) {
    const n = this._getAdapterMap(t).get("webgl");
    n || Ht.warn("enforceWebGL2: webgl adapter not found")(), n?.enforceWebGL2?.(e);
  }
  // DEPRECATED
  /** @deprecated */
  setDefaultDeviceProps(e) {
    Object.assign(vy.defaultProps, e);
  }
  // HELPERS
  /** Convert a list of adapters to a map */
  _getAdapterMap(e = []) {
    const t = new Map(this.preregisteredAdapters);
    for (const i of e)
      t.set(i.type, i);
    return t;
  }
  /** Get type of a handle (for attachDevice) */
  _getTypeFromHandle(e, t = []) {
    return e instanceof WebGL2RenderingContext ? "webgl" : typeof GPUDevice < "u" && e instanceof GPUDevice || e?.queue ? "webgpu" : e === null ? "null" : (e instanceof WebGLRenderingContext ? Ht.warn("WebGL1 is not supported", e)() : Ht.warn("Unknown handle type", e)(), null);
  }
}
const uv = new vy();
class yD {
  /**
   * Page load promise
   * Resolves when the DOM is loaded.
   * @note Since are be limitations on number of `load` event listeners,
   * it is recommended avoid calling this accessor until actually needed.
   * I.e. we don't call it unless you know that you will be looking up a string in the DOM.
   */
  get pageLoaded() {
    return xD();
  }
}
const bD = ad() && typeof document < "u", vD = () => bD && document.readyState === "complete";
let Ym = null;
function xD() {
  return Ym || (vD() || typeof window > "u" ? Ym = Promise.resolve() : Ym = new Promise((r) => window.addEventListener("load", () => r()))), Ym;
}
function wD() {
  let r, e;
  return {
    promise: new Promise((i, n) => {
      r = i, e = n;
    }),
    resolve: r,
    reject: e
  };
}
class Of {
  static isHTMLCanvas(e) {
    return typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement;
  }
  static isOffscreenCanvas(e) {
    return typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas;
  }
  static defaultProps = {
    id: void 0,
    canvas: null,
    width: 800,
    height: 600,
    useDevicePixels: !0,
    autoResize: !0,
    container: null,
    visible: !0,
    alphaMode: "opaque",
    colorSpace: "srgb",
    trackPosition: !1
  };
  id;
  props;
  canvas;
  /** Handle to HTML canvas */
  htmlCanvas;
  /** Handle to wrapped OffScreenCanvas */
  offscreenCanvas;
  type;
  /** Promise that resolved once the resize observer has updated the pixel size */
  initialized;
  isInitialized = !1;
  /** Visibility is automatically updated (via an IntersectionObserver) */
  isVisible = !0;
  /** Width of canvas in CSS units (tracked by a ResizeObserver) */
  cssWidth;
  /** Height of canvas in CSS units (tracked by a ResizeObserver) */
  cssHeight;
  /** Device pixel ratio. Automatically updated via media queries */
  devicePixelRatio;
  /** Exact width of canvas in physical pixels (tracked by a ResizeObserver) */
  devicePixelWidth;
  /** Exact height of canvas in physical pixels (tracked by a ResizeObserver) */
  devicePixelHeight;
  /** Width of drawing buffer: automatically tracks this.pixelWidth if props.autoResize is true */
  drawingBufferWidth;
  /** Height of drawing buffer: automatically tracks this.pixelHeight if props.autoResize is true */
  drawingBufferHeight;
  _initializedResolvers = wD();
  _resizeObserver;
  _intersectionObserver;
  _position;
  destroyed = !1;
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  constructor(e) {
    if (this.props = {
      ...Of.defaultProps,
      ...e
    }, e = this.props, this.initialized = this._initializedResolvers.promise, ad() ? e.canvas ? typeof e.canvas == "string" ? this.canvas = TD(e.canvas) : this.canvas = e.canvas : this.canvas = SD(e) : this.canvas = {
      width: e.width || 1,
      height: e.height || 1
    }, Of.isHTMLCanvas(this.canvas) ? (this.id = e.id || this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : Of.isOffscreenCanvas(this.canvas) ? (this.id = e.id || "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas) : (this.id = e.id || "node-canvas-context", this.type = "node"), this.cssWidth = this.htmlCanvas?.clientWidth || this.canvas.width, this.cssHeight = this.htmlCanvas?.clientHeight || this.canvas.height, this.devicePixelWidth = this.canvas.width, this.devicePixelHeight = this.canvas.height, this.drawingBufferWidth = this.canvas.width, this.drawingBufferHeight = this.canvas.height, this.devicePixelRatio = globalThis.devicePixelRatio || 1, this._position = [0, 0], Of.isHTMLCanvas(this.canvas)) {
      this._intersectionObserver = new IntersectionObserver((t) => this._handleIntersection(t)), this._intersectionObserver.observe(this.canvas), this._resizeObserver = new ResizeObserver((t) => this._handleResize(t));
      try {
        this._resizeObserver.observe(this.canvas, {
          box: "device-pixel-content-box"
        });
      } catch {
        this._resizeObserver.observe(this.canvas, {
          box: "content-box"
        });
      }
      setTimeout(() => this._observeDevicePixelRatio(), 0), this.props.trackPosition && this._trackPosition();
    }
  }
  destroy() {
    this.destroyed = !0;
  }
  setProps(e) {
    return "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1, this._updateDrawingBufferSize()), this;
  }
  // SIZE METHODS
  /**
   * Returns the size covered by the canvas in CSS pixels
   * @note This can be different from the actual device pixel size of a canvas due to DPR scaling, and rounding to integer pixels
   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).
   */
  getCSSSize() {
    return [this.cssWidth, this.cssHeight];
  }
  getPosition() {
    return this._position;
  }
  /**
   * Returns the size covered by the canvas in actual device pixels.
   * @note This can be different from the 'CSS' size of a canvas due to DPR scaling, and rounding to integer pixels
   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).
   */
  getDevicePixelSize() {
    return [this.devicePixelWidth, this.devicePixelHeight];
  }
  /** Get the drawing buffer size (number of pixels GPU is rendering into, can be different from CSS size) */
  getDrawingBufferSize() {
    return [this.drawingBufferWidth, this.drawingBufferHeight];
  }
  /** Returns the biggest allowed framebuffer size. @todo Allow the application to limit this? */
  getMaxDrawingBufferSize() {
    const e = this.device.limits.maxTextureDimension2D;
    return [e, e];
  }
  /** Update the canvas drawing buffer size. Called automatically if props.autoResize is true. */
  setDrawingBufferSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.drawingBufferWidth = e, this.drawingBufferHeight = t;
  }
  /**
   * Returns the current DPR (number of physical pixels per CSS pixel), if props.useDevicePixels is true
   * @note This can be a fractional (non-integer) number, e.g. when the user zooms in the browser.
   * @note This function handles the non-HTML canvas cases
   */
  getDevicePixelRatio() {
    return typeof window < "u" && window.devicePixelRatio || 1;
  }
  // DEPRECATED METHODS
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(e, t = !0) {
    const i = this.cssToDeviceRatio(), [n, s] = this.getDrawingBufferSize();
    return ED(e, i, n, s, t);
  }
  /** @deprecated - use .getDevicePixelSize() */
  getPixelSize() {
    return this.getDevicePixelSize();
  }
  /** @deprecated - TODO which values should we use for aspect */
  getAspect() {
    const [e, t] = this.getDevicePixelSize();
    return e / t;
  }
  /** @deprecated Returns multiplier need to convert CSS size to Device size */
  cssToDeviceRatio() {
    try {
      const [e] = this.getDrawingBufferSize(), [t] = this.getCSSSize();
      return t ? e / t : 1;
    } catch {
      return 1;
    }
  }
  /** @deprecated Use canvasContext.setDrawingBufferSize() */
  resize(e) {
    this.setDrawingBufferSize(e.width, e.height);
  }
  // IMPLEMENTATION
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(e) {
    this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
  }
  /** reacts to an observed intersection */
  _handleIntersection(e) {
    const t = e.find((n) => n.target === this.canvas);
    if (!t)
      return;
    const i = t.isIntersecting;
    this.isVisible !== i && (this.isVisible = i, this.device.props.onVisibilityChange(this));
  }
  /**
   * Reacts to an observed resize by using the most accurate pixel size information the browser can provide
   * @see https://web.dev/articles/device-pixel-content-box
   * @see https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html
   */
  _handleResize(e) {
    const t = e.find((d) => d.target === this.canvas);
    if (!t)
      return;
    this.cssWidth = t.contentBoxSize[0].inlineSize, this.cssHeight = t.contentBoxSize[0].blockSize;
    const i = this.getDevicePixelSize(), n = t.devicePixelContentBoxSize?.[0].inlineSize || t.contentBoxSize[0].inlineSize * devicePixelRatio, s = t.devicePixelContentBoxSize?.[0].blockSize || t.contentBoxSize[0].blockSize * devicePixelRatio, [c, o] = this.getMaxDrawingBufferSize();
    this.devicePixelWidth = Math.max(1, Math.min(n, c)), this.devicePixelHeight = Math.max(1, Math.min(s, o)), this._updateDrawingBufferSize(), this.device.props.onResize(this, {
      oldPixelSize: i
    });
  }
  _updateDrawingBufferSize() {
    if (this.props.autoResize) {
      if (typeof this.props.useDevicePixels == "number") {
        const e = this.props.useDevicePixels;
        this.setDrawingBufferSize(this.cssWidth * e, this.cssHeight * e);
      } else this.props.useDevicePixels ? this.setDrawingBufferSize(this.devicePixelWidth, this.devicePixelHeight) : this.setDrawingBufferSize(this.cssWidth, this.cssHeight);
      this._updateDevice();
    }
    this._initializedResolvers.resolve(), this.isInitialized = !0, this.updatePosition();
  }
  /** Monitor DPR changes */
  _observeDevicePixelRatio() {
    const e = this.devicePixelRatio;
    this.devicePixelRatio = window.devicePixelRatio, this.updatePosition(), this.device.props.onDevicePixelRatioChange(this, {
      oldRatio: e
    }), matchMedia(`(resolution: ${this.devicePixelRatio}dppx)`).addEventListener("change", () => this._observeDevicePixelRatio(), {
      once: !0
    });
  }
  /** Start tracking positions with a timer */
  _trackPosition(e = 100) {
    const t = setInterval(() => {
      this.destroyed ? clearInterval(t) : this.updatePosition();
    }, e);
  }
  /**
   * Calculated the absolute position of the canvas
   * @note - getBoundingClientRect() is normally cheap but can be expensive
   * if called before browser has finished a reflow. Should not be the case here.
   */
  updatePosition() {
    const e = this.htmlCanvas?.getBoundingClientRect();
    if (e) {
      const t = [e.left, e.top];
      if (this._position ??= t, t[0] !== this._position[0] || t[1] !== this._position[1]) {
        const n = this._position;
        this._position = t, this.device.props.onPositionChange?.(this, {
          oldPosition: n
        });
      }
    }
  }
}
function AD(r) {
  if (typeof r == "string") {
    const e = document.getElementById(r);
    if (!e)
      throw new Error(`${r} is not an HTML element`);
    return e;
  }
  return r || document.body;
}
function TD(r) {
  const e = document.getElementById(r);
  if (!Of.isHTMLCanvas(e))
    throw new Error("Object is not a canvas element");
  return e;
}
function SD(r) {
  const {
    width: e,
    height: t
  } = r, i = document.createElement("canvas");
  i.id = Yy("lumagl-auto-created-canvas"), i.width = e || 1, i.height = t || 1, i.style.width = Number.isFinite(e) ? `${e}px` : "100%", i.style.height = Number.isFinite(t) ? `${t}px` : "100%", r?.visible || (i.style.visibility = "hidden");
  const n = AD(r?.container || null);
  return n.insertBefore(i, n.firstChild), i;
}
function ED(r, e, t, i, n) {
  const s = r, c = ET(s[0], e, t);
  let o = CT(s[1], e, i, n), d = ET(s[0] + 1, e, t);
  const m = d === t - 1 ? d : d - 1;
  d = CT(s[1] + 1, e, i, n);
  let y;
  return n ? (d = d === 0 ? d : d + 1, y = o, o = d) : y = d === i - 1 ? d : d - 1, {
    x: c,
    y: o,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(m - c + 1, 1),
    height: Math.max(y - o + 1, 1)
  };
}
function ET(r, e, t) {
  return Math.min(Math.round(r * e), t - 1);
}
function CT(r, e, t, i) {
  return i ? Math.max(0, t - 1 - Math.round(r * e)) : Math.min(Math.round(r * e), t - 1);
}
class Jf extends yn {
  static defaultProps = {
    ...yn.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "none",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    // Per WebGPU spec
    compare: "less-equal",
    maxAnisotropy: 1
  };
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(e, t) {
    t = Jf.normalizeProps(e, t), super(e, t, Jf.defaultProps);
  }
  static normalizeProps(e, t) {
    return t;
  }
}
const CD = {
  "1d": "1d",
  "2d": "2d",
  "2d-array": "2d",
  cube: "2d",
  "cube-array": "2d",
  "3d": "3d"
};
class Fs extends yn {
  /** The texture can be bound for use as a sampled texture in a shader */
  static SAMPLE = 4;
  /** The texture can be bound for use as a storage texture in a shader */
  static STORAGE = 8;
  /** The texture can be used as a color or depth/stencil attachment in a render pass */
  static RENDER = 16;
  /** The texture can be used as the source of a copy operation */
  static COPY_SRC = 1;
  /** he texture can be used as the destination of a copy or write operation */
  static COPY_DST = 2;
  /** @deprecated Use Texture.SAMPLE */
  static TEXTURE = 4;
  /** @deprecated Use Texture.RENDER */
  static RENDER_ATTACHMENT = 16;
  /** dimension of this texture */
  dimension;
  /** base dimension of this texture */
  baseDimension;
  /** format of this texture */
  format;
  /** width in pixels of this texture */
  width;
  /** height in pixels of this texture */
  height;
  /** depth of this texture */
  depth;
  /** mip levels in this texture */
  mipLevels;
  /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
  updateTimestamp;
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  toString() {
    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
  }
  /** Do not use directly. Create with device.createTexture() */
  constructor(e, t) {
    if (t = Fs.normalizeProps(e, t), super(e, t, Fs.defaultProps), this.dimension = this.props.dimension, this.baseDimension = CD[this.dimension], this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.mipLevels = this.props.mipLevels, this.props.width === void 0 || this.props.height === void 0)
      if (e.isExternalImage(t.data)) {
        const i = e.getExternalImageSize(t.data);
        this.width = i?.width || 1, this.height = i?.height || 1;
      } else
        this.width = 1, this.height = 1, (this.props.width === void 0 || this.props.height === void 0) && Ht.warn(`${this} created with undefined width or height. This is deprecated. Use AsyncTexture instead.`)();
    this.updateTimestamp = e.incrementTimestamp();
  }
  /** Set sampler props associated with this texture */
  setSampler(e) {
    this.sampler = e instanceof Jf ? e : this.device.createSampler(e);
  }
  /**
   * Create a new texture with the same parameters and optionally a different size
   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   */
  clone(e) {
    return this.device.createTexture({
      ...this.props,
      ...e
    });
  }
  /** Ensure we have integer coordinates */
  static normalizeProps(e, t) {
    const i = {
      ...t
    }, {
      width: n,
      height: s
    } = i;
    return typeof n == "number" && (i.width = Math.max(1, Math.ceil(n))), typeof s == "number" && (i.height = Math.max(1, Math.ceil(s))), i;
  }
  // HELPERS
  /** Initialize texture with supplied props */
  // eslint-disable-next-line max-statements
  _initializeData(e) {
    this.device.isExternalImage(e) ? this.copyExternalImage({
      image: e,
      width: this.width,
      height: this.height,
      depth: this.depth,
      mipLevel: 0,
      x: 0,
      y: 0,
      z: 0,
      aspect: "all",
      colorSpace: "srgb",
      premultipliedAlpha: !1,
      flipY: !1
    }) : e && this.copyImageData({
      data: e,
      // width: this.width,
      // height: this.height,
      // depth: this.depth,
      mipLevel: 0,
      x: 0,
      y: 0,
      z: 0,
      aspect: "all"
    });
  }
  _normalizeCopyImageDataOptions(e) {
    const {
      width: t,
      height: i,
      depth: n
    } = this, s = {
      ...Fs.defaultCopyDataOptions,
      width: t,
      height: i,
      depth: n,
      ...e
    }, c = this.device.getTextureFormatInfo(this.format);
    if (!e.bytesPerRow && !c.bytesPerPixel)
      throw new Error(`bytesPerRow must be provided for texture format ${this.format}`);
    return s.bytesPerRow = e.bytesPerRow || t * (c.bytesPerPixel || 4), s.rowsPerImage = e.rowsPerImage || i, s;
  }
  _normalizeCopyExternalImageOptions(e) {
    const t = this.device.getExternalImageSize(e.image), i = {
      ...Fs.defaultCopyExternalImageOptions,
      ...t,
      ...e
    };
    return i.width = Math.min(i.width, this.width - i.x), i.height = Math.min(i.height, this.height - i.y), i;
  }
  /** Default options */
  static defaultProps = {
    ...yn.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    usage: Fs.TEXTURE | Fs.RENDER_ATTACHMENT | Fs.COPY_DST,
    width: void 0,
    height: void 0,
    depth: 1,
    mipLevels: 1,
    samples: void 0,
    sampler: {},
    view: void 0
  };
  static defaultCopyDataOptions = {
    data: void 0,
    byteOffset: 0,
    bytesPerRow: void 0,
    rowsPerImage: void 0,
    mipLevel: 0,
    x: 0,
    y: 0,
    z: 0,
    aspect: "all"
  };
  /** Default options */
  static defaultCopyExternalImageOptions = {
    image: void 0,
    sourceX: 0,
    sourceY: 0,
    width: void 0,
    height: void 0,
    depth: 1,
    mipLevel: 0,
    x: 0,
    y: 0,
    z: 0,
    aspect: "all",
    colorSpace: "srgb",
    premultipliedAlpha: !1,
    flipY: !1
  };
}
class Jy extends yn {
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(e, t) {
    super(e, t, Jy.defaultProps);
  }
  static defaultProps = {
    ...yn.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  };
}
function ID(r, e, t) {
  let i = "";
  const n = e.split(/\r?\n/), s = r.slice().sort((c, o) => c.lineNum - o.lineNum);
  switch (t?.showSourceCode || "no") {
    case "all":
      let c = 0;
      for (let o = 1; o <= n.length; o++)
        for (i += eI(n[o - 1], o, t); s.length > c && s[c].lineNum === o; ) {
          const d = s[c++];
          i += vb(d, n, d.lineNum, {
            ...t,
            inlineSource: !1
          });
        }
      for (; s.length > c; ) {
        const o = s[c++];
        i += vb(o, [], 0, {
          ...t,
          inlineSource: !1
        });
      }
      return i;
    case "issues":
    case "no":
      for (const o of r)
        i += vb(o, n, o.lineNum, {
          inlineSource: t?.showSourceCode !== "no"
        });
      return i;
  }
}
function vb(r, e, t, i) {
  if (i?.inlineSource) {
    const s = PD(e, t), c = r.linePos > 0 ? `${" ".repeat(r.linePos + 5)}^^^
` : "";
    return `
${s}${c}${r.type.toUpperCase()}: ${r.message}

`;
  }
  const n = r.type === "error" ? "red" : "#8B4000";
  return i?.html ? `<div class='luma-compiler-log-error' style="color:${n};"><b> ${r.type.toUpperCase()}: ${r.message}</b></div>` : `${r.type.toUpperCase()}: ${r.message}`;
}
function PD(r, e, t) {
  let i = "";
  for (let n = e - 2; n <= e; n++) {
    const s = r[n - 1];
    s !== void 0 && (i += eI(s, e, t));
  }
  return i;
}
function eI(r, e, t) {
  const i = t?.html ? RD(r) : r;
  return `${MD(String(e), 4)}: ${i}${t?.html ? "<br/>" : `
`}`;
}
function MD(r, e) {
  let t = "";
  for (let i = r.length; i < e; ++i)
    t += " ";
  return t + r;
}
function RD(r) {
  return r.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
class Ky extends yn {
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** The stage of this shader */
  stage;
  /** The source code of this shader */
  source;
  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
  compilationStatus = "pending";
  /** Create a new Shader instance */
  constructor(e, t) {
    t = {
      ...t,
      debugShaders: t.debugShaders || e.props.debugShaders || "errors"
    }, super(e, {
      id: LD(t),
      ...t
    }, Ky.defaultProps), this.stage = this.props.stage, this.source = this.props.source;
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader() {
    const e = this.props.debugShaders;
    switch (e) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const t = await this.getCompilationInfo();
    e === "warnings" && t?.length === 0 || this._displayShaderLog(t, this.id);
  }
  // PRIVATE
  /**
   * In-browser UI logging of errors
   * TODO - this HTML formatting code should not be in Device, should be pluggable
   */
  _displayShaderLog(e, t) {
    if (typeof document > "u" || !document?.createElement)
      return;
    const i = t, n = `${this.stage} shader "${i}"`;
    let s = ID(e, this.source, {
      showSourceCode: "all",
      html: !0
    });
    const c = this.getTranslatedSource();
    c && (s += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${c}</pre></code>`);
    const o = document.createElement("Button");
    o.innerHTML = `
<h1>Compilation error in ${n}</h1><br /><br />
<code style="user-select:text;"><pre>
${s}
</pre></code>`, o.style.top = "10px", o.style.left = "10px", o.style.position = "absolute", o.style.zIndex = "9999", o.style.width = "100%", o.style.textAlign = "left", document.body.appendChild(o), document.getElementsByClassName("luma-compiler-log-error")[0]?.scrollIntoView(), o.onclick = () => {
      const m = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(m);
    };
  }
  static defaultProps = {
    ...yn.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debugShaders: void 0
  };
}
function LD(r) {
  return BD(r.source) || r.id || Yy(`unnamed ${r.stage}-shader`);
}
function BD(r, e = "unnamed") {
  const i = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(r);
  return i ? i[1] : e;
}
class Qy extends yn {
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /** Width of all attachments in this framebuffer */
  width;
  /** Height of all attachments in this framebuffer */
  height;
  constructor(e, t = {}) {
    super(e, t, Qy.defaultProps), this.width = this.props.width, this.height = this.props.height;
  }
  /**
   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
   * @note Does not copy contents of the attached textures.
   */
  clone(e) {
    const t = this.colorAttachments.map((n) => n.texture.clone(e)), i = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(e);
    return this.device.createFramebuffer({
      ...this.props,
      colorAttachments: t,
      depthStencilAttachment: i
    });
  }
  resize(e) {
    let t = !e;
    if (e) {
      const [i, n] = Array.isArray(e) ? e : [e.width, e.height];
      t = t || n !== this.height || i !== this.width, this.width = i, this.height = n;
    }
    t && (Ht.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((t, i) => {
      if (typeof t == "string") {
        const n = this.createColorTexture(t, i);
        return this.attachResource(n), n.view;
      }
      return t instanceof Fs ? t.view : t;
    });
    const e = this.props.depthStencilAttachment;
    if (e)
      if (typeof e == "string") {
        const t = this.createDepthStencilTexture(e);
        this.attachResource(t), this.depthStencilAttachment = t.view;
      } else e instanceof Fs ? this.depthStencilAttachment = e.view : this.depthStencilAttachment = e;
  }
  /** Create a color texture */
  createColorTexture(e, t) {
    return this.device.createTexture({
      id: `${this.id}-color-attachment-${t}`,
      usage: Fs.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height,
      // TODO deprecated? - luma.gl v8 compatibility
      sampler: {
        magFilter: "linear",
        minFilter: "linear"
      }
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(e) {
    return this.device.createTexture({
      id: `${this.id}-depth-stencil-attachment`,
      usage: Fs.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(e, t) {
    for (let i = 0; i < this.colorAttachments.length; ++i)
      if (this.colorAttachments[i]) {
        const n = this.colorAttachments[i].texture.clone({
          width: e,
          height: t
        });
        this.destroyAttachedResource(this.colorAttachments[i]), this.colorAttachments[i] = n.view, this.attachResource(n.view);
      }
    if (this.depthStencilAttachment) {
      const i = this.depthStencilAttachment.texture.clone({
        width: e,
        height: t
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = i.view, this.attachResource(i);
    }
    this.updateAttachments();
  }
  static defaultProps = {
    ...yn.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    // ['rgba8unorm'],
    depthStencilAttachment: null
    // 'depth24plus-stencil8'
  };
}
class Gf extends yn {
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  /** The merged layout */
  shaderLayout;
  /** Buffer map describing buffer interleaving etc */
  bufferLayout;
  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
  linkStatus = "pending";
  /** The hash of the pipeline */
  hash = "";
  constructor(e, t) {
    super(e, t, Gf.defaultProps), this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  static defaultProps = {
    ...yn.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    colorAttachmentFormats: void 0,
    depthStencilAttachmentFormat: void 0,
    parameters: {},
    bindings: {},
    uniforms: {}
  };
}
class Mf extends yn {
  /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
  static defaultClearColor = [0, 0, 0, 1];
  /** Depth 1.0 represents the far plance */
  static defaultClearDepth = 1;
  /** Clears all stencil bits */
  static defaultClearStencil = 0;
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(e, t) {
    t = Mf.normalizeProps(e, t), super(e, t, Mf.defaultProps);
  }
  static normalizeProps(e, t) {
    return t;
  }
  /** Default properties for RenderPass */
  static defaultProps = {
    ...yn.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: Mf.defaultClearColor,
    clearColors: void 0,
    clearDepth: Mf.defaultClearDepth,
    clearStencil: Mf.defaultClearStencil,
    depthReadOnly: !1,
    stencilReadOnly: !1,
    discard: !1,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  };
}
class xy extends yn {
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
  hash = "";
  /** The merged shader layout */
  shaderLayout;
  constructor(e, t) {
    super(e, t, xy.defaultProps), this.shaderLayout = t.shaderLayout;
  }
  static defaultProps = {
    ...yn.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  };
}
class k2 extends yn {
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(e, t) {
    super(e, t, k2.defaultProps);
  }
  // TODO - luma.gl has these on the device, should we align with WebGPU API?
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  static defaultProps = {
    ...yn.defaultProps,
    measureExecutionTime: void 0
  };
}
class O2 extends yn {
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(e, t) {
    super(e, t, O2.defaultProps);
  }
  static defaultProps = {
    ...yn.defaultProps
  };
}
function tI(r) {
  return ND[r];
}
function kD(r) {
  const [e, t] = DD[r], i = e === "i32" || e === "u32", n = e !== "u32", s = OD[e] * t;
  return {
    primitiveType: e,
    components: t,
    byteLength: s,
    integer: i,
    signed: n
  };
}
const OD = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
}, DD = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, ND = {
  f32: {
    type: "f32",
    components: 1
  },
  f16: {
    type: "f16",
    components: 1
  },
  i32: {
    type: "i32",
    components: 1
  },
  u32: {
    type: "u32",
    components: 1
  },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": {
    type: "f32",
    components: 2
  },
  "vec3<f32>": {
    type: "f32",
    components: 3
  },
  "vec4<f32>": {
    type: "f32",
    components: 4
  },
  "vec2<f16>": {
    type: "f16",
    components: 2
  },
  "vec3<f16>": {
    type: "f16",
    components: 3
  },
  "vec4<f16>": {
    type: "f16",
    components: 4
  },
  "vec2<i32>": {
    type: "i32",
    components: 2
  },
  "vec3<i32>": {
    type: "i32",
    components: 3
  },
  "vec4<i32>": {
    type: "i32",
    components: 4
  },
  "vec2<u32>": {
    type: "u32",
    components: 2
  },
  "vec3<u32>": {
    type: "u32",
    components: 3
  },
  "vec4<u32>": {
    type: "u32",
    components: 4
  },
  "mat2x2<f32>": {
    type: "f32",
    components: 4
  },
  "mat2x3<f32>": {
    type: "f32",
    components: 6
  },
  "mat2x4<f32>": {
    type: "f32",
    components: 8
  },
  "mat3x2<f32>": {
    type: "f32",
    components: 6
  },
  "mat3x3<f32>": {
    type: "f32",
    components: 9
  },
  "mat3x4<f32>": {
    type: "f32",
    components: 12
  },
  "mat4x2<f32>": {
    type: "f32",
    components: 8
  },
  "mat4x3<f32>": {
    type: "f32",
    components: 12
  },
  "mat4x4<f32>": {
    type: "f32",
    components: 16
  },
  "mat2x2<f16>": {
    type: "f16",
    components: 4
  },
  "mat2x3<f16>": {
    type: "f16",
    components: 6
  },
  "mat2x4<f16>": {
    type: "f16",
    components: 8
  },
  "mat3x2<f16>": {
    type: "f16",
    components: 6
  },
  "mat3x3<f16>": {
    type: "f16",
    components: 9
  },
  "mat3x4<f16>": {
    type: "f16",
    components: 12
  },
  "mat4x2<f16>": {
    type: "f16",
    components: 8
  },
  "mat4x3<f16>": {
    type: "f16",
    components: 12
  },
  "mat4x4<f16>": {
    type: "f16",
    components: 16
  },
  "mat2x2<i32>": {
    type: "i32",
    components: 4
  },
  "mat2x3<i32>": {
    type: "i32",
    components: 6
  },
  "mat2x4<i32>": {
    type: "i32",
    components: 8
  },
  "mat3x2<i32>": {
    type: "i32",
    components: 6
  },
  "mat3x3<i32>": {
    type: "i32",
    components: 9
  },
  "mat3x4<i32>": {
    type: "i32",
    components: 12
  },
  "mat4x2<i32>": {
    type: "i32",
    components: 8
  },
  "mat4x3<i32>": {
    type: "i32",
    components: 12
  },
  "mat4x4<i32>": {
    type: "i32",
    components: 16
  },
  "mat2x2<u32>": {
    type: "u32",
    components: 4
  },
  "mat2x3<u32>": {
    type: "u32",
    components: 6
  },
  "mat2x4<u32>": {
    type: "u32",
    components: 8
  },
  "mat3x2<u32>": {
    type: "u32",
    components: 6
  },
  "mat3x3<u32>": {
    type: "u32",
    components: 9
  },
  "mat3x4<u32>": {
    type: "u32",
    components: 12
  },
  "mat4x2<u32>": {
    type: "u32",
    components: 8
  },
  "mat4x3<u32>": {
    type: "u32",
    components: 12
  },
  "mat4x4<u32>": {
    type: "u32",
    components: 16
  }
};
function rI(r, e) {
  const t = {};
  for (const i of r.attributes) {
    const n = UD(r, e, i.name);
    n && (t[i.name] = n);
  }
  return t;
}
function FD(r, e, t = 16) {
  const i = rI(r, e), n = new Array(t).fill(null);
  for (const s of Object.values(i))
    n[s.location] = s;
  return n;
}
function UD(r, e, t) {
  const i = zD(r, t), n = jD(e, t);
  if (!i)
    return null;
  const s = kD(i.type), c = rD(s), o = n?.vertexFormat || c, d = B2(o);
  return {
    attributeName: n?.attributeName || i.name,
    bufferName: n?.bufferName || i.name,
    location: i.location,
    shaderType: i.type,
    primitiveType: s.primitiveType,
    shaderComponents: s.components,
    vertexFormat: o,
    bufferDataType: d.type,
    bufferComponents: d.components,
    // normalized is a property of the buffer's vertex format
    normalized: d.normalized,
    // integer is a property of the shader declaration
    integer: s.integer,
    stepMode: n?.stepMode || i.stepMode || "vertex",
    byteOffset: n?.byteOffset || 0,
    byteStride: n?.byteStride || 0
  };
}
function zD(r, e) {
  const t = r.attributes.find((i) => i.name === e);
  return t || Ht.warn(`shader layout attribute "${e}" not present in shader`), t || null;
}
function jD(r, e) {
  VD(r);
  let t = GD(r, e);
  return t || (t = $D(r, e), t) ? t : (Ht.warn(`layout for attribute "${e}" not present in buffer layout`), null);
}
function VD(r) {
  for (const e of r)
    (e.attributes && e.format || !e.attributes && !e.format) && Ht.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function GD(r, e) {
  for (const t of r)
    if (t.format && t.name === e)
      return {
        attributeName: t.name,
        bufferName: e,
        stepMode: t.stepMode,
        vertexFormat: t.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: t.byteStride || 0
      };
  return null;
}
function $D(r, e) {
  for (const t of r) {
    let i = t.byteStride;
    if (typeof t.byteStride != "number")
      for (const s of t.attributes || []) {
        const c = B2(s.format);
        i += c.byteLength;
      }
    const n = t.attributes?.find((s) => s.attribute === e);
    if (n)
      return {
        attributeName: n.attribute,
        bufferName: t.name,
        stepMode: t.stepMode,
        vertexFormat: n.format,
        byteOffset: n.byteOffset,
        // @ts-ignore
        byteStride: i
      };
  }
  return null;
}
class D2 extends yn {
  static defaultProps = {
    ...yn.defaultProps,
    shaderLayout: void 0,
    bufferLayout: []
  };
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** Max number of vertex attributes */
  maxVertexAttributes;
  /** Attribute infos indexed by location - TODO only needed by webgl module? */
  attributeInfos;
  /** Index buffer */
  indexBuffer = null;
  /** Attributes indexed by buffer slot */
  attributes;
  constructor(e, t) {
    super(e, t, D2.defaultProps), this.maxVertexAttributes = e.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = FD(t.shaderLayout, t.bufferLayout, this.maxVertexAttributes);
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(e, t) {
    this.device.reportError(new Error("constant attributes not supported"), this)();
  }
}
class N2 extends yn {
  static defaultProps = {
    ...yn.defaultProps,
    layout: void 0,
    buffers: {}
  };
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(e, t) {
    super(e, t, N2.defaultProps);
  }
}
class F2 extends yn {
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(e, t) {
    super(e, t, F2.defaultProps);
  }
  static defaultProps = {
    ...yn.defaultProps,
    type: void 0,
    count: void 0
  };
}
let Jm;
function iI(r) {
  return (!Jm || Jm.byteLength < r) && (Jm = new ArrayBuffer(r)), Jm;
}
function HD(r, e) {
  const t = iI(r.BYTES_PER_ELEMENT * e);
  return new r(t, 0, e);
}
function qD(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function wy(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : qD(r);
}
const WD = 1024;
class XD {
  layout = {};
  /** number of bytes needed for buffer allocation */
  byteLength;
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(e, t = {}) {
    let i = 0;
    for (const [s, c] of Object.entries(e)) {
      const o = tI(c), {
        type: d,
        components: m
      } = o, y = m * (t?.[s] ?? 1);
      i = QO(i, y);
      const T = i;
      i += y, this.layout[s] = {
        type: d,
        size: y,
        offset: T
      };
    }
    i += (4 - i % 4) % 4;
    const n = i * 4;
    this.byteLength = Math.max(n, WD);
  }
  /** Get the data for the complete buffer */
  getData(e) {
    const t = iI(this.byteLength), i = {
      i32: new Int32Array(t),
      u32: new Uint32Array(t),
      f32: new Float32Array(t),
      // TODO not implemented
      f16: new Uint16Array(t)
    };
    for (const [n, s] of Object.entries(e)) {
      const c = this.layout[n];
      if (!c) {
        Ht.warn(`Supplied uniform value ${n} not present in uniform block layout`)();
        continue;
      }
      const {
        type: o,
        size: d,
        offset: m
      } = c, y = i[o];
      if (d === 1) {
        if (typeof s != "number" && typeof s != "boolean") {
          Ht.warn(`Supplied value for single component uniform ${n} is not a number: ${s}`)();
          continue;
        }
        y[m] = Number(s);
      } else {
        if (!wy(s)) {
          Ht.warn(`Supplied value for multi component / array uniform ${n} is not a numeric array: ${s}`)();
          continue;
        }
        y.set(s, m);
      }
    }
    return new Uint8Array(t, 0, this.byteLength);
  }
  /** Does this layout have a field with specified name */
  has(e) {
    return !!this.layout[e];
  }
  /** Get offset and size for a field with specified name */
  get(e) {
    return this.layout[e];
  }
}
function ZD(r, e, t = 16) {
  if (r !== e)
    return !1;
  const i = r, n = e;
  if (!wy(i))
    return !1;
  if (wy(n) && i.length === n.length) {
    for (let s = 0; s < i.length; ++s)
      if (n[s] !== i[s])
        return !1;
  }
  return !0;
}
function YD(r) {
  return wy(r) ? r.slice() : r;
}
class JD {
  name;
  uniforms = {};
  modifiedUniforms = {};
  modified = !0;
  bindingLayout = {};
  needsRedraw = "initialized";
  constructor(e) {
    if (this.name = e?.name || "unnamed", e?.name && e?.shaderLayout) {
      const t = e?.shaderLayout.bindings?.find((n) => n.type === "uniform" && n.name === e?.name);
      if (!t)
        throw new Error(e?.name);
      const i = t;
      for (const n of i.uniforms || [])
        this.bindingLayout[n.name] = n;
    }
  }
  /** Set a map of uniforms */
  setUniforms(e) {
    for (const [t, i] of Object.entries(e))
      this._setUniform(t, i), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${t}=${i}`);
  }
  setNeedsRedraw(e) {
    this.needsRedraw = this.needsRedraw || e;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(e, t) {
    ZD(this.uniforms[e], t) || (this.uniforms[e] = YD(t), this.modifiedUniforms[e] = !0, this.modified = !0);
  }
}
class KD {
  /** Stores the uniform values for each uniform block */
  uniformBlocks = /* @__PURE__ */ new Map();
  /** Can generate data for a uniform buffer for each block from data */
  uniformBufferLayouts = /* @__PURE__ */ new Map();
  /** Actual buffer for the blocks */
  uniformBuffers = /* @__PURE__ */ new Map();
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(e) {
    for (const [t, i] of Object.entries(e)) {
      const n = t, s = new XD(i.uniformTypes ?? {}, i.uniformSizes ?? {});
      this.uniformBufferLayouts.set(n, s);
      const c = new JD({
        name: t
      });
      c.setUniforms(i.defaultUniforms || {}), this.uniformBlocks.set(n, c);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const e of this.uniformBuffers.values())
      e.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(e) {
    for (const [t, i] of Object.entries(e))
      this.uniformBlocks.get(t)?.setUniforms(i);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(e) {
    return this.uniformBufferLayouts.get(e)?.byteLength || 0;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(e) {
    const t = this.uniformBlocks.get(e)?.getAllUniforms() || {};
    return this.uniformBufferLayouts.get(e)?.getData(t);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(e, t, i) {
    i && this.setUniforms(i);
    const n = this.getUniformBufferByteLength(t), s = e.createBuffer({
      usage: us.UNIFORM | us.COPY_DST,
      byteLength: n
    }), c = this.getUniformBufferData(t);
    return s.write(c), s;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(e, t) {
    if (!this.uniformBuffers.get(t)) {
      const i = this.getUniformBufferByteLength(t), n = e.createBuffer({
        usage: us.UNIFORM | us.COPY_DST,
        byteLength: i
      });
      this.uniformBuffers.set(t, n);
    }
    return this.uniformBuffers.get(t);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let e = !1;
    for (const t of this.uniformBlocks.keys()) {
      const i = this.updateUniformBuffer(t);
      e ||= i;
    }
    return e && Ht.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(e) {
    const t = this.uniformBlocks.get(e);
    let i = this.uniformBuffers.get(e), n = !1;
    if (i && t?.needsRedraw) {
      n ||= t.needsRedraw;
      const s = this.getUniformBufferData(e);
      i = this.uniformBuffers.get(e), i?.write(s);
      const c = this.uniformBlocks.get(e)?.getAllUniforms();
      Ht.log(4, `Writing to uniform buffer ${String(e)}`, s, c)();
    }
    return n;
  }
}
class Dl {
  constructor(e, t) {
    this.name = e, this.attributes = t, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
  get isPointer() {
    return !1;
  }
  getTypeName() {
    return this.name;
  }
}
class IT {
  constructor(e, t, i) {
    this.name = e, this.type = t, this.attributes = i, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class Uh extends Dl {
  constructor(e, t) {
    super(e, t), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
class Gh extends Dl {
  constructor(e, t) {
    super(e, t), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
  getTypeName() {
    return `array<${this.format.getTypeName()}, ${this.count}>`;
  }
}
class hv extends Dl {
  constructor(e, t, i) {
    super(e, i), this.format = t;
  }
  get isPointer() {
    return !0;
  }
  getTypeName() {
    return `&${this.format.getTypeName()}`;
  }
}
class Kf extends Dl {
  constructor(e, t, i, n) {
    super(e, i), this.format = t, this.access = n;
  }
  get isTemplate() {
    return !0;
  }
  getTypeName() {
    let e = this.name;
    if (this.format !== null) {
      if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
        if (this.format.name === "f32") return e += "f", e;
        if (this.format.name === "i32") return e += "i", e;
        if (this.format.name === "u32") return e += "u", e;
        if (this.format.name === "bool") return e += "b", e;
        if (this.format.name === "f16") return e += "h", e;
      }
      e += `<${this.format.name}>`;
    } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
    return e;
  }
}
var Nh;
((r) => {
  r[r.Uniform = 0] = "Uniform", r[r.Storage = 1] = "Storage", r[r.Texture = 2] = "Texture", r[r.Sampler = 3] = "Sampler", r[r.StorageTexture = 4] = "StorageTexture";
})(Nh || (Nh = {}));
class Km {
  constructor(e, t, i, n, s, c, o) {
    this.name = e, this.type = t, this.group = i, this.binding = n, this.attributes = s, this.resourceType = c, this.access = o;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class QD {
  constructor(e, t) {
    this.name = e, this.type = t;
  }
}
class eN {
  constructor(e, t, i, n) {
    this.name = e, this.type = t, this.locationType = i, this.location = n, this.interpolation = null;
  }
}
class PT {
  constructor(e, t, i, n) {
    this.name = e, this.type = t, this.locationType = i, this.location = n;
  }
}
class tN {
  constructor(e, t, i, n) {
    this.name = e, this.type = t, this.attributes = i, this.id = n;
  }
}
class rN {
  constructor(e, t, i) {
    this.name = e, this.type = t, this.attributes = i;
  }
}
class iN {
  constructor(e, t = null, i) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = t, this.attributes = i;
  }
}
class nN {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
}
function sN(r) {
  var e = (32768 & r) >> 15, t = (31744 & r) >> 10, i = 1023 & r;
  return t == 0 ? (e ? -1 : 1) * Math.pow(2, -14) * (i / Math.pow(2, 10)) : t == 31 ? i ? NaN : 1 / 0 * (e ? -1 : 1) : (e ? -1 : 1) * Math.pow(2, t - 15) * (1 + i / Math.pow(2, 10));
}
const nI = new Float32Array(1), oN = new Int32Array(nI.buffer), Oo = new Uint16Array(1);
function aN(r) {
  nI[0] = r;
  const e = oN[0], t = e >> 31 & 1;
  let i = e >> 23 & 255, n = 8388607 & e;
  if (i === 255) return Oo[0] = t << 15 | 31744 | (n !== 0 ? 512 : 0), Oo[0];
  if (i === 0) {
    if (n === 0) return Oo[0] = t << 15, Oo[0];
    n |= 8388608;
    let s = 113;
    for (; !(8388608 & n); ) n <<= 1, s--;
    return i = 127 - s, n &= 8388607, i > 0 ? (n = (n >> 126 - i) + (n >> 127 - i & 1), Oo[0] = t << 15 | i << 10 | n >> 13, Oo[0]) : (Oo[0] = t << 15, Oo[0]);
  }
  return i = i - 127 + 15, i >= 31 ? (Oo[0] = t << 15 | 31744, Oo[0]) : i <= 0 ? i < -10 ? (Oo[0] = t << 15, Oo[0]) : (n = (8388608 | n) >> 1 - i, Oo[0] = t << 15 | n >> 13, Oo[0]) : (n >>= 13, Oo[0] = t << 15 | i << 10 | n, Oo[0]);
}
const U2 = new Uint32Array(1), sI = new Float32Array(U2.buffer, 0, 1);
function MT(r) {
  const e = 112 + (r >> 6 & 31) << 23 | (63 & r) << 17;
  return U2[0] = e, sI[0];
}
function lN(r, e, t, i, n, s, c, o, d) {
  const m = i * (c >>= n) * (s >>= n) + t * c + e * o;
  switch (d) {
    case "r8unorm":
      return [Ji(r, m, "8unorm", 1)[0]];
    case "r8snorm":
      return [Ji(r, m, "8snorm", 1)[0]];
    case "r8uint":
      return [Ji(r, m, "8uint", 1)[0]];
    case "r8sint":
      return [Ji(r, m, "8sint", 1)[0]];
    case "rg8unorm": {
      const y = Ji(r, m, "8unorm", 2);
      return [y[0], y[1]];
    }
    case "rg8snorm": {
      const y = Ji(r, m, "8snorm", 2);
      return [y[0], y[1]];
    }
    case "rg8uint": {
      const y = Ji(r, m, "8uint", 2);
      return [y[0], y[1]];
    }
    case "rg8sint": {
      const y = Ji(r, m, "8sint", 2);
      return [y[0], y[1]];
    }
    case "rgba8unorm-srgb":
    case "rgba8unorm": {
      const y = Ji(r, m, "8unorm", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba8snorm": {
      const y = Ji(r, m, "8snorm", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba8uint": {
      const y = Ji(r, m, "8uint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba8sint": {
      const y = Ji(r, m, "8sint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "bgra8unorm-srgb":
    case "bgra8unorm": {
      const y = Ji(r, m, "8unorm", 4);
      return [y[2], y[1], y[0], y[3]];
    }
    case "r16uint":
      return [Ji(r, m, "16uint", 1)[0]];
    case "r16sint":
      return [Ji(r, m, "16sint", 1)[0]];
    case "r16float":
      return [Ji(r, m, "16float", 1)[0]];
    case "rg16uint": {
      const y = Ji(r, m, "16uint", 2);
      return [y[0], y[1]];
    }
    case "rg16sint": {
      const y = Ji(r, m, "16sint", 2);
      return [y[0], y[1]];
    }
    case "rg16float": {
      const y = Ji(r, m, "16float", 2);
      return [y[0], y[1]];
    }
    case "rgba16uint": {
      const y = Ji(r, m, "16uint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba16sint": {
      const y = Ji(r, m, "16sint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba16float": {
      const y = Ji(r, m, "16float", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "r32uint":
      return [Ji(r, m, "32uint", 1)[0]];
    case "r32sint":
      return [Ji(r, m, "32sint", 1)[0]];
    case "depth16unorm":
    case "depth24plus":
    case "depth24plus-stencil8":
    case "depth32float":
    case "depth32float-stencil8":
    case "r32float":
      return [Ji(r, m, "32float", 1)[0]];
    case "rg32uint": {
      const y = Ji(r, m, "32uint", 2);
      return [y[0], y[1]];
    }
    case "rg32sint": {
      const y = Ji(r, m, "32sint", 2);
      return [y[0], y[1]];
    }
    case "rg32float": {
      const y = Ji(r, m, "32float", 2);
      return [y[0], y[1]];
    }
    case "rgba32uint": {
      const y = Ji(r, m, "32uint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba32sint": {
      const y = Ji(r, m, "32sint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba32float": {
      const y = Ji(r, m, "32float", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rg11b10ufloat": {
      const y = new Uint32Array(r.buffer, m, 1)[0], T = (4192256 & y) >> 11, P = (4290772992 & y) >> 22;
      return [MT(2047 & y), MT(T), function(I) {
        const D = 112 + (I >> 5 & 31) << 23 | (31 & I) << 18;
        return U2[0] = D, sI[0];
      }(P), 1];
    }
  }
  return null;
}
function Ji(r, e, t, i) {
  const n = [0, 0, 0, 0];
  for (let s = 0; s < i; ++s) switch (t) {
    case "8unorm":
      n[s] = r[e] / 255, e++;
      break;
    case "8snorm":
      n[s] = r[e] / 255 * 2 - 1, e++;
      break;
    case "8uint":
      n[s] = r[e], e++;
      break;
    case "8sint":
      n[s] = r[e] - 127, e++;
      break;
    case "16uint":
      n[s] = r[e] | r[e + 1] << 8, e += 2;
      break;
    case "16sint":
      n[s] = (r[e] | r[e + 1] << 8) - 32768, e += 2;
      break;
    case "16float":
      n[s] = sN(r[e] | r[e + 1] << 8), e += 2;
      break;
    case "32uint":
    case "32sint":
      n[s] = r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24, e += 4;
      break;
    case "32float":
      n[s] = new Float32Array(r.buffer, e, 1)[0], e += 4;
  }
  return n;
}
function tn(r, e, t, i, n) {
  for (let s = 0; s < i; ++s) switch (t) {
    case "8unorm":
      r[e] = 255 * n[s], e++;
      break;
    case "8snorm":
      r[e] = 0.5 * (n[s] + 1) * 255, e++;
      break;
    case "8uint":
      r[e] = n[s], e++;
      break;
    case "8sint":
      r[e] = n[s] + 127, e++;
      break;
    case "16uint":
      new Uint16Array(r.buffer, e, 1)[0] = n[s], e += 2;
      break;
    case "16sint":
      new Int16Array(r.buffer, e, 1)[0] = n[s], e += 2;
      break;
    case "16float": {
      const c = aN(n[s]);
      new Uint16Array(r.buffer, e, 1)[0] = c, e += 2;
      break;
    }
    case "32uint":
      new Uint32Array(r.buffer, e, 1)[0] = n[s], e += 4;
      break;
    case "32sint":
      new Int32Array(r.buffer, e, 1)[0] = n[s], e += 4;
      break;
    case "32float":
      new Float32Array(r.buffer, e, 1)[0] = n[s], e += 4;
  }
  return n;
}
const xb = {
  r8unorm: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r8snorm: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r8uint: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r8sint: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  rg8unorm: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg8snorm: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg8uint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg8sint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rgba8unorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  "rgba8unorm-srgb": {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba8snorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba8uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba8sint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  bgra8unorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  "bgra8unorm-srgb": {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  r16uint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r16sint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r16float: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  rg16uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg16sint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg16float: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rgba16uint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba16sint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba16float: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  r32uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r32sint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r32float: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  rg32uint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg32sint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg32float: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rgba32uint: {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba32sint: {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba32float: {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgb10a2uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgb10a2unorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rg11b10ufloat: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  stencil8: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !1,
    hasStencil: !0,
    channels: 1
  },
  depth16unorm: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !1,
    channels: 1
  },
  depth24plus: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !1,
    depthOnlyFormat: "depth32float",
    channels: 1
  },
  "depth24plus-stencil8": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !0,
    depthOnlyFormat: "depth32float",
    channels: 1
  },
  depth32float: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !1,
    channels: 1
  },
  "depth32float-stencil8": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !0,
    stencilOnlyFormat: "depth32float",
    channels: 1
  },
  rgb9e5ufloat: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  "bc1-rgba-unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc1-rgba-unorm-srgb": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc2-rgba-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc2-rgba-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc3-rgba-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc3-rgba-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc4-r-unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 1
  },
  "bc4-r-snorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 1
  },
  "bc5-rg-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 2
  },
  "bc5-rg-snorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 2
  },
  "bc6h-rgb-ufloat": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc6h-rgb-float": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc7-rgba-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc7-rgba-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8unorm-srgb": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8a1unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8a1unorm-srgb": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgba8unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgba8unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "eac-r11unorm": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 1
  },
  "eac-r11snorm": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 1
  },
  "eac-rg11unorm": {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 2
  },
  "eac-rg11snorm": {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 2
  },
  "astc-4x4-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-4x4-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x4-unorm": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x4-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x6-unorm": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x6-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x6-unorm": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x6-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x8-unorm": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x8-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x6-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x6-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x8-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x8-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x10-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x10-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x10-unorm": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x10-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x12-unorm": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 12,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x12-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 12,
    isCompressed: !0,
    channels: 4
  }
};
class Fl {
  constructor() {
    this.id = Fl._id++, this.line = 0;
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  search(e) {
    e(this);
  }
  searchBlock(e, t) {
    if (e) {
      t(Ay.instance);
      for (const i of e) i instanceof Array ? this.searchBlock(i, t) : i.search(t);
      t(Ty.instance);
    }
  }
  constEvaluate(e, t) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(e) {
    return this.constEvaluate(e).toString();
  }
}
Fl._id = 0;
class Ay extends Fl {
}
Ay.instance = new Ay();
class Ty extends Fl {
}
Ty.instance = new Ty();
const oI = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
class $n extends Fl {
  constructor() {
    super();
  }
}
class Wg extends $n {
  constructor(e, t, i, n, s, c) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = t, this.returnType = i, this.body = n, this.startLine = s, this.endLine = c;
  }
  get astNodeType() {
    return "function";
  }
  search(e) {
    if (this.attributes) for (const t of this.attributes) e(t);
    e(this);
    for (const t of this.args) e(t);
    this.searchBlock(this.body, e);
  }
}
class cN extends $n {
  constructor(e) {
    super(), this.expression = e;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e) {
    this.expression.search(e);
  }
}
class aI extends $n {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "while";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class fv extends $n {
  constructor(e, t) {
    super(), this.body = e, this.loopId = t;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class lI extends $n {
  constructor(e, t, i, n) {
    super(), this.init = e, this.condition = t, this.increment = i, this.body = n;
  }
  get astNodeType() {
    return "for";
  }
  search(e) {
    var t, i, n;
    (t = this.init) === null || t === void 0 || t.search(e), (i = this.condition) === null || i === void 0 || i.search(e), (n = this.increment) === null || n === void 0 || n.search(e), this.searchBlock(this.body, e);
  }
}
class rh extends $n {
  constructor(e, t, i, n, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = n, this.value = s;
  }
  get astNodeType() {
    return "var";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class z2 extends $n {
  constructor(e, t, i) {
    super(), this.attributes = null, this.name = e, this.type = t, this.value = i;
  }
  get astNodeType() {
    return "override";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class Bg extends $n {
  constructor(e, t, i, n, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = n, this.value = s;
  }
  get astNodeType() {
    return "let";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class j_ extends $n {
  constructor(e, t, i, n, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = n, this.value = s;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(e, t) {
    return this.value.constEvaluate(e, t);
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
var ep, wg, vt, lt;
((r) => {
  r.increment = "++", r.decrement = "--";
})(ep || (ep = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for IncrementOperator");
    return r[t];
  };
})(ep || (ep = {}));
class cI extends $n {
  constructor(e, t) {
    super(), this.operator = e, this.variable = t;
  }
  get astNodeType() {
    return "increment";
  }
  search(e) {
    this.variable.search(e);
  }
}
((r) => {
  r.assign = "=", r.addAssign = "+=", r.subtractAssin = "-=", r.multiplyAssign = "*=", r.divideAssign = "/=", r.moduloAssign = "%=", r.andAssign = "&=", r.orAssign = "|=", r.xorAssign = "^=", r.shiftLeftAssign = "<<=", r.shiftRightAssign = ">>=";
})(wg || (wg = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for AssignOperator");
    return t;
  };
})(wg || (wg = {}));
class uI extends $n {
  constructor(e, t, i) {
    super(), this.operator = e, this.variable = t, this.value = i;
  }
  get astNodeType() {
    return "assign";
  }
  search(e) {
    this.variable.search(e), this.value.search(e);
  }
}
class j2 extends $n {
  constructor(e, t) {
    super(), this.name = e, this.args = t;
  }
  get astNodeType() {
    return "call";
  }
  isBuiltin() {
    return oI.has(this.name);
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
}
class hI extends $n {
  constructor(e, t) {
    super(), this.body = e, this.continuing = t;
  }
  get astNodeType() {
    return "loop";
  }
  search(e) {
    var t;
    this.searchBlock(this.body, e), (t = this.continuing) === null || t === void 0 || t.search(e);
  }
}
class fI extends $n {
  constructor(e, t) {
    super(), this.condition = e, this.cases = t;
  }
  get astNodeType() {
    return "switch";
  }
  search(e) {
    e(this);
    for (const t of this.cases) t.search(e);
  }
}
class dI extends $n {
  constructor(e, t, i, n) {
    super(), this.condition = e, this.body = t, this.elseif = i, this.else = n;
  }
  get astNodeType() {
    return "if";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
  }
}
class pI extends $n {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "return";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class uN extends $n {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "enable";
  }
}
class hN extends $n {
  constructor(e) {
    super(), this.extensions = e;
  }
  get astNodeType() {
    return "requires";
  }
}
class gI extends $n {
  constructor(e, t) {
    super(), this.severity = e, this.rule = t;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class V2 extends $n {
  constructor(e, t) {
    super(), this.name = e, this.type = t;
  }
  get astNodeType() {
    return "alias";
  }
}
class fN extends $n {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class mI extends $n {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
}
class _I extends $n {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
}
class $t extends $n {
  constructor(e) {
    super(), this.attributes = null, this.name = e;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
  static maxFormatType(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let i = 1; i < e.length; ++i) {
      const n = $t._priority.get(t.name);
      $t._priority.get(e[i].name) < n && (t = e[i]);
    }
    return t.name === "x32" ? $t.i32 : t;
  }
  getTypeName() {
    return this.name;
  }
}
$t.x32 = new $t("x32"), $t.f32 = new $t("f32"), $t.i32 = new $t("i32"), $t.u32 = new $t("u32"), $t.f16 = new $t("f16"), $t.bool = new $t("bool"), $t.void = new $t("void"), $t._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class RT extends $t {
  constructor(e) {
    super(e);
  }
}
class Qu extends $t {
  constructor(e, t, i, n) {
    super(e), this.members = t, this.startLine = i, this.endLine = n;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  getMemberIndex(e) {
    for (let t = 0; t < this.members.length; t++) if (this.members[t].name == e) return t;
    return -1;
  }
  search(e) {
    for (const t of this.members) e(t);
  }
}
class pt extends $t {
  constructor(e, t, i) {
    super(e), this.format = t, this.access = i;
  }
  get astNodeType() {
    return "template";
  }
  getTypeName() {
    let e = this.name;
    if (this.format !== null) {
      if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
        if (this.format.name === "f32") return e += "f", e;
        if (this.format.name === "i32") return e += "i", e;
        if (this.format.name === "u32") return e += "u", e;
        if (this.format.name === "bool") return e += "b", e;
        if (this.format.name === "f16") return e += "h", e;
      }
      e += `<${this.format.name}>`;
    } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
    return e;
  }
}
pt.vec2f = new pt("vec2", $t.f32, null), pt.vec3f = new pt("vec3", $t.f32, null), pt.vec4f = new pt("vec4", $t.f32, null), pt.vec2i = new pt("vec2", $t.i32, null), pt.vec3i = new pt("vec3", $t.i32, null), pt.vec4i = new pt("vec4", $t.i32, null), pt.vec2u = new pt("vec2", $t.u32, null), pt.vec3u = new pt("vec3", $t.u32, null), pt.vec4u = new pt("vec4", $t.u32, null), pt.vec2h = new pt("vec2", $t.f16, null), pt.vec3h = new pt("vec3", $t.f16, null), pt.vec4h = new pt("vec4", $t.f16, null), pt.vec2b = new pt("vec2", $t.bool, null), pt.vec3b = new pt("vec3", $t.bool, null), pt.vec4b = new pt("vec4", $t.bool, null), pt.mat2x2f = new pt("mat2x2", $t.f32, null), pt.mat2x3f = new pt("mat2x3", $t.f32, null), pt.mat2x4f = new pt("mat2x4", $t.f32, null), pt.mat3x2f = new pt("mat3x2", $t.f32, null), pt.mat3x3f = new pt("mat3x3", $t.f32, null), pt.mat3x4f = new pt("mat3x4", $t.f32, null), pt.mat4x2f = new pt("mat4x2", $t.f32, null), pt.mat4x3f = new pt("mat4x3", $t.f32, null), pt.mat4x4f = new pt("mat4x4", $t.f32, null), pt.mat2x2h = new pt("mat2x2", $t.f16, null), pt.mat2x3h = new pt("mat2x3", $t.f16, null), pt.mat2x4h = new pt("mat2x4", $t.f16, null), pt.mat3x2h = new pt("mat3x2", $t.f16, null), pt.mat3x3h = new pt("mat3x3", $t.f16, null), pt.mat3x4h = new pt("mat3x4", $t.f16, null), pt.mat4x2h = new pt("mat4x2", $t.f16, null), pt.mat4x3h = new pt("mat4x3", $t.f16, null), pt.mat4x4h = new pt("mat4x4", $t.f16, null), pt.mat2x2i = new pt("mat2x2", $t.i32, null), pt.mat2x3i = new pt("mat2x3", $t.i32, null), pt.mat2x4i = new pt("mat2x4", $t.i32, null), pt.mat3x2i = new pt("mat3x2", $t.i32, null), pt.mat3x3i = new pt("mat3x3", $t.i32, null), pt.mat3x4i = new pt("mat3x4", $t.i32, null), pt.mat4x2i = new pt("mat4x2", $t.i32, null), pt.mat4x3i = new pt("mat4x3", $t.i32, null), pt.mat4x4i = new pt("mat4x4", $t.i32, null), pt.mat2x2u = new pt("mat2x2", $t.u32, null), pt.mat2x3u = new pt("mat2x3", $t.u32, null), pt.mat2x4u = new pt("mat2x4", $t.u32, null), pt.mat3x2u = new pt("mat3x2", $t.u32, null), pt.mat3x3u = new pt("mat3x3", $t.u32, null), pt.mat3x4u = new pt("mat3x4", $t.u32, null), pt.mat4x2u = new pt("mat4x2", $t.u32, null), pt.mat4x3u = new pt("mat4x3", $t.u32, null), pt.mat4x4u = new pt("mat4x4", $t.u32, null);
class V_ extends $t {
  constructor(e, t, i, n) {
    super(e), this.storage = t, this.type = i, this.access = n;
  }
  get astNodeType() {
    return "pointer";
  }
}
class kg extends $t {
  constructor(e, t, i, n) {
    super(e), this.attributes = t, this.format = i, this.count = n;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}
class Ag extends $t {
  constructor(e, t, i) {
    super(e), this.format = t, this.access = i;
  }
  get astNodeType() {
    return "sampler";
  }
}
class Ic extends Fl {
  constructor() {
    super(), this.postfix = null;
  }
}
class Qf extends Ic {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
}
class pu extends Ic {
  constructor(e, t) {
    super(), this.type = e, this.args = t;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e) {
    if (e(this), this.args) for (const t of this.args) t.search(e);
  }
  constEvaluate(e, t) {
    return t && (t[0] = this.type), e.evalExpression(this, e.context);
  }
}
class G2 extends Ic {
  constructor(e, t) {
    super(), this.cachedReturnValue = null, this.name = e, this.args = t;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(e) {
    this.cachedReturnValue = e;
  }
  get isBuiltin() {
    return oI.has(this.name);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
}
class il extends Ic {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e) {
    e(this), this.postfix && this.postfix.search(e);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
}
class yI extends Ic {
  constructor(e, t) {
    super(), this.name = e, this.initializer = t;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(e, t) {
    if (this.initializer) {
      const i = e.evalExpression(this.initializer, e.context);
      return i !== null && this.postfix ? i.getSubData(e, this.postfix, e.context) : i;
    }
    return null;
  }
  search(e) {
    this.initializer.search(e);
  }
}
class Ys extends Ic {
  constructor(e, t) {
    super(), this.value = e, this.type = t;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(e, t) {
    return t !== void 0 && (t[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof ot;
  }
  get isVector() {
    return this.value instanceof Ne || this.value instanceof ei;
  }
  get scalarValue() {
    return this.value instanceof ot ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof Ne || this.value instanceof ei ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
  }
}
class bI extends Ic {
  constructor(e, t) {
    super(), this.type = e, this.value = t;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e) {
    this.value.search(e);
  }
}
class xp extends Ic {
  constructor(e) {
    super(), this.index = e;
  }
  search(e) {
    this.index.search(e);
  }
}
let vI = class extends Ic {
  constructor() {
    super();
  }
};
class Ds extends vI {
  constructor(e, t) {
    super(), this.operator = e, this.right = t;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.right.search(e);
  }
}
class gc extends vI {
  constructor(e, t, i) {
    super(), this.operator = e, this.left = t, this.right = i;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(e, t) {
    return e.name === t.name ? e : e.name === "f32" || t.name === "f32" ? $t.f32 : e.name === "u32" || t.name === "u32" ? $t.u32 : $t.i32;
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.left.search(e), this.right.search(e);
  }
}
class xI extends Fl {
  constructor(e) {
    super(), this.body = e;
  }
  search(e) {
    e(this), this.searchBlock(this.body, e);
  }
}
class G_ extends Ic {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
}
class wI extends xI {
  constructor(e, t) {
    super(t), this.selectors = e;
  }
  get astNodeType() {
    return "case";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
let AI = class extends xI {
  constructor(e) {
    super(e);
  }
  get astNodeType() {
    return "default";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}, LT = class extends Fl {
  constructor(e, t, i) {
    super(), this.name = e, this.type = t, this.attributes = i;
  }
  get astNodeType() {
    return "argument";
  }
};
class dN extends Fl {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class BT extends Fl {
  constructor(e, t, i) {
    super(), this.name = e, this.type = t, this.attributes = i;
  }
  get astNodeType() {
    return "member";
  }
}
class TI extends Fl {
  constructor(e, t) {
    super(), this.name = e, this.value = t;
  }
  get astNodeType() {
    return "attribute";
  }
}
let wu = class SI {
  constructor(e, t) {
    this.parent = null, this.typeInfo = e, this.parent = t, this.id = SI._id++;
  }
  clone() {
    throw `Clone: Not implemented for ${this.constructor.name}`;
  }
  setDataValue(e, t, i, n) {
    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
  }
  getSubData(e, t, i) {
    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
  }
  toString() {
    return `<${this.typeInfo.getTypeName()}>`;
  }
};
wu._id = 0;
let dv = class extends wu {
  constructor() {
    super(new Dl("void", null), null);
  }
  toString() {
    return "void";
  }
};
dv.void = new dv();
class zd extends wu {
  constructor(e) {
    super(new hv("pointer", e.typeInfo, null), null), this.reference = e;
  }
  clone() {
    return this;
  }
  setDataValue(e, t, i, n) {
    this.reference.setDataValue(e, t, i, n);
  }
  getSubData(e, t, i) {
    return t ? this.reference.getSubData(e, t, i) : this;
  }
  toString() {
    return `&${this.reference.toString()}`;
  }
}
class ot extends wu {
  constructor(e, t, i = null) {
    super(t, i), e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array ? this.data = e : this.typeInfo.name === "x32" ? e - Math.floor(e) !== 0 ? this.data = new Float32Array([e]) : this.data = e >= 0 ? new Uint32Array([e]) : new Int32Array([e]) : this.typeInfo.name === "i32" || this.typeInfo.name === "bool" ? this.data = new Int32Array([e]) : this.typeInfo.name === "u32" ? this.data = new Uint32Array([e]) : this.typeInfo.name === "f32" || this.typeInfo.name === "f16" ? this.data = new Float32Array([e]) : console.error("ScalarData2: Invalid type", t);
  }
  clone() {
    if (this.data instanceof Float32Array) return new ot(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new ot(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new ot(new Uint32Array(this.data), this.typeInfo, null);
    throw "ScalarData: Invalid data type";
  }
  get value() {
    return this.data[0];
  }
  set value(e) {
    this.data[0] = e;
  }
  setDataValue(e, t, i, n) {
    if (i) return void console.error("SetDataValue: Scalar data does not support postfix", i);
    if (!(t instanceof ot)) return void console.error("SetDataValue: Invalid value", t);
    let s = t.data[0];
    this.typeInfo.name === "i32" || this.typeInfo.name === "u32" ? s = Math.floor(s) : this.typeInfo.name === "bool" && (s = s ? 1 : 0), this.data[0] = s;
  }
  getSubData(e, t, i) {
    return t ? (console.error("getSubData: Scalar data does not support postfix", t), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
}
function pN(r, e, t) {
  const i = e.length;
  return i === 2 ? t === "f32" ? new Ne(new Float32Array(e), r.getTypeInfo("vec2f")) : t === "i32" || t === "bool" ? new Ne(new Int32Array(e), r.getTypeInfo("vec2i")) : t === "u32" ? new Ne(new Uint32Array(e), r.getTypeInfo("vec2u")) : t === "f16" ? new Ne(new Float32Array(e), r.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${t}`), null) : i === 3 ? t === "f32" ? new Ne(new Float32Array(e), r.getTypeInfo("vec3f")) : t === "i32" || t === "bool" ? new Ne(new Int32Array(e), r.getTypeInfo("vec3i")) : t === "u32" ? new Ne(new Uint32Array(e), r.getTypeInfo("vec3u")) : t === "f16" ? new Ne(new Float32Array(e), r.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${t}`), null) : i === 4 ? t === "f32" ? new Ne(new Float32Array(e), r.getTypeInfo("vec4f")) : t === "i32" || t === "bool" ? new Ne(new Int32Array(e), r.getTypeInfo("vec4i")) : t === "u32" ? new Ne(new Uint32Array(e), r.getTypeInfo("vec4u")) : t === "f16" ? new Ne(new Float32Array(e), r.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${t}`), null) : (console.error(`getSubData: Invalid vector size ${e.length}`), null);
}
class Ne extends wu {
  constructor(e, t, i = null) {
    if (super(t, i), e instanceof Float32Array || e instanceof Uint32Array || e instanceof Int32Array) this.data = e;
    else {
      const n = this.typeInfo.name;
      n === "vec2f" || n === "vec3f" || n === "vec4f" ? this.data = new Float32Array(e) : n === "vec2i" || n === "vec3i" || n === "vec4i" ? this.data = new Int32Array(e) : n === "vec2u" || n === "vec3u" || n === "vec4u" ? this.data = new Uint32Array(e) : n === "vec2h" || n === "vec3h" || n === "vec4h" ? this.data = new Float32Array(e) : n === "vec2b" || n === "vec3b" || n === "vec4b" ? this.data = new Int32Array(e) : n === "vec2" || n === "vec3" || n === "vec4" ? this.data = new Float32Array(e) : console.error(`VectorData: Invalid type ${n}`);
    }
  }
  clone() {
    if (this.data instanceof Float32Array) return new Ne(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new Ne(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new Ne(new Uint32Array(this.data), this.typeInfo, null);
    throw "VectorData: Invalid data type";
  }
  setDataValue(e, t, i, n) {
    i instanceof Qf ? console.error("TODO: Set vector postfix") : t instanceof Ne ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
  }
  getSubData(e, t, i) {
    if (t === null) return this;
    let n = e.getTypeInfo("f32");
    if (this.typeInfo instanceof Kf) n = this.typeInfo.format || n;
    else {
      const c = this.typeInfo.name;
      c === "vec2f" || c === "vec3f" || c === "vec4f" ? n = e.getTypeInfo("f32") : c === "vec2i" || c === "vec3i" || c === "vec4i" ? n = e.getTypeInfo("i32") : c === "vec2b" || c === "vec3b" || c === "vec4b" ? n = e.getTypeInfo("bool") : c === "vec2u" || c === "vec3u" || c === "vec4u" ? n = e.getTypeInfo("u32") : c === "vec2h" || c === "vec3h" || c === "vec4h" ? n = e.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${c}`);
    }
    let s = this;
    for (; t !== null && s !== null; ) {
      if (t instanceof xp) {
        const c = t.index;
        let o = -1;
        if (c instanceof Ys) {
          if (!(c.value instanceof ot)) return console.error(`GetSubData: Invalid array index ${c.value}`), null;
          o = c.value.value;
        } else {
          const d = e.evalExpression(c, i);
          if (!(d instanceof ot)) return console.error("GetSubData: Unknown index type", c), null;
          o = d.value;
        }
        if (o < 0 || o >= s.data.length) return console.error("GetSubData: Index out of range", o), null;
        if (s.data instanceof Float32Array) {
          const d = new Float32Array(s.data.buffer, s.data.byteOffset + 4 * o, 1);
          return new ot(d, n);
        }
        if (s.data instanceof Int32Array) {
          const d = new Int32Array(s.data.buffer, s.data.byteOffset + 4 * o, 1);
          return new ot(d, n);
        }
        if (s.data instanceof Uint32Array) {
          const d = new Uint32Array(s.data.buffer, s.data.byteOffset + 4 * o, 1);
          return new ot(d, n);
        }
        throw "GetSubData: Invalid data type";
      }
      if (!(t instanceof Qf)) return console.error("GetSubData: Unknown postfix", t), null;
      {
        const c = t.value.toLowerCase();
        if (c.length === 1) {
          let d = 0;
          if (c === "x" || c === "r") d = 0;
          else if (c === "y" || c === "g") d = 1;
          else if (c === "z" || c === "b") d = 2;
          else {
            if (c !== "w" && c !== "a") return console.error(`GetSubData: Unknown member ${c}`), null;
            d = 3;
          }
          if (this.data instanceof Float32Array) {
            let m = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new ot(m, n, this);
          }
          if (this.data instanceof Int32Array) {
            let m = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new ot(m, n, this);
          }
          if (this.data instanceof Uint32Array) {
            let m = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new ot(m, n, this);
          }
        }
        const o = [];
        for (const d of c) d === "x" || d === "r" ? o.push(this.data[0]) : d === "y" || d === "g" ? o.push(this.data[1]) : d === "z" || d === "b" ? o.push(this.data[2]) : d === "w" || d === "a" ? o.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${d}`);
        s = pN(e, o, n.name);
      }
      t = t.postfix;
    }
    return s;
  }
  toString() {
    let e = `${this.data[0]}`;
    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
    return e;
  }
}
class ei extends wu {
  constructor(e, t, i = null) {
    super(t, i), e instanceof Float32Array ? this.data = e : this.data = new Float32Array(e);
  }
  clone() {
    return new ei(new Float32Array(this.data), this.typeInfo, null);
  }
  setDataValue(e, t, i, n) {
    i instanceof Qf ? console.error("TODO: Set matrix postfix") : t instanceof ei ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
  }
  getSubData(e, t, i) {
    if (t === null) return this;
    const n = this.typeInfo.name;
    if (e.getTypeInfo("f32"), this.typeInfo instanceof Kf) this.typeInfo.format;
    else if (n.endsWith("f")) e.getTypeInfo("f32");
    else if (n.endsWith("i")) e.getTypeInfo("i32");
    else if (n.endsWith("u")) e.getTypeInfo("u32");
    else {
      if (!n.endsWith("h")) return console.error(`GetDataValue: Unknown type ${n}`), null;
      e.getTypeInfo("f16");
    }
    if (t instanceof xp) {
      const s = t.index;
      let c = -1;
      if (s instanceof Ys) {
        if (!(s.value instanceof ot)) return console.error(`GetDataValue: Invalid array index ${s.value}`), null;
        c = s.value.value;
      } else {
        const m = e.evalExpression(s, i);
        if (!(m instanceof ot)) return console.error("GetDataValue: Unknown index type", s), null;
        c = m.value;
      }
      if (c < 0 || c >= this.data.length) return console.error("GetDataValue: Index out of range", c), null;
      const o = n.endsWith("h") ? "h" : "f";
      let d;
      if (n === "mat2x2" || n === "mat2x2f" || n === "mat2x2h" || n === "mat3x2" || n === "mat3x2f" || n === "mat3x2h" || n === "mat4x2" || n === "mat4x2f" || n === "mat4x2h") d = new Ne(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * c * 4, 2), e.getTypeInfo(`vec2${o}`));
      else if (n === "mat2x3" || n === "mat2x3f" || n === "mat2x3h" || n === "mat3x3" || n === "mat3x3f" || n === "mat3x3h" || n === "mat4x3" || n === "mat4x3f" || n === "mat4x3h") d = new Ne(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * c * 4, 3), e.getTypeInfo(`vec3${o}`));
      else {
        if (n !== "mat2x4" && n !== "mat2x4f" && n !== "mat2x4h" && n !== "mat3x4" && n !== "mat3x4f" && n !== "mat3x4h" && n !== "mat4x4" && n !== "mat4x4f" && n !== "mat4x4h") return console.error(`GetDataValue: Unknown type ${n}`), null;
        d = new Ne(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * c * 4, 4), e.getTypeInfo(`vec4${o}`));
      }
      return t.postfix ? d.getSubData(e, t.postfix, i) : d;
    }
    return console.error("GetDataValue: Invalid postfix", t), null;
  }
  toString() {
    let e = `${this.data[0]}`;
    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
    return e;
  }
}
class cs extends wu {
  constructor(e, t, i = 0, n = null) {
    super(t, n), this.buffer = e instanceof ArrayBuffer ? e : e.buffer, this.offset = i;
  }
  clone() {
    const e = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
    return new cs(e.buffer, this.typeInfo, 0, null);
  }
  setDataValue(e, t, i, n) {
    if (t === null) return void console.log("setDataValue: NULL data.");
    let s = this.offset, c = this.typeInfo;
    for (; i; ) {
      if (i instanceof xp)
        if (c instanceof Gh) {
          const o = i.index;
          if (o instanceof Ys) {
            if (!(o.value instanceof ot)) return void console.error(`SetDataValue: Invalid index type ${o.value}`);
            s += o.value.value * c.stride;
          } else {
            const d = e.evalExpression(o, n);
            if (!(d instanceof ot)) return void console.error("SetDataValue: Unknown index type", o);
            s += d.value * c.stride;
          }
          c = c.format;
        } else console.error(`SetDataValue: Type ${c.getTypeName()} is not an array`);
      else {
        if (!(i instanceof Qf)) return void console.error("SetDataValue: Unknown postfix type", i);
        {
          const o = i.value;
          if (c instanceof Uh) {
            let d = !1;
            for (const m of c.members) if (m.name === o) {
              s += m.offset, c = m.type, d = !0;
              break;
            }
            if (!d) return void console.error(`SetDataValue: Member ${o} not found`);
          } else if (c instanceof Dl) {
            const d = c.getTypeName();
            let m = 0;
            if (o === "x" || o === "r") m = 0;
            else if (o === "y" || o === "g") m = 1;
            else if (o === "z" || o === "b") m = 2;
            else {
              if (o !== "w" && o !== "a") return void console.error(`SetDataValue: Unknown member ${o}`);
              m = 3;
            }
            if (!(t instanceof ot)) return void console.error("SetDataValue: Invalid value", t);
            const y = t.value;
            return d === "vec2f" ? void (new Float32Array(this.buffer, s, 2)[m] = y) : d === "vec3f" ? void (new Float32Array(this.buffer, s, 3)[m] = y) : d === "vec4f" ? void (new Float32Array(this.buffer, s, 4)[m] = y) : d === "vec2i" ? void (new Int32Array(this.buffer, s, 2)[m] = y) : d === "vec3i" ? void (new Int32Array(this.buffer, s, 3)[m] = y) : d === "vec4i" ? void (new Int32Array(this.buffer, s, 4)[m] = y) : d === "vec2u" ? void (new Uint32Array(this.buffer, s, 2)[m] = y) : d === "vec3u" ? void (new Uint32Array(this.buffer, s, 3)[m] = y) : d === "vec4u" ? void (new Uint32Array(this.buffer, s, 4)[m] = y) : void console.error(`SetDataValue: Type ${d} is not a struct`);
          }
        }
      }
      i = i.postfix;
    }
    this.setData(e, t, c, s, n);
  }
  setData(e, t, i, n, s) {
    const c = i.getTypeName();
    if (c !== "f32" && c !== "f16")
      if (c !== "i32" && c !== "atomic<i32>" && c !== "x32")
        if (c !== "u32" && c !== "atomic<u32>")
          if (c !== "bool") {
            if (c === "vec2f" || c === "vec2h") {
              const o = new Float32Array(this.buffer, n, 2);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]));
            }
            if (c === "vec3f" || c === "vec3h") {
              const o = new Float32Array(this.buffer, n, 3);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]));
            }
            if (c === "vec4f" || c === "vec4h") {
              const o = new Float32Array(this.buffer, n, 4);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]));
            }
            if (c === "vec2i") {
              const o = new Int32Array(this.buffer, n, 2);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]));
            }
            if (c === "vec3i") {
              const o = new Int32Array(this.buffer, n, 3);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]));
            }
            if (c === "vec4i") {
              const o = new Int32Array(this.buffer, n, 4);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]));
            }
            if (c === "vec2u") {
              const o = new Uint32Array(this.buffer, n, 2);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]));
            }
            if (c === "vec3u") {
              const o = new Uint32Array(this.buffer, n, 3);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]));
            }
            if (c === "vec4u") {
              const o = new Uint32Array(this.buffer, n, 4);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]));
            }
            if (c === "vec2b") {
              const o = new Uint32Array(this.buffer, n, 2);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]));
            }
            if (c === "vec3b") {
              const o = new Uint32Array(this.buffer, n, 3);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]));
            }
            if (c === "vec4b") {
              const o = new Uint32Array(this.buffer, n, 4);
              return void (t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]));
            }
            if (c === "mat2x2f" || c === "mat2x2h") {
              const o = new Float32Array(this.buffer, n, 4);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]));
            }
            if (c === "mat2x3f" || c === "mat2x3h") {
              const o = new Float32Array(this.buffer, n, 6);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5]));
            }
            if (c === "mat2x4f" || c === "mat2x4h") {
              const o = new Float32Array(this.buffer, n, 8);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7]));
            }
            if (c === "mat3x2f" || c === "mat3x2h") {
              const o = new Float32Array(this.buffer, n, 6);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5]));
            }
            if (c === "mat3x3f" || c === "mat3x3h") {
              const o = new Float32Array(this.buffer, n, 9);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8]));
            }
            if (c === "mat3x4f" || c === "mat3x4h") {
              const o = new Float32Array(this.buffer, n, 12);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8], o[9] = t.data[9], o[10] = t.data[10], o[11] = t.data[11]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11]));
            }
            if (c === "mat4x2f" || c === "mat4x2h") {
              const o = new Float32Array(this.buffer, n, 8);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7]));
            }
            if (c === "mat4x3f" || c === "mat4x3h") {
              const o = new Float32Array(this.buffer, n, 12);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8], o[9] = t.data[9], o[10] = t.data[10], o[11] = t.data[11]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11]));
            }
            if (c === "mat4x4f" || c === "mat4x4h") {
              const o = new Float32Array(this.buffer, n, 16);
              return void (t instanceof ei ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8], o[9] = t.data[9], o[10] = t.data[10], o[11] = t.data[11], o[12] = t.data[12], o[13] = t.data[13], o[14] = t.data[14], o[15] = t.data[15]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]));
            }
            if (t instanceof cs) {
              if (i === t.typeInfo)
                return void new Uint8Array(this.buffer, n, t.buffer.byteLength).set(new Uint8Array(t.buffer));
              console.error("SetDataValue: Type mismatch", c, t.typeInfo.getTypeName());
            } else console.error(`SetData: Unknown type ${c}`);
          } else t instanceof ot && (new Int32Array(this.buffer, n, 1)[0] = t.value);
        else t instanceof ot && (new Uint32Array(this.buffer, n, 1)[0] = t.value);
      else t instanceof ot && (new Int32Array(this.buffer, n, 1)[0] = t.value);
    else t instanceof ot && (new Float32Array(this.buffer, n, 1)[0] = t.value);
  }
  getSubData(e, t, i) {
    var n, s, c;
    if (t === null) return this;
    let o = this.offset, d = this.typeInfo;
    for (; t; ) {
      if (t instanceof xp) {
        const y = t.index, T = y instanceof Ic ? e.evalExpression(y, i) : y;
        let P = 0;
        if (T instanceof ot ? P = T.value : typeof T == "number" ? P = T : console.error("GetDataValue: Invalid index type", y), d instanceof Gh) o += P * d.stride, d = d.format;
        else {
          const I = d.getTypeName();
          I === "mat4x4" || I === "mat4x4f" || I === "mat4x4h" ? (o += 16 * P, d = e.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${d.getTypeName()} is not an array`);
        }
      } else {
        if (!(t instanceof Qf)) return console.error("GetDataValue: Unknown postfix type", t), null;
        {
          const y = t.value;
          if (d instanceof Uh) {
            let T = !1;
            for (const P of d.members) if (P.name === y) {
              o += P.offset, d = P.type, T = !0;
              break;
            }
            if (!T) return console.error(`GetDataValue: Member ${y} not found`), null;
          } else if (d instanceof Dl) {
            const T = d.getTypeName();
            if (T === "vec2f" || T === "vec3f" || T === "vec4f" || T === "vec2i" || T === "vec3i" || T === "vec4i" || T === "vec2u" || T === "vec3u" || T === "vec4u" || T === "vec2b" || T === "vec3b" || T === "vec4b" || T === "vec2h" || T === "vec3h" || T === "vec4h" || T === "vec2" || T === "vec3" || T === "vec4") {
              if (y.length > 0 && y.length < 5) {
                let P = "f";
                const I = [];
                for (let D = 0; D < y.length; ++D) {
                  const k = y[D].toLowerCase();
                  let $ = 0;
                  if (k === "x" || k === "r") $ = 0;
                  else if (k === "y" || k === "g") $ = 1;
                  else if (k === "z" || k === "b") $ = 2;
                  else {
                    if (k !== "w" && k !== "a") return console.error(`Unknown member ${y}`), null;
                    $ = 3;
                  }
                  if (y.length === 1) {
                    if (T.endsWith("f")) return this.buffer.byteLength < o + 4 * $ + 4 ? (console.log("Insufficient buffer data"), null) : new ot(new Float32Array(this.buffer, o + 4 * $, 1), e.getTypeInfo("f32"), this);
                    if (T.endsWith("h")) return new ot(new Float32Array(this.buffer, o + 4 * $, 1), e.getTypeInfo("f16"), this);
                    if (T.endsWith("i")) return new ot(new Int32Array(this.buffer, o + 4 * $, 1), e.getTypeInfo("i32"), this);
                    if (T.endsWith("b")) return new ot(new Int32Array(this.buffer, o + 4 * $, 1), e.getTypeInfo("bool"), this);
                    if (T.endsWith("u")) return new ot(new Uint32Array(this.buffer, o + 4 * $, 1), e.getTypeInfo("i32"), this);
                  }
                  if (T === "vec2f") I.push(new Float32Array(this.buffer, o, 2)[$]);
                  else if (T === "vec3f") {
                    if (o + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                    const G = new Float32Array(this.buffer, o, 3);
                    I.push(G[$]);
                  } else if (T === "vec4f") I.push(new Float32Array(this.buffer, o, 4)[$]);
                  else if (T === "vec2i") P = "i", I.push(new Int32Array(this.buffer, o, 2)[$]);
                  else if (T === "vec3i") P = "i", I.push(new Int32Array(this.buffer, o, 3)[$]);
                  else if (T === "vec4i") P = "i", I.push(new Int32Array(this.buffer, o, 4)[$]);
                  else if (T === "vec2u") {
                    P = "u";
                    const G = new Uint32Array(this.buffer, o, 2);
                    I.push(G[$]);
                  } else T === "vec3u" ? (P = "u", I.push(new Uint32Array(this.buffer, o, 3)[$])) : T === "vec4u" && (P = "u", I.push(new Uint32Array(this.buffer, o, 4)[$]));
                }
                return I.length === 2 ? d = e.getTypeInfo(`vec2${P}`) : I.length === 3 ? d = e.getTypeInfo(`vec3${P}`) : I.length === 4 ? d = e.getTypeInfo(`vec4${P}`) : console.error(`GetDataValue: Invalid vector length ${I.length}`), new Ne(I, d, null);
              }
              return console.error(`GetDataValue: Unknown member ${y}`), null;
            }
            return console.error(`GetDataValue: Type ${T} is not a struct`), null;
          }
        }
      }
      t = t.postfix;
    }
    const m = d.getTypeName();
    return m === "f32" ? new ot(new Float32Array(this.buffer, o, 1), d, this) : m === "i32" ? new ot(new Int32Array(this.buffer, o, 1), d, this) : m === "u32" ? new ot(new Uint32Array(this.buffer, o, 1), d, this) : m === "vec2f" ? new Ne(new Float32Array(this.buffer, o, 2), d, this) : m === "vec3f" ? new Ne(new Float32Array(this.buffer, o, 3), d, this) : m === "vec4f" ? new Ne(new Float32Array(this.buffer, o, 4), d, this) : m === "vec2i" ? new Ne(new Int32Array(this.buffer, o, 2), d, this) : m === "vec3i" ? new Ne(new Int32Array(this.buffer, o, 3), d, this) : m === "vec4i" ? new Ne(new Int32Array(this.buffer, o, 4), d, this) : m === "vec2u" ? new Ne(new Uint32Array(this.buffer, o, 2), d, this) : m === "vec3u" ? new Ne(new Uint32Array(this.buffer, o, 3), d, this) : m === "vec4u" ? new Ne(new Uint32Array(this.buffer, o, 4), d, this) : d instanceof Kf && d.name === "atomic" ? ((n = d.format) === null || n === void 0 ? void 0 : n.name) === "u32" ? new ot(new Uint32Array(this.buffer, o, 1)[0], d.format, this) : ((s = d.format) === null || s === void 0 ? void 0 : s.name) === "i32" ? new ot(new Int32Array(this.buffer, o, 1)[0], d.format, this) : (console.error(`GetDataValue: Invalid atomic format ${(c = d.format) === null || c === void 0 ? void 0 : c.name}`), null) : new cs(this.buffer, d, o, this);
  }
  toString() {
    let e = "";
    if (this.typeInfo instanceof Gh)
      if (this.typeInfo.format.name === "f32") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let i = 1; i < t.length; ++i) e += `, ${t[i]}`;
      } else if (this.typeInfo.format.name === "i32") {
        const t = new Int32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let i = 1; i < t.length; ++i) e += `, ${t[i]}`;
      } else if (this.typeInfo.format.name === "u32") {
        const t = new Uint32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let i = 1; i < t.length; ++i) e += `, ${t[i]}`;
      } else if (this.typeInfo.format.name === "vec2f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}]`;
        for (let i = 1; i < t.length / 2; ++i) e += `, [${t[2 * i]}, ${t[2 * i + 1]}]`;
      } else if (this.typeInfo.format.name === "vec3f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}]`;
        for (let i = 4; i < t.length; i += 4) e += `, [${t[i]}, ${t[i + 1]}, ${t[i + 2]}]`;
      } else if (this.typeInfo.format.name === "vec4f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;
        for (let i = 4; i < t.length; i += 4) e += `, [${t[i]}, ${t[i + 1]}, ${t[i + 2]}, ${t[i + 3]}]`;
      } else e = "[...]";
    else this.typeInfo instanceof Uh ? e += "{...}" : e = "[...]";
    return e;
  }
}
class eh extends wu {
  constructor(e, t, i, n) {
    super(t, null), this.data = e, this.descriptor = i, this.view = n;
  }
  clone() {
    return new eh(this.data, this.typeInfo, this.descriptor, this.view);
  }
  get width() {
    var e, t;
    const i = this.descriptor.size;
    return i instanceof Array && i.length > 0 ? (e = i[0]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.width) !== null && t !== void 0 ? t : 0;
  }
  get height() {
    var e, t;
    const i = this.descriptor.size;
    return i instanceof Array && i.length > 1 ? (e = i[1]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.height) !== null && t !== void 0 ? t : 0;
  }
  get depthOrArrayLayers() {
    var e, t;
    const i = this.descriptor.size;
    return i instanceof Array && i.length > 2 ? (e = i[2]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.depthOrArrayLayers) !== null && t !== void 0 ? t : 0;
  }
  get format() {
    var e;
    return this.descriptor && (e = this.descriptor.format) !== null && e !== void 0 ? e : "rgba8unorm";
  }
  get sampleCount() {
    var e;
    return this.descriptor && (e = this.descriptor.sampleCount) !== null && e !== void 0 ? e : 1;
  }
  get mipLevelCount() {
    var e;
    return this.descriptor && (e = this.descriptor.mipLevelCount) !== null && e !== void 0 ? e : 1;
  }
  get dimension() {
    var e;
    return this.descriptor && (e = this.descriptor.dimension) !== null && e !== void 0 ? e : "2d";
  }
  getMipLevelSize(e) {
    if (e >= this.mipLevelCount) return [0, 0, 0];
    const t = [this.width, this.height, this.depthOrArrayLayers];
    for (let i = 0; i < t.length; ++i) t[i] = Math.max(1, t[i] >> e);
    return t;
  }
  get texelByteSize() {
    const e = this.format, t = xb[e];
    return t ? t.isDepthStencil ? 4 : t.bytesPerBlock : 0;
  }
  get bytesPerRow() {
    return this.width * this.texelByteSize;
  }
  get isDepthStencil() {
    const e = this.format, t = xb[e];
    return !!t && t.isDepthStencil;
  }
  getGpuSize() {
    const e = this.format, t = xb[e], i = this.width;
    if (!e || i <= 0 || !t) return -1;
    const n = this.height, s = this.depthOrArrayLayers, c = this.dimension;
    return i / t.blockWidth * (c === "1d" ? 1 : n / t.blockHeight) * t.bytesPerBlock * s;
  }
  getPixel(e, t, i = 0, n = 0) {
    const s = this.texelByteSize, c = this.bytesPerRow, o = this.height, d = this.data[n];
    return lN(new Uint8Array(d), e, t, i, n, o, c, s, this.format);
  }
  setPixel(e, t, i, n, s) {
    const c = this.texelByteSize, o = this.bytesPerRow, d = this.height, m = this.data[n];
    (function(y, T, P, I, D, k, $, G, te, Z) {
      const H = I * ($ >>= D) * (k >>= D) + P * $ + T * G;
      switch (te) {
        case "r8unorm":
          return void tn(y, H, "8unorm", 1, Z);
        case "r8snorm":
          return void tn(y, H, "8snorm", 1, Z);
        case "r8uint":
          return void tn(y, H, "8uint", 1, Z);
        case "r8sint":
          return void tn(y, H, "8sint", 1, Z);
        case "rg8unorm":
          return void tn(y, H, "8unorm", 2, Z);
        case "rg8snorm":
          return void tn(y, H, "8snorm", 2, Z);
        case "rg8uint":
          return void tn(y, H, "8uint", 2, Z);
        case "rg8sint":
          return void tn(y, H, "8sint", 2, Z);
        case "rgba8unorm-srgb":
        case "rgba8unorm":
        case "bgra8unorm-srgb":
        case "bgra8unorm":
          return void tn(y, H, "8unorm", 4, Z);
        case "rgba8snorm":
          return void tn(y, H, "8snorm", 4, Z);
        case "rgba8uint":
          return void tn(y, H, "8uint", 4, Z);
        case "rgba8sint":
          return void tn(y, H, "8sint", 4, Z);
        case "r16uint":
          return void tn(y, H, "16uint", 1, Z);
        case "r16sint":
          return void tn(y, H, "16sint", 1, Z);
        case "r16float":
          return void tn(y, H, "16float", 1, Z);
        case "rg16uint":
          return void tn(y, H, "16uint", 2, Z);
        case "rg16sint":
          return void tn(y, H, "16sint", 2, Z);
        case "rg16float":
          return void tn(y, H, "16float", 2, Z);
        case "rgba16uint":
          return void tn(y, H, "16uint", 4, Z);
        case "rgba16sint":
          return void tn(y, H, "16sint", 4, Z);
        case "rgba16float":
          return void tn(y, H, "16float", 4, Z);
        case "r32uint":
          return void tn(y, H, "32uint", 1, Z);
        case "r32sint":
          return void tn(y, H, "32sint", 1, Z);
        case "depth16unorm":
        case "depth24plus":
        case "depth24plus-stencil8":
        case "depth32float":
        case "depth32float-stencil8":
        case "r32float":
          return void tn(y, H, "32float", 1, Z);
        case "rg32uint":
          return void tn(y, H, "32uint", 2, Z);
        case "rg32sint":
          return void tn(y, H, "32sint", 2, Z);
        case "rg32float":
          return void tn(y, H, "32float", 2, Z);
        case "rgba32uint":
          return void tn(y, H, "32uint", 4, Z);
        case "rgba32sint":
          return void tn(y, H, "32sint", 4, Z);
        case "rgba32float":
          return void tn(y, H, "32float", 4, Z);
        case "rg11b10ufloat":
          console.error("TODO: rg11b10ufloat not supported for writing");
      }
    })(new Uint8Array(m), e, t, i, n, d, o, c, this.format, s);
  }
}
((r) => {
  r[r.token = 0] = "token", r[r.keyword = 1] = "keyword", r[r.reserved = 2] = "reserved";
})(lt || (lt = {}));
class ct {
  constructor(e, t, i) {
    this.name = e, this.type = t, this.rule = i;
  }
  toString() {
    return this.name;
  }
}
class Ce {
}
vt = Ce, Ce.none = new ct("", lt.reserved, ""), Ce.eof = new ct("EOF", lt.token, ""), Ce.reserved = {
  asm: new ct("asm", lt.reserved, "asm"),
  bf16: new ct("bf16", lt.reserved, "bf16"),
  do: new ct("do", lt.reserved, "do"),
  enum: new ct("enum", lt.reserved, "enum"),
  f16: new ct("f16", lt.reserved, "f16"),
  f64: new ct("f64", lt.reserved, "f64"),
  handle: new ct("handle", lt.reserved, "handle"),
  i8: new ct("i8", lt.reserved, "i8"),
  i16: new ct("i16", lt.reserved, "i16"),
  i64: new ct("i64", lt.reserved, "i64"),
  mat: new ct("mat", lt.reserved, "mat"),
  premerge: new ct("premerge", lt.reserved, "premerge"),
  regardless: new ct("regardless", lt.reserved, "regardless"),
  typedef: new ct("typedef", lt.reserved, "typedef"),
  u8: new ct("u8", lt.reserved, "u8"),
  u16: new ct("u16", lt.reserved, "u16"),
  u64: new ct("u64", lt.reserved, "u64"),
  unless: new ct("unless", lt.reserved, "unless"),
  using: new ct("using", lt.reserved, "using"),
  vec: new ct("vec", lt.reserved, "vec"),
  void: new ct("void", lt.reserved, "void")
}, Ce.keywords = {
  array: new ct("array", lt.keyword, "array"),
  atomic: new ct("atomic", lt.keyword, "atomic"),
  bool: new ct("bool", lt.keyword, "bool"),
  f32: new ct("f32", lt.keyword, "f32"),
  i32: new ct("i32", lt.keyword, "i32"),
  mat2x2: new ct("mat2x2", lt.keyword, "mat2x2"),
  mat2x3: new ct("mat2x3", lt.keyword, "mat2x3"),
  mat2x4: new ct("mat2x4", lt.keyword, "mat2x4"),
  mat3x2: new ct("mat3x2", lt.keyword, "mat3x2"),
  mat3x3: new ct("mat3x3", lt.keyword, "mat3x3"),
  mat3x4: new ct("mat3x4", lt.keyword, "mat3x4"),
  mat4x2: new ct("mat4x2", lt.keyword, "mat4x2"),
  mat4x3: new ct("mat4x3", lt.keyword, "mat4x3"),
  mat4x4: new ct("mat4x4", lt.keyword, "mat4x4"),
  ptr: new ct("ptr", lt.keyword, "ptr"),
  sampler: new ct("sampler", lt.keyword, "sampler"),
  sampler_comparison: new ct("sampler_comparison", lt.keyword, "sampler_comparison"),
  struct: new ct("struct", lt.keyword, "struct"),
  texture_1d: new ct("texture_1d", lt.keyword, "texture_1d"),
  texture_2d: new ct("texture_2d", lt.keyword, "texture_2d"),
  texture_2d_array: new ct("texture_2d_array", lt.keyword, "texture_2d_array"),
  texture_3d: new ct("texture_3d", lt.keyword, "texture_3d"),
  texture_cube: new ct("texture_cube", lt.keyword, "texture_cube"),
  texture_cube_array: new ct("texture_cube_array", lt.keyword, "texture_cube_array"),
  texture_multisampled_2d: new ct("texture_multisampled_2d", lt.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new ct("texture_storage_1d", lt.keyword, "texture_storage_1d"),
  texture_storage_2d: new ct("texture_storage_2d", lt.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new ct("texture_storage_2d_array", lt.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new ct("texture_storage_3d", lt.keyword, "texture_storage_3d"),
  texture_depth_2d: new ct("texture_depth_2d", lt.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new ct("texture_depth_2d_array", lt.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new ct("texture_depth_cube", lt.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new ct("texture_depth_cube_array", lt.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new ct("texture_depth_multisampled_2d", lt.keyword, "texture_depth_multisampled_2d"),
  texture_external: new ct("texture_external", lt.keyword, "texture_external"),
  u32: new ct("u32", lt.keyword, "u32"),
  vec2: new ct("vec2", lt.keyword, "vec2"),
  vec3: new ct("vec3", lt.keyword, "vec3"),
  vec4: new ct("vec4", lt.keyword, "vec4"),
  bitcast: new ct("bitcast", lt.keyword, "bitcast"),
  block: new ct("block", lt.keyword, "block"),
  break: new ct("break", lt.keyword, "break"),
  case: new ct("case", lt.keyword, "case"),
  continue: new ct("continue", lt.keyword, "continue"),
  continuing: new ct("continuing", lt.keyword, "continuing"),
  default: new ct("default", lt.keyword, "default"),
  diagnostic: new ct("diagnostic", lt.keyword, "diagnostic"),
  discard: new ct("discard", lt.keyword, "discard"),
  else: new ct("else", lt.keyword, "else"),
  enable: new ct("enable", lt.keyword, "enable"),
  fallthrough: new ct("fallthrough", lt.keyword, "fallthrough"),
  false: new ct("false", lt.keyword, "false"),
  fn: new ct("fn", lt.keyword, "fn"),
  for: new ct("for", lt.keyword, "for"),
  function: new ct("function", lt.keyword, "function"),
  if: new ct("if", lt.keyword, "if"),
  let: new ct("let", lt.keyword, "let"),
  const: new ct("const", lt.keyword, "const"),
  loop: new ct("loop", lt.keyword, "loop"),
  while: new ct("while", lt.keyword, "while"),
  private: new ct("private", lt.keyword, "private"),
  read: new ct("read", lt.keyword, "read"),
  read_write: new ct("read_write", lt.keyword, "read_write"),
  return: new ct("return", lt.keyword, "return"),
  requires: new ct("requires", lt.keyword, "requires"),
  storage: new ct("storage", lt.keyword, "storage"),
  switch: new ct("switch", lt.keyword, "switch"),
  true: new ct("true", lt.keyword, "true"),
  alias: new ct("alias", lt.keyword, "alias"),
  type: new ct("type", lt.keyword, "type"),
  uniform: new ct("uniform", lt.keyword, "uniform"),
  var: new ct("var", lt.keyword, "var"),
  override: new ct("override", lt.keyword, "override"),
  workgroup: new ct("workgroup", lt.keyword, "workgroup"),
  write: new ct("write", lt.keyword, "write"),
  r8unorm: new ct("r8unorm", lt.keyword, "r8unorm"),
  r8snorm: new ct("r8snorm", lt.keyword, "r8snorm"),
  r8uint: new ct("r8uint", lt.keyword, "r8uint"),
  r8sint: new ct("r8sint", lt.keyword, "r8sint"),
  r16uint: new ct("r16uint", lt.keyword, "r16uint"),
  r16sint: new ct("r16sint", lt.keyword, "r16sint"),
  r16float: new ct("r16float", lt.keyword, "r16float"),
  rg8unorm: new ct("rg8unorm", lt.keyword, "rg8unorm"),
  rg8snorm: new ct("rg8snorm", lt.keyword, "rg8snorm"),
  rg8uint: new ct("rg8uint", lt.keyword, "rg8uint"),
  rg8sint: new ct("rg8sint", lt.keyword, "rg8sint"),
  r32uint: new ct("r32uint", lt.keyword, "r32uint"),
  r32sint: new ct("r32sint", lt.keyword, "r32sint"),
  r32float: new ct("r32float", lt.keyword, "r32float"),
  rg16uint: new ct("rg16uint", lt.keyword, "rg16uint"),
  rg16sint: new ct("rg16sint", lt.keyword, "rg16sint"),
  rg16float: new ct("rg16float", lt.keyword, "rg16float"),
  rgba8unorm: new ct("rgba8unorm", lt.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new ct("rgba8unorm_srgb", lt.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new ct("rgba8snorm", lt.keyword, "rgba8snorm"),
  rgba8uint: new ct("rgba8uint", lt.keyword, "rgba8uint"),
  rgba8sint: new ct("rgba8sint", lt.keyword, "rgba8sint"),
  bgra8unorm: new ct("bgra8unorm", lt.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new ct("bgra8unorm_srgb", lt.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new ct("rgb10a2unorm", lt.keyword, "rgb10a2unorm"),
  rg11b10float: new ct("rg11b10float", lt.keyword, "rg11b10float"),
  rg32uint: new ct("rg32uint", lt.keyword, "rg32uint"),
  rg32sint: new ct("rg32sint", lt.keyword, "rg32sint"),
  rg32float: new ct("rg32float", lt.keyword, "rg32float"),
  rgba16uint: new ct("rgba16uint", lt.keyword, "rgba16uint"),
  rgba16sint: new ct("rgba16sint", lt.keyword, "rgba16sint"),
  rgba16float: new ct("rgba16float", lt.keyword, "rgba16float"),
  rgba32uint: new ct("rgba32uint", lt.keyword, "rgba32uint"),
  rgba32sint: new ct("rgba32sint", lt.keyword, "rgba32sint"),
  rgba32float: new ct("rgba32float", lt.keyword, "rgba32float"),
  static_assert: new ct("static_assert", lt.keyword, "static_assert")
}, Ce.tokens = {
  decimal_float_literal: new ct("decimal_float_literal", lt.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),
  hex_float_literal: new ct("hex_float_literal", lt.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),
  int_literal: new ct("int_literal", lt.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
  uint_literal: new ct("uint_literal", lt.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  name: new ct("name", lt.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),
  ident: new ct("ident", lt.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  and: new ct("and", lt.token, "&"),
  and_and: new ct("and_and", lt.token, "&&"),
  arrow: new ct("arrow ", lt.token, "->"),
  attr: new ct("attr", lt.token, "@"),
  forward_slash: new ct("forward_slash", lt.token, "/"),
  bang: new ct("bang", lt.token, "!"),
  bracket_left: new ct("bracket_left", lt.token, "["),
  bracket_right: new ct("bracket_right", lt.token, "]"),
  brace_left: new ct("brace_left", lt.token, "{"),
  brace_right: new ct("brace_right", lt.token, "}"),
  colon: new ct("colon", lt.token, ":"),
  comma: new ct("comma", lt.token, ","),
  equal: new ct("equal", lt.token, "="),
  equal_equal: new ct("equal_equal", lt.token, "=="),
  not_equal: new ct("not_equal", lt.token, "!="),
  greater_than: new ct("greater_than", lt.token, ">"),
  greater_than_equal: new ct("greater_than_equal", lt.token, ">="),
  shift_right: new ct("shift_right", lt.token, ">>"),
  less_than: new ct("less_than", lt.token, "<"),
  less_than_equal: new ct("less_than_equal", lt.token, "<="),
  shift_left: new ct("shift_left", lt.token, "<<"),
  modulo: new ct("modulo", lt.token, "%"),
  minus: new ct("minus", lt.token, "-"),
  minus_minus: new ct("minus_minus", lt.token, "--"),
  period: new ct("period", lt.token, "."),
  plus: new ct("plus", lt.token, "+"),
  plus_plus: new ct("plus_plus", lt.token, "++"),
  or: new ct("or", lt.token, "|"),
  or_or: new ct("or_or", lt.token, "||"),
  paren_left: new ct("paren_left", lt.token, "("),
  paren_right: new ct("paren_right", lt.token, ")"),
  semicolon: new ct("semicolon", lt.token, ";"),
  star: new ct("star", lt.token, "*"),
  tilde: new ct("tilde", lt.token, "~"),
  underscore: new ct("underscore", lt.token, "_"),
  xor: new ct("xor", lt.token, "^"),
  plus_equal: new ct("plus_equal", lt.token, "+="),
  minus_equal: new ct("minus_equal", lt.token, "-="),
  times_equal: new ct("times_equal", lt.token, "*="),
  division_equal: new ct("division_equal", lt.token, "/="),
  modulo_equal: new ct("modulo_equal", lt.token, "%="),
  and_equal: new ct("and_equal", lt.token, "&="),
  or_equal: new ct("or_equal", lt.token, "|="),
  xor_equal: new ct("xor_equal", lt.token, "^="),
  shift_right_equal: new ct("shift_right_equal", lt.token, ">>="),
  shift_left_equal: new ct("shift_left_equal", lt.token, "<<=")
}, Ce.simpleTokens = {
  "@": vt.tokens.attr,
  "{": vt.tokens.brace_left,
  "}": vt.tokens.brace_right,
  ":": vt.tokens.colon,
  ",": vt.tokens.comma,
  "(": vt.tokens.paren_left,
  ")": vt.tokens.paren_right,
  ";": vt.tokens.semicolon
}, Ce.literalTokens = {
  "&": vt.tokens.and,
  "&&": vt.tokens.and_and,
  "->": vt.tokens.arrow,
  "/": vt.tokens.forward_slash,
  "!": vt.tokens.bang,
  "[": vt.tokens.bracket_left,
  "]": vt.tokens.bracket_right,
  "=": vt.tokens.equal,
  "==": vt.tokens.equal_equal,
  "!=": vt.tokens.not_equal,
  ">": vt.tokens.greater_than,
  ">=": vt.tokens.greater_than_equal,
  ">>": vt.tokens.shift_right,
  "<": vt.tokens.less_than,
  "<=": vt.tokens.less_than_equal,
  "<<": vt.tokens.shift_left,
  "%": vt.tokens.modulo,
  "-": vt.tokens.minus,
  "--": vt.tokens.minus_minus,
  ".": vt.tokens.period,
  "+": vt.tokens.plus,
  "++": vt.tokens.plus_plus,
  "|": vt.tokens.or,
  "||": vt.tokens.or_or,
  "*": vt.tokens.star,
  "~": vt.tokens.tilde,
  _: vt.tokens.underscore,
  "^": vt.tokens.xor,
  "+=": vt.tokens.plus_equal,
  "-=": vt.tokens.minus_equal,
  "*=": vt.tokens.times_equal,
  "/=": vt.tokens.division_equal,
  "%=": vt.tokens.modulo_equal,
  "&=": vt.tokens.and_equal,
  "|=": vt.tokens.or_equal,
  "^=": vt.tokens.xor_equal,
  ">>=": vt.tokens.shift_right_equal,
  "<<=": vt.tokens.shift_left_equal
}, Ce.regexTokens = {
  decimal_float_literal: vt.tokens.decimal_float_literal,
  hex_float_literal: vt.tokens.hex_float_literal,
  int_literal: vt.tokens.int_literal,
  uint_literal: vt.tokens.uint_literal,
  ident: vt.tokens.ident
}, Ce.storage_class = [vt.keywords.function, vt.keywords.private, vt.keywords.workgroup, vt.keywords.uniform, vt.keywords.storage], Ce.access_mode = [vt.keywords.read, vt.keywords.write, vt.keywords.read_write], Ce.sampler_type = [vt.keywords.sampler, vt.keywords.sampler_comparison], Ce.sampled_texture_type = [vt.keywords.texture_1d, vt.keywords.texture_2d, vt.keywords.texture_2d_array, vt.keywords.texture_3d, vt.keywords.texture_cube, vt.keywords.texture_cube_array], Ce.multisampled_texture_type = [vt.keywords.texture_multisampled_2d], Ce.storage_texture_type = [vt.keywords.texture_storage_1d, vt.keywords.texture_storage_2d, vt.keywords.texture_storage_2d_array, vt.keywords.texture_storage_3d], Ce.depth_texture_type = [vt.keywords.texture_depth_2d, vt.keywords.texture_depth_2d_array, vt.keywords.texture_depth_cube, vt.keywords.texture_depth_cube_array, vt.keywords.texture_depth_multisampled_2d], Ce.texture_external_type = [vt.keywords.texture_external], Ce.any_texture_type = [...vt.sampled_texture_type, ...vt.multisampled_texture_type, ...vt.storage_texture_type, ...vt.depth_texture_type, ...vt.texture_external_type], Ce.texel_format = [vt.keywords.r8unorm, vt.keywords.r8snorm, vt.keywords.r8uint, vt.keywords.r8sint, vt.keywords.r16uint, vt.keywords.r16sint, vt.keywords.r16float, vt.keywords.rg8unorm, vt.keywords.rg8snorm, vt.keywords.rg8uint, vt.keywords.rg8sint, vt.keywords.r32uint, vt.keywords.r32sint, vt.keywords.r32float, vt.keywords.rg16uint, vt.keywords.rg16sint, vt.keywords.rg16float, vt.keywords.rgba8unorm, vt.keywords.rgba8unorm_srgb, vt.keywords.rgba8snorm, vt.keywords.rgba8uint, vt.keywords.rgba8sint, vt.keywords.bgra8unorm, vt.keywords.bgra8unorm_srgb, vt.keywords.rgb10a2unorm, vt.keywords.rg11b10float, vt.keywords.rg32uint, vt.keywords.rg32sint, vt.keywords.rg32float, vt.keywords.rgba16uint, vt.keywords.rgba16sint, vt.keywords.rgba16float, vt.keywords.rgba32uint, vt.keywords.rgba32sint, vt.keywords.rgba32float], Ce.const_literal = [vt.tokens.int_literal, vt.tokens.uint_literal, vt.tokens.decimal_float_literal, vt.tokens.hex_float_literal, vt.keywords.true, vt.keywords.false], Ce.literal_or_ident = [vt.tokens.ident, vt.tokens.int_literal, vt.tokens.uint_literal, vt.tokens.decimal_float_literal, vt.tokens.hex_float_literal, vt.tokens.name], Ce.element_count_expression = [vt.tokens.int_literal, vt.tokens.uint_literal, vt.tokens.ident], Ce.template_types = [vt.keywords.vec2, vt.keywords.vec3, vt.keywords.vec4, vt.keywords.mat2x2, vt.keywords.mat2x3, vt.keywords.mat2x4, vt.keywords.mat3x2, vt.keywords.mat3x3, vt.keywords.mat3x4, vt.keywords.mat4x2, vt.keywords.mat4x3, vt.keywords.mat4x4, vt.keywords.atomic, vt.keywords.bitcast, ...vt.any_texture_type], Ce.attribute_name = [vt.tokens.ident, vt.keywords.block, vt.keywords.diagnostic], Ce.assignment_operators = [vt.tokens.equal, vt.tokens.plus_equal, vt.tokens.minus_equal, vt.tokens.times_equal, vt.tokens.division_equal, vt.tokens.modulo_equal, vt.tokens.and_equal, vt.tokens.or_equal, vt.tokens.xor_equal, vt.tokens.shift_right_equal, vt.tokens.shift_left_equal], Ce.increment_operators = [vt.tokens.plus_plus, vt.tokens.minus_minus];
class kT {
  constructor(e, t, i, n, s) {
    this.type = e, this.lexeme = t, this.line = i, this.start = n, this.end = s;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return Ce.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == Ce.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
let gN = class {
  constructor(e) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
  }
  scanTokens() {
    for (; !this._isAtEnd(); ) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new kT(Ce.eof, "", this._line, this._current, this._current)), this._tokens;
  }
  scanToken() {
    let e = this._advance();
    if (e == `
`) return this._line++, !0;
    if (this._isWhitespace(e)) return !0;
    if (e == "/") {
      if (this._peekAhead() == "/") {
        for (; e != `
`; ) {
          if (this._isAtEnd()) return !0;
          e = this._advance();
        }
        return this._line++, !0;
      }
      if (this._peekAhead() == "*") {
        this._advance();
        let c = 1;
        for (; c > 0; ) {
          if (this._isAtEnd()) return !0;
          if (e = this._advance(), e == `
`) this._line++;
          else if (e == "*") {
            if (this._peekAhead() == "/" && (this._advance(), c--, c == 0)) return !0;
          } else e == "/" && this._peekAhead() == "*" && (this._advance(), c++);
        }
        return !0;
      }
    }
    const t = Ce.simpleTokens[e];
    if (t) return this._addToken(t), !0;
    let i = Ce.none;
    const n = this._isAlpha(e), s = e === "_";
    if (this._isAlphaNumeric(e)) {
      let c = this._peekAhead();
      for (; this._isAlphaNumeric(c); ) e += this._advance(), c = this._peekAhead();
    }
    if (n) {
      const c = Ce.keywords[e];
      if (c) return this._addToken(c), !0;
    }
    if (n || s) return this._addToken(Ce.tokens.ident), !0;
    for (; ; ) {
      let c = this._findType(e);
      const o = this._peekAhead();
      if (e == "-" && this._tokens.length > 0) {
        if (o == "=") return this._current++, e += o, this._addToken(Ce.tokens.minus_equal), !0;
        if (o == "-") return this._current++, e += o, this._addToken(Ce.tokens.minus_minus), !0;
        const d = this._tokens.length - 1;
        if ((Ce.literal_or_ident.indexOf(this._tokens[d].type) != -1 || this._tokens[d].type == Ce.tokens.paren_right) && o != ">") return this._addToken(c), !0;
      }
      if (e == ">" && (o == ">" || o == "=")) {
        let d = !1, m = this._tokens.length - 1;
        for (let y = 0; y < 5 && m >= 0 && Ce.assignment_operators.indexOf(this._tokens[m].type) === -1; ++y, --m) if (this._tokens[m].type === Ce.tokens.less_than) {
          m > 0 && this._tokens[m - 1].isArrayOrTemplateType() && (d = !0);
          break;
        }
        if (d) return this._addToken(c), !0;
      }
      if (c === Ce.none) {
        let d = e, m = 0;
        const y = 2;
        for (let T = 0; T < y; ++T) if (d += this._peekAhead(T), c = this._findType(d), c !== Ce.none) {
          m = T;
          break;
        }
        if (c === Ce.none) return i !== Ce.none && (this._current--, this._addToken(i), !0);
        e = d, this._current += m + 1;
      }
      if (i = c, this._isAtEnd()) break;
      e += this._advance();
    }
    return i !== Ce.none && (this._addToken(i), !0);
  }
  _findType(e) {
    for (const i in Ce.regexTokens) {
      const n = Ce.regexTokens[i];
      if (this._match(e, n.rule)) return n;
    }
    return Ce.literalTokens[e] || Ce.none;
  }
  _match(e, t) {
    const i = t.exec(e);
    return i && i.index == 0 && i[0] == e;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e) {
    return !this._isNumeric(e) && !this._isWhitespace(e) && e !== "_" && e !== "." && e !== "(" && e !== ")" && e !== "[" && e !== "]" && e !== "{" && e !== "}" && e !== "," && e !== ";" && e !== ":" && e !== "=" && e !== "!" && e !== "<" && e !== ">" && e !== "+" && e !== "-" && e !== "*" && e !== "/" && e !== "%" && e !== "&" && e !== "|" && e !== "^" && e !== "~" && e !== "@" && e !== "#" && e !== "?" && e !== "'" && e !== "`" && e !== '"' && e !== "\\" && e !== `
` && e !== "\r" && e !== "	" && e !== "\0";
  }
  _isNumeric(e) {
    return e >= "0" && e <= "9";
  }
  _isAlphaNumeric(e) {
    return this._isAlpha(e) || this._isNumeric(e) || e === "_";
  }
  _isWhitespace(e) {
    return e == " " || e == "	" || e == "\r";
  }
  _advance(e = 0) {
    let t = this._source[this._current];
    return e = e || 0, e++, this._current += e, t;
  }
  _peekAhead(e = 0) {
    return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
  }
  _addToken(e) {
    const t = this._source.substring(this._start, this._current);
    this._tokens.push(new kT(e, t, this._line, this._start, this._current));
  }
};
function gr(r) {
  return Array.isArray(r) || r?.buffer instanceof ArrayBuffer;
}
const Sy = new Float32Array(1), mN = new Uint32Array(Sy.buffer), _N = new Uint32Array(Sy.buffer), Ey = new Int32Array(1), yN = new Float32Array(Ey.buffer), bN = new Uint32Array(Ey.buffer), Cy = new Uint32Array(1), vN = new Float32Array(Cy.buffer), xN = new Int32Array(Cy.buffer);
function OT(r, e, t) {
  if (e === t) return r;
  if (e === "f32") {
    if (t === "i32" || t === "x32") return Sy[0] = r, mN[0];
    if (t === "u32") return Sy[0] = r, _N[0];
  } else if (e === "i32" || e === "x32") {
    if (t === "f32") return Ey[0] = r, yN[0];
    if (t === "u32") return Ey[0] = r, bN[0];
  } else if (e === "u32") {
    if (t === "f32") return Cy[0] = r, vN[0];
    if (t === "i32" || t === "x32") return Cy[0] = r, xN[0];
  }
  return console.error(`Unsupported cast from ${e} to ${t}`), r;
}
class wN {
  constructor(e) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = e;
  }
}
class Qm {
  constructor(e, t) {
    this.align = e, this.size = t;
  }
}
class bu {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new nN(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(e) {
    return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
  }
  updateAST(e) {
    for (const t of e) t instanceof Wg && this._functions.set(t.name, new wN(t));
    for (const t of e) if (t instanceof Qu) {
      const i = this.getTypeInfo(t, null);
      i instanceof Uh && this.structs.push(i);
    }
    for (const t of e) if (t instanceof V2) this.aliases.push(this._getAliasInfo(t));
    else {
      if (t instanceof z2) {
        const i = t, n = this._getAttributeNum(i.attributes, "id", 0), s = i.type != null ? this.getTypeInfo(i.type, i.attributes) : null;
        this.overrides.push(new tN(i.name, s, i.attributes, n));
        continue;
      }
      if (this._isUniformVar(t)) {
        const i = t, n = this._getAttributeNum(i.attributes, "group", 0), s = this._getAttributeNum(i.attributes, "binding", 0), c = this.getTypeInfo(i.type, i.attributes), o = new Km(i.name, c, n, s, i.attributes, Nh.Uniform, i.access);
        o.access || (o.access = "read"), this.uniforms.push(o);
        continue;
      }
      if (this._isStorageVar(t)) {
        const i = t, n = this._getAttributeNum(i.attributes, "group", 0), s = this._getAttributeNum(i.attributes, "binding", 0), c = this.getTypeInfo(i.type, i.attributes), o = this._isStorageTexture(c), d = new Km(i.name, c, n, s, i.attributes, o ? Nh.StorageTexture : Nh.Storage, i.access);
        d.access || (d.access = "read"), this.storage.push(d);
        continue;
      }
      if (this._isTextureVar(t)) {
        const i = t, n = this._getAttributeNum(i.attributes, "group", 0), s = this._getAttributeNum(i.attributes, "binding", 0), c = this.getTypeInfo(i.type, i.attributes), o = this._isStorageTexture(c), d = new Km(i.name, c, n, s, i.attributes, o ? Nh.StorageTexture : Nh.Texture, i.access);
        d.access || (d.access = "read"), o ? this.storage.push(d) : this.textures.push(d);
        continue;
      }
      if (this._isSamplerVar(t)) {
        const i = t, n = this._getAttributeNum(i.attributes, "group", 0), s = this._getAttributeNum(i.attributes, "binding", 0), c = this.getTypeInfo(i.type, i.attributes), o = new Km(i.name, c, n, s, i.attributes, Nh.Sampler, i.access);
        this.samplers.push(o);
        continue;
      }
    }
    for (const t of e) if (t instanceof Wg) {
      const i = this._getAttribute(t, "vertex"), n = this._getAttribute(t, "fragment"), s = this._getAttribute(t, "compute"), c = i || n || s, o = new iN(t.name, c?.name, t.attributes);
      o.attributes = t.attributes, o.startLine = t.startLine, o.endLine = t.endLine, this.functions.push(o), this._functions.get(t.name).info = o, c && (this._functions.get(t.name).inUse = !0, o.inUse = !0, o.resources = this._findResources(t, !!c), o.inputs = this._getInputs(t.args), o.outputs = this._getOutputs(t.returnType), this.entry[c.name].push(o)), o.arguments = t.args.map((d) => new rN(d.name, this.getTypeInfo(d.type, d.attributes), d.attributes)), o.returnType = t.returnType ? this.getTypeInfo(t.returnType, t.attributes) : null;
      continue;
    }
    for (const t of this._functions.values()) t.info && (t.info.inUse = t.inUse, this._addCalls(t.node, t.info.calls));
    for (const t of this._functions.values()) t.node.search((i) => {
      var n, s, c;
      if (i instanceof TI) {
        if (i.value) if (gr(i.value)) for (const o of i.value) for (const d of this.overrides) o === d.name && ((n = t.info) === null || n === void 0 || n.overrides.push(d));
        else for (const o of this.overrides) i.value === o.name && ((s = t.info) === null || s === void 0 || s.overrides.push(o));
      } else if (i instanceof il) for (const o of this.overrides) i.name === o.name && ((c = t.info) === null || c === void 0 || c.overrides.push(o));
    });
    for (const t of this.uniforms) this._markStructsInUse(t.type);
    for (const t of this.storage) this._markStructsInUse(t.type);
  }
  getFunctionInfo(e) {
    for (const t of this.functions) if (t.name == e) return t;
    return null;
  }
  getStructInfo(e) {
    for (const t of this.structs) if (t.name == e) return t;
    return null;
  }
  getOverrideInfo(e) {
    for (const t of this.overrides) if (t.name == e) return t;
    return null;
  }
  _markStructsInUse(e) {
    if (e) if (e.isStruct) {
      if (e.inUse = !0, e.members) for (const t of e.members) this._markStructsInUse(t.type);
    } else if (e.isArray) this._markStructsInUse(e.format);
    else if (e.isTemplate) e.format && this._markStructsInUse(e.format);
    else {
      const t = this._getAlias(e.name);
      t && this._markStructsInUse(t);
    }
  }
  _addCalls(e, t) {
    var i;
    for (const n of e.calls) {
      const s = (i = this._functions.get(n.name)) === null || i === void 0 ? void 0 : i.info;
      s && t.add(s);
    }
  }
  findResource(e, t, i) {
    if (i) {
      for (const n of this.entry.compute) if (n.name === i) {
        for (const s of n.resources) if (s.group == e && s.binding == t) return s;
      }
      for (const n of this.entry.vertex) if (n.name === i) {
        for (const s of n.resources) if (s.group == e && s.binding == t) return s;
      }
      for (const n of this.entry.fragment) if (n.name === i) {
        for (const s of n.resources) if (s.group == e && s.binding == t) return s;
      }
    }
    for (const n of this.uniforms) if (n.group == e && n.binding == t) return n;
    for (const n of this.storage) if (n.group == e && n.binding == t) return n;
    for (const n of this.textures) if (n.group == e && n.binding == t) return n;
    for (const n of this.samplers) if (n.group == e && n.binding == t) return n;
    return null;
  }
  _findResource(e) {
    for (const t of this.uniforms) if (t.name == e) return t;
    for (const t of this.storage) if (t.name == e) return t;
    for (const t of this.textures) if (t.name == e) return t;
    for (const t of this.samplers) if (t.name == e) return t;
    return null;
  }
  _markStructsFromAST(e) {
    const t = this.getTypeInfo(e, null);
    this._markStructsInUse(t);
  }
  _findResources(e, t) {
    const i = [], n = this, s = [];
    return e.search((c) => {
      if (c instanceof Ay) s.push({});
      else if (c instanceof Ty) s.pop();
      else if (c instanceof rh) {
        const o = c;
        t && o.type !== null && this._markStructsFromAST(o.type), s.length > 0 && (s[s.length - 1][o.name] = o);
      } else if (c instanceof pu) {
        const o = c;
        t && o.type !== null && this._markStructsFromAST(o.type);
      } else if (c instanceof Bg) {
        const o = c;
        t && o.type !== null && this._markStructsFromAST(o.type), s.length > 0 && (s[s.length - 1][o.name] = o);
      } else if (c instanceof il) {
        const o = c;
        if (s.length > 0 && s[s.length - 1][o.name])
          return;
        const d = n._findResource(o.name);
        d && i.push(d);
      } else if (c instanceof G2) {
        const o = c, d = n._functions.get(o.name);
        d && (t && (d.inUse = !0), e.calls.add(d.node), d.resources === null && (d.resources = n._findResources(d.node, t)), i.push(...d.resources));
      } else if (c instanceof j2) {
        const o = c, d = n._functions.get(o.name);
        d && (t && (d.inUse = !0), e.calls.add(d.node), d.resources === null && (d.resources = n._findResources(d.node, t)), i.push(...d.resources));
      }
    }), [...new Map(i.map((c) => [c.name, c])).values()];
  }
  getBindGroups() {
    const e = [];
    function t(i, n) {
      i >= e.length && (e.length = i + 1), e[i] === void 0 && (e[i] = []), n >= e[i].length && (e[i].length = n + 1);
    }
    for (const i of this.uniforms)
      t(i.group, i.binding), e[i.group][i.binding] = i;
    for (const i of this.storage)
      t(i.group, i.binding), e[i.group][i.binding] = i;
    for (const i of this.textures)
      t(i.group, i.binding), e[i.group][i.binding] = i;
    for (const i of this.samplers)
      t(i.group, i.binding), e[i.group][i.binding] = i;
    return e;
  }
  _getOutputs(e, t = void 0) {
    if (t === void 0 && (t = []), e instanceof Qu) this._getStructOutputs(e, t);
    else {
      const i = this._getOutputInfo(e);
      i !== null && t.push(i);
    }
    return t;
  }
  _getStructOutputs(e, t) {
    for (const i of e.members) if (i.type instanceof Qu) this._getStructOutputs(i.type, t);
    else {
      const n = this._getAttribute(i, "location") || this._getAttribute(i, "builtin");
      if (n !== null) {
        const s = this.getTypeInfo(i.type, i.type.attributes), c = this._parseInt(n.value), o = new PT(i.name, s, n.name, c);
        t.push(o);
      }
    }
  }
  _getOutputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const i = this.getTypeInfo(e, e.attributes), n = this._parseInt(t.value);
      return new PT("", i, t.name, n);
    }
    return null;
  }
  _getInputs(e, t = void 0) {
    t === void 0 && (t = []);
    for (const i of e) if (i.type instanceof Qu) this._getStructInputs(i.type, t);
    else {
      const n = this._getInputInfo(i);
      n !== null && t.push(n);
    }
    return t;
  }
  _getStructInputs(e, t) {
    for (const i of e.members) if (i.type instanceof Qu) this._getStructInputs(i.type, t);
    else {
      const n = this._getInputInfo(i);
      n !== null && t.push(n);
    }
  }
  _getInputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const i = this._getAttribute(e, "interpolation"), n = this.getTypeInfo(e.type, e.attributes), s = this._parseInt(t.value), c = new eN(e.name, n, t.name, s);
      return i !== null && (c.interpolation = this._parseString(i.value)), c;
    }
    return null;
  }
  _parseString(e) {
    return e instanceof Array && (e = e[0]), e;
  }
  _parseInt(e) {
    e instanceof Array && (e = e[0]);
    const t = parseInt(e);
    return isNaN(t) ? e : t;
  }
  _getAlias(e) {
    for (const t of this.aliases) if (t.name == e) return t.type;
    return null;
  }
  _getAliasInfo(e) {
    return new QD(e.name, this.getTypeInfo(e.type, null));
  }
  getTypeInfoByName(e) {
    for (const t of this.structs) if (t.name == e) return t;
    for (const t of this.aliases) if (t.name == e) return t.type;
    return null;
  }
  getTypeInfo(e, t = null) {
    if (this._types.has(e)) return this._types.get(e);
    if (e instanceof V_) {
      const n = e.type ? this.getTypeInfo(e.type, e.attributes) : null, s = new hv(e.name, n, t);
      return this._types.set(e, s), this._updateTypeInfo(s), s;
    }
    if (e instanceof kg) {
      const n = e, s = n.format ? this.getTypeInfo(n.format, n.attributes) : null, c = new Gh(n.name, t);
      return c.format = s, c.count = n.count, this._types.set(e, c), this._updateTypeInfo(c), c;
    }
    if (e instanceof Qu) {
      const n = e, s = new Uh(n.name, t);
      s.startLine = n.startLine, s.endLine = n.endLine;
      for (const c of n.members) {
        const o = this.getTypeInfo(c.type, c.attributes);
        s.members.push(new IT(c.name, o, c.attributes));
      }
      return this._types.set(e, s), this._updateTypeInfo(s), s;
    }
    if (e instanceof Ag) {
      const n = e, s = n.format instanceof $t, c = n.format ? s ? this.getTypeInfo(n.format, null) : new Dl(n.format, null) : null, o = new Kf(n.name, c, t, n.access);
      return this._types.set(e, o), this._updateTypeInfo(o), o;
    }
    if (e instanceof pt) {
      const n = e, s = n.format ? this.getTypeInfo(n.format, null) : null, c = new Kf(n.name, s, t, n.access);
      return this._types.set(e, c), this._updateTypeInfo(c), c;
    }
    const i = new Dl(e.name, t);
    return this._types.set(e, i), this._updateTypeInfo(i), i;
  }
  _updateTypeInfo(e) {
    var t, i, n;
    const s = this._getTypeSize(e);
    if (e.size = (t = s?.size) !== null && t !== void 0 ? t : 0, e instanceof Gh && e.format) {
      const c = this._getTypeSize(e.format);
      e.stride = Math.max((i = c?.size) !== null && i !== void 0 ? i : 0, (n = c?.align) !== null && n !== void 0 ? n : 0), this._updateTypeInfo(e.format);
    }
    e instanceof hv && this._updateTypeInfo(e.format), e instanceof Uh && this._updateStructInfo(e);
  }
  _updateStructInfo(e) {
    var t;
    let i = 0, n = 0, s = 0, c = 0;
    for (let o = 0, d = e.members.length; o < d; ++o) {
      const m = e.members[o], y = this._getTypeSize(m);
      if (!y) continue;
      (t = this._getAlias(m.type.name)) !== null && t !== void 0 || m.type;
      const T = y.align, P = y.size;
      i = this._roundUp(T, i + n), n = P, s = i, c = Math.max(c, T), m.offset = i, m.size = P, this._updateTypeInfo(m.type);
    }
    e.size = this._roundUp(c, s + n), e.align = c;
  }
  _getTypeSize(e) {
    var t, i;
    if (e == null) return null;
    const n = this._getAttributeNum(e.attributes, "size", 0), s = this._getAttributeNum(e.attributes, "align", 0);
    if (e instanceof IT && (e = e.type), e instanceof Dl) {
      const c = this._getAlias(e.name);
      c !== null && (e = c);
    }
    {
      const c = bu._typeInfo[e.name];
      if (c !== void 0) {
        const o = ((t = e.format) === null || t === void 0 ? void 0 : t.name) === "f16" ? 2 : 1;
        return new Qm(Math.max(s, c.align / o), Math.max(n, c.size / o));
      }
    }
    {
      const c = bu._typeInfo[e.name.substring(0, e.name.length - 1)];
      if (c) {
        const o = e.name[e.name.length - 1] === "h" ? 2 : 1;
        return new Qm(Math.max(s, c.align / o), Math.max(n, c.size / o));
      }
    }
    if (e instanceof Gh) {
      let c = e, o = 8, d = 8;
      const m = this._getTypeSize(c.format);
      return m !== null && (d = m.size, o = m.align), d = c.count * this._getAttributeNum((i = e?.attributes) !== null && i !== void 0 ? i : null, "stride", this._roundUp(o, d)), n && (d = n), new Qm(Math.max(s, o), Math.max(n, d));
    }
    if (e instanceof Uh) {
      let c = 0, o = 0, d = 0, m = 0, y = 0;
      for (const T of e.members) {
        const P = this._getTypeSize(T.type);
        P !== null && (c = Math.max(P.align, c), d = this._roundUp(P.align, d + m), m = P.size, y = d);
      }
      return o = this._roundUp(c, y + m), new Qm(Math.max(s, c), Math.max(n, o));
    }
    return null;
  }
  _isUniformVar(e) {
    return e instanceof rh && e.storage == "uniform";
  }
  _isStorageVar(e) {
    return e instanceof rh && e.storage == "storage";
  }
  _isTextureVar(e) {
    return e instanceof rh && e.type !== null && bu._textureTypes.indexOf(e.type.name) != -1;
  }
  _isSamplerVar(e) {
    return e instanceof rh && e.type !== null && bu._samplerTypes.indexOf(e.type.name) != -1;
  }
  _getAttribute(e, t) {
    const i = e;
    if (!i || !i.attributes) return null;
    const n = i.attributes;
    for (let s of n) if (s.name == t) return s;
    return null;
  }
  _getAttributeNum(e, t, i) {
    if (e === null) return i;
    for (let n of e) if (n.name == t) {
      let s = n !== null && n.value !== null ? n.value : i;
      return s instanceof Array && (s = s[0]), typeof s == "number" ? s : typeof s == "string" ? parseInt(s) : i;
    }
    return i;
  }
  _roundUp(e, t) {
    return Math.ceil(t / e) * e;
  }
}
bu._typeInfo = {
  f16: {
    align: 2,
    size: 2
  },
  i32: {
    align: 4,
    size: 4
  },
  u32: {
    align: 4,
    size: 4
  },
  f32: {
    align: 4,
    size: 4
  },
  atomic: {
    align: 4,
    size: 4
  },
  vec2: {
    align: 8,
    size: 8
  },
  vec3: {
    align: 16,
    size: 12
  },
  vec4: {
    align: 16,
    size: 16
  },
  mat2x2: {
    align: 8,
    size: 16
  },
  mat3x2: {
    align: 8,
    size: 24
  },
  mat4x2: {
    align: 8,
    size: 32
  },
  mat2x3: {
    align: 16,
    size: 32
  },
  mat3x3: {
    align: 16,
    size: 48
  },
  mat4x3: {
    align: 16,
    size: 64
  },
  mat2x4: {
    align: 16,
    size: 32
  },
  mat3x4: {
    align: 16,
    size: 48
  },
  mat4x4: {
    align: 16,
    size: 64
  }
}, bu._textureTypes = Ce.any_texture_type.map((r) => r.name), bu._samplerTypes = Ce.sampler_type.map((r) => r.name);
let $2 = 0;
class H2 {
  constructor(e, t, i) {
    this.id = $2++, this.name = e, this.value = t, this.node = i;
  }
  clone() {
    return new H2(this.name, this.value, this.node);
  }
}
class q2 {
  constructor(e) {
    this.id = $2++, this.name = e.name, this.node = e;
  }
  clone() {
    return new q2(this.node);
  }
}
class W2 {
  constructor(e) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = $2++, e && (this.parent = e, this.currentFunctionName = e.currentFunctionName);
  }
  getVariable(e) {
    var t;
    return this.variables.has(e) ? (t = this.variables.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getVariable(e) : null;
  }
  getFunction(e) {
    var t;
    return this.functions.has(e) ? (t = this.functions.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getFunction(e) : null;
  }
  createVariable(e, t, i) {
    this.variables.set(e, new H2(e, t, i ?? null));
  }
  setVariable(e, t, i) {
    const n = this.getVariable(e);
    n !== null ? n.value = t : this.createVariable(e, t, i);
  }
  getVariableValue(e) {
    var t;
    const i = this.getVariable(e);
    return (t = i?.value) !== null && t !== void 0 ? t : null;
  }
  clone() {
    return new W2(this);
  }
}
class AN {
  evalExpression(e, t) {
    return null;
  }
  getTypeInfo(e) {
    return null;
  }
  getVariableName(e, t) {
    return "";
  }
}
class TN {
  constructor(e) {
    this.exec = e;
  }
  getTypeInfo(e) {
    return this.exec.getTypeInfo(e);
  }
  All(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    let n = !0;
    if (i instanceof Ne) return i.data.forEach((s) => {
      s || (n = !1);
    }), new ot(n ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${e.line}`);
  }
  Any(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) {
      const n = i.data.some((s) => s);
      return new ot(n ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${e.line}`);
  }
  Select(e, t) {
    const i = this.exec.evalExpression(e.args[2], t);
    if (!(i instanceof ot)) throw new Error(`Select() expects a bool condition. Line ${e.line}`);
    return i.value ? this.exec.evalExpression(e.args[1], t) : this.exec.evalExpression(e.args[0], t);
  }
  ArrayLength(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.evalExpression(i, t);
    if (n instanceof cs && n.typeInfo.size === 0) {
      const s = n.typeInfo, c = n.buffer.byteLength / s.stride;
      return new ot(c, this.getTypeInfo("u32"));
    }
    return new ot(n.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.abs(s)), i.typeInfo);
    const n = i;
    return new ot(Math.abs(n.value), n.typeInfo);
  }
  Acos(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.acos(s)), i.typeInfo);
    const n = i;
    return new ot(Math.acos(n.value), i.typeInfo);
  }
  Acosh(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.acosh(s)), i.typeInfo);
    const n = i;
    return new ot(Math.acosh(n.value), i.typeInfo);
  }
  Asin(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.asin(s)), i.typeInfo);
    const n = i;
    return new ot(Math.asin(n.value), i.typeInfo);
  }
  Asinh(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.asinh(s)), i.typeInfo);
    const n = i;
    return new ot(Math.asinh(n.value), i.typeInfo);
  }
  Atan(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.atan(s)), i.typeInfo);
    const n = i;
    return new ot(Math.atan(n.value), i.typeInfo);
  }
  Atanh(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.atanh(s)), i.typeInfo);
    const n = i;
    return new ot(Math.atanh(n.value), i.typeInfo);
  }
  Atan2(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) return new Ne(i.data.map((o, d) => Math.atan2(o, n.data[d])), i.typeInfo);
    const s = i, c = n;
    return new ot(Math.atan2(s.value, c.value), i.typeInfo);
  }
  Ceil(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.ceil(s)), i.typeInfo);
    const n = i;
    return new ot(Math.ceil(n.value), i.typeInfo);
  }
  _clamp(e, t, i) {
    return Math.min(Math.max(e, t), i);
  }
  Clamp(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i instanceof Ne && n instanceof Ne && s instanceof Ne) return new Ne(i.data.map((m, y) => this._clamp(m, n.data[y], s.data[y])), i.typeInfo);
    const c = i, o = n, d = s;
    return new ot(this._clamp(c.value, o.value, d.value), i.typeInfo);
  }
  Cos(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.cos(s)), i.typeInfo);
    const n = i;
    return new ot(Math.cos(n.value), i.typeInfo);
  }
  Cosh(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.cosh(s)), i.typeInfo);
    const n = i;
    return new ot(Math.cos(n.value), i.typeInfo);
  }
  CountLeadingZeros(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.clz32(s)), i.typeInfo);
    const n = i;
    return new ot(Math.clz32(n.value), i.typeInfo);
  }
  _countOneBits(e) {
    let t = 0;
    for (; e !== 0; ) 1 & e && t++, e >>= 1;
    return t;
  }
  CountOneBits(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => this._countOneBits(s)), i.typeInfo);
    const n = i;
    return new ot(this._countOneBits(n.value), i.typeInfo);
  }
  _countTrailingZeros(e) {
    if (e === 0) return 32;
    let t = 0;
    for (; !(1 & e); ) e >>= 1, t++;
    return t;
  }
  CountTrailingZeros(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => this._countTrailingZeros(s)), i.typeInfo);
    const n = i;
    return new ot(this._countTrailingZeros(n.value), i.typeInfo);
  }
  Cross(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) {
      if (i.data.length !== 3 || n.data.length !== 3) return console.error(`Cross() expects 3D vectors. Line ${e.line}`), null;
      const s = i.data, c = n.data;
      return new Ne([s[1] * c[2] - c[1] * s[2], s[2] * c[0] - c[2] * s[0], s[0] * c[1] - c[0] * s[1]], i.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${e.line}`), null;
  }
  Degrees(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = 180 / Math.PI;
    return i instanceof Ne ? new Ne(i.data.map((s) => s * n), i.typeInfo) : new ot(i.value * n, this.getTypeInfo("f32"));
  }
  Determinant(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof ei) {
      const n = i.data, s = i.typeInfo.getTypeName(), c = s.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if (s === "mat2x2" || s === "mat2x2f" || s === "mat2x2h") return new ot(n[0] * n[3] - n[1] * n[2], c);
      if (s === "mat2x3" || s === "mat2x3f" || s === "mat2x3h") return new ot(n[0] * (n[4] * n[8] - n[5] * n[7]) - n[1] * (n[3] * n[8] - n[5] * n[6]) + n[2] * (n[3] * n[7] - n[4] * n[6]), c);
      if (s === "mat2x4" || s === "mat2x4f" || s === "mat2x4h") console.error(`TODO: Determinant for ${s}`);
      else if (s === "mat3x2" || s === "mat3x2f" || s === "mat3x2h") console.error(`TODO: Determinant for ${s}`);
      else {
        if (s === "mat3x3" || s === "mat3x3f" || s === "mat3x3h") return new ot(n[0] * (n[4] * n[8] - n[5] * n[7]) - n[1] * (n[3] * n[8] - n[5] * n[6]) + n[2] * (n[3] * n[7] - n[4] * n[6]), c);
        s === "mat3x4" || s === "mat3x4f" || s === "mat3x4h" || s === "mat4x2" || s === "mat4x2f" || s === "mat4x2h" || s === "mat4x3" || s === "mat4x3f" || s === "mat4x3h" ? console.error(`TODO: Determinant for ${s}`) : s !== "mat4x4" && s !== "mat4x4f" && s !== "mat4x4h" || console.error(`TODO: Determinant for ${s}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${e.line}`), null;
  }
  Distance(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) {
      let o = 0;
      for (let d = 0; d < i.data.length; ++d) o += (i.data[d] - n.data[d]) * (i.data[d] - n.data[d]);
      return new ot(Math.sqrt(o), this.getTypeInfo("f32"));
    }
    const s = i, c = n;
    return new ot(Math.abs(s.value - c.value), i.typeInfo);
  }
  _dot(e, t) {
    let i = 0;
    for (let n = 0; n < e.length; ++n) i += t[n] * e[n];
    return i;
  }
  Dot(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    return i instanceof Ne && n instanceof Ne ? new ot(this._dot(i.data, n.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e.line}`), null);
  }
  Dot4U8Packed(e, t) {
    return console.error(`TODO: dot4U8Packed. Line ${e.line}`), null;
  }
  Dot4I8Packed(e, t) {
    return console.error(`TODO: dot4I8Packed. Line ${e.line}`), null;
  }
  Exp(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.exp(s)), i.typeInfo);
    const n = i;
    return new ot(Math.exp(n.value), i.typeInfo);
  }
  Exp2(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.pow(2, s)), i.typeInfo);
    const n = i;
    return new ot(Math.pow(2, n.value), i.typeInfo);
  }
  ExtractBits(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n.typeInfo.name !== "u32" && n.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`), null;
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`), null;
    const c = n.value, o = s.value;
    if (i instanceof Ne) return new Ne(i.data.map((m) => m >> c & (1 << o) - 1), i.typeInfo);
    if (i.typeInfo.name !== "i32" && i.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`), null;
    const d = i.value;
    return new ot(d >> c & (1 << o) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i instanceof Ne && n instanceof Ne && s instanceof Ne) {
      const c = this._dot(n.data, s.data);
      return new Ne(c < 0 ? Array.from(i.data) : i.data.map((o) => -o), i.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${e.line}`), null;
  }
  _firstLeadingBit(e) {
    return e === 0 ? -1 : 31 - Math.clz32(e);
  }
  FirstLeadingBit(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => this._firstLeadingBit(s)), i.typeInfo);
    const n = i;
    return new ot(this._firstLeadingBit(n.value), i.typeInfo);
  }
  _firstTrailingBit(e) {
    return e === 0 ? -1 : Math.log2(e & -e);
  }
  FirstTrailingBit(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => this._firstTrailingBit(s)), i.typeInfo);
    const n = i;
    return new ot(this._firstTrailingBit(n.value), i.typeInfo);
  }
  Floor(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.floor(s)), i.typeInfo);
    const n = i;
    return new ot(Math.floor(n.value), i.typeInfo);
  }
  Fma(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i instanceof Ne && n instanceof Ne && s instanceof Ne) return i.data.length !== n.data.length || i.data.length !== s.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e.line}`), null) : new Ne(i.data.map((m, y) => m * n.data[y] + s.data[y]), i.typeInfo);
    const c = i, o = n, d = s;
    return new ot(c.value * o.value + d.value, c.typeInfo);
  }
  Fract(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => s - Math.floor(s)), i.typeInfo);
    const n = i;
    return new ot(n.value - Math.floor(n.value), i.typeInfo);
  }
  Frexp(e, t) {
    return console.error(`TODO: frexp. Line ${e.line}`), null;
  }
  InsertBits(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t), c = this.exec.evalExpression(e.args[3], t);
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`), null;
    const o = s.value, d = (1 << c.value) - 1 << o, m = ~d;
    if (i instanceof Ne && n instanceof Ne) return new Ne(i.data.map((P, I) => P & m | n.data[I] << o & d), i.typeInfo);
    const y = i.value, T = n.value;
    return new ot(y & m | T << o & d, i.typeInfo);
  }
  InverseSqrt(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => 1 / Math.sqrt(s)), i.typeInfo);
    const n = i;
    return new ot(1 / Math.sqrt(n.value), i.typeInfo);
  }
  Ldexp(e, t) {
    return console.error(`TODO: ldexp. Line ${e.line}`), null;
  }
  Length(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) {
      let s = 0;
      return i.data.forEach((c) => {
        s += c * c;
      }), new ot(Math.sqrt(s), this.getTypeInfo("f32"));
    }
    const n = i;
    return new ot(Math.abs(n.value), i.typeInfo);
  }
  Log(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.log(s)), i.typeInfo);
    const n = i;
    return new ot(Math.log(n.value), i.typeInfo);
  }
  Log2(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.log2(s)), i.typeInfo);
    const n = i;
    return new ot(Math.log2(n.value), i.typeInfo);
  }
  Max(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) return new Ne(i.data.map((o, d) => Math.max(o, n.data[d])), i.typeInfo);
    const s = i, c = n;
    return new ot(Math.max(s.value, c.value), i.typeInfo);
  }
  Min(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) return new Ne(i.data.map((o, d) => Math.min(o, n.data[d])), i.typeInfo);
    const s = i, c = n;
    return new ot(Math.min(s.value, c.value), i.typeInfo);
  }
  Mix(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i instanceof Ne && n instanceof Ne && s instanceof Ne) return new Ne(i.data.map((d, m) => i.data[m] * (1 - s.data[m]) + n.data[m] * s.data[m]), i.typeInfo);
    const c = n, o = s;
    return new ot(i.value * (1 - o.value) + c.value * o.value, i.typeInfo);
  }
  Modf(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) return new Ne(i.data.map((c, o) => c % n.data[o]), i.typeInfo);
    const s = n;
    return new ot(i.value % s.value, i.typeInfo);
  }
  Normalize(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) {
      const n = this.Length(e, t).value;
      return new Ne(i.data.map((s) => s / n), i.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${e.line}`), null;
  }
  Pow(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) return new Ne(i.data.map((o, d) => Math.pow(o, n.data[d])), i.typeInfo);
    const s = i, c = n;
    return new ot(Math.pow(s.value, c.value), i.typeInfo);
  }
  QuantizeToF16(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    return i instanceof Ne ? new Ne(i.data.map((n) => n), i.typeInfo) : new ot(i.value, i.typeInfo);
  }
  Radians(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    return i instanceof Ne ? new Ne(i.data.map((n) => n * Math.PI / 180), i.typeInfo) : new ot(i.value * Math.PI / 180, this.getTypeInfo("f32"));
  }
  Reflect(e, t) {
    let i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) {
      const s = this._dot(i.data, n.data);
      return new Ne(i.data.map((c, o) => c - 2 * s * n.data[o]), i.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${e.line}`), null;
  }
  Refract(e, t) {
    let i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i instanceof Ne && n instanceof Ne && s instanceof ot) {
      const c = this._dot(n.data, i.data);
      return new Ne(i.data.map((o, d) => {
        const m = 1 - s.value * s.value * (1 - c * c);
        if (m < 0) return 0;
        const y = Math.sqrt(m);
        return s.value * o - (s.value * c + y) * n.data[d];
      }), i.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`), null;
  }
  ReverseBits(e, t) {
    return console.error(`TODO: reverseBits. Line ${e.line}`), null;
  }
  Round(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.round(s)), i.typeInfo);
    const n = i;
    return new ot(Math.round(n.value), i.typeInfo);
  }
  Saturate(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.min(Math.max(s, 0), 1)), i.typeInfo);
    const n = i;
    return new ot(Math.min(Math.max(n.value, 0), 1), i.typeInfo);
  }
  Sign(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.sign(s)), i.typeInfo);
    const n = i;
    return new ot(Math.sign(n.value), i.typeInfo);
  }
  Sin(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.sin(s)), i.typeInfo);
    const n = i;
    return new ot(Math.sin(n.value), i.typeInfo);
  }
  Sinh(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.sinh(s)), i.typeInfo);
    const n = i;
    return new ot(Math.sinh(n.value), i.typeInfo);
  }
  _smoothstep(e, t, i) {
    const n = Math.min(Math.max((i - e) / (t - e), 0), 1);
    return n * n * (3 - 2 * n);
  }
  SmoothStep(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (s instanceof Ne && i instanceof Ne && n instanceof Ne) return new Ne(s.data.map((m, y) => this._smoothstep(i.data[y], n.data[y], m)), s.typeInfo);
    const c = i, o = n, d = s;
    return new ot(this._smoothstep(c.value, o.value, d.value), s.typeInfo);
  }
  Sqrt(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.sqrt(s)), i.typeInfo);
    const n = i;
    return new ot(Math.sqrt(n.value), i.typeInfo);
  }
  Step(e, t) {
    const i = this.exec.evalExpression(e.args[0], t), n = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) return new Ne(n.data.map((c, o) => c < i.data[o] ? 0 : 1), n.typeInfo);
    const s = i;
    return new ot(n.value < s.value ? 0 : 1, s.typeInfo);
  }
  Tan(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.tan(s)), i.typeInfo);
    const n = i;
    return new ot(Math.tan(n.value), i.typeInfo);
  }
  Tanh(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.tanh(s)), i.typeInfo);
    const n = i;
    return new ot(Math.tanh(n.value), i.typeInfo);
  }
  _getTransposeType(e) {
    const t = e.getTypeName();
    return t === "mat2x2f" || t === "mat2x2h" ? e : t === "mat2x3f" ? this.getTypeInfo("mat3x2f") : t === "mat2x3h" ? this.getTypeInfo("mat3x2h") : t === "mat2x4f" ? this.getTypeInfo("mat4x2f") : t === "mat2x4h" ? this.getTypeInfo("mat4x2h") : t === "mat3x2f" ? this.getTypeInfo("mat2x3f") : t === "mat3x2h" ? this.getTypeInfo("mat2x3h") : t === "mat3x3f" || t === "mat3x3h" ? e : t === "mat3x4f" ? this.getTypeInfo("mat4x3f") : t === "mat3x4h" ? this.getTypeInfo("mat4x3h") : t === "mat4x2f" ? this.getTypeInfo("mat2x4f") : t === "mat4x2h" ? this.getTypeInfo("mat2x4h") : t === "mat4x3f" ? this.getTypeInfo("mat3x4f") : t === "mat4x3h" ? this.getTypeInfo("mat3x4h") : (t === "mat4x4f" || t === "mat4x4h" || console.error(`Invalid matrix type ${t}`), e);
  }
  Transpose(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (!(i instanceof ei)) return console.error(`Transpose() expects a matrix argument. Line ${e.line}`), null;
    const n = this._getTransposeType(i.typeInfo);
    if (i.typeInfo.name === "mat2x2" || i.typeInfo.name === "mat2x2f" || i.typeInfo.name === "mat2x2h") {
      const s = i.data;
      return new ei([s[0], s[2], s[1], s[3]], n);
    }
    if (i.typeInfo.name === "mat2x3" || i.typeInfo.name === "mat2x3f" || i.typeInfo.name === "mat2x3h") {
      const s = i.data;
      return new ei([s[0], s[3], s[6], s[1], s[4], s[7]], n);
    }
    if (i.typeInfo.name === "mat2x4" || i.typeInfo.name === "mat2x4f" || i.typeInfo.name === "mat2x4h") {
      const s = i.data;
      return new ei([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13]], n);
    }
    if (i.typeInfo.name === "mat3x2" || i.typeInfo.name === "mat3x2f" || i.typeInfo.name === "mat3x2h") {
      const s = i.data;
      return new ei([s[0], s[3], s[1], s[4], s[2], s[5]], n);
    }
    if (i.typeInfo.name === "mat3x3" || i.typeInfo.name === "mat3x3f" || i.typeInfo.name === "mat3x3h") {
      const s = i.data;
      return new ei([s[0], s[3], s[6], s[1], s[4], s[7], s[2], s[5], s[8]], n);
    }
    if (i.typeInfo.name === "mat3x4" || i.typeInfo.name === "mat3x4f" || i.typeInfo.name === "mat3x4h") {
      const s = i.data;
      return new ei([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14]], n);
    }
    if (i.typeInfo.name === "mat4x2" || i.typeInfo.name === "mat4x2f" || i.typeInfo.name === "mat4x2h") {
      const s = i.data;
      return new ei([s[0], s[4], s[1], s[5], s[2], s[6]], n);
    }
    if (i.typeInfo.name === "mat4x3" || i.typeInfo.name === "mat4x3f" || i.typeInfo.name === "mat4x3h") {
      const s = i.data;
      return new ei([s[0], s[4], s[8], s[1], s[5], s[9], s[2], s[6], s[10]], n);
    }
    if (i.typeInfo.name === "mat4x4" || i.typeInfo.name === "mat4x4f" || i.typeInfo.name === "mat4x4h") {
      const s = i.data;
      return new ei([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14], s[3], s[7], s[11], s[15]], n);
    }
    return console.error(`Invalid matrix type ${i.typeInfo.name}`), null;
  }
  Trunc(e, t) {
    const i = this.exec.evalExpression(e.args[0], t);
    if (i instanceof Ne) return new Ne(i.data.map((s) => Math.trunc(s)), i.typeInfo);
    const n = i;
    return new ot(Math.trunc(n.value), i.typeInfo);
  }
  Dpdx(e, t) {
    return console.error(`TODO: dpdx. Line ${e.line}`), null;
  }
  DpdxCoarse(e, t) {
    return console.error(`TODO: dpdxCoarse. Line ${e.line}`), null;
  }
  DpdxFine(e, t) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(e, t) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(e, t) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(e, t) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(e, t) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(e, t) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(e, t) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(e, t) {
    const i = e.args[0], n = e.args.length > 1 ? this.exec.evalExpression(e.args[1], t).value : 0;
    if (i instanceof il) {
      const s = i.name, c = t.getVariableValue(s);
      if (c instanceof eh) {
        if (n < 0 || n >= c.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`), null;
        const o = c.getMipLevelSize(n), d = c.dimension;
        return d === "1d" ? new ot(o[0], this.getTypeInfo("u32")) : d === "3d" ? new Ne(o, this.getTypeInfo("vec3u")) : d === "2d" ? new Ne(o.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${d} not found. Line ${e.line}`), null);
      }
      return console.error(`Texture ${s} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`), null;
  }
  TextureGather(e, t) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(e, t) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(e, t) {
    const i = e.args[0], n = this.exec.evalExpression(e.args[1], t), s = e.args.length > 2 ? this.exec.evalExpression(e.args[2], t).value : 0;
    if (!(n instanceof Ne) || n.data.length !== 2) return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`), null;
    if (i instanceof il) {
      const c = i.name, o = t.getVariableValue(c);
      if (o instanceof eh) {
        const d = Math.floor(n.data[0]), m = Math.floor(n.data[1]);
        if (d < 0 || d >= o.width || m < 0 || m >= o.height) return console.error(`Texture ${c} out of bounds. Line ${e.line}`), null;
        const y = o.getPixel(d, m, 0, s);
        return y === null ? (console.error(`Invalid texture format for textureLoad. Line ${e.line}`), null) : new Ne(y, this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${c} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`), null;
  }
  TextureNumLayers(e, t) {
    const i = e.args[0];
    if (i instanceof il) {
      const n = i.name, s = t.getVariableValue(n);
      return s instanceof eh ? new ot(s.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${n} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`), null;
  }
  TextureNumLevels(e, t) {
    const i = e.args[0];
    if (i instanceof il) {
      const n = i.name, s = t.getVariableValue(n);
      return s instanceof eh ? new ot(s.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${n} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`), null;
  }
  TextureNumSamples(e, t) {
    const i = e.args[0];
    if (i instanceof il) {
      const n = i.name, s = t.getVariableValue(n);
      return s instanceof eh ? new ot(s.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${n} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`), null;
  }
  TextureSample(e, t) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(e, t) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(e, t) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(e, t) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(e, t) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(e, t) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(e, t) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(e, t) {
    const i = e.args[0], n = this.exec.evalExpression(e.args[1], t), s = e.args.length === 4 ? this.exec.evalExpression(e.args[2], t).value : 0, c = e.args.length === 4 ? this.exec.evalExpression(e.args[3], t).data : this.exec.evalExpression(e.args[2], t).data;
    if (c.length !== 4) return console.error(`Invalid value argument for textureStore. Line ${e.line}`), null;
    if (!(n instanceof Ne) || n.data.length !== 2) return console.error(`Invalid UV argument for textureStore. Line ${e.line}`), null;
    if (i instanceof il) {
      const o = i.name, d = t.getVariableValue(o);
      if (d instanceof eh) {
        const m = d.getMipLevelSize(0), y = Math.floor(n.data[0]), T = Math.floor(n.data[1]);
        return y < 0 || y >= m[0] || T < 0 || T >= m[1] ? (console.error(`Texture ${o} out of bounds. Line ${e.line}`), null) : (d.setPixel(y, T, 0, s, Array.from(c)), null);
      }
      return console.error(`Texture ${o} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${e.line}`), null;
  }
  AtomicLoad(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t);
    return t.getVariable(n).value.getSubData(this.exec, i.postfix, t);
  }
  AtomicStore(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t);
    return d instanceof ot && o instanceof ot && (d.value = o.value), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), null;
  }
  AtomicAdd(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value += o.value), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicSub(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value -= o.value), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicMax(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value = Math.max(d.value, o.value)), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicMin(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value = Math.min(d.value, o.value)), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicAnd(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value = d.value & o.value), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicOr(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value = d.value | o.value), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicXor(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value = d.value ^ o.value), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicExchange(e, t) {
    let i = e.args[0];
    i instanceof Ds && (i = i.right);
    const n = this.exec.getVariableName(i, t), s = t.getVariable(n);
    let c = e.args[1];
    const o = this.exec.evalExpression(c, t), d = s.value.getSubData(this.exec, i.postfix, t), m = new ot(d.value, d.typeInfo);
    return d instanceof ot && o instanceof ot && (d.value = o.value), s.value instanceof cs && s.value.setDataValue(this.exec, d, i.postfix, t), m;
  }
  AtomicCompareExchangeWeak(e, t) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(e, t) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(e, t) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(e, t) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(e, t) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(e, t) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(e, t) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(e, t) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(e, t) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(e, t) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(e, t) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(e, t) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(e, t) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(e, t) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(e, t) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(e, t) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(e, t) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(e, t) {
    return null;
  }
  TextureBarrier(e, t) {
    return null;
  }
  WorkgroupBarrier(e, t) {
    return null;
  }
  WorkgroupUniformLoad(e, t) {
    return null;
  }
  SubgroupAdd(e, t) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(e, t) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(e, t) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(e, t) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(e, t) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(e, t) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(e, t) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(e, t) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(e, t) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(e, t) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(e, t) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(e, t) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(e, t) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(e, t) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(e, t) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(e, t) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(e, t) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(e, t) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(e, t) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(e, t) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(e, t) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(e, t) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(e, t) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(e, t) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(e, t) {
    return console.error("TODO: quadSwapY"), null;
  }
}
const wb = {
  vec2: 2,
  vec2f: 2,
  vec2i: 2,
  vec2u: 2,
  vec2b: 2,
  vec2h: 2,
  vec3: 3,
  vec3f: 3,
  vec3i: 3,
  vec3u: 3,
  vec3b: 3,
  vec3h: 3,
  vec4: 4,
  vec4f: 4,
  vec4i: 4,
  vec4u: 4,
  vec4b: 4,
  vec4h: 4
}, ua = {
  mat2x2: [2, 2, 4],
  mat2x2f: [2, 2, 4],
  mat2x2h: [2, 2, 4],
  mat2x3: [2, 3, 6],
  mat2x3f: [2, 3, 6],
  mat2x3h: [2, 3, 6],
  mat2x4: [2, 4, 8],
  mat2x4f: [2, 4, 8],
  mat2x4h: [2, 4, 8],
  mat3x2: [3, 2, 6],
  mat3x2f: [3, 2, 6],
  mat3x2h: [3, 2, 6],
  mat3x3: [3, 3, 9],
  mat3x3f: [3, 3, 9],
  mat3x3h: [3, 3, 9],
  mat3x4: [3, 4, 12],
  mat3x4f: [3, 4, 12],
  mat3x4h: [3, 4, 12],
  mat4x2: [4, 2, 8],
  mat4x2f: [4, 2, 8],
  mat4x2h: [4, 2, 8],
  mat4x3: [4, 3, 12],
  mat4x3f: [4, 3, 12],
  mat4x3h: [4, 3, 12],
  mat4x4: [4, 4, 16],
  mat4x4f: [4, 4, 16],
  mat4x4h: [4, 4, 16]
};
class jo extends AN {
  constructor(e, t) {
    var i;
    super(), this.ast = e ?? [], this.reflection = new bu(), this.reflection.updateAST(this.ast), this.context = (i = t?.clone()) !== null && i !== void 0 ? i : new W2(), this.builtins = new TN(this), this.typeInfo = {
      bool: this.getTypeInfo($t.bool),
      i32: this.getTypeInfo($t.i32),
      u32: this.getTypeInfo($t.u32),
      f32: this.getTypeInfo($t.f32),
      f16: this.getTypeInfo($t.f16),
      vec2f: this.getTypeInfo(pt.vec2f),
      vec2u: this.getTypeInfo(pt.vec2u),
      vec2i: this.getTypeInfo(pt.vec2i),
      vec2h: this.getTypeInfo(pt.vec2h),
      vec3f: this.getTypeInfo(pt.vec3f),
      vec3u: this.getTypeInfo(pt.vec3u),
      vec3i: this.getTypeInfo(pt.vec3i),
      vec3h: this.getTypeInfo(pt.vec3h),
      vec4f: this.getTypeInfo(pt.vec4f),
      vec4u: this.getTypeInfo(pt.vec4u),
      vec4i: this.getTypeInfo(pt.vec4i),
      vec4h: this.getTypeInfo(pt.vec4h),
      mat2x2f: this.getTypeInfo(pt.mat2x2f),
      mat2x3f: this.getTypeInfo(pt.mat2x3f),
      mat2x4f: this.getTypeInfo(pt.mat2x4f),
      mat3x2f: this.getTypeInfo(pt.mat3x2f),
      mat3x3f: this.getTypeInfo(pt.mat3x3f),
      mat3x4f: this.getTypeInfo(pt.mat3x4f),
      mat4x2f: this.getTypeInfo(pt.mat4x2f),
      mat4x3f: this.getTypeInfo(pt.mat4x3f),
      mat4x4f: this.getTypeInfo(pt.mat4x4f)
    };
  }
  getVariableValue(e) {
    var t, i;
    const n = (i = (t = this.context.getVariable(e)) === null || t === void 0 ? void 0 : t.value) !== null && i !== void 0 ? i : null;
    if (n === null) return null;
    if (n instanceof ot) return n.value;
    if (n instanceof Ne || n instanceof ei) return Array.from(n.data);
    if (n instanceof cs && n.typeInfo instanceof Gh) {
      if (n.typeInfo.format.name === "u32") return Array.from(new Uint32Array(n.buffer, n.offset, n.typeInfo.count));
      if (n.typeInfo.format.name === "i32") return Array.from(new Int32Array(n.buffer, n.offset, n.typeInfo.count));
      if (n.typeInfo.format.name === "f32") return Array.from(new Float32Array(n.buffer, n.offset, n.typeInfo.count));
    }
    return console.error(`Unsupported return variable type ${n.typeInfo.name}`), null;
  }
  execute(e) {
    (e = e ?? {}).constants && this._setOverrides(e.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(e, t, i, n) {
    const s = this.context.clone();
    (n = n ?? {}).constants && this._setOverrides(n.constants, s), this._execStatements(this.ast, s);
    const c = s.getFunction(e);
    if (!c) return void console.error(`Function ${e} not found`);
    if (typeof t == "number") t = [t, 1, 1];
    else {
      if (t.length === 0) return void console.error("Invalid dispatch count");
      t.length === 1 ? t = [t[0], 1, 1] : t.length === 2 ? t = [t[0], t[1], 1] : t.length > 3 && (t = [t[0], t[1], t[2]]);
    }
    const o = t[0], d = t[1], m = t[2], y = this.getTypeInfo("vec3u");
    s.setVariable("@num_workgroups", new Ne(t, y));
    const T = this.reflection.getFunctionInfo(e);
    T === null && console.error(`Function ${e} not found in reflection data`);
    for (const P in i) for (const I in i[P]) {
      const D = i[P][I];
      s.variables.forEach((k) => {
        var $;
        const G = k.node;
        if (G?.attributes) {
          let te = null, Z = null;
          for (const H of G.attributes) H.name === "binding" ? te = H.value : H.name === "group" && (Z = H.value);
          if (I == te && P == Z) {
            let H = !1;
            for (const J of T.resources) if (J.name === k.name && J.group === parseInt(P) && J.binding === parseInt(I)) {
              H = !0;
              break;
            }
            if (H) if (D.texture !== void 0 && D.descriptor !== void 0) {
              const J = new eh(D.texture, this.getTypeInfo(G.type), D.descriptor, ($ = D.texture.view) !== null && $ !== void 0 ? $ : null);
              k.value = J;
            } else D.uniform !== void 0 ? k.value = new cs(D.uniform, this.getTypeInfo(G.type)) : k.value = new cs(D, this.getTypeInfo(G.type));
          }
        }
      });
    }
    for (let P = 0; P < m; ++P) for (let I = 0; I < d; ++I) for (let D = 0; D < o; ++D) s.setVariable("@workgroup_id", new Ne([D, I, P], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(c, [D, I, P], s);
  }
  execStatement(e, t) {
    if (e instanceof pI) return this.evalExpression(e.value, t);
    if (e instanceof mI) {
      if (e.condition) {
        const i = this.evalExpression(e.condition, t);
        if (!(i instanceof ot)) throw new Error("Invalid break-if condition");
        if (!i.value) return null;
      }
      return jo._breakObj;
    }
    if (e instanceof _I) return jo._continueObj;
    if (e instanceof Bg) this._let(e, t);
    else if (e instanceof rh) this._var(e, t);
    else if (e instanceof j_) this._const(e, t);
    else if (e instanceof Wg) this._function(e, t);
    else {
      if (e instanceof dI) return this._if(e, t);
      if (e instanceof fI) return this._switch(e, t);
      if (e instanceof lI) return this._for(e, t);
      if (e instanceof aI) return this._while(e, t);
      if (e instanceof hI) return this._loop(e, t);
      if (e instanceof fv) {
        const i = t.clone();
        return i.currentFunctionName = t.currentFunctionName, this._execStatements(e.body, i);
      }
      if (e instanceof uI) this._assign(e, t);
      else if (e instanceof cI) this._increment(e, t);
      else {
        if (e instanceof Qu) return null;
        if (e instanceof z2) {
          const i = e.name;
          t.getVariable(i) === null && t.setVariable(i, new ot(0, this.getTypeInfo("u32")));
        } else if (e instanceof j2) this._call(e, t);
        else {
          if (e instanceof gI || e instanceof V2) return null;
          console.error("Invalid statement type.", e, `Line ${e.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(e, t) {
    return e instanceof gc ? this._evalBinaryOp(e, t) : e instanceof Ys ? this._evalLiteral(e, t) : e instanceof il ? this._evalVariable(e, t) : e instanceof G2 ? this._evalCall(e, t) : e instanceof pu ? this._evalCreate(e, t) : e instanceof yI ? this._evalConst(e, t) : e instanceof bI ? this._evalBitcast(e, t) : e instanceof Ds ? this._evalUnaryOp(e, t) : (console.error("Invalid expression type", e, `Line ${e.line}`), null);
  }
  getTypeInfo(e) {
    var t;
    if (e instanceof $t) {
      const n = this.reflection.getTypeInfo(e);
      if (n !== null) return n;
    }
    let i = (t = this.typeInfo[e]) !== null && t !== void 0 ? t : null;
    return i !== null || (i = this.reflection.getTypeInfoByName(e)), i;
  }
  _setOverrides(e, t) {
    for (const i in e) {
      const n = e[i], s = this.reflection.getOverrideInfo(i);
      s !== null ? (s.type === null && (s.type = this.getTypeInfo("u32")), s.type.name === "u32" || s.type.name === "i32" || s.type.name === "f32" || s.type.name === "f16" ? t.setVariable(i, new ot(n, s.type)) : s.type.name === "bool" ? t.setVariable(i, new ot(n ? 1 : 0, s.type)) : s.type.name === "vec2" || s.type.name === "vec3" || s.type.name === "vec4" || s.type.name === "vec2f" || s.type.name === "vec3f" || s.type.name === "vec4f" || s.type.name === "vec2i" || s.type.name === "vec3i" || s.type.name === "vec4i" || s.type.name === "vec2u" || s.type.name === "vec3u" || s.type.name === "vec4u" || s.type.name === "vec2h" || s.type.name === "vec3h" || s.type.name === "vec4h" ? t.setVariable(i, new Ne(n, s.type)) : console.error(`Invalid constant type for ${i}`)) : console.error(`Override ${i} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(e, t, i) {
    const n = [1, 1, 1];
    for (const y of e.node.attributes) if (y.name === "workgroup_size") {
      if (y.value.length > 0) {
        const T = i.getVariableValue(y.value[0]);
        n[0] = T instanceof ot ? T.value : parseInt(y.value[0]);
      }
      if (y.value.length > 1) {
        const T = i.getVariableValue(y.value[1]);
        n[1] = T instanceof ot ? T.value : parseInt(y.value[1]);
      }
      if (y.value.length > 2) {
        const T = i.getVariableValue(y.value[2]);
        n[2] = T instanceof ot ? T.value : parseInt(y.value[2]);
      }
    }
    const s = this.getTypeInfo("vec3u"), c = this.getTypeInfo("u32");
    i.setVariable("@workgroup_size", new Ne(n, s));
    const o = n[0], d = n[1], m = n[2];
    for (let y = 0, T = 0; y < m; ++y) for (let P = 0; P < d; ++P) for (let I = 0; I < o; ++I, ++T) {
      const D = [I, P, y], k = [I + t[0] * n[0], P + t[1] * n[1], y + t[2] * n[2]];
      i.setVariable("@local_invocation_id", new Ne(D, s)), i.setVariable("@global_invocation_id", new Ne(k, s)), i.setVariable("@local_invocation_index", new ot(T, c)), this._dispatchExec(e, i);
    }
  }
  _dispatchExec(e, t) {
    for (const i of e.node.args) for (const n of i.attributes) if (n.name === "builtin") {
      const s = `@${n.value}`, c = t.getVariable(s);
      c !== void 0 && t.variables.set(i.name, c);
    }
    this._execStatements(e.node.body, t);
  }
  getVariableName(e, t) {
    for (; e instanceof Ds; ) e = e.right;
    return e instanceof il ? e.name : (console.error("Unknown variable type", e, "Line", e.line), null);
  }
  _execStatements(e, t) {
    for (const i of e) {
      if (i instanceof Array) {
        const s = t.clone(), c = this._execStatements(i, s);
        if (c) return c;
        continue;
      }
      const n = this.execStatement(i, t);
      if (n) return n;
    }
    return null;
  }
  _call(e, t) {
    const i = t.clone();
    i.currentFunctionName = e.name;
    const n = t.getFunction(e.name);
    if (n) {
      for (let s = 0; s < n.node.args.length; ++s) {
        const c = n.node.args[s], o = this.evalExpression(e.args[s], i);
        i.setVariable(c.name, o, c);
      }
      this._execStatements(n.node.body, i);
    } else e.isBuiltin ? this._callBuiltinFunction(e, i) : this.getTypeInfo(e.name) && this._evalCreate(e, t);
  }
  _increment(e, t) {
    const i = this.getVariableName(e.variable, t), n = t.getVariable(i);
    n ? e.operator === "++" ? n.value instanceof ot ? n.value.value++ : console.error(`Variable ${i} is not a scalar. Line ${e.line}`) : e.operator === "--" ? n.value instanceof ot ? n.value.value-- : console.error(`Variable ${i} is not a scalar. Line ${e.line}`) : console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`) : console.error(`Variable ${i} not found. Line ${e.line}`);
  }
  _getVariableData(e, t) {
    if (e instanceof il) {
      const i = this.getVariableName(e, t), n = t.getVariable(i);
      return n === null ? (console.error(`Variable ${i} not found. Line ${e.line}`), null) : n.value.getSubData(this, e.postfix, t);
    }
    if (e instanceof Ds) {
      if (e.operator === "*") {
        const i = this._getVariableData(e.right, t);
        return i instanceof zd ? i.reference.getSubData(this, e.postfix, t) : (console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`), null);
      }
      if (e.operator === "&") {
        const i = this._getVariableData(e.right, t);
        return new zd(i);
      }
    }
    return null;
  }
  _assign(e, t) {
    let i = null, n = "<var>", s = null;
    if (e.variable instanceof Ds) {
      const d = this._getVariableData(e.variable, t), m = this.evalExpression(e.value, t), y = e.operator;
      if (y === "=") {
        if (d instanceof ot || d instanceof Ne || d instanceof ei) {
          if (m instanceof ot || m instanceof Ne || m instanceof ei && d.data.length === m.data.length) return void d.data.set(m.data);
          console.error(`Invalid assignment. Line ${e.line}`);
        } else if (d instanceof cs && m instanceof cs && d.buffer.byteLength - d.offset >= m.buffer.byteLength - m.offset) return void (d.buffer.byteLength % 4 == 0 ? new Uint32Array(d.buffer, d.offset, d.typeInfo.size / 4).set(new Uint32Array(m.buffer, m.offset, m.typeInfo.size / 4)) : new Uint8Array(d.buffer, d.offset, d.typeInfo.size).set(new Uint8Array(m.buffer, m.offset, m.typeInfo.size)));
        return console.error(`Invalid assignment. Line ${e.line}`), null;
      }
      if (y === "+=") return d instanceof ot || d instanceof Ne || d instanceof ei ? m instanceof ot || m instanceof Ne || m instanceof ei ? void d.data.set(m.data.map((T, P) => d.data[P] + T)) : void console.error(`Invalid assignment . Line ${e.line}`) : void console.error(`Invalid assignment. Line ${e.line}`);
      if (y === "-=") return (d instanceof ot || d instanceof Ne || d instanceof ei) && (m instanceof ot || m instanceof Ne || m instanceof ei) ? void d.data.set(m.data.map((T, P) => d.data[P] - T)) : void console.error(`Invalid assignment. Line ${e.line}`);
    }
    if (e.variable instanceof Ds) {
      if (e.variable.operator === "*") {
        n = this.getVariableName(e.variable.right, t);
        const d = t.getVariable(n);
        if (!(d && d.value instanceof zd)) return void console.error(`Variable ${n} is not a pointer. Line ${e.line}`);
        i = d.value.reference;
        let m = e.variable.postfix;
        if (!m) {
          let y = e.variable.right;
          for (; y instanceof Ds; ) {
            if (y.postfix) {
              m = y.postfix;
              break;
            }
            y = y.right;
          }
        }
        m && (i = i.getSubData(this, m, t));
      }
    } else {
      s = e.variable.postfix, n = this.getVariableName(e.variable, t);
      const d = t.getVariable(n);
      if (d === null) return void console.error(`Variable ${n} not found. Line ${e.line}`);
      i = d.value;
    }
    if (i instanceof zd && (i = i.reference), i === null) return void console.error(`Variable ${n} not found. Line ${e.line}`);
    const c = this.evalExpression(e.value, t), o = e.operator;
    if (o !== "=") {
      const d = i.getSubData(this, s, t);
      if (d instanceof Ne && c instanceof ot) {
        const m = d.data, y = c.value;
        if (o === "+=") for (let T = 0; T < m.length; ++T) m[T] += y;
        else if (o === "-=") for (let T = 0; T < m.length; ++T) m[T] -= y;
        else if (o === "*=") for (let T = 0; T < m.length; ++T) m[T] *= y;
        else if (o === "/=") for (let T = 0; T < m.length; ++T) m[T] /= y;
        else if (o === "%=") for (let T = 0; T < m.length; ++T) m[T] %= y;
        else if (o === "&=") for (let T = 0; T < m.length; ++T) m[T] &= y;
        else if (o === "|=") for (let T = 0; T < m.length; ++T) m[T] |= y;
        else if (o === "^=") for (let T = 0; T < m.length; ++T) m[T] ^= y;
        else if (o === "<<=") for (let T = 0; T < m.length; ++T) m[T] <<= y;
        else if (o === ">>=") for (let T = 0; T < m.length; ++T) m[T] >>= y;
        else console.error(`Invalid operator ${o}. Line ${e.line}`);
      } else if (d instanceof Ne && c instanceof Ne) {
        const m = d.data, y = c.data;
        if (m.length !== y.length) return void console.error(`Vector length mismatch. Line ${e.line}`);
        if (o === "+=") for (let T = 0; T < m.length; ++T) m[T] += y[T];
        else if (o === "-=") for (let T = 0; T < m.length; ++T) m[T] -= y[T];
        else if (o === "*=") for (let T = 0; T < m.length; ++T) m[T] *= y[T];
        else if (o === "/=") for (let T = 0; T < m.length; ++T) m[T] /= y[T];
        else if (o === "%=") for (let T = 0; T < m.length; ++T) m[T] %= y[T];
        else if (o === "&=") for (let T = 0; T < m.length; ++T) m[T] &= y[T];
        else if (o === "|=") for (let T = 0; T < m.length; ++T) m[T] |= y[T];
        else if (o === "^=") for (let T = 0; T < m.length; ++T) m[T] ^= y[T];
        else if (o === "<<=") for (let T = 0; T < m.length; ++T) m[T] <<= y[T];
        else if (o === ">>=") for (let T = 0; T < m.length; ++T) m[T] >>= y[T];
        else console.error(`Invalid operator ${o}. Line ${e.line}`);
      } else {
        if (!(d instanceof ot && c instanceof ot)) return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);
        o === "+=" ? d.value += c.value : o === "-=" ? d.value -= c.value : o === "*=" ? d.value *= c.value : o === "/=" ? d.value /= c.value : o === "%=" ? d.value %= c.value : o === "&=" ? d.value &= c.value : o === "|=" ? d.value |= c.value : o === "^=" ? d.value ^= c.value : o === "<<=" ? d.value <<= c.value : o === ">>=" ? d.value >>= c.value : console.error(`Invalid operator ${o}. Line ${e.line}`);
      }
      return void (i instanceof cs && i.setDataValue(this, d, s, t));
    }
    if (i instanceof cs) i.setDataValue(this, c, s, t);
    else if (s) {
      if (!(i instanceof Ne || i instanceof ei)) return void console.error(`Variable ${n} is not a vector or matrix. Line ${e.line}`);
      if (s instanceof xp) {
        const d = this.evalExpression(s.index, t).value;
        if (i instanceof Ne) {
          if (!(c instanceof ot)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
          i.data[d] = c.value;
        } else {
          if (!(i instanceof ei)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
          {
            const m = this.evalExpression(s.index, t).value;
            if (m < 0) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
            if (!(c instanceof Ne)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
            {
              const y = i.typeInfo.getTypeName();
              if (y === "mat2x2" || y === "mat2x2f" || y === "mat2x2h") {
                if (!(m < 2 && c.data.length === 2)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[2 * m] = c.data[0], i.data[2 * m + 1] = c.data[1];
              } else if (y === "mat2x3" || y === "mat2x3f" || y === "mat2x3h") {
                if (!(m < 2 && c.data.length === 3)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[3 * m] = c.data[0], i.data[3 * m + 1] = c.data[1], i.data[3 * m + 2] = c.data[2];
              } else if (y === "mat2x4" || y === "mat2x4f" || y === "mat2x4h") {
                if (!(m < 2 && c.data.length === 4)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[4 * m] = c.data[0], i.data[4 * m + 1] = c.data[1], i.data[4 * m + 2] = c.data[2], i.data[4 * m + 3] = c.data[3];
              } else if (y === "mat3x2" || y === "mat3x2f" || y === "mat3x2h") {
                if (!(m < 3 && c.data.length === 2)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[2 * m] = c.data[0], i.data[2 * m + 1] = c.data[1];
              } else if (y === "mat3x3" || y === "mat3x3f" || y === "mat3x3h") {
                if (!(m < 3 && c.data.length === 3)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[3 * m] = c.data[0], i.data[3 * m + 1] = c.data[1], i.data[3 * m + 2] = c.data[2];
              } else if (y === "mat3x4" || y === "mat3x4f" || y === "mat3x4h") {
                if (!(m < 3 && c.data.length === 4)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[4 * m] = c.data[0], i.data[4 * m + 1] = c.data[1], i.data[4 * m + 2] = c.data[2], i.data[4 * m + 3] = c.data[3];
              } else if (y === "mat4x2" || y === "mat4x2f" || y === "mat4x2h") {
                if (!(m < 4 && c.data.length === 2)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[2 * m] = c.data[0], i.data[2 * m + 1] = c.data[1];
              } else if (y === "mat4x3" || y === "mat4x3f" || y === "mat4x3h") {
                if (!(m < 4 && c.data.length === 3)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[3 * m] = c.data[0], i.data[3 * m + 1] = c.data[1], i.data[3 * m + 2] = c.data[2];
              } else {
                if (y !== "mat4x4" && y !== "mat4x4f" && y !== "mat4x4h") return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                if (!(m < 4 && c.data.length === 4)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
                i.data[4 * m] = c.data[0], i.data[4 * m + 1] = c.data[1], i.data[4 * m + 2] = c.data[2], i.data[4 * m + 3] = c.data[3];
              }
            }
          }
        }
      } else if (s instanceof Qf) {
        const d = s.value;
        if (!(i instanceof Ne)) return void console.error(`Invalid assignment to ${d}. Variable ${n} is not a vector. Line ${e.line}`);
        if (c instanceof ot) {
          if (d.length > 1) return void console.error(`Invalid assignment to ${d} for variable ${n}. Line ${e.line}`);
          if (d === "x") i.data[0] = c.value;
          else if (d === "y") {
            if (i.data.length < 2) return void console.error(`Invalid assignment to ${d} for variable ${n}. Line ${e.line}`);
            i.data[1] = c.value;
          } else if (d === "z") {
            if (i.data.length < 3) return void console.error(`Invalid assignment to ${d} for variable ${n}. Line ${e.line}`);
            i.data[2] = c.value;
          } else if (d === "w") {
            if (i.data.length < 4) return void console.error(`Invalid assignment to ${d} for variable ${n}. Line ${e.line}`);
            i.data[3] = c.value;
          }
        } else {
          if (!(c instanceof Ne)) return void console.error(`Invalid assignment to ${n}. Line ${e.line}`);
          if (d.length !== c.data.length) return void console.error(`Invalid assignment to ${d} for variable ${n}. Line ${e.line}`);
          for (let m = 0; m < d.length; ++m) {
            const y = d[m];
            if (y === "x" || y === "r") i.data[0] = c.data[m];
            else if (y === "y" || y === "g") {
              if (c.data.length < 2) return void console.error(`Invalid assignment to ${y} for variable ${n}. Line ${e.line}`);
              i.data[1] = c.data[m];
            } else if (y === "z" || y === "b") {
              if (c.data.length < 3) return void console.error(`Invalid assignment to ${y} for variable ${n}. Line ${e.line}`);
              i.data[2] = c.data[m];
            } else {
              if (y !== "w" && y !== "a") return void console.error(`Invalid assignment to ${y} for variable ${n}. Line ${e.line}`);
              if (c.data.length < 4) return void console.error(`Invalid assignment to ${y} for variable ${n}. Line ${e.line}`);
              i.data[3] = c.data[m];
            }
          }
        }
      }
    } else i instanceof ot && c instanceof ot ? i.value = c.value : i instanceof Ne && c instanceof Ne || i instanceof ei && c instanceof ei ? i.data.set(c.data) : console.error(`Invalid assignment to ${n}. Line ${e.line}`);
  }
  _function(e, t) {
    const i = new q2(e);
    t.functions.set(e.name, i);
  }
  _const(e, t) {
    let i = null;
    e.value !== null && (i = this.evalExpression(e.value, t)), t.createVariable(e.name, i, e);
  }
  _let(e, t) {
    let i = null;
    if (e.value !== null) {
      if (i = this.evalExpression(e.value, t), i === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
      e.value instanceof Ds || (i = i.clone());
    } else {
      const n = e.type.name;
      if (n === "f32" || n === "i32" || n === "u32" || n === "bool" || n === "f16" || n === "vec2" || n === "vec3" || n === "vec4" || n === "vec2f" || n === "vec3f" || n === "vec4f" || n === "vec2i" || n === "vec3i" || n === "vec4i" || n === "vec2u" || n === "vec3u" || n === "vec4u" || n === "vec2h" || n === "vec3h" || n === "vec4h" || n === "vec2b" || n === "vec3b" || n === "vec4b" || n === "mat2x2" || n === "mat2x3" || n === "mat2x4" || n === "mat3x2" || n === "mat3x3" || n === "mat3x4" || n === "mat4x2" || n === "mat4x3" || n === "mat4x4" || n === "mat2x2f" || n === "mat2x3f" || n === "mat2x4f" || n === "mat3x2f" || n === "mat3x3f" || n === "mat3x4f" || n === "mat4x2f" || n === "mat4x3f" || n === "mat4x4f" || n === "mat2x2h" || n === "mat2x3h" || n === "mat2x4h" || n === "mat3x2h" || n === "mat3x3h" || n === "mat3x4h" || n === "mat4x2h" || n === "mat4x3h" || n === "mat4x4h" || n === "array") {
        const s = new pu(e.type, []);
        i = this._evalCreate(s, t);
      }
    }
    t.createVariable(e.name, i, e);
  }
  _var(e, t) {
    let i = null;
    if (e.value !== null) {
      if (i = this.evalExpression(e.value, t), i === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
      e.value instanceof Ds || (i = i.clone());
    } else {
      if (e.type === null) return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);
      const n = e.type.name;
      if (n === "f32" || n === "i32" || n === "u32" || n === "bool" || n === "f16" || n === "vec2" || n === "vec3" || n === "vec4" || n === "vec2f" || n === "vec3f" || n === "vec4f" || n === "vec2i" || n === "vec3i" || n === "vec4i" || n === "vec2u" || n === "vec3u" || n === "vec4u" || n === "vec2h" || n === "vec3h" || n === "vec4h" || n === "vec2b" || n === "vec3b" || n === "vec4b" || n === "mat2x2" || n === "mat2x3" || n === "mat2x4" || n === "mat3x2" || n === "mat3x3" || n === "mat3x4" || n === "mat4x2" || n === "mat4x3" || n === "mat4x4" || n === "mat2x2f" || n === "mat2x3f" || n === "mat2x4f" || n === "mat3x2f" || n === "mat3x3f" || n === "mat3x4f" || n === "mat4x2f" || n === "mat4x3f" || n === "mat4x4f" || n === "mat2x2h" || n === "mat2x3h" || n === "mat2x4h" || n === "mat3x2h" || n === "mat3x3h" || n === "mat3x4h" || n === "mat4x2h" || n === "mat4x3h" || n === "mat4x4h" || e.type instanceof kg || e.type instanceof Qu || e.type instanceof pt) {
        const s = new pu(e.type, []);
        i = this._evalCreate(s, t);
      }
    }
    t.createVariable(e.name, i, e);
  }
  _switch(e, t) {
    t = t.clone();
    const i = this.evalExpression(e.condition, t);
    if (!(i instanceof ot)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    let n = null;
    for (const s of e.cases) if (s instanceof wI) for (const c of s.selectors) {
      if (c instanceof G_) {
        n = s;
        continue;
      }
      const o = this.evalExpression(c, t);
      if (!(o instanceof ot)) return console.error(`Invalid case selector. Line ${e.line}`), null;
      if (o.value === i.value) return this._execStatements(s.body, t);
    }
    else s instanceof AI && (n = s);
    return n ? this._execStatements(n.body, t) : null;
  }
  _if(e, t) {
    t = t.clone();
    const i = this.evalExpression(e.condition, t);
    if (!(i instanceof ot)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    if (i.value) return this._execStatements(e.body, t);
    for (const n of e.elseif) {
      const s = this.evalExpression(n.condition, t);
      if (!(s instanceof ot)) return console.error(`Invalid if condition. Line ${e.line}`), null;
      if (s.value) return this._execStatements(n.body, t);
    }
    return e.else ? this._execStatements(e.else, t) : null;
  }
  _getScalarValue(e) {
    return e instanceof ot ? e.value : (console.error("Expected scalar value.", e), 0);
  }
  _for(e, t) {
    for (t = t.clone(), this.execStatement(e.init, t); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const i = this._execStatements(e.body, t);
      if (i === jo._breakObj) break;
      if (i !== null && i !== jo._continueObj) return i;
      this.execStatement(e.increment, t);
    }
    return null;
  }
  _loop(e, t) {
    for (t = t.clone(); ; ) {
      const i = this._execStatements(e.body, t);
      if (i === jo._breakObj) break;
      if (i === jo._continueObj) {
        if (e.continuing && this._execStatements(e.continuing.body, t) === jo._breakObj)
          break;
      } else if (i !== null) return i;
    }
    return null;
  }
  _while(e, t) {
    for (t = t.clone(); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const i = this._execStatements(e.body, t);
      if (i === jo._breakObj) break;
      if (i !== jo._continueObj && i !== null) return i;
    }
    return null;
  }
  _evalBitcast(e, t) {
    const i = this.evalExpression(e.value, t), n = e.type;
    if (i instanceof ot) {
      const s = OT(i.value, i.typeInfo.name, n.name);
      return new ot(s, this.getTypeInfo(n));
    }
    if (i instanceof Ne) {
      const s = i.typeInfo.getTypeName();
      let c = "";
      if (s.endsWith("f")) c = "f32";
      else if (s.endsWith("i")) c = "i32";
      else if (s.endsWith("u")) c = "u32";
      else if (s.endsWith("b")) c = "bool";
      else {
        if (!s.endsWith("h")) return console.error(`Unknown vector type ${s}. Line ${e.line}`), null;
        c = "f16";
      }
      const o = n.getTypeName();
      let d = "";
      if (o.endsWith("f")) d = "f32";
      else if (o.endsWith("i")) d = "i32";
      else if (o.endsWith("u")) d = "u32";
      else if (o.endsWith("b")) d = "bool";
      else {
        if (!o.endsWith("h")) return console.error(`Unknown vector type ${d}. Line ${e.line}`), null;
        d = "f16";
      }
      const m = function(y, T, P) {
        if (T === P) return y;
        const I = new Array(y.length);
        for (let D = 0; D < y.length; D++) I[D] = OT(y[D], T, P);
        return I;
      }(Array.from(i.data), c, d);
      return new Ne(m, this.getTypeInfo(n));
    }
    return console.error(`TODO: bitcast for ${i.typeInfo.name}. Line ${e.line}`), null;
  }
  _evalConst(e, t) {
    return t.getVariableValue(e.name).clone().getSubData(this, e.postfix, t);
  }
  _evalCreate(e, t) {
    var i;
    if (e instanceof pu) {
      if (e.type === null) return dv.void;
      switch (e.type.getTypeName()) {
        case "bool":
        case "i32":
        case "u32":
        case "f32":
        case "f16":
          return this._callConstructorValue(e, t);
        case "vec2":
        case "vec3":
        case "vec4":
        case "vec2f":
        case "vec3f":
        case "vec4f":
        case "vec2h":
        case "vec3h":
        case "vec4h":
        case "vec2i":
        case "vec3i":
        case "vec4i":
        case "vec2u":
        case "vec3u":
        case "vec4u":
        case "vec2b":
        case "vec3b":
        case "vec4b":
          return this._callConstructorVec(e, t);
        case "mat2x2":
        case "mat2x2f":
        case "mat2x2h":
        case "mat2x3":
        case "mat2x3f":
        case "mat2x3h":
        case "mat2x4":
        case "mat2x4f":
        case "mat2x4h":
        case "mat3x2":
        case "mat3x2f":
        case "mat3x2h":
        case "mat3x3":
        case "mat3x3f":
        case "mat3x3h":
        case "mat3x4":
        case "mat3x4f":
        case "mat3x4h":
        case "mat4x2":
        case "mat4x2f":
        case "mat4x2h":
        case "mat4x3":
        case "mat4x3f":
        case "mat4x3h":
        case "mat4x4":
        case "mat4x4f":
        case "mat4x4h":
          return this._callConstructorMatrix(e, t);
      }
    }
    const n = e instanceof pu ? e.type.name : e.name, s = e instanceof pu ? this.getTypeInfo(e.type) : this.getTypeInfo(e.name);
    if (s === null) return console.error(`Unknown type ${n}. Line ${e.line}`), null;
    if (s.size === 0) return null;
    const c = new cs(new ArrayBuffer(s.size), s, 0);
    if (s instanceof Uh) {
      if (e.args) for (let o = 0; o < e.args.length; ++o) {
        const d = s.members[o], m = e.args[o], y = this.evalExpression(m, t);
        c.setData(this, y, d.type, d.offset, t);
      }
    } else if (s instanceof Gh) {
      let o = 0;
      if (e.args) for (let d = 0; d < e.args.length; ++d) {
        const m = e.args[d], y = this.evalExpression(m, t);
        s.format === null && (((i = y.typeInfo) === null || i === void 0 ? void 0 : i.name) === "x32" ? s.format = this.getTypeInfo("i32") : s.format = y.typeInfo), c.setData(this, y, s.format, o, t), o += s.stride;
      }
    } else console.error(`Unknown type "${n}". Line ${e.line}`);
    return e instanceof pu ? c.getSubData(this, e.postfix, t) : c;
  }
  _evalLiteral(e, t) {
    const i = this.getTypeInfo(e.type), n = i.name;
    return n === "x32" || n === "u32" || n === "f32" || n === "f16" || n === "i32" || n === "bool" ? new ot(e.scalarValue, i) : n === "vec2" || n === "vec3" || n === "vec4" || n === "vec2f" || n === "vec3f" || n === "vec4f" || n === "vec2h" || n === "vec3h" || n === "vec4h" || n === "vec2i" || n === "vec3i" || n === "vec4i" || n === "vec2u" || n === "vec3u" || n === "vec4u" ? this._callConstructorVec(e, t) : n === "mat2x2" || n === "mat2x3" || n === "mat2x4" || n === "mat3x2" || n === "mat3x3" || n === "mat3x4" || n === "mat4x2" || n === "mat4x3" || n === "mat4x4" || n === "mat2x2f" || n === "mat2x3f" || n === "mat2x4f" || n === "mat3x2f" || n === "mat3x3f" || n === "mat3x4f" || n === "mat4x2f" || n === "mat4x3f" || n === "mat4x4f" || n === "mat2x2h" || n === "mat2x3h" || n === "mat2x4h" || n === "mat3x2h" || n === "mat3x3h" || n === "mat3x4h" || n === "mat4x2h" || n === "mat4x3h" || n === "mat4x4h" ? this._callConstructorMatrix(e, t) : e.value;
  }
  _evalVariable(e, t) {
    const i = t.getVariableValue(e.name);
    return i === null ? i : i.getSubData(this, e.postfix, t);
  }
  _maxFormatTypeInfo(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let i = 1; i < e.length; ++i) {
      const n = jo._priority.get(t.name);
      jo._priority.get(e[i].name) < n && (t = e[i]);
    }
    return t.name === "x32" ? this.getTypeInfo("i32") : t;
  }
  _evalUnaryOp(e, t) {
    const i = this.evalExpression(e.right, t);
    if (e.operator === "&") return new zd(i);
    if (e.operator === "*") return i instanceof zd ? i.reference.getSubData(this, e.postfix, t) : (console.error(`Invalid dereference. Line ${e.line}`), null);
    const n = i instanceof ot ? i.value : i instanceof Ne ? Array.from(i.data) : null;
    switch (e.operator) {
      case "+": {
        if (gr(n)) {
          const o = n.map((d, m) => +d);
          return new Ne(o, i.typeInfo);
        }
        const s = n, c = this._maxFormatTypeInfo([i.typeInfo, i.typeInfo]);
        return new ot(+s, c);
      }
      case "-": {
        if (gr(n)) {
          const o = n.map((d, m) => -d);
          return new Ne(o, i.typeInfo);
        }
        const s = n, c = this._maxFormatTypeInfo([i.typeInfo, i.typeInfo]);
        return new ot(-s, c);
      }
      case "!": {
        if (gr(n)) {
          const o = n.map((d, m) => d ? 0 : 1);
          return new Ne(o, i.typeInfo);
        }
        const s = n, c = this._maxFormatTypeInfo([i.typeInfo, i.typeInfo]);
        return new ot(s ? 0 : 1, c);
      }
      case "~": {
        if (gr(n)) {
          const o = n.map((d, m) => ~d);
          return new Ne(o, i.typeInfo);
        }
        const s = n, c = this._maxFormatTypeInfo([i.typeInfo, i.typeInfo]);
        return new ot(~s, c);
      }
    }
    return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalBinaryOp(e, t) {
    const i = this.evalExpression(e.left, t), n = this.evalExpression(e.right, t), s = i instanceof ot ? i.value : i instanceof Ne || i instanceof ei ? Array.from(i.data) : null, c = n instanceof ot ? n.value : n instanceof Ne || n instanceof ei ? Array.from(n.data) : null;
    switch (e.operator) {
      case "+": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I + T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P + y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y + P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o + d, m);
      }
      case "-": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I - T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P - y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y - P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o - d, m);
      }
      case "*": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (i instanceof ei && n instanceof ei) {
            const P = function($, G, te, Z) {
              if (ua[G.name] === void 0 || ua[Z.name] === void 0) return null;
              const H = ua[G.name][0], J = ua[G.name][1], re = ua[Z.name][0];
              if (H !== ua[Z.name][1]) return null;
              const be = new Array(re * J);
              for (let pe = 0; pe < J; pe++) for (let oe = 0; oe < re; oe++) {
                let Ee = 0;
                for (let le = 0; le < H; le++) Ee += $[le * J + pe] * te[oe * H + le];
                be[pe * re + oe] = Ee;
              }
              return be;
            }(y, i.typeInfo, T, n.typeInfo);
            if (P === null) return console.error(`Matrix multiplication failed. Line ${e.line}.`), null;
            const I = ua[n.typeInfo.name][0], D = ua[i.typeInfo.name][1], k = this.getTypeInfo(`mat${I}x${D}f`);
            return new ei(P, k);
          }
          if (i instanceof ei && n instanceof Ne) {
            const P = function(I, D, k, $) {
              if (ua[D.name] === void 0 || wb[$.name] === void 0) return null;
              const G = ua[D.name][0], te = ua[D.name][1];
              if (G !== k.length) return null;
              const Z = new Array(te);
              for (let H = 0; H < te; H++) {
                let J = 0;
                for (let re = 0; re < G; re++) J += I[re * te + H] * k[re];
                Z[H] = J;
              }
              return Z;
            }(y, i.typeInfo, T, n.typeInfo);
            return P === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new Ne(P, n.typeInfo);
          }
          if (i instanceof Ne && n instanceof ei) {
            const P = function(I, D, k, $) {
              if (wb[D.name] === void 0 || ua[$.name] === void 0) return null;
              const G = ua[$.name][0], te = ua[$.name][1];
              if (te !== I.length) return null;
              const Z = [];
              for (let H = 0; H < G; H++) {
                let J = 0;
                for (let re = 0; re < te; re++) J += I[re] * k[re * G + H];
                Z[H] = J;
              }
              return Z;
            }(y, i.typeInfo, T, n.typeInfo);
            return P === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new Ne(P, i.typeInfo);
          }
          {
            if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const P = y.map((I, D) => I * T[D]);
            return new Ne(P, i.typeInfo);
          }
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P * y);
          return i instanceof ei ? new ei(T, i.typeInfo) : new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y * P);
          return n instanceof ei ? new ei(T, n.typeInfo) : new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o * d, m);
      }
      case "%": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I % T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P % y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y % P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o % d, m);
      }
      case "/": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I / T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P / y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y / P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o / d, m);
      }
      case "&": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I & T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P & y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y & P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o & d, m);
      }
      case "|": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I | T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P | y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y | P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o | d, m);
      }
      case "^": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I ^ T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P ^ y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y ^ P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o ^ d, m);
      }
      case "<<": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I << T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P << y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y << P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o << d, m);
      }
      case ">>": {
        if (gr(s) && gr(c)) {
          const y = s, T = c;
          if (y.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((I, D) => I >> T[D]);
          return new Ne(P, i.typeInfo);
        }
        if (gr(s)) {
          const y = c, T = s.map((P, I) => P >> y);
          return new Ne(T, i.typeInfo);
        }
        if (gr(c)) {
          const y = s, T = c.map((P, I) => y >> P);
          return new Ne(T, n.typeInfo);
        }
        const o = s, d = c, m = this._maxFormatTypeInfo([i.typeInfo, n.typeInfo]);
        return new ot(o >> d, m);
      }
      case ">":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y > d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m > o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o > m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s > c ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y < d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m < o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o < m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s < c ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y === d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m == o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o == m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s === c ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y !== d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m !== o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o !== m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s !== c ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y >= d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m >= o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o >= m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s >= c ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y <= d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m <= o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o <= m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s <= c ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y && d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m && o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o && m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s && c ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (gr(s) && gr(c)) {
          const o = s, d = c;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((y, T) => y || d[T] ? 1 : 0);
          return new Ne(m, i.typeInfo);
        }
        if (gr(s)) {
          const o = c, d = s.map((m, y) => m || o ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        if (gr(c)) {
          const o = s, d = c.map((m, y) => o || m ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        return new ot(s || c ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalCall(e, t) {
    if (e.cachedReturnValue !== null) return e.cachedReturnValue;
    const i = t.clone();
    i.currentFunctionName = e.name;
    const n = t.getFunction(e.name);
    if (!n)
      return e.isBuiltin ? this._callBuiltinFunction(e, i) : this.getTypeInfo(e.name) ? this._evalCreate(e, t) : (console.error(`Unknown function "${e.name}". Line ${e.line}`), null);
    for (let s = 0; s < n.node.args.length; ++s) {
      const c = n.node.args[s], o = this.evalExpression(e.args[s], i);
      i.createVariable(c.name, o, c);
    }
    return this._execStatements(n.node.body, i);
  }
  _callBuiltinFunction(e, t) {
    switch (e.name) {
      case "all":
        return this.builtins.All(e, t);
      case "any":
        return this.builtins.Any(e, t);
      case "select":
        return this.builtins.Select(e, t);
      case "arrayLength":
        return this.builtins.ArrayLength(e, t);
      case "abs":
        return this.builtins.Abs(e, t);
      case "acos":
        return this.builtins.Acos(e, t);
      case "acosh":
        return this.builtins.Acosh(e, t);
      case "asin":
        return this.builtins.Asin(e, t);
      case "asinh":
        return this.builtins.Asinh(e, t);
      case "atan":
        return this.builtins.Atan(e, t);
      case "atanh":
        return this.builtins.Atanh(e, t);
      case "atan2":
        return this.builtins.Atan2(e, t);
      case "ceil":
        return this.builtins.Ceil(e, t);
      case "clamp":
        return this.builtins.Clamp(e, t);
      case "cos":
        return this.builtins.Cos(e, t);
      case "cosh":
        return this.builtins.Cosh(e, t);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(e, t);
      case "countOneBits":
        return this.builtins.CountOneBits(e, t);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(e, t);
      case "cross":
        return this.builtins.Cross(e, t);
      case "degrees":
        return this.builtins.Degrees(e, t);
      case "determinant":
        return this.builtins.Determinant(e, t);
      case "distance":
        return this.builtins.Distance(e, t);
      case "dot":
        return this.builtins.Dot(e, t);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(e, t);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(e, t);
      case "exp":
        return this.builtins.Exp(e, t);
      case "exp2":
        return this.builtins.Exp2(e, t);
      case "extractBits":
        return this.builtins.ExtractBits(e, t);
      case "faceForward":
        return this.builtins.FaceForward(e, t);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(e, t);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(e, t);
      case "floor":
        return this.builtins.Floor(e, t);
      case "fma":
        return this.builtins.Fma(e, t);
      case "fract":
        return this.builtins.Fract(e, t);
      case "frexp":
        return this.builtins.Frexp(e, t);
      case "insertBits":
        return this.builtins.InsertBits(e, t);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(e, t);
      case "ldexp":
        return this.builtins.Ldexp(e, t);
      case "length":
        return this.builtins.Length(e, t);
      case "log":
        return this.builtins.Log(e, t);
      case "log2":
        return this.builtins.Log2(e, t);
      case "max":
        return this.builtins.Max(e, t);
      case "min":
        return this.builtins.Min(e, t);
      case "mix":
        return this.builtins.Mix(e, t);
      case "modf":
        return this.builtins.Modf(e, t);
      case "normalize":
        return this.builtins.Normalize(e, t);
      case "pow":
        return this.builtins.Pow(e, t);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(e, t);
      case "radians":
        return this.builtins.Radians(e, t);
      case "reflect":
        return this.builtins.Reflect(e, t);
      case "refract":
        return this.builtins.Refract(e, t);
      case "reverseBits":
        return this.builtins.ReverseBits(e, t);
      case "round":
        return this.builtins.Round(e, t);
      case "saturate":
        return this.builtins.Saturate(e, t);
      case "sign":
        return this.builtins.Sign(e, t);
      case "sin":
        return this.builtins.Sin(e, t);
      case "sinh":
        return this.builtins.Sinh(e, t);
      case "smoothstep":
        return this.builtins.SmoothStep(e, t);
      case "sqrt":
        return this.builtins.Sqrt(e, t);
      case "step":
        return this.builtins.Step(e, t);
      case "tan":
        return this.builtins.Tan(e, t);
      case "tanh":
        return this.builtins.Tanh(e, t);
      case "transpose":
        return this.builtins.Transpose(e, t);
      case "trunc":
        return this.builtins.Trunc(e, t);
      case "dpdx":
        return this.builtins.Dpdx(e, t);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(e, t);
      case "dpdxFine":
        return this.builtins.DpdxFine(e, t);
      case "dpdy":
        return this.builtins.Dpdy(e, t);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(e, t);
      case "dpdyFine":
        return this.builtins.DpdyFine(e, t);
      case "fwidth":
        return this.builtins.Fwidth(e, t);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(e, t);
      case "fwidthFine":
        return this.builtins.FwidthFine(e, t);
      case "textureDimensions":
        return this.builtins.TextureDimensions(e, t);
      case "textureGather":
        return this.builtins.TextureGather(e, t);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(e, t);
      case "textureLoad":
        return this.builtins.TextureLoad(e, t);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(e, t);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(e, t);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(e, t);
      case "textureSample":
        return this.builtins.TextureSample(e, t);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(e, t);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(e, t);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(e, t);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(e, t);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(e, t);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(e, t);
      case "textureStore":
        return this.builtins.TextureStore(e, t);
      case "atomicLoad":
        return this.builtins.AtomicLoad(e, t);
      case "atomicStore":
        return this.builtins.AtomicStore(e, t);
      case "atomicAdd":
        return this.builtins.AtomicAdd(e, t);
      case "atomicSub":
        return this.builtins.AtomicSub(e, t);
      case "atomicMax":
        return this.builtins.AtomicMax(e, t);
      case "atomicMin":
        return this.builtins.AtomicMin(e, t);
      case "atomicAnd":
        return this.builtins.AtomicAnd(e, t);
      case "atomicOr":
        return this.builtins.AtomicOr(e, t);
      case "atomicXor":
        return this.builtins.AtomicXor(e, t);
      case "atomicExchange":
        return this.builtins.AtomicExchange(e, t);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(e, t);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(e, t);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(e, t);
      case "pack4xI8":
        return this.builtins.Pack4xI8(e, t);
      case "pack4xU8":
        return this.builtins.Pack4xU8(e, t);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(e, t);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(e, t);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(e, t);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(e, t);
      case "pack2x16float":
        return this.builtins.Pack2x16float(e, t);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(e, t);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(e, t);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(e, t);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(e, t);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(e, t);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(e, t);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(e, t);
      case "storageBarrier":
        return this.builtins.StorageBarrier(e, t);
      case "textureBarrier":
        return this.builtins.TextureBarrier(e, t);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(e, t);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(e, t);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(e, t);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(e, t);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(e, t);
      case "subgroupAll":
        return this.builtins.SubgroupAll(e, t);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(e, t);
      case "subgroupAny":
        return this.builtins.SubgroupAny(e, t);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(e, t);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(e, t);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(e, t);
      case "subgroupElect":
        return this.builtins.SubgroupElect(e, t);
      case "subgroupMax":
        return this.builtins.SubgroupMax(e, t);
      case "subgroupMin":
        return this.builtins.SubgroupMin(e, t);
      case "subgroupMul":
        return this.builtins.SubgroupMul(e, t);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(e, t);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(e, t);
      case "subgroupOr":
        return this.builtins.SubgroupOr(e, t);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(e, t);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(e, t);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(e, t);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(e, t);
      case "subgroupXor":
        return this.builtins.SubgroupXor(e, t);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(e, t);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(e, t);
      case "quadSwapX":
        return this.builtins.QuadSwapX(e, t);
      case "quadSwapY":
        return this.builtins.QuadSwapY(e, t);
    }
    const i = t.getFunction(e.name);
    if (i) {
      const n = t.clone();
      for (let s = 0; s < i.node.args.length; ++s) {
        const c = i.node.args[s], o = this.evalExpression(e.args[s], n);
        n.setVariable(c.name, o, c);
      }
      return this._execStatements(i.node.body, n);
    }
    return null;
  }
  _callConstructorValue(e, t) {
    if (!e.args || e.args.length === 0) return new ot(0, this.getTypeInfo(e.type));
    const i = this.evalExpression(e.args[0], t);
    return i.typeInfo = this.getTypeInfo(e.type), i.getSubData(this, e.postfix, t).clone();
  }
  _callConstructorVec(e, t) {
    const i = this.getTypeInfo(e.type), n = e.type.getTypeName(), s = wb[n];
    if (s === void 0) return console.error(`Invalid vec constructor ${n}. Line ${e.line}`), null;
    const c = [];
    if (e instanceof Ys)
      if (e.isVector) {
        const o = e.vectorValue;
        for (const d of o) c.push(d);
      } else c.push(e.scalarValue);
    else if (e.args) for (const o of e.args) {
      const d = this.evalExpression(o, t);
      if (d instanceof Ne) {
        const m = d.data;
        for (let y = 0; y < m.length; ++y) {
          let T = m[y];
          c.push(T);
        }
      } else if (d instanceof ot) {
        let m = d.value;
        c.push(m);
      }
    }
    if (e.type instanceof pt && e.type.format === null && (e.type.format = pt.f32), c.length === 0) {
      const o = new Array(s).fill(0);
      return new Ne(o, i).getSubData(this, e.postfix, t);
    }
    if (c.length === 1) for (; c.length < s; ) c.push(c[0]);
    return c.length < s ? (console.error(`Invalid vec constructor. Line ${e.line}`), null) : new Ne(c.length > s ? c.slice(0, s) : c, i).getSubData(this, e.postfix, t);
  }
  _callConstructorMatrix(e, t) {
    const i = this.getTypeInfo(e.type), n = e.type.getTypeName(), s = ua[n];
    if (s === void 0) return console.error(`Invalid matrix constructor ${n}. Line ${e.line}`), null;
    const c = [];
    if (e instanceof Ys)
      if (e.isVector) {
        const o = e.vectorValue;
        for (const d of o) c.push(d);
      } else c.push(e.scalarValue);
    else if (e.args) for (const o of e.args) {
      const d = this.evalExpression(o, t);
      d instanceof Ne ? c.push(...d.data) : d instanceof ot ? c.push(d.value) : d instanceof ei && c.push(...d.data);
    }
    if (i instanceof Kf && i.format === null && (i.format = this.getTypeInfo("f32")), c.length === 0) {
      const o = new Array(s[2]).fill(0);
      return new ei(o, i).getSubData(this, e.postfix, t);
    }
    return c.length !== s[2] ? (console.error(`Invalid matrix constructor. Line ${e.line}`), null) : new ei(c, i).getSubData(this, e.postfix, t);
  }
}
jo._breakObj = new wu(new Dl("BREAK", null), null), jo._continueObj = new wu(new Dl("CONTINUE", null), null), jo._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class SN {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class EN {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new SN(), this._exec = new jo(), this._forwardTypeCount = 0;
  }
  parse(e) {
    this._initialize(e), this._deferArrayCountEval.length = 0;
    const t = [];
    for (; !this._isAtEnd(); ) {
      const i = this._global_decl_or_directive();
      if (!i) break;
      t.push(i);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const i of this._deferArrayCountEval) {
        const n = i.arrayType, s = i.countNode;
        if (s instanceof il) {
          const c = s.name, o = this._context.constants.get(c);
          if (o) try {
            const d = o.constEvaluate(this._exec);
            n.count = d;
          } catch {
          }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    if (this._forwardTypeCount > 0) for (const i of t) i.search((n) => {
      n instanceof BT || n instanceof V_ ? n.type = this._forwardType(n.type) : n instanceof kg ? n.format = this._forwardType(n.format) : n instanceof rh || n instanceof Bg || n instanceof j_ ? n.type = this._forwardType(n.type) : n instanceof Wg ? n.returnType = this._forwardType(n.returnType) : n instanceof LT && (n.type = this._forwardType(n.type));
    });
    return t;
  }
  _forwardType(e) {
    if (e instanceof RT) {
      const t = this._getType(e.name);
      if (t) return t;
    } else e instanceof V_ ? e.type = this._forwardType(e.type) : e instanceof kg && (e.format = this._forwardType(e.format));
    return e;
  }
  _initialize(e) {
    if (e)
      if (typeof e == "string") {
        const t = new gN(e);
        this._tokens = t.scanTokens();
      } else this._tokens = e;
    else this._tokens = [];
    this._current = 0;
  }
  _updateNode(e, t) {
    return e.line = t ?? this._currentLine, e;
  }
  _error(e, t) {
    return {
      token: e,
      message: t,
      toString: () => `${t}`
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == Ce.eof;
  }
  _match(e) {
    if (e instanceof ct) return !!this._check(e) && (this._advance(), !0);
    for (let t = 0, i = e.length; t < i; ++t) {
      const n = e[t];
      if (this._check(n)) return this._advance(), !0;
    }
    return !1;
  }
  _consume(e, t) {
    if (this._check(e)) return this._advance();
    throw this._error(this._peek(), `${t}. Line:${this._currentLine}`);
  }
  _check(e) {
    if (this._isAtEnd()) return !1;
    const t = this._peek();
    if (e instanceof Array) {
      const i = t.type;
      let n = !1;
      for (const s of e) {
        if (i === s) return !0;
        s === Ce.tokens.name && (n = !0);
      }
      if (n) {
        const s = Ce.tokens.name.rule.exec(t.lexeme);
        if (s && s.index == 0 && s[0] == t.lexeme) return !0;
      }
      return !1;
    }
    if (t.type === e) return !0;
    if (e === Ce.tokens.name) {
      const i = Ce.tokens.name.rule.exec(t.lexeme);
      return i && i.index == 0 && i[0] == t.lexeme;
    }
    return !1;
  }
  _advance() {
    var e, t;
    return this._currentLine = (t = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && t !== void 0 ? t : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(Ce.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._match(Ce.keywords.alias)) {
      const t = this._type_alias();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ce.keywords.diagnostic)) {
      const t = this._diagnostic();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ce.keywords.requires)) {
      const t = this._requires_directive();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ce.keywords.enable)) {
      const t = this._enable_directive();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    const e = this._attribute();
    if (this._check(Ce.keywords.var)) {
      const t = this._global_variable_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.override)) {
      const t = this._override_variable_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.let)) {
      const t = this._global_let_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.const)) {
      const t = this._global_const_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.struct)) {
      const t = this._struct_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.fn)) {
      const t = this._function_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(Ce.keywords.fn)) return null;
    const e = this._currentLine, t = this._consume(Ce.tokens.ident, "Expected function name.").toString();
    this._consume(Ce.tokens.paren_left, "Expected '(' for function arguments.");
    const i = [];
    if (!this._check(Ce.tokens.paren_right)) do {
      if (this._check(Ce.tokens.paren_right)) break;
      const o = this._attribute(), d = this._consume(Ce.tokens.name, "Expected argument name.").toString();
      this._consume(Ce.tokens.colon, "Expected ':' for argument type.");
      const m = this._attribute(), y = this._type_decl();
      y != null && (y.attributes = m, i.push(this._updateNode(new LT(d, y, o))));
    } while (this._match(Ce.tokens.comma));
    this._consume(Ce.tokens.paren_right, "Expected ')' after function arguments.");
    let n = null;
    if (this._match(Ce.tokens.arrow)) {
      const o = this._attribute();
      n = this._type_decl(), n != null && (n.attributes = o);
    }
    const s = this._compound_statement(), c = this._currentLine;
    return this._updateNode(new Wg(t, i, n, s, e, c), e);
  }
  _compound_statement() {
    const e = [];
    for (this._consume(Ce.tokens.brace_left, "Expected '{' for block."); !this._check(Ce.tokens.brace_right); ) {
      const t = this._statement();
      t !== null && e.push(t);
    }
    return this._consume(Ce.tokens.brace_right, "Expected '}' for block."), e;
  }
  _statement() {
    for (; this._match(Ce.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._check(Ce.tokens.attr) && this._attribute(), this._check(Ce.keywords.if)) return this._if_statement();
    if (this._check(Ce.keywords.switch)) return this._switch_statement();
    if (this._check(Ce.keywords.loop)) return this._loop_statement();
    if (this._check(Ce.keywords.for)) return this._for_statement();
    if (this._check(Ce.keywords.while)) return this._while_statement();
    if (this._check(Ce.keywords.continuing)) return this._continuing_statement();
    if (this._check(Ce.keywords.static_assert)) return this._static_assert_statement();
    if (this._check(Ce.tokens.brace_left)) return this._compound_statement();
    let e = null;
    if (this._check(Ce.keywords.return)) e = this._return_statement();
    else if (this._check([Ce.keywords.var, Ce.keywords.let, Ce.keywords.const])) e = this._variable_statement();
    else if (this._match(Ce.keywords.discard)) e = this._updateNode(new fN());
    else if (this._match(Ce.keywords.break)) {
      const t = this._updateNode(new mI());
      if (this._currentLoop.length > 0) {
        const i = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = i.id;
      }
      e = t, this._check(Ce.keywords.if) && (this._advance(), t.condition = this._optional_paren_expression());
    } else if (this._match(Ce.keywords.continue)) {
      const t = this._updateNode(new _I());
      if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t.line}`);
      {
        const i = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = i.id;
      }
      e = t;
    } else e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    return e != null && this._consume(Ce.tokens.semicolon, "Expected ';' after statement."), e;
  }
  _static_assert_statement() {
    if (!this._match(Ce.keywords.static_assert)) return null;
    const e = this._currentLine, t = this._optional_paren_expression();
    return this._updateNode(new cN(t), e);
  }
  _while_statement() {
    if (!this._match(Ce.keywords.while)) return null;
    const e = this._updateNode(new aI(null, null));
    return this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Ce.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _continuing_statement() {
    const e = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
    if (!this._match(Ce.keywords.continuing)) return null;
    const t = this._currentLine, i = this._compound_statement();
    return this._updateNode(new fv(i, e), t);
  }
  _for_statement() {
    if (!this._match(Ce.keywords.for)) return null;
    this._consume(Ce.tokens.paren_left, "Expected '('.");
    const e = this._updateNode(new lI(null, null, null, null));
    return this._currentLoop.push(e), e.init = this._check(Ce.tokens.semicolon) ? null : this._for_init(), this._consume(Ce.tokens.semicolon, "Expected ';'."), e.condition = this._check(Ce.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(Ce.tokens.semicolon, "Expected ';'."), e.increment = this._check(Ce.tokens.paren_right) ? null : this._for_increment(), this._consume(Ce.tokens.paren_right, "Expected ')'."), this._check(Ce.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(Ce.keywords.var)) {
      const e = this._variable_decl();
      if (e === null) throw this._error(this._peek(), "Variable declaration expected.");
      let t = null;
      return this._match(Ce.tokens.equal) && (t = this._short_circuit_or_expression()), this._updateNode(new rh(e.name, e.type, e.storage, e.access, t), e.line);
    }
    if (this._match(Ce.keywords.let)) {
      const e = this._currentLine, t = this._consume(Ce.tokens.name, "Expected name for let.").toString();
      let i = null;
      if (this._match(Ce.tokens.colon)) {
        const s = this._attribute();
        i = this._type_decl(), i != null && (i.attributes = s);
      }
      this._consume(Ce.tokens.equal, "Expected '=' for let.");
      const n = this._short_circuit_or_expression();
      return this._updateNode(new Bg(t, i, null, null, n), e);
    }
    if (this._match(Ce.keywords.const)) {
      const e = this._currentLine, t = this._consume(Ce.tokens.name, "Expected name for const.").toString();
      let i = null;
      if (this._match(Ce.tokens.colon)) {
        const s = this._attribute();
        i = this._type_decl(), i != null && (i.attributes = s);
      }
      this._consume(Ce.tokens.equal, "Expected '=' for const.");
      const n = this._short_circuit_or_expression();
      return i === null && n instanceof Ys && (i = n.type), this._updateNode(new j_(t, i, null, null, n), e);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e = this._current, t = this._unary_expression();
    if (t == null) return null;
    if (!this._check(Ce.increment_operators)) return this._current = e, null;
    const i = this._consume(Ce.increment_operators, "Expected increment operator");
    return this._updateNode(new cI(i.type === Ce.tokens.plus_plus ? ep.increment : ep.decrement, t));
  }
  _assignment_statement() {
    let e = null;
    const t = this._currentLine;
    if (this._check(Ce.tokens.brace_right)) return null;
    let i = this._match(Ce.tokens.underscore);
    if (i || (e = this._unary_expression()), !i && e == null) return null;
    const n = this._consume(Ce.assignment_operators, "Expected assignment operator."), s = this._short_circuit_or_expression();
    return this._updateNode(new uI(wg.parse(n.lexeme), e, s), t);
  }
  _func_call_statement() {
    if (!this._check(Ce.tokens.ident)) return null;
    const e = this._currentLine, t = this._current, i = this._consume(Ce.tokens.ident, "Expected function name."), n = this._argument_expression_list();
    return n === null ? (this._current = t, null) : this._updateNode(new j2(i.lexeme, n), e);
  }
  _loop_statement() {
    if (!this._match(Ce.keywords.loop)) return null;
    this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Expected '{' for loop.");
    const e = this._updateNode(new hI([], null));
    this._currentLoop.push(e);
    let t = this._statement();
    for (; t !== null; ) {
      if (Array.isArray(t)) for (let i of t) e.body.push(i);
      else e.body.push(t);
      if (t instanceof fv) {
        e.continuing = t;
        break;
      }
      t = this._statement();
    }
    return this._currentLoop.pop(), this._consume(Ce.tokens.brace_right, "Expected '}' for loop."), e;
  }
  _switch_statement() {
    if (!this._match(Ce.keywords.switch)) return null;
    const e = this._updateNode(new fI(null, []));
    if (this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Expected '{' for switch."), e.cases = this._switch_body(), e.cases == null || e.cases.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(Ce.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e;
  }
  _switch_body() {
    const e = [];
    let t = !1;
    for (; this._check([Ce.keywords.default, Ce.keywords.case]); ) {
      if (this._match(Ce.keywords.case)) {
        const i = this._case_selectors();
        for (const s of i) if (s instanceof G_) {
          if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
          t = !0;
          break;
        }
        this._match(Ce.tokens.colon), this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Exected '{' for switch case.");
        const n = this._case_body();
        this._consume(Ce.tokens.brace_right, "Exected '}' for switch case."), e.push(this._updateNode(new wI(i, n)));
      }
      if (this._match(Ce.keywords.default)) {
        if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
        this._match(Ce.tokens.colon), this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Exected '{' for switch default.");
        const i = this._case_body();
        this._consume(Ce.tokens.brace_right, "Exected '}' for switch default."), e.push(this._updateNode(new AI(i)));
      }
    }
    return e;
  }
  _case_selectors() {
    const e = [];
    for (this._match(Ce.keywords.default) ? e.push(this._updateNode(new G_())) : e.push(this._shift_expression()); this._match(Ce.tokens.comma); ) this._match(Ce.keywords.default) ? e.push(this._updateNode(new G_())) : e.push(this._shift_expression());
    return e;
  }
  _case_body() {
    if (this._match(Ce.keywords.fallthrough)) return this._consume(Ce.tokens.semicolon, "Expected ';'"), [];
    let e = this._statement();
    if (e == null) return [];
    e instanceof Array || (e = [e]);
    const t = this._case_body();
    return t.length == 0 ? e : [...e, t[0]];
  }
  _if_statement() {
    if (!this._match(Ce.keywords.if)) return null;
    const e = this._currentLine, t = this._optional_paren_expression();
    this._check(Ce.tokens.attr) && this._attribute();
    const i = this._compound_statement();
    let n = [];
    this._match_elseif() && (this._check(Ce.tokens.attr) && this._attribute(), n = this._elseif_statement(n));
    let s = null;
    return this._match(Ce.keywords.else) && (this._check(Ce.tokens.attr) && this._attribute(), s = this._compound_statement()), this._updateNode(new dI(t, i, n, s), e);
  }
  _match_elseif() {
    return this._tokens[this._current].type === Ce.keywords.else && this._tokens[this._current + 1].type === Ce.keywords.if && (this._advance(), this._advance(), !0);
  }
  _elseif_statement(e = []) {
    const t = this._optional_paren_expression(), i = this._compound_statement();
    return e.push(this._updateNode(new dN(t, i))), this._match_elseif() && (this._check(Ce.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
  }
  _return_statement() {
    if (!this._match(Ce.keywords.return)) return null;
    const e = this._short_circuit_or_expression();
    return this._updateNode(new pI(e));
  }
  _short_circuit_or_expression() {
    let e = this._short_circuit_and_expr();
    for (; this._match(Ce.tokens.or_or); ) e = this._updateNode(new gc(this._previous().toString(), e, this._short_circuit_and_expr()));
    return e;
  }
  _short_circuit_and_expr() {
    let e = this._inclusive_or_expression();
    for (; this._match(Ce.tokens.and_and); ) e = this._updateNode(new gc(this._previous().toString(), e, this._inclusive_or_expression()));
    return e;
  }
  _inclusive_or_expression() {
    let e = this._exclusive_or_expression();
    for (; this._match(Ce.tokens.or); ) e = this._updateNode(new gc(this._previous().toString(), e, this._exclusive_or_expression()));
    return e;
  }
  _exclusive_or_expression() {
    let e = this._and_expression();
    for (; this._match(Ce.tokens.xor); ) e = this._updateNode(new gc(this._previous().toString(), e, this._and_expression()));
    return e;
  }
  _and_expression() {
    let e = this._equality_expression();
    for (; this._match(Ce.tokens.and); ) e = this._updateNode(new gc(this._previous().toString(), e, this._equality_expression()));
    return e;
  }
  _equality_expression() {
    const e = this._relational_expression();
    return this._match([Ce.tokens.equal_equal, Ce.tokens.not_equal]) ? this._updateNode(new gc(this._previous().toString(), e, this._relational_expression())) : e;
  }
  _relational_expression() {
    let e = this._shift_expression();
    for (; this._match([Ce.tokens.less_than, Ce.tokens.greater_than, Ce.tokens.less_than_equal, Ce.tokens.greater_than_equal]); ) e = this._updateNode(new gc(this._previous().toString(), e, this._shift_expression()));
    return e;
  }
  _shift_expression() {
    let e = this._additive_expression();
    for (; this._match([Ce.tokens.shift_left, Ce.tokens.shift_right]); ) e = this._updateNode(new gc(this._previous().toString(), e, this._additive_expression()));
    return e;
  }
  _additive_expression() {
    let e = this._multiplicative_expression();
    for (; this._match([Ce.tokens.plus, Ce.tokens.minus]); ) e = this._updateNode(new gc(this._previous().toString(), e, this._multiplicative_expression()));
    return e;
  }
  _multiplicative_expression() {
    let e = this._unary_expression();
    for (; this._match([Ce.tokens.star, Ce.tokens.forward_slash, Ce.tokens.modulo]); ) e = this._updateNode(new gc(this._previous().toString(), e, this._unary_expression()));
    return e;
  }
  _unary_expression() {
    return this._match([Ce.tokens.minus, Ce.tokens.bang, Ce.tokens.tilde, Ce.tokens.star, Ce.tokens.and]) ? this._updateNode(new Ds(this._previous().toString(), this._unary_expression())) : this._singular_expression();
  }
  _singular_expression() {
    const e = this._primary_expression(), t = this._postfix_expression();
    return t && (e.postfix = t), e;
  }
  _postfix_expression() {
    if (this._match(Ce.tokens.bracket_left)) {
      const e = this._short_circuit_or_expression();
      this._consume(Ce.tokens.bracket_right, "Expected ']'.");
      const t = this._updateNode(new xp(e)), i = this._postfix_expression();
      return i && (t.postfix = i), t;
    }
    if (this._match(Ce.tokens.period)) {
      const e = this._consume(Ce.tokens.name, "Expected member name."), t = this._postfix_expression(), i = this._updateNode(new Qf(e.lexeme));
      return t && (i.postfix = t), i;
    }
    return null;
  }
  _getStruct(e) {
    return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
  }
  _getType(e) {
    const t = this._getStruct(e);
    if (t !== null) return t;
    switch (e) {
      case "void":
        return $t.void;
      case "bool":
        return $t.bool;
      case "i32":
        return $t.i32;
      case "u32":
        return $t.u32;
      case "f32":
        return $t.f32;
      case "f16":
        return $t.f16;
      case "vec2f":
        return pt.vec2f;
      case "vec3f":
        return pt.vec3f;
      case "vec4f":
        return pt.vec4f;
      case "vec2i":
        return pt.vec2i;
      case "vec3i":
        return pt.vec3i;
      case "vec4i":
        return pt.vec4i;
      case "vec2u":
        return pt.vec2u;
      case "vec3u":
        return pt.vec3u;
      case "vec4u":
        return pt.vec4u;
      case "vec2h":
        return pt.vec2h;
      case "vec3h":
        return pt.vec3h;
      case "vec4h":
        return pt.vec4h;
      case "mat2x2f":
        return pt.mat2x2f;
      case "mat2x3f":
        return pt.mat2x3f;
      case "mat2x4f":
        return pt.mat2x4f;
      case "mat3x2f":
        return pt.mat3x2f;
      case "mat3x3f":
        return pt.mat3x3f;
      case "mat3x4f":
        return pt.mat3x4f;
      case "mat4x2f":
        return pt.mat4x2f;
      case "mat4x3f":
        return pt.mat4x3f;
      case "mat4x4f":
        return pt.mat4x4f;
      case "mat2x2h":
        return pt.mat2x2h;
      case "mat2x3h":
        return pt.mat2x3h;
      case "mat2x4h":
        return pt.mat2x4h;
      case "mat3x2h":
        return pt.mat3x2h;
      case "mat3x3h":
        return pt.mat3x3h;
      case "mat3x4h":
        return pt.mat3x4h;
      case "mat4x2h":
        return pt.mat4x2h;
      case "mat4x3h":
        return pt.mat4x3h;
      case "mat4x4h":
        return pt.mat4x4h;
      case "mat2x2i":
        return pt.mat2x2i;
      case "mat2x3i":
        return pt.mat2x3i;
      case "mat2x4i":
        return pt.mat2x4i;
      case "mat3x2i":
        return pt.mat3x2i;
      case "mat3x3i":
        return pt.mat3x3i;
      case "mat3x4i":
        return pt.mat3x4i;
      case "mat4x2i":
        return pt.mat4x2i;
      case "mat4x3i":
        return pt.mat4x3i;
      case "mat4x4i":
        return pt.mat4x4i;
      case "mat2x2u":
        return pt.mat2x2u;
      case "mat2x3u":
        return pt.mat2x3u;
      case "mat2x4u":
        return pt.mat2x4u;
      case "mat3x2u":
        return pt.mat3x2u;
      case "mat3x3u":
        return pt.mat3x3u;
      case "mat3x4u":
        return pt.mat3x4u;
      case "mat4x2u":
        return pt.mat4x2u;
      case "mat4x3u":
        return pt.mat4x3u;
      case "mat4x4u":
        return pt.mat4x4u;
    }
    return null;
  }
  _validateTypeRange(e, t) {
    if (t.name === "i32") {
      if (e < -2147483648 || e > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e}. Line: ${this._currentLine}.`);
    } else if (t.name === "u32" && (e < 0 || e > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e}. Line: ${this._currentLine}.`);
  }
  _primary_expression() {
    if (this._match(Ce.tokens.ident)) {
      const i = this._previous().toString();
      if (this._check(Ce.tokens.paren_left)) {
        const n = this._argument_expression_list(), s = this._getType(i);
        return s !== null ? this._updateNode(new pu(s, n)) : this._updateNode(new G2(i, n));
      }
      if (this._context.constants.has(i)) {
        const n = this._context.constants.get(i);
        return this._updateNode(new yI(i, n.value));
      }
      return this._updateNode(new il(i));
    }
    if (this._match(Ce.tokens.int_literal)) {
      const i = this._previous().toString();
      let n = i.endsWith("i") || i.endsWith("i") ? $t.i32 : i.endsWith("u") || i.endsWith("U") ? $t.u32 : $t.x32;
      const s = parseInt(i);
      return this._validateTypeRange(s, n), this._updateNode(new Ys(new ot(s, this._exec.getTypeInfo(n)), n));
    }
    if (this._match(Ce.tokens.uint_literal)) {
      const i = parseInt(this._previous().toString());
      return this._validateTypeRange(i, $t.u32), this._updateNode(new Ys(new ot(i, this._exec.getTypeInfo($t.u32)), $t.u32));
    }
    if (this._match([Ce.tokens.decimal_float_literal, Ce.tokens.hex_float_literal])) {
      let i = this._previous().toString(), n = i.endsWith("h");
      n && (i = i.substring(0, i.length - 1));
      const s = parseFloat(i);
      this._validateTypeRange(s, n ? $t.f16 : $t.f32);
      const c = n ? $t.f16 : $t.f32;
      return this._updateNode(new Ys(new ot(s, this._exec.getTypeInfo(c)), c));
    }
    if (this._match([Ce.keywords.true, Ce.keywords.false])) {
      let i = this._previous().toString() === Ce.keywords.true.rule;
      return this._updateNode(new Ys(new ot(i ? 1 : 0, this._exec.getTypeInfo($t.bool)), $t.bool));
    }
    if (this._check(Ce.tokens.paren_left)) return this._paren_expression();
    if (this._match(Ce.keywords.bitcast)) {
      this._consume(Ce.tokens.less_than, "Expected '<'.");
      const i = this._type_decl();
      this._consume(Ce.tokens.greater_than, "Expected '>'.");
      const n = this._paren_expression();
      return this._updateNode(new bI(i, n));
    }
    const e = this._type_decl(), t = this._argument_expression_list();
    return this._updateNode(new pu(e, t));
  }
  _argument_expression_list() {
    if (!this._match(Ce.tokens.paren_left)) return null;
    const e = [];
    do {
      if (this._check(Ce.tokens.paren_right)) break;
      const t = this._short_circuit_or_expression();
      e.push(t);
    } while (this._match(Ce.tokens.comma));
    return this._consume(Ce.tokens.paren_right, "Expected ')' for agument list"), e;
  }
  _optional_paren_expression() {
    this._match(Ce.tokens.paren_left);
    const e = this._short_circuit_or_expression();
    return this._match(Ce.tokens.paren_right), e;
  }
  _paren_expression() {
    this._consume(Ce.tokens.paren_left, "Expected '('.");
    const e = this._short_circuit_or_expression();
    return this._consume(Ce.tokens.paren_right, "Expected ')'."), e;
  }
  _struct_decl() {
    if (!this._match(Ce.keywords.struct)) return null;
    const e = this._currentLine, t = this._consume(Ce.tokens.ident, "Expected name for struct.").toString();
    this._consume(Ce.tokens.brace_left, "Expected '{' for struct body.");
    const i = [];
    for (; !this._check(Ce.tokens.brace_right); ) {
      const c = this._attribute(), o = this._consume(Ce.tokens.name, "Expected variable name.").toString();
      this._consume(Ce.tokens.colon, "Expected ':' for struct member type.");
      const d = this._attribute(), m = this._type_decl();
      m != null && (m.attributes = d), this._check(Ce.tokens.brace_right) ? this._match(Ce.tokens.comma) : this._consume(Ce.tokens.comma, "Expected ',' for struct member."), i.push(this._updateNode(new BT(o, m, c)));
    }
    this._consume(Ce.tokens.brace_right, "Expected '}' after struct body.");
    const n = this._currentLine, s = this._updateNode(new Qu(t, i, e, n), e);
    return this._context.structs.set(t, s), s;
  }
  _global_variable_decl() {
    const e = this._variable_decl();
    if (!e) return null;
    if (this._match(Ce.tokens.equal)) {
      const t = this._const_expression();
      e.value = t;
    }
    if (e.type !== null && e.value instanceof Ys) {
      if (e.value.type.name !== "x32" && e.type.getTypeName() !== e.value.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);
      e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type), e.value.type = e.type;
    } else e.type === null && e.value instanceof Ys && (e.type = e.value.type.name === "x32" ? $t.i32 : e.value.type, e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type));
    return e;
  }
  _override_variable_decl() {
    const e = this._override_decl();
    return e && this._match(Ce.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _global_const_decl() {
    var e;
    if (!this._match(Ce.keywords.const)) return null;
    const t = this._consume(Ce.tokens.name, "Expected variable name"), i = this._currentLine;
    let n = null;
    if (this._match(Ce.tokens.colon)) {
      const d = this._attribute();
      n = this._type_decl(), n != null && (n.attributes = d);
    }
    let s = null;
    this._consume(Ce.tokens.equal, "const declarations require an assignment");
    const c = this._short_circuit_or_expression();
    try {
      let d = [$t.f32], m = c.constEvaluate(this._exec, d);
      m instanceof ot && this._validateTypeRange(m.value, d[0]), d[0] instanceof pt && d[0].format === null && m.typeInfo instanceof Kf && m.typeInfo.format !== null && (m.typeInfo.format.name === "f16" ? d[0].format = $t.f16 : m.typeInfo.format.name === "f32" ? d[0].format = $t.f32 : m.typeInfo.format.name === "i32" ? d[0].format = $t.i32 : m.typeInfo.format.name === "u32" ? d[0].format = $t.u32 : m.typeInfo.format.name === "bool" ? d[0].format = $t.bool : console.error(`TODO: impelement template format type ${m.typeInfo.format.name}`)), s = this._updateNode(new Ys(m, d[0])), this._exec.context.setVariable(t.toString(), m);
    } catch {
      s = c;
    }
    if (n !== null && s instanceof Ys) {
      if (s.type.name !== "x32" && n.getTypeName() !== s.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${s.type.name} to ${n.name}. Line:${this._currentLine}`);
      s.type = n, s.isScalar && this._validateTypeRange(s.scalarValue, s.type);
    } else n === null && s instanceof Ys && (n = (e = s?.type) !== null && e !== void 0 ? e : $t.f32, n === $t.x32 && (n = $t.i32));
    const o = this._updateNode(new j_(t.toString(), n, "", "", s), i);
    return this._context.constants.set(o.name, o), o;
  }
  _global_let_decl() {
    if (!this._match(Ce.keywords.let)) return null;
    const e = this._currentLine, t = this._consume(Ce.tokens.name, "Expected variable name");
    let i = null;
    if (this._match(Ce.tokens.colon)) {
      const s = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = s);
    }
    let n = null;
    if (this._match(Ce.tokens.equal) && (n = this._const_expression()), i !== null && n instanceof Ys) {
      if (n.type.name !== "x32" && i.getTypeName() !== n.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${n.type.name} to ${i.name}. Line:${this._currentLine}`);
      n.type = i;
    } else i === null && n instanceof Ys && (i = n.type.name === "x32" ? $t.i32 : n.type);
    return n instanceof Ys && n.isScalar && this._validateTypeRange(n.scalarValue, i), this._updateNode(new Bg(t.toString(), i, "", "", n), e);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(Ce.keywords.var)) return null;
    const e = this._currentLine;
    let t = "", i = "";
    this._match(Ce.tokens.less_than) && (t = this._consume(Ce.storage_class, "Expected storage_class.").toString(), this._match(Ce.tokens.comma) && (i = this._consume(Ce.access_mode, "Expected access_mode.").toString()), this._consume(Ce.tokens.greater_than, "Expected '>'."));
    const n = this._consume(Ce.tokens.name, "Expected variable name");
    let s = null;
    if (this._match(Ce.tokens.colon)) {
      const c = this._attribute();
      s = this._type_decl(), s != null && (s.attributes = c);
    }
    return this._updateNode(new rh(n.toString(), s, t, i, null), e);
  }
  _override_decl() {
    if (!this._match(Ce.keywords.override)) return null;
    const e = this._consume(Ce.tokens.name, "Expected variable name");
    let t = null;
    if (this._match(Ce.tokens.colon)) {
      const i = this._attribute();
      t = this._type_decl(), t != null && (t.attributes = i);
    }
    return this._updateNode(new z2(e.toString(), t, null));
  }
  _diagnostic() {
    this._consume(Ce.tokens.paren_left, "Expected '('");
    const e = this._consume(Ce.tokens.ident, "Expected severity control name.");
    this._consume(Ce.tokens.comma, "Expected ','");
    let t = this._consume(Ce.tokens.ident, "Expected diagnostic rule name.").toString();
    return this._match(Ce.tokens.period) && (t += `.${this._consume(Ce.tokens.ident, "Expected diagnostic message.").toString()}`), this._consume(Ce.tokens.paren_right, "Expected ')'"), this._updateNode(new gI(e.toString(), t));
  }
  _enable_directive() {
    const e = this._consume(Ce.tokens.ident, "identity expected.");
    return this._updateNode(new uN(e.toString()));
  }
  _requires_directive() {
    const e = [this._consume(Ce.tokens.ident, "identity expected.").toString()];
    for (; this._match(Ce.tokens.comma); ) {
      const t = this._consume(Ce.tokens.ident, "identity expected.");
      e.push(t.toString());
    }
    return this._updateNode(new hN(e));
  }
  _type_alias() {
    const e = this._consume(Ce.tokens.ident, "identity expected.");
    this._consume(Ce.tokens.equal, "Expected '=' for type alias.");
    let t = this._type_decl();
    if (t === null) throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(t.name) && (t = this._context.aliases.get(t.name).type);
    const i = this._updateNode(new V2(e.toString(), t));
    return this._context.aliases.set(i.name, i), i;
  }
  _type_decl() {
    if (this._check([Ce.tokens.ident, ...Ce.texel_format, Ce.keywords.bool, Ce.keywords.f32, Ce.keywords.i32, Ce.keywords.u32])) {
      const i = this._advance().toString();
      if (this._context.structs.has(i)) return this._context.structs.get(i);
      if (this._context.aliases.has(i)) return this._context.aliases.get(i).type;
      if (!this._getType(i)) {
        const n = this._updateNode(new RT(i));
        return this._forwardTypeCount++, n;
      }
      return this._updateNode(new $t(i));
    }
    let e = this._texture_sampler_types();
    if (e) return e;
    if (this._check(Ce.template_types)) {
      let i = this._advance().toString(), n = null, s = null;
      return this._match(Ce.tokens.less_than) && (n = this._type_decl(), s = null, this._match(Ce.tokens.comma) && (s = this._consume(Ce.access_mode, "Expected access_mode for pointer").toString()), this._consume(Ce.tokens.greater_than, "Expected '>' for type.")), this._updateNode(new pt(i, n, s));
    }
    if (this._match(Ce.keywords.ptr)) {
      let i = this._previous().toString();
      this._consume(Ce.tokens.less_than, "Expected '<' for pointer.");
      const n = this._consume(Ce.storage_class, "Expected storage_class for pointer");
      this._consume(Ce.tokens.comma, "Expected ',' for pointer.");
      const s = this._type_decl();
      let c = null;
      return this._match(Ce.tokens.comma) && (c = this._consume(Ce.access_mode, "Expected access_mode for pointer").toString()), this._consume(Ce.tokens.greater_than, "Expected '>' for pointer."), this._updateNode(new V_(i, n.toString(), s, c));
    }
    const t = this._attribute();
    if (this._match(Ce.keywords.array)) {
      let i = null, n = -1;
      const s = this._previous();
      let c = null;
      if (this._match(Ce.tokens.less_than)) {
        i = this._type_decl(), this._context.aliases.has(i.name) && (i = this._context.aliases.get(i.name).type);
        let d = "";
        if (this._match(Ce.tokens.comma)) {
          c = this._shift_expression();
          try {
            d = c.constEvaluate(this._exec).toString(), c = null;
          } catch {
            d = "1";
          }
        }
        this._consume(Ce.tokens.greater_than, "Expected '>' for array."), n = d ? parseInt(d) : 0;
      }
      const o = this._updateNode(new kg(s.toString(), t, i, n));
      return c && this._deferArrayCountEval.push({
        arrayType: o,
        countNode: c
      }), o;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(Ce.sampler_type)) return this._updateNode(new Ag(this._previous().toString(), null, null));
    if (this._match(Ce.depth_texture_type)) return this._updateNode(new Ag(this._previous().toString(), null, null));
    if (this._match(Ce.sampled_texture_type) || this._match(Ce.multisampled_texture_type)) {
      const e = this._previous();
      this._consume(Ce.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._type_decl();
      return this._consume(Ce.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new Ag(e.toString(), t, null));
    }
    if (this._match(Ce.storage_texture_type)) {
      const e = this._previous();
      this._consume(Ce.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._consume(Ce.texel_format, "Invalid texel format.").toString();
      this._consume(Ce.tokens.comma, "Expected ',' after texel format.");
      const i = this._consume(Ce.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(Ce.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new Ag(e.toString(), t, i));
    }
    return null;
  }
  _attribute() {
    let e = [];
    for (; this._match(Ce.tokens.attr); ) {
      const t = this._consume(Ce.attribute_name, "Expected attribute name"), i = this._updateNode(new TI(t.toString(), null));
      if (this._match(Ce.tokens.paren_left)) {
        if (i.value = this._consume(Ce.literal_or_ident, "Expected attribute value").toString(), this._check(Ce.tokens.comma)) {
          this._advance();
          do {
            const n = this._consume(Ce.literal_or_ident, "Expected attribute value").toString();
            i.value instanceof Array || (i.value = [i.value]), i.value.push(n);
          } while (this._match(Ce.tokens.comma));
        }
        this._consume(Ce.tokens.paren_right, "Expected ')'");
      }
      e.push(i);
    }
    return e.length == 0 ? null : e;
  }
}
class CN extends bu {
  constructor(e) {
    super(), e && this.update(e);
  }
  update(e) {
    const t = new EN().parse(e);
    this.updateAST(t);
  }
}
function IN(r) {
  const e = {
    attributes: [],
    bindings: []
  };
  let t;
  try {
    t = PN(r);
  } catch (s) {
    return Ht.error(s.message)(), e;
  }
  for (const s of t.uniforms) {
    const c = [];
    for (const o of s.type?.members || [])
      c.push({
        name: o.name,
        type: DT(o.type)
      });
    e.bindings.push({
      type: "uniform",
      name: s.name,
      group: s.group,
      location: s.binding,
      // @ts-expect-error TODO - unused for now but needs fixing
      members: c
    });
  }
  for (const s of t.textures)
    e.bindings.push({
      type: "texture",
      name: s.name,
      group: s.group,
      location: s.binding
    });
  for (const s of t.samplers)
    e.bindings.push({
      type: "sampler",
      name: s.name,
      group: s.group,
      location: s.binding
    });
  const i = t.entry.vertex[0], n = i?.inputs.length || 0;
  for (let s = 0; s < n; s++) {
    const c = i.inputs[s];
    if (c.locationType === "location") {
      const o = DT(c.type);
      e.attributes.push({
        name: c.name,
        location: Number(c.location),
        type: o
      });
    }
  }
  return e;
}
function DT(r) {
  return r?.format ? `${r.name}<${r.format.name}>` : r.name;
}
function PN(r) {
  try {
    return new CN(r);
  } catch (e) {
    if (e instanceof Error)
      throw e;
    let t = "WGSL parse error";
    throw typeof e == "object" && e?.message && (t += `: ${e.message} `), typeof e == "object" && e?.token && (t += e.token.line || ""), new Error(t, {
      cause: e
    });
  }
}
const MN = 1 / Math.PI * 180, RN = 1 / 180 * Math.PI, LN = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || {
  config: {
    ...LN
  }
};
const Qs = globalThis.mathgl.config;
function BN(r, {
  precision: e = Qs.precision
} = {}) {
  return r = NN(r), `${parseFloat(r.toPrecision(e))}`;
}
function Xh(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function kN(r) {
  return DN(r);
}
function ON(r) {
  return yc(r);
}
function DN(r, e) {
  return X2(r, (t) => t * RN, e);
}
function yc(r, e) {
  return X2(r, (t) => t * MN, e);
}
function vc(r, e, t) {
  return X2(r, (i) => Math.max(e, Math.min(t, i)));
}
function Iy(r, e, t) {
  return Xh(r) ? r.map((i, n) => Iy(i, e[n], t)) : t * e + (1 - t) * r;
}
function Ac(r, e, t) {
  const i = Qs.EPSILON;
  t && (Qs.EPSILON = t);
  try {
    if (r === e)
      return !0;
    if (Xh(r) && Xh(e)) {
      if (r.length !== e.length)
        return !1;
      for (let n = 0; n < r.length; ++n)
        if (!Ac(r[n], e[n]))
          return !1;
      return !0;
    }
    return r && r.equals ? r.equals(e) : e && e.equals ? e.equals(r) : typeof r == "number" && typeof e == "number" ? Math.abs(r - e) <= Qs.EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) : !1;
  } finally {
    Qs.EPSILON = i;
  }
}
function NN(r) {
  return Math.round(r / Qs.EPSILON) * Qs.EPSILON;
}
function FN(r) {
  return r.clone ? r.clone() : new Array(r.length);
}
function X2(r, e, t) {
  if (Xh(r)) {
    const i = r;
    t = t || FN(i);
    for (let n = 0; n < t.length && n < i.length; ++n) {
      const s = typeof r == "number" ? r : r[n];
      t[n] = e(s, n, t);
    }
    return t;
  }
  return e(r);
}
class Z2 extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = e[i + t];
    return this.check();
  }
  toArray(e = [], t = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      e[t + i] = this[i];
    return e;
  }
  toObject(e) {
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : (
      // @ts-ignore
      this.fromObject(e)
    );
  }
  to(e) {
    return e === this ? this : Xh(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(Qs);
  }
  /** Formats string according to options */
  formatString(e) {
    let t = "";
    for (let i = 0; i < this.ELEMENTS; ++i)
      t += (i > 0 ? ", " : "") + BN(this[i], e);
    return `${e.printTypes ? this.constructor.name : ""}[${t}]`;
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (!Ac(this[t], e[t]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, t, i) {
    if (i === void 0)
      return this.lerp(this, e, t);
    for (let n = 0; n < this.ELEMENTS; ++n) {
      const s = e[n], c = typeof t == "number" ? t : t[n];
      this[n] = s + i * (c - s);
    }
    return this.check();
  }
  /** Minimal */
  min(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.min(e[t], this[t]);
    return this.check();
  }
  /** Maximal */
  max(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.max(e[t], this[t]);
    return this.check();
  }
  clamp(e, t) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(Math.max(this[i], e[i]), t[i]);
    return this.check();
  }
  add(...e) {
    for (const t of e)
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] += t[i];
    return this.check();
  }
  subtract(...e) {
    for (const t of e)
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] -= t[i];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
    else
      for (let t = 0; t < this.ELEMENTS && t < e.length; ++t)
        this[t] *= e[t];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (Qs.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e = e && Number.isFinite(this[t]);
    return e;
  }
  // three.js compatibility
  /** @deprecated */
  sub(e) {
    return this.subtract(e);
  }
  /** @deprecated */
  setScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = e;
    return this.check();
  }
  /** @deprecated */
  addScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] += e;
    return this.check();
  }
  /** @deprecated */
  subScalar(e) {
    return this.addScalar(-e);
  }
  /** @deprecated */
  multiplyScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  /** @deprecated */
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  /** @deprecated */
  clampScalar(e, t) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(Math.max(this[i], e), t);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function UN(r, e) {
  if (r.length !== e)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (!Number.isFinite(r[t]))
      return !1;
  return !0;
}
function Ki(r) {
  if (!Number.isFinite(r))
    throw new Error(`Invalid number ${JSON.stringify(r)}`);
  return r;
}
function Og(r, e, t = "") {
  if (Qs.debug && !UN(r, e))
    throw new Error(`math.gl: ${t} some fields set to invalid numbers'`);
  return r;
}
function bc(r, e) {
  if (!r)
    throw new Error(`math.gl assertion ${e}`);
}
class Y2 extends Z2 {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Ki(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Ki(e);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let e = 0;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e += this[t] * this[t];
    return e;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let t = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const n = this[i] - e[i];
      t += n * n;
    }
    return Ki(t);
  }
  dot(e) {
    let t = 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      t += this[i] * e[i];
    return Ki(t);
  }
  // MODIFIERS
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] /= e;
    return this.check();
  }
  multiply(...e) {
    for (const t of e)
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] *= t[i];
    return this.check();
  }
  divide(...e) {
    for (const t of e)
      for (let i = 0; i < this.ELEMENTS; ++i)
        this[i] /= t[i];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return bc(e >= 0 && e < this.ELEMENTS, "index is out of range"), Ki(this[e]);
  }
  setComponent(e, t) {
    return bc(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
  }
  addVectors(e, t) {
    return this.copy(e).add(t);
  }
  subVectors(e, t) {
    return this.copy(e).subtract(t);
  }
  multiplyVectors(e, t) {
    return this.copy(e).multiply(t);
  }
  addScaledVector(e, t) {
    return this.add(new this.constructor(e).multiplyScalar(t));
  }
}
const Dg = 1e-6;
let Sc = typeof Float32Array < "u" ? Float32Array : Array;
function zN() {
  const r = new Sc(2);
  return Sc != Float32Array && (r[0] = 0, r[1] = 0), r;
}
function NT(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function jN(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function EI(r, e, t, i) {
  const n = e[0], s = e[1];
  return r[0] = n + i * (t[0] - n), r[1] = s + i * (t[1] - s), r;
}
function VN(r, e, t) {
  const i = e[0], n = e[1];
  return r[0] = t[0] * i + t[2] * n, r[1] = t[1] * i + t[3] * n, r;
}
function GN(r, e, t) {
  const i = e[0], n = e[1];
  return r[0] = t[0] * i + t[2] * n + t[4], r[1] = t[1] * i + t[3] * n + t[5], r;
}
function CI(r, e, t) {
  const i = e[0], n = e[1];
  return r[0] = t[0] * i + t[3] * n + t[6], r[1] = t[1] * i + t[4] * n + t[7], r;
}
function II(r, e, t) {
  const i = e[0], n = e[1];
  return r[0] = t[0] * i + t[4] * n + t[12], r[1] = t[1] * i + t[5] * n + t[13], r;
}
(function() {
  const r = zN();
  return function(e, t, i, n, s, c) {
    let o, d;
    for (t || (t = 2), i || (i = 0), n ? d = Math.min(n * t + i, e.length) : d = e.length, o = i; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], s(r, r, c), e[o] = r[0], e[o + 1] = r[1];
    return e;
  };
})();
function PI(r, e, t) {
  const i = e[0], n = e[1], s = t[3] * i + t[7] * n || 1;
  return r[0] = (t[0] * i + t[4] * n) / s, r[1] = (t[1] * i + t[5] * n) / s, r;
}
function MI(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = t[3] * i + t[7] * n + t[11] * s || 1;
  return r[0] = (t[0] * i + t[4] * n + t[8] * s) / c, r[1] = (t[1] * i + t[5] * n + t[9] * s) / c, r[2] = (t[2] * i + t[6] * n + t[10] * s) / c, r;
}
function $N(r, e, t) {
  const i = e[0], n = e[1];
  return r[0] = t[0] * i + t[2] * n, r[1] = t[1] * i + t[3] * n, r[2] = e[2], r;
}
function HN(r, e, t) {
  const i = e[0], n = e[1];
  return r[0] = t[0] * i + t[2] * n, r[1] = t[1] * i + t[3] * n, r[2] = e[2], r[3] = e[3], r;
}
function RI(r, e, t) {
  const i = e[0], n = e[1], s = e[2];
  return r[0] = t[0] * i + t[3] * n + t[6] * s, r[1] = t[1] * i + t[4] * n + t[7] * s, r[2] = t[2] * i + t[5] * n + t[8] * s, r[3] = e[3], r;
}
class J2 extends Y2 {
  // Creates a new, empty vec2
  constructor(e = 0, t = 0) {
    super(2), Xh(e) && arguments.length === 1 ? this.copy(e) : (Qs.debug && (Ki(e), Ki(t)), this[0] = e, this[1] = t);
  }
  set(e, t) {
    return this[0] = e, this[1] = t, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return Qs.debug && (Ki(e.x), Ki(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 2;
  }
  /**
   * Returns angle from x axis
   * @returns
   */
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns angle from y axis
   * @returns
   */
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  // Transforms
  /**
   * Transforms as point
   * @param matrix4
   * @returns
   */
  transform(e) {
    return this.transformAsPoint(e);
  }
  /**
   * transforms as point (4th component is implicitly 1)
   * @param matrix4
   * @returns
   */
  transformAsPoint(e) {
    return II(this, this, e), this.check();
  }
  /**
   * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
   * @param matrix4
   * @returns
   */
  transformAsVector(e) {
    return PI(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return CI(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return GN(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return VN(this, this, e), this.check();
  }
}
function LI() {
  const r = new Sc(3);
  return Sc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function BI(r) {
  const e = r[0], t = r[1], i = r[2];
  return Math.sqrt(e * e + t * t + i * i);
}
function FT(r, e, t) {
  const i = new Sc(3);
  return i[0] = r, i[1] = e, i[2] = t, i;
}
function qN(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], r;
}
function WN(r) {
  const e = r[0], t = r[1], i = r[2];
  return e * e + t * t + i * i;
}
function XN(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r;
}
function ZN(r, e) {
  const t = e[0], i = e[1], n = e[2];
  let s = t * t + i * i + n * n;
  return s > 0 && (s = 1 / Math.sqrt(s)), r[0] = e[0] * s, r[1] = e[1] * s, r[2] = e[2] * s, r;
}
function K2(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function $_(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = t[0], o = t[1], d = t[2];
  return r[0] = n * d - s * o, r[1] = s * c - i * d, r[2] = i * o - n * c, r;
}
function YN(r, e, t, i) {
  const n = e[0], s = e[1], c = e[2];
  return r[0] = n + i * (t[0] - n), r[1] = s + i * (t[1] - s), r[2] = c + i * (t[2] - c), r;
}
function Q2(r, e, t) {
  const i = e[0], n = e[1], s = e[2];
  let c = t[3] * i + t[7] * n + t[11] * s + t[15];
  return c = c || 1, r[0] = (t[0] * i + t[4] * n + t[8] * s + t[12]) / c, r[1] = (t[1] * i + t[5] * n + t[9] * s + t[13]) / c, r[2] = (t[2] * i + t[6] * n + t[10] * s + t[14]) / c, r;
}
function kI(r, e, t) {
  const i = e[0], n = e[1], s = e[2];
  return r[0] = i * t[0] + n * t[3] + s * t[6], r[1] = i * t[1] + n * t[4] + s * t[7], r[2] = i * t[2] + n * t[5] + s * t[8], r;
}
function OI(r, e, t) {
  const i = t[0], n = t[1], s = t[2], c = t[3], o = e[0], d = e[1], m = e[2];
  let y = n * m - s * d, T = s * o - i * m, P = i * d - n * o, I = n * P - s * T, D = s * y - i * P, k = i * T - n * y;
  const $ = c * 2;
  return y *= $, T *= $, P *= $, I *= 2, D *= 2, k *= 2, r[0] = o + y + I, r[1] = d + T + D, r[2] = m + P + k, r;
}
function JN(r, e, t, i) {
  const n = [], s = [];
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], s[0] = n[0], s[1] = n[1] * Math.cos(i) - n[2] * Math.sin(i), s[2] = n[1] * Math.sin(i) + n[2] * Math.cos(i), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function KN(r, e, t, i) {
  const n = [], s = [];
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], s[0] = n[2] * Math.sin(i) + n[0] * Math.cos(i), s[1] = n[1], s[2] = n[2] * Math.cos(i) - n[0] * Math.sin(i), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function QN(r, e, t, i) {
  const n = [], s = [];
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], s[0] = n[0] * Math.cos(i) - n[1] * Math.sin(i), s[1] = n[0] * Math.sin(i) + n[1] * Math.cos(i), s[2] = n[2], r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function eF(r, e) {
  const t = r[0], i = r[1], n = r[2], s = e[0], c = e[1], o = e[2], d = Math.sqrt((t * t + i * i + n * n) * (s * s + c * c + o * o)), m = d && K2(r, e) / d;
  return Math.acos(Math.min(Math.max(m, -1), 1));
}
const DI = qN, NI = BI, Ab = WN;
(function() {
  const r = LI();
  return function(e, t, i, n, s, c) {
    let o, d;
    for (t || (t = 3), i || (i = 0), n ? d = Math.min(n * t + i, e.length) : d = e.length, o = i; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], r[2] = e[o + 2], s(r, r, c), e[o] = r[0], e[o + 1] = r[1], e[o + 2] = r[2];
    return e;
  };
})();
const Tb = [0, 0, 0];
let e_;
class xt extends Y2 {
  static get ZERO() {
    return e_ || (e_ = new xt(0, 0, 0), Object.freeze(e_)), e_;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(e = 0, t = 0, i = 0) {
    super(-0, -0, -0), arguments.length === 1 && Xh(e) ? this.copy(e) : (Qs.debug && (Ki(e), Ki(t), Ki(i)), this[0] = e, this[1] = t, this[2] = i);
  }
  set(e, t, i) {
    return this[0] = e, this[1] = t, this[2] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return Qs.debug && (Ki(e.x), Ki(e.y), Ki(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ki(e);
  }
  // ACCESSORS
  angle(e) {
    return eF(this, e);
  }
  // MODIFIERS
  cross(e) {
    return $_(this, this, e), this.check();
  }
  rotateX({
    radians: e,
    origin: t = Tb
  }) {
    return JN(this, this, t, e), this.check();
  }
  rotateY({
    radians: e,
    origin: t = Tb
  }) {
    return KN(this, this, t, e), this.check();
  }
  rotateZ({
    radians: e,
    origin: t = Tb
  }) {
    return QN(this, this, t, e), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(e) {
    return this.transformAsPoint(e);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(e) {
    return Q2(this, this, e), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(e) {
    return MI(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return kI(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return $N(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return OI(this, this, e), this.check();
  }
}
let t_;
class ex extends Y2 {
  static get ZERO() {
    return t_ || (t_ = new ex(0, 0, 0, 0), Object.freeze(t_)), t_;
  }
  constructor(e = 0, t = 0, i = 0, n = 0) {
    super(-0, -0, -0, -0), Xh(e) && arguments.length === 1 ? this.copy(e) : (Qs.debug && (Ki(e), Ki(t), Ki(i), Ki(n)), this[0] = e, this[1] = t, this[2] = i, this[3] = n);
  }
  set(e, t, i, n) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = n, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return Qs.debug && (Ki(e.x), Ki(e.y), Ki(e.z), Ki(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ki(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Ki(e);
  }
  transform(e) {
    return Q2(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return RI(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return HN(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return OI(this, this, e), this.check();
  }
  // three.js compatibility
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class FI extends Z2 {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let e = "[";
    if (Qs.printRowMajor) {
      e += "row-major:";
      for (let t = 0; t < this.RANK; ++t)
        for (let i = 0; i < this.RANK; ++i)
          e += ` ${this[i * this.RANK + t]}`;
    } else {
      e += "column-major:";
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += ` ${this[t]}`;
    }
    return e += "]", e;
  }
  getElementIndex(e, t) {
    return t * this.RANK + e;
  }
  // By default assumes row major indices
  getElement(e, t) {
    return this[t * this.RANK + e];
  }
  // By default assumes row major indices
  setElement(e, t, i) {
    return this[t * this.RANK + e] = Ki(i), this;
  }
  getColumn(e, t = new Array(this.RANK).fill(-0)) {
    const i = e * this.RANK;
    for (let n = 0; n < this.RANK; ++n)
      t[n] = this[i + n];
    return t;
  }
  setColumn(e, t) {
    const i = e * this.RANK;
    for (let n = 0; n < this.RANK; ++n)
      this[i + n] = t[n];
    return this;
  }
}
function tF() {
  const r = new Sc(9);
  return Sc != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
}
function rF(r, e) {
  if (r === e) {
    const t = e[1], i = e[2], n = e[5];
    r[1] = e[3], r[2] = e[6], r[3] = t, r[5] = e[7], r[6] = i, r[7] = n;
  } else
    r[0] = e[0], r[1] = e[3], r[2] = e[6], r[3] = e[1], r[4] = e[4], r[5] = e[7], r[6] = e[2], r[7] = e[5], r[8] = e[8];
  return r;
}
function iF(r, e) {
  const t = e[0], i = e[1], n = e[2], s = e[3], c = e[4], o = e[5], d = e[6], m = e[7], y = e[8], T = y * c - o * m, P = -y * s + o * d, I = m * s - c * d;
  let D = t * T + i * P + n * I;
  return D ? (D = 1 / D, r[0] = T * D, r[1] = (-y * i + n * m) * D, r[2] = (o * i - n * c) * D, r[3] = P * D, r[4] = (y * t - n * d) * D, r[5] = (-o * t + n * s) * D, r[6] = I * D, r[7] = (-m * t + i * d) * D, r[8] = (c * t - i * s) * D, r) : null;
}
function nF(r) {
  const e = r[0], t = r[1], i = r[2], n = r[3], s = r[4], c = r[5], o = r[6], d = r[7], m = r[8];
  return e * (m * s - c * d) + t * (-m * n + c * o) + i * (d * n - s * o);
}
function UT(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = e[3], o = e[4], d = e[5], m = e[6], y = e[7], T = e[8], P = t[0], I = t[1], D = t[2], k = t[3], $ = t[4], G = t[5], te = t[6], Z = t[7], H = t[8];
  return r[0] = P * i + I * c + D * m, r[1] = P * n + I * o + D * y, r[2] = P * s + I * d + D * T, r[3] = k * i + $ * c + G * m, r[4] = k * n + $ * o + G * y, r[5] = k * s + $ * d + G * T, r[6] = te * i + Z * c + H * m, r[7] = te * n + Z * o + H * y, r[8] = te * s + Z * d + H * T, r;
}
function sF(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = e[3], o = e[4], d = e[5], m = e[6], y = e[7], T = e[8], P = t[0], I = t[1];
  return r[0] = i, r[1] = n, r[2] = s, r[3] = c, r[4] = o, r[5] = d, r[6] = P * i + I * c + m, r[7] = P * n + I * o + y, r[8] = P * s + I * d + T, r;
}
function oF(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = e[3], o = e[4], d = e[5], m = e[6], y = e[7], T = e[8], P = Math.sin(t), I = Math.cos(t);
  return r[0] = I * i + P * c, r[1] = I * n + P * o, r[2] = I * s + P * d, r[3] = I * c - P * i, r[4] = I * o - P * n, r[5] = I * d - P * s, r[6] = m, r[7] = y, r[8] = T, r;
}
function zT(r, e, t) {
  const i = t[0], n = t[1];
  return r[0] = i * e[0], r[1] = i * e[1], r[2] = i * e[2], r[3] = n * e[3], r[4] = n * e[4], r[5] = n * e[5], r[6] = e[6], r[7] = e[7], r[8] = e[8], r;
}
function aF(r, e) {
  const t = e[0], i = e[1], n = e[2], s = e[3], c = t + t, o = i + i, d = n + n, m = t * c, y = i * c, T = i * o, P = n * c, I = n * o, D = n * d, k = s * c, $ = s * o, G = s * d;
  return r[0] = 1 - T - D, r[3] = y - G, r[6] = P + $, r[1] = y + G, r[4] = 1 - m - D, r[7] = I - k, r[2] = P - $, r[5] = I + k, r[8] = 1 - m - T, r;
}
var pv;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL1ROW0 = 3] = "COL1ROW0", r[r.COL1ROW1 = 4] = "COL1ROW1", r[r.COL1ROW2 = 5] = "COL1ROW2", r[r.COL2ROW0 = 6] = "COL2ROW0", r[r.COL2ROW1 = 7] = "COL2ROW1", r[r.COL2ROW2 = 8] = "COL2ROW2";
})(pv || (pv = {}));
const lF = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class hs extends FI {
  static get IDENTITY() {
    return uF();
  }
  static get ZERO() {
    return cF();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return pv;
  }
  constructor(e, ...t) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : t.length > 0 ? this.copy([e, ...t]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  // Constructors
  identity() {
    return this.copy(lF);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(e) {
    return aF(this, e), this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(e, t, i, n, s, c, o, d, m) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = n, this[4] = s, this[5] = c, this[6] = o, this[7] = d, this[8] = m, this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(e, t, i, n, s, c, o, d, m) {
    return this[0] = e, this[1] = n, this[2] = o, this[3] = t, this[4] = s, this[5] = d, this[6] = i, this[7] = c, this[8] = m, this.check();
  }
  // Accessors
  determinant() {
    return nF(this);
  }
  // Modifiers
  transpose() {
    return rF(this, this), this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    return iF(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return UT(this, e, this), this.check();
  }
  multiplyRight(e) {
    return UT(this, this, e), this.check();
  }
  rotate(e) {
    return oF(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? zT(this, this, e) : zT(this, this, [e, e]), this.check();
  }
  translate(e) {
    return sF(this, this, e), this.check();
  }
  // Transforms
  transform(e, t) {
    let i;
    switch (e.length) {
      case 2:
        i = CI(t || [-0, -0], e, this);
        break;
      case 3:
        i = kI(t || [-0, -0, -0], e, this);
        break;
      case 4:
        i = RI(t || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Og(i, e.length), i;
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector2(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector3(e, t) {
    return this.transform(e, t);
  }
}
let r_, i_ = null;
function cF() {
  return r_ || (r_ = new hs([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(r_)), r_;
}
function uF() {
  return i_ || (i_ = new hs(), Object.freeze(i_)), i_;
}
function hF(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function fF(r, e) {
  if (r === e) {
    const t = e[1], i = e[2], n = e[3], s = e[6], c = e[7], o = e[11];
    r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = t, r[6] = e[9], r[7] = e[13], r[8] = i, r[9] = s, r[11] = e[14], r[12] = n, r[13] = c, r[14] = o;
  } else
    r[0] = e[0], r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = e[1], r[5] = e[5], r[6] = e[9], r[7] = e[13], r[8] = e[2], r[9] = e[6], r[10] = e[10], r[11] = e[14], r[12] = e[3], r[13] = e[7], r[14] = e[11], r[15] = e[15];
  return r;
}
function gv(r, e) {
  const t = e[0], i = e[1], n = e[2], s = e[3], c = e[4], o = e[5], d = e[6], m = e[7], y = e[8], T = e[9], P = e[10], I = e[11], D = e[12], k = e[13], $ = e[14], G = e[15], te = t * o - i * c, Z = t * d - n * c, H = t * m - s * c, J = i * d - n * o, re = i * m - s * o, be = n * m - s * d, pe = y * k - T * D, oe = y * $ - P * D, Ee = y * G - I * D, le = T * $ - P * k, _e = T * G - I * k, Ve = P * G - I * $;
  let Be = te * Ve - Z * _e + H * le + J * Ee - re * oe + be * pe;
  return Be ? (Be = 1 / Be, r[0] = (o * Ve - d * _e + m * le) * Be, r[1] = (n * _e - i * Ve - s * le) * Be, r[2] = (k * be - $ * re + G * J) * Be, r[3] = (P * re - T * be - I * J) * Be, r[4] = (d * Ee - c * Ve - m * oe) * Be, r[5] = (t * Ve - n * Ee + s * oe) * Be, r[6] = ($ * H - D * be - G * Z) * Be, r[7] = (y * be - P * H + I * Z) * Be, r[8] = (c * _e - o * Ee + m * pe) * Be, r[9] = (i * Ee - t * _e - s * pe) * Be, r[10] = (D * re - k * H + G * te) * Be, r[11] = (T * H - y * re - I * te) * Be, r[12] = (o * oe - c * le - d * pe) * Be, r[13] = (t * le - i * oe + n * pe) * Be, r[14] = (k * Z - D * J - $ * te) * Be, r[15] = (y * J - T * Z + P * te) * Be, r) : null;
}
function dF(r) {
  const e = r[0], t = r[1], i = r[2], n = r[3], s = r[4], c = r[5], o = r[6], d = r[7], m = r[8], y = r[9], T = r[10], P = r[11], I = r[12], D = r[13], k = r[14], $ = r[15], G = e * c - t * s, te = e * o - i * s, Z = t * o - i * c, H = m * D - y * I, J = m * k - T * I, re = y * k - T * D, be = e * re - t * J + i * H, pe = s * re - c * J + o * H, oe = m * Z - y * te + T * G, Ee = I * Z - D * te + k * G;
  return d * be - n * pe + $ * oe - P * Ee;
}
function $f(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = e[3], o = e[4], d = e[5], m = e[6], y = e[7], T = e[8], P = e[9], I = e[10], D = e[11], k = e[12], $ = e[13], G = e[14], te = e[15];
  let Z = t[0], H = t[1], J = t[2], re = t[3];
  return r[0] = Z * i + H * o + J * T + re * k, r[1] = Z * n + H * d + J * P + re * $, r[2] = Z * s + H * m + J * I + re * G, r[3] = Z * c + H * y + J * D + re * te, Z = t[4], H = t[5], J = t[6], re = t[7], r[4] = Z * i + H * o + J * T + re * k, r[5] = Z * n + H * d + J * P + re * $, r[6] = Z * s + H * m + J * I + re * G, r[7] = Z * c + H * y + J * D + re * te, Z = t[8], H = t[9], J = t[10], re = t[11], r[8] = Z * i + H * o + J * T + re * k, r[9] = Z * n + H * d + J * P + re * $, r[10] = Z * s + H * m + J * I + re * G, r[11] = Z * c + H * y + J * D + re * te, Z = t[12], H = t[13], J = t[14], re = t[15], r[12] = Z * i + H * o + J * T + re * k, r[13] = Z * n + H * d + J * P + re * $, r[14] = Z * s + H * m + J * I + re * G, r[15] = Z * c + H * y + J * D + re * te, r;
}
function Py(r, e, t) {
  const i = t[0], n = t[1], s = t[2];
  let c, o, d, m, y, T, P, I, D, k, $, G;
  return e === r ? (r[12] = e[0] * i + e[4] * n + e[8] * s + e[12], r[13] = e[1] * i + e[5] * n + e[9] * s + e[13], r[14] = e[2] * i + e[6] * n + e[10] * s + e[14], r[15] = e[3] * i + e[7] * n + e[11] * s + e[15]) : (c = e[0], o = e[1], d = e[2], m = e[3], y = e[4], T = e[5], P = e[6], I = e[7], D = e[8], k = e[9], $ = e[10], G = e[11], r[0] = c, r[1] = o, r[2] = d, r[3] = m, r[4] = y, r[5] = T, r[6] = P, r[7] = I, r[8] = D, r[9] = k, r[10] = $, r[11] = G, r[12] = c * i + y * n + D * s + e[12], r[13] = o * i + T * n + k * s + e[13], r[14] = d * i + P * n + $ * s + e[14], r[15] = m * i + I * n + G * s + e[15]), r;
}
function tx(r, e, t) {
  const i = t[0], n = t[1], s = t[2];
  return r[0] = e[0] * i, r[1] = e[1] * i, r[2] = e[2] * i, r[3] = e[3] * i, r[4] = e[4] * n, r[5] = e[5] * n, r[6] = e[6] * n, r[7] = e[7] * n, r[8] = e[8] * s, r[9] = e[9] * s, r[10] = e[10] * s, r[11] = e[11] * s, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function pF(r, e, t, i) {
  let n = i[0], s = i[1], c = i[2], o = Math.sqrt(n * n + s * s + c * c), d, m, y, T, P, I, D, k, $, G, te, Z, H, J, re, be, pe, oe, Ee, le, _e, Ve, Be, gt;
  return o < Dg ? null : (o = 1 / o, n *= o, s *= o, c *= o, m = Math.sin(t), d = Math.cos(t), y = 1 - d, T = e[0], P = e[1], I = e[2], D = e[3], k = e[4], $ = e[5], G = e[6], te = e[7], Z = e[8], H = e[9], J = e[10], re = e[11], be = n * n * y + d, pe = s * n * y + c * m, oe = c * n * y - s * m, Ee = n * s * y - c * m, le = s * s * y + d, _e = c * s * y + n * m, Ve = n * c * y + s * m, Be = s * c * y - n * m, gt = c * c * y + d, r[0] = T * be + k * pe + Z * oe, r[1] = P * be + $ * pe + H * oe, r[2] = I * be + G * pe + J * oe, r[3] = D * be + te * pe + re * oe, r[4] = T * Ee + k * le + Z * _e, r[5] = P * Ee + $ * le + H * _e, r[6] = I * Ee + G * le + J * _e, r[7] = D * Ee + te * le + re * _e, r[8] = T * Ve + k * Be + Z * gt, r[9] = P * Ve + $ * Be + H * gt, r[10] = I * Ve + G * Be + J * gt, r[11] = D * Ve + te * Be + re * gt, e !== r && (r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r);
}
function UI(r, e, t) {
  const i = Math.sin(t), n = Math.cos(t), s = e[4], c = e[5], o = e[6], d = e[7], m = e[8], y = e[9], T = e[10], P = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = s * n + m * i, r[5] = c * n + y * i, r[6] = o * n + T * i, r[7] = d * n + P * i, r[8] = m * n - s * i, r[9] = y * n - c * i, r[10] = T * n - o * i, r[11] = P * n - d * i, r;
}
function gF(r, e, t) {
  const i = Math.sin(t), n = Math.cos(t), s = e[0], c = e[1], o = e[2], d = e[3], m = e[8], y = e[9], T = e[10], P = e[11];
  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * n - m * i, r[1] = c * n - y * i, r[2] = o * n - T * i, r[3] = d * n - P * i, r[8] = s * i + m * n, r[9] = c * i + y * n, r[10] = o * i + T * n, r[11] = d * i + P * n, r;
}
function zI(r, e, t) {
  const i = Math.sin(t), n = Math.cos(t), s = e[0], c = e[1], o = e[2], d = e[3], m = e[4], y = e[5], T = e[6], P = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * n + m * i, r[1] = c * n + y * i, r[2] = o * n + T * i, r[3] = d * n + P * i, r[4] = m * n - s * i, r[5] = y * n - c * i, r[6] = T * n - o * i, r[7] = P * n - d * i, r;
}
function mF(r, e) {
  const t = e[0], i = e[1], n = e[2], s = e[4], c = e[5], o = e[6], d = e[8], m = e[9], y = e[10];
  return r[0] = Math.sqrt(t * t + i * i + n * n), r[1] = Math.sqrt(s * s + c * c + o * o), r[2] = Math.sqrt(d * d + m * m + y * y), r;
}
function _F(r, e) {
  const t = e[0], i = e[1], n = e[2], s = e[3], c = t + t, o = i + i, d = n + n, m = t * c, y = i * c, T = i * o, P = n * c, I = n * o, D = n * d, k = s * c, $ = s * o, G = s * d;
  return r[0] = 1 - T - D, r[1] = y + G, r[2] = P - $, r[3] = 0, r[4] = y - G, r[5] = 1 - m - D, r[6] = I + k, r[7] = 0, r[8] = P + $, r[9] = I - k, r[10] = 1 - m - T, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function yF(r, e, t, i, n, s, c) {
  const o = 1 / (t - e), d = 1 / (n - i), m = 1 / (s - c);
  return r[0] = s * 2 * o, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s * 2 * d, r[6] = 0, r[7] = 0, r[8] = (t + e) * o, r[9] = (n + i) * d, r[10] = (c + s) * m, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = c * s * 2 * m, r[15] = 0, r;
}
function bF(r, e, t, i, n) {
  const s = 1 / Math.tan(e / 2);
  if (r[0] = s / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, n != null && n !== 1 / 0) {
    const c = 1 / (i - n);
    r[10] = (n + i) * c, r[14] = 2 * n * i * c;
  } else
    r[10] = -1, r[14] = -2 * i;
  return r;
}
const vF = bF;
function xF(r, e, t, i, n, s, c) {
  const o = 1 / (e - t), d = 1 / (i - n), m = 1 / (s - c);
  return r[0] = -2 * o, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * d, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * m, r[11] = 0, r[12] = (e + t) * o, r[13] = (n + i) * d, r[14] = (c + s) * m, r[15] = 1, r;
}
const wF = xF;
function AF(r, e, t, i) {
  let n, s, c, o, d, m, y, T, P, I;
  const D = e[0], k = e[1], $ = e[2], G = i[0], te = i[1], Z = i[2], H = t[0], J = t[1], re = t[2];
  return Math.abs(D - H) < Dg && Math.abs(k - J) < Dg && Math.abs($ - re) < Dg ? hF(r) : (T = D - H, P = k - J, I = $ - re, n = 1 / Math.sqrt(T * T + P * P + I * I), T *= n, P *= n, I *= n, s = te * I - Z * P, c = Z * T - G * I, o = G * P - te * T, n = Math.sqrt(s * s + c * c + o * o), n ? (n = 1 / n, s *= n, c *= n, o *= n) : (s = 0, c = 0, o = 0), d = P * o - I * c, m = I * s - T * o, y = T * c - P * s, n = Math.sqrt(d * d + m * m + y * y), n ? (n = 1 / n, d *= n, m *= n, y *= n) : (d = 0, m = 0, y = 0), r[0] = s, r[1] = d, r[2] = T, r[3] = 0, r[4] = c, r[5] = m, r[6] = P, r[7] = 0, r[8] = o, r[9] = y, r[10] = I, r[11] = 0, r[12] = -(s * D + c * k + o * $), r[13] = -(d * D + m * k + y * $), r[14] = -(T * D + P * k + I * $), r[15] = 1, r);
}
function TF() {
  const r = new Sc(4);
  return Sc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0), r;
}
function SF(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r[3] = e[3] + t[3], r;
}
function rx(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r[3] = e[3] * t, r;
}
function EF(r) {
  const e = r[0], t = r[1], i = r[2], n = r[3];
  return Math.sqrt(e * e + t * t + i * i + n * n);
}
function CF(r) {
  const e = r[0], t = r[1], i = r[2], n = r[3];
  return e * e + t * t + i * i + n * n;
}
function IF(r, e) {
  const t = e[0], i = e[1], n = e[2], s = e[3];
  let c = t * t + i * i + n * n + s * s;
  return c > 0 && (c = 1 / Math.sqrt(c)), r[0] = t * c, r[1] = i * c, r[2] = n * c, r[3] = s * c, r;
}
function PF(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] * e[3];
}
function MF(r, e, t, i) {
  const n = e[0], s = e[1], c = e[2], o = e[3];
  return r[0] = n + i * (t[0] - n), r[1] = s + i * (t[1] - s), r[2] = c + i * (t[2] - c), r[3] = o + i * (t[3] - o), r;
}
function Op(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = e[3];
  return r[0] = t[0] * i + t[4] * n + t[8] * s + t[12] * c, r[1] = t[1] * i + t[5] * n + t[9] * s + t[13] * c, r[2] = t[2] * i + t[6] * n + t[10] * s + t[14] * c, r[3] = t[3] * i + t[7] * n + t[11] * s + t[15] * c, r;
}
function RF(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = t[0], o = t[1], d = t[2], m = t[3], y = m * i + o * s - d * n, T = m * n + d * i - c * s, P = m * s + c * n - o * i, I = -c * i - o * n - d * s;
  return r[0] = y * m + I * -c + T * -d - P * -o, r[1] = T * m + I * -o + P * -c - y * -d, r[2] = P * m + I * -d + y * -o - T * -c, r[3] = e[3], r;
}
(function() {
  const r = TF();
  return function(e, t, i, n, s, c) {
    let o, d;
    for (t || (t = 4), i || (i = 0), n ? d = Math.min(n * t + i, e.length) : d = e.length, o = i; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], r[2] = e[o + 2], r[3] = e[o + 3], s(r, r, c), e[o] = r[0], e[o + 1] = r[1], e[o + 2] = r[2], e[o + 3] = r[3];
    return e;
  };
})();
var mv;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL0ROW3 = 3] = "COL0ROW3", r[r.COL1ROW0 = 4] = "COL1ROW0", r[r.COL1ROW1 = 5] = "COL1ROW1", r[r.COL1ROW2 = 6] = "COL1ROW2", r[r.COL1ROW3 = 7] = "COL1ROW3", r[r.COL2ROW0 = 8] = "COL2ROW0", r[r.COL2ROW1 = 9] = "COL2ROW1", r[r.COL2ROW2 = 10] = "COL2ROW2", r[r.COL2ROW3 = 11] = "COL2ROW3", r[r.COL3ROW0 = 12] = "COL3ROW0", r[r.COL3ROW1 = 13] = "COL3ROW1", r[r.COL3ROW2 = 14] = "COL3ROW2", r[r.COL3ROW3 = 15] = "COL3ROW3";
})(mv || (mv = {}));
const LF = 45 * Math.PI / 180, BF = 1, Sb = 0.1, Eb = 500, kF = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Pi extends FI {
  static get IDENTITY() {
    return DF();
  }
  static get ZERO() {
    return OF();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return mv;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(e, t, i, n, s, c, o, d, m, y, T, P, I, D, k, $) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = n, this[4] = s, this[5] = c, this[6] = o, this[7] = d, this[8] = m, this[9] = y, this[10] = T, this[11] = P, this[12] = I, this[13] = D, this[14] = k, this[15] = $, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(e, t, i, n, s, c, o, d, m, y, T, P, I, D, k, $) {
    return this[0] = e, this[1] = s, this[2] = m, this[3] = I, this[4] = t, this[5] = c, this[6] = y, this[7] = D, this[8] = i, this[9] = o, this[10] = T, this[11] = k, this[12] = n, this[13] = d, this[14] = P, this[15] = $, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(kF);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(e) {
    return _F(this, e), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(e) {
    const {
      left: t,
      right: i,
      bottom: n,
      top: s,
      near: c = Sb,
      far: o = Eb
    } = e;
    return o === 1 / 0 ? NF(this, t, i, n, s, c) : yF(this, t, i, n, s, c, o), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(e) {
    const {
      eye: t,
      center: i = [0, 0, 0],
      up: n = [0, 1, 0]
    } = e;
    return AF(this, t, i, n), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(e) {
    const {
      left: t,
      right: i,
      bottom: n,
      top: s,
      near: c = Sb,
      far: o = Eb
    } = e;
    return wF(this, t, i, n, s, c, o), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(e) {
    const {
      fovy: t = LF,
      aspect: i = BF,
      focalDistance: n = 1,
      near: s = Sb,
      far: c = Eb
    } = e;
    jT(t);
    const o = t / 2, d = n * Math.tan(o), m = d * i;
    return this.ortho({
      left: -m,
      right: m,
      bottom: -d,
      top: d,
      near: s,
      far: c
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(e) {
    const {
      fovy: t = 45 * Math.PI / 180,
      aspect: i = 1,
      near: n = 0.1,
      far: s = 500
    } = e;
    return jT(t), vF(this, t, i, n, s), this.check();
  }
  // Accessors
  determinant() {
    return dF(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(e = [-0, -0, -0]) {
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(e = [-0, -0, -0]) {
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const i = this.getScale(t), n = 1 / i[0], s = 1 / i[1], c = 1 / i[2];
    return e[0] = this[0] * n, e[1] = this[1] * s, e[2] = this[2] * c, e[3] = 0, e[4] = this[4] * n, e[5] = this[5] * s, e[6] = this[6] * c, e[7] = 0, e[8] = this[8] * n, e[9] = this[9] * s, e[10] = this[10] * c, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const i = this.getScale(t), n = 1 / i[0], s = 1 / i[1], c = 1 / i[2];
    return e[0] = this[0] * n, e[1] = this[1] * s, e[2] = this[2] * c, e[3] = this[4] * n, e[4] = this[5] * s, e[5] = this[6] * c, e[6] = this[8] * n, e[7] = this[9] * s, e[8] = this[10] * c, e;
  }
  // Modifiers
  transpose() {
    return fF(this, this), this.check();
  }
  invert() {
    return gv(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return $f(this, e, this), this.check();
  }
  multiplyRight(e) {
    return $f(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(e) {
    return UI(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(e) {
    return gF(this, this, e), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(e) {
    return zI(this, this, e), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(e, t) {
    return pF(this, this, e, t), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(e) {
    return tx(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(e) {
    return Py(this, this, e), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(e, t) {
    return e.length === 4 ? (t = Op(t || [-0, -0, -0, -0], e, this), Og(t, 4), t) : this.transformAsPoint(e, t);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(e, t) {
    const {
      length: i
    } = e;
    let n;
    switch (i) {
      case 2:
        n = II(t || [-0, -0], e, this);
        break;
      case 3:
        n = Q2(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Og(n, e.length), n;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(e, t) {
    let i;
    switch (e.length) {
      case 2:
        i = PI(t || [-0, -0], e, this);
        break;
      case 3:
        i = MI(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return Og(i, e.length), i;
  }
  /** @deprecated */
  transformPoint(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformDirection(e, t) {
    return this.transformAsVector(e, t);
  }
  // three.js math API compatibility
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, t, i) {
    return this.identity().translate([e, t, i]);
  }
}
let n_, s_;
function OF() {
  return n_ || (n_ = new Pi([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(n_)), n_;
}
function DF() {
  return s_ || (s_ = new Pi(), Object.freeze(s_)), s_;
}
function jT(r) {
  if (r > Math.PI * 2)
    throw Error("expected radians");
}
function NF(r, e, t, i, n, s) {
  const c = 2 * s / (t - e), o = 2 * s / (n - i), d = (t + e) / (t - e), m = (n + i) / (n - i), y = -1, T = -1, P = -2 * s;
  return r[0] = c, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = d, r[9] = m, r[10] = y, r[11] = T, r[12] = 0, r[13] = 0, r[14] = P, r[15] = 0, r;
}
function VT() {
  const r = new Sc(4);
  return Sc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
}
function FF(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r;
}
function jI(r, e, t) {
  t = t * 0.5;
  const i = Math.sin(t);
  return r[0] = i * e[0], r[1] = i * e[1], r[2] = i * e[2], r[3] = Math.cos(t), r;
}
function GT(r, e, t) {
  const i = e[0], n = e[1], s = e[2], c = e[3], o = t[0], d = t[1], m = t[2], y = t[3];
  return r[0] = i * y + c * o + n * m - s * d, r[1] = n * y + c * d + s * o - i * m, r[2] = s * y + c * m + i * d - n * o, r[3] = c * y - i * o - n * d - s * m, r;
}
function UF(r, e, t) {
  t *= 0.5;
  const i = e[0], n = e[1], s = e[2], c = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = i * d + c * o, r[1] = n * d + s * o, r[2] = s * d - n * o, r[3] = c * d - i * o, r;
}
function zF(r, e, t) {
  t *= 0.5;
  const i = e[0], n = e[1], s = e[2], c = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = i * d - s * o, r[1] = n * d + c * o, r[2] = s * d + i * o, r[3] = c * d - n * o, r;
}
function jF(r, e, t) {
  t *= 0.5;
  const i = e[0], n = e[1], s = e[2], c = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = i * d + n * o, r[1] = n * d - i * o, r[2] = s * d + c * o, r[3] = c * d - s * o, r;
}
function VF(r, e) {
  const t = e[0], i = e[1], n = e[2];
  return r[0] = t, r[1] = i, r[2] = n, r[3] = Math.sqrt(Math.abs(1 - t * t - i * i - n * n)), r;
}
function H_(r, e, t, i) {
  const n = e[0], s = e[1], c = e[2], o = e[3];
  let d = t[0], m = t[1], y = t[2], T = t[3], P, I, D, k, $;
  return P = n * d + s * m + c * y + o * T, P < 0 && (P = -P, d = -d, m = -m, y = -y, T = -T), 1 - P > Dg ? (I = Math.acos(P), $ = Math.sin(I), D = Math.sin((1 - i) * I) / $, k = Math.sin(i * I) / $) : (D = 1 - i, k = i), r[0] = D * n + k * d, r[1] = D * s + k * m, r[2] = D * c + k * y, r[3] = D * o + k * T, r;
}
function GF(r, e) {
  const t = e[0], i = e[1], n = e[2], s = e[3], c = t * t + i * i + n * n + s * s, o = c ? 1 / c : 0;
  return r[0] = -t * o, r[1] = -i * o, r[2] = -n * o, r[3] = s * o, r;
}
function $F(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r[3] = e[3], r;
}
function VI(r, e) {
  const t = e[0] + e[4] + e[8];
  let i;
  if (t > 0)
    i = Math.sqrt(t + 1), r[3] = 0.5 * i, i = 0.5 / i, r[0] = (e[5] - e[7]) * i, r[1] = (e[6] - e[2]) * i, r[2] = (e[1] - e[3]) * i;
  else {
    let n = 0;
    e[4] > e[0] && (n = 1), e[8] > e[n * 3 + n] && (n = 2);
    const s = (n + 1) % 3, c = (n + 2) % 3;
    i = Math.sqrt(e[n * 3 + n] - e[s * 3 + s] - e[c * 3 + c] + 1), r[n] = 0.5 * i, i = 0.5 / i, r[3] = (e[s * 3 + c] - e[c * 3 + s]) * i, r[s] = (e[s * 3 + n] + e[n * 3 + s]) * i, r[c] = (e[c * 3 + n] + e[n * 3 + c]) * i;
  }
  return r;
}
const HF = SF, qF = rx, WF = PF, XF = MF, ZF = EF, YF = CF, GI = IF, JF = function() {
  const r = LI(), e = FT(1, 0, 0), t = FT(0, 1, 0);
  return function(i, n, s) {
    const c = K2(n, s);
    return c < -0.999999 ? ($_(r, e, n), NI(r) < 1e-6 && $_(r, t, n), ZN(r, r), jI(i, r, Math.PI), i) : c > 0.999999 ? (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i) : ($_(r, n, s), i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = 1 + c, GI(i, i));
  };
}();
(function() {
  const r = VT(), e = VT();
  return function(t, i, n, s, c, o) {
    return H_(r, i, c, o), H_(e, n, s, o), H_(t, r, e, 2 * o * (1 - o)), t;
  };
})();
(function() {
  const r = tF();
  return function(e, t, i, n) {
    return r[0] = i[0], r[3] = i[1], r[6] = i[2], r[1] = n[0], r[4] = n[1], r[7] = n[2], r[2] = -t[0], r[5] = -t[1], r[8] = -t[2], GI(e, VI(e, r));
  };
})();
const KF = [0, 0, 0, 1];
class Xg extends Z2 {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, t, i, n);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, t, i, n) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = n, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(e) {
    return VI(this, e), this.check();
  }
  fromAxisRotation(e, t) {
    return jI(this, e, t), this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    return FF(this), this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(e, t) {
    return this.fromAxisRotation(e, t);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Ki(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Ki(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ki(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Ki(e);
  }
  // Calculates the length of a quat
  len() {
    return ZF(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return YF(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(e) {
    return WF(this, e);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(e, t) {
    return JF(this, e, t), this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(e) {
    return HF(this, this, e), this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    return VF(this, this), this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    return $F(this, this), this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    return GF(this, this), this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(e, t, i) {
    return i === void 0 ? this.lerp(this, e, t) : (XF(this, e, t, i), this.check());
  }
  // Multiplies two quat's
  multiplyRight(e) {
    return GT(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return GT(this, e, this), this.check();
  }
  // Normalize a quat
  normalize() {
    const e = this.len(), t = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * t, this[1] = this[1] * t, this[2] = this[2] * t, this[3] = this[3] * t, e === 0 && (this[3] = 1), this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(e) {
    return UF(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(e) {
    return zF(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(e) {
    return jF(this, this, e), this.check();
  }
  // Scales a quat by a scalar number
  scale(e) {
    return qF(this, this, e), this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(e, t, i) {
    let n, s, c;
    switch (arguments.length) {
      case 1:
        ({
          start: n = KF,
          target: s,
          ratio: c
        } = e);
        break;
      case 2:
        n = this, s = e, c = t;
        break;
      default:
        n = e, s = t, c = i;
    }
    return H_(this, n, s, c), this.check();
  }
  transformVector4(e, t = new ex()) {
    return RF(t, e, this), Og(t, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, t) {
    return this.setAxisAngle(e, t);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const QF = 0.1, e8 = 1e-12, $I = 1e-15, t8 = 1e-20;
function HI(r, e = [], t = 0) {
  const i = Math.fround(r), n = r - i;
  return e[t] = i, e[t + 1] = n, e;
}
function r8(r) {
  return r - Math.fround(r);
}
function i8(r) {
  const e = new Float32Array(32);
  for (let t = 0; t < 4; ++t)
    for (let i = 0; i < 4; ++i) {
      const n = t * 4 + i;
      HI(r[i * 4 + t], e, n * 2);
    }
  return e;
}
const n8 = (
  /* glsl */
  `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
), s8 = {
  name: "fp32",
  vs: n8
}, o8 = (
  /* glsl */
  `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
), a8 = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
}, l8 = {
  name: "fp64arithmetic",
  vs: o8,
  defaultUniforms: a8,
  uniformTypes: {
    ONE: "f32"
  },
  // Additional Functions
  fp64ify: HI,
  fp64LowPart: r8,
  fp64ifyMatrix4: i8
}, c8 = [0, 1, 1, 1], u8 = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
), h8 = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
), $T = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: c8
  },
  vs: u8,
  fs: h8,
  getUniforms: f8
};
function f8(r = {}, e) {
  const t = {};
  if (r.highlightedObjectColor !== void 0) if (r.highlightedObjectColor === null)
    t.isHighlightActive = !1;
  else {
    t.isHighlightActive = !0;
    const i = r.highlightedObjectColor.slice(0, 3);
    t.highlightedObjectColor = i;
  }
  if (r.highlightColor) {
    const i = Array.from(r.highlightColor, (n) => n / 255);
    Number.isFinite(i[3]) || (i[3] = 1), t.highlightColor = i;
  }
  return r.isActive !== void 0 && (t.isActive = !!r.isActive, t.isAttribute = !!r.isAttribute), r.useFloatColors !== void 0 && (t.useFloatColors = !!r.useFloatColors), t;
}
const HT = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
), d8 = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
), p8 = 5, g8 = 255;
var Zg;
(function(r) {
  r[r.POINT = 0] = "POINT", r[r.DIRECTIONAL = 1] = "DIRECTIONAL";
})(Zg || (Zg = {}));
const hp = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    // MAX_LIGHTS
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: Zg.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: d8,
  vs: HT,
  fs: HT,
  getUniforms: m8
};
function m8(r, e = {}) {
  if (r = r && {
    ...r
  }, !r)
    return {
      ...hp.defaultUniforms
    };
  r.lights && (r = {
    ...r,
    ...y8(r.lights),
    lights: void 0
  });
  const {
    ambientLight: t,
    pointLights: i,
    directionalLights: n
  } = r || {};
  if (!(t || i && i.length > 0 || n && n.length > 0))
    return {
      ...hp.defaultUniforms,
      enabled: 0
    };
  const c = {
    ...hp.defaultUniforms,
    ...e,
    ..._8({
      ambientLight: t,
      pointLights: i,
      directionalLights: n
    })
  };
  return r.enabled !== void 0 && (c.enabled = r.enabled ? 1 : 0), c;
}
function _8({
  ambientLight: r,
  pointLights: e = [],
  directionalLights: t = []
}) {
  const i = {};
  i.ambientColor = Cb(r);
  let n = 0;
  for (const s of e) {
    i.lightType = Zg.POINT;
    const c = n;
    i[`lightColor${c}`] = Cb(s), i[`lightPosition${c}`] = s.position, i[`lightAttenuation${c}`] = s.attenuation || [1, 0, 0], n++;
  }
  for (const s of t) {
    i.lightType = Zg.DIRECTIONAL;
    const c = n;
    i[`lightColor${c}`] = Cb(s), i[`lightDirection${c}`] = s.direction, n++;
  }
  return n > p8 && Ht.warn("MAX_LIGHTS exceeded")(), i.directionalLightCount = t.length, i.pointLightCount = e.length, i;
}
function y8(r) {
  const e = {
    pointLights: [],
    directionalLights: []
  };
  for (const t of r || [])
    switch (t.type) {
      case "ambient":
        e.ambientLight = t;
        break;
      case "directional":
        e.directionalLights?.push(t);
        break;
      case "point":
        e.pointLights?.push(t);
        break;
    }
  return e;
}
function Cb(r = {}) {
  const {
    color: e = [0, 0, 0],
    intensity: t = 1
  } = r;
  return e.map((i) => i * t / g8);
}
const qI = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
), WI = (
  /* glsl */
  `#define MAX_LIGHTS 3

uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
), XI = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
), ZI = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: WI.replace("phongMaterial", "gouraudMaterial"),
  fs: qI.replace("phongMaterial", "gouraudMaterial"),
  source: XI.replaceAll("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: !0
  },
  dependencies: [hp],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = {
      ...r
    };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
      ...ZI.defaultUniforms,
      ...e
    };
  }
}, YI = {
  name: "phongMaterial",
  dependencies: [hp],
  // Note these are switched between phong and gouraud
  source: XI,
  vs: qI,
  fs: WI,
  defines: {
    LIGHTING_FRAGMENT: !0
  },
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = {
      ...r
    };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
      ...YI.defaultUniforms,
      ...e
    };
  }
}, b8 = (
  /* glsl */
  `out vec3 pbr_vPosition;
out vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`
), v8 = (
  /* glsl */
  `precision highp float;

uniform pbrMaterialUniforms {
  // Material is unlit
  bool unlit;

  // Base color map
  bool baseColorMapEnabled;
  vec4 baseColorFactor;

  bool normalMapEnabled;  
  float normalScale; // #ifdef HAS_NORMALMAP

  bool emissiveMapEnabled;
  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP

  vec2 metallicRoughnessValues;
  bool metallicRoughnessMapEnabled;

  bool occlusionMapEnabled;
  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP
  
  bool alphaCutoffEnabled;
  float alphaCutoff; // #ifdef ALPHA_CUTOFF
  
  // IBL
  bool IBLenabled;
  vec2 scaleIBLAmbient; // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  vec4 scaleDiffBaseMR;
  vec4 scaleFGDSpec;
  // #endif
} pbrMaterial;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Inputs from vertex shader

in vec3 pbr_vPosition;
in vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  float NdotL;                  // cos angle between normal and light direction
  float NdotV;                  // cos angle between normal and view direction
  float NdotH;                  // cos angle between normal and half vector
  float LdotH;                  // cos angle between light direction and half vector
  float VdotH;                  // cos angle between view direction and half vector
  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
  float metalness;              // metallic value at the surface
  vec3 reflectance0;            // full reflectance color (normal incidence angle)
  vec3 reflectance90;           // reflectance color at grazing angle
  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
  vec3 diffuseColor;            // color contribution from diffuse lighting
  vec3 specularColor;           // color contribution from specular lighting
  vec3 n;                       // normal at surface point
  vec3 v;                       // vector from surface point to camera
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInfo)
{
  return pbrInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInfo)
{
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInfo)
{
  float NdotL = pbrInfo.NdotL;
  float NdotV = pbrInfo.NdotV;
  float r = pbrInfo.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInfo)
{
  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
  pbrInfo.NdotL = 1.0;
  pbrInfo.NdotH = 0.0;
  pbrInfo.LdotH = 0.0;
  pbrInfo.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
  vec3 n = pbrInfo.n;
  vec3 v = pbrInfo.v;
  vec3 l = normalize(lightDirection);             // Vector from surface point to light
  vec3 h = normalize(l+v);                        // Half vector between both l and v

  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
  // Calculate the shading terms for the microfacet specular shading model
  vec3 F = specularReflection(pbrInfo);
  float G = geometricOcclusion(pbrInfo);
  float D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
  // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
#else
  vec4 baseColor = pbrMaterial.baseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbrMaterial.unlit){
    color.rgb = baseColor.rgb;
  }
  else{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    float metallic = pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();                          // normal at surface point
    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );


#ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for(int i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for(int i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));
        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
#endif

 // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
#endif

#ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
#endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
#ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`
), x8 = (
  /* wgsl */
  `struct PBRFragmentInputs {
  pbr_vPosition: vec3f,
  pbr_vUV: vec2f,
  pbr_vTBN: mat3f,
  pbr_vNormal: vec3f
};

var fragmentInputs: PBRFragmentInputs;

fn pbr_setPositionNormalTangentUV(position: vec4f, normal: vec4f, tangent: vec4f, uv: vec2f)
{
  var pos: vec4f = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  let normalW: vec3f = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  let tangentW: vec3f = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  let bitangentW: vec3f = cross(normalW, tangentW) * tangent.w;
  fragmentInputs,pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  fragmentInputs.pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}

struct pbrMaterialUniforms {
  // Material is unlit
  unlit: uint32,

  // Base color map
  baseColorMapEnabled: uint32,
  baseColorFactor: vec4f,

  normalMapEnabled : uint32,
  normalScale: f32,  // #ifdef HAS_NORMALMAP

  emissiveMapEnabled: uint32,
  emissiveFactor: vec3f, // #ifdef HAS_EMISSIVEMAP

  metallicRoughnessValues: vec2f,
  metallicRoughnessMapEnabled: uint32,

  occlusionMapEnabled: i32,
  occlusionStrength: f32, // #ifdef HAS_OCCLUSIONMAP
  
  alphaCutoffEnabled: i32,
  alphaCutoff: f32, // #ifdef ALPHA_CUTOFF
  
  // IBL
  IBLenabled: i32,
  scaleIBLAmbient: vec2f, // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  scaleDiffBaseMR: vec4f,
  scaleFGDSpec: vec4f
  // #endif
} 
  
@binding(2) @group(0) var<uniform> material : pbrMaterialUniforms;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  NdotL: f32,                  // cos angle between normal and light direction
  NdotV: f32,                  // cos angle between normal and view direction
  NdotH: f32,                  // cos angle between normal and half vector
  LdotH: f32,                  // cos angle between light direction and half vector
  VdotH: f32,                  // cos angle between view direction and half vector
  perceptualRoughness: f32,    // roughness value, as authored by the model creator (input to shader)
  metalness: f32,              // metallic value at the surface
  reflectance0: vec3f,            // full reflectance color (normal incidence angle)
  reflectance90: vec3f,           // reflectance color at grazing angle
  alphaRoughness: f32,         // roughness mapped to a more linear change in the roughness (proposed by [2])
  diffuseColor: vec3f,            // color contribution from diffuse lighting
  specularColor: vec3f,           // color contribution from specular lighting
  n: vec3f,                       // normal at surface point
  v: vec3f,                       // vector from surface point to camera
};

const M_PI = 3.141592653589793;
const c_MinRoughness = 0.04;

fn SRGBtoLINEAR(srgbIn: vec4f ) -> vec4f
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  var linOut: vec3f = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  var bLess: vec3f = step(vec3(0.04045),srgbIn.xyz);
  var linOut: vec3f = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4f(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
fn getNormal() -> vec3f
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  var pos_dx: vec3f = dFdx(pbr_vPosition);
  var pos_dy: vec3f = dFdy(pbr_vPosition);
  var tex_dx: vec3f = dFdx(vec3(pbr_vUV, 0.0));
  var tex_dy: vec3f = dFdy(vec3(pbr_vUV, 0.0));
  var t: vec3f = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  var ng: vec3f = normalize(pbr_vNormal);
#else
  var ng: vec3f = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  var b: vec3f = normalize(cross(ng, t));
  var tbn: mat3f = mat3f(t, b, ng);
#else // HAS_TANGENTS
  var tbn: mat3f = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
fn getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection) -> vec3f
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
fn diffuse(pbrInfo: PBRInfo) -> vec3<f32> {
  return pbrInfo.diffuseColor / PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
fn specularReflection(pbrInfo: PBRInfo) -> vec3<f32> {
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
fn geometricOcclusion(pbrInfo: PBRInfo) -> f32 {
  let NdotL: f32 = pbrInfo.NdotL;
  let NdotV: f32 = pbrInfo.NdotV;
  let r: f32 = pbrInfo.alphaRoughness;

  let attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  let attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
fn microfacetDistribution(pbrInfo: PBRInfo) -> f32 {
  let roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  let f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (PI * f * f);
}

fn PBRInfo_setAmbientLight(pbrInfo: ptr<function, PBRInfo>) {
  (*pbrInfo).NdotL = 1.0;
  (*pbrInfo).NdotH = 0.0;
  (*pbrInfo).LdotH = 0.0;
  (*pbrInfo).VdotH = 1.0;
}

fn PBRInfo_setDirectionalLight(pbrInfo: ptr<function, PBRInfo>, lightDirection: vec3<f32>) {
  let n = (*pbrInfo).n;
  let v = (*pbrInfo).v;
  let l = normalize(lightDirection);             // Vector from surface point to light
  let h = normalize(l + v);                      // Half vector between both l and v

  (*pbrInfo).NdotL = clamp(dot(n, l), 0.001, 1.0);
  (*pbrInfo).NdotH = clamp(dot(n, h), 0.0, 1.0);
  (*pbrInfo).LdotH = clamp(dot(l, h), 0.0, 1.0);
  (*pbrInfo).VdotH = clamp(dot(v, h), 0.0, 1.0);
}

fn PBRInfo_setPointLight(pbrInfo: ptr<function, PBRInfo>, pointLight: PointLight) {
  let light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

fn calculateFinalColor(pbrInfo: PBRInfo, lightColor: vec3<f32>) -> vec3<f32> {
  // Calculate the shading terms for the microfacet specular shading model
  let F = specularReflection(pbrInfo);
  let G = geometricOcclusion(pbrInfo);
  let D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  let diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  let specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

fn pbr_filterColor(colorUnused: vec4<f32>) -> vec4<f32> {
  // The albedo may be defined from a base texture or a flat color
  var baseColor: vec4<f32>;
  #ifdef HAS_BASECOLORMAP
  baseColor = SRGBtoLINEAR(textureSample(pbr_baseColorSampler, pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
  #else
  baseColor = pbrMaterial.baseColorFactor;
  #endif

  #ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
  #endif

  var color = vec3<f32>(0.0, 0.0, 0.0);

  if (pbrMaterial.unlit) {
    color = baseColor.rgb;
  } else {
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    var perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    var metallic = pbrMaterial.metallicRoughnessValues.x;
    #ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    let mrSample = textureSample(pbr_metallicRoughnessSampler, pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
    #endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    let alphaRoughness = perceptualRoughness * perceptualRoughness;

    let f0 = vec3<f32>(0.04);
    var diffuseColor = baseColor.rgb * (vec3<f32>(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    let specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflectance to 0%.
    let reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    let specularEnvironmentR0 = specularColor;
    let specularEnvironmentR90 = vec3<f32>(1.0, 1.0, 1.0) * reflectance90;

    let n = getNormal();                          // normal at surface point
    let v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    let NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    let reflection = -normalize(reflect(v, n));

    var pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );

    #ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(&pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for (var i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(&pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for (var i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(&pbrInfo, lighting_getPointLight(i));
        let attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
    #endif

    // Calculate lighting contribution from image based lighting source (IBL)
    #ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
    #endif

    // Apply optional PBR terms for additional (optional) shading
    #ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      let ao = textureSample(pbr_occlusionSampler, pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
    #endif

    #ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      let emissive = SRGBtoLINEAR(textureSample(pbr_emissiveSampler, pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
    #endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
    #ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3<f32>(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3<f32>(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
    #endif
  }

  return vec4<f32>(pow(color, vec3<f32>(1.0 / 2.2)), baseColor.a);
}
`
), qT = (
  /* glsl */
  `uniform pbrProjectionUniforms {
  mat4 modelViewProjectionMatrix;
  mat4 modelMatrix;
  mat4 normalMatrix;
  vec3 camera;
} pbrProjection;
`
), w8 = {
  name: "pbrProjection",
  vs: qT,
  fs: qT,
  // TODO why is this needed?
  getUniforms: (r) => r,
  uniformTypes: {
    modelViewProjectionMatrix: "mat4x4<f32>",
    modelMatrix: "mat4x4<f32>",
    normalMatrix: "mat4x4<f32>",
    camera: "vec3<i32>"
  }
}, ix = {
  props: {},
  uniforms: {},
  name: "pbrMaterial",
  dependencies: [hp, w8],
  source: x8,
  vs: b8,
  fs: v8,
  defines: {
    LIGHTING_FRAGMENT: !0,
    HAS_NORMALMAP: !1,
    HAS_EMISSIVEMAP: !1,
    HAS_OCCLUSIONMAP: !1,
    HAS_BASECOLORMAP: !1,
    HAS_METALROUGHNESSMAP: !1,
    ALPHA_CUTOFF: !1,
    USE_IBL: !1,
    PBR_DEBUG: !1
  },
  getUniforms: (r) => r,
  uniformTypes: {
    // Material is unlit
    unlit: "i32",
    // Base color map
    baseColorMapEnabled: "i32",
    baseColorFactor: "vec4<f32>",
    normalMapEnabled: "i32",
    normalScale: "f32",
    // #ifdef HAS_NORMALMAP
    emissiveMapEnabled: "i32",
    emissiveFactor: "vec3<f32>",
    // #ifdef HAS_EMISSIVEMAP
    metallicRoughnessValues: "vec2<f32>",
    metallicRoughnessMapEnabled: "i32",
    occlusionMapEnabled: "i32",
    occlusionStrength: "f32",
    // #ifdef HAS_OCCLUSIONMAP
    alphaCutoffEnabled: "i32",
    alphaCutoff: "f32",
    // #ifdef ALPHA_CUTOFF
    // IBL
    IBLenabled: "i32",
    scaleIBLAmbient: "vec2<f32>",
    // #ifdef USE_IBL
    // debugging flags used for shader output of intermediate PBR variables
    // #ifdef PBR_DEBUG
    scaleDiffBaseMR: "vec4<f32>",
    scaleFGDSpec: "vec4<f32>"
  }
}, WT = `uniform layerUniforms {
  uniform float opacity;
} layer;
`, A8 = {
  name: "layer",
  vs: WT,
  fs: WT,
  getUniforms: (r) => ({
    // apply gamma to opacity to make it visually "linear"
    // TODO - v10: use raw opacity?
    opacity: Math.pow(r.opacity, 1 / 2.2)
  }),
  uniformTypes: {
    opacity: "f32"
  }
}, T8 = (
  /* WGSL */
  `

struct ColorUniforms {
  opacity: f32,
};

var<private> color: ColorUniforms = ColorUniforms(1.0);
// TODO (kaapp) avoiding binding index collisions to handle layer opacity 
// requires some thought.
// @group(0) @binding(0) var<uniform> color: ColorUniforms;

@must_use
fn deckgl_premultiplied_alpha(fragColor: vec4<f32>) -> vec4<f32> {
    return vec4(fragColor.rgb * fragColor.a, fragColor.a); 
};
`
), S8 = {
  name: "color",
  dependencies: [],
  source: T8,
  getUniforms: (r) => ({}),
  uniformTypes: {
    opacity: "f32"
  }
  // @ts-ignore TODO v9.1
}, E8 = (
  /* wgsl */
  `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), JI = "#define SMOOTH_EDGE_RADIUS 0.5", C8 = (
  /* glsl */
  `${JI}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`
), I8 = (
  /* glsl */
  `${JI}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), KI = {
  name: "geometry",
  source: E8,
  vs: C8,
  fs: I8
}, P8 = 25;
var Us;
(function(r) {
  r[r.Start = 1] = "Start", r[r.Move = 2] = "Move", r[r.End = 4] = "End", r[r.Cancel = 8] = "Cancel";
})(Us || (Us = {}));
var Js;
(function(r) {
  r[r.None = 0] = "None", r[r.Left = 1] = "Left", r[r.Right = 2] = "Right", r[r.Up = 4] = "Up", r[r.Down = 8] = "Down", r[r.Horizontal = 3] = "Horizontal", r[r.Vertical = 12] = "Vertical", r[r.All = 15] = "All";
})(Js || (Js = {}));
var gi;
(function(r) {
  r[r.Possible = 1] = "Possible", r[r.Began = 2] = "Began", r[r.Changed = 4] = "Changed", r[r.Ended = 8] = "Ended", r[r.Recognized = 8] = "Recognized", r[r.Cancelled = 16] = "Cancelled", r[r.Failed = 32] = "Failed";
})(gi || (gi = {}));
const M8 = "compute", R8 = "auto", _v = "manipulation", q_ = "none", yv = "pan-x", bv = "pan-y";
function L8(r) {
  if (r.includes(q_))
    return q_;
  const e = r.includes(yv), t = r.includes(bv);
  return e && t ? q_ : e || t ? e ? yv : bv : r.includes(_v) ? _v : R8;
}
class B8 {
  constructor(e, t) {
    this.actions = "", this.manager = e, this.set(t);
  }
  /**
   * set the touchAction value on the element or enable the polyfill
   */
  set(e) {
    e === M8 && (e = this.compute()), this.manager.element && (this.manager.element.style.touchAction = e, this.actions = e);
  }
  /**
   * just re-set the touchAction value
   */
  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * compute the value for the touchAction property based on the recognizer's settings
   */
  compute() {
    let e = [];
    for (const t of this.manager.recognizers)
      t.options.enable && (e = e.concat(t.getTouchAction()));
    return L8(e.join(" "));
  }
}
function My(r) {
  return r.trim().split(/\s+/g);
}
function Ib(r, e, t) {
  if (r)
    for (const i of My(e))
      r.addEventListener(i, t, !1);
}
function Pb(r, e, t) {
  if (r)
    for (const i of My(e))
      r.removeEventListener(i, t, !1);
}
function XT(r) {
  return (r.ownerDocument || r).defaultView;
}
function k8(r, e) {
  let t = r;
  for (; t; ) {
    if (t === e)
      return !0;
    t = t.parentNode;
  }
  return !1;
}
function QI(r) {
  const e = r.length;
  if (e === 1)
    return {
      x: Math.round(r[0].clientX),
      y: Math.round(r[0].clientY)
    };
  let t = 0, i = 0, n = 0;
  for (; n < e; )
    t += r[n].clientX, i += r[n].clientY, n++;
  return {
    x: Math.round(t / e),
    y: Math.round(i / e)
  };
}
function ZT(r) {
  const e = [];
  let t = 0;
  for (; t < r.pointers.length; )
    e[t] = {
      clientX: Math.round(r.pointers[t].clientX),
      clientY: Math.round(r.pointers[t].clientY)
    }, t++;
  return {
    timeStamp: Date.now(),
    pointers: e,
    center: QI(e),
    deltaX: r.deltaX,
    deltaY: r.deltaY
  };
}
function eP(r, e) {
  const t = e.x - r.x, i = e.y - r.y;
  return Math.sqrt(t * t + i * i);
}
function YT(r, e) {
  const t = e.clientX - r.clientX, i = e.clientY - r.clientY;
  return Math.sqrt(t * t + i * i);
}
function O8(r, e) {
  const t = e.x - r.x, i = e.y - r.y;
  return Math.atan2(i, t) * 180 / Math.PI;
}
function JT(r, e) {
  const t = e.clientX - r.clientX, i = e.clientY - r.clientY;
  return Math.atan2(i, t) * 180 / Math.PI;
}
function tP(r, e) {
  return r === e ? Js.None : Math.abs(r) >= Math.abs(e) ? r < 0 ? Js.Left : Js.Right : e < 0 ? Js.Up : Js.Down;
}
function D8(r, e) {
  const t = e.center;
  let i = r.offsetDelta, n = r.prevDelta;
  const s = r.prevInput;
  return (e.eventType === Us.Start || s?.eventType === Us.End) && (n = r.prevDelta = {
    x: s?.deltaX || 0,
    y: s?.deltaY || 0
  }, i = r.offsetDelta = {
    x: t.x,
    y: t.y
  }), {
    deltaX: n.x + (t.x - i.x),
    deltaY: n.y + (t.y - i.y)
  };
}
function rP(r, e, t) {
  return {
    x: e / r || 0,
    y: t / r || 0
  };
}
function N8(r, e) {
  return YT(e[0], e[1]) / YT(r[0], r[1]);
}
function F8(r, e) {
  return JT(e[1], e[0]) - JT(r[1], r[0]);
}
function U8(r, e) {
  const t = r.lastInterval || e, i = e.timeStamp - t.timeStamp;
  let n, s, c, o;
  if (e.eventType !== Us.Cancel && (i > P8 || t.velocity === void 0)) {
    const d = e.deltaX - t.deltaX, m = e.deltaY - t.deltaY, y = rP(i, d, m);
    s = y.x, c = y.y, n = Math.abs(y.x) > Math.abs(y.y) ? y.x : y.y, o = tP(d, m), r.lastInterval = e;
  } else
    n = t.velocity, s = t.velocityX, c = t.velocityY, o = t.direction;
  e.velocity = n, e.velocityX = s, e.velocityY = c, e.direction = o;
}
function z8(r, e) {
  const {
    session: t
  } = r, {
    pointers: i
  } = e, {
    length: n
  } = i;
  t.firstInput || (t.firstInput = ZT(e)), n > 1 && !t.firstMultiple ? t.firstMultiple = ZT(e) : n === 1 && (t.firstMultiple = !1);
  const {
    firstInput: s,
    firstMultiple: c
  } = t, o = c ? c.center : s.center, d = e.center = QI(i);
  e.timeStamp = Date.now(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = O8(o, d), e.distance = eP(o, d);
  const {
    deltaX: m,
    deltaY: y
  } = D8(t, e);
  e.deltaX = m, e.deltaY = y, e.offsetDirection = tP(e.deltaX, e.deltaY);
  const T = rP(e.deltaTime, e.deltaX, e.deltaY);
  e.overallVelocityX = T.x, e.overallVelocityY = T.y, e.overallVelocity = Math.abs(T.x) > Math.abs(T.y) ? T.x : T.y, e.scale = c ? N8(c.pointers, i) : 1, e.rotation = c ? F8(c.pointers, i) : 0, e.maxPointers = t.prevInput ? e.pointers.length > t.prevInput.maxPointers ? e.pointers.length : t.prevInput.maxPointers : e.pointers.length;
  let P = r.element;
  return k8(e.srcEvent.target, P) && (P = e.srcEvent.target), e.target = P, U8(t, e), e;
}
function j8(r, e, t) {
  const i = t.pointers.length, n = t.changedPointers.length, s = e & Us.Start && i - n === 0, c = e & (Us.End | Us.Cancel) && i - n === 0;
  t.isFirst = !!s, t.isFinal = !!c, s && (r.session = {}), t.eventType = e;
  const o = z8(r, t);
  r.emit("hammer.input", o), r.recognize(o), r.session.prevInput = o;
}
let V8 = class {
  constructor(e) {
    this.evEl = "", this.evWin = "", this.evTarget = "", this.domHandler = (t) => {
      this.manager.options.enable && this.handler(t);
    }, this.manager = e, this.element = e.element, this.target = e.options.inputTarget || e.element;
  }
  callback(e, t) {
    j8(this.manager, e, t);
  }
  // eslint-disable @typescript-eslint/unbound-method
  /**
   * bind the events
   */
  init() {
    Ib(this.element, this.evEl, this.domHandler), Ib(this.target, this.evTarget, this.domHandler), Ib(XT(this.element), this.evWin, this.domHandler);
  }
  /**
   * unbind the events
   */
  destroy() {
    Pb(this.element, this.evEl, this.domHandler), Pb(this.target, this.evTarget, this.domHandler), Pb(XT(this.element), this.evWin, this.domHandler);
  }
};
const G8 = {
  pointerdown: Us.Start,
  pointermove: Us.Move,
  pointerup: Us.End,
  pointercancel: Us.Cancel,
  pointerout: Us.Cancel
}, $8 = "pointerdown", H8 = "pointermove pointerup pointercancel";
class q8 extends V8 {
  constructor(e) {
    super(e), this.evEl = $8, this.evWin = H8, this.store = this.manager.session.pointerEvents = [], this.init();
  }
  /**
   * handle mouse events
   */
  handler(e) {
    const {
      store: t
    } = this;
    let i = !1;
    const n = G8[e.type], s = e.pointerType, c = s === "touch";
    let o = t.findIndex((d) => d.pointerId === e.pointerId);
    n & Us.Start && (e.buttons || c) ? o < 0 && (t.push(e), o = t.length - 1) : n & (Us.End | Us.Cancel) && (i = !0), !(o < 0) && (t[o] = e, this.callback(n, {
      pointers: t,
      changedPointers: [e],
      eventType: n,
      pointerType: s,
      srcEvent: e
    }), i && t.splice(o, 1));
  }
}
const W8 = ["", "webkit", "Moz", "MS", "ms", "o"];
function X8(r, e) {
  const t = e[0].toUpperCase() + e.slice(1);
  for (const i of W8) {
    const n = i ? i + t : e;
    if (n in r)
      return n;
  }
}
const Z8 = 1, KT = 2, QT = {
  touchAction: "compute",
  enable: !0,
  inputTarget: null,
  cssProps: {
    /**
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     */
    userSelect: "none",
    /**
     * (Webkit) Disable default dragging behavior
     */
    // @ts-ignore
    userDrag: "none",
    /**
     * (iOS only) Disables the default callout shown when you touch and hold a touch target.
     * When you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     */
    // @ts-ignore
    touchCallout: "none",
    /**
     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
     */
    // @ts-ignore
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
class Y8 {
  constructor(e, t) {
    this.options = {
      ...QT,
      ...t,
      cssProps: {
        ...QT.cssProps,
        ...t.cssProps
      },
      inputTarget: t.inputTarget || e
    }, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new q8(this), this.touchAction = new B8(this, this.options.touchAction), this.toggleCssProps(!0);
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
  }
  /**
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   */
  stop(e) {
    this.session.stopped = e ? KT : Z8;
  }
  /**
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   */
  recognize(e) {
    const {
      session: t
    } = this;
    if (t.stopped)
      return;
    this.session.prevented && e.srcEvent.preventDefault();
    let i;
    const {
      recognizers: n
    } = this;
    let {
      curRecognizer: s
    } = t;
    (!s || s && s.state & gi.Recognized) && (s = t.curRecognizer = null);
    let c = 0;
    for (; c < n.length; )
      i = n[c], t.stopped !== KT && // 1
      (!s || i === s || // 2
      i.canRecognizeWith(s)) ? i.recognize(e) : i.reset(), !s && i.state & (gi.Began | gi.Changed | gi.Ended) && (s = t.curRecognizer = i), c++;
  }
  /**
   * get a recognizer by its event name.
   */
  get(e) {
    const {
      recognizers: t
    } = this;
    for (let i = 0; i < t.length; i++)
      if (t[i].options.event === e)
        return t[i];
    return null;
  }
  /**
   * add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   */
  add(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.add(i);
      return this;
    }
    const t = this.get(e.options.event);
    return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
  }
  /**
   * remove a recognizer by name or instance
   */
  remove(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.remove(i);
      return this;
    }
    const t = typeof e == "string" ? this.get(e) : e;
    if (t) {
      const {
        recognizers: i
      } = this, n = i.indexOf(t);
      n !== -1 && (i.splice(n, 1), this.touchAction.update());
    }
    return this;
  }
  /**
   * bind event
   */
  on(e, t) {
    if (!e || !t)
      return;
    const {
      handlers: i
    } = this;
    for (const n of My(e))
      i[n] = i[n] || [], i[n].push(t);
  }
  /**
   * unbind event, leave hander blank to remove all handlers
   */
  off(e, t) {
    if (!e)
      return;
    const {
      handlers: i
    } = this;
    for (const n of My(e))
      t ? i[n] && i[n].splice(i[n].indexOf(t), 1) : delete i[n];
  }
  /**
   * emit event to the listeners
   */
  emit(e, t) {
    const i = this.handlers[e] && this.handlers[e].slice();
    if (!i || !i.length)
      return;
    const n = t;
    n.type = e, n.preventDefault = function() {
      t.srcEvent.preventDefault();
    };
    let s = 0;
    for (; s < i.length; )
      i[s](n), s++;
  }
  /**
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */
  destroy() {
    this.toggleCssProps(!1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
  }
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   */
  toggleCssProps(e) {
    const {
      element: t
    } = this;
    if (t) {
      for (const [i, n] of Object.entries(this.options.cssProps)) {
        const s = X8(t.style, i);
        e ? (this.oldCssProps[s] = t.style[s], t.style[s] = n) : t.style[s] = this.oldCssProps[s] || "";
      }
      e || (this.oldCssProps = {});
    }
  }
}
let J8 = 1;
function K8() {
  return J8++;
}
function e3(r) {
  return r & gi.Cancelled ? "cancel" : r & gi.Ended ? "end" : r & gi.Changed ? "move" : r & gi.Began ? "start" : "";
}
class iP {
  constructor(e) {
    this.options = e, this.id = K8(), this.state = gi.Possible, this.simultaneous = {}, this.requireFail = [];
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), this.manager.touchAction.update(), this;
  }
  /**
   * recognize simultaneous with an other recognizer.
   */
  recognizeWith(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.recognizeWith(n);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const {
      simultaneous: i
    } = this;
    return i[t.id] || (i[t.id] = t, t.recognizeWith(this)), this;
  }
  /**
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   */
  dropRecognizeWith(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.dropRecognizeWith(i);
      return this;
    }
    let t;
    return typeof e == "string" ? t = this.manager.get(e) : t = e, t && delete this.simultaneous[t.id], this;
  }
  /**
   * recognizer can only run when an other is failing
   */
  requireFailure(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.requireFailure(n);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const {
      requireFail: i
    } = this;
    return i.indexOf(t) === -1 && (i.push(t), t.requireFailure(this)), this;
  }
  /**
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   */
  dropRequireFailure(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.dropRequireFailure(i);
      return this;
    }
    let t;
    if (typeof e == "string" ? t = this.manager.get(e) : t = e, t) {
      const i = this.requireFail.indexOf(t);
      i > -1 && this.requireFail.splice(i, 1);
    }
    return this;
  }
  /**
   * has require failures boolean
   */
  hasRequireFailures() {
    return !!this.requireFail.find((e) => e.options.enable);
  }
  /**
   * if the recognizer can recognize simultaneous with an other recognizer
   */
  canRecognizeWith(e) {
    return !!this.simultaneous[e.id];
  }
  /**
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   */
  emit(e) {
    if (!e) return;
    const {
      state: t
    } = this;
    t < gi.Ended && this.manager.emit(this.options.event + e3(t), e), this.manager.emit(this.options.event, e), e.additionalEvent && this.manager.emit(e.additionalEvent, e), t >= gi.Ended && this.manager.emit(this.options.event + e3(t), e);
  }
  /**
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   */
  tryEmit(e) {
    this.canEmit() ? this.emit(e) : this.state = gi.Failed;
  }
  /**
   * can we emit?
   */
  canEmit() {
    let e = 0;
    for (; e < this.requireFail.length; ) {
      if (!(this.requireFail[e].state & (gi.Failed | gi.Possible)))
        return !1;
      e++;
    }
    return !0;
  }
  /**
   * update the recognizer
   */
  recognize(e) {
    const t = {
      ...e
    };
    if (!this.options.enable) {
      this.reset(), this.state = gi.Failed;
      return;
    }
    this.state & (gi.Recognized | gi.Cancelled | gi.Failed) && (this.state = gi.Possible), this.state = this.process(t), this.state & (gi.Began | gi.Changed | gi.Ended | gi.Cancelled) && this.tryEmit(t);
  }
  /**
   * return the event names that are emitted by this recognizer
   */
  getEventNames() {
    return [this.options.event];
  }
  /**
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   */
  reset() {
  }
}
class nP extends iP {
  /**
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   */
  attrTest(e) {
    const t = this.options.pointers;
    return t === 0 || e.pointers.length === t;
  }
  /**
   * Process the input and return the state for the recognizer
   */
  process(e) {
    const {
      state: t
    } = this, {
      eventType: i
    } = e, n = t & (gi.Began | gi.Changed), s = this.attrTest(e);
    return n && (i & Us.Cancel || !s) ? t | gi.Cancelled : n || s ? i & Us.End ? t | gi.Ended : t & gi.Began ? t | gi.Changed : gi.Began : gi.Failed;
  }
}
class t3 extends iP {
  constructor(e = {}) {
    super({
      enable: !0,
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10,
      ...e
    }), this.pTime = null, this.pCenter = null, this._timer = null, this._input = null, this.count = 0;
  }
  getTouchAction() {
    return [_v];
  }
  process(e) {
    const {
      options: t
    } = this, i = e.pointers.length === t.pointers, n = e.distance < t.threshold, s = e.deltaTime < t.time;
    if (this.reset(), e.eventType & Us.Start && this.count === 0)
      return this.failTimeout();
    if (n && s && i) {
      if (e.eventType !== Us.End)
        return this.failTimeout();
      const c = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, o = !this.pCenter || eP(this.pCenter, e.center) < t.posThreshold;
      if (this.pTime = e.timeStamp, this.pCenter = e.center, !o || !c ? this.count = 1 : this.count += 1, this._input = e, this.count % t.taps === 0)
        return this.hasRequireFailures() ? (this._timer = setTimeout(() => {
          this.state = gi.Recognized, this.tryEmit(this._input);
        }, t.interval), gi.Began) : gi.Recognized;
    }
    return gi.Failed;
  }
  failTimeout() {
    return this._timer = setTimeout(() => {
      this.state = gi.Failed;
    }, this.options.interval), gi.Failed;
  }
  reset() {
    clearTimeout(this._timer);
  }
  emit(e) {
    this.state === gi.Recognized && (e.tapCount = this.count, this.manager.emit(this.options.event, e));
  }
}
const Q8 = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
class r3 extends nP {
  constructor(e = {}) {
    super({
      enable: !0,
      pointers: 1,
      event: "pan",
      threshold: 10,
      direction: Js.All,
      ...e
    }), this.pX = null, this.pY = null;
  }
  getTouchAction() {
    const {
      options: {
        direction: e
      }
    } = this, t = [];
    return e & Js.Horizontal && t.push(bv), e & Js.Vertical && t.push(yv), t;
  }
  getEventNames() {
    return Q8.map((e) => this.options.event + e);
  }
  directionTest(e) {
    const {
      options: t
    } = this;
    let i = !0, {
      distance: n
    } = e, {
      direction: s
    } = e;
    const c = e.deltaX, o = e.deltaY;
    return s & t.direction || (t.direction & Js.Horizontal ? (s = c === 0 ? Js.None : c < 0 ? Js.Left : Js.Right, i = c !== this.pX, n = Math.abs(e.deltaX)) : (s = o === 0 ? Js.None : o < 0 ? Js.Up : Js.Down, i = o !== this.pY, n = Math.abs(e.deltaY))), e.direction = s, i && n > t.threshold && !!(s & t.direction);
  }
  attrTest(e) {
    return super.attrTest(e) && (!!(this.state & gi.Began) || !(this.state & gi.Began) && this.directionTest(e));
  }
  emit(e) {
    this.pX = e.deltaX, this.pY = e.deltaY;
    const t = Js[e.direction].toLowerCase();
    t && (e.additionalEvent = this.options.event + t), super.emit(e);
  }
}
const eU = ["", "start", "move", "end", "cancel", "in", "out"];
class tU extends nP {
  constructor(e = {}) {
    super({
      enable: !0,
      event: "pinch",
      threshold: 0,
      pointers: 2,
      ...e
    });
  }
  getTouchAction() {
    return [q_];
  }
  getEventNames() {
    return eU.map((e) => this.options.event + e);
  }
  attrTest(e) {
    return super.attrTest(e) && (Math.abs(e.scale - 1) > this.options.threshold || !!(this.state & gi.Began));
  }
  emit(e) {
    if (e.scale !== 1) {
      const t = e.scale < 1 ? "in" : "out";
      e.additionalEvent = this.options.event + t;
    }
    super.emit(e);
  }
}
class e0 {
  constructor(e, t, i) {
    this.element = e, this.callback = t, this.options = i;
  }
}
const rU = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", iU = rU.indexOf("firefox") !== -1, i3 = 4.000244140625, nU = 40, sU = 0.25;
class oU extends e0 {
  constructor(e, t, i) {
    super(e, t, {
      enable: !0,
      ...i
    }), this.handleEvent = (n) => {
      if (!this.options.enable)
        return;
      let s = n.deltaY;
      globalThis.WheelEvent && (iU && n.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL && (s /= globalThis.devicePixelRatio), n.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE && (s *= nU)), s !== 0 && s % i3 === 0 && (s = Math.floor(s / i3)), n.shiftKey && s && (s = s * sU), this.callback({
        type: "wheel",
        center: {
          x: n.clientX,
          y: n.clientY
        },
        delta: -s,
        srcEvent: n,
        pointerType: "mouse",
        target: n.target
      });
    }, e.addEventListener("wheel", this.handleEvent, {
      passive: !1
    });
  }
  destroy() {
    this.element.removeEventListener("wheel", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "wheel" && (this.options.enable = t);
  }
}
const n3 = ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"];
class aU extends e0 {
  constructor(e, t, i) {
    super(e, t, {
      enable: !0,
      ...i
    }), this.handleEvent = (s) => {
      this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s);
    }, this.pressed = !1;
    const {
      enable: n
    } = this.options;
    this.enableMoveEvent = n, this.enableLeaveEvent = n, this.enableEnterEvent = n, this.enableOutEvent = n, this.enableOverEvent = n, n3.forEach((s) => e.addEventListener(s, this.handleEvent));
  }
  destroy() {
    n3.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    switch (e) {
      case "pointermove":
        this.enableMoveEvent = t;
        break;
      case "pointerover":
        this.enableOverEvent = t;
        break;
      case "pointerout":
        this.enableOutEvent = t;
        break;
      case "pointerenter":
        this.enableEnterEvent = t;
        break;
      case "pointerleave":
        this.enableLeaveEvent = t;
        break;
    }
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit("pointerover", e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit("pointerout", e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit("pointerenter", e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit("pointerleave", e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit("pointermove", e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
}
const s3 = ["keydown", "keyup"];
class lU extends e0 {
  constructor(e, t, i) {
    super(e, t, {
      enable: !0,
      tabIndex: 0,
      ...i
    }), this.handleEvent = (n) => {
      const s = n.target || n.srcElement;
      s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && n.type === "keydown" && this.callback({
        type: "keydown",
        srcEvent: n,
        key: n.key,
        target: n.target
      }), this.enableUpEvent && n.type === "keyup" && this.callback({
        type: "keyup",
        srcEvent: n,
        key: n.key,
        target: n.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, e.tabIndex = this.options.tabIndex, e.style.outline = "none", s3.forEach((n) => e.addEventListener(n, this.handleEvent));
  }
  destroy() {
    s3.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "keydown" && (this.enableDownEvent = t), e === "keyup" && (this.enableUpEvent = t);
  }
}
class cU extends e0 {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (n) => {
      this.options.enable && this.callback({
        type: "contextmenu",
        center: {
          x: n.clientX,
          y: n.clientY
        },
        srcEvent: n,
        pointerType: "mouse",
        target: n.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "contextmenu" && (this.options.enable = t);
  }
}
const o3 = 1, vv = 2, a3 = 4, uU = {
  pointerdown: o3,
  pointermove: vv,
  pointerup: a3,
  mousedown: o3,
  mousemove: vv,
  mouseup: a3
}, hU = 0, fU = 1, dU = 2, pU = 1, gU = 2, mU = 4;
function _U(r) {
  const e = uU[r.srcEvent.type];
  if (!e)
    return null;
  const {
    buttons: t,
    button: i
  } = r.srcEvent;
  let n = !1, s = !1, c = !1;
  return e === vv ? (n = !!(t & pU), s = !!(t & mU), c = !!(t & gU)) : (n = i === hU, s = i === fU, c = i === dU), {
    leftButton: n,
    middleButton: s,
    rightButton: c
  };
}
function yU(r, e) {
  const t = r.center;
  if (!t)
    return null;
  const i = e.getBoundingClientRect(), n = i.width / e.offsetWidth || 1, s = i.height / e.offsetHeight || 1, c = {
    x: (t.x - i.left - e.clientLeft) / n,
    y: (t.y - i.top - e.clientTop) / s
  };
  return {
    center: t,
    offsetCenter: c
  };
}
const bU = {
  srcElement: "root",
  priority: 0
};
class vU {
  constructor(e, t) {
    this.handleEvent = (i) => {
      if (this.isEmpty())
        return;
      const n = this._normalizeEvent(i);
      let s = i.srcEvent.target;
      for (; s && s !== n.rootElement; ) {
        if (this._emit(n, s), n.handled)
          return;
        s = s.parentNode;
      }
      this._emit(n, "root");
    }, this.eventManager = e, this.recognizerName = t, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, i, n = !1, s = !1) {
    const {
      handlers: c,
      handlersByElement: o
    } = this, d = {
      ...bU,
      ...i
    };
    let m = o.get(d.srcElement);
    m || (m = [], o.set(d.srcElement, m));
    const y = {
      type: e,
      handler: t,
      srcElement: d.srcElement,
      priority: d.priority
    };
    n && (y.once = !0), s && (y.passive = !0), c.push(y), this._active = this._active || !y.passive;
    let T = m.length - 1;
    for (; T >= 0 && !(m[T].priority >= y.priority); )
      T--;
    m.splice(T + 1, 0, y);
  }
  remove(e, t) {
    const {
      handlers: i,
      handlersByElement: n
    } = this;
    for (let s = i.length - 1; s >= 0; s--) {
      const c = i[s];
      if (c.type === e && c.handler === t) {
        i.splice(s, 1);
        const o = n.get(c.srcElement);
        o.splice(o.indexOf(c), 1), o.length === 0 && n.delete(c.srcElement);
      }
    }
    this._active = i.some((s) => !s.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const i = this.handlersByElement.get(t);
    if (i) {
      let n = !1;
      const s = () => {
        e.handled = !0;
      }, c = () => {
        e.handled = !0, n = !0;
      }, o = [];
      for (let d = 0; d < i.length; d++) {
        const {
          type: m,
          handler: y,
          once: T
        } = i[d];
        if (y({
          ...e,
          type: m,
          stopPropagation: s,
          stopImmediatePropagation: c
        }), T && o.push(i[d]), n)
          break;
      }
      for (let d = 0; d < o.length; d++) {
        const {
          type: m,
          handler: y
        } = o[d];
        this.remove(m, y);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ..._U(e),
      ...yU(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
}
function xU(r) {
  if ("recognizer" in r)
    return r;
  let e;
  const t = Array.isArray(r) ? [...r] : [r];
  if (typeof t[0] == "function") {
    const i = t.shift(), n = t.shift() || {};
    e = new i(n);
  } else
    e = t.shift();
  return {
    recognizer: e,
    recognizeWith: typeof t[0] == "string" ? [t[0]] : t[0],
    requireFailure: typeof t[1] == "string" ? [t[1]] : t[1]
  };
}
class wU {
  constructor(e = null, t = {}) {
    if (this._onBasicInput = (i) => {
      this.manager.emit(i.srcEvent.type, i);
    }, this._onOtherEvent = (i) => {
      this.manager.emit(i.type, i);
    }, this.options = {
      recognizers: [],
      events: {},
      touchAction: "compute",
      tabIndex: 0,
      cssProps: {},
      ...t
    }, this.events = /* @__PURE__ */ new Map(), this.element = e, !!e) {
      this.manager = new Y8(e, this.options);
      for (const i of this.options.recognizers) {
        const {
          recognizer: n,
          recognizeWith: s,
          requireFailure: c
        } = xU(i);
        this.manager.add(n), s && n.recognizeWith(s), c && n.requireFailure(c);
      }
      this.manager.on("hammer.input", this._onBasicInput), this.wheelInput = new oU(e, this._onOtherEvent, {
        enable: !1
      }), this.moveInput = new aU(e, this._onOtherEvent, {
        enable: !1
      }), this.keyInput = new lU(e, this._onOtherEvent, {
        enable: !1,
        tabIndex: t.tabIndex
      }), this.contextmenuInput = new cU(e, this._onOtherEvent, {
        enable: !1
      }), this.on(this.options.events);
    }
  }
  getElement() {
    return this.element;
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy());
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, i) {
    this._addEventHandler(e, t, i, !1);
  }
  once(e, t, i) {
    this._addEventHandler(e, t, i, !0);
  }
  watch(e, t, i) {
    this._addEventHandler(e, t, i, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    const {
      manager: i
    } = this;
    if (!i)
      return;
    const n = i.get(e);
    n && (n.set({
      enable: t
    }), i.touchAction.update()), this.wheelInput?.enableEventType(e, t), this.moveInput?.enableEventType(e, t), this.keyInput?.enableEventType(e, t), this.contextmenuInput?.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, i, n, s) {
    if (typeof e != "string") {
      i = t;
      for (const [m, y] of Object.entries(e))
        this._addEventHandler(m, y, i, n, s);
      return;
    }
    const {
      manager: c,
      events: o
    } = this;
    if (!c) return;
    let d = o.get(e);
    if (!d) {
      const m = this._getRecognizerName(e) || e;
      d = new vU(this, m), o.set(e, d), c && c.on(e, d.handleEvent);
    }
    d.add(e, t, i, n, s), d.isEmpty() || this._toggleRecognizer(d.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const [s, c] of Object.entries(e))
        this._removeEventHandler(s, c);
      return;
    }
    const {
      events: i
    } = this, n = i.get(e);
    if (n && (n.remove(e, t), n.isEmpty())) {
      const {
        recognizerName: s
      } = n;
      let c = !1;
      for (const o of i.values())
        if (o.recognizerName === s && !o.isEmpty()) {
          c = !0;
          break;
        }
      c || this._toggleRecognizer(s, !1);
    }
  }
  _getRecognizerName(e) {
    return this.manager.recognizers.find((t) => t.getEventNames().includes(e))?.options.event;
  }
}
const Mi = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(Mi, "IDENTITY", {
  get: () => (Ni.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const nl = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, Yg = {
  common: 0,
  meters: 1,
  pixels: 2
}, xv = {
  click: "onClick",
  dblclick: "onClick",
  panstart: "onDragStart",
  panmove: "onDrag",
  panend: "onDragEnd"
}, l3 = {
  multipan: [r3, {
    threshold: 10,
    direction: Js.Vertical,
    pointers: 2
  }],
  pinch: [tU, {}, null, ["multipan"]],
  pan: [r3, {
    threshold: 1
  }, ["pinch"], ["multipan"]],
  dblclick: [t3, {
    event: "dblclick",
    taps: 2
  }],
  click: [t3, {
    event: "click"
  }, null, ["dblclick"]]
};
function AU(r, e) {
  if (r === e)
    return !0;
  if (Array.isArray(r)) {
    const t = r.length;
    if (!e || e.length !== t)
      return !1;
    for (let i = 0; i < t; i++)
      if (r[i] !== e[i])
        return !1;
    return !0;
  }
  return !1;
}
function fm(r) {
  let e = {}, t;
  return (i) => {
    for (const n in i)
      if (!AU(i[n], e[n])) {
        t = r(i), e = i;
        break;
      }
    return t;
  };
}
const c3 = [0, 0, 0, 0], TU = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], sP = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], SU = [0, 0, 0], oP = [0, 0, 0], EU = fm(PU);
function aP(r, e, t = oP) {
  t.length < 3 && (t = [t[0], t[1], 0]);
  let i = t, n, s = !0;
  switch (e === Mi.LNGLAT_OFFSETS || e === Mi.METER_OFFSETS ? n = t : n = r.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(r.longitude), Math.fround(r.latitude), 0]
  ) : null, r.projectionMode) {
    case nl.WEB_MERCATOR:
      (e === Mi.LNGLAT || e === Mi.CARTESIAN) && (n = [0, 0, 0], s = !1);
      break;
    case nl.WEB_MERCATOR_AUTO_OFFSET:
      e === Mi.LNGLAT ? i = n : e === Mi.CARTESIAN && (i = [Math.fround(r.center[0]), Math.fround(r.center[1]), 0], n = r.unprojectPosition(i), i[0] -= t[0], i[1] -= t[1], i[2] -= t[2]);
      break;
    case nl.IDENTITY:
      i = r.position.map(Math.fround), i[2] = i[2] || 0;
      break;
    case nl.GLOBE:
      s = !1, n = null;
      break;
    default:
      s = !1;
  }
  return {
    geospatialOrigin: n,
    shaderCoordinateOrigin: i,
    offsetMode: s
  };
}
function CU(r, e, t) {
  const {
    viewMatrixUncentered: i,
    projectionMatrix: n
  } = r;
  let {
    viewMatrix: s,
    viewProjectionMatrix: c
  } = r, o = c3, d = c3, m = r.cameraPosition;
  const {
    geospatialOrigin: y,
    shaderCoordinateOrigin: T,
    offsetMode: P
  } = aP(r, e, t);
  return P && (d = r.projectPosition(y || T), m = [m[0] - d[0], m[1] - d[1], m[2] - d[2]], d[3] = 1, o = Op([], d, c), s = i || s, c = $f([], n, s), c = $f([], c, TU)), {
    viewMatrix: s,
    viewProjectionMatrix: c,
    projectionCenter: o,
    originCommon: d,
    cameraPosCommon: m,
    shaderCoordinateOrigin: T,
    geospatialOrigin: y
  };
}
function IU({
  viewport: r,
  devicePixelRatio: e = 1,
  modelMatrix: t = null,
  // Match Layer.defaultProps
  coordinateSystem: i = Mi.DEFAULT,
  coordinateOrigin: n = oP,
  autoWrapLongitude: s = !1
}) {
  i === Mi.DEFAULT && (i = r.isGeospatial ? Mi.LNGLAT : Mi.CARTESIAN);
  const c = EU({
    viewport: r,
    devicePixelRatio: e,
    coordinateSystem: i,
    coordinateOrigin: n
  });
  return c.wrapLongitude = s, c.modelMatrix = t || sP, c;
}
function PU({
  viewport: r,
  devicePixelRatio: e,
  coordinateSystem: t,
  coordinateOrigin: i
}) {
  const {
    projectionCenter: n,
    viewProjectionMatrix: s,
    originCommon: c,
    cameraPosCommon: o,
    shaderCoordinateOrigin: d,
    geospatialOrigin: m
  } = CU(r, t, i), y = r.getDistanceScales(), T = [r.width * e, r.height * e], P = Op([], [0, 0, -r.focalDistance, 1], r.projectionMatrix)[3] || 1, I = {
    // Projection mode values
    coordinateSystem: t,
    projectionMode: r.projectionMode,
    coordinateOrigin: d,
    commonOrigin: c.slice(0, 3),
    center: n,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    pseudoMeters: !!r._pseudoMeters,
    // Screen size
    viewportSize: T,
    devicePixelRatio: e,
    focalDistance: P,
    commonUnitsPerMeter: y.unitsPerMeter,
    commonUnitsPerWorldUnit: y.unitsPerMeter,
    commonUnitsPerWorldUnit2: SU,
    scale: r.scale,
    // This is the mercator scale (2 ** zoom)
    wrapLongitude: !1,
    viewProjectionMatrix: s,
    modelMatrix: sP,
    // This is for lighting calculations
    cameraPosition: o
  };
  if (m) {
    const D = r.getDistanceScales(m);
    switch (t) {
      case Mi.METER_OFFSETS:
        I.commonUnitsPerWorldUnit = D.unitsPerMeter, I.commonUnitsPerWorldUnit2 = D.unitsPerMeter2;
        break;
      case Mi.LNGLAT:
      case Mi.LNGLAT_OFFSETS:
        r._pseudoMeters || (I.commonUnitsPerMeter = D.unitsPerMeter), I.commonUnitsPerWorldUnit = D.unitsPerDegree, I.commonUnitsPerWorldUnit2 = D.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case Mi.CARTESIAN:
        I.commonUnitsPerWorldUnit = [1, 1, D.unitsPerMeter[2]], I.commonUnitsPerWorldUnit2 = [0, 0, D.unitsPerMeter2[2]];
        break;
    }
  }
  return I;
}
const MU = Object.keys(Mi).map((r) => `const COORDINATE_SYSTEM_${r}: i32 = ${Mi[r]};`).join(""), RU = Object.keys(nl).map((r) => `const PROJECTION_MODE_${r}: i32 = ${nl[r]};`).join(""), LU = Object.keys(Yg).map((r) => `const UNIT_${r.toUpperCase()}: i32 = ${Yg[r]};`).join(""), BU = (
  /* wgsl */
  `${MU}
${RU}
${LU}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`
), kU = (
  /* wgsl */
  `${BU}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the z‑axis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`
), OU = Object.keys(Mi).map((r) => `const int COORDINATE_SYSTEM_${r} = ${Mi[r]};`).join(""), DU = Object.keys(nl).map((r) => `const int PROJECTION_MODE_${r} = ${nl[r]};`).join(""), NU = Object.keys(Yg).map((r) => `const int UNIT_${r.toUpperCase()} = ${Yg[r]};`).join(""), FU = (
  /* glsl */
  `${OU}
${DU}
${NU}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`
), UU = {};
function zU(r = UU) {
  return "viewport" in r ? IU(r) : {};
}
const nx = {
  name: "project",
  dependencies: [s8, KI],
  source: kU,
  vs: FU,
  getUniforms: zU,
  uniformTypes: {
    wrapLongitude: "f32",
    coordinateSystem: "i32",
    commonUnitsPerMeter: "vec3<f32>",
    projectionMode: "i32",
    scale: "f32",
    commonUnitsPerWorldUnit: "vec3<f32>",
    commonUnitsPerWorldUnit2: "vec3<f32>",
    center: "vec4<f32>",
    modelMatrix: "mat4x4<f32>",
    viewProjectionMatrix: "mat4x4<f32>",
    viewportSize: "vec2<f32>",
    devicePixelRatio: "f32",
    focalDistance: "f32",
    cameraPosition: "vec3<f32>",
    coordinateOrigin: "vec3<f32>",
    commonOrigin: "vec3<f32>",
    pseudoMeters: "f32"
  }
  // @ts-ignore TODO v9.1
}, jU = (
  /* wgsl */
  `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`
), VU = (
  /* glsl */
  `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`
), sx = {
  name: "project32",
  dependencies: [nx],
  source: jU,
  vs: VU
};
function GU() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function fp(r, e) {
  const t = Op([], e, r);
  return rx(t, t, 1 / t[3]), t;
}
function u3(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function wv(r, e, t) {
  return r < e ? e : r > t ? t : r;
}
function $U(r) {
  return Math.log(r) * Math.LOG2E;
}
const ox = Math.log2 || $U;
function lh(r, e) {
  if (!r)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const xc = Math.PI, lP = xc / 4, Nl = xc / 180, Av = 180 / xc, wp = 512, Ry = 4003e4, zh = 85.051129, HU = 1.5;
function qU(r) {
  return ox(r);
}
function Jg(r) {
  const [e, t] = r;
  lh(Number.isFinite(e)), lh(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const i = e * Nl, n = t * Nl, s = wp * (i + xc) / (2 * xc), c = wp * (xc + Math.log(Math.tan(lP + n * 0.5))) / (2 * xc);
  return [s, c];
}
function Ap(r) {
  const [e, t] = r, i = e / wp * (2 * xc) - xc, n = 2 * (Math.atan(Math.exp(t / wp * (2 * xc) - xc)) - lP);
  return [i * Av, n * Av];
}
function WU(r) {
  const {
    latitude: e
  } = r;
  lh(Number.isFinite(e));
  const t = Math.cos(e * Nl);
  return qU(Ry * t) - 9;
}
function W_(r) {
  const e = Math.cos(r * Nl);
  return wp / Ry / e;
}
function Tv(r) {
  const {
    latitude: e,
    longitude: t,
    highPrecision: i = !1
  } = r;
  lh(Number.isFinite(e) && Number.isFinite(t));
  const n = wp, s = Math.cos(e * Nl), c = n / 360, o = c / s, d = n / Ry / s, m = {
    unitsPerMeter: [d, d, d],
    metersPerUnit: [1 / d, 1 / d, 1 / d],
    unitsPerDegree: [c, o, d],
    degreesPerUnit: [1 / c, 1 / o, 1 / d]
  };
  if (i) {
    const y = Nl * Math.tan(e * Nl) / s, T = c * y / 2, P = n / Ry * y, I = P / o * d;
    m.unitsPerDegree2 = [0, T, P], m.unitsPerMeter2 = [I, 0, I];
  }
  return m;
}
function cP(r, e) {
  const [t, i, n] = r, [s, c, o] = e, {
    unitsPerMeter: d,
    unitsPerMeter2: m
  } = Tv({
    longitude: t,
    latitude: i,
    highPrecision: !0
  }), y = Jg(r);
  y[0] += s * (d[0] + m[0] * c), y[1] += c * (d[1] + m[1] * c);
  const T = Ap(y), P = (n || 0) + (o || 0);
  return Number.isFinite(n) || Number.isFinite(o) ? [T[0], T[1], P] : T;
}
function XU(r) {
  const {
    // Viewport props
    height: e,
    pitch: t,
    bearing: i,
    altitude: n,
    // Pre-calculated parameters
    scale: s,
    center: c
  } = r, o = GU();
  Py(o, o, [0, 0, -n]), UI(o, o, -t * Nl), zI(o, o, i * Nl);
  const d = s / e;
  return tx(o, o, [d, d, d]), c && Py(o, o, XN([], c)), o;
}
function ZU(r) {
  const {
    width: e,
    height: t,
    altitude: i,
    pitch: n = 0,
    offset: s,
    center: c,
    scale: o,
    nearZMultiplier: d = 1,
    farZMultiplier: m = 1
  } = r;
  let {
    fovy: y = Kg(HU)
  } = r;
  i !== void 0 && (y = Kg(i));
  const T = y * Nl, P = n * Nl, I = ax(y);
  let D = I;
  c && (D += c[2] * o / Math.cos(P) / t);
  const k = T * (0.5 + (s ? s[1] : 0) / t), $ = Math.sin(k) * D / Math.sin(wv(Math.PI / 2 - P - k, 0.01, Math.PI - 0.01)), G = Math.sin(P) * $ + D, te = D * 10, Z = Math.min(G * m, te);
  return {
    fov: T,
    aspect: e / t,
    focalDistance: I,
    near: d,
    far: Z
  };
}
function Kg(r) {
  return 2 * Math.atan(0.5 / r) * Av;
}
function ax(r) {
  return 0.5 / Math.tan(0.5 * r * Nl);
}
function uP(r, e) {
  const [t, i, n = 0] = r;
  return lh(Number.isFinite(t) && Number.isFinite(i) && Number.isFinite(n)), fp(e, [t, i, n, 1]);
}
function lx(r, e, t = 0) {
  const [i, n, s] = r;
  if (lh(Number.isFinite(i) && Number.isFinite(n), "invalid pixel coordinate"), Number.isFinite(s))
    return fp(e, [i, n, s, 1]);
  const c = fp(e, [i, n, 0, 1]), o = fp(e, [i, n, 1, 1]), d = c[2], m = o[2], y = d === m ? 0 : ((t || 0) - d) / (m - d);
  return EI([], c, o, y);
}
function YU(r) {
  const {
    width: e,
    height: t,
    bounds: i,
    minExtent: n = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: s = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: c = [0, 0]
  } = r, [[o, d], [m, y]] = i, T = JU(r.padding), P = Jg([o, wv(y, -zh, zh)]), I = Jg([m, wv(d, -zh, zh)]), D = [Math.max(Math.abs(I[0] - P[0]), n), Math.max(Math.abs(I[1] - P[1]), n)], k = [e - T.left - T.right - Math.abs(c[0]) * 2, t - T.top - T.bottom - Math.abs(c[1]) * 2];
  lh(k[0] > 0 && k[1] > 0);
  const $ = k[0] / D[0], G = k[1] / D[1], te = (T.right - T.left) / 2 / $, Z = (T.top - T.bottom) / 2 / G, H = [(I[0] + P[0]) / 2 + te, (I[1] + P[1]) / 2 + Z], J = Ap(H), re = Math.min(s, ox(Math.abs(Math.min($, G))));
  return lh(Number.isFinite(re)), {
    longitude: J[0],
    latitude: J[1],
    zoom: re
  };
}
function JU(r = 0) {
  return typeof r == "number" ? {
    top: r,
    bottom: r,
    left: r,
    right: r
  } : (lh(Number.isFinite(r.top) && Number.isFinite(r.bottom) && Number.isFinite(r.left) && Number.isFinite(r.right)), r);
}
const h3 = Math.PI / 180;
function KU(r, e = 0) {
  const {
    width: t,
    height: i,
    unproject: n
  } = r, s = {
    targetZ: e
  }, c = n([0, i], s), o = n([t, i], s);
  let d, m;
  const y = r.fovy ? 0.5 * r.fovy * h3 : Math.atan(0.5 / r.altitude), T = (90 - r.pitch) * h3;
  return y > T - 0.01 ? (d = f3(r, 0, e), m = f3(r, t, e)) : (d = n([0, 0], s), m = n([t, 0], s)), [c, o, m, d];
}
function f3(r, e, t) {
  const {
    pixelUnprojectionMatrix: i
  } = r, n = fp(i, [e, 0, 1, 1]), s = fp(i, [e, r.height, 1, 1]), o = (t * r.distanceScales.unitsPerMeter[2] - n[2]) / (s[2] - n[2]), d = EI([], n, s, o), m = Ap(d);
  return m.push(t), m;
}
const d3 = 512;
function QU(r) {
  const {
    width: e,
    height: t,
    pitch: i = 0
  } = r;
  let {
    longitude: n,
    latitude: s,
    zoom: c,
    bearing: o = 0
  } = r;
  (n < -180 || n > 180) && (n = u3(n + 180, 360) - 180), (o < -180 || o > 180) && (o = u3(o + 180, 360) - 180);
  const d = ox(t / d3);
  if (c <= d)
    c = d, s = 0;
  else {
    const m = t / 2 / Math.pow(2, c), y = Ap([0, m])[1];
    if (s < y)
      s = y;
    else {
      const T = Ap([0, d3 - m])[1];
      s > T && (s = T);
    }
  }
  return {
    width: e,
    height: t,
    longitude: n,
    latitude: s,
    zoom: c,
    pitch: i,
    bearing: o
  };
}
const hP = (
  /* glsl */
  `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
), ez = (
  /* glsl */
  `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
), tz = `
${hP}
${ez}
`, rz = (
  /* glsl */
  `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
), iz = `
${hP}
${rz}
`, nz = fm(cz), sz = fm(uz), oz = [0, 0, 0, 1], az = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function lz(r, e) {
  const [t, i, n] = r, s = lx([t, i, n], e);
  return Number.isFinite(n) ? s : [s[0], s[1], 0];
}
function cz({
  viewport: r,
  center: e
}) {
  return new Pi(r.viewProjectionMatrix).invert().transform(e);
}
function uz({
  viewport: r,
  shadowMatrices: e
}) {
  const t = [], i = r.pixelUnprojectionMatrix, n = r.isGeospatial ? void 0 : 1, s = [
    [0, 0, n],
    // top left ground
    [r.width, 0, n],
    // top right ground
    [0, r.height, n],
    // bottom left ground
    [r.width, r.height, n],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [r.width, 0, -1],
    // top right near
    [0, r.height, -1],
    // bottom left near
    [r.width, r.height, -1]
    // bottom right near
  ].map((c) => (
    // @ts-expect-error z may be undefined
    lz(c, i)
  ));
  for (const c of e) {
    const o = c.clone().translate(new xt(r.center).negate()), d = s.map((y) => o.transform(y)), m = new Pi().ortho({
      left: Math.min(...d.map((y) => y[0])),
      right: Math.max(...d.map((y) => y[0])),
      bottom: Math.min(...d.map((y) => y[1])),
      top: Math.max(...d.map((y) => y[1])),
      near: Math.min(...d.map((y) => -y[2])),
      far: Math.max(...d.map((y) => -y[2]))
    });
    t.push(m.multiplyRight(c));
  }
  return t;
}
function hz(r) {
  const {
    shadowEnabled: e = !0,
    project: t
  } = r;
  if (!e || !t || !r.shadowMatrices || !r.shadowMatrices.length)
    return {
      drawShadowMap: !1,
      useShadowMap: !1,
      shadow_uShadowMap0: r.dummyShadowMap,
      shadow_uShadowMap1: r.dummyShadowMap
    };
  const i = nx.getUniforms(t), n = nz({
    viewport: t.viewport,
    center: i.center
  }), s = [], c = sz({
    shadowMatrices: r.shadowMatrices,
    viewport: t.viewport
  }).slice();
  for (let d = 0; d < r.shadowMatrices.length; d++) {
    const m = c[d], y = m.clone().translate(new xt(t.viewport.center).negate());
    i.coordinateSystem === Mi.LNGLAT && i.projectionMode === nl.WEB_MERCATOR ? (c[d] = y, s[d] = n) : (c[d] = m.clone().multiplyRight(az), s[d] = y.transform(n));
  }
  const o = {
    drawShadowMap: !!r.drawToShadowMap,
    useShadowMap: r.shadowMaps ? r.shadowMaps.length > 0 : !1,
    color: r.shadowColor || oz,
    lightId: r.shadowLightId || 0,
    lightCount: r.shadowMatrices.length,
    shadow_uShadowMap0: r.dummyShadowMap,
    shadow_uShadowMap1: r.dummyShadowMap
  };
  for (let d = 0; d < c.length; d++)
    o[`viewProjectionMatrix${d}`] = c[d], o[`projectCenter${d}`] = s[d];
  for (let d = 0; d < 2; d++)
    o[`shadow_uShadowMap${d}`] = r.shadowMaps && r.shadowMaps[d] || r.dummyShadowMap;
  return o;
}
const p3 = {
  name: "shadow",
  dependencies: [nx],
  vs: tz,
  fs: iz,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: hz,
  uniformTypes: {
    drawShadowMap: "f32",
    useShadowMap: "f32",
    color: "vec4<f32>",
    lightId: "i32",
    lightCount: "f32",
    viewProjectionMatrix0: "mat4x4<f32>",
    viewProjectionMatrix1: "mat4x4<f32>",
    projectCenter0: "vec4<f32>",
    projectCenter1: "vec4<f32>"
  }
}, cx = {
  ...$T,
  defaultUniforms: {
    ...$T.defaultUniforms,
    useFloatColors: !1
  },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, fz = [KI], dz = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"], pz = [
  // Not yet supported
];
function gz(r) {
  const e = kf.getDefaultShaderAssembler();
  for (const i of fz)
    e.addDefaultModule(i);
  e._hookFunctions.length = 0;
  const t = r === "glsl" ? dz : pz;
  for (const i of t)
    e.addShaderHook(i);
  return e;
}
const mz = [255, 255, 255], _z = 1;
let yz = 0;
class fP {
  constructor(e = {}) {
    this.type = "ambient";
    const {
      color: t = mz
    } = e, {
      intensity: i = _z
    } = e;
    this.id = e.id || `ambient-${yz++}`, this.color = t, this.intensity = i;
  }
}
const bz = [255, 255, 255], vz = 1, xz = [0, 0, -1];
let wz = 0;
class g3 {
  constructor(e = {}) {
    this.type = "directional";
    const {
      color: t = bz
    } = e, {
      intensity: i = vz
    } = e, {
      direction: n = xz
    } = e, {
      _shadow: s = !1
    } = e;
    this.id = e.id || `directional-${wz++}`, this.color = t, this.intensity = i, this.type = "directional", this.direction = new xt(n).normalize().toArray(), this.shadow = s;
  }
  getProjectedLight(e) {
    return this;
  }
}
class Az {
  /** Create a new Pass instance */
  constructor(e, t = {
    id: "pass"
  }) {
    const {
      id: i
    } = t;
    this.id = i, this.device = e, this.props = {
      ...t
    };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class ux extends Az {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(e) {
    const [t, i] = this.device.canvasContext.getDrawingBufferSize(), n = e.clearCanvas ?? !0, s = e.clearColor ?? (n ? [0, 0, 0, 0] : !1), c = n ? 1 : !1, o = n ? 0 : !1, d = e.colorMask ?? 15, m = {
      viewport: [0, 0, t, i]
    };
    e.colorMask && (m.colorMask = d), e.scissorRect && (m.scissorRect = e.scissorRect);
    const y = this.device.beginRenderPass({
      framebuffer: e.target,
      parameters: m,
      clearColor: s,
      clearDepth: c,
      clearStencil: o
    });
    try {
      return this._drawLayers(y, e);
    } finally {
      y.end(), this.device.submit();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(e, t) {
    const {
      target: i,
      shaderModuleProps: n,
      viewports: s,
      views: c,
      onViewportActive: o,
      clearStack: d = !0
    } = t;
    t.pass = t.pass || "unknown", d && (this._lastRenderIndex = -1);
    const m = [];
    for (const y of s) {
      const T = c && c[y.id];
      o?.(y);
      const P = this._getDrawLayerParams(y, t), I = y.subViewports || [y];
      for (const D of I) {
        const k = this._drawLayersInViewport(e, {
          target: i,
          shaderModuleProps: n,
          viewport: D,
          view: T,
          pass: t.pass,
          layers: t.layers
        }, P);
        m.push(k);
      }
    }
    return m;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(e, {
    layers: t,
    pass: i,
    isPicking: n = !1,
    layerFilter: s,
    cullRect: c,
    effects: o,
    shaderModuleProps: d
  }, m = !1) {
    const y = [], T = dP(this._lastRenderIndex + 1), P = {
      layer: t[0],
      viewport: e,
      isPicking: n,
      renderPass: i,
      cullRect: c
    }, I = {};
    for (let D = 0; D < t.length; D++) {
      const k = t[D], $ = this._shouldDrawLayer(k, P, s, I), G = {
        shouldDrawLayer: $
      };
      $ && !m && (G.shouldDrawLayer = !0, G.layerRenderIndex = T(k, $), G.shaderModuleProps = this._getShaderModuleProps(k, o, i, d), G.layerParameters = {
        ...k.context.deck?.props.parameters,
        ...this.getLayerParameters(k, D, e)
      }), y[D] = G;
    }
    return y;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements, complexity */
  _drawLayersInViewport(e, {
    layers: t,
    shaderModuleProps: i,
    pass: n,
    target: s,
    viewport: c,
    view: o
  }, d) {
    const m = Tz(this.device, {
      shaderModuleProps: i,
      target: s,
      viewport: c
    });
    if (o) {
      const {
        clear: T,
        clearColor: P,
        clearDepth: I,
        clearStencil: D
      } = o.props;
      if (T) {
        let k = [0, 0, 0, 0], $ = 1, G = 0;
        Array.isArray(P) ? k = [...P.slice(0, 3), P[3] || 255].map((Z) => Z / 255) : P === !1 && (k = !1), I !== void 0 && ($ = I), D !== void 0 && (G = D), this.device.beginRenderPass({
          framebuffer: s,
          parameters: {
            viewport: m,
            scissorRect: m
          },
          clearColor: k,
          clearDepth: $,
          clearStencil: G
        }).end();
      }
    }
    const y = {
      totalCount: t.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    e.setParameters({
      viewport: m
    });
    for (let T = 0; T < t.length; T++) {
      const P = t[T], I = d[T], {
        shouldDrawLayer: D
      } = I;
      if (D && P.props.pickable && y.pickableCount++, P.isComposite && y.compositeCount++, P.isDrawable && I.shouldDrawLayer) {
        const {
          layerRenderIndex: k,
          shaderModuleProps: $,
          layerParameters: G
        } = I;
        y.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, k), $.project && ($.project.viewport = c), P.context.renderPass = e;
        try {
          P._drawLayer({
            renderPass: e,
            shaderModuleProps: $,
            uniforms: {
              layerIndex: k
            },
            parameters: G
          });
        } catch (te) {
          P.raiseError(te, `drawing ${P} to ${n}`);
        }
      }
    }
    return y;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(e) {
    return !0;
  }
  getShaderModuleProps(e, t, i) {
    return null;
  }
  getLayerParameters(e, t, i) {
    return e.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(e, t, i, n) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    t.layer = e;
    let c = e.parent;
    for (; c; ) {
      if (!c.props.visible || !c.filterSubLayer(t))
        return !1;
      t.layer = c, c = c.parent;
    }
    if (i) {
      const o = t.layer.id;
      if (o in n || (n[o] = i(t)), !n[o])
        return !1;
    }
    return e.activateViewport(t.viewport), !0;
  }
  _getShaderModuleProps(e, t, i, n) {
    const s = this.device.canvasContext.cssToDeviceRatio(), c = e.internalState?.propsInTransition || e.props, o = {
      layer: c,
      picking: {
        isActive: !1
      },
      project: {
        viewport: e.context.viewport,
        devicePixelRatio: s,
        modelMatrix: c.modelMatrix,
        coordinateSystem: c.coordinateSystem,
        coordinateOrigin: c.coordinateOrigin,
        autoWrapLongitude: e.wrapLongitude
      }
    };
    if (t)
      for (const d of t)
        m3(o, d.getShaderModuleProps?.(e, o));
    return m3(o, this.getShaderModuleProps(e, t, o), n);
  }
}
function dP(r = 0, e = {}) {
  const t = {}, i = (n, s) => {
    const c = n.props._offset, o = n.id, d = n.parent && n.parent.id;
    let m;
    if (d && !(d in e) && i(n.parent, !1), d in t) {
      const y = t[d] = t[d] || dP(e[d], e);
      m = y(n, s), t[o] = y;
    } else Number.isFinite(c) ? (m = c + (e[d] || 0), t[o] = null) : m = r;
    return s && m >= r && (r = m + 1), e[o] = m, m;
  };
  return i;
}
function Tz(r, {
  shaderModuleProps: e,
  target: t,
  viewport: i
}) {
  const n = e?.project?.devicePixelRatio ?? // @ts-expect-error TODO - assuming WebGL context
  r.canvasContext.cssToDeviceRatio(), [, s] = r.canvasContext.getDrawingBufferSize(), c = t ? t.height : s, o = i;
  return [o.x * n, c - (o.y + o.height) * n, o.width * n, o.height * n];
}
function m3(r, ...e) {
  for (const t of e)
    if (t)
      for (const i in t)
        r[i] ? Object.assign(r[i], t[i]) : r[i] = t[i];
  return r;
}
class Sz extends ux {
  constructor(e, t) {
    super(e, t);
    const i = e.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
      // TODO - texture API change in luma.gl v9.2
      // mipmaps: true
    }), n = e.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1
    });
    this.fbo = e.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [i],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: n
    });
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null);
  }
  getShadowMap() {
    return this.fbo.colorAttachments[0].texture;
  }
  render(e) {
    const t = this.fbo, i = this.device.canvasContext.cssToDeviceRatio(), n = e.viewports[0], s = n.width * i, c = n.height * i, o = [1, 1, 1, 1];
    (s !== t.width || c !== t.height) && t.resize({
      width: s,
      height: c
    }), super.render({
      ...e,
      clearColor: o,
      target: t,
      pass: "shadow"
    });
  }
  getLayerParameters(e, t, i) {
    return {
      ...e.props.parameters,
      blend: !1,
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    };
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getShaderModuleProps(e, t, i) {
    return {
      shadow: {
        project: i.project,
        drawToShadowMap: !0
      }
    };
  }
}
const Ez = {
  color: [255, 255, 255],
  intensity: 1
}, _3 = [{
  color: [255, 255, 255],
  intensity: 1,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}], Cz = [0, 0, 0, 200 / 255];
class hx {
  constructor(e = {}) {
    this.id = "lighting-effect", this.shadowColor = Cz, this.shadow = !1, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.dummyShadowMap = null, this.setProps(e);
  }
  setup(e) {
    this.context = e;
    const {
      device: t,
      deck: i
    } = e;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(t), i._addDefaultShaderModule(p3), this.dummyShadowMap = t.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(e) {
    this.ambientLight = void 0, this.directionalLights = [], this.pointLights = [];
    for (const t in e) {
      const i = e[t];
      switch (i.type) {
        case "ambient":
          this.ambientLight = i;
          break;
        case "directional":
          this.directionalLights.push(i);
          break;
        case "point":
          this.pointLights.push(i);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.context && this.setup(this.context), this.props = e;
  }
  preRender({
    layers: e,
    layerFilter: t,
    viewports: i,
    onViewportActive: n,
    views: s
  }) {
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let c = 0; c < this.shadowPasses.length; c++)
        this.shadowPasses[c].render({
          layers: e,
          layerFilter: t,
          viewports: i,
          onViewportActive: n,
          views: s,
          shaderModuleProps: {
            shadow: {
              shadowLightId: c,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          }
        });
    }
  }
  getShaderModuleProps(e, t) {
    const i = this.shadow ? {
      project: t.project,
      shadowMaps: this.shadowPasses.map((c) => c.getShadowMap()),
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {}, n = {
      enabled: !0,
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((c) => c.getProjectedLight({
        layer: e
      })),
      pointLights: this.pointLights.map((c) => c.getProjectedLight({
        layer: e
      }))
    }, s = e.props.material;
    return {
      shadow: i,
      lighting: n,
      phongMaterial: s,
      gouraudMaterial: s
    };
  }
  cleanup(e) {
    for (const t of this.shadowPasses)
      t.delete();
    this.shadowPasses.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(p3));
  }
  _calculateMatrices() {
    const e = [];
    for (const t of this.directionalLights) {
      const i = new Pi().lookAt({
        eye: new xt(t.direction).negate()
      });
      e.push(i);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let t = 0; t < this.directionalLights.length; t++) {
      const i = new Sz(e);
      this.shadowPasses[t] = i;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: i
    } = this;
    !e && t.length === 0 && i.length === 0 && (this.ambientLight = new fP(Ez), this.directionalLights.push(new g3(_3[0]), new g3(_3[1])));
  }
}
class Iz {
  constructor(e = {}) {
    this._pool = [], this.opts = {
      overAlloc: 2,
      poolSize: 100
    }, this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, t, {
    size: i = 1,
    type: n,
    padding: s = 0,
    copy: c = !1,
    initialize: o = !1,
    maxCount: d
  }) {
    const m = n || e && e.constructor || Float32Array, y = t * i + s;
    if (ArrayBuffer.isView(e)) {
      if (y <= e.length)
        return e;
      if (y * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new m(e.buffer, 0, y);
    }
    let T = 1 / 0;
    d && (T = d * i + s);
    const P = this._allocate(m, y, o, T);
    return e && c ? P.set(e) : o || P.fill(0, 0, 4), this._release(e), P;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, t, i, n) {
    let s = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
    s > n && (s = n);
    const c = this._pool, o = e.BYTES_PER_ELEMENT * s, d = c.findIndex((m) => m.byteLength >= o);
    if (d >= 0) {
      const m = new e(c.splice(d, 1)[0], 0, s);
      return i && m.fill(0), m;
    }
    return new e(s);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const t = this._pool, {
      buffer: i
    } = e, {
      byteLength: n
    } = i, s = t.findIndex((c) => c.byteLength >= n);
    s < 0 ? t.push(i) : (s > 0 || t.length < this.opts.poolSize) && t.splice(s, 0, i), t.length > this.opts.poolSize && t.shift();
  }
}
const Qg = new Iz();
function Tg() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Pz(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function Mz(r) {
  return [r[12], r[13], r[14]];
}
function Rz(r) {
  return {
    left: jd(r[3] + r[0], r[7] + r[4], r[11] + r[8], r[15] + r[12]),
    right: jd(r[3] - r[0], r[7] - r[4], r[11] - r[8], r[15] - r[12]),
    bottom: jd(r[3] + r[1], r[7] + r[5], r[11] + r[9], r[15] + r[13]),
    top: jd(r[3] - r[1], r[7] - r[5], r[11] - r[9], r[15] - r[13]),
    near: jd(r[3] + r[2], r[7] + r[6], r[11] + r[10], r[15] + r[14]),
    far: jd(r[3] - r[2], r[7] - r[6], r[11] - r[10], r[15] - r[14])
  };
}
const y3 = new xt();
function jd(r, e, t, i) {
  y3.set(r, e, t);
  const n = y3.len();
  return {
    distance: i / n,
    normal: new xt(-r / n, -e / n, -t / n)
  };
}
function Lz(r) {
  return r - Math.fround(r);
}
let hg;
function Mb(r, e) {
  const {
    size: t = 1,
    startIndex: i = 0
  } = e, n = e.endIndex !== void 0 ? e.endIndex : r.length, s = (n - i) / t;
  hg = Qg.allocate(hg, s, {
    type: Float32Array,
    size: t * 2
  });
  let c = i, o = 0;
  for (; c < n; ) {
    for (let d = 0; d < t; d++) {
      const m = r[c++];
      hg[o + d] = m, hg[o + d + t] = Lz(m);
    }
    o += t * 2;
  }
  return hg.subarray(0, s * t * 2);
}
function Bz(r) {
  let e = null, t = !1;
  for (const i of r)
    i && (e ? (t || (e = [[e[0][0], e[0][1]], [e[1][0], e[1][1]]], t = !0), e[0][0] = Math.min(e[0][0], i[0][0]), e[0][1] = Math.min(e[0][1], i[0][1]), e[1][0] = Math.max(e[1][0], i[1][0]), e[1][1] = Math.max(e[1][1], i[1][1])) : e = i);
  return e;
}
const kz = Math.PI / 180, Oz = Tg(), b3 = [0, 0, 0], Dz = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function Nz({
  width: r,
  height: e,
  orthographic: t,
  fovyRadians: i,
  focalDistance: n,
  padding: s,
  near: c,
  far: o
}) {
  const d = r / e, m = t ? new Pi().orthographic({
    fovy: i,
    aspect: d,
    focalDistance: n,
    near: c,
    far: o
  }) : new Pi().perspective({
    fovy: i,
    aspect: d,
    near: c,
    far: o
  });
  if (s) {
    const {
      left: y = 0,
      right: T = 0,
      top: P = 0,
      bottom: I = 0
    } = s, D = vc((y + r - T) / 2, 0, r) - r / 2, k = vc((P + e - I) / 2, 0, e) - e / 2;
    m[8] -= D * 2 / r, m[9] += k * 2 / e;
  }
  return m;
}
class Dp {
  // eslint-disable-next-line complexity
  constructor(e = {}) {
    this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || Dz, this.focalDistance = e.focalDistance || 1, this.position = e.position || b3, this.modelMatrix = e.modelMatrix || null;
    const {
      longitude: t,
      latitude: i
    } = e;
    this.isGeospatial = Number.isFinite(i) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? nl.WEB_MERCATOR : nl.WEB_MERCATOR_AUTO_OFFSET : nl.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(e) {
    return e instanceof Dp ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && Ac(e.projectionMatrix, this.projectionMatrix) && Ac(e.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(e, {
    topLeft: t = !0
  } = {}) {
    const i = this.projectPosition(e), n = uP(i, this.pixelProjectionMatrix), [s, c] = n, o = t ? c : this.height - c;
    return e.length === 2 ? [s, o] : [s, o, n[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, {
    topLeft: t = !0,
    targetZ: i
  } = {}) {
    const [n, s, c] = e, o = t ? s : this.height - s, d = i && i * this.distanceScales.unitsPerMeter[2], m = lx([n, o, c], this.pixelUnprojectionMatrix, d), [y, T, P] = this.unprojectPosition(m);
    return Number.isFinite(c) ? [y, T, P] : Number.isFinite(i) ? [y, T, i] : [y, T];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(e) {
    const [t, i] = this.projectFlat(e), n = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [t, i, n];
  }
  unprojectPosition(e) {
    const [t, i] = this.unprojectFlat(e), n = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [t, i, n];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(e) {
    if (this.isGeospatial) {
      const t = Jg(e);
      return t[1] = vc(t[1], -318, 830), t;
    }
    return e;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(e) {
    return this.isGeospatial ? Ap(e) : e;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(e = {}) {
    const t = {
      targetZ: e.z || 0
    }, i = this.unproject([0, 0], t), n = this.unproject([this.width, 0], t), s = this.unproject([0, this.height], t), c = this.unproject([this.width, this.height], t);
    return [Math.min(i[0], n[0], s[0], c[0]), Math.min(i[1], n[1], s[1], c[1]), Math.max(i[0], n[0], s[0], c[0]), Math.max(i[1], n[1], s[1], c[1])];
  }
  getDistanceScales(e) {
    return e && this.isGeospatial ? Tv({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel({
    x: e,
    y: t,
    width: i = 1,
    height: n = 1
  }) {
    return e < this.x + this.width && this.x < e + i && t < this.y + this.height && this.y < t + n;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, Rz(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(e, t) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(e) {
    const t = e.longitude, i = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = WU({
      latitude: i
    }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || Tv({
      latitude: i,
      longitude: t
    }));
    const n = Math.pow(2, this.zoom);
    this.scale = n;
    const {
      position: s,
      modelMatrix: c
    } = e;
    let o = b3;
    if (s && (o = c ? new Pi(c).transformAsVector(s, []) : s), this.isGeospatial) {
      const d = this.projectPosition([t, i, 0]);
      this.center = new xt(o).scale(this.distanceScales.unitsPerMeter).add(d);
    } else
      this.center = this.projectPosition(o);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(e) {
    const {
      // View matrix
      viewMatrix: t = Oz,
      // Projection matrix
      projectionMatrix: i = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: n = !1,
      fovyRadians: s,
      fovy: c = 75,
      near: o = 0.1,
      // Distance of near clipping plane
      far: d = 1e3,
      // Distance of far clipping plane
      padding: m = null,
      // Center offset in pixels
      focalDistance: y = 1
    } = e;
    this.viewMatrixUncentered = t, this.viewMatrix = new Pi().multiplyRight(t).translate(new xt(this.center).negate()), this.projectionMatrix = i || Nz({
      width: this.width,
      height: this.height,
      orthographic: n,
      fovyRadians: s || c * kz,
      focalDistance: y,
      padding: m,
      near: o,
      far: d
    });
    const T = Tg();
    $f(T, T, this.projectionMatrix), $f(T, T, this.viewMatrix), this.viewProjectionMatrix = T, this.viewMatrixInverse = gv([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = Mz(this.viewMatrixInverse);
    const P = Tg(), I = Tg();
    tx(P, P, [this.width / 2, -this.height / 2, 1]), Py(P, P, [1, -1, 0]), $f(I, P, this.viewProjectionMatrix), this.pixelProjectionMatrix = I, this.pixelUnprojectionMatrix = gv(Tg(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Ni.warn("Pixel project matrix not invertible")();
  }
}
Dp.displayName = "Viewport";
class ed extends Dp {
  /* eslint-disable complexity, max-statements */
  constructor(e = {}) {
    const {
      latitude: t = 0,
      longitude: i = 0,
      zoom: n = 0,
      pitch: s = 0,
      bearing: c = 0,
      nearZMultiplier: o = 0.1,
      farZMultiplier: d = 1.01,
      nearZ: m,
      farZ: y,
      orthographic: T = !1,
      projectionMatrix: P,
      repeat: I = !1,
      worldOffset: D = 0,
      position: k,
      padding: $,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: G = !1
    } = e;
    let {
      width: te,
      height: Z,
      altitude: H = 1.5
    } = e;
    const J = Math.pow(2, n);
    te = te || 1, Z = Z || 1;
    let re, be = null;
    if (P)
      H = P[5] / 2, re = Kg(H);
    else {
      e.fovy ? (re = e.fovy, H = ax(re)) : re = Kg(H);
      let oe;
      if ($) {
        const {
          top: Ee = 0,
          bottom: le = 0
        } = $;
        oe = [0, vc((Ee + Z - le) / 2, 0, Z) - Z / 2];
      }
      be = ZU({
        width: te,
        height: Z,
        scale: J,
        center: k && [0, 0, k[2] * W_(t)],
        offset: oe,
        pitch: s,
        fovy: re,
        nearZMultiplier: o,
        farZMultiplier: d
      }), Number.isFinite(m) && (be.near = m), Number.isFinite(y) && (be.far = y);
    }
    let pe = XU({
      height: Z,
      pitch: s,
      bearing: c,
      scale: J,
      altitude: H
    });
    D && (pe = new Pi().translate([512 * D, 0, 0]).multiplyLeft(pe)), super({
      ...e,
      // x, y,
      width: te,
      height: Z,
      // view matrix
      viewMatrix: pe,
      longitude: i,
      latitude: t,
      zoom: n,
      // projection matrix parameters
      ...be,
      fovy: re,
      focalDistance: H
    }), this.latitude = t, this.longitude = i, this.zoom = n, this.pitch = s, this.bearing = c, this.altitude = H, this.fovy = re, this.orthographic = T, this._subViewports = I ? [] : null, this._pseudoMeters = G, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), i = Math.ceil((e[2] - 180) / 360);
      for (let n = t; n <= i; n++) {
        const s = n ? new ed({
          ...this,
          worldOffset: n
        }) : this;
        this._subViewports.push(s);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [t, i] = this.projectFlat(e), n = (e[2] || 0) * W_(e[1]);
    return [t, i, n];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [t, i] = this.unprojectFlat(e), n = (e[2] || 0) / W_(i);
    return [t, i, n];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(e, t) {
    return cP(e, t);
  }
  panByPosition(e, t) {
    const i = lx(t, this.pixelUnprojectionMatrix), n = this.projectFlat(e), s = NT([], n, jN([], i)), c = NT([], this.center, s), [o, d] = this.unprojectFlat(c);
    return {
      longitude: o,
      latitude: d
    };
  }
  getBounds(e = {}) {
    const t = KU(this, e.z || 0);
    return [Math.min(t[0][0], t[1][0], t[2][0], t[3][0]), Math.min(t[0][1], t[1][1], t[2][1], t[3][1]), Math.max(t[0][0], t[1][0], t[2][0], t[3][0]), Math.max(t[0][1], t[1][1], t[2][1], t[3][1])];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(e, t = {}) {
    const {
      width: i,
      height: n
    } = this, {
      longitude: s,
      latitude: c,
      zoom: o
    } = YU({
      width: i,
      height: n,
      bounds: e,
      ...t
    });
    return new ed({
      width: i,
      height: n,
      longitude: s,
      latitude: c,
      zoom: o
    });
  }
}
ed.displayName = "WebMercatorViewport";
const v3 = [0, 0, 0];
function Rb(r, e, t = !1) {
  const i = e.projectPosition(r);
  if (t && e instanceof ed) {
    const [n, s, c = 0] = r, o = e.getDistanceScales([n, s]);
    i[2] = c * o.unitsPerMeter[2];
  }
  return i;
}
function Fz(r) {
  const {
    viewport: e,
    modelMatrix: t,
    coordinateOrigin: i
  } = r;
  let {
    coordinateSystem: n,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: c
  } = r;
  return n === Mi.DEFAULT && (n = e.isGeospatial ? Mi.LNGLAT : Mi.CARTESIAN), s === void 0 && (s = n), c === void 0 && (c = i), {
    viewport: e,
    coordinateSystem: n,
    coordinateOrigin: i,
    modelMatrix: t,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: c
  };
}
function pP(r, {
  viewport: e,
  modelMatrix: t,
  coordinateSystem: i,
  coordinateOrigin: n,
  offsetMode: s
}) {
  let [c, o, d = 0] = r;
  switch (t && ([c, o, d] = Op([], [c, o, d, 1], t)), i) {
    case Mi.LNGLAT:
      return Rb([c, o, d], e, s);
    case Mi.LNGLAT_OFFSETS:
      return Rb([c + n[0], o + n[1], d + (n[2] || 0)], e, s);
    case Mi.METER_OFFSETS:
      return Rb(cP(n, [c, o, d]), e, s);
    case Mi.CARTESIAN:
    default:
      return e.isGeospatial ? [c + n[0], o + n[1], d + n[2]] : e.projectPosition([c, o, d]);
  }
}
function Uz(r, e) {
  const {
    viewport: t,
    coordinateSystem: i,
    coordinateOrigin: n,
    modelMatrix: s,
    fromCoordinateSystem: c,
    fromCoordinateOrigin: o
  } = Fz(e), {
    autoOffset: d = !0
  } = e, {
    geospatialOrigin: m = v3,
    shaderCoordinateOrigin: y = v3,
    offsetMode: T = !1
  } = d ? aP(t, i, n) : {}, P = pP(r, {
    viewport: t,
    modelMatrix: s,
    coordinateSystem: c,
    coordinateOrigin: o,
    offsetMode: T
  });
  if (T) {
    const I = t.projectPosition(m || y);
    DI(P, P, I);
  }
  return P;
}
let zz = 1, jz = 1;
class gP {
  time = 0;
  channels = /* @__PURE__ */ new Map();
  animations = /* @__PURE__ */ new Map();
  playing = !1;
  lastEngineTime = -1;
  constructor() {
  }
  addChannel(e) {
    const {
      delay: t = 0,
      duration: i = Number.POSITIVE_INFINITY,
      rate: n = 1,
      repeat: s = 1
    } = e, c = zz++, o = {
      time: 0,
      delay: t,
      duration: i,
      rate: n,
      repeat: s
    };
    return this._setChannelTime(o, this.time), this.channels.set(c, o), c;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [t, i] of this.animations)
      i.channel === e && this.detachAnimation(t);
  }
  isFinished(e) {
    const t = this.channels.get(e);
    return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const t = this.channels.get(e);
    return t === void 0 ? -1 : t.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const t = this.channels.values();
    for (const n of t)
      this._setChannelTime(n, this.time);
    const i = this.animations.values();
    for (const n of i) {
      const {
        animation: s,
        channel: c
      } = n;
      s.setTime(this.getTime(c));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, t) {
    const i = jz++;
    return this.animations.set(i, {
      animation: e,
      channel: t
    }), e.setTime(this.getTime(t)), i;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, t) {
    const i = t - e.delay, n = e.duration * e.repeat;
    i >= n ? e.time = e.duration * e.rate : (e.time = Math.max(0, i) % e.duration, e.time *= e.rate);
  }
}
function Vz(r) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(r) : setTimeout(r, 1e3 / 60);
}
function Gz(r) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(r) : clearTimeout(r);
}
let $z = 0;
class fx {
  static defaultAnimationLoopProps = {
    device: null,
    onAddHTML: () => "",
    onInitialize: async () => null,
    onRender: () => {
    },
    onFinalize: () => {
    },
    onError: (e) => console.error(e),
    // eslint-disable-line no-console
    stats: uv.stats.get(`animation-loop-${$z++}`),
    // view parameters
    autoResizeViewport: !1
  };
  device = null;
  canvas = null;
  props;
  animationProps = null;
  timeline = null;
  stats;
  cpuTime;
  gpuTime;
  frameRate;
  display;
  needsRedraw = "initialized";
  _initialized = !1;
  _running = !1;
  _animationFrameId = null;
  _nextFramePromise = null;
  _resolveNextFrame = null;
  _cpuStartTime = 0;
  _error = null;
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(e) {
    if (this.props = {
      ...fx.defaultAnimationLoopProps,
      ...e
    }, e = this.props, !e.device)
      throw new Error("No device provided");
    this.stats = e.stats || new kp({
      id: "animation-loop-stats"
    }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
      autoResizeViewport: e.autoResizeViewport
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  reportError(e) {
    this.props.onError(e), this._error = e;
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(e) {
    return this.needsRedraw = this.needsRedraw || e, this;
  }
  setProps(e) {
    return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let e;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (e) {
      const t = e instanceof Error ? e : new Error("Unknown error");
      throw this.props.onError(t), t;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && !this._error && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    return this.device?.isLost || this._error ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeViewport();
  }
  _setDisplay(e) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = Vz(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (Gz(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(e) {
    if (this.display) {
      this.display._renderFrame(e);
      return;
    }
    this.props.onRender(this._getAnimationProps()), this.device?.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    const e = this.device?.getDefaultCanvasContext();
    if (!this.device || !e)
      throw new Error("loop");
    const t = e?.canvas, i = e.props.useDevicePixels;
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvasContext: e,
      canvas: t,
      // @ts-expect-error Deprecated
      useDevicePixels: i,
      timeline: this.timeline,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const {
      width: e,
      height: t,
      aspect: i
    } = this._getSizeAndAspect();
    (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), i !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = i, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = this.device.getDefaultCanvasContext().canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(t);
      const i = this.props.onAddHTML(t);
      i && (t.innerHTML = i);
    }
  }
  _getSizeAndAspect() {
    if (!this.device)
      return {
        width: 1,
        height: 1,
        aspect: 1
      };
    const [e, t] = this.device?.getDefaultCanvasContext().getDevicePixelSize() || [1, 1];
    let i = 1;
    const n = this.device?.getDefaultCanvasContext().canvas;
    return n && n.clientHeight ? i = n.clientWidth / n.clientHeight : e > 0 && t > 0 && (i = e / t), {
      width: e,
      height: t,
      aspect: i
    };
  }
  /** @deprecated Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(e) {
    e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY]);
  }
  _onMouseleave(e) {
    this._getAnimationProps()._mousePosition = null;
  }
}
const Lb = {};
function Np(r = "id") {
  Lb[r] = Lb[r] || 1;
  const e = Lb[r]++;
  return `${r}-${e}`;
}
class x3 {
  id;
  userData = {};
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  bufferLayout = [];
  vertexCount;
  indices;
  attributes;
  constructor(e) {
    if (this.id = e.id || Np("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && !(this.indices.usage & us.INDEX))
      throw new Error("Index buffer must have INDEX usage");
  }
  destroy() {
    this.indices?.destroy();
    for (const e of Object.values(this.attributes))
      e.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices || null;
  }
  _calculateVertexCount(e) {
    return e.byteLength / 12;
  }
}
function Hz(r, e) {
  if (e instanceof x3)
    return e;
  const t = qz(r, e), {
    attributes: i,
    bufferLayout: n
  } = Wz(r, e);
  return new x3({
    topology: e.topology || "triangle-list",
    bufferLayout: n,
    vertexCount: e.vertexCount,
    indices: t,
    attributes: i
  });
}
function qz(r, e) {
  if (!e.indices)
    return;
  const t = e.indices.value;
  return r.createBuffer({
    usage: us.INDEX,
    data: t
  });
}
function Wz(r, e) {
  const t = [], i = {};
  for (const [s, c] of Object.entries(e.attributes)) {
    let o = s;
    switch (s) {
      case "POSITION":
        o = "positions";
        break;
      case "NORMAL":
        o = "normals";
        break;
      case "TEXCOORD_0":
        o = "texCoords";
        break;
      case "COLOR_0":
        o = "colors";
        break;
    }
    if (c) {
      i[o] = r.createBuffer({
        data: c.value,
        id: `${s}-buffer`
      });
      const {
        value: d,
        size: m,
        normalized: y
      } = c;
      t.push({
        name: o,
        format: tD(d, m, y)
      });
    }
  }
  const n = e._calculateVertexCount(e.attributes, e.indices);
  return {
    attributes: i,
    bufferLayout: t,
    vertexCount: n
  };
}
class dx {
  static defaultProps = {
    ...Gf.defaultProps
  };
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(e) {
    return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new dx(e), e._lumaData.defaultPipelineFactory;
  }
  device;
  cachingEnabled;
  destroyPolicy;
  debug;
  _hashCounter = 0;
  _hashes = {};
  _renderPipelineCache = {};
  _computePipelineCache = {};
  get [Symbol.toStringTag]() {
    return "PipelineFactory";
  }
  toString() {
    return `PipelineFactory(${this.device.id})`;
  }
  constructor(e) {
    this.device = e, this.cachingEnabled = e.props._cachePipelines, this.destroyPolicy = e.props._cacheDestroyPolicy, this.debug = e.props.debugFactories;
  }
  /** Return a RenderPipeline matching supplied props. Reuses an equivalent pipeline if already created. */
  createRenderPipeline(e) {
    if (!this.cachingEnabled)
      return this.device.createRenderPipeline(e);
    const t = {
      ...Gf.defaultProps,
      ...e
    }, i = this._renderPipelineCache, n = this._hashRenderPipeline(t);
    let s = i[n]?.pipeline;
    return s ? (i[n].useCount++, this.debug && Ht.warn(`${this}: ${i[n].pipeline} reused, count=${i[n].useCount}, (id=${e.id})`)()) : (s = this.device.createRenderPipeline({
      ...t,
      id: t.id ? `${t.id}-cached` : Np("unnamed-cached")
    }), s.hash = n, i[n] = {
      pipeline: s,
      useCount: 1
    }, this.debug && Ht.warn(`${this}: ${s} created, count=${i[n].useCount}`)()), s;
  }
  /** Return a ComputePipeline matching supplied props. Reuses an equivalent pipeline if already created. */
  createComputePipeline(e) {
    if (!this.cachingEnabled)
      return this.device.createComputePipeline(e);
    const t = {
      ...xy.defaultProps,
      ...e
    }, i = this._computePipelineCache, n = this._hashComputePipeline(t);
    let s = i[n]?.pipeline;
    return s ? (i[n].useCount++, this.debug && Ht.warn(`${this}: ${i[n].pipeline} reused, count=${i[n].useCount}, (id=${e.id})`)()) : (s = this.device.createComputePipeline({
      ...t,
      id: t.id ? `${t.id}-cached` : void 0
    }), s.hash = n, i[n] = {
      pipeline: s,
      useCount: 1
    }, this.debug && Ht.warn(`${this}: ${s} created, count=${i[n].useCount}`)()), s;
  }
  release(e) {
    if (!this.cachingEnabled) {
      e.destroy();
      return;
    }
    const t = this._getCache(e), i = e.hash;
    t[i].useCount--, t[i].useCount === 0 ? (this._destroyPipeline(e), this.debug && Ht.warn(`${this}: ${e} released and destroyed`)()) : t[i].useCount < 0 ? (Ht.error(`${this}: ${e} released, useCount < 0, resetting`)(), t[i].useCount = 0) : this.debug && Ht.warn(`${this}: ${e} released, count=${t[i].useCount}`)();
  }
  // PRIVATE
  /** Destroy a cached pipeline, removing it from the cache (depending on destroy policy) */
  _destroyPipeline(e) {
    const t = this._getCache(e);
    switch (this.destroyPolicy) {
      case "never":
        return !1;
      case "unused":
        return delete t[e.hash], e.destroy(), !0;
    }
  }
  /** Get the appropriate cache for the type of pipeline */
  _getCache(e) {
    let t;
    if (e instanceof xy && (t = this._computePipelineCache), e instanceof Gf && (t = this._renderPipelineCache), !t)
      throw new Error(`${this}`);
    if (!t[e.hash])
      throw new Error(`${this}: ${e} matched incorrect entry`);
    return t;
  }
  /** Calculate a hash based on all the inputs for a compute pipeline */
  _hashComputePipeline(e) {
    const {
      type: t
    } = this.device, i = this._getHash(e.shader.source);
    return `${t}/C/${i}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(e) {
    const t = e.vs ? this._getHash(e.vs.source) : 0, i = e.fs ? this._getHash(e.fs.source) : 0, n = "-", s = this._getHash(JSON.stringify(e.bufferLayout)), {
      type: c
    } = this.device;
    switch (c) {
      case "webgl":
        return `${c}/R/${t}/${i}V${n}BL${s}`;
      case "webgpu":
      default:
        const o = this._getHash(JSON.stringify(e.parameters));
        return `${c}/R/${t}/${i}V${n}T${e.topology}P${o}BL${s}`;
    }
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
}
class px {
  static defaultProps = {
    ...Ky.defaultProps
  };
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(e) {
    return e._lumaData.defaultShaderFactory ||= new px(e), e._lumaData.defaultShaderFactory;
  }
  device;
  cachingEnabled;
  destroyPolicy;
  debug;
  _cache = {};
  get [Symbol.toStringTag]() {
    return "ShaderFactory";
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.device.id})`;
  }
  /** @internal */
  constructor(e) {
    this.device = e, this.cachingEnabled = e.props._cacheShaders, this.destroyPolicy = e.props._cacheDestroyPolicy, this.debug = !0;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(e) {
    if (!this.cachingEnabled)
      return this.device.createShader(e);
    const t = this._hashShader(e);
    let i = this._cache[t];
    if (i)
      i.useCount++, this.debug && Ht.warn(`${this}: Reusing shader ${i.shader.id} count=${i.useCount}`)();
    else {
      const n = this.device.createShader({
        ...e,
        id: e.id ? `${e.id}-cached` : void 0
      });
      this._cache[t] = i = {
        shader: n,
        useCount: 1
      }, this.debug && Ht.warn(`${this}: Created new shader ${n.id}`)();
    }
    return i.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(e) {
    if (!this.cachingEnabled) {
      e.destroy();
      return;
    }
    const t = this._hashShader(e), i = this._cache[t];
    if (i)
      if (i.useCount--, i.useCount === 0)
        this.destroyPolicy === "unused" && (delete this._cache[t], i.shader.destroy(), this.debug && Ht.warn(`${this}: Releasing shader ${e.id}, destroyed`)());
      else {
        if (i.useCount < 0)
          throw new Error(`ShaderFactory: Shader ${e.id} released too many times`);
        this.debug && Ht.warn(`${this}: Releasing shader ${e.id} count=${i.useCount}`)();
      }
  }
  // PRIVATE
  _hashShader(e) {
    return `${e.stage}:${e.source}`;
  }
}
function Xz(r, e) {
  const t = {}, i = "Values";
  if (r.attributes.length === 0 && !r.varyings?.length)
    return {
      "No attributes or varyings": {
        [i]: "N/A"
      }
    };
  for (const n of r.attributes)
    if (n) {
      const s = `${n.location} ${n.name}: ${n.type}`;
      t[`in ${s}`] = {
        [i]: n.stepMode || "vertex"
      };
    }
  for (const n of r.varyings || []) {
    const s = `${n.location} ${n.name}`;
    t[`out ${s}`] = {
      [i]: JSON.stringify(n)
    };
  }
  return t;
}
let co = null, Bb = null;
function Zz(r, {
  id: e,
  minimap: t,
  opaque: i,
  top: n = "0",
  left: s = "0",
  rgbaScale: c = 1
}) {
  co || (co = document.createElement("canvas"), co.id = e, co.title = e, co.style.zIndex = "100", co.style.position = "absolute", co.style.top = n, co.style.left = s, co.style.border = "blue 5px solid", co.style.transform = "scaleY(-1)", document.body.appendChild(co), Bb = co.getContext("2d")), (co.width !== r.width || co.height !== r.height) && (co.width = r.width / 2, co.height = r.height / 2, co.style.width = "400px", co.style.height = "400px");
  const o = r.device.readPixelsToArrayWebGL(r), d = Bb?.createImageData(r.width, r.height);
  if (d) {
    for (let y = 0; y < o.length; y += 4)
      d.data[0 + y + 0] = o[y + 0] * c, d.data[0 + y + 1] = o[y + 1] * c, d.data[0 + y + 2] = o[y + 2] * c, d.data[0 + y + 3] = i ? 255 : o[y + 3] * c;
    Bb?.putImageData(d, 0, 0);
  }
}
function Sv(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let i = 0; i < r.length; i++)
      if (!Sv(r[i], e[i], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const i = Object.keys(r), n = Object.keys(e);
    if (i.length !== n.length)
      return !1;
    for (const s of i)
      if (!e.hasOwnProperty(s) || !Sv(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class kb {
  bufferLayouts;
  constructor(e) {
    this.bufferLayouts = e;
  }
  getBufferLayout(e) {
    return this.bufferLayouts.find((t) => t.name === e) || null;
  }
  /** Get attribute names from a BufferLayout */
  getAttributeNamesForBuffer(e) {
    return e.attributes ? e.attributes?.map((t) => t.attribute) : [e.name];
  }
  mergeBufferLayouts(e, t) {
    const i = [...e];
    for (const n of t) {
      const s = i.findIndex((c) => c.name === n.name);
      s < 0 ? i.push(n) : i[s] = n;
    }
    return i;
  }
  getBufferIndex(e) {
    const t = this.bufferLayouts.findIndex((i) => i.name === e);
    return t === -1 && Ht.warn(`BufferLayout: Missing buffer for "${e}".`)(), t;
  }
}
function Yz(r, e) {
  const t = Object.fromEntries(r.attributes.map((n) => [n.name, n.location])), i = e.slice();
  return i.sort((n, s) => {
    const c = n.attributes ? n.attributes.map((y) => y.attribute) : [n.name], o = s.attributes ? s.attributes.map((y) => y.attribute) : [s.name], d = Math.min(...c.map((y) => t[y])), m = Math.min(...o.map((y) => t[y]));
    return d - m;
  }), i;
}
function Jz(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function Kz(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : !1;
}
function Qz(r) {
  return Jz(r) || Kz(r);
}
function e7(r) {
  return Qz(r) || typeof r == "number" || typeof r == "boolean";
}
function t7(r) {
  const e = {
    bindings: {},
    uniforms: {}
  };
  return Object.keys(r).forEach((t) => {
    const i = r[t];
    e7(i) ? e.uniforms[t] = i : e.bindings[t] = i;
  }), e;
}
class r7 {
  options = {
    disableWarnings: !1
  };
  /**
   * The map of modules
   * @todo should should this include the resolved dependencies?
   */
  // @ts-ignore Fix typings
  modules;
  /** Stores the uniform values for each module */
  moduleUniforms;
  /** Stores the uniform bindings for each module  */
  moduleBindings;
  /** Tracks if uniforms have changed */
  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(e, t) {
    Object.assign(this.options, t);
    const i = P2(Object.values(e).filter((n) => n.dependencies));
    for (const n of i)
      e[n.name] = n;
    Ht.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [n, s] of Object.entries(e))
      this._addModule(s), s.name && n !== s.name && !this.options.disableWarnings && Ht.warn(`Module name: ${n} vs ${s.name}`)();
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(e) {
    for (const t of Object.keys(e)) {
      const i = t, n = e[i] || {}, s = this.modules[i];
      if (!s) {
        this.options.disableWarnings || Ht.warn(`Module ${t} not found`)();
        continue;
      }
      const c = this.moduleUniforms[i], o = this.moduleBindings[i], d = s.getUniforms?.(n, c) || n, {
        uniforms: m,
        bindings: y
      } = t7(d);
      this.moduleUniforms[i] = {
        ...c,
        ...m
      }, this.moduleBindings[i] = {
        ...o,
        ...y
      };
    }
  }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindingValues() {
    const e = {};
    for (const t of Object.values(this.moduleBindings))
      Object.assign(e, t);
    return e;
  }
  // INTERNAL
  /** Return a debug table that can be used for console.table() or log.table() */
  getDebugTable() {
    const e = {};
    for (const [t, i] of Object.entries(this.moduleUniforms))
      for (const [n, s] of Object.entries(i))
        e[`${t}.${n}`] = {
          type: this.modules[t].uniformTypes?.[n],
          value: String(s)
        };
    return e;
  }
  _addModule(e) {
    const t = e.name;
    this.moduleUniforms[t] = e.defaultUniforms || {}, this.moduleBindings[t] = {};
  }
}
let i7 = "";
async function n7(r, e) {
  const t = new Image();
  return t.crossOrigin = "anonymous", t.src = r.startsWith("http") ? r : i7 + r, await t.decode(), e ? await createImageBitmap(t, e) : await createImageBitmap(t);
}
const s7 = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"], o7 = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"];
class Ng {
  device;
  id;
  props;
  // TODO - should we type these as possibly `null`? It will make usage harder?
  // @ts-expect-error
  texture;
  // @ts-expect-error
  sampler;
  // @ts-expect-error
  view;
  ready;
  isReady = !1;
  destroyed = !1;
  resolveReady = () => {
  };
  rejectReady = () => {
  };
  get [Symbol.toStringTag]() {
    return "AsyncTexture";
  }
  toString() {
    return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
  }
  constructor(e, t) {
    this.device = e;
    const i = Np("async-texture");
    this.props = {
      ...Ng.defaultProps,
      id: i,
      ...t
    }, this.id = this.props.id, t = {
      ...t
    }, typeof t?.data == "string" && t.dimension === "2d" && (t.data = n7(t.data)), t.mipmaps && (t.mipLevels = "auto"), this.ready = new Promise((n, s) => {
      this.resolveReady = () => {
        this.isReady = !0, n();
      }, this.rejectReady = s;
    }), this.initAsync(t);
  }
  async initAsync(e) {
    const t = e.data, i = await mP(t).then(void 0, this.rejectReady);
    if (this.destroyed)
      return;
    const n = this.props.width && this.props.height ? {
      width: this.props.width,
      height: this.props.height
    } : this.getTextureDataSize(i);
    if (!n)
      throw new Error("Texture size could not be determined");
    const s = {
      ...n,
      ...e,
      data: void 0,
      mipLevels: 1
    }, c = this.device.getMipLevelCount(s.width, s.height);
    if (s.mipLevels = this.props.mipLevels === "auto" ? c : Math.min(c, this.props.mipLevels), this.texture = this.device.createTexture(s), this.sampler = this.texture.sampler, this.view = this.texture.view, e.data)
      switch (this.props.dimension) {
        case "1d":
          this._setTexture1DData(this.texture, i);
          break;
        case "2d":
          this._setTexture2DData(i);
          break;
        case "3d":
          this._setTexture3DData(this.texture, i);
          break;
        case "2d-array":
          this._setTextureArrayData(this.texture, i);
          break;
        case "cube":
          this._setTextureCubeData(this.texture, i);
          break;
        case "cube-array":
          this._setTextureCubeArrayData(this.texture, i);
          break;
      }
    this.props.mipmaps && this.generateMipmaps(), Ht.info(1, `${this} loaded`), this.resolveReady();
  }
  destroy() {
    this.texture && (this.texture.destroy(), this.texture = null), this.destroyed = !0;
  }
  generateMipmaps() {
    this.texture.generateMipmapsWebGL();
  }
  /** Set sampler or create and set new Sampler from SamplerProps */
  setSampler(e = {}) {
    this.texture.setSampler(e instanceof Jf ? e : this.device.createSampler(e));
  }
  /**
   * Textures are immutable and cannot be resized after creation,
   * but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   * @note Mipmaps may need to be regenerated after resizing / setting new data
   * @todo Abort pending promise and create a texture with the new size?
   */
  resize(e) {
    if (!this.isReady)
      throw new Error("Cannot resize texture before it is ready");
    if (e.width === this.texture.width && e.height === this.texture.height)
      return !1;
    if (this.texture) {
      const t = this.texture;
      this.texture = t.clone(e), t.destroy();
    }
    return !0;
  }
  /** Check if texture data is a typed array */
  isTextureLevelData(e) {
    const t = e?.data;
    return ArrayBuffer.isView(t);
  }
  /** Get the size of the texture described by the provided TextureData */
  getTextureDataSize(e) {
    if (!e || ArrayBuffer.isView(e))
      return null;
    if (Array.isArray(e))
      return this.getTextureDataSize(e[0]);
    if (this.device.isExternalImage(e))
      return this.device.getExternalImageSize(e);
    if (e && typeof e == "object" && e.constructor === Object) {
      const i = Object.values(e)[0];
      return {
        width: i.width,
        height: i.height
      };
    }
    throw new Error("texture size deduction failed");
  }
  /** Convert luma.gl cubemap face constants to depth index */
  getCubeFaceDepth(e) {
    switch (e) {
      case "+X":
        return 0;
      case "-X":
        return 1;
      case "+Y":
        return 2;
      case "-Y":
        return 3;
      case "+Z":
        return 4;
      case "-Z":
        return 5;
      default:
        throw new Error(e);
    }
  }
  // EXPERIMENTAL
  setTextureData(e) {
  }
  /** Experimental: Set multiple mip levels */
  _setTexture1DData(e, t) {
    throw new Error("setTexture1DData not supported in WebGL.");
  }
  /** Experimental: Set multiple mip levels */
  _setTexture2DData(e, t = 0) {
    if (!this.texture)
      throw new Error("Texture not initialized");
    const i = this._normalizeTextureData(e);
    i.length > 1 && this.props.mipmaps !== !1 && Ht.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
    for (let n = 0; n < i.length; n++) {
      const s = i[n];
      this.device.isExternalImage(s) ? this.texture.copyExternalImage({
        image: s,
        depth: t,
        mipLevel: n,
        flipY: !0
      }) : this.texture.copyImageData({
        data: s.data,
        mipLevel: n
      });
    }
  }
  /**
   * Experimental: Sets 3D texture data: multiple depth slices, multiple mip levels
   * @param data
   */
  _setTexture3DData(e, t) {
    if (this.texture?.props.dimension !== "3d")
      throw new Error(this.id);
    for (let i = 0; i < t.length; i++)
      this._setTexture2DData(t[i], i);
  }
  /**
   * Experimental: Set Cube texture data, multiple faces, multiple mip levels
   * @todo - could support TextureCubeArray with depth
   * @param data
   * @param index
   */
  _setTextureCubeData(e, t) {
    if (this.texture?.props.dimension !== "cube")
      throw new Error(this.id);
    for (const [i, n] of Object.entries(t)) {
      const s = o7.indexOf(i);
      this._setTexture2DData(n, s);
    }
  }
  /**
   * Experimental: Sets texture array data, multiple levels, multiple depth slices
   * @param data
   */
  _setTextureArrayData(e, t) {
    if (this.texture?.props.dimension !== "2d-array")
      throw new Error(this.id);
    for (let i = 0; i < t.length; i++)
      this._setTexture2DData(t[i], i);
  }
  /**
   * Experimental: Sets texture cube array, multiple faces, multiple levels, multiple mip levels
   * @param data
   */
  _setTextureCubeArrayData(e, t) {
    throw new Error("setTextureCubeArrayData not supported in WebGL2.");
  }
  /** Experimental */
  _setTextureCubeFaceData(e, t, i, n = 0) {
    Array.isArray(t) && t.length > 1 && this.props.mipmaps !== !1 && Ht.warn(`${this.id} has mipmap and multiple LODs.`)();
    const s = s7.indexOf(i);
    this._setTexture2DData(t, s);
  }
  /**
   * Normalize TextureData to an array of TextureImageData / ExternalImages
   * @param data
   * @param options
   * @returns array of TextureImageData / ExternalImages
   */
  _normalizeTextureData(e) {
    const t = this.texture;
    let i;
    return ArrayBuffer.isView(e) ? i = [{
      // ts-expect-error does data really need to be Uint8ClampedArray?
      data: e,
      width: t.width,
      height: t.height
      // depth: options.depth
    }] : Array.isArray(e) ? i = e : i = [e], i;
  }
  static defaultProps = {
    ...Fs.defaultProps,
    data: null,
    mipmaps: !1
  };
}
async function mP(r) {
  if (r = await r, Array.isArray(r))
    return await Promise.all(r.map(mP));
  if (r && typeof r == "object" && r.constructor === Object) {
    const e = r, t = await Promise.all(Object.values(e)), i = Object.keys(e), n = {};
    for (let s = 0; s < i.length; s++)
      n[i[s]] = t[s];
    return n;
  }
  return r;
}
const Af = 2, a7 = 1e4;
class Zh {
  static defaultProps = {
    ...Gf.defaultProps,
    source: void 0,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: kf.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  };
  device;
  id;
  // @ts-expect-error assigned in function called from constructor
  source;
  // @ts-expect-error assigned in function called from constructor
  vs;
  // @ts-expect-error assigned in function called from constructor
  fs;
  pipelineFactory;
  shaderFactory;
  userData = {};
  // Fixed properties (change can trigger pipeline rebuild)
  /** The render pipeline GPU parameters, depth testing etc */
  parameters;
  /** The primitive topology */
  topology;
  /** Buffer layout */
  bufferLayout;
  // Dynamic properties
  /** Use instanced rendering */
  isInstanced = void 0;
  /** instance count. `undefined` means not instanced */
  instanceCount = 0;
  /** Vertex count */
  vertexCount;
  /** Index buffer */
  indexBuffer = null;
  /** Buffer-valued attributes */
  bufferAttributes = {};
  /** Constant-valued attributes */
  constantAttributes = {};
  /** Bindings (textures, samplers, uniform buffers) */
  bindings = {};
  /**
   * VertexArray
   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
   * @todo - allow application to define multiple vertex arrays?
   * */
  vertexArray;
  /** TransformFeedback, WebGL 2 only. */
  transformFeedback = null;
  /** The underlying GPU "program". @note May be recreated if parameters change */
  pipeline;
  /** ShaderInputs instance */
  // @ts-expect-error Assigned in function called by constructor
  shaderInputs;
  // @ts-expect-error Assigned in function called by constructor
  _uniformStore;
  _attributeInfos = {};
  _gpuGeometry = null;
  props;
  _pipelineNeedsUpdate = "newly created";
  _needsRedraw = "initializing";
  _destroyed = !1;
  /** "Time" of last draw. Monotonically increasing timestamp */
  _lastDrawTimestamp = -1;
  get [Symbol.toStringTag]() {
    return "Model";
  }
  toString() {
    return `Model(${this.id})`;
  }
  constructor(e, t) {
    this.props = {
      ...Zh.defaultProps,
      ...t
    }, t = this.props, this.id = t.id || Np("model"), this.device = e, Object.assign(this.userData, t.userData);
    const i = Object.fromEntries(this.props.modules?.map((d) => [d.name, d]) || []), n = t.shaderInputs || new r7(i, {
      disableWarnings: this.props.disableWarnings
    });
    this.setShaderInputs(n);
    const s = c7(e), c = (
      // @ts-ignore shaderInputs is assigned in setShaderInputs above.
      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || []
    );
    if (this.device.type === "webgpu" && this.props.source) {
      const {
        source: d,
        getUniforms: m
      } = this.props.shaderAssembler.assembleWGSLShader({
        platformInfo: s,
        ...this.props,
        modules: c
      });
      this.source = d, this._getModuleUniforms = m, this.props.shaderLayout ||= IN(this.source);
    } else {
      const {
        vs: d,
        fs: m,
        getUniforms: y
      } = this.props.shaderAssembler.assembleGLSLShaderPair({
        platformInfo: s,
        ...this.props,
        modules: c
      });
      this.vs = d, this.fs = m, this._getModuleUniforms = y;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, t.geometry && this.setGeometry(t.geometry), this.pipelineFactory = t.pipelineFactory || dx.getDefaultPipelineFactory(this.device), this.shaderFactory = t.shaderFactory || px.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
      shaderLayout: this.pipeline.shaderLayout,
      bufferLayout: this.pipeline.bufferLayout
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in t && (this.isInstanced = t.isInstanced), t.instanceCount && this.setInstanceCount(t.instanceCount), t.vertexCount && this.setVertexCount(t.vertexCount), t.indexBuffer && this.setIndexBuffer(t.indexBuffer), t.attributes && this.setAttributes(t.attributes), t.constantAttributes && this.setConstantAttributes(t.constantAttributes), t.bindings && this.setBindings(t.bindings), t.transformFeedback && (this.transformFeedback = t.transformFeedback), Object.seal(this);
  }
  destroy() {
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const e = this._needsRedraw;
    return this._needsRedraw = !1, e;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(e) {
    this._needsRedraw ||= e;
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(e) {
    const t = this._areBindingsLoading();
    if (t)
      return Ht.info(Af, `>>> DRAWING ABORTED ${this.id}: ${t} not loaded`)(), !1;
    try {
      e.pushDebugGroup(`${this}.predraw(${e})`), this.predraw();
    } finally {
      e.popDebugGroup();
    }
    let i;
    try {
      e.pushDebugGroup(`${this}.draw(${e})`), this._logDrawCallStart(), this.pipeline = this._updatePipeline();
      const n = this._getBindings();
      this.pipeline.setBindings(n, {
        disableWarnings: this.props.disableWarnings
      });
      const {
        indexBuffer: s
      } = this.vertexArray, c = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
      i = this.pipeline.draw({
        renderPass: e,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: c,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      e.popDebugGroup(), this._logDrawCallEnd();
    }
    return this._logFramebuffer(e), i ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", i;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(e) {
    this._gpuGeometry?.destroy();
    const t = e && Hz(this.device, e);
    if (t) {
      this.setTopology(t.topology || "triangle-list");
      const i = new kb(this.bufferLayout);
      this.bufferLayout = i.mergeBufferLayouts(t.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(t);
    }
    this._gpuGeometry = t;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(e) {
    e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(e) {
    const t = new kb(this.bufferLayout);
    this.bufferLayout = this._gpuGeometry ? t.mergeBufferLayouts(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      shaderLayout: this.pipeline.shaderLayout,
      bufferLayout: this.pipeline.bufferLayout
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(e) {
    Sv(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(e) {
    this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(e) {
    this.vertexCount = e, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(e) {
    this.shaderInputs = e, this._uniformStore = new KD(this.shaderInputs.modules);
    for (const [t, i] of Object.entries(this.shaderInputs.modules))
      if (l7(i)) {
        const n = this._uniformStore.getManagedUniformBuffer(this.device, t);
        this.bindings[`${t}Uniforms`] = n;
      }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindingValues()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(e) {
    Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(e) {
    this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(e) {
    this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(e, t) {
    const i = t?.disableWarnings ?? this.props.disableWarnings;
    e.indices && Ht.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)(), this.bufferLayout = Yz(this.pipeline.shaderLayout, this.bufferLayout);
    const n = new kb(this.bufferLayout);
    for (const [s, c] of Object.entries(e)) {
      const o = n.getBufferLayout(s);
      if (!o) {
        i || Ht.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
        continue;
      }
      const d = n.getAttributeNamesForBuffer(o);
      let m = !1;
      for (const y of d) {
        const T = this._attributeInfos[y];
        if (T) {
          const P = this.device.type === "webgpu" ? n.getBufferIndex(T.bufferName) : T.location;
          this.vertexArray.setBuffer(P, c), m = !0;
        }
      }
      !m && !i && Ht.warn(`Model(${this.id}): Ignoring buffer "${c.id}" for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(e, t) {
    for (const [i, n] of Object.entries(e)) {
      const s = this._attributeInfos[i];
      s ? this.vertexArray.setConstantWebGL(s.location, n) : (t?.disableWarnings ?? this.props.disableWarnings) || Ht.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${i}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // INTERNAL METHODS
  /** Check that bindings are loaded. Returns id of first binding that is still loading. */
  _areBindingsLoading() {
    for (const e of Object.values(this.bindings))
      if (e instanceof Ng && !e.isReady)
        return e.id;
    return !1;
  }
  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
  _getBindings() {
    const e = {};
    for (const [t, i] of Object.entries(this.bindings))
      i instanceof Ng ? i.isReady && (e[t] = i.texture) : e[t] = i;
    return e;
  }
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let e = 0;
    for (const t of Object.values(this.bindings))
      t instanceof Jy ? e = Math.max(e, t.texture.updateTimestamp) : t instanceof us || t instanceof Fs ? e = Math.max(e, t.updateTimestamp) : t instanceof Ng ? e = t.texture ? Math.max(e, t.texture.updateTimestamp) : (
        // The texture will become available in the future
        1 / 0
      ) : t instanceof Jf || (e = Math.max(e, t.buffer.updateTimestamp));
    return e;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(e) {
    const t = {
      ...e.attributes
    };
    for (const [i] of Object.entries(t))
      !this.pipeline.shaderLayout.attributes.find((n) => n.name === i) && i !== "positions" && delete t[i];
    this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, {
      disableWarnings: !0
    }), this.setAttributes(t, {
      disableWarnings: this.props.disableWarnings
    }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(e) {
    this._pipelineNeedsUpdate ||= e, this.setNeedsRedraw(e);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let e = null, t = null;
      this.pipeline && (Ht.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, t = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const i = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debugShaders: this.props.debugShaders
      });
      let n = null;
      this.source ? n = i : this.fs && (n = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debugShaders: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        // TODO - why set bindings here when we reset them every frame?
        // Should we expose a BindGroup abstraction?
        bindings: this._getBindings(),
        vs: i,
        fs: n
      }), this._attributeInfos = rI(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), t && this.shaderFactory.release(t);
    }
    return this.pipeline;
  }
  /** Throttle draw call logging */
  _lastLogTime = 0;
  _logOpen = !1;
  _logDrawCallStart() {
    const e = Ht.level > 3 ? 0 : a7;
    Ht.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, Ht.group(Af, `>>> DRAWING MODEL ${this.id}`, {
      collapsed: Ht.level <= 2
    })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const e = Xz(this.pipeline.shaderLayout, this.id);
      Ht.table(Af, e)();
      const t = this.shaderInputs.getDebugTable();
      Ht.table(Af, t)();
      const i = this._getAttributeDebugTable();
      Ht.table(Af, this._attributeInfos)(), Ht.table(Af, i)(), Ht.groupEnd(Af)(), this._logOpen = !1;
    }
  }
  _drawCount = 0;
  _logFramebuffer(e) {
    const t = this.device.props.debugFramebuffers;
    if (this._drawCount++, !t)
      return;
    const i = e.props.framebuffer;
    i && Zz(i, {
      id: i.id,
      minimap: !0
    });
  }
  _getAttributeDebugTable() {
    const e = {};
    for (const [t, i] of Object.entries(this._attributeInfos)) {
      const n = this.vertexArray.attributes[i.location];
      e[i.location] = {
        name: t,
        type: i.shaderType,
        values: n ? this._getBufferOrConstantValues(n, i.bufferDataType) : "null"
      };
    }
    if (this.vertexArray.indexBuffer) {
      const {
        indexBuffer: t
      } = this.vertexArray, i = t.indexType === "uint32" ? new Uint32Array(t.debugData) : new Uint16Array(t.debugData);
      e.indices = {
        name: "indices",
        type: t.indexType,
        values: i.toString()
      };
    }
    return e;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(e, t) {
    const i = R2(t);
    return (e instanceof us ? new i(e.debugData) : e).toString();
  }
}
function l7(r) {
  return !!(r.uniformTypes && !u7(r.uniformTypes));
}
function c7(r) {
  return {
    type: r.type,
    shaderLanguage: r.info.shadingLanguage,
    shaderLanguageVersion: r.info.shadingLanguageVersion,
    gpu: r.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: r.features
  };
}
function u7(r) {
  for (const e in r)
    return !1;
  return !0;
}
class Tp {
  device;
  model;
  transformFeedback;
  static defaultProps = {
    ...Zh.defaultProps,
    outputs: void 0,
    feedbackBuffers: void 0
  };
  static isSupported(e) {
    return e?.info?.type === "webgl";
  }
  constructor(e, t = Tp.defaultProps) {
    if (!Tp.isSupported(e))
      throw new Error("BufferTransform not yet implemented on WebGPU");
    this.device = e, this.model = new Zh(this.device, {
      id: t.id || "buffer-transform-model",
      fs: t.fs || WO(),
      topology: t.topology || "point-list",
      varyings: t.outputs || t.varyings,
      ...t
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      // @ts-expect-error TODO
      buffers: t.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(e) {
    e?.inputBuffers && this.model.setAttributes(e.inputBuffers), e?.outputBuffers && this.transformFeedback.setBuffers(e.outputBuffers);
    const t = this.device.beginRenderPass(e);
    this.model.draw(t), t.end();
  }
  // DEPRECATED METHODS
  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(e) {
    return this.transformFeedback.getBuffer(e);
  }
  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
  readAsync(e) {
    const t = this.getBuffer(e);
    if (!t)
      throw new Error("BufferTransform#getBuffer");
    if (t instanceof us)
      return t.readAsync();
    const {
      buffer: i,
      byteOffset: n = 0,
      byteLength: s = i.byteLength
    } = t;
    return i.readAsync(n, s);
  }
}
class dp {
  id;
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  vertexCount;
  indices;
  attributes;
  userData = {};
  constructor(e) {
    const {
      attributes: t = {},
      indices: i = null,
      vertexCount: n = null
    } = e;
    this.id = e.id || Np("geometry"), this.topology = e.topology, i && (this.indices = ArrayBuffer.isView(i) ? {
      value: i,
      size: 1
    } : i), this.attributes = {};
    for (const [s, c] of Object.entries(t)) {
      const o = ArrayBuffer.isView(c) ? {
        value: c
      } : c;
      if (!ArrayBuffer.isView(o.value))
        throw new Error(`${this._print(s)}: must be typed array or object with value as typed array`);
      if ((s === "POSITION" || s === "positions") && !o.size && (o.size = 3), s === "indices") {
        if (this.indices)
          throw new Error("Multiple indices detected");
        this.indices = o;
      } else
        this.attributes[s] = o;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = n || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  // PRIVATE
  _print(e) {
    return `Geometry ${this.id} attribute ${e}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(e, t) {
    return this;
  }
  _calculateVertexCount(e, t) {
    if (t)
      return t.value.length;
    let i = 1 / 0;
    for (const n of Object.values(e)) {
      const {
        value: s,
        size: c,
        constant: o
      } = n;
      !o && s && c !== void 0 && c >= 1 && (i = Math.min(i, s.length / c));
    }
    return i;
  }
}
class Ly {
  id;
  matrix = new Pi();
  display = !0;
  position = new xt();
  rotation = new xt();
  scale = new xt(1, 1, 1);
  userData = {};
  props = {};
  constructor(e = {}) {
    const {
      id: t
    } = e;
    this.id = t || Np(this.constructor.name), this._setScenegraphNodeProps(e);
  }
  getBounds() {
    return null;
  }
  destroy() {
  }
  /** @deprecated use .destroy() */
  delete() {
    this.destroy();
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }
  setPosition(e) {
    return this.position = e, this;
  }
  setRotation(e) {
    return this.rotation = e, this;
  }
  setScale(e) {
    return this.scale = e, this;
  }
  setMatrix(e, t = !0) {
    t ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    const {
      position: t,
      rotation: i,
      scale: n,
      update: s = !0
    } = e;
    return t && this.setPosition(t), i && this.setRotation(i), n && this.setScale(n), s && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, t = this.rotation, i = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(t), this.matrix.scale(i), this;
  }
  update(e = {}) {
    const {
      position: t,
      rotation: i,
      scale: n
    } = e;
    return t && this.setPosition(t), i && this.setRotation(i), n && this.setScale(n), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, t) {
    t = t || this.matrix;
    const i = new Pi(e).multiplyRight(t), n = i.invert(), s = n.transpose();
    return {
      viewMatrix: e,
      modelMatrix: t,
      objectMatrix: t,
      worldMatrix: i,
      worldInverseMatrix: n,
      worldInverseTransposeMatrix: s
    };
  }
  // TODO - copied code, not yet vetted
  /*
  transform() {
    if (!this.parent) {
      this.endPosition.set(this.position);
      this.endRotation.set(this.rotation);
      this.endScale.set(this.scale);
    } else {
      const parent = this.parent;
      this.endPosition.set(this.position.add(parent.endPosition));
      this.endRotation.set(this.rotation.add(parent.endRotation));
      this.endScale.set(this.scale.add(parent.endScale));
    }
       const ch = this.children;
    for (let i = 0; i < ch.length; ++i) {
      ch[i].transform();
    }
       return this;
  }
  */
  _setScenegraphNodeProps(e) {
    "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class Fp extends Ly {
  children;
  constructor(e = {}) {
    e = Array.isArray(e) ? {
      children: e
    } : e;
    const {
      children: t = []
    } = e;
    Ht.assert(t.every((i) => i instanceof Ly), "every child must an instance of ScenegraphNode"), super(e), this.children = t;
  }
  getBounds() {
    const e = [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
    return this.traverse((t, {
      worldMatrix: i
    }) => {
      const n = t.getBounds();
      if (!n)
        return;
      const [s, c] = n, o = new xt(s).add(c).divide([2, 2, 2]);
      i.transformAsPoint(o, o);
      const d = new xt(c).subtract(s).divide([2, 2, 2]);
      i.transformAsVector(d, d);
      for (let m = 0; m < 8; m++) {
        const y = new xt(m & 1 ? -1 : 1, m & 2 ? -1 : 1, m & 4 ? -1 : 1).multiply(d).add(o);
        for (let T = 0; T < 3; T++)
          e[0][T] = Math.min(e[0][T], y[T]), e[1][T] = Math.max(e[1][T], y[T]);
      }
    }), Number.isFinite(e[0][0]) ? e : null;
  }
  destroy() {
    this.children.forEach((e) => e.destroy()), this.removeAll(), super.destroy();
  }
  // Unpacks arrays and nested arrays of children
  add(...e) {
    for (const t of e)
      Array.isArray(t) ? this.add(...t) : this.children.push(t);
    return this;
  }
  remove(e) {
    const t = this.children, i = t.indexOf(e);
    return i > -1 && t.splice(i, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  traverse(e, {
    worldMatrix: t = new Pi()
  } = {}) {
    const i = new Pi(t).multiplyRight(this.matrix);
    for (const n of this.children)
      n instanceof Fp ? n.traverse(e, {
        worldMatrix: i
      }) : e(n, {
        worldMatrix: i
      });
  }
}
class Ev extends Ly {
  model;
  bounds = null;
  managedResources;
  // TODO - is this used? override callbacks to make sure we call them with this
  // onBeforeRender = null;
  // onAfterRender = null;
  // AfterRender = null;
  constructor(e) {
    super(e), this.model = e.model, this.managedResources = e.managedResources || [], this.bounds = e.bounds || null, this.setProps(e);
  }
  destroy() {
    this.model && (this.model.destroy(), this.model = null), this.managedResources.forEach((e) => e.destroy()), this.managedResources = [];
  }
  getBounds() {
    return this.bounds;
  }
  // Expose model methods
  draw(e) {
    return this.model.draw(e);
  }
}
const h7 = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant",
  blendAlphaDstFactor: "zero"
};
class _P extends ux {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({
    layers: e,
    layerFilter: t,
    views: i,
    viewports: n,
    onViewportActive: s,
    pickingFBO: c,
    deviceRect: {
      x: o,
      y: d,
      width: m,
      height: y
    },
    cullRect: T,
    effects: P,
    pass: I = "picking",
    pickZ: D,
    shaderModuleProps: k
  }) {
    this.pickZ = D;
    const $ = this._resetColorEncoder(D), G = [o, d, m, y], te = super.render({
      target: c,
      layers: e,
      layerFilter: t,
      views: i,
      viewports: n,
      onViewportActive: s,
      cullRect: T,
      effects: P?.filter((H) => H.useInPicking),
      pass: I,
      isPicking: !0,
      shaderModuleProps: k,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: G
    });
    return this._colorEncoderState = null, {
      decodePickingColor: $ && d7.bind(null, $),
      stats: te
    };
  }
  shouldDrawLayer(e) {
    const {
      pickable: t,
      operation: i
    } = e.props;
    return t && i.includes("draw") || i.includes("terrain") || i.includes("mask");
  }
  getShaderModuleProps(e, t, i) {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      lighting: {
        enabled: !1
      }
    };
  }
  getLayerParameters(e, t, i) {
    const n = {
      ...e.props.parameters
    }, {
      pickable: s,
      operation: c
    } = e.props;
    return !this._colorEncoderState || c.includes("terrain") ? n.blend = !1 : s && c.includes("draw") && (Object.assign(n, h7), n.blend = !0, n.blendColor = f7(this._colorEncoderState, e, i)), n;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function f7(r, e, t) {
  const {
    byLayer: i,
    byAlpha: n
  } = r;
  let s, c = i.get(e);
  return c ? (c.viewports.push(t), s = c.a) : (s = i.size + 1, s <= 255 ? (c = {
    a: s,
    layer: e,
    viewports: [t]
  }, i.set(e, c), n[s] = c) : (Ni.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255];
}
function d7(r, e) {
  const t = r.byAlpha[e[3]];
  return t && {
    pickedLayer: t.layer,
    pickedViewports: t.viewports,
    pickedObjectIndex: t.layer.decodePickingColor(e)
  };
}
const Yd = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, By = Symbol.for("component"), $h = Symbol.for("propTypes"), Ob = Symbol.for("deprecatedProps"), pp = Symbol.for("asyncPropDefaults"), td = Symbol.for("asyncPropOriginal"), jh = Symbol.for("asyncPropResolved");
function rd(r, e = () => !0) {
  return Array.isArray(r) ? yP(r, e, []) : e(r) ? [r] : [];
}
function yP(r, e, t) {
  let i = -1;
  for (; ++i < r.length; ) {
    const n = r[i];
    Array.isArray(n) ? yP(n, e, t) : e(n) && t.push(n);
  }
  return t;
}
function p7({
  target: r,
  source: e,
  start: t = 0,
  count: i = 1
}) {
  const n = e.length, s = i * n;
  let c = 0;
  for (let o = t; c < n; c++)
    r[o++] = e[c];
  for (; c < s; )
    c < s - c ? (r.copyWithin(t + c, t, t + c), c *= 2) : (r.copyWithin(t + c, t, t + s - c), c = s);
  return r;
}
class g7 {
  constructor(e, t, i) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = i, this.setData(t);
  }
  // consumer: {onChange: Function}
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, t) {
    if (e === this._data && !t)
      return;
    this._data = e;
    const i = ++this._loadCount;
    let n = e;
    typeof e == "string" && (n = Wh(e)), n instanceof Promise ? (this.isLoaded = !1, this._loader = n.then((s) => {
      this._loadCount === i && (this.isLoaded = !0, this._error = void 0, this._content = s);
    }).catch((s) => {
      this._loadCount === i && (this.isLoaded = !0, this._error = s || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const s of this._subscribers)
      s.onChange(this.getData());
  }
}
class m7 {
  constructor(e) {
    this.protocol = e.protocol || "resource://", this._context = {
      device: e.device,
      // @ts-expect-error
      gl: e.device?.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add({
    resourceId: e,
    data: t,
    forceUpdate: i = !1,
    persistent: n = !0
  }) {
    let s = this._resources[e];
    s ? s.setData(t, i) : (s = new g7(e, t, this._context), this._resources[e] = s), s.persistent = n;
  }
  remove(e) {
    const t = this._resources[e];
    t && (t.delete(), delete this._resources[e]);
  }
  unsubscribe({
    consumerId: e
  }) {
    const t = this._consumers[e];
    if (t) {
      for (const i in t) {
        const n = t[i], s = this._resources[n.resourceId];
        s && s.unsubscribe(n);
      }
      delete this._consumers[e], this.prune();
    }
  }
  subscribe({
    resourceId: e,
    onChange: t,
    consumerId: i,
    requestId: n = "default"
  }) {
    const {
      _resources: s,
      protocol: c
    } = this;
    e.startsWith(c) && (e = e.replace(c, ""), s[e] || this.add({
      resourceId: e,
      data: null,
      persistent: !1
    }));
    const o = s[e];
    if (this._track(i, n, o, t), o)
      return o.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, t, i, n) {
    const s = this._consumers, c = s[e] = s[e] || {};
    let o = c[t];
    const d = o && o.resourceId && this._resources[o.resourceId];
    d && (d.unsubscribe(o), this.prune()), i && (o ? (o.onChange = n, o.resourceId = i.id) : o = {
      onChange: n,
      resourceId: i.id
    }, c[t] = o, i.subscribe(o));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const t = this._resources[e];
      !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
    }
  }
}
const _7 = "layerManager.setLayers", y7 = "layerManager.activateViewport";
class b7 {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(e, t) {
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (o) => {
      Vo(y7, this, o), o && (this.context.viewport = o);
    };
    const {
      deck: i,
      stats: n,
      viewport: s,
      timeline: c
    } = t || {};
    this.layers = [], this.resourceManager = new m7({
      device: e,
      protocol: "deck://"
    }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: e,
      // @ts-expect-error
      gl: e?.gl,
      deck: i,
      shaderAssembler: gz(e?.info?.shadingLanguage || "glsl"),
      defaultShaderModules: [A8],
      renderPass: void 0,
      stats: n || new kp({
        id: "deck.gl"
      }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: s || new Dp({
        id: "DEFAULT-INITIAL-VIEWPORT"
      }),
      // Current viewport, exposed to layers for project* function
      timeline: c || new gP(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  /** Check if a redraw is needed */
  needsRedraw(e = {
    clearRedrawFlags: !1
  }) {
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const i of this.layers) {
      const n = i.getNeedsRedraw(e);
      t = t || n;
    }
    return t;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({
    layerIds: e
  } = {}) {
    return e ? this.layers.filter((t) => e.find((i) => t.id.indexOf(i) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(e, t) {
    Vo(_7, this, t, e), this._lastRenderedLayers = e;
    const i = rd(e, Boolean);
    for (const n of i)
      n.context = this.context;
    this._updateLayers(this.layers, i);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(e) {
    const {
      defaultShaderModules: t
    } = this.context;
    t.find((i) => i.name === e.name) || (t.push(e), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(e) {
    const {
      defaultShaderModules: t
    } = this.context, i = t.findIndex((n) => n.name === e.name);
    i >= 0 && (t.splice(i, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(e, t, i) {
    i.raiseError(t, `${e} of ${i}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(e, t) {
    const i = {};
    for (const c of e)
      i[c.id] ? Ni.warn(`Multiple old layers with same id ${c.id}`)() : i[c.id] = c;
    if (this._defaultShaderModulesChanged) {
      for (const c of e)
        c.setNeedsUpdate(), c.setChangeFlags({
          extensionsChanged: !0
        });
      this._defaultShaderModulesChanged = !1;
    }
    const n = [];
    this._updateSublayersRecursively(t, i, n), this._finalizeOldLayers(i);
    let s = !1;
    for (const c of n)
      if (c.hasUniformTransition()) {
        s = `Uniform transition in ${c}`;
        break;
      }
    this._needsUpdate = s, this.layers = n;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(e, t, i) {
    for (const n of e) {
      n.context = this.context;
      const s = t[n.id];
      s === null && Ni.warn(`Multiple new layers with same id ${n.id}`)(), t[n.id] = null;
      let c = null;
      try {
        this._debug && s !== n && n.validateProps(), s ? (this._transferLayerState(s, n), this._updateLayer(n)) : this._initializeLayer(n), i.push(n), c = n.isComposite ? n.getSubLayers() : null;
      } catch (o) {
        this._handleError("matching", o, n);
      }
      c && this._updateSublayersRecursively(c, t, i);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(e) {
    for (const t in e) {
      const i = e[t];
      i && this._finalizeLayer(i);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = Yd.INITIALIZED;
    } catch (t) {
      this._handleError("initialization", t, e);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(e, t) {
    t._transferState(e), t.lifecycle = Yd.MATCHED, t !== e && (e.lifecycle = Yd.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(e) {
    try {
      e._update();
    } catch (t) {
      this._handleError("update", t, e);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Yd.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = Yd.FINALIZED;
    } catch (t) {
      this._handleError("finalization", t, e);
    }
  }
}
function Rl(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let i = 0; i < r.length; i++)
      if (!Rl(r[i], e[i], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const i = Object.keys(r), n = Object.keys(e);
    if (i.length !== n.length)
      return !1;
    for (const s of i)
      if (!e.hasOwnProperty(s) || !Rl(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class v7 {
  constructor(e) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(e = {
    clearRedrawFlags: !1
  }) {
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(e) {
    return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const e = {};
    return this.views.forEach((t) => {
      e[t.id] = t;
    }), e;
  }
  /** Resolves a viewId string to a View */
  getView(e) {
    return this.views.find((t) => t.id === e);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(e) {
    const t = typeof e == "string" ? this.getView(e) : e, i = t && this.viewState[t.getViewStateId()] || this.viewState;
    return t ? t.filterViewState(i) : i;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, t) {
    const i = this.getViewports(), n = {
      x: e[0],
      y: e[1]
    };
    for (let s = i.length - 1; s >= 0; --s) {
      const c = i[s];
      if (c.containsPixel(n)) {
        const o = e.slice();
        return o[0] -= c.x, o[1] -= c.y, c.unproject(o, t);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, t) {
    (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(e) {
    e = rd(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!Rl(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : Ni.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(e, t) {
    const i = t.type;
    return new i({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (s) => this.getView(e.id)?.makeViewport({
        viewState: s,
        width: this.width,
        height: this.height
      })
    });
  }
  _updateController(e, t, i, n) {
    const s = e.controller;
    if (s && i) {
      const c = {
        ...t,
        ...s,
        id: e.id,
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      };
      return (!n || n.constructor !== s.type) && (n = this._createController(e, c)), n && n.setProps(c), n;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const {
      views: e
    } = this, t = this.controllers;
    this._viewports = [], this.controllers = {};
    let i = !1;
    for (let n = e.length; n--; ) {
      const s = e[n], c = this.getViewState(s), o = s.makeViewport({
        viewState: c,
        width: this.width,
        height: this.height
      });
      let d = t[s.id];
      const m = !!s.controller;
      m && !d && (i = !0), (i || !m) && d && (d.finalize(), d = null), this.controllers[s.id] = this._updateController(s, c, o, d), o && this._viewports.unshift(o);
    }
    for (const n in t) {
      const s = t[n];
      s && !this.controllers[n] && s.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(e, t) {
    return e.length !== t.length ? !0 : e.some((i, n) => !e[n].equals(t[n]));
  }
}
const x7 = /([0-9]+\.?[0-9]*)(%|px)/;
function Ph(r) {
  switch (typeof r) {
    case "number":
      return {
        position: r,
        relative: !1
      };
    case "string":
      const e = x7.exec(r);
      if (e && e.length >= 3) {
        const t = e[2] === "%", i = parseFloat(e[1]);
        return {
          position: t ? i / 100 : i,
          relative: t
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${r}`);
  }
}
function Mh(r, e) {
  return r.relative ? Math.round(r.position * e) : r.position;
}
class bP {
  constructor(e) {
    const {
      id: t,
      x: i = 0,
      y: n = 0,
      width: s = "100%",
      height: c = "100%",
      padding: o = null
    } = e;
    this.id = t || this.constructor.displayName || "view", this.props = {
      ...e,
      id: this.id
    }, this._x = Ph(i), this._y = Ph(n), this._width = Ph(s), this._height = Ph(c), this._padding = o && {
      left: Ph(o.left || 0),
      right: Ph(o.right || 0),
      top: Ph(o.top || 0),
      bottom: Ph(o.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.constructor === e.constructor && Rl(this.props, e.props, 2);
  }
  /** Clone this view with modified props */
  clone(e) {
    const t = this.constructor;
    return new t({
      ...this.props,
      ...e
    });
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({
    width: e,
    height: t,
    viewState: i
  }) {
    i = this.filterViewState(i);
    const n = this.getDimensions({
      width: e,
      height: t
    });
    if (!n.height || !n.width)
      return null;
    const s = this.getViewportType(i);
    return new s({
      ...i,
      ...this.props,
      ...n
    });
  }
  getViewStateId() {
    const {
      viewState: e
    } = this.props;
    return typeof e == "string" ? e : e?.id || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const t = {
        ...e
      };
      for (const i in this.props.viewState)
        i !== "id" && (t[i] = this.props.viewState[i]);
      return t;
    }
    return e;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({
    width: e,
    height: t
  }) {
    const i = {
      x: Mh(this._x, e),
      y: Mh(this._y, t),
      width: Mh(this._width, e),
      height: Mh(this._height, t)
    };
    return this._padding && (i.padding = {
      left: Mh(this._padding.left, e),
      top: Mh(this._padding.top, t),
      right: Mh(this._padding.right, e),
      bottom: Mh(this._padding.bottom, t)
    }), i;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? {
      type: this.ControllerType
    } : typeof e == "function" ? {
      type: e
    } : {
      type: this.ControllerType,
      ...e
    } : null;
  }
}
class t0 {
  /**
   * @params timeline {Timeline}
   */
  constructor(e) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = e;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(e) {
    this.cancel(), this.settings = e, this._inProgress = !0, this.settings.onStart?.(this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, this.settings.onEnd?.(this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    this._inProgress && (this.settings.onInterrupt?.(this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const {
        _timeline: e,
        settings: t
      } = this;
      this._handle = e.addChannel({
        delay: e.getTime(),
        duration: t.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const w3 = () => {
}, Cv = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, w7 = (r) => r, A7 = Cv.BREAK;
class T7 {
  constructor(e) {
    this._onTransitionUpdate = (t) => {
      const {
        time: i,
        settings: {
          interpolator: n,
          startProps: s,
          endProps: c,
          duration: o,
          easing: d
        }
      } = t, m = d(i / o), y = n.interpolateProps(s, c, m);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...y
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new t0(e.timeline), this.onViewStateChange = e.onViewStateChange || w3, this.onStateChange = e.onStateChange || w3;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(e) {
    let t = !1;
    const i = this.props;
    if (this.props = e, !i || this._shouldIgnoreViewportChange(i, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let n = i;
      if (this.transition.inProgress) {
        const {
          interruption: s,
          endProps: c
        } = this.transition.settings;
        n = {
          ...i,
          ...s === Cv.SNAP_TO_END ? c : this.propsInTransition || i
        };
      }
      this._triggerTransition(n, e), t = !0;
    } else
      this.transition.cancel();
    return t;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(e) {
    const {
      transitionDuration: t,
      transitionInterpolator: i
    } = e;
    return (t > 0 || t === "auto") && !!i;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, t) {
    return this.transition.inProgress ? this.transition.settings.interruption === Cv.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
  }
  _triggerTransition(e, t) {
    const i = this.getControllerState(e), n = this.getControllerState(t).shortestPathFrom(i), s = t.transitionInterpolator, c = s.getDuration ? s.getDuration(e, t) : t.transitionDuration;
    if (c === 0)
      return;
    const o = s.initializeProps(e, n);
    this.propsInTransition = {};
    const d = {
      duration: c,
      easing: t.transitionEasing || w7,
      interpolator: s,
      interruption: t.transitionInterruption || A7,
      startProps: o.start,
      endProps: o.end,
      onStart: t.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(t.onTransitionEnd)
    };
    this.transition.start(d), this.onStateChange({
      inTransition: !0
    }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (t) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e?.(t);
    };
  }
}
function Ks(r, e) {
  if (!r)
    throw new Error(e || "deck.gl: assertion failed.");
}
class S7 {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(e) {
    const {
      compare: t,
      extract: i,
      required: n
    } = e;
    this._propsToCompare = t, this._propsToExtract = i || t, this._requiredProps = n;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(e, t) {
    for (const i of this._propsToCompare)
      if (!(i in e) || !(i in t) || !Ac(e[i], t[i]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(e, t) {
    const i = {}, n = {};
    for (const s of this._propsToExtract)
      (s in e || s in t) && (i[s] = e[s], n[s] = t[s]);
    return this._checkRequiredProps(i), this._checkRequiredProps(n), {
      start: i,
      end: n
    };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(e, t) {
    return t.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((t) => {
      const i = e[t];
      Ks(Number.isFinite(i) || Array.isArray(i), `${t} is required for transition`);
    });
  }
}
const E7 = ["longitude", "latitude", "zoom", "bearing", "pitch"], C7 = ["longitude", "latitude", "zoom"];
class gx extends S7 {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(e = {}) {
    const t = Array.isArray(e) ? e : e.transitionProps, i = Array.isArray(e) ? {} : e;
    i.transitionProps = Array.isArray(t) ? {
      compare: t,
      required: t
    } : t || {
      compare: E7,
      required: C7
    }, super(i.transitionProps), this.opts = i;
  }
  initializeProps(e, t) {
    const i = super.initializeProps(e, t), {
      makeViewport: n,
      around: s
    } = this.opts;
    if (n && s) {
      const c = n(e), o = n(t), d = c.unproject(s);
      i.start.around = s, Object.assign(i.end, {
        around: o.project(d),
        aroundPosition: d,
        width: t.width,
        height: t.height
      });
    }
    return i;
  }
  interpolateProps(e, t, i) {
    const n = {};
    for (const s of this._propsToExtract)
      n[s] = Iy(e[s] || 0, t[s] || 0, i);
    if (t.aroundPosition && this.opts.makeViewport) {
      const s = this.opts.makeViewport({
        ...t,
        ...n
      });
      Object.assign(n, s.panByPosition(
        t.aroundPosition,
        // anchor point in current screen coordinates
        Iy(e.around, t.around, i)
      ));
    }
    return n;
  }
}
const Zu = {
  transitionDuration: 0
}, I7 = 300, o_ = (r) => 1 - (1 - r) * (1 - r), Vd = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
  DOUBLE_CLICK: ["dblclick"],
  KEYBOARD: ["keydown"]
}, Tf = {};
class vP {
  constructor(e) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new T7({
      ...e,
      getControllerState: (t) => new this.ControllerState(t),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const e in this._events)
      this._events[e] && this.eventManager?.off(e, this.handleEvent);
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(e) {
    this._controllerState = void 0;
    const t = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return t ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return t ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "multipanstart":
        return t ? !1 : this._onMultiPanStart(e);
      case "multipanmove":
        return this._onMultiPan(e);
      case "multipanend":
        return this._onMultiPanEnd(e);
      case "dblclick":
        return this._onDoubleClick(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const {
      x: t,
      y: i
    } = this.props, {
      offsetCenter: n
    } = e;
    return [n.x - t, n.y - i];
  }
  isPointInBounds(e, t) {
    const {
      width: i,
      height: n
    } = this.props;
    if (t && t.handled)
      return !1;
    const s = e[0] >= 0 && e[0] <= i && e[1] >= 0 && e[1] <= n;
    return s && t && t.stopPropagation(), s;
  }
  isFunctionKeyPressed(e) {
    const {
      srcEvent: t
    } = e;
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(e) {
    const t = setTimeout(() => {
      this._eventStartBlocked === t && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = t;
  }
  /**
   * Extract interactivity options
   */
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const {
      inertia: t
    } = e;
    this.inertia = Number.isFinite(t) ? t : t === !0 ? I7 : 0;
    const {
      scrollZoom: i = !0,
      dragPan: n = !0,
      dragRotate: s = !0,
      doubleClickZoom: c = !0,
      touchZoom: o = !0,
      touchRotate: d = !1,
      keyboard: m = !0
    } = e, y = !!this.onViewStateChange;
    this.toggleEvents(Vd.WHEEL, y && i), this.toggleEvents(Vd.PAN, y), this.toggleEvents(Vd.PINCH, y && (o || d)), this.toggleEvents(Vd.MULTI_PAN, y && d), this.toggleEvents(Vd.DOUBLE_CLICK, y && c), this.toggleEvents(Vd.KEYBOARD, y && m), this.scrollZoom = i, this.dragPan = n, this.dragRotate = s, this.doubleClickZoom = c, this.touchZoom = o, this.touchRotate = d, this.keyboard = m;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, t) {
    this.eventManager && e.forEach((i) => {
      this._events[i] !== t && (this._events[i] = t, t ? this.eventManager.on(i, this.handleEvent) : this.eventManager.off(i, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(e, t = null, i = {}) {
    const n = {
      ...e.getViewportProps(),
      ...t
    }, s = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(i), s) {
      const c = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({
        viewState: n,
        interactionState: this._interactionState,
        oldViewState: c,
        viewId: this.props.id
      });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({
      ...e,
      interactionState: this._interactionState,
      viewId: this.props.id
    });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    let i = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (i = !i);
    const n = this.controllerState[i ? "panStart" : "rotateStart"]({
      pos: t
    });
    return this._panMove = i, this.updateViewport(n, Zu, {
      isDragging: !0
    }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const t = this.getCenter(e), i = this.controllerState.pan({
      pos: t
    });
    return this.updateViewport(i, Zu, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragPan && t && e.velocity) {
      const i = this.getCenter(e), n = [i[0] + e.velocityX * t / 2, i[1] + e.velocityY * t / 2], s = this.controllerState.pan({
        pos: n
      }).panEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: o_
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const i = this.controllerState.panEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const t = this.getCenter(e), i = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(i, Zu, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragRotate && t && e.velocity) {
      const i = this.getCenter(e), n = [i[0] + e.velocityX * t / 2, i[1] + e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: n
      }).rotateEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: o_
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const i = this.controllerState.rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    e.srcEvent.preventDefault();
    const {
      speed: i = 0.01,
      smooth: n = !1
    } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
      delta: s
    } = e;
    let c = 2 / (1 + Math.exp(-Math.abs(s * i)));
    s < 0 && c !== 0 && (c = 1 / c);
    const o = n ? {
      ...this._getTransitionProps({
        around: t
      }),
      transitionDuration: 250
    } : Zu, d = this.controllerState.zoom({
      pos: t,
      scale: c
    });
    return this.updateViewport(d, o, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onMultiPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.controllerState.rotateStart({
      pos: t
    });
    return this.updateViewport(i, Zu, {
      isDragging: !0
    }), !0;
  }
  _onMultiPan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const t = this.getCenter(e);
    t[0] -= e.deltaX;
    const i = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(i, Zu, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onMultiPanEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this;
    if (this.touchRotate && t && e.velocityY) {
      const i = this.getCenter(e), n = [i[0], i[1] += e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: n
      });
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: o_
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(t);
    } else {
      const i = this.controllerState.rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.controllerState.zoomStart({
      pos: t
    }).rotateStart({
      pos: t
    });
    return Tf._startPinchRotation = e.rotation, Tf._lastPinchEvent = e, this.updateViewport(i, Zu, {
      isDragging: !0
    }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let t = this.controllerState;
    if (this.touchZoom) {
      const {
        scale: i
      } = e, n = this.getCenter(e);
      t = t.zoom({
        pos: n,
        scale: i
      });
    }
    if (this.touchRotate) {
      const {
        rotation: i
      } = e;
      t = t.rotate({
        deltaAngleX: Tf._startPinchRotation - i
      });
    }
    return this.updateViewport(t, Zu, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), Tf._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this, {
      _lastPinchEvent: i
    } = Tf;
    if (this.touchZoom && t && i && e.scale !== i.scale) {
      const n = this.getCenter(e);
      let s = this.controllerState.rotateEnd();
      const c = Math.log2(e.scale), o = (c - Math.log2(i.scale)) / (e.deltaTime - i.deltaTime), d = Math.pow(2, c + o * t / 2);
      s = s.zoom({
        pos: n,
        scale: d
      }).zoomEnd(), this.updateViewport(s, {
        ...this._getTransitionProps({
          around: n
        }),
        transitionDuration: t,
        transitionEasing: o_
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(t);
    } else {
      const n = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return Tf._startPinchRotation = null, Tf._lastPinchEvent = null, !0;
  }
  // Default handler for the `dblclick` event.
  _onDoubleClick(e) {
    if (!this.doubleClickZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.isFunctionKeyPressed(e), n = this.controllerState.zoom({
      pos: t,
      scale: i ? 0.5 : 2
    });
    return this.updateViewport(n, this._getTransitionProps({
      around: t
    }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const t = this.isFunctionKeyPressed(e), {
      zoomSpeed: i,
      moveSpeed: n,
      rotateSpeedX: s,
      rotateSpeedY: c
    } = this.keyboard === !0 ? {} : this.keyboard, {
      controllerState: o
    } = this;
    let d;
    const m = {};
    switch (e.srcEvent.code) {
      case "Minus":
        d = t ? o.zoomOut(i).zoomOut(i) : o.zoomOut(i), m.isZooming = !0;
        break;
      case "Equal":
        d = t ? o.zoomIn(i).zoomIn(i) : o.zoomIn(i), m.isZooming = !0;
        break;
      case "ArrowLeft":
        t ? (d = o.rotateLeft(s), m.isRotating = !0) : (d = o.moveLeft(n), m.isPanning = !0);
        break;
      case "ArrowRight":
        t ? (d = o.rotateRight(s), m.isRotating = !0) : (d = o.moveRight(n), m.isPanning = !0);
        break;
      case "ArrowUp":
        t ? (d = o.rotateUp(c), m.isRotating = !0) : (d = o.moveUp(n), m.isPanning = !0);
        break;
      case "ArrowDown":
        t ? (d = o.rotateDown(c), m.isRotating = !0) : (d = o.moveDown(n), m.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(d, this._getTransitionProps(), m), !0;
  }
  _getTransitionProps(e) {
    const {
      transition: t
    } = this;
    return !t || !t.transitionInterpolator ? Zu : e ? {
      ...t,
      transitionInterpolator: new gx({
        ...e,
        ...t.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : t;
  }
}
class P7 {
  constructor(e, t) {
    this._viewportProps = this.applyConstraints(e), this._state = t;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const A3 = 5, M7 = 1.2;
class xP extends P7 {
  constructor(e) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: t,
      /** The height of the viewport */
      height: i,
      /** The latitude at the center of the viewport */
      latitude: n,
      /** The longitude at the center of the viewport */
      longitude: s,
      /** The tile zoom level of the map. */
      zoom: c,
      /** The bearing of the viewport in degrees */
      bearing: o = 0,
      /** The pitch of the viewport in degrees */
      pitch: d = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: m = 1.5,
      /** Viewport position */
      position: y = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: T = 20,
      minZoom: P = 0,
      maxPitch: I = 60,
      minPitch: D = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: k,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: $,
      /* Pointer position when rotation started */
      startRotatePos: G,
      /** Bearing when current perspective rotate operation started */
      startBearing: te,
      /** Pitch when current perspective rotate operation started */
      startPitch: Z,
      /** Zoom when current zoom operation started */
      startZoom: H,
      /** Normalize viewport props to fit map height into viewport */
      normalize: J = !0
    } = e;
    Ks(Number.isFinite(s)), Ks(Number.isFinite(n)), Ks(Number.isFinite(c)), super({
      width: t,
      height: i,
      latitude: n,
      longitude: s,
      zoom: c,
      bearing: o,
      pitch: d,
      altitude: m,
      maxZoom: T,
      minZoom: P,
      maxPitch: I,
      minPitch: D,
      normalize: J,
      position: y
    }, {
      startPanLngLat: k,
      startZoomLngLat: $,
      startRotatePos: G,
      startBearing: te,
      startPitch: Z,
      startZoom: H
    }), this.makeViewport = e.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({
    pos: e
  }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(e)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({
    pos: e,
    startPos: t
  }) {
    const i = this.getState().startPanLngLat || this._unproject(t);
    if (!i)
      return this;
    const s = this.makeViewport(this.getViewportProps()).panByPosition(i, e);
    return this._getUpdatedState(s);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({
    pos: e
  }) {
    return this._getUpdatedState({
      startRotatePos: e,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({
    pos: e,
    deltaAngleX: t = 0,
    deltaAngleY: i = 0
  }) {
    const {
      startRotatePos: n,
      startBearing: s,
      startPitch: c
    } = this.getState();
    if (!n || s === void 0 || c === void 0)
      return this;
    let o;
    return e ? o = this._getNewRotation(e, n, c, s) : o = {
      bearing: s + t,
      pitch: c + i
    }, this._getUpdatedState(o);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({
    pos: e
  }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(e),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({
    pos: e,
    startPos: t,
    scale: i
  }) {
    let {
      startZoom: n,
      startZoomLngLat: s
    } = this.getState();
    if (s || (n = this.getViewportProps().zoom, s = this._unproject(t) || this._unproject(e)), !s)
      return this;
    const {
      maxZoom: c,
      minZoom: o
    } = this.getViewportProps();
    let d = n + Math.log2(i);
    d = vc(d, o, c);
    const m = this.makeViewport({
      ...this.getViewportProps(),
      zoom: d
    });
    return this._getUpdatedState({
      zoom: d,
      ...m.panByPosition(s, e)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(e = 2) {
    return this._zoomFromCenter(e);
  }
  zoomOut(e = 2) {
    return this._zoomFromCenter(1 / e);
  }
  moveLeft(e = 100) {
    return this._panFromCenter([e, 0]);
  }
  moveRight(e = 100) {
    return this._panFromCenter([-e, 0]);
  }
  moveUp(e = 100) {
    return this._panFromCenter([0, e]);
  }
  moveDown(e = 100) {
    return this._panFromCenter([0, -e]);
  }
  rotateLeft(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const t = e.getViewportProps(), i = {
      ...this.getViewportProps()
    }, {
      bearing: n,
      longitude: s
    } = i;
    return Math.abs(n - t.bearing) > 180 && (i.bearing = n < 0 ? n + 360 : n - 360), Math.abs(s - t.longitude) > 180 && (i.longitude = s < 0 ? s + 360 : s - 360), i;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: i,
      zoom: n
    } = e;
    e.zoom = vc(n, i, t);
    const {
      maxPitch: s,
      minPitch: c,
      pitch: o
    } = e;
    e.pitch = vc(o, c, s);
    const {
      normalize: d = !0
    } = e;
    return d && Object.assign(e, QU(e)), e;
  }
  /* Private methods */
  _zoomFromCenter(e) {
    const {
      width: t,
      height: i
    } = this.getViewportProps();
    return this.zoom({
      pos: [t / 2, i / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const {
      width: t,
      height: i
    } = this.getViewportProps();
    return this.pan({
      startPos: [t / 2, i / 2],
      pos: [t / 2 + e[0], i / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const t = this.makeViewport(this.getViewportProps());
    return e && t.unproject(e);
  }
  _getNewRotation(e, t, i, n) {
    const s = e[0] - t[0], c = e[1] - t[1], o = e[1], d = t[1], {
      width: m,
      height: y
    } = this.getViewportProps(), T = s / m;
    let P = 0;
    c > 0 ? Math.abs(y - d) > A3 && (P = c / (d - y) * M7) : c < 0 && d > A3 && (P = 1 - o / d), P = vc(P, -1, 1);
    const {
      minPitch: I,
      maxPitch: D
    } = this.getViewportProps(), k = n + 180 * T;
    let $ = i;
    return P > 0 ? $ = i + P * (D - i) : P < 0 && ($ = i - P * (I - i)), {
      pitch: $,
      bearing: k
    };
  }
}
class R7 extends vP {
  constructor() {
    super(...arguments), this.ControllerState = xP, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new gx({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const t = this.props;
    super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class mx extends bP {
  constructor(e = {}) {
    super(e);
  }
  getViewportType() {
    return ed;
  }
  get ControllerType() {
    return R7;
  }
}
mx.displayName = "MapView";
const L7 = new hx();
function B7(r, e) {
  const t = r.order ?? 1 / 0, i = e.order ?? 1 / 0;
  return t - i;
}
class k7 {
  constructor(e) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(e) {
    const t = this._defaultEffects;
    if (!t.find((i) => i.id === e.id)) {
      const i = t.findIndex((n) => B7(n, e) > 0);
      i < 0 ? t.push(e) : t.splice(i, 0, e), e.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (Rl(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw(e = {
    clearRedrawFlags: !1
  }) {
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const t = {};
    for (const n of this.effects)
      t[n.id] = n;
    const i = [];
    for (const n of e) {
      const s = t[n.id];
      let c = n;
      s && s !== n ? s.setProps ? (s.setProps(n.props), c = s) : s.cleanup(this._context) : s || n.setup(this._context), i.push(c), delete t[n.id];
    }
    for (const n in t)
      t[n].cleanup(this._context);
    this.effects = i, this._resolvedEffects = i.concat(this._defaultEffects), e.some((n) => n instanceof hx) || this._resolvedEffects.push(L7), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class O7 extends ux {
  shouldDrawLayer(e) {
    const {
      operation: t
    } = e.props;
    return t.includes("draw") || t.includes("terrain");
  }
}
const D7 = "deckRenderer.renderLayers";
class N7 {
  constructor(e) {
    this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new O7(e), this.pickLayersPass = new _P(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, i = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e
    };
    i.effects && this._preRender(i.effects, i);
    const n = this.lastPostProcessEffect ? this.renderBuffers[0] : i.target;
    this.lastPostProcessEffect && (i.clearColor = [0, 0, 0, 0], i.clearCanvas = !0);
    const s = t.render({
      ...i,
      target: n
    });
    i.effects && (this.lastPostProcessEffect && (i.clearCanvas = e.clearCanvas === void 0 ? !0 : e.clearCanvas), this._postRender(i.effects, i)), this.renderCount++, Vo(D7, this, s, e);
  }
  needsRedraw(e = {
    clearRedrawFlags: !1
  }) {
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  finalize() {
    const {
      renderBuffers: e
    } = this;
    for (const t of e)
      t.delete();
    e.length = 0;
  }
  _preRender(e, t) {
    this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
    for (const i of e)
      t.preRenderStats[i.id] = i.preRender(t), i.postRender && (this.lastPostProcessEffect = i.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers: e
    } = this, t = this.device.canvasContext.getDrawingBufferSize(), [i, n] = t;
    e.length === 0 && [0, 1].map((s) => {
      const c = this.device.createTexture({
        sampler: {
          minFilter: "linear",
          magFilter: "linear"
        },
        width: i,
        height: n
      });
      e.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${s}`,
        colorAttachments: [c]
      }));
    });
    for (const s of e)
      s.resize(t);
  }
  _postRender(e, t) {
    const {
      renderBuffers: i
    } = this, n = {
      ...t,
      inputBuffer: i[0],
      swapBuffer: i[1]
    };
    for (const s of e)
      if (s.postRender) {
        n.target = s.id === this.lastPostProcessEffect ? t.target : void 0;
        const c = s.postRender(n);
        n.inputBuffer = c, n.swapBuffer = c === i[0] ? i[1] : i[0];
      }
  }
}
const F7 = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function T3({
  pickedColors: r,
  decodePickingColor: e,
  deviceX: t,
  deviceY: i,
  deviceRadius: n,
  deviceRect: s
}) {
  const {
    x: c,
    y: o,
    width: d,
    height: m
  } = s;
  let y = n * n, T = -1, P = 0;
  for (let I = 0; I < m; I++) {
    const D = I + o - i, k = D * D;
    if (k > y)
      P += 4 * d;
    else
      for (let $ = 0; $ < d; $++) {
        if (r[P + 3] - 1 >= 0) {
          const te = $ + c - t, Z = te * te + k;
          Z <= y && (y = Z, T = P);
        }
        P += 4;
      }
  }
  if (T >= 0) {
    const I = r.slice(T, T + 4), D = e(I);
    if (D) {
      const k = Math.floor(T / 4 / d), $ = T / 4 - k * d;
      return {
        ...D,
        pickedColor: I,
        pickedX: c + $,
        pickedY: o + k
      };
    }
    Ni.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return F7;
}
function S3({
  pickedColors: r,
  decodePickingColor: e
}) {
  const t = /* @__PURE__ */ new Map();
  if (r) {
    for (let i = 0; i < r.length; i += 4)
      if (r[i + 3] - 1 >= 0) {
        const s = r.slice(i, i + 4), c = s.join(",");
        if (!t.has(c)) {
          const o = e(s);
          o ? t.set(c, {
            ...o,
            color: s
          }) : Ni.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(t.values());
}
function Iv({
  pickInfo: r,
  viewports: e,
  pixelRatio: t,
  x: i,
  y: n,
  z: s
}) {
  let c = e[0];
  e.length > 1 && (c = U7(r?.pickedViewports || e, {
    x: i,
    y: n
  }));
  let o;
  if (c) {
    const d = [i - c.x, n - c.y];
    s !== void 0 && (d[2] = s), o = c.unproject(d);
  }
  return {
    color: null,
    layer: null,
    viewport: c,
    index: -1,
    picked: !1,
    x: i,
    y: n,
    pixel: [i, n],
    coordinate: o,
    devicePixel: r && "pickedX" in r ? [r.pickedX, r.pickedY] : void 0,
    pixelRatio: t
  };
}
function E3(r) {
  const {
    pickInfo: e,
    lastPickedInfo: t,
    mode: i,
    layers: n
  } = r, {
    pickedColor: s,
    pickedLayer: c,
    pickedObjectIndex: o
  } = e, d = c ? [c] : [];
  if (i === "hover") {
    const T = t.index, P = t.layerId, I = c ? c.props.id : null;
    if (I !== P || o !== T) {
      if (I !== P) {
        const D = n.find((k) => k.props.id === P);
        D && d.unshift(D);
      }
      t.layerId = I, t.index = o, t.info = null;
    }
  }
  const m = Iv(r), y = /* @__PURE__ */ new Map();
  return y.set(null, m), d.forEach((T) => {
    let P = {
      ...m
    };
    T === c && (P.color = s, P.index = o, P.picked = !0), P = Pv({
      layer: T,
      info: P,
      mode: i
    });
    const I = P.layer;
    T === c && i === "hover" && (t.info = P), y.set(I.id, P), i === "hover" && I.updateAutoHighlight(P);
  }), y;
}
function Pv({
  layer: r,
  info: e,
  mode: t
}) {
  for (; r && e; ) {
    const i = e.layer || null;
    e.sourceLayer = i, e.layer = r, e = r.getPickingInfo({
      info: e,
      mode: t,
      sourceLayer: i
    }), r = r.parent;
  }
  return e;
}
function U7(r, e) {
  for (let t = r.length - 1; t >= 0; t--) {
    const i = r[t];
    if (i.containsPixel(e))
      return i;
  }
  return r[0];
}
class z7 {
  constructor(e) {
    this._pickable = !0, this.device = e, this.pickLayersPass = new _P(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /**
   * Pick the closest info at given coordinate
   * @returns Promise that resolves with picking info
   */
  pickObjectAsync(e) {
    return this._pickClosestObjectAsync(e);
  }
  /**
   * Picks a list of unique infos within a bounding box
   * @returns Promise that resolves to all unique infos within a bounding box
   */
  pickObjectsAsync(e) {
    return this._pickVisibleObjectsAsync(e);
  }
  /**
   * Pick the closest info at given coordinate
   * @returns picking info
   * @deprecated WebGL only - use pickObjectAsync instead
   */
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  /**
   * Get all unique infos within a bounding box
   * @returns all unique infos within a bounding box
   * @deprecated WebGL only - use pickObjectAsync instead
   */
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({
    x: e,
    y: t,
    layers: i,
    viewports: n
  }, s = this.lastPickedInfo.info) {
    const c = s && s.layer && s.layer.id, o = s && s.viewport && s.viewport.id, d = c ? i.find((P) => P.id === c) : null, m = o && n.find((P) => P.id === o) || n[0], y = m && m.unproject([e - m.x, t - m.y]);
    return {
      ...s,
      ...{
        x: e,
        y: t,
        viewport: m,
        coordinate: y,
        layer: d
      }
    };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const t = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = t;
    }
    const {
      canvas: e
    } = this.device.getDefaultCanvasContext();
    this.pickingFBO?.resize({
      width: e.width,
      height: e.height
    }), this.depthFBO?.resize({
      width: e.width,
      height: e.height
    });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const t = e.filter((i) => this.pickLayersPass.shouldDrawLayer(i) && !i.isComposite);
    return t.length ? t : null;
  }
  /**
   * Pick the closest object at the given coordinate
   */
  // eslint-disable-next-line max-statements,complexity
  async _pickClosestObjectAsync({
    layers: e,
    views: t,
    viewports: i,
    x: n,
    y: s,
    radius: c = 0,
    depth: o = 1,
    mode: d = "query",
    unproject3D: m,
    onViewportActive: y,
    effects: T
  }) {
    const P = this.device.canvasContext.cssToDeviceRatio(), I = this._getPickable(e);
    if (!I || i.length === 0)
      return {
        result: [],
        emptyInfo: Iv({
          viewports: i,
          x: n,
          y: s,
          pixelRatio: P
        })
      };
    this._resizeBuffer();
    const D = this.device.canvasContext.cssToDevicePixels([n, s], !0), k = [D.x + Math.floor(D.width / 2), D.y + Math.floor(D.height / 2)], $ = Math.round(c * P), {
      width: G,
      height: te
    } = this.pickingFBO, Z = this._getPickingRect({
      deviceX: k[0],
      deviceY: k[1],
      deviceRadius: $,
      deviceWidth: G,
      deviceHeight: te
    }), H = {
      x: n - c,
      y: s - c,
      width: c * 2 + 1,
      height: c * 2 + 1
    };
    let J;
    const re = [], be = /* @__PURE__ */ new Set();
    for (let pe = 0; pe < o; pe++) {
      let oe;
      if (Z) {
        const le = this._drawAndSample({
          layers: I,
          views: t,
          viewports: i,
          onViewportActive: y,
          deviceRect: Z,
          cullRect: H,
          effects: T,
          pass: `picking:${d}`
        });
        oe = T3({
          ...le,
          deviceX: k[0],
          deviceY: k[1],
          deviceRadius: $,
          deviceRect: Z
        });
      } else
        oe = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let Ee;
      if (oe.pickedLayer && m && this.depthFBO) {
        const {
          pickedColors: le
        } = this._drawAndSample({
          layers: [oe.pickedLayer],
          views: t,
          viewports: i,
          onViewportActive: y,
          deviceRect: {
            x: oe.pickedX,
            y: oe.pickedY,
            width: 1,
            height: 1
          },
          cullRect: H,
          effects: T,
          pass: `picking:${d}:z`
        }, !0);
        le[3] && (Ee = le[0]);
      }
      oe.pickedLayer && pe + 1 < o && (be.add(oe.pickedLayer), oe.pickedLayer.disablePickingIndex(oe.pickedObjectIndex)), J = E3({
        pickInfo: oe,
        lastPickedInfo: this.lastPickedInfo,
        mode: d,
        layers: I,
        viewports: i,
        x: n,
        y: s,
        z: Ee,
        pixelRatio: P
      });
      for (const le of J.values())
        le.layer && re.push(le);
      if (!oe.pickedColor)
        break;
    }
    for (const pe of be)
      pe.restorePickingColors();
    return {
      result: re,
      emptyInfo: J.get(null)
    };
  }
  /**
   * Pick the closest object at the given coordinate
   * @deprecated WebGL only
   */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({
    layers: e,
    views: t,
    viewports: i,
    x: n,
    y: s,
    radius: c = 0,
    depth: o = 1,
    mode: d = "query",
    unproject3D: m,
    onViewportActive: y,
    effects: T
  }) {
    const P = this.device.canvasContext.cssToDeviceRatio(), I = this._getPickable(e);
    if (!I || i.length === 0)
      return {
        result: [],
        emptyInfo: Iv({
          viewports: i,
          x: n,
          y: s,
          pixelRatio: P
        })
      };
    this._resizeBuffer();
    const D = this.device.canvasContext.cssToDevicePixels([n, s], !0), k = [D.x + Math.floor(D.width / 2), D.y + Math.floor(D.height / 2)], $ = Math.round(c * P), {
      width: G,
      height: te
    } = this.pickingFBO, Z = this._getPickingRect({
      deviceX: k[0],
      deviceY: k[1],
      deviceRadius: $,
      deviceWidth: G,
      deviceHeight: te
    }), H = {
      x: n - c,
      y: s - c,
      width: c * 2 + 1,
      height: c * 2 + 1
    };
    let J;
    const re = [], be = /* @__PURE__ */ new Set();
    for (let pe = 0; pe < o; pe++) {
      let oe;
      if (Z) {
        const le = this._drawAndSample({
          layers: I,
          views: t,
          viewports: i,
          onViewportActive: y,
          deviceRect: Z,
          cullRect: H,
          effects: T,
          pass: `picking:${d}`
        });
        oe = T3({
          ...le,
          deviceX: k[0],
          deviceY: k[1],
          deviceRadius: $,
          deviceRect: Z
        });
      } else
        oe = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let Ee;
      if (oe.pickedLayer && m && this.depthFBO) {
        const {
          pickedColors: le
        } = this._drawAndSample({
          layers: [oe.pickedLayer],
          views: t,
          viewports: i,
          onViewportActive: y,
          deviceRect: {
            x: oe.pickedX,
            y: oe.pickedY,
            width: 1,
            height: 1
          },
          cullRect: H,
          effects: T,
          pass: `picking:${d}:z`
        }, !0);
        le[3] && (Ee = le[0]);
      }
      oe.pickedLayer && pe + 1 < o && (be.add(oe.pickedLayer), oe.pickedLayer.disablePickingIndex(oe.pickedObjectIndex)), J = E3({
        pickInfo: oe,
        lastPickedInfo: this.lastPickedInfo,
        mode: d,
        layers: I,
        viewports: i,
        x: n,
        y: s,
        z: Ee,
        pixelRatio: P
      });
      for (const le of J.values())
        le.layer && re.push(le);
      if (!oe.pickedColor)
        break;
    }
    for (const pe of be)
      pe.restorePickingColors();
    return {
      result: re,
      emptyInfo: J.get(null)
    };
  }
  /**
   * Pick all objects within the given bounding box
   */
  // eslint-disable-next-line max-statements
  async _pickVisibleObjectsAsync({
    layers: e,
    views: t,
    viewports: i,
    x: n,
    y: s,
    width: c = 1,
    height: o = 1,
    mode: d = "query",
    maxObjects: m = null,
    onViewportActive: y,
    effects: T
  }) {
    const P = this._getPickable(e);
    if (!P || i.length === 0)
      return [];
    this._resizeBuffer();
    const I = this.device.canvasContext.cssToDeviceRatio(), D = this.device.canvasContext.cssToDevicePixels([n, s], !0), k = D.x, $ = D.y + D.height, G = this.device.canvasContext.cssToDevicePixels([n + c, s + o], !0), te = G.x + G.width, Z = G.y, H = {
      x: k,
      y: Z,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: te - k,
      height: $ - Z
    }, J = this._drawAndSample({
      layers: P,
      views: t,
      viewports: i,
      onViewportActive: y,
      deviceRect: H,
      cullRect: {
        x: n,
        y: s,
        width: c,
        height: o
      },
      effects: T,
      pass: `picking:${d}`
    }), re = S3(J), be = /* @__PURE__ */ new Map(), pe = [], oe = Number.isFinite(m);
    for (let Ee = 0; Ee < re.length && !(oe && pe.length >= m); Ee++) {
      const le = re[Ee];
      let _e = {
        color: le.pickedColor,
        layer: null,
        index: le.pickedObjectIndex,
        picked: !0,
        x: n,
        y: s,
        pixelRatio: I
      };
      _e = Pv({
        layer: le.pickedLayer,
        info: _e,
        mode: d
      });
      const Ve = _e.layer.id;
      be.has(Ve) || be.set(Ve, /* @__PURE__ */ new Set());
      const Be = be.get(Ve), gt = _e.object ?? _e.index;
      Be.has(gt) || (Be.add(gt), pe.push(_e));
    }
    return pe;
  }
  /**
   * Pick all objects within the given bounding box
   * @deprecated WebGL only
   */
  // eslint-disable-next-line max-statements
  _pickVisibleObjects({
    layers: e,
    views: t,
    viewports: i,
    x: n,
    y: s,
    width: c = 1,
    height: o = 1,
    mode: d = "query",
    maxObjects: m = null,
    onViewportActive: y,
    effects: T
  }) {
    const P = this._getPickable(e);
    if (!P || i.length === 0)
      return [];
    this._resizeBuffer();
    const I = this.device.canvasContext.cssToDeviceRatio(), D = this.device.canvasContext.cssToDevicePixels([n, s], !0), k = D.x, $ = D.y + D.height, G = this.device.canvasContext.cssToDevicePixels([n + c, s + o], !0), te = G.x + G.width, Z = G.y, H = {
      x: k,
      y: Z,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: te - k,
      height: $ - Z
    }, J = this._drawAndSample({
      layers: P,
      views: t,
      viewports: i,
      onViewportActive: y,
      deviceRect: H,
      cullRect: {
        x: n,
        y: s,
        width: c,
        height: o
      },
      effects: T,
      pass: `picking:${d}`
    }), re = S3(J), be = /* @__PURE__ */ new Map(), pe = [], oe = Number.isFinite(m);
    for (let Ee = 0; Ee < re.length && !(oe && pe.length >= m); Ee++) {
      const le = re[Ee];
      let _e = {
        color: le.pickedColor,
        layer: null,
        index: le.pickedObjectIndex,
        picked: !0,
        x: n,
        y: s,
        pixelRatio: I
      };
      _e = Pv({
        layer: le.pickedLayer,
        info: _e,
        mode: d
      });
      const Ve = _e.layer.id;
      be.has(Ve) || be.set(Ve, /* @__PURE__ */ new Set());
      const Be = be.get(Ve), gt = _e.object ?? _e.index;
      Be.has(gt) || (Be.add(gt), pe.push(_e));
    }
    return pe;
  }
  // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures
  async _drawAndSampleAsync({
    layers: e,
    views: t,
    viewports: i,
    onViewportActive: n,
    deviceRect: s,
    cullRect: c,
    effects: o,
    pass: d
  }, m = !1) {
    const y = m ? this.depthFBO : this.pickingFBO, T = {
      layers: e,
      layerFilter: this.layerFilter,
      views: t,
      viewports: i,
      onViewportActive: n,
      pickingFBO: y,
      deviceRect: s,
      cullRect: c,
      effects: o,
      pass: d,
      pickZ: m,
      preRenderStats: {},
      isPicking: !0
    };
    for (const te of o)
      te.useInPicking && (T.preRenderStats[te.id] = te.preRender(T));
    const {
      decodePickingColor: P
    } = this.pickLayersPass.render(T), {
      x: I,
      y: D,
      width: k,
      height: $
    } = s, G = new (m ? Float32Array : Uint8Array)(k * $ * 4);
    return this.device.readPixelsToArrayWebGL(y, {
      sourceX: I,
      sourceY: D,
      sourceWidth: k,
      sourceHeight: $,
      target: G
    }), {
      pickedColors: G,
      decodePickingColor: P
    };
  }
  // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures
  _drawAndSample({
    layers: e,
    views: t,
    viewports: i,
    onViewportActive: n,
    deviceRect: s,
    cullRect: c,
    effects: o,
    pass: d
  }, m = !1) {
    const y = m ? this.depthFBO : this.pickingFBO, T = {
      layers: e,
      layerFilter: this.layerFilter,
      views: t,
      viewports: i,
      onViewportActive: n,
      pickingFBO: y,
      deviceRect: s,
      cullRect: c,
      effects: o,
      pass: d,
      pickZ: m,
      preRenderStats: {},
      isPicking: !0
    };
    for (const te of o)
      te.useInPicking && (T.preRenderStats[te.id] = te.preRender(T));
    const {
      decodePickingColor: P
    } = this.pickLayersPass.render(T), {
      x: I,
      y: D,
      width: k,
      height: $
    } = s, G = new (m ? Float32Array : Uint8Array)(k * $ * 4);
    return this.device.readPixelsToArrayWebGL(y, {
      sourceX: I,
      sourceY: D,
      sourceWidth: k,
      sourceHeight: $,
      target: G
    }), {
      pickedColors: G,
      decodePickingColor: P
    };
  }
  /**
   * Calculate a picking rect centered on deviceX and deviceY and clipped to device
   * @returns null if pixel is outside of device
   */
  _getPickingRect({
    deviceX: e,
    deviceY: t,
    deviceRadius: i,
    deviceWidth: n,
    deviceHeight: s
  }) {
    const c = Math.max(0, e - i), o = Math.max(0, t - i), d = Math.min(n, e + i + 1) - c, m = Math.min(s, t + i + 1) - o;
    return d <= 0 || m <= 0 ? null : {
      x: c,
      y: o,
      width: d,
      height: m
    };
  }
}
const j7 = {
  "top-left": {
    top: 0,
    left: 0
  },
  "top-right": {
    top: 0,
    right: 0
  },
  "bottom-left": {
    bottom: 0,
    left: 0
  },
  "bottom-right": {
    bottom: 0,
    right: 0
  },
  fill: {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
  }
}, V7 = "top-left", C3 = "__root";
class G7 {
  constructor({
    deck: e,
    parentElement: t
  }) {
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, t?.classList.add("deck-widget-container"), this.parentElement = t;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(e) {
    if (e.widgets && !Rl(e.widgets, this.widgets, 1)) {
      const t = e.widgets.filter(Boolean);
      this._setWidgets(t);
    }
  }
  finalize() {
    for (const e of this.getWidgets())
      this._removeWidget(e);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const e in this.containers)
      this.containers[e].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(e) {
    this.defaultWidgets.find((t) => t.id === e.id) || (this._addWidget(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
  }
  onRedraw({
    viewports: e,
    layers: t
  }) {
    const i = e.reduce((n, s) => (n[s.id] = s, n), {});
    for (const n of this.getWidgets()) {
      const {
        viewId: s
      } = n;
      if (s) {
        const c = i[s];
        c && (n.onViewportChange && n.onViewportChange(c), n.onRedraw?.({
          viewports: [c],
          layers: t
        }));
      } else {
        if (n.onViewportChange)
          for (const c of e)
            n.onViewportChange(c);
        n.onRedraw?.({
          viewports: e,
          layers: t
        });
      }
    }
    this.lastViewports = i, this._updateContainers();
  }
  onHover(e, t) {
    for (const i of this.getWidgets()) {
      const {
        viewId: n
      } = i;
      (!n || n === e.viewport?.id) && i.onHover?.(e, t);
    }
  }
  onEvent(e, t) {
    const i = xv[t.type];
    if (i)
      for (const n of this.getWidgets()) {
        const {
          viewId: s
        } = n;
        (!s || s === e.viewport?.id) && n[i]?.(e, t);
      }
  }
  // INTERNAL METHODS
  /**
   * Resolve widgets from the declarative prop
   * Initialize new widgets and remove old ones
   * Update props of existing widgets
   */
  _setWidgets(e) {
    const t = {};
    for (const i of this.resolvedWidgets)
      t[i.id] = i;
    this.resolvedWidgets.length = 0;
    for (const i of this.defaultWidgets)
      t[i.id] = null, this.resolvedWidgets.push(i);
    for (let i of e) {
      const n = t[i.id];
      n ? /* Widget placement changed */ n.viewId !== i.viewId || n.placement !== i.placement ? (this._removeWidget(n), this._addWidget(i)) : i !== n && (n.setProps(i.props), i = n) : this._addWidget(i), t[i.id] = null, this.resolvedWidgets.push(i);
    }
    for (const i in t) {
      const n = t[i];
      n && this._removeWidget(n);
    }
    this.widgets = e;
  }
  /** Initialize new widget */
  _addWidget(e) {
    const {
      viewId: t = null,
      placement: i = V7
    } = e;
    e.widgetManager = this, e.deck = this.deck, e.rootElement = e._onAdd({
      deck: this.deck,
      viewId: t
    }), e.rootElement && this._getContainer(t, i).append(e.rootElement), e.updateHTML();
  }
  /** Destroy an old widget */
  _removeWidget(e) {
    e.onRemove?.(), e.rootElement && e.rootElement.remove(), e.rootElement = void 0, e.deck = void 0, e.widgetManager = void 0;
  }
  /** Get a container element based on view and placement */
  _getContainer(e, t) {
    const i = e || C3;
    let n = this.containers[i];
    n || (n = document.createElement("div"), n.style.pointerEvents = "none", n.style.position = "absolute", n.style.overflow = "hidden", this.parentElement?.append(n), this.containers[i] = n);
    let s = n.querySelector(`.${t}`);
    return s || (s = globalThis.document.createElement("div"), s.className = t, s.style.position = "absolute", s.style.zIndex = "2", Object.assign(s.style, j7[t]), n.append(s)), s;
  }
  _updateContainers() {
    const e = this.deck.width, t = this.deck.height;
    for (const i in this.containers) {
      const n = this.lastViewports[i] || null, s = i === C3 || n, c = this.containers[i];
      s ? (c.style.display = "block", c.style.left = `${n ? n.x : 0}px`, c.style.top = `${n ? n.y : 0}px`, c.style.width = `${n ? n.width : e}px`, c.style.height = `${n ? n.height : t}px`) : c.style.display = "none";
    }
  }
}
function I3(r, e) {
  e && Object.entries(e).map(([t, i]) => {
    t.startsWith("--") ? r.style.setProperty(t, i) : r.style[t] = i;
  });
}
function $7(r, e) {
  e && Object.keys(e).map((t) => {
    t.startsWith("--") ? r.style.removeProperty(t) : r.style[t] = "";
  });
}
class _x {
  constructor(e) {
    this.viewId = null, this.props = {
      // @ts-expect-error `defaultProps` may not exist on constructor
      ...this.constructor.defaultProps,
      ...e
    }, this.id = this.props.id;
  }
  /** Called to update widget options */
  setProps(e) {
    const t = this.props, i = this.rootElement;
    i && t.className !== e.className && (t.className && i.classList.remove(t.className), e.className && i.classList.add(e.className)), i && !Rl(t.style, e.style, 1) && ($7(i, t.style), I3(i, e.style)), Object.assign(this.props, e), this.updateHTML();
  }
  /** Update the HTML to reflect latest props and state */
  updateHTML() {
    this.rootElement && this.onRenderHTML(this.rootElement);
  }
  // @note empty method calls have an overhead in V8 but it is very low, ~1ns
  /**
   * Common utility to create the root DOM element for this widget
   * Configures the top-level styles and adds basic class names for theming
   * @returns an UI element that should be appended to the Deck container
   */
  onCreateRootElement() {
    const e = [
      // Add class names for theming
      "deck-widget",
      this.className,
      // plus any app-supplied class name
      this.props.className
    ], t = document.createElement("div");
    return e.filter((i) => typeof i == "string" && i.length > 0).forEach((i) => t.classList.add(i)), I3(t, this.props.style), t;
  }
  /** Internal API called by Deck when the widget is first added to a Deck instance */
  _onAdd(e) {
    return this.onAdd(e) ?? this.onCreateRootElement();
  }
  /** Overridable by subclass - called when the widget is first added to a Deck instance
   * @returns an optional UI element that should be appended to the Deck container
   */
  onAdd(e) {
  }
  /** Called when the widget is removed */
  onRemove() {
  }
  // deck integration - Event hooks
  /** Called when the containing view is changed */
  onViewportChange(e) {
  }
  /** Called when the containing view is redrawn */
  onRedraw(e) {
  }
  /** Called when a hover event occurs */
  onHover(e, t) {
  }
  /** Called when a click event occurs */
  onClick(e, t) {
  }
  /** Called when a drag event occurs */
  onDrag(e, t) {
  }
  /** Called when a dragstart event occurs */
  onDragStart(e, t) {
  }
  /** Called when a dragend event occurs */
  onDragEnd(e, t) {
  }
}
_x.defaultProps = {
  id: "widget",
  style: {},
  className: ""
};
const H7 = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class wP extends _x {
  constructor(e = {}) {
    super(e), this.id = "default-tooltip", this.placement = "fill", this.className = "deck-tooltip", this.isVisible = !1, this.setProps(e);
  }
  // TODO(ib) - does this really need to be overridden?
  onCreateRootElement() {
    const e = document.createElement("div");
    return e.className = this.className, Object.assign(e.style, H7), e;
  }
  onRenderHTML(e) {
  }
  onViewportChange(e) {
    this.isVisible && e.id === this.lastViewport?.id && e !== this.lastViewport && this.setTooltip(null);
  }
  onHover(e) {
    const {
      deck: t
    } = this, i = t && t.props.getTooltip;
    if (!i)
      return;
    const n = i(e);
    this.lastViewport = e.viewport, this.setTooltip(n, e.x, e.y);
  }
  setTooltip(e, t, i) {
    const n = this.rootElement;
    if (n) {
      if (typeof e == "string")
        n.innerText = e;
      else if (e)
        e.text && (n.innerText = e.text), e.html && (n.innerHTML = e.html), e.className && (n.className = e.className);
      else {
        this.isVisible = !1, n.style.display = "none";
        return;
      }
      this.isVisible = !0, n.style.display = "block", n.style.transform = `translate(${t}px, ${i}px)`, e && typeof e == "object" && "style" in e && Object.assign(n.style, e.style);
    }
  }
}
wP.defaultProps = {
  ..._x.defaultProps
};
var tp;
(function(r) {
  r[r.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", r[r.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", r[r.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", r[r.ZERO = 0] = "ZERO", r[r.ONE = 1] = "ONE", r[r.SRC_COLOR = 768] = "SRC_COLOR", r[r.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", r[r.SRC_ALPHA = 770] = "SRC_ALPHA", r[r.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", r[r.DST_ALPHA = 772] = "DST_ALPHA", r[r.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", r[r.DST_COLOR = 774] = "DST_COLOR", r[r.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", r[r.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", r[r.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", r[r.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", r[r.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", r[r.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", r[r.FUNC_ADD = 32774] = "FUNC_ADD", r[r.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", r[r.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", r[r.BLEND_EQUATION = 32777] = "BLEND_EQUATION", r[r.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", r[r.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", r[r.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", r[r.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", r[r.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", r[r.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", r[r.BLEND_COLOR = 32773] = "BLEND_COLOR", r[r.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", r[r.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", r[r.LINE_WIDTH = 2849] = "LINE_WIDTH", r[r.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", r[r.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", r[r.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", r[r.FRONT_FACE = 2886] = "FRONT_FACE", r[r.DEPTH_RANGE = 2928] = "DEPTH_RANGE", r[r.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", r[r.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", r[r.DEPTH_FUNC = 2932] = "DEPTH_FUNC", r[r.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", r[r.STENCIL_FUNC = 2962] = "STENCIL_FUNC", r[r.STENCIL_FAIL = 2964] = "STENCIL_FAIL", r[r.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", r[r.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", r[r.STENCIL_REF = 2967] = "STENCIL_REF", r[r.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", r[r.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", r[r.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", r[r.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", r[r.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", r[r.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", r[r.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", r[r.VIEWPORT = 2978] = "VIEWPORT", r[r.SCISSOR_BOX = 3088] = "SCISSOR_BOX", r[r.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", r[r.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", r[r.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", r[r.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", r[r.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", r[r.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", r[r.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", r[r.RED_BITS = 3410] = "RED_BITS", r[r.GREEN_BITS = 3411] = "GREEN_BITS", r[r.BLUE_BITS = 3412] = "BLUE_BITS", r[r.ALPHA_BITS = 3413] = "ALPHA_BITS", r[r.DEPTH_BITS = 3414] = "DEPTH_BITS", r[r.STENCIL_BITS = 3415] = "STENCIL_BITS", r[r.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", r[r.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", r[r.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", r[r.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", r[r.SAMPLES = 32937] = "SAMPLES", r[r.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", r[r.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", r[r.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", r[r.VENDOR = 7936] = "VENDOR", r[r.RENDERER = 7937] = "RENDERER", r[r.VERSION = 7938] = "VERSION", r[r.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", r[r.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", r[r.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", r[r.STATIC_DRAW = 35044] = "STATIC_DRAW", r[r.STREAM_DRAW = 35040] = "STREAM_DRAW", r[r.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.BUFFER_SIZE = 34660] = "BUFFER_SIZE", r[r.BUFFER_USAGE = 34661] = "BUFFER_USAGE", r[r.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", r[r.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", r[r.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", r[r.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", r[r.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", r[r.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", r[r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", r[r.CULL_FACE = 2884] = "CULL_FACE", r[r.FRONT = 1028] = "FRONT", r[r.BACK = 1029] = "BACK", r[r.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", r[r.BLEND = 3042] = "BLEND", r[r.DEPTH_TEST = 2929] = "DEPTH_TEST", r[r.DITHER = 3024] = "DITHER", r[r.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", r[r.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", r[r.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", r[r.SCISSOR_TEST = 3089] = "SCISSOR_TEST", r[r.STENCIL_TEST = 2960] = "STENCIL_TEST", r[r.NO_ERROR = 0] = "NO_ERROR", r[r.INVALID_ENUM = 1280] = "INVALID_ENUM", r[r.INVALID_VALUE = 1281] = "INVALID_VALUE", r[r.INVALID_OPERATION = 1282] = "INVALID_OPERATION", r[r.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", r[r.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", r[r.CW = 2304] = "CW", r[r.CCW = 2305] = "CCW", r[r.DONT_CARE = 4352] = "DONT_CARE", r[r.FASTEST = 4353] = "FASTEST", r[r.NICEST = 4354] = "NICEST", r[r.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", r[r.BYTE = 5120] = "BYTE", r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.SHORT = 5122] = "SHORT", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.INT = 5124] = "INT", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.FLOAT = 5126] = "FLOAT", r[r.DOUBLE = 5130] = "DOUBLE", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.ALPHA = 6406] = "ALPHA", r[r.RGB = 6407] = "RGB", r[r.RGBA = 6408] = "RGBA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", r[r.VERTEX_SHADER = 35633] = "VERTEX_SHADER", r[r.COMPILE_STATUS = 35713] = "COMPILE_STATUS", r[r.DELETE_STATUS = 35712] = "DELETE_STATUS", r[r.LINK_STATUS = 35714] = "LINK_STATUS", r[r.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", r[r.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", r[r.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", r[r.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", r[r.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", r[r.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", r[r.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", r[r.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", r[r.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", r[r.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", r[r.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", r[r.SHADER_TYPE = 35663] = "SHADER_TYPE", r[r.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", r[r.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", r[r.NEVER = 512] = "NEVER", r[r.LESS = 513] = "LESS", r[r.EQUAL = 514] = "EQUAL", r[r.LEQUAL = 515] = "LEQUAL", r[r.GREATER = 516] = "GREATER", r[r.NOTEQUAL = 517] = "NOTEQUAL", r[r.GEQUAL = 518] = "GEQUAL", r[r.ALWAYS = 519] = "ALWAYS", r[r.KEEP = 7680] = "KEEP", r[r.REPLACE = 7681] = "REPLACE", r[r.INCR = 7682] = "INCR", r[r.DECR = 7683] = "DECR", r[r.INVERT = 5386] = "INVERT", r[r.INCR_WRAP = 34055] = "INCR_WRAP", r[r.DECR_WRAP = 34056] = "DECR_WRAP", r[r.NEAREST = 9728] = "NEAREST", r[r.LINEAR = 9729] = "LINEAR", r[r.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", r[r.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", r[r.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", r[r.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", r[r.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", r[r.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", r[r.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", r[r.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE = 5890] = "TEXTURE", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", r[r.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", r[r.TEXTURE0 = 33984] = "TEXTURE0", r[r.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", r[r.REPEAT = 10497] = "REPEAT", r[r.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", r[r.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", r[r.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", r[r.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", r[r.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", r[r.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", r[r.INT_VEC2 = 35667] = "INT_VEC2", r[r.INT_VEC3 = 35668] = "INT_VEC3", r[r.INT_VEC4 = 35669] = "INT_VEC4", r[r.BOOL = 35670] = "BOOL", r[r.BOOL_VEC2 = 35671] = "BOOL_VEC2", r[r.BOOL_VEC3 = 35672] = "BOOL_VEC3", r[r.BOOL_VEC4 = 35673] = "BOOL_VEC4", r[r.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", r[r.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", r[r.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", r[r.SAMPLER_2D = 35678] = "SAMPLER_2D", r[r.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", r[r.LOW_FLOAT = 36336] = "LOW_FLOAT", r[r.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", r[r.HIGH_FLOAT = 36338] = "HIGH_FLOAT", r[r.LOW_INT = 36339] = "LOW_INT", r[r.MEDIUM_INT = 36340] = "MEDIUM_INT", r[r.HIGH_INT = 36341] = "HIGH_INT", r[r.FRAMEBUFFER = 36160] = "FRAMEBUFFER", r[r.RENDERBUFFER = 36161] = "RENDERBUFFER", r[r.RGBA4 = 32854] = "RGBA4", r[r.RGB5_A1 = 32855] = "RGB5_A1", r[r.RGB565 = 36194] = "RGB565", r[r.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", r[r.STENCIL_INDEX = 6401] = "STENCIL_INDEX", r[r.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", r[r.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", r[r.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", r[r.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", r[r.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", r[r.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", r[r.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", r[r.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", r[r.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", r[r.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", r[r.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", r[r.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", r[r.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", r[r.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", r[r.NONE = 0] = "NONE", r[r.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", r[r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", r[r.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", r[r.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", r[r.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", r[r.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", r[r.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", r[r.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", r[r.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", r[r.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", r[r.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", r[r.READ_BUFFER = 3074] = "READ_BUFFER", r[r.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", r[r.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", r[r.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", r[r.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", r[r.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", r[r.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", r[r.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", r[r.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", r[r.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", r[r.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", r[r.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", r[r.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", r[r.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", r[r.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", r[r.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", r[r.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", r[r.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", r[r.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", r[r.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", r[r.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", r[r.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", r[r.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", r[r.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", r[r.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", r[r.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", r[r.RED = 6403] = "RED", r[r.RGB8 = 32849] = "RGB8", r[r.RGBA8 = 32856] = "RGBA8", r[r.RGB10_A2 = 32857] = "RGB10_A2", r[r.TEXTURE_3D = 32879] = "TEXTURE_3D", r[r.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", r[r.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", r[r.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", r[r.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", r[r.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", r[r.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", r[r.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", r[r.SRGB = 35904] = "SRGB", r[r.SRGB8 = 35905] = "SRGB8", r[r.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", r[r.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", r[r.RGBA32F = 34836] = "RGBA32F", r[r.RGB32F = 34837] = "RGB32F", r[r.RGBA16F = 34842] = "RGBA16F", r[r.RGB16F = 34843] = "RGB16F", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", r[r.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", r[r.RGB9_E5 = 35901] = "RGB9_E5", r[r.RGBA32UI = 36208] = "RGBA32UI", r[r.RGB32UI = 36209] = "RGB32UI", r[r.RGBA16UI = 36214] = "RGBA16UI", r[r.RGB16UI = 36215] = "RGB16UI", r[r.RGBA8UI = 36220] = "RGBA8UI", r[r.RGB8UI = 36221] = "RGB8UI", r[r.RGBA32I = 36226] = "RGBA32I", r[r.RGB32I = 36227] = "RGB32I", r[r.RGBA16I = 36232] = "RGBA16I", r[r.RGB16I = 36233] = "RGB16I", r[r.RGBA8I = 36238] = "RGBA8I", r[r.RGB8I = 36239] = "RGB8I", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.R8 = 33321] = "R8", r[r.RG8 = 33323] = "RG8", r[r.R16F = 33325] = "R16F", r[r.R32F = 33326] = "R32F", r[r.RG16F = 33327] = "RG16F", r[r.RG32F = 33328] = "RG32F", r[r.R8I = 33329] = "R8I", r[r.R8UI = 33330] = "R8UI", r[r.R16I = 33331] = "R16I", r[r.R16UI = 33332] = "R16UI", r[r.R32I = 33333] = "R32I", r[r.R32UI = 33334] = "R32UI", r[r.RG8I = 33335] = "RG8I", r[r.RG8UI = 33336] = "RG8UI", r[r.RG16I = 33337] = "RG16I", r[r.RG16UI = 33338] = "RG16UI", r[r.RG32I = 33339] = "RG32I", r[r.RG32UI = 33340] = "RG32UI", r[r.R8_SNORM = 36756] = "R8_SNORM", r[r.RG8_SNORM = 36757] = "RG8_SNORM", r[r.RGB8_SNORM = 36758] = "RGB8_SNORM", r[r.RGBA8_SNORM = 36759] = "RGBA8_SNORM", r[r.RGB10_A2UI = 36975] = "RGB10_A2UI", r[r.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", r[r.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.HALF_FLOAT = 5131] = "HALF_FLOAT", r[r.RG = 33319] = "RG", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", r[r.CURRENT_QUERY = 34917] = "CURRENT_QUERY", r[r.QUERY_RESULT = 34918] = "QUERY_RESULT", r[r.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", r[r.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", r[r.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", r[r.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", r[r.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", r[r.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", r[r.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", r[r.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", r[r.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", r[r.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", r[r.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", r[r.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", r[r.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", r[r.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", r[r.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", r[r.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", r[r.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", r[r.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", r[r.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", r[r.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", r[r.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", r[r.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", r[r.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", r[r.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", r[r.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", r[r.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", r[r.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", r[r.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", r[r.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", r[r.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", r[r.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", r[r.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", r[r.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", r[r.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", r[r.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", r[r.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", r[r.SAMPLER_3D = 35679] = "SAMPLER_3D", r[r.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", r[r.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", r[r.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", r[r.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", r[r.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", r[r.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", r[r.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", r[r.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", r[r.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", r[r.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", r[r.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", r[r.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", r[r.MAX_SAMPLES = 36183] = "MAX_SAMPLES", r[r.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", r[r.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", r[r.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", r[r.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", r[r.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", r[r.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", r[r.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", r[r.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", r[r.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", r[r.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", r[r.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", r[r.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", r[r.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", r[r.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", r[r.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", r[r.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", r[r.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", r[r.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", r[r.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", r[r.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", r[r.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", r[r.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", r[r.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", r[r.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", r[r.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", r[r.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", r[r.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", r[r.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", r[r.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", r[r.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", r[r.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", r[r.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", r[r.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", r[r.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", r[r.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", r[r.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", r[r.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", r[r.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", r[r.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", r[r.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", r[r.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", r[r.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", r[r.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", r[r.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", r[r.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", r[r.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", r[r.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", r[r.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", r[r.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", r[r.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", r[r.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", r[r.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", r[r.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", r[r.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", r[r.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", r[r.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", r[r.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", r[r.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", r[r.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", r[r.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", r[r.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", r[r.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", r[r.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", r[r.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", r[r.OBJECT_TYPE = 37138] = "OBJECT_TYPE", r[r.SYNC_CONDITION = 37139] = "SYNC_CONDITION", r[r.SYNC_STATUS = 37140] = "SYNC_STATUS", r[r.SYNC_FLAGS = 37141] = "SYNC_FLAGS", r[r.SYNC_FENCE = 37142] = "SYNC_FENCE", r[r.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", r[r.UNSIGNALED = 37144] = "UNSIGNALED", r[r.SIGNALED = 37145] = "SIGNALED", r[r.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", r[r.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", r[r.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", r[r.WAIT_FAILED = 37149] = "WAIT_FAILED", r[r.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", r[r.COLOR = 6144] = "COLOR", r[r.DEPTH = 6145] = "DEPTH", r[r.STENCIL = 6146] = "STENCIL", r[r.MIN = 32775] = "MIN", r[r.MAX = 32776] = "MAX", r[r.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", r[r.STREAM_READ = 35041] = "STREAM_READ", r[r.STREAM_COPY = 35042] = "STREAM_COPY", r[r.STATIC_READ = 35045] = "STATIC_READ", r[r.STATIC_COPY = 35046] = "STATIC_COPY", r[r.DYNAMIC_READ = 35049] = "DYNAMIC_READ", r[r.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", r[r.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", r[r.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", r[r.INVALID_INDEX = 4294967295] = "INVALID_INDEX", r[r.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", r[r.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", r[r.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", r[r.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", r[r.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", r[r.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", r[r.R16_EXT = 33322] = "R16_EXT", r[r.RG16_EXT = 33324] = "RG16_EXT", r[r.RGB16_EXT = 32852] = "RGB16_EXT", r[r.RGBA16_EXT = 32859] = "RGBA16_EXT", r[r.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", r[r.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", r[r.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", r[r.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", r[r.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", r[r.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", r[r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", r[r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", r[r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", r[r.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", r[r.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", r[r.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", r[r.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", r[r.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", r[r.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", r[r.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", r[r.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", r[r.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", r[r.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", r[r.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", r[r.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", r[r.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", r[r.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", r[r.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", r[r.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", r[r.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", r[r.LINE_WEBGL = 6913] = "LINE_WEBGL", r[r.FILL_WEBGL = 6914] = "FILL_WEBGL", r[r.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", r[r.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", r[r.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", r[r.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", r[r.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", r[r.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", r[r.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", r[r.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", r[r.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", r[r.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", r[r.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", r[r.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", r[r.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", r[r.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", r[r.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", r[r.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", r[r.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", r[r.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", r[r.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", r[r.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", r[r.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", r[r.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", r[r.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", r[r.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(tp || (tp = {}));
const q7 = {
  WEBGL_depth_texture: {
    UNSIGNED_INT_24_8_WEBGL: 34042
  },
  OES_element_index_uint: {},
  OES_texture_float: {},
  OES_texture_half_float: {
    // @ts-expect-error different numbers?
    HALF_FLOAT_OES: 5131
  },
  EXT_color_buffer_float: {},
  OES_standard_derivatives: {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
  },
  EXT_frag_depth: {},
  EXT_blend_minmax: {
    MIN_EXT: 32775,
    MAX_EXT: 32776
  },
  EXT_shader_texture_lod: {}
}, W7 = (r) => ({
  drawBuffersWEBGL(e) {
    return r.drawBuffers(e);
  },
  COLOR_ATTACHMENT0_WEBGL: 36064,
  COLOR_ATTACHMENT1_WEBGL: 36065,
  COLOR_ATTACHMENT2_WEBGL: 36066,
  COLOR_ATTACHMENT3_WEBGL: 36067
}), X7 = (r) => ({
  VERTEX_ARRAY_BINDING_OES: 34229,
  createVertexArrayOES() {
    return r.createVertexArray();
  },
  deleteVertexArrayOES(e) {
    return r.deleteVertexArray(e);
  },
  isVertexArrayOES(e) {
    return r.isVertexArray(e);
  },
  bindVertexArrayOES(e) {
    return r.bindVertexArray(e);
  }
}), Z7 = (r) => ({
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
  drawArraysInstancedANGLE(...e) {
    return r.drawArraysInstanced(...e);
  },
  drawElementsInstancedANGLE(...e) {
    return r.drawElementsInstanced(...e);
  },
  vertexAttribDivisorANGLE(...e) {
    return r.vertexAttribDivisor(...e);
  }
});
function Y7(r = !0) {
  const e = HTMLCanvasElement.prototype;
  if (!r && e.originalGetContext) {
    e.getContext = e.originalGetContext, e.originalGetContext = void 0;
    return;
  }
  e.originalGetContext = e.getContext, e.getContext = function(t, i) {
    if (t === "webgl" || t === "experimental-webgl") {
      const n = this.originalGetContext("webgl2", i);
      return n instanceof HTMLElement && J7(n), n;
    }
    return this.originalGetContext(t, i);
  };
}
function J7(r) {
  r.getExtension("EXT_color_buffer_float");
  const e = {
    ...q7,
    WEBGL_disjoint_timer_query: r.getExtension("EXT_disjoint_timer_query_webgl2"),
    WEBGL_draw_buffers: W7(r),
    OES_vertex_array_object: X7(r),
    ANGLE_instanced_arrays: Z7(r)
  }, t = r.getExtension;
  r.getExtension = function(n) {
    const s = t.call(r, n);
    return s || (n in e ? e[n] : null);
  };
  const i = r.getSupportedExtensions;
  r.getSupportedExtensions = function() {
    return (i.apply(r) || [])?.concat(Object.keys(e));
  };
}
async function AP(r, e) {
  const t = document.getElementsByTagName("head")[0];
  if (!t)
    throw new Error("loadScript");
  const i = document.createElement("script");
  return i.setAttribute("type", "text/javascript"), i.setAttribute("src", r), new Promise((n, s) => {
    i.onload = n, i.onerror = (c) => s(new Error(`Unable to load script '${r}': ${c}`)), t.appendChild(i);
  });
}
const K7 = 1;
let Ja = null, P3 = !1;
const yx = {
  debugSpectorJS: Ht.get("debug-spectorjs"),
  // https://github.com/BabylonJS/Spector.js#basic-usage
  // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
  // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
  debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
  gl: void 0
};
async function Q7(r) {
  if (!globalThis.SPECTOR)
    try {
      await AP(r.debugSpectorJSUrl || yx.debugSpectorJSUrl);
    } catch (e) {
      Ht.warn(String(e));
    }
}
function e9(r) {
  if (r = {
    ...yx,
    ...r
  }, !r.debugSpectorJS)
    return null;
  if (!Ja && globalThis.SPECTOR && !globalThis.luma?.spector) {
    Ht.probe(K7, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
    const {
      Spector: e
    } = globalThis.SPECTOR;
    Ja = new e(), globalThis.luma && (globalThis.luma.spector = Ja);
  }
  if (!Ja)
    return null;
  if (P3 || (P3 = !0, Ja.spyCanvases(), Ja?.onCaptureStarted.add((e) => Ht.info("Spector capture started:", e)()), Ja?.onCapture.add((e) => {
    Ht.info("Spector capture complete:", e)(), Ja?.getResultUI(), Ja?.resultView.display(), Ja?.resultView.addCapture(e);
  })), r.gl) {
    const e = r.gl, t = e.device;
    Ja?.startCapture(r.gl, 500), e.device = t, new Promise((i) => setTimeout(i, 2e3)).then((i) => {
      Ht.info("Spector capture stopped after 2 seconds")(), Ja?.stopCapture();
    });
  }
  return Ja;
}
const t9 = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function TP(r) {
  return r.luma = r.luma || {}, r.luma;
}
async function r9() {
  ad() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await AP(t9));
}
function i9(r, e = {}) {
  return e.debugWebGL || e.traceWebGL ? s9(r, e) : n9(r);
}
function n9(r) {
  const e = TP(r);
  return e.realContext ? e.realContext : r;
}
function s9(r, e) {
  if (!globalThis.WebGLDebugUtils)
    return Ht.warn("webgl-debug not loaded")(), r;
  const t = TP(r);
  if (t.debugContext)
    return t.debugContext;
  globalThis.WebGLDebugUtils.init({
    ...tp,
    ...r
  });
  const i = globalThis.WebGLDebugUtils.makeDebugContext(r, o9.bind(null, e), a9.bind(null, e));
  for (const c in tp)
    !(c in i) && typeof tp[c] == "number" && (i[c] = tp[c]);
  class n {
  }
  Object.setPrototypeOf(i, Object.getPrototypeOf(r)), Object.setPrototypeOf(n, i);
  const s = Object.create(n);
  return t.realContext = r, t.debugContext = s, s.debug = !0, s;
}
function M3(r, e) {
  e = Array.from(e).map((i) => i === void 0 ? "undefined" : i);
  let t = globalThis.WebGLDebugUtils.glFunctionArgsToString(r, e);
  return t = `${t.slice(0, 100)}${t.length > 100 ? "..." : ""}`, `gl.${r}(${t})`;
}
function o9(r, e, t, i) {
  i = Array.from(i).map((o) => o === void 0 ? "undefined" : o);
  const n = globalThis.WebGLDebugUtils.glEnumToString(e), s = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, i), c = `${n} in gl.${t}(${s})`;
  Ht.error(c)();
  debugger;
}
function a9(r, e, t) {
  let i = "";
  Ht.level >= 1 && (i = M3(e, t), r.traceWebGL && Ht.log(1, i)());
  for (const n of t)
    if (n === void 0) {
      i = i || M3(e, t);
      debugger;
    }
}
const a_ = 1;
class l9 extends yD {
  /** type of device's created by this adapter */
  type = "webgl";
  constructor() {
    super(), Yf.defaultProps = {
      ...Yf.defaultProps,
      ...yx
    };
  }
  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
  enforceWebGL2(e) {
    Y7(e);
  }
  /** Check if WebGL 2 is available */
  isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  isDeviceHandle(e) {
    return typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext ? !0 : (typeof WebGLRenderingContext < "u" && e instanceof WebGLRenderingContext && Ht.warn("WebGL1 is not supported", e)(), !1);
  }
  /**
   * Get a device instance from a GL context
   * Creates a WebGLCanvasContext against the contexts canvas
   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
   * @param gl
   * @returns
   */
  async attach(e, t = {}) {
    const {
      WebGLDevice: i
    } = await Promise.resolve().then(() => q3);
    if (e instanceof i)
      return e;
    if (e?.device instanceof i)
      return e.device;
    if (!c9(e))
      throw new Error("Invalid WebGL2RenderingContext");
    const n = t.createCanvasContext === !0 ? {} : t.createCanvasContext;
    return new i({
      ...t,
      _handle: e,
      createCanvasContext: {
        canvas: e.canvas,
        autoResize: !1,
        ...n
      }
    });
  }
  async create(e = {}) {
    const {
      WebGLDevice: t
    } = await Promise.resolve().then(() => q3);
    Ht.groupCollapsed(a_, "WebGLDevice created")();
    try {
      const i = [];
      (e.debugWebGL || e.debug) && i.push(r9()), e.debugSpectorJS && i.push(Q7(e));
      const n = await Promise.allSettled(i);
      for (const o of n)
        o.status === "rejected" && Ht.error(`Failed to initialize debug libraries ${o.reason}`)();
      const s = new t(e), c = `${s._reused ? "Reusing" : "Created"} device with WebGL2 ${s.props.debug ? "debug " : ""}context: ${s.info.vendor}, ${s.info.renderer} for canvas: ${s.canvasContext.id}`;
      return Ht.probe(a_, c)(), Ht.table(a_, s.info)(), s;
    } finally {
      Ht.groupEnd(a_)();
    }
  }
}
function c9(r) {
  return typeof WebGL2RenderingContext < "u" && r instanceof WebGL2RenderingContext ? !0 : !!(r && Number.isFinite(r._version));
}
const Db = new l9(), bx = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, Os = (r, e, t) => e ? r.enable(t) : r.disable(t), R3 = (r, e, t) => r.hint(t, e), Ka = (r, e, t) => r.pixelStorei(t, e), L3 = (r, e, t) => {
  const i = t === 36006 ? 36009 : 36008;
  return r.bindFramebuffer(i, e);
}, fg = (r, e, t) => {
  const n = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[t];
  r.bindBuffer(n, e);
};
function Nb(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
const u9 = {
  3042: Os,
  32773: (r, e) => r.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (r, e) => r.clearColor(...e),
  3107: (r, e) => r.colorMask(...e),
  2884: Os,
  2885: (r, e) => r.cullFace(e),
  2929: Os,
  2931: (r, e) => r.clearDepth(e),
  2932: (r, e) => r.depthFunc(e),
  2928: (r, e) => r.depthRange(...e),
  2930: (r, e) => r.depthMask(e),
  3024: Os,
  35723: R3,
  35725: (r, e) => r.useProgram(e),
  36007: (r, e) => r.bindRenderbuffer(36161, e),
  36389: (r, e) => r.bindTransformFeedback?.(36386, e),
  34229: (r, e) => r.bindVertexArray(e),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: L3,
  36010: L3,
  // Buffers
  34964: fg,
  36662: fg,
  36663: fg,
  35053: fg,
  35055: fg,
  2886: (r, e) => r.frontFace(e),
  33170: R3,
  2849: (r, e) => r.lineWidth(e),
  32823: Os,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: Os,
  32926: Os,
  32928: Os,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: Os,
  3088: (r, e) => r.scissor(...e),
  2960: Os,
  2961: (r, e) => r.clearStencil(e),
  2968: (r, e) => r.stencilMaskSeparate(1028, e),
  36005: (r, e) => r.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (r, e) => r.viewport(...e),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: Os,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: Os,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: Os,
  12289: Os,
  12290: Os,
  12291: Os,
  12292: Os,
  12293: Os,
  12294: Os,
  12295: Os,
  // PIXEL PACK/UNPACK MODES
  3333: Ka,
  3317: Ka,
  37440: Ka,
  37441: Ka,
  37443: Ka,
  3330: Ka,
  3332: Ka,
  3331: Ka,
  3314: Ka,
  32878: Ka,
  3316: Ka,
  3315: Ka,
  32877: Ka,
  // Function-style setters
  framebuffer: (r, e) => {
    const t = e && "handle" in e ? e.handle : e;
    return r.bindFramebuffer(36160, t);
  },
  blend: (r, e) => e ? r.enable(3042) : r.disable(3042),
  blendColor: (r, e) => r.blendColor(...e),
  blendEquation: (r, e) => {
    const t = typeof e == "number" ? [e, e] : e;
    r.blendEquationSeparate(...t);
  },
  blendFunc: (r, e) => {
    const t = e?.length === 2 ? [...e, ...e] : e;
    r.blendFuncSeparate(...t);
  },
  clearColor: (r, e) => r.clearColor(...e),
  clearDepth: (r, e) => r.clearDepth(e),
  clearStencil: (r, e) => r.clearStencil(e),
  colorMask: (r, e) => r.colorMask(...e),
  cull: (r, e) => e ? r.enable(2884) : r.disable(2884),
  cullFace: (r, e) => r.cullFace(e),
  depthTest: (r, e) => e ? r.enable(2929) : r.disable(2929),
  depthFunc: (r, e) => r.depthFunc(e),
  depthMask: (r, e) => r.depthMask(e),
  depthRange: (r, e) => r.depthRange(...e),
  dither: (r, e) => e ? r.enable(3024) : r.disable(3024),
  derivativeHint: (r, e) => {
    r.hint(35723, e);
  },
  frontFace: (r, e) => r.frontFace(e),
  mipmapHint: (r, e) => r.hint(33170, e),
  lineWidth: (r, e) => r.lineWidth(e),
  polygonOffsetFill: (r, e) => e ? r.enable(32823) : r.disable(32823),
  polygonOffset: (r, e) => r.polygonOffset(...e),
  sampleCoverage: (r, e) => r.sampleCoverage(e[0], e[1] || !1),
  scissorTest: (r, e) => e ? r.enable(3089) : r.disable(3089),
  scissor: (r, e) => r.scissor(...e),
  stencilTest: (r, e) => e ? r.enable(2960) : r.disable(2960),
  stencilMask: (r, e) => {
    e = Nb(e) ? e : [e, e];
    const [t, i] = e;
    r.stencilMaskSeparate(1028, t), r.stencilMaskSeparate(1029, i);
  },
  stencilFunc: (r, e) => {
    e = Nb(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, i, n, s, c, o] = e;
    r.stencilFuncSeparate(1028, t, i, n), r.stencilFuncSeparate(1029, s, c, o);
  },
  stencilOp: (r, e) => {
    e = Nb(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, i, n, s, c, o] = e;
    r.stencilOpSeparate(1028, t, i, n), r.stencilOpSeparate(1029, s, c, o);
  },
  viewport: (r, e) => r.viewport(...e)
};
function os(r, e, t) {
  return e[r] !== void 0 ? e[r] : t[r];
}
const h9 = {
  blendEquation: (r, e, t) => r.blendEquationSeparate(os(32777, e, t), os(34877, e, t)),
  blendFunc: (r, e, t) => r.blendFuncSeparate(os(32969, e, t), os(32968, e, t), os(32971, e, t), os(32970, e, t)),
  polygonOffset: (r, e, t) => r.polygonOffset(os(32824, e, t), os(10752, e, t)),
  sampleCoverage: (r, e, t) => r.sampleCoverage(os(32938, e, t), os(32939, e, t)),
  stencilFuncFront: (r, e, t) => r.stencilFuncSeparate(1028, os(2962, e, t), os(2967, e, t), os(2963, e, t)),
  stencilFuncBack: (r, e, t) => r.stencilFuncSeparate(1029, os(34816, e, t), os(36003, e, t), os(36004, e, t)),
  stencilOpFront: (r, e, t) => r.stencilOpSeparate(1028, os(2964, e, t), os(2965, e, t), os(2966, e, t)),
  stencilOpBack: (r, e, t) => r.stencilOpSeparate(1029, os(34817, e, t), os(34818, e, t), os(34819, e, t))
}, B3 = {
  // GENERIC SETTERS
  enable: (r, e) => r({
    [e]: !0
  }),
  disable: (r, e) => r({
    [e]: !1
  }),
  pixelStorei: (r, e, t) => r({
    [e]: t
  }),
  hint: (r, e, t) => r({
    [e]: t
  }),
  // SPECIFIC SETTERS
  useProgram: (r, e) => r({
    35725: e
  }),
  bindRenderbuffer: (r, e, t) => r({
    36007: t
  }),
  bindTransformFeedback: (r, e, t) => r({
    36389: t
  }),
  bindVertexArray: (r, e) => r({
    34229: e
  }),
  bindFramebuffer: (r, e, t) => {
    switch (e) {
      case 36160:
        return r({
          36006: t,
          36010: t
        });
      case 36009:
        return r({
          36006: t
        });
      case 36008:
        return r({
          36010: t
        });
      default:
        return null;
    }
  },
  bindBuffer: (r, e, t) => {
    const i = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[e];
    return i ? r({
      [i]: t
    }) : {
      valueChanged: !0
    };
  },
  blendColor: (r, e, t, i, n) => r({
    32773: new Float32Array([e, t, i, n])
  }),
  blendEquation: (r, e) => r({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (r, e, t) => r({
    32777: e,
    34877: t
  }),
  blendFunc: (r, e, t) => r({
    32969: e,
    32968: t,
    32971: e,
    32970: t
  }),
  blendFuncSeparate: (r, e, t, i, n) => r({
    32969: e,
    32968: t,
    32971: i,
    32970: n
  }),
  clearColor: (r, e, t, i, n) => r({
    3106: new Float32Array([e, t, i, n])
  }),
  clearDepth: (r, e) => r({
    2931: e
  }),
  clearStencil: (r, e) => r({
    2961: e
  }),
  colorMask: (r, e, t, i, n) => r({
    3107: [e, t, i, n]
  }),
  cullFace: (r, e) => r({
    2885: e
  }),
  depthFunc: (r, e) => r({
    2932: e
  }),
  depthRange: (r, e, t) => r({
    2928: new Float32Array([e, t])
  }),
  depthMask: (r, e) => r({
    2930: e
  }),
  frontFace: (r, e) => r({
    2886: e
  }),
  lineWidth: (r, e) => r({
    2849: e
  }),
  polygonOffset: (r, e, t) => r({
    32824: e,
    10752: t
  }),
  sampleCoverage: (r, e, t) => r({
    32938: e,
    32939: t
  }),
  scissor: (r, e, t, i, n) => r({
    3088: new Int32Array([e, t, i, n])
  }),
  stencilMask: (r, e) => r({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (r, e, t) => r({
    [e === 1028 ? 2968 : 36005]: t
  }),
  stencilFunc: (r, e, t, i) => r({
    2962: e,
    2967: t,
    2963: i,
    34816: e,
    36003: t,
    36004: i
  }),
  stencilFuncSeparate: (r, e, t, i, n) => r({
    [e === 1028 ? 2962 : 34816]: t,
    [e === 1028 ? 2967 : 36003]: i,
    [e === 1028 ? 2963 : 36004]: n
  }),
  stencilOp: (r, e, t, i) => r({
    2964: e,
    2965: t,
    2966: i,
    34817: e,
    34818: t,
    34819: i
  }),
  stencilOpSeparate: (r, e, t, i, n) => r({
    [e === 1028 ? 2964 : 34817]: t,
    [e === 1028 ? 2965 : 34818]: i,
    [e === 1028 ? 2966 : 34819]: n
  }),
  viewport: (r, e, t, i, n) => r({
    2978: [e, t, i, n]
  })
}, cu = (r, e) => r.isEnabled(e), k3 = {
  3042: cu,
  2884: cu,
  2929: cu,
  3024: cu,
  32823: cu,
  32926: cu,
  32928: cu,
  3089: cu,
  2960: cu,
  35977: cu
}, f9 = /* @__PURE__ */ new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);
function Up(r, e) {
  if (p9(e))
    return;
  const t = {};
  for (const n in e) {
    const s = Number(n), c = u9[n];
    c && (typeof c == "string" ? t[c] = !0 : c(r, e[n], s));
  }
  const i = r.state && r.state.cache;
  if (i)
    for (const n in t) {
      const s = h9[n];
      s(r, e, i);
    }
}
function SP(r, e = bx) {
  if (typeof e == "number") {
    const n = e, s = k3[n];
    return s ? s(r, n) : r.getParameter(n);
  }
  const t = Array.isArray(e) ? e : Object.keys(e), i = {};
  for (const n of t) {
    const s = k3[n];
    i[n] = s ? s(r, Number(n)) : r.getParameter(Number(n));
  }
  return i;
}
function d9(r) {
  Up(r, bx);
}
function p9(r) {
  for (const e in r)
    return !1;
  return !0;
}
function g9(r, e) {
  if (r === e)
    return !0;
  if (O3(r) && O3(e) && r.length === e.length) {
    for (let t = 0; t < r.length; ++t)
      if (r[t] !== e[t])
        return !1;
    return !0;
  }
  return !1;
}
function O3(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
class Hf {
  static get(e) {
    return e.state;
  }
  gl;
  program = null;
  stateStack = [];
  enable = !0;
  cache = null;
  log;
  initialized = !1;
  constructor(e, t) {
    this.gl = e, this.log = t?.log || (() => {
    }), this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push(e = {}) {
    this.stateStack.push({});
  }
  pop() {
    const e = this.stateStack[this.stateStack.length - 1];
    Up(this.gl, e), this.stateStack.pop();
  }
  /**
   * Initialize WebGL state caching on a context
   * can be called multiple times to enable/disable
   *
   * @note After calling this function, context state will be cached
   * .push() and .pop() will be available for saving,
   * temporarily modifying, and then restoring state.
   */
  trackState(e, t) {
    if (this.cache = t?.copyState ? SP(e) : Object.assign({}, bx), this.initialized)
      throw new Error("WebGLStateTracker");
    this.initialized = !0, this.gl.state = this, _9(e);
    for (const i in B3) {
      const n = B3[i];
      m9(e, i, n);
    }
    D3(e, "getParameter"), D3(e, "isEnabled");
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(e) {
    let t = !1, i;
    const n = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const s in e) {
      const c = e[s], o = this.cache[s];
      g9(c, o) || (t = !0, i = o, n && !(s in n) && (n[s] = o), this.cache[s] = c);
    }
    return {
      valueChanged: t,
      oldValue: i
    };
  }
}
function D3(r, e) {
  const t = r[e].bind(r);
  r[e] = function(n) {
    if (n === void 0 || f9.has(n))
      return t(n);
    const s = Hf.get(r);
    return n in s.cache || (s.cache[n] = t(n)), s.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      s.cache[n]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      t(n)
    );
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-from-cache`,
    configurable: !1
  });
}
function m9(r, e, t) {
  if (!r[e])
    return;
  const i = r[e].bind(r);
  r[e] = function(...s) {
    const c = Hf.get(r), {
      valueChanged: o,
      oldValue: d
    } = t(c._updateCache, ...s);
    return o && i(...s), d;
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-to-cache`,
    configurable: !1
  });
}
function _9(r) {
  const e = r.useProgram.bind(r);
  r.useProgram = function(i) {
    const n = Hf.get(r);
    n.program !== i && (e(i), n.program = i);
  };
}
function y9(r, e, t) {
  let i = "";
  const n = {
    preserveDrawingBuffer: !0,
    // failIfMajorPerformanceCaveat: true,
    ...t
  };
  let s = null;
  if (s ||= r.getContext("webgl2", n), n.failIfMajorPerformanceCaveat && (i ||= "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow."), !s && !t.failIfMajorPerformanceCaveat && (n.failIfMajorPerformanceCaveat = !1, s = r.getContext("webgl2", n), s.luma ||= {}, s.luma.softwareRenderer = !0), s || (s = r.getContext("webgl", {}), s && (s = null, i ||= "Your browser only supports WebGL1")), !s)
    throw i ||= "Your browser does not support WebGL", new Error(`Failed to create WebGL context: ${i}`);
  const {
    onContextLost: c,
    onContextRestored: o
  } = e;
  return r.addEventListener("webglcontextlost", (d) => c(d), !1), r.addEventListener("webglcontextrestored", (d) => o(d), !1), s.luma ||= {}, s;
}
function Sp(r, e, t) {
  return t[e] === void 0 && (t[e] = r.getExtension(e) || null), t[e];
}
function b9(r, e) {
  const t = r.getParameter(7936), i = r.getParameter(7937);
  Sp(r, "WEBGL_debug_renderer_info", e);
  const n = e.WEBGL_debug_renderer_info, s = r.getParameter(n ? n.UNMASKED_VENDOR_WEBGL : 7936), c = r.getParameter(n ? n.UNMASKED_RENDERER_WEBGL : 7937), o = s || t, d = c || i, m = r.getParameter(7938), y = EP(o, d), T = v9(o, d), P = x9(o, d);
  return {
    type: "webgl",
    gpu: y,
    gpuType: P,
    gpuBackend: T,
    vendor: o,
    renderer: d,
    version: m,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function EP(r, e) {
  return /NVIDIA/i.exec(r) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(r) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(r) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(r) || /AMD/i.exec(e) || /ATI/i.exec(r) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(r) || /SwiftShader/i.exec(e) ? "software" : "unknown";
}
function v9(r, e) {
  return /Metal/i.exec(r) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(r) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
}
function x9(r, e) {
  if (/SwiftShader/i.exec(r) || /SwiftShader/i.exec(e))
    return "cpu";
  switch (EP(r, e)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function CP(r) {
  switch (r) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(r));
}
const Sg = "WEBGL_compressed_texture_s3tc", Eg = "WEBGL_compressed_texture_s3tc_srgb", rp = "EXT_texture_compression_rgtc", ip = "EXT_texture_compression_bptc", w9 = "WEBGL_compressed_texture_etc", A9 = "WEBGL_compressed_texture_astc", T9 = "WEBGL_compressed_texture_etc1", S9 = "WEBGL_compressed_texture_pvrtc", E9 = "WEBGL_compressed_texture_atc", N3 = "EXT_texture_norm16", F3 = "EXT_render_snorm", C9 = "EXT_color_buffer_float", vx = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [F3],
  "norm16-renderable-webgl": [N3],
  "snorm16-renderable-webgl": [N3, F3],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [Sg, Eg, rp, ip],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [rp],
  "texture-compression-bc7-webgl": [ip],
  "texture-compression-etc2": [w9],
  "texture-compression-astc": [A9],
  "texture-compression-etc1-webgl": [T9],
  "texture-compression-pvrtc-webgl": [S9],
  "texture-compression-atc-webgl": [E9]
};
function I9(r) {
  return r in vx;
}
function P9(r, e, t) {
  return (vx[e] || []).every((n) => Sp(r, n, t));
}
const xx = {
  // 8-bit formats
  r8unorm: {
    gl: 33321,
    rb: !0
  },
  r8snorm: {
    gl: 36756
  },
  r8uint: {
    gl: 33330,
    rb: !0
  },
  r8sint: {
    gl: 33329,
    rb: !0
  },
  // 16-bit formats
  rg8unorm: {
    gl: 33323,
    rb: !0
  },
  rg8snorm: {
    gl: 36757
  },
  rg8uint: {
    gl: 33336,
    rb: !0
  },
  rg8sint: {
    gl: 33335,
    rb: !0
  },
  r16uint: {
    gl: 33332,
    rb: !0
  },
  r16sint: {
    gl: 33331,
    rb: !0
  },
  r16float: {
    gl: 33325,
    rb: !0
  },
  r16unorm: {
    gl: 33322,
    rb: !0
  },
  r16snorm: {
    gl: 36760
  },
  // Packed 16-bit formats
  "rgba4unorm-webgl": {
    gl: 32854,
    rb: !0
  },
  "rgb565unorm-webgl": {
    gl: 36194,
    rb: !0
  },
  "rgb5a1unorm-webgl": {
    gl: 32855,
    rb: !0
  },
  // 24-bit formats
  "rgb8unorm-webgl": {
    gl: 32849
  },
  "rgb8snorm-webgl": {
    gl: 36758
  },
  // 32-bit formats
  rgba8unorm: {
    gl: 32856
  },
  "rgba8unorm-srgb": {
    gl: 35907
  },
  rgba8snorm: {
    gl: 36759
  },
  rgba8uint: {
    gl: 36220
  },
  rgba8sint: {
    gl: 36238
  },
  // reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: {
    gl: 33338
  },
  rg16sint: {
    gl: 33337
  },
  rg16float: {
    gl: 33327,
    rb: !0
  },
  rg16unorm: {
    gl: 33324
  },
  rg16snorm: {
    gl: 36761
  },
  r32uint: {
    gl: 33334,
    rb: !0
  },
  r32sint: {
    gl: 33333,
    rb: !0
  },
  r32float: {
    gl: 33326
  },
  // Packed 32-bit formats
  rgb9e5ufloat: {
    gl: 35901
  },
  // , filter: true},
  rg11b10ufloat: {
    gl: 35898,
    rb: !0
  },
  rgb10a2unorm: {
    gl: 32857,
    rb: !0
  },
  rgb10a2uint: {
    gl: 36975,
    rb: !0
  },
  // 48-bit formats
  "rgb16unorm-webgl": {
    gl: 32852
  },
  // rgb not renderable
  "rgb16snorm-webgl": {
    gl: 36762
  },
  // rgb not renderable
  // 64-bit formats
  rg32uint: {
    gl: 33340,
    rb: !0
  },
  rg32sint: {
    gl: 33339,
    rb: !0
  },
  rg32float: {
    gl: 33328,
    rb: !0
  },
  rgba16uint: {
    gl: 36214,
    rb: !0
  },
  rgba16sint: {
    gl: 36232,
    rb: !0
  },
  rgba16float: {
    gl: 34842
  },
  rgba16unorm: {
    gl: 32859,
    rb: !0
  },
  rgba16snorm: {
    gl: 36763
  },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: 34837,
    x: C9,
    dataFormat: 6407,
    types: [5126]
  },
  // 128-bit formats
  rgba32uint: {
    gl: 36208,
    rb: !0
  },
  rgba32sint: {
    gl: 36226,
    rb: !0
  },
  rgba32float: {
    gl: 34836,
    rb: !0
  },
  // Depth and stencil formats
  stencil8: {
    gl: 36168,
    rb: !0
  },
  // 8 stencil bits
  depth16unorm: {
    gl: 33189,
    dataFormat: 6402,
    types: [5123],
    rb: !0
  },
  // 16 depth bits
  depth24plus: {
    gl: 33190,
    dataFormat: 6402,
    types: [5125]
  },
  depth32float: {
    gl: 36012,
    dataFormat: 6402,
    types: [5126],
    rb: !0
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    gl: 35056,
    rb: !0,
    depthTexture: !0,
    dataFormat: 34041,
    types: [34042]
  },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": {
    gl: 36013,
    dataFormat: 34041,
    types: [36269],
    rb: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": {
    gl: 33776,
    x: Sg
  },
  "bc1-rgb-unorm-srgb-webgl": {
    gl: 35916,
    x: Eg
  },
  "bc1-rgba-unorm": {
    gl: 33777,
    x: Sg
  },
  "bc1-rgba-unorm-srgb": {
    gl: 35916,
    x: Eg
  },
  "bc2-rgba-unorm": {
    gl: 33778,
    x: Sg
  },
  "bc2-rgba-unorm-srgb": {
    gl: 35918,
    x: Eg
  },
  "bc3-rgba-unorm": {
    gl: 33779,
    x: Sg
  },
  "bc3-rgba-unorm-srgb": {
    gl: 35919,
    x: Eg
  },
  "bc4-r-unorm": {
    gl: 36283,
    x: rp
  },
  "bc4-r-snorm": {
    gl: 36284,
    x: rp
  },
  "bc5-rg-unorm": {
    gl: 36285,
    x: rp
  },
  "bc5-rg-snorm": {
    gl: 36286,
    x: rp
  },
  "bc6h-rgb-ufloat": {
    gl: 36495,
    x: ip
  },
  "bc6h-rgb-float": {
    gl: 36494,
    x: ip
  },
  "bc7-rgba-unorm": {
    gl: 36492,
    x: ip
  },
  "bc7-rgba-unorm-srgb": {
    gl: 36493,
    x: ip
  },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": {
    gl: 37492
  },
  "etc2-rgb8unorm-srgb": {
    gl: 37494
  },
  "etc2-rgb8a1unorm": {
    gl: 37496
  },
  "etc2-rgb8a1unorm-srgb": {
    gl: 37497
  },
  "etc2-rgba8unorm": {
    gl: 37493
  },
  "etc2-rgba8unorm-srgb": {
    gl: 37495
  },
  "eac-r11unorm": {
    gl: 37488
  },
  "eac-r11snorm": {
    gl: 37489
  },
  "eac-rg11unorm": {
    gl: 37490
  },
  "eac-rg11snorm": {
    gl: 37491
  },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": {
    gl: 37808
  },
  "astc-4x4-unorm-srgb": {
    gl: 37840
  },
  "astc-5x4-unorm": {
    gl: 37809
  },
  "astc-5x4-unorm-srgb": {
    gl: 37841
  },
  "astc-5x5-unorm": {
    gl: 37810
  },
  "astc-5x5-unorm-srgb": {
    gl: 37842
  },
  "astc-6x5-unorm": {
    gl: 37811
  },
  "astc-6x5-unorm-srgb": {
    gl: 37843
  },
  "astc-6x6-unorm": {
    gl: 37812
  },
  "astc-6x6-unorm-srgb": {
    gl: 37844
  },
  "astc-8x5-unorm": {
    gl: 37813
  },
  "astc-8x5-unorm-srgb": {
    gl: 37845
  },
  "astc-8x6-unorm": {
    gl: 37814
  },
  "astc-8x6-unorm-srgb": {
    gl: 37846
  },
  "astc-8x8-unorm": {
    gl: 37815
  },
  "astc-8x8-unorm-srgb": {
    gl: 37847
  },
  "astc-10x5-unorm": {
    gl: 37819
  },
  "astc-10x5-unorm-srgb": {
    gl: 37851
  },
  "astc-10x6-unorm": {
    gl: 37817
  },
  "astc-10x6-unorm-srgb": {
    gl: 37849
  },
  "astc-10x8-unorm": {
    gl: 37818
  },
  "astc-10x8-unorm-srgb": {
    gl: 37850
  },
  "astc-10x10-unorm": {
    gl: 37819
  },
  "astc-10x10-unorm-srgb": {
    gl: 37851
  },
  "astc-12x10-unorm": {
    gl: 37820
  },
  "astc-12x10-unorm-srgb": {
    gl: 37852
  },
  "astc-12x12-unorm": {
    gl: 37821
  },
  "astc-12x12-unorm-srgb": {
    gl: 37853
  },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": {
    gl: 35840
  },
  "pvrtc-rgba4unorm-webgl": {
    gl: 35842
  },
  "pvrtc-rbg2unorm-webgl": {
    gl: 35841
  },
  "pvrtc-rgba2unorm-webgl": {
    gl: 35843
  },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": {
    gl: 36196
  },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": {
    gl: 35986
  },
  "atc-rgba-unorm-webgl": {
    gl: 35986
  },
  "atc-rgbai-unorm-webgl": {
    gl: 34798
  }
};
function M9(r, e, t) {
  let i = e.create;
  const n = xx[e.format];
  return n?.gl === void 0 && (i = !1), n?.x && (i = i && !!Sp(r, n.x, t)), {
    format: e.format,
    // @ts-ignore
    create: i && e.create,
    // @ts-ignore
    render: i && e.render,
    // @ts-ignore
    filter: i && e.filter,
    // @ts-ignore
    blend: i && e.blend,
    // @ts-ignore
    store: i && e.store
  };
}
function IP(r) {
  const e = xx[r], t = B9(r), i = up.getInfo(r);
  return i.compressed && (e.dataFormat = t), {
    internalFormat: t,
    format: e?.dataFormat || L9(i.channels, i.integer, i.normalized, t),
    // depth formats don't have a type
    type: i.dataType ? CP(i.dataType) : e?.types?.[0] || 5121,
    compressed: i.compressed || !1
  };
}
function R9(r) {
  switch (up.getInfo(r).attachment) {
    case "depth":
      return 36096;
    case "stencil":
      return 36128;
    case "depth-stencil":
      return 33306;
    default:
      throw new Error(`Not a depth stencil format: ${r}`);
  }
}
function L9(r, e, t, i) {
  if (i === 6408 || i === 6407)
    return i;
  switch (r) {
    case "r":
      return e && !t ? 36244 : 6403;
    case "rg":
      return e && !t ? 33320 : 33319;
    case "rgb":
      return e && !t ? 36248 : 6407;
    case "rgba":
      return e && !t ? 36249 : 6408;
    case "bgra":
      throw new Error("bgra pixels not supported by WebGL");
    default:
      return 6408;
  }
}
function B9(r) {
  const t = xx[r]?.gl;
  if (t === void 0)
    throw new Error(`Unsupported texture format ${r}`);
  return t;
}
const U3 = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class k9 extends mD {
  gl;
  extensions;
  testedFeatures = /* @__PURE__ */ new Set();
  constructor(e, t, i) {
    super([], i), this.gl = e, this.extensions = t, Sp(e, "EXT_color_buffer_float", t);
  }
  *[Symbol.iterator]() {
    const e = this.getFeatures();
    for (const t of e)
      this.has(t) && (yield t);
    return [];
  }
  has(e) {
    return this.disabledFeatures?.[e] ? !1 : (this.testedFeatures.has(e) || (this.testedFeatures.add(e), I9(e) && P9(this.gl, e, this.extensions) && this.features.add(e), this.getWebGLFeature(e) && this.features.add(e)), this.features.has(e));
  }
  // FOR DEVICE
  initializeFeatures() {
    const e = this.getFeatures().filter((t) => t !== "polygon-mode-webgl");
    for (const t of e)
      this.has(t);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(U3), ...Object.keys(vx)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(e) {
    const t = U3[e];
    return typeof t == "string" ? !!Sp(this.gl, t, this.extensions) : !!t;
  }
}
class O9 extends gD {
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderVariables() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  // WebGL does not support compute shaders
  // PRIVATE
  gl;
  limits = {};
  constructor(e) {
    super(), this.gl = e;
  }
  getParameter(e) {
    return this.limits[e] === void 0 && (this.limits[e] = this.gl.getParameter(e)), this.limits[e] || 0;
  }
}
class Fg extends Qy {
  device;
  gl;
  handle;
  colorAttachments = [];
  depthStencilAttachment = null;
  constructor(e, t) {
    super(e, t);
    const i = t.handle === null;
    this.device = e, this.gl = e.gl, this.handle = this.props.handle || i ? this.props.handle : this.gl.createFramebuffer(), i || (e._setWebGLDebugMetadata(this.handle, this, {
      spector: this.props
    }), this.autoCreateAttachmentTextures(), this.updateAttachments());
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  updateAttachments() {
    const e = this.gl.bindFramebuffer(36160, this.handle);
    for (let t = 0; t < this.colorAttachments.length; ++t) {
      const i = this.colorAttachments[t];
      if (i) {
        const n = 36064 + t;
        this._attachTextureView(n, i);
      }
    }
    if (this.depthStencilAttachment) {
      const t = R9(this.depthStencilAttachment.props.format);
      this._attachTextureView(t, this.depthStencilAttachment);
    }
    if (this.device.props.debug) {
      const t = this.gl.checkFramebufferStatus(36160);
      if (t !== 36053)
        throw new Error(`Framebuffer ${N9(t)}`);
    }
    this.gl.bindFramebuffer(36160, e);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  // protected override createDepthStencilTexture(format: TextureFormat): Texture {
  //   // return new WEBGLRenderbuffer(this.device, {
  //   return new WEBGLTexture(this.device, {
  //     id: `${this.id}-depth-stencil`,
  //     format,
  //     width: this.width,
  //     height: this.height,
  //     mipmaps: false
  //   });
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTextureView(e, t) {
    const {
      gl: i
    } = this.device, {
      texture: n
    } = t, s = t.props.baseMipLevel, c = t.props.baseArrayLayer;
    switch (i.bindTexture(n.glTarget, n.handle), n.glTarget) {
      case 35866:
      case 32879:
        i.framebufferTextureLayer(36160, e, n.handle, s, c);
        break;
      case 34067:
        const o = D9(c);
        i.framebufferTexture2D(36160, e, o, n.handle, s);
        break;
      case 3553:
        i.framebufferTexture2D(36160, e, 3553, n.handle, s);
        break;
      default:
        throw new Error("Illegal texture type");
    }
    i.bindTexture(n.glTarget, null);
  }
}
function D9(r) {
  return r < 34069 ? r + 34069 : r;
}
function N9(r) {
  switch (r) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${r}`;
  }
}
class F9 extends Of {
  device;
  handle = null;
  _framebuffer = null;
  get [Symbol.toStringTag]() {
    return "WebGLCanvasContext";
  }
  constructor(e, t) {
    super(t), this.device = e, this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this._updateDevice();
  }
  getCurrentFramebuffer() {
    return this._framebuffer = this._framebuffer || new Fg(this.device, {
      handle: null
    }), this._framebuffer;
  }
  // IMPLEMENTATION OF ABSTRACT METHODS
  _updateDevice() {
  }
}
const Fb = {};
function U9(r = "id") {
  Fb[r] = Fb[r] || 1;
  const e = Fb[r]++;
  return `${r}-${e}`;
}
class Ug extends us {
  device;
  gl;
  handle;
  /** Target in OpenGL defines the type of buffer */
  glTarget;
  /** Usage is a hint on how frequently the buffer will be updates */
  glUsage;
  /** Index type is needed when issuing draw calls, so we pre-compute it */
  glIndexType = 5123;
  /** Number of bytes allocated on the GPU for this buffer */
  byteLength = 0;
  /** Number of bytes used */
  bytesUsed = 0;
  constructor(e, t = {}) {
    super(e, t), this.device = e, this.gl = this.device.gl;
    const i = typeof t == "object" ? t.handle : void 0;
    this.handle = i || this.gl.createBuffer(), e._setWebGLDebugMetadata(this.handle, this, {
      spector: {
        ...this.props,
        data: typeof this.props.data
      }
    }), this.glTarget = z9(this.props.usage), this.glUsage = j9(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, t.data ? this._initWithData(t.data, t.byteOffset, t.byteLength) : this._initWithByteLength(t.byteLength || 0);
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(e, t = 0, i = e.byteLength + t) {
    const n = this.glTarget;
    this.gl.bindBuffer(n, this.handle), this.gl.bufferData(n, i, this.glUsage), this.gl.bufferSubData(n, t, e), this.gl.bindBuffer(n, null), this.bytesUsed = i, this.byteLength = i, this._setDebugData(e, t, i), this.trackAllocatedMemory(i);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(e) {
    let t = e;
    e === 0 && (t = new Float32Array(0));
    const i = this.glTarget;
    return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, t, this.glUsage), this.gl.bindBuffer(i, null), this.bytesUsed = e, this.byteLength = e, this._setDebugData(null, 0, e), this.trackAllocatedMemory(e), this;
  }
  write(e, t = 0) {
    const i = ArrayBuffer.isView(e) ? e : new Uint8Array(e), n = 36663;
    this.gl.bindBuffer(n, this.handle), this.gl.bufferSubData(n, t, i), this.gl.bindBuffer(n, null), this._setDebugData(e, t, e.byteLength);
  }
  async mapAndWriteAsync(e, t = 0, i = this.byteLength - t) {
    const n = new ArrayBuffer(i);
    await e(n, "copied"), this.write(n, t);
  }
  async readAsync(e = 0, t) {
    return this.readSyncWebGL(e, t);
  }
  async mapAndReadAsync(e, t = 0, i) {
    const n = await this.readAsync(t, i);
    return await e(n.buffer, "copied");
  }
  readSyncWebGL(e = 0, t) {
    t = t ?? this.byteLength - e;
    const i = new Uint8Array(t), n = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, i, n, t), this.gl.bindBuffer(36662, null), this._setDebugData(i, e, t), i;
  }
}
function z9(r) {
  return r & us.INDEX ? 34963 : r & us.VERTEX ? 34962 : r & us.UNIFORM ? 35345 : 34962;
}
function j9(r) {
  return r & us.INDEX || r & us.VERTEX ? 35044 : r & us.UNIFORM ? 35048 : 35044;
}
function V9(r) {
  const e = r.split(/\r?\n/), t = [];
  for (const i of e) {
    if (i.length <= 1)
      continue;
    const n = i.split(":");
    if (n.length === 2) {
      const [T, P] = n;
      t.push({
        message: P.trim(),
        type: z3(T),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [s, c, o, ...d] = n;
    let m = parseInt(o, 10);
    isNaN(m) && (m = 0);
    let y = parseInt(c, 10);
    isNaN(y) && (y = 0), t.push({
      message: d.join(":").trim(),
      type: z3(s),
      lineNum: m,
      linePos: y
      // TODO
    });
  }
  return t;
}
function z3(r) {
  const e = ["warning", "error", "info"], t = r.toLowerCase();
  return e.includes(t) ? t : "info";
}
class G9 extends Ky {
  device;
  handle;
  constructor(e, t) {
    switch (super(e, t), this.device = e, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    e._setWebGLDebugMetadata(this.handle, this, {
      spector: this.props
    }), this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0, this.handle.destroyed = !0);
  }
  get asyncCompilationStatus() {
    return this._waitForCompilationComplete().then(() => (this._getCompilationStatus(), this.compilationStatus));
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const e = this.device.gl.getShaderInfoLog(this.handle);
    return e ? V9(e) : [];
  }
  getTranslatedSource() {
    return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle) || null;
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(e) {
    e = e.startsWith("#version ") ? e : `#version 300 es
${e}`;
    const {
      gl: t
    } = this.device;
    if (t.shaderSource(this.handle, e), t.compileShader(this.handle), !this.device.props.debug) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    Ht.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), Ht.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const e = async (n) => await new Promise((s) => setTimeout(s, n));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const {
      gl: i
    } = this.device;
    for (; ; ) {
      if (i.getShaderParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
function $9(r, e, t, i) {
  if (X9(e))
    return i(r);
  const n = r;
  n.pushState();
  try {
    return H9(r, e), Up(n.gl, t), i(r);
  } finally {
    n.popState();
  }
}
function H9(r, e) {
  const t = r, {
    gl: i
  } = t;
  if (e.cullMode)
    switch (e.cullMode) {
      case "none":
        i.disable(2884);
        break;
      case "front":
        i.enable(2884), i.cullFace(1028);
        break;
      case "back":
        i.enable(2884), i.cullFace(1029);
        break;
    }
  if (e.frontFace && i.frontFace(qf("frontFace", e.frontFace, {
    ccw: 2305,
    cw: 2304
  })), e.unclippedDepth && r.features.has("depth-clip-control") && i.enable(34383), e.depthBias !== void 0 && (i.enable(32823), i.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && r.features.has("provoking-vertex-webgl")) {
    const s = t.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, c = qf("provokingVertex", e.provokingVertex, {
      first: 36429,
      last: 36430
    });
    s?.provokingVertexWEBGL(c);
  }
  if ((e.polygonMode || e.polygonOffsetLine) && r.features.has("polygon-mode-webgl")) {
    if (e.polygonMode) {
      const s = t.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, c = qf("polygonMode", e.polygonMode, {
        fill: 6914,
        line: 6913
      });
      s?.polygonModeWEBGL(1028, c), s?.polygonModeWEBGL(1029, c);
    }
    e.polygonOffsetLine && i.enable(10754);
  }
  if (r.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && i.enable(12288), e.clipDistance1 && i.enable(12289), e.clipDistance2 && i.enable(12290), e.clipDistance3 && i.enable(12291), e.clipDistance4 && i.enable(12292), e.clipDistance5 && i.enable(12293), e.clipDistance6 && i.enable(12294), e.clipDistance7 && i.enable(12295)), e.depthWriteEnabled !== void 0 && i.depthMask(W9("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? i.enable(2929) : i.disable(2929), i.depthFunc(Mv("depthCompare", e.depthCompare))), e.stencilWriteMask) {
    const n = e.stencilWriteMask;
    i.stencilMaskSeparate(1028, n), i.stencilMaskSeparate(1029, n);
  }
  if (e.stencilReadMask && Ht.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
    const n = e.stencilReadMask || 4294967295, s = Mv("depthCompare", e.stencilCompare);
    e.stencilCompare !== "always" ? i.enable(2960) : i.disable(2960), i.stencilFuncSeparate(1028, s, 0, n), i.stencilFuncSeparate(1029, s, 0, n);
  }
  if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
    const n = Ub("stencilPassOperation", e.stencilPassOperation), s = Ub("stencilFailOperation", e.stencilFailOperation), c = Ub("stencilDepthFailOperation", e.stencilDepthFailOperation);
    i.stencilOpSeparate(1028, s, c, n), i.stencilOpSeparate(1029, s, c, n);
  }
  switch (e.blend) {
    case !0:
      i.enable(3042);
      break;
    case !1:
      i.disable(3042);
      break;
  }
  if (e.blendColorOperation || e.blendAlphaOperation) {
    const n = j3("blendColorOperation", e.blendColorOperation || "add"), s = j3("blendAlphaOperation", e.blendAlphaOperation || "add");
    i.blendEquationSeparate(n, s);
    const c = l_("blendColorSrcFactor", e.blendColorSrcFactor || "one"), o = l_("blendColorDstFactor", e.blendColorDstFactor || "zero"), d = l_("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), m = l_("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
    i.blendFuncSeparate(c, o, d, m);
  }
}
function Mv(r, e) {
  return qf(r, e, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function Ub(r, e) {
  return qf(r, e, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function j3(r, e) {
  return qf(r, e, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function l_(r, e, t = "color") {
  return qf(r, e, {
    one: 1,
    zero: 0,
    src: 768,
    "one-minus-src": 769,
    dst: 774,
    "one-minus-dst": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    constant: t === "color" ? 32769 : 32771,
    "one-minus-constant": t === "color" ? 32770 : 32772,
    // 'constant-alpha': GL.CONSTANT_ALPHA,
    // 'one-minus-constant-alpha': GL.ONE_MINUS_CONSTANT_ALPHA,
    // TODO not supported in WebGL2
    src1: 768,
    "one-minus-src1": 769,
    "src1-alpha": 770,
    "one-minus-src1-alpha": 771
  });
}
function q9(r, e) {
  return `Illegal parameter ${e} for ${r}`;
}
function qf(r, e, t) {
  if (!(e in t))
    throw new Error(q9(r, e));
  return t[e];
}
function W9(r, e) {
  return e;
}
function X9(r) {
  let e = !0;
  for (const t in r) {
    e = !1;
    break;
  }
  return e;
}
function PP(r) {
  const e = {};
  return r.addressModeU && (e[10242] = zb(r.addressModeU)), r.addressModeV && (e[10243] = zb(r.addressModeV)), r.addressModeW && (e[32882] = zb(r.addressModeW)), r.magFilter && (e[10240] = Rv(r.magFilter)), (r.minFilter || r.mipmapFilter) && (e[10241] = Z9(r.minFilter || "linear", r.mipmapFilter)), r.lodMinClamp !== void 0 && (e[33082] = r.lodMinClamp), r.lodMaxClamp !== void 0 && (e[33083] = r.lodMaxClamp), r.type === "comparison-sampler" && (e[34892] = 34894), r.compare && (e[34893] = Mv("compare", r.compare)), r.maxAnisotropy && (e[34046] = r.maxAnisotropy), e;
}
function zb(r) {
  switch (r) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function Rv(r) {
  switch (r) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function Z9(r, e = "none") {
  if (!e)
    return Rv(r);
  switch (e) {
    case "none":
      return Rv(r);
    case "nearest":
      switch (r) {
        case "nearest":
          return 9984;
        case "linear":
          return 9985;
      }
      break;
    case "linear":
      switch (r) {
        case "nearest":
          return 9986;
        case "linear":
          return 9987;
      }
  }
}
class Y9 extends Jf {
  device;
  handle;
  parameters;
  constructor(e, t) {
    super(e, t), this.device = e, this.parameters = PP(t), this.handle = t.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(e) {
    for (const [t, i] of Object.entries(e)) {
      const n = Number(t);
      switch (n) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, n, i);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, n, i);
          break;
      }
    }
  }
}
function em(r, e, t) {
  if (J9(e))
    return t(r);
  const {
    nocatch: i = !0
  } = e, n = Hf.get(r);
  n.push(), Up(r, e);
  let s;
  if (i)
    s = t(r), n.pop();
  else
    try {
      s = t(r);
    } finally {
      n.pop();
    }
  return s;
}
function J9(r) {
  for (const e in r)
    return !1;
  return !0;
}
class np extends Jy {
  device;
  gl;
  handle;
  // Does not have a WebGL representation
  texture;
  constructor(e, t) {
    super(e, {
      ...Fs.defaultProps,
      ...t
    }), this.device = e, this.gl = this.device.gl, this.handle = null, this.texture = t.texture;
  }
}
class zg extends Fs {
  // readonly MAX_ATTRIBUTES: number;
  device;
  gl;
  handle;
  // @ts-ignore TODO - currently unused in WebGL. Create dummy sampler?
  sampler = void 0;
  view;
  /**
   * The WebGL target corresponding to the texture type
   * @note `target` cannot be modified by bind:
   * textures are special because when you first bind them to a target,
   * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
   * And it will always be a 2D texture; this state cannot be changed ever.
   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
   */
  glTarget;
  /** The WebGL format - essentially channel structure */
  glFormat;
  /** The WebGL data format - the type of each channel */
  glType;
  /** The WebGL constant corresponding to the WebGPU style constant in format */
  glInternalFormat;
  /** Whether the internal format is compressed */
  compressed;
  // state
  /** Texture binding slot - TODO - move to texture view? */
  _textureUnit = 0;
  constructor(e, t) {
    super(e, t), this.device = e, this.gl = this.device.gl;
    const i = IP(this.props.format);
    this.glTarget = K9(this.props.dimension), this.glInternalFormat = i.internalFormat, this.glFormat = i.format, this.glType = i.type, this.compressed = i.compressed, this.handle = this.props.handle || this.gl.createTexture(), this.device._setWebGLDebugMetadata(this.handle, this, {
      spector: this.props
    }), this.gl.bindTexture(this.glTarget, this.handle);
    const {
      dimension: n,
      width: s,
      height: c,
      depth: o,
      mipLevels: d,
      glTarget: m,
      glInternalFormat: y
    } = this;
    switch (n) {
      case "2d":
      case "cube":
        this.gl.texStorage2D(m, d, y, s, c);
        break;
      case "2d-array":
      case "3d":
        this.gl.texStorage3D(m, d, y, s, c, o);
        break;
      default:
        throw new Error(n);
    }
    this.gl.bindTexture(this.glTarget, null), this._initializeData(t.data), this.setSampler(this.props.sampler), this.view = new np(this.device, {
      ...this.props,
      texture: this
    }), Object.seal(this);
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  createView(e) {
    return new np(this.device, {
      ...e,
      texture: this
    });
  }
  setSampler(e = {}) {
    super.setSampler(e);
    const t = PP(this.sampler.props);
    this._setSamplerParameters(t);
  }
  copyImageData(e) {
    const t = this._normalizeCopyImageDataOptions(e), i = t.data, {
      width: n,
      height: s,
      depth: c
    } = this, {
      mipLevel: o = 0,
      byteOffset: d = 0,
      x: m = 0,
      y = 0,
      z: T = 0
    } = t, {
      glFormat: P,
      glType: I,
      compressed: D
    } = this, k = V3(this.glTarget, this.dimension, c), $ = this.compressed ? {} : {
      3314: t.bytesPerRow,
      32878: t.rowsPerImage
    };
    this.gl.bindTexture(k, this.handle), em(this.gl, $, () => {
      switch (this.dimension) {
        case "2d":
        case "cube":
          D ? this.gl.compressedTexSubImage2D(k, o, m, y, n, s, P, i, d) : this.gl.texSubImage2D(k, o, m, y, n, s, P, I, i, d);
          break;
        case "2d-array":
        case "3d":
          D ? this.gl.compressedTexSubImage3D(k, o, m, y, T, n, s, c, P, i, d) : this.gl.texSubImage3D(k, o, m, y, T, n, s, c, P, I, i, d);
          break;
        default:
      }
    }), this.gl.bindTexture(k, null);
  }
  copyExternalImage(e) {
    const t = this._normalizeCopyExternalImageOptions(e);
    if (t.sourceX || t.sourceY)
      throw new Error("WebGL does not support sourceX/sourceY)");
    const {
      glFormat: i,
      glType: n
    } = this, {
      image: s,
      depth: c,
      mipLevel: o,
      x: d,
      y: m,
      z: y,
      width: T,
      height: P
    } = t, I = V3(this.glTarget, this.dimension, c), D = t.flipY ? {
      37440: !0
    } : {};
    return this.gl.bindTexture(this.glTarget, this.handle), em(this.gl, D, () => {
      switch (this.dimension) {
        case "2d":
        case "cube":
          this.gl.texSubImage2D(I, o, d, m, T, P, i, n, s);
          break;
        case "2d-array":
        case "3d":
          this.gl.texSubImage3D(I, o, d, m, y, T, P, c, i, n, s);
          break;
        default:
      }
    }), this.gl.bindTexture(this.glTarget, null), {
      width: t.width,
      height: t.height
    };
  }
  // WEBGL SPECIFIC
  generateMipmapsWebGL(e) {
    if (!(!(this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format)) && (Ht.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)(), !e?.force)))
      try {
        this.gl.bindTexture(this.glTarget, this.handle), this.gl.generateMipmap(this.glTarget);
      } catch (i) {
        Ht.warn(`Error generating mipmap for ${this}: ${i.message}`)();
      } finally {
        this.gl.bindTexture(this.glTarget, null);
      }
  }
  // INTERNAL
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(e) {
    Ht.log(2, `${this.id} sampler parameters`, this.device.getGLKeys(e))(), this.gl.bindTexture(this.glTarget, this.handle);
    for (const [t, i] of Object.entries(e)) {
      const n = Number(t), s = i;
      switch (n) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.glTarget, n, s);
          break;
        case 10240:
        case 10241:
          this.gl.texParameteri(this.glTarget, n, s);
          break;
        case 10242:
        case 10243:
        case 32882:
          this.gl.texParameteri(this.glTarget, n, s);
          break;
        case 34046:
          this.device.features.has("texture-filterable-anisotropic-webgl") && this.gl.texParameteri(this.glTarget, n, s);
          break;
        case 34892:
        case 34893:
          this.gl.texParameteri(this.glTarget, n, s);
          break;
      }
    }
    this.gl.bindTexture(this.glTarget, null);
  }
  _getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  _bind(e) {
    const {
      gl: t
    } = this;
    return e !== void 0 && (this._textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, this.handle), e;
  }
  _unbind(e) {
    const {
      gl: t
    } = this;
    return e !== void 0 && (this._textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, null), e;
  }
}
function K9(r) {
  switch (r) {
    case "1d":
      break;
    // not supported in any WebGL version
    case "2d":
      return 3553;
    // supported in WebGL1
    case "3d":
      return 32879;
    // supported in WebGL2
    case "cube":
      return 34067;
    // supported in WebGL1
    case "2d-array":
      return 35866;
  }
  throw new Error(r);
}
function V3(r, e, t) {
  return e === "cube" ? 34069 + t : r;
}
function Q9(r) {
  return ij[r];
}
function wx(r) {
  return rj[r];
}
function ej(r) {
  return !!MP[r];
}
function tj(r) {
  return MP[r];
}
const rj = {
  5126: "f32",
  35664: "vec2<f32>",
  35665: "vec3<f32>",
  35666: "vec4<f32>",
  5124: "i32",
  35667: "vec2<i32>",
  35668: "vec3<i32>",
  35669: "vec4<i32>",
  5125: "u32",
  36294: "vec2<u32>",
  36295: "vec3<u32>",
  36296: "vec4<u32>",
  35670: "f32",
  35671: "vec2<f32>",
  35672: "vec3<f32>",
  35673: "vec4<f32>",
  // TODO - are sizes/components below correct?
  35674: "mat2x2<f32>",
  35685: "mat2x3<f32>",
  35686: "mat2x4<f32>",
  35687: "mat3x2<f32>",
  35675: "mat3x3<f32>",
  35688: "mat3x4<f32>",
  35689: "mat4x2<f32>",
  35690: "mat4x3<f32>",
  35676: "mat4x4<f32>"
}, MP = {
  35678: {
    viewDimension: "2d",
    sampleType: "float"
  },
  35680: {
    viewDimension: "cube",
    sampleType: "float"
  },
  35679: {
    viewDimension: "3d",
    sampleType: "float"
  },
  35682: {
    viewDimension: "3d",
    sampleType: "depth"
  },
  36289: {
    viewDimension: "2d-array",
    sampleType: "float"
  },
  36292: {
    viewDimension: "2d-array",
    sampleType: "depth"
  },
  36293: {
    viewDimension: "cube",
    sampleType: "float"
  },
  36298: {
    viewDimension: "2d",
    sampleType: "sint"
  },
  36299: {
    viewDimension: "3d",
    sampleType: "sint"
  },
  36300: {
    viewDimension: "cube",
    sampleType: "sint"
  },
  36303: {
    viewDimension: "2d-array",
    sampleType: "uint"
  },
  36306: {
    viewDimension: "2d",
    sampleType: "uint"
  },
  36307: {
    viewDimension: "3d",
    sampleType: "uint"
  },
  36308: {
    viewDimension: "cube",
    sampleType: "uint"
  },
  36311: {
    viewDimension: "2d-array",
    sampleType: "uint"
  }
}, ij = {
  uint8: 5121,
  sint8: 5120,
  unorm8: 5121,
  snorm8: 5120,
  uint16: 5123,
  sint16: 5122,
  unorm16: 5123,
  snorm16: 5122,
  uint32: 5125,
  sint32: 5124,
  // WebGPU does not support normalized 32 bit integer attributes
  //  'unorm32': GL.UNSIGNED_INT,
  //  'snorm32': GL.INT,
  float16: 5131,
  float32: 5126
};
function nj(r, e) {
  const t = {
    attributes: [],
    bindings: []
  };
  t.attributes = sj(r, e);
  const i = lj(r, e);
  for (const o of i) {
    const d = o.uniforms.map((m) => ({
      name: m.name,
      format: m.format,
      byteOffset: m.byteOffset,
      byteStride: m.byteStride,
      arrayLength: m.arrayLength
    }));
    t.bindings.push({
      type: "uniform",
      name: o.name,
      group: 0,
      location: o.location,
      visibility: (o.vertex ? 1 : 0) & (o.fragment ? 2 : 0),
      minBindingSize: o.byteLength,
      uniforms: d
    });
  }
  const n = aj(r, e);
  let s = 0;
  for (const o of n)
    if (ej(o.type)) {
      const {
        viewDimension: d,
        sampleType: m
      } = tj(o.type);
      t.bindings.push({
        type: "texture",
        name: o.name,
        group: 0,
        location: s,
        viewDimension: d,
        sampleType: m
      }), o.textureUnit = s, s += 1;
    }
  n.length && (t.uniforms = n);
  const c = oj(r, e);
  return c?.length && (t.varyings = c), t;
}
function sj(r, e) {
  const t = [], i = r.getProgramParameter(e, 35721);
  for (let n = 0; n < i; n++) {
    const s = r.getActiveAttrib(e, n);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: c,
      type: o
      /* , size*/
    } = s, d = r.getAttribLocation(e, c);
    if (d >= 0) {
      const m = wx(o), y = /instance/i.test(c) ? "instance" : "vertex";
      t.push({
        name: c,
        location: d,
        stepMode: y,
        type: m
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return t.sort((n, s) => n.location - s.location), t;
}
function oj(r, e) {
  const t = [], i = r.getProgramParameter(e, 35971);
  for (let n = 0; n < i; n++) {
    const s = r.getTransformFeedbackVarying(e, n);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: c,
      type: o,
      size: d
    } = s, m = wx(o), {
      type: y,
      components: T
    } = tI(m);
    t.push({
      location: n,
      name: c,
      type: y,
      size: d * T
    });
  }
  return t.sort((n, s) => n.location - s.location), t;
}
function aj(r, e) {
  const t = [], i = r.getProgramParameter(e, 35718);
  for (let n = 0; n < i; n++) {
    const s = r.getActiveUniform(e, n);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: c,
      size: o,
      type: d
    } = s, {
      name: m,
      isArray: y
    } = cj(c);
    let T = r.getUniformLocation(e, m);
    const P = {
      // WebGL locations are uniquely typed but just numbers
      location: T,
      name: m,
      size: o,
      type: d,
      isArray: y
    };
    if (t.push(P), P.size > 1)
      for (let I = 0; I < P.size; I++) {
        const D = `${m}[${I}]`;
        T = r.getUniformLocation(e, D);
        const k = {
          ...P,
          name: D,
          location: T
        };
        t.push(k);
      }
  }
  return t;
}
function lj(r, e) {
  const t = (s, c) => r.getActiveUniformBlockParameter(e, s, c), i = [], n = r.getProgramParameter(e, 35382);
  for (let s = 0; s < n; s++) {
    const c = {
      name: r.getActiveUniformBlockName(e, s) || "",
      location: t(s, 35391),
      byteLength: t(s, 35392),
      vertex: t(s, 35396),
      fragment: t(s, 35398),
      uniformCount: t(s, 35394),
      uniforms: []
    }, o = t(s, 35395) || [], d = r.getActiveUniforms(e, o, 35383), m = r.getActiveUniforms(e, o, 35384), y = r.getActiveUniforms(e, o, 35387), T = r.getActiveUniforms(e, o, 35388);
    for (let P = 0; P < c.uniformCount; ++P) {
      const I = r.getActiveUniform(e, o[P]);
      if (!I)
        throw new Error("activeInfo");
      const D = wx(d[P]);
      c.uniforms.push({
        name: I.name,
        format: D,
        type: d[P],
        arrayLength: m[P],
        byteOffset: y[P],
        byteStride: T[P]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    i.push(c);
  }
  return i.sort((s, c) => s.location - c.location), i;
}
function cj(r) {
  if (r[r.length - 1] !== "]")
    return {
      name: r,
      length: 1,
      isArray: !1
    };
  const t = /([^[]*)(\[[0-9]+\])?/.exec(r);
  if (!t || t.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${r}`);
  return {
    name: t[1],
    length: t[2] ? 1 : 0,
    isArray: !!t[2]
  };
}
function uj(r, e, t, i) {
  const n = r;
  let s = i;
  s === !0 && (s = 1), s === !1 && (s = 0);
  const c = typeof s == "number" ? [s] : s;
  switch (t) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof i != "number")
        throw new Error("samplers must be set to integers");
      return r.uniform1i(e, i);
    case 5126:
      return r.uniform1fv(e, c);
    case 35664:
      return r.uniform2fv(e, c);
    case 35665:
      return r.uniform3fv(e, c);
    case 35666:
      return r.uniform4fv(e, c);
    case 5124:
      return r.uniform1iv(e, c);
    case 35667:
      return r.uniform2iv(e, c);
    case 35668:
      return r.uniform3iv(e, c);
    case 35669:
      return r.uniform4iv(e, c);
    case 35670:
      return r.uniform1iv(e, c);
    case 35671:
      return r.uniform2iv(e, c);
    case 35672:
      return r.uniform3iv(e, c);
    case 35673:
      return r.uniform4iv(e, c);
    // WEBGL2 - unsigned integers
    case 5125:
      return n.uniform1uiv(e, c, 1);
    case 36294:
      return n.uniform2uiv(e, c, 2);
    case 36295:
      return n.uniform3uiv(e, c, 3);
    case 36296:
      return n.uniform4uiv(e, c, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return r.uniformMatrix2fv(e, !1, c);
    case 35675:
      return r.uniformMatrix3fv(e, !1, c);
    case 35676:
      return r.uniformMatrix4fv(e, !1, c);
    // WebGL2 - rectangular matrices
    case 35685:
      return n.uniformMatrix2x3fv(e, !1, c);
    case 35686:
      return n.uniformMatrix2x4fv(e, !1, c);
    case 35687:
      return n.uniformMatrix3x2fv(e, !1, c);
    case 35688:
      return n.uniformMatrix3x4fv(e, !1, c);
    case 35689:
      return n.uniformMatrix4x2fv(e, !1, c);
    case 35690:
      return n.uniformMatrix4x3fv(e, !1, c);
  }
  throw new Error("Illegal uniform");
}
function hj(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    default:
      throw new Error(r);
  }
}
function fj(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    default:
      throw new Error(r);
  }
}
const G3 = 4;
class dj extends Gf {
  /** The WebGL device that created this render pipeline */
  device;
  /** Handle to underlying WebGL program */
  handle;
  /** vertex shader */
  vs;
  /** fragment shader */
  fs;
  /** The layout extracted from shader by WebGL introspection APIs */
  introspectedLayout;
  /** Uniforms set on this model */
  uniforms = {};
  /** Bindings set on this model */
  bindings = {};
  /** WebGL varyings */
  varyings = null;
  _uniformCount = 0;
  _uniformSetters = {};
  // TODO are these used?
  get [Symbol.toStringTag]() {
    return "WEBGLRenderPipeline";
  }
  constructor(e, t) {
    super(e, t), this.device = e, this.handle = this.props.handle || this.device.gl.createProgram(), this.device._setWebGLDebugMetadata(this.handle, this, {
      spector: {
        id: this.props.id
      }
    }), this.vs = t.vs, this.fs = t.fs;
    const {
      varyings: i,
      bufferMode: n = 35981
    } = t;
    i && i.length > 0 && (this.varyings = i, this.device.gl.transformFeedbackVaryings(this.handle, i, n)), this._linkShaders(), Ht.time(3, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = nj(this.device.gl, this.handle), Ht.timeEnd(3, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = t.shaderLayout ? pj(this.introspectedLayout, t.shaderLayout) : this.introspectedLayout;
  }
  destroy() {
    this.handle && (this.device.gl.useProgram(null), this.device.gl.deleteProgram(this.handle), this.destroyed = !0, this.handle.destroyed = !0, this.handle = null);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(e, t) {
    for (const [i, n] of Object.entries(e)) {
      const s = this.shaderLayout.bindings.find((c) => c.name === i) || this.shaderLayout.bindings.find((c) => c.name === `${i}Uniforms`);
      if (!s) {
        const c = this.shaderLayout.bindings.map((o) => `"${o.name}"`).join(", ");
        t?.disableWarnings || Ht.warn(`No binding "${i}" in render pipeline "${this.id}", expected one of ${c}`, n)();
        continue;
      }
      switch (n || Ht.warn(`Unsetting binding "${i}" in render pipeline "${this.id}"`)(), s.type) {
        case "uniform":
          if (!(n instanceof Ug) && !(n.buffer instanceof Ug))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(n instanceof np || n instanceof zg || n instanceof Fg))
            throw new Error(`${this} Bad texture binding for ${i}`);
          break;
        case "sampler":
          Ht.warn(`Ignoring sampler ${i}`)();
          break;
        default:
          throw new Error(s.type);
      }
      this.bindings[i] = n;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(e) {
    const {
      renderPass: t,
      parameters: i = this.props.parameters,
      topology: n = this.props.topology,
      vertexArray: s,
      vertexCount: c,
      // indexCount,
      instanceCount: o,
      isInstanced: d = !1,
      firstVertex: m = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: y
    } = e, T = hj(n), P = !!s.indexBuffer, I = s.indexBuffer?.glIndexType;
    if (this.linkStatus !== "success")
      return Ht.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable())
      return Ht.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    this.device.gl.useProgram(this.handle), s.bindBeforeRender(t), y && y.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const D = t;
    return $9(this.device, i, D.glParameters, () => {
      P && d ? this.device.gl.drawElementsInstanced(
        T,
        c || 0,
        // indexCount?
        I,
        m,
        o || 0
      ) : P ? this.device.gl.drawElements(T, c || 0, I, m) : d ? this.device.gl.drawArraysInstanced(T, m, c || 0, o || 0) : this.device.gl.drawArrays(T, m, c || 0), y && y.end();
    }), s.unbindAfterRender(t), !0;
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const {
      gl: e
    } = this.device;
    if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), Ht.time(G3, `linkProgram for ${this.id}`)(), e.linkProgram(this.handle), Ht.timeEnd(G3, `linkProgram for ${this.id}`)(), Ht.level, !this.device.features.has("compilation-status-async-webgl")) {
      const i = this._getLinkStatus();
      this._reportLinkStatus(i);
      return;
    }
    Ht.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), Ht.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const t = this._getLinkStatus();
    this._reportLinkStatus(t);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  async _reportLinkStatus(e) {
    switch (e) {
      case "success":
        return;
      default:
        const t = e === "link-error" ? "Link error" : "Validation error";
        switch (this.vs.compilationStatus) {
          case "error":
            throw this.vs.debugShader(), new Error(`${this} ${t} during compilation of ${this.vs}`);
          case "pending":
            await this.vs.asyncCompilationStatus, this.vs.debugShader();
            break;
        }
        switch (this.fs?.compilationStatus) {
          case "error":
            throw this.fs.debugShader(), new Error(`${this} ${t} during compilation of ${this.fs}`);
          case "pending":
            await this.fs.asyncCompilationStatus, this.fs.debugShader();
            break;
        }
        const i = this.device.gl.getProgramInfoLog(this.handle);
        this.device.reportError(new Error(`${t} during ${e}: ${i}`), this)(), this.device.debug();
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const {
      gl: e
    } = this.device;
    return e.getProgramParameter(this.handle, 35714) ? (e.validateProgram(this.handle), e.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation-error")) : (this.linkStatus = "error", "link-error");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const e = async (n) => await new Promise((s) => setTimeout(s, n));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const {
      gl: i
    } = this.device;
    for (; ; ) {
      if (i.getProgramParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let e = !0;
    for (const t of this.shaderLayout.bindings)
      !this.bindings[t.name] && !this.bindings[t.name.replace(/Uniforms$/, "")] && (Ht.warn(`Binding ${t.name} not found in ${this.id}`)(), e = !1);
    return e;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const {
      gl: e
    } = this.device;
    e.useProgram(this.handle);
    let t = 0, i = 0;
    for (const n of this.shaderLayout.bindings) {
      const s = this.bindings[n.name] || this.bindings[n.name.replace(/Uniforms$/, "")];
      if (!s)
        throw new Error(`No value for binding ${n.name} in ${this.id}`);
      switch (n.type) {
        case "uniform":
          const {
            name: c
          } = n, o = e.getUniformBlockIndex(this.handle, c);
          if (o === 4294967295)
            throw new Error(`Invalid uniform block name ${c}`);
          e.uniformBlockBinding(this.handle, i, o), s instanceof Ug ? e.bindBufferBase(35345, i, s.handle) : e.bindBufferRange(
            35345,
            i,
            // @ts-expect-error
            s.buffer.handle,
            // @ts-expect-error
            s.offset || 0,
            // @ts-expect-error
            s.size || s.buffer.byteLength - s.offset
          ), i += 1;
          break;
        case "texture":
          if (!(s instanceof np || s instanceof zg || s instanceof Fg))
            throw new Error("texture");
          let d;
          if (s instanceof np)
            d = s.texture;
          else if (s instanceof zg)
            d = s;
          else if (s instanceof Fg && s.colorAttachments[0] instanceof np)
            Ht.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), d = s.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          e.activeTexture(33984 + t), e.bindTexture(d.glTarget, d.handle), t += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${n.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const e of this.shaderLayout.uniforms || []) {
      const {
        name: t,
        location: i,
        type: n,
        textureUnit: s
      } = e, c = this.uniforms[t] ?? s;
      c !== void 0 && uj(this.device.gl, i, n, c);
    }
  }
}
function pj(r, e) {
  const t = {
    ...r,
    attributes: r.attributes.map((i) => ({
      ...i
    }))
  };
  for (const i of e?.attributes || []) {
    const n = t.attributes.find((s) => s.name === i.name);
    n ? (n.type = i.type || n.type, n.stepMode = i.stepMode || n.stepMode) : Ht.warn(`shader layout attribute ${i.name} not present in shader`);
  }
  return t;
}
class gj extends O2 {
  device;
  handle = null;
  commands = [];
  constructor(e) {
    super(e, {}), this.device = e;
  }
  _executeCommands(e = this.commands) {
    for (const t of e)
      switch (t.name) {
        case "copy-buffer-to-buffer":
          mj(this.device, t.options);
          break;
        case "copy-buffer-to-texture":
          _j(this.device, t.options);
          break;
        case "copy-texture-to-buffer":
          yj(this.device, t.options);
          break;
        case "copy-texture-to-texture":
          bj(this.device, t.options);
          break;
        // case 'clear-texture':
        //   _clearTexture(this.device, command.options);
        //   break;
        default:
          throw new Error(t.name);
      }
  }
}
function mj(r, e) {
  const t = e.sourceBuffer, i = e.destinationBuffer;
  r.gl.bindBuffer(36662, t.handle), r.gl.bindBuffer(36663, i.handle), r.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), r.gl.bindBuffer(36662, null), r.gl.bindBuffer(36663, null);
}
function _j(r, e) {
  throw new Error("Not implemented");
}
function yj(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: i = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: n = "all",
    /** Width to copy */
    width: s = e.sourceTexture.width,
    /** Height to copy */
    height: c = e.sourceTexture.height,
    depthOrArrayLayers: o = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: d = [0, 0],
    /** Destination buffer */
    destinationBuffer: m,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: y = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: T,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: P
  } = e;
  if (n !== "all")
    throw new Error("aspect not supported in WebGL");
  if (i !== 0 || o !== 0 || T || P)
    throw new Error("not implemented");
  const {
    framebuffer: I,
    destroyFramebuffer: D
  } = RP(t);
  let k;
  try {
    const $ = m, G = s || I.width, te = c || I.height, Z = IP(I.colorAttachments[0].texture.props.format), H = Z.format, J = Z.type;
    r.gl.bindBuffer(35051, $.handle), k = r.gl.bindFramebuffer(36160, I.handle), r.gl.readPixels(d[0], d[1], G, te, H, J, y);
  } finally {
    r.gl.bindBuffer(35051, null), k !== void 0 && r.gl.bindFramebuffer(36160, k), D && I.destroy();
  }
}
function bj(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: i = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: n = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: s = [0, 0],
    /** Texture to copy to/from. */
    destinationTexture: c
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = e;
  let {
    width: o = e.destinationTexture.width,
    height: d = e.destinationTexture.height
    // depthOrArrayLayers = 0
  } = e;
  const {
    framebuffer: m,
    destroyFramebuffer: y
  } = RP(t), [T, P] = n, [I, D, k] = s, $ = r.gl.bindFramebuffer(36160, m.handle);
  let G, te;
  if (c instanceof zg)
    G = c, o = Number.isFinite(o) ? o : G.width, d = Number.isFinite(d) ? d : G.height, G._bind(0), te = G.glTarget;
  else
    throw new Error("invalid destination");
  switch (te) {
    case 3553:
    case 34067:
      r.gl.copyTexSubImage2D(te, i, I, D, T, P, o, d);
      break;
    case 35866:
    case 32879:
      r.gl.copyTexSubImage3D(te, i, I, D, k, T, P, o, d);
      break;
  }
  G && G._unbind(), r.gl.bindFramebuffer(36160, $), y && m.destroy();
}
function RP(r) {
  if (r instanceof Fs) {
    const {
      width: e,
      height: t,
      id: i
    } = r;
    return {
      framebuffer: r.device.createFramebuffer({
        id: `framebuffer-for-${i}`,
        width: e,
        height: t,
        colorAttachments: [r]
      }),
      destroyFramebuffer: !0
    };
  }
  return {
    framebuffer: r,
    destroyFramebuffer: !1
  };
}
const vj = [1, 2, 4, 8];
class xj extends Mf {
  device;
  handle = null;
  /** Parameters that should be applied before each draw call */
  glParameters = {};
  constructor(e, t) {
    super(e, t), this.device = e;
    let i;
    if (!t?.parameters?.viewport)
      if (t?.framebuffer) {
        const {
          width: s,
          height: c
        } = t.framebuffer;
        i = [0, 0, s, c];
      } else {
        const [s, c] = e.getDefaultCanvasContext().getDrawingBufferSize();
        i = [0, 0, s, c];
      }
    this.device.pushState(), this.setParameters({
      viewport: i,
      ...this.props.parameters
    });
    const n = this.props.framebuffer;
    if (this.props.framebuffer && n?.handle) {
      const s = this.props.framebuffer.colorAttachments.map((c, o) => 36064 + o);
      this.device.gl.drawBuffers(s);
    } else
      this.device.gl.drawBuffers([1029]);
    this.clear();
  }
  end() {
    this.device.popState();
  }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(e = {}) {
    const t = {
      ...this.glParameters
    };
    t.framebuffer = this.props.framebuffer || null, this.props.depthReadOnly && (t.depthMask = !this.props.depthReadOnly), t.stencilMask = this.props.stencilReadOnly ? 0 : 1, t[35977] = this.props.discard, e.viewport && (e.viewport.length >= 6 ? (t.viewport = e.viewport.slice(0, 4), t.depthRange = [e.viewport[4], e.viewport[5]]) : t.viewport = e.viewport), e.scissorRect && (t.scissorTest = !0, t.scissor = e.scissorRect), e.blendConstant && (t.blendColor = e.blendConstant), e.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), t[2967] = e.stencilReference), "colorMask" in e && (t.colorMask = vj.map((i) => !!(i & e.colorMask))), this.glParameters = t, Up(this.device.gl, t);
  }
  beginOcclusionQuery(e) {
    this.props.occlusionQuerySet?.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    this.props.occlusionQuerySet?.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const e = {
      ...this.glParameters
    };
    let t = 0;
    this.props.clearColors && this.props.clearColors.forEach((i, n) => {
      i && this.clearColorBuffer(n, i);
    }), this.props.clearColor !== !1 && this.props.clearColors === void 0 && (t |= 16384, e.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (t |= 256, e.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (t |= 1024, e.clearStencil = this.props.clearStencil), t !== 0 && em(this.device.gl, e, () => {
      this.device.gl.clear(t);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(e = 0, t = [0, 0, 0, 0]) {
    em(this.device.gl, {
      framebuffer: this.props.framebuffer
    }, () => {
      switch (t.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
          this.device.gl.clearBufferiv(6144, e, t);
          break;
        case Uint8Array:
        case Uint8ClampedArray:
        case Uint16Array:
        case Uint32Array:
          this.device.gl.clearBufferuiv(6144, e, t);
          break;
        case Float32Array:
          this.device.gl.clearBufferfv(6144, e, t);
          break;
        default:
          throw new Error("clearColorBuffer: color must be typed array");
      }
    });
  }
}
class $3 extends k2 {
  device;
  handle = null;
  commandBuffer;
  constructor(e, t) {
    super(e, t), this.device = e, this.commandBuffer = new gj(e);
  }
  destroy() {
  }
  finish() {
    return this.commandBuffer;
  }
  beginRenderPass(e) {
    return new xj(this.device, e);
  }
  beginComputePass(e) {
    throw new Error("ComputePass not supported in WebGL");
  }
  copyBufferToBuffer(e) {
    this.commandBuffer.commands.push({
      name: "copy-buffer-to-buffer",
      options: e
    });
  }
  copyBufferToTexture(e) {
    this.commandBuffer.commands.push({
      name: "copy-buffer-to-texture",
      options: e
    });
  }
  copyTextureToBuffer(e) {
    this.commandBuffer.commands.push({
      name: "copy-texture-to-buffer",
      options: e
    });
  }
  copyTextureToTexture(e) {
    this.commandBuffer.commands.push({
      name: "copy-texture-to-texture",
      options: e
    });
  }
  // clearTexture(options: ClearTextureOptions): void {
  //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
  // }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  resolveQuerySet(e, t, i) {
  }
}
function wj(r) {
  const {
    target: e,
    source: t,
    start: i = 0,
    count: n = 1
  } = r, s = t.length, c = n * s;
  let o = 0;
  for (let d = i; o < s; o++)
    e[d++] = t[o];
  for (; o < c; )
    o < c - o ? (e.copyWithin(i + o, i, i + o), o *= 2) : (e.copyWithin(i + o, i, i + c - o), o = c);
  return r.target;
}
class Ax extends D2 {
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  device;
  handle;
  /** Attribute 0 buffer constant */
  buffer = null;
  bufferValue = null;
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(e) {
    return ZB() === "Chrome";
  }
  // Create a VertexArray
  constructor(e, t) {
    super(e, t), this.device = e, this.handle = this.device.gl.createVertexArray();
  }
  destroy() {
    super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(e) {
    const t = e;
    if (t && t.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, t ? t.handle : null), this.indexBuffer = t, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(e, t) {
    const i = t;
    if (i.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const {
      size: n,
      type: s,
      stride: c,
      offset: o,
      normalized: d,
      integer: m,
      divisor: y
    } = this._getAccessor(e);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, i.handle), m ? this.device.gl.vertexAttribIPointer(e, n, s, c, o) : this.device.gl.vertexAttribPointer(e, n, s, d, c, o), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(e), this.device.gl.vertexAttribDivisor(e, y || 0), this.attributes[e] = i, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(e, t) {
    this._enable(e, !1), this.attributes[e] = t;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let e = 0; e < this.maxVertexAttributes; ++e) {
      const t = this.attributes[e];
      ArrayBuffer.isView(t) && this.device.setConstantAttributeWebGL(e, t);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(e) {
    const t = this.attributeInfos[e];
    if (!t)
      throw new Error(`Unknown attribute location ${e}`);
    const i = CP(t.bufferDataType);
    return {
      size: t.bufferComponents,
      type: i,
      stride: t.byteStride,
      offset: t.byteOffset,
      normalized: t.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: t.integer,
      divisor: t.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(e, t = !0) {
    const n = Ax.isConstantAttributeZeroSupported(this.device) || e !== 0;
    (t || n) && (e = Number(e), this.device.gl.bindVertexArray(this.handle), t ? this.device.gl.enableVertexAttribArray(e) : this.device.gl.disableVertexAttribArray(e), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(e, t) {
    const i = Aj(t), n = i.byteLength * e, s = i.length * e;
    if (this.buffer && n !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${n} !== ${this.buffer.byteLength}.`);
    let c = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({
      byteLength: n
    }), c ||= !Tj(i, this.bufferValue), c) {
      const o = HD(t.constructor, s);
      wj({
        target: o,
        source: i,
        start: 0,
        count: s
      }), this.buffer.write(o), this.bufferValue = t;
    }
    return this.buffer;
  }
}
function Aj(r) {
  return Array.isArray(r) ? new Float32Array(r) : r;
}
function Tj(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
class Sj extends N2 {
  device;
  gl;
  handle;
  /**
   * NOTE: The Model already has this information while drawing, but
   * TransformFeedback currently needs it internally, to look up
   * varying information outside of a draw() call.
   */
  layout;
  buffers = {};
  unusedBuffers = {};
  /**
   * Allows us to avoid a Chrome bug where a buffer that is already bound to a
   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
   */
  bindOnUse = !0;
  _bound = !1;
  constructor(e, t) {
    super(e, t), this.device = e, this.gl = e.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, t.buffers && this.setBuffers(t.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin(e = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(fj(e));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(e) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const t in e)
        this.setBuffer(t, e[t]);
    });
  }
  setBuffer(e, t) {
    const i = this._getVaryingIndex(e), {
      buffer: n,
      byteLength: s,
      byteOffset: c
    } = this._getBufferRange(t);
    if (i < 0) {
      this.unusedBuffers[e] = n, Ht.warn(`${this.id} unusedBuffers varying buffer ${e}`)();
      return;
    }
    this.buffers[i] = {
      buffer: n,
      byteLength: s,
      byteOffset: c
    }, this.bindOnUse || this._bindBuffer(i, n, c, s);
  }
  getBuffer(e) {
    if (H3(e))
      return this.buffers[e] || null;
    const t = this._getVaryingIndex(e);
    return t >= 0 ? this.buffers[t] : null;
  }
  bind(e = this.handle) {
    if (typeof e != "function")
      return this.gl.bindTransformFeedback(36386, e), this;
    let t;
    return this._bound ? t = e() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, t = e(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), t;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(e) {
    if (e instanceof Ug)
      return {
        buffer: e,
        byteOffset: 0,
        byteLength: e.byteLength
      };
    const {
      buffer: t,
      byteOffset: i = 0,
      byteLength: n = e.buffer.byteLength
    } = e;
    return {
      buffer: t,
      byteOffset: i,
      byteLength: n
    };
  }
  _getVaryingIndex(e) {
    if (H3(e))
      return Number(e);
    for (const t of this.layout.varyings || [])
      if (e === t.name)
        return t.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const e in this.buffers) {
      const {
        buffer: t,
        byteLength: i,
        byteOffset: n
      } = this._getBufferRange(this.buffers[e]);
      this._bindBuffer(Number(e), t, n, i);
    }
  }
  _unbindBuffers() {
    for (const e in this.buffers)
      this.gl.bindBufferBase(35982, Number(e), null);
  }
  _bindBuffer(e, t, i = 0, n) {
    const s = t && t.handle;
    !s || n === void 0 ? this.gl.bindBufferBase(35982, e, s) : this.gl.bindBufferRange(35982, e, s, i, n);
  }
}
function H3(r) {
  return typeof r == "number" ? Number.isInteger(r) : /^\d+$/.test(r);
}
class Ej extends F2 {
  device;
  handle;
  target = null;
  _queryPending = !1;
  _pollingPromise = null;
  get [Symbol.toStringTag]() {
    return "Query";
  }
  // Create a query class
  constructor(e, t) {
    if (super(e, t), this.device = e, t.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    const i = this.device.gl.createQuery();
    if (!i)
      throw new Error("WebGL query not supported");
    this.handle = i, Object.seal(this);
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(e) {
    return this._begin(e?.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(e) {
    this._queryPending || (this.target = e, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const e = this.device.gl.getQueryParameter(this.handle, 34919);
    return e && (this._queryPending = !1), e;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(e = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise)
      return this._pollingPromise;
    let t = 0;
    return this._pollingPromise = new Promise((i, n) => {
      const s = () => {
        this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : t++ > e ? (n("Timed out"), this._pollingPromise = null) : requestAnimationFrame(s);
      };
      requestAnimationFrame(s);
    }), this._pollingPromise;
  }
}
function LP(r) {
  switch (r) {
    case 6406:
    case 33326:
    case 6403:
    case 36244:
      return 1;
    case 33339:
    case 33340:
    case 33328:
    case 33320:
    case 33319:
      return 2;
    case 6407:
    case 36248:
    case 34837:
      return 3;
    case 6408:
    case 36249:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      return 0;
  }
}
function Cj(r) {
  switch (r) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      return 0;
  }
}
function Ij(r) {
  return Pj[r];
}
const Pj = {
  5124: "sint32",
  5125: "uint32",
  5122: "sint16",
  5123: "uint16",
  5120: "sint8",
  5121: "uint8",
  5126: "float32",
  5131: "float16",
  33635: "uint16",
  32819: "uint16",
  32820: "uint16",
  33640: "uint32",
  35899: "uint32",
  35902: "uint32",
  34042: "uint32",
  36269: "uint32"
};
function Mj(r, e) {
  const {
    sourceX: t = 0,
    sourceY: i = 0,
    sourceAttachment: n = 0
    // TODO - support gl.readBuffer
  } = e || {};
  let {
    target: s = null,
    // following parameters are auto deduced if not provided
    sourceWidth: c,
    sourceHeight: o,
    sourceDepth: d,
    sourceFormat: m,
    sourceType: y
  } = e || {};
  const {
    framebuffer: T,
    deleteFramebuffer: P
  } = BP(r), {
    gl: I,
    handle: D
  } = T;
  c ||= T.width, o ||= T.height;
  const k = T.colorAttachments[n]?.texture;
  if (!k)
    throw new Error(`Invalid framebuffer attachment ${n}`);
  d = k?.depth || 1, m ||= k?.glFormat || 6408, y ||= k?.glType || 5121, s = Bj(s, y, m, c, o);
  const $ = M2(s);
  y = y || Q9($);
  const G = I.bindFramebuffer(36160, D);
  return I.readBuffer(36064 + n), I.readPixels(t, i, c, o, m, y, s), I.readBuffer(36064), I.bindFramebuffer(36160, G || null), P && T.destroy(), s;
}
function Rj(r, e) {
  const {
    target: t,
    sourceX: i = 0,
    sourceY: n = 0,
    sourceFormat: s = 6408,
    targetByteOffset: c = 0
  } = e || {};
  let {
    sourceWidth: o,
    sourceHeight: d,
    sourceType: m
  } = e || {};
  const {
    framebuffer: y,
    deleteFramebuffer: T
  } = BP(r);
  o = o || y.width, d = d || y.height;
  const P = y;
  m = m || 5121;
  let I = t;
  if (!I) {
    const k = LP(s), $ = Cj(m), G = c + o * d * k * $;
    I = P.device.createBuffer({
      byteLength: G
    });
  }
  const D = r.device.createCommandEncoder();
  return D.copyTextureToBuffer({
    sourceTexture: r,
    width: o,
    height: d,
    origin: [i, n],
    destinationBuffer: I,
    byteOffset: c
  }), D.destroy(), T && y.destroy(), I;
}
function BP(r) {
  return r instanceof Qy ? {
    framebuffer: r,
    deleteFramebuffer: !1
  } : {
    framebuffer: Lj(r),
    deleteFramebuffer: !0
  };
}
function Lj(r, e) {
  const {
    device: t,
    width: i,
    height: n,
    id: s
  } = r;
  return t.createFramebuffer({
    ...e,
    id: `framebuffer-for-${s}`,
    width: i,
    height: n,
    colorAttachments: [r]
  });
}
function Bj(r, e, t, i, n, s) {
  if (r)
    return r;
  e ||= 5121;
  const c = Ij(e), o = R2(c), d = LP(t);
  return new o(i * n * d);
}
class Lv extends Yf {
  // Public `Device` API
  /** type of this device */
  type = "webgl";
  // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
  /** The underlying WebGL context */
  handle;
  features;
  limits;
  info;
  canvasContext;
  preferredColorFormat = "rgba8unorm";
  preferredDepthFormat = "depth24plus";
  commandEncoder;
  lost;
  _resolveContextLost;
  /** WebGL2 context. */
  gl;
  /** Store constants */
  // @ts-ignore TODO fix
  _constants;
  /** State used by luma.gl classes - TODO - not used? */
  _extensions = {};
  _polyfilled = !1;
  /** Instance of Spector.js (if initialized) */
  spectorJS;
  //
  // Public API
  //
  get [Symbol.toStringTag]() {
    return "WebGLDevice";
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  isVertexFormatSupported(e) {
    switch (e) {
      case "unorm8x4-bgra":
        return !1;
      default:
        return !0;
    }
  }
  constructor(e) {
    super({
      ...e,
      id: e.id || U9("webgl-device")
    });
    const t = Yf._getCanvasContextProps(e);
    if (!t)
      throw new Error("WebGLDevice requires props.createCanvasContext to be set");
    let i = t.canvas?.gl?.device;
    if (i)
      throw new Error(`WebGL context already attached to device ${i.id}`);
    this.canvasContext = new F9(this, t), this.lost = new Promise((y) => {
      this._resolveContextLost = y;
    });
    const n = {
      ...e.webgl
    };
    t.alphaMode === "premultiplied" && (n.premultipliedAlpha = !0), e.powerPreference !== void 0 && (n.powerPreference = e.powerPreference);
    const c = this.props._handle || y9(this.canvasContext.canvas, {
      onContextLost: (y) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
      }),
      // eslint-disable-next-line no-console
      onContextRestored: (y) => console.log("WebGL context restored")
    }, n);
    if (!c)
      throw new Error("WebGL context creation failed");
    if (i = c.device, i) {
      if (e._reuseDevices)
        return Ht.log(1, `Not creating a new Device, instead returning a reference to Device ${i.id} already attached to WebGL context`, i)(), i._reused = !0, i;
      throw new Error(`WebGL context already attached to device ${i.id}`);
    }
    this.handle = c, this.gl = c, this.spectorJS = e9({
      ...this.props,
      gl: this.handle
    }), this.gl.device = this, this.gl._version = 2, this.info = b9(this.gl, this._extensions), this.limits = new O9(this.gl), this.features = new k9(this.gl, this._extensions, this.props._disabledFeatures), this.props._initializeFeatures && this.features.initializeFeatures(), new Hf(this.gl, {
      log: (...y) => Ht.log(1, ...y)()
    }).trackState(this.gl, {
      copyState: !1
    });
    const d = e.debugWebGL || e.debug, m = e.debugWebGL;
    d && (this.gl = i9(this.gl, {
      debugWebGL: d,
      traceWebGL: m
    }), Ht.warn("WebGL debug mode activated. Performance reduced.")(), e.debugWebGL && (Ht.level = Math.max(Ht.level, 1))), this.commandEncoder = new $3(this, {
      id: `${this}-command-encoder`
    });
  }
  /**
   * Destroys the device
   *
   * @note "Detaches" from the WebGL context unless _reuseDevices is true.
   *
   * @note The underlying WebGL context is not immediately destroyed,
   * but may be destroyed later through normal JavaScript garbage collection.
   * This is a fundamental limitation since WebGL does not offer any
   * browser API for destroying WebGL contexts.
   */
  destroy() {
    !this.props._reuseDevices && !this._reused && delete this.gl.device;
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  getTextureByteAlignment() {
    return 4;
  }
  createCanvasContext(e) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(e) {
    const t = this._normalizeBufferProps(e);
    return new Ug(this, t);
  }
  createTexture(e) {
    return new zg(this, e);
  }
  createExternalTexture(e) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(e) {
    return new Y9(this, e);
  }
  createShader(e) {
    return new G9(this, e);
  }
  createFramebuffer(e) {
    return new Fg(this, e);
  }
  createVertexArray(e) {
    return new Ax(this, e);
  }
  createTransformFeedback(e) {
    return new Sj(this, e);
  }
  createQuerySet(e) {
    return new Ej(this, e);
  }
  createRenderPipeline(e) {
    return new dj(this, e);
  }
  createComputePipeline(e) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  createCommandEncoder(e = {}) {
    return new $3(this, e);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit(e) {
    e || (e = this.commandEncoder.finish(), this.commandEncoder.destroy(), this.commandEncoder = this.createCommandEncoder({
      id: `${this.id}-default-encoder`
    })), e._executeCommands();
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(e, t) {
    return Mj(e, t);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(e, t) {
    return Rj(e, t);
  }
  setParametersWebGL(e) {
    Up(this.gl, e);
  }
  getParametersWebGL(e) {
    return SP(this.gl, e);
  }
  withParametersWebGL(e, t) {
    return em(this.gl, e, t);
  }
  resetWebGL() {
    Ht.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), d9(this.gl);
  }
  _getDeviceSpecificTextureFormatCapabilities(e) {
    return M9(this.gl, e, this._extensions);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    let e = !1;
    const i = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return i && (e = !0, i.loseContext()), this._resolveContextLost?.({
      reason: "destroyed",
      message: "Application triggered context loss"
    }), e;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    Hf.get(this.gl).push();
  }
  /** Restores previously saved context state */
  popState() {
    Hf.get(this.gl).pop();
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(e, t) {
    const i = Number(e);
    for (const n in this.gl)
      if (this.gl[n] === i)
        return `GL.${n}`;
    return t?.emptyIfUnknown ? "" : String(e);
  }
  /**
   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
   */
  getGLKeys(e) {
    const t = {
      emptyIfUnknown: !0
    };
    return Object.entries(e).reduce((i, [n, s]) => (i[`${n}:${this.getGLKey(n, t)}`] = `${s}:${this.getGLKey(s, t)}`, i), {});
  }
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(e, t) {
    const i = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(i).fill(null);
    const n = this._constants[e];
    switch (n && Nj(n, t) && Ht.info(1, `setConstantAttributeWebGL(${e}) could have been skipped, value unchanged`)(), this._constants[e] = t, t.constructor) {
      case Float32Array:
        kj(this, e, t);
        break;
      case Int32Array:
        Oj(this, e, t);
        break;
      case Uint32Array:
        Dj(this, e, t);
        break;
      default:
        throw new Error("constant");
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(e) {
    return Sp(this.gl, e, this._extensions), this._extensions;
  }
  // INTERNAL SUPPORT METHODS FOR WEBGL RESOURCES
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  _setWebGLDebugMetadata(e, t, i) {
    e.luma = t;
    const n = {
      props: i.spector,
      id: i.spector.id
    };
    e.__SPECTOR_Metadata = n;
  }
}
function kj(r, e, t) {
  switch (t.length) {
    case 1:
      r.gl.vertexAttrib1fv(e, t);
      break;
    case 2:
      r.gl.vertexAttrib2fv(e, t);
      break;
    case 3:
      r.gl.vertexAttrib3fv(e, t);
      break;
    case 4:
      r.gl.vertexAttrib4fv(e, t);
      break;
  }
}
function Oj(r, e, t) {
  r.gl.vertexAttribI4iv(e, t);
}
function Dj(r, e, t) {
  r.gl.vertexAttribI4uiv(e, t);
}
function Nj(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
const q3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WebGLDevice: Lv
}, Symbol.toStringTag, { value: "Module" }));
function Rh() {
}
const Fj = ({
  isDragging: r
}) => r ? "grabbing" : "grab", kP = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: {},
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: Rh,
  onWebGLInitialized: Rh,
  onResize: Rh,
  onViewStateChange: Rh,
  onInteractionStateChange: Rh,
  onBeforeRender: Rh,
  onAfterRender: Rh,
  onLoad: Rh,
  onError: (r) => Ni.error(r.message, r.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: Fj,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class tm {
  constructor(e) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new kp({
      id: "deck.gl"
    }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (i) => {
      const {
        _pickRequest: n
      } = this;
      if (i.type === "pointerleave")
        n.x = -1, n.y = -1, n.radius = 0;
      else {
        if (i.leftButton || i.rightButton)
          return;
        {
          const s = i.offsetCenter;
          if (!s)
            return;
          n.x = s.x, n.y = s.y, n.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = {
        x: n.x,
        y: n.y
      }), n.event = i;
    }, this._onEvent = (i) => {
      const n = xv[i.type], s = i.offsetCenter;
      if (!n || !s || !this.layerManager)
        return;
      const c = this.layerManager.getLayers(), o = this.deckPicker.getLastPickedObject({
        x: s.x,
        y: s.y,
        layers: c,
        viewports: this.getViewports(s)
      }, this._lastPointerDownInfo), {
        layer: d
      } = o, m = d && (d[n] || d.props[n]), y = this.props[n];
      let T = !1;
      m && (T = m.call(d, o, i)), T || (y?.(o, i), this.widgetManager.onEvent(o, i));
    }, this._onPointerDown = (i) => {
      if (this.device?.type === "webgpu")
        return;
      const n = i.offsetCenter, s = this._pick("pickObject", "pickObject Time", {
        x: n.x,
        y: n.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = s.result[0] || s.emptyInfo;
    }, this.props = {
      ...kP,
      ...e
    }, e = this.props, e.viewState && e.initialViewState && Ni.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device && (this.device = e.device);
    let t = this.device;
    !t && e.gl && (e.gl instanceof WebGLRenderingContext && Ni.error("WebGL1 context not supported.")(), t = Db.attach(e.gl, this.props.deviceProps)), t || (t = this._createDevice(e)), this.animationLoop = this._createAnimationLoop(t, e), this.setProps(e), e._typedArrayManagerProps && Qg.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(e) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && Ni.removed("onLayerHover", "onHover")(), "onLayerClick" in e && Ni.removed("onLayerClick", "onClick")(), e.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !Rl(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const t = Object.create(this.props);
    if (Object.assign(t, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), e.device && e.device.id !== this.device?.id && (this.animationLoop?.stop(), this.canvas !== e.device.canvasContext?.canvas && (this.canvas?.remove(), this.eventManager?.destroy(), this.canvas = null), Ni.log(`recreating animation loop for new device! id=${e.device.id}`)(), this.animationLoop = this._createAnimationLoop(e.device, e), this.animationLoop.start()), this.animationLoop?.setProps(t), e.useDevicePixels !== void 0 && this.device?.canvasContext?.canvas instanceof HTMLCanvasElement) {
      this.device.canvasContext.props.useDevicePixels = e.useDevicePixels;
      const i = this.device.canvasContext.canvas, n = {
        target: i,
        contentBoxSize: [{
          inlineSize: i.clientWidth,
          blockSize: i.clientHeight
        }],
        devicePixelContentBoxSize: [{
          inlineSize: i.clientWidth,
          blockSize: i.clientHeight
        }],
        borderBoxSize: [{
          inlineSize: i.clientWidth,
          blockSize: i.clientHeight
        }]
      };
      this.device.canvasContext._handleResize([n]);
    }
    this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t), this.widgetManager.setProps(t)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(e = {
    clearRedrawFlags: !1
  }) {
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const i = this.viewManager.needsRedraw(e), n = this.layerManager.needsRedraw(e), s = this.effectManager.needsRedraw(e), c = this.deckRenderer.needsRedraw(e);
    return t = t || i || n || s || c, t;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(e) {
    if (!this.layerManager)
      return;
    let t = this.needsRedraw({
      clearRedrawFlags: !0
    });
    t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return Ks(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(e) {
    return Ks(this.viewManager), this.viewManager.getViewports(e);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(e) {
    const t = this._pick("pickObject", "pickObject Time", e).result;
    return t.length ? t[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(e, t = !1) {
    for (const i in e)
      this.layerManager.resourceManager.add({
        resourceId: i,
        data: e[i],
        forceUpdate: t
      });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(e) {
    for (const t of e)
      this.layerManager.resourceManager.remove(t);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _addDefaultShaderModule(e) {
    this.layerManager.addDefaultShaderModule(e);
  }
  _removeDefaultShaderModule(e) {
    this.layerManager?.removeDefaultShaderModule(e);
  }
  _pick(e, t, i) {
    Ks(this.deckPicker);
    const {
      stats: n
    } = this;
    n.get("Pick Count").incrementCount(), n.get(t).timeStart();
    const s = this.deckPicker[e]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(i),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(i),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...i
    });
    return n.get(t).timeEnd(), s;
  }
  /** Resolve props.canvas to element */
  _createCanvas(e) {
    let t = e.canvas;
    return typeof t == "string" && (t = document.getElementById(t), Ks(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", e.width && typeof e.width == "number" && (t.width = e.width), e.height && typeof e.height == "number" && (t.height = e.height), (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(e) {
    if (!this.canvas)
      return;
    const {
      width: t,
      height: i
    } = e;
    if (t || t === 0) {
      const n = Number.isFinite(t) ? `${t}px` : t;
      this.canvas.style.width = n;
    }
    if (i || i === 0) {
      const n = Number.isFinite(i) ? `${i}px` : i;
      this.canvas.style.position = e.style?.position || "absolute", this.canvas.style.height = n;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    const {
      canvas: e
    } = this;
    if (!e)
      return;
    const t = e.clientWidth ?? e.width, i = e.clientHeight ?? e.height;
    (t !== this.width || i !== this.height) && (this.width = t, this.height = i, this.viewManager?.setProps({
      width: t,
      height: i
    }), this.layerManager?.activateViewport(this.getViewports()[0]), this.props.onResize({
      width: t,
      height: i
    }));
  }
  _createAnimationLoop(e, t) {
    const {
      // width,
      // height,
      gl: i,
      // debug,
      onError: n
      // onBeforeRender,
      // onAfterRender,
    } = t;
    return new fx({
      device: e,
      // TODO v9
      autoResizeDrawingBuffer: !i,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (s) => this._setDevice(s.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: n
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Create a device from the deviceProps, assigning required defaults
  _createDevice(e) {
    const t = this.props.deviceProps?.createCanvasContext, i = typeof t == "object" ? t : void 0, n = {
      adapters: [],
      ...e.deviceProps
    };
    n.adapters.includes(Db) || n.adapters.push(Db);
    const s = {
      // we must use 'premultiplied' canvas for webgpu to enable transparency and match shaders
      alphaMode: this.props.deviceProps?.type === "webgpu" ? "premultiplied" : void 0
    };
    return uv.createDevice({
      // luma by default throws if a device is already attached
      // asynchronous device creation could happen after finalize() is called
      // TODO - createDevice should support AbortController?
      _reuseDevices: !0,
      // tests can't handle WebGPU devices yet so we force WebGL2 unless overridden
      type: "webgl",
      ...n,
      // In deck.gl v10 we may emphasize multi canvas support and unwind this prop wrapping
      createCanvasContext: {
        ...s,
        ...i,
        canvas: this._createCanvas(e),
        useDevicePixels: this.props.useDevicePixels,
        autoResize: !0
      }
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const {
      views: e
    } = this.props, t = Array.isArray(e) ? e : (
      // If null, default to a full screen map view port
      e ? [e] : [new mx({
        id: "default-view"
      })]
    );
    return t.length && this.props.controller && (t[0].props.controller = this.props.controller), t;
  }
  _onContextLost() {
    const {
      onError: e
    } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    if (this.device?.type === "webgpu")
      return;
    const {
      _pickRequest: e
    } = this;
    if (e.event) {
      const {
        result: t,
        emptyInfo: i
      } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = t.length > 0;
      let n = i, s = !1;
      for (const c of t)
        n = c, s = c.layer?.onHover(c, e.event) || s;
      s || (this.props.onHover?.(n, e.event), this.widgetManager.onHover(n, e.event)), e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(e) {
    if (this.device = e, !this.animationLoop)
      return;
    this.canvas || (this.canvas = this.device.canvasContext?.canvas, !this.canvas.isConnected && this.props.parent && this.props.parent.insertBefore(this.canvas, this.props.parent.firstChild)), this.device.type === "webgl" && this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device.type === "webgl" && this.props.onWebGLInitialized(this.device.gl);
    const t = new gP();
    t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new wU(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizers: Object.keys(l3).map((n) => {
        const [s, c, o, d] = l3[n], m = this.props.eventRecognizerOptions?.[n], y = {
          ...c,
          ...m,
          event: n
        };
        return {
          recognizer: new s(y),
          recognizeWith: o,
          requestFailure: d
        };
      }),
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const n in xv)
      this.eventManager.on(n, this._onEvent);
    this.viewManager = new v7({
      timeline: t,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const i = this.viewManager.getViewports()[0];
    this.layerManager = new b7(this.device, {
      deck: this,
      stats: this.stats,
      viewport: i,
      timeline: t
    }), this.effectManager = new k7({
      deck: this,
      device: this.device
    }), this.deckRenderer = new N7(this.device), this.deckPicker = new z7(this.device), this.widgetManager = new G7({
      deck: this,
      parentElement: this.canvas?.parentElement
    }), this.widgetManager.addDefault(new wP()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(e, t) {
    const {
      device: i,
      gl: n
    } = this.layerManager.context;
    this.props.onBeforeRender({
      device: i,
      gl: n
    });
    const s = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...t
    };
    this.deckRenderer?.renderLayers(s), s.pass === "screen" && this.widgetManager.onRedraw({
      viewports: s.viewports,
      layers: s.layers
    }), this.props.onAfterRender({
      device: i,
      gl: n
    });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Ni.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this.device?.type !== "webgpu" && this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(e) {
    const t = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = {
      ...this.viewState,
      [e.viewId]: t
    }, this.props.viewState || this.viewManager && this.viewManager.setProps({
      viewState: this.viewState
    }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const {
      stats: e
    } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const t = this.animationLoop.stats;
    e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const {
      metrics: e,
      stats: t
    } = this;
    e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
    const i = uv.stats.get("Memory Usage");
    e.bufferMemory = i.get("Buffer Memory").count, e.textureMemory = i.get("Texture Memory").count, e.renderbufferMemory = i.get("Renderbuffer Memory").count, e.gpuMemory = i.get("GPU Memory").count;
  }
}
tm.defaultProps = kP;
tm.VERSION = vO;
function Uj(r) {
  switch (r) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return R2(r);
  }
}
const zj = M2;
function c_(r, e, t) {
  const i = t === "webgpu" && e.type === "uint8" ? "unorm8" : e.type;
  return {
    attribute: r,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: e.size > 1 ? `${i}x${e.size}` : e.type,
    byteOffset: e.offset || 0
    // Note stride is set on the top level
  };
}
function Df(r) {
  return r.stride || r.size * r.bytesPerElement;
}
function jj(r, e) {
  return r.type === e.type && r.size === e.size && Df(r) === Df(e) && (r.offset || 0) === (e.offset || 0);
}
function Bv(r, e) {
  e.offset && Ni.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const t = Df(r), i = e.vertexOffset !== void 0 ? e.vertexOffset : r.vertexOffset || 0, n = e.elementOffset || 0, s = (
    // offsets defined by the attribute
    i * t + n * r.bytesPerElement + // offsets defined by external buffers if any
    (r.offset || 0)
  );
  return {
    ...e,
    offset: s,
    stride: t
  };
}
function Vj(r, e) {
  const t = Bv(r, e);
  return {
    high: t,
    low: {
      ...t,
      offset: t.offset + r.size * 4
    }
  };
}
class Gj {
  /* eslint-disable max-statements */
  constructor(e, t, i) {
    this._buffer = null, this.device = e, this.id = t.id || "", this.size = t.size || 1;
    const n = t.logicalType || t.type, s = n === "float64";
    let {
      defaultValue: c
    } = t;
    c = Number.isFinite(c) ? [c] : c || new Array(this.size).fill(0);
    let o;
    s ? o = "float32" : !n && t.isIndexed ? o = "uint32" : o = n || "float32";
    let d = Uj(n || o);
    this.doublePrecision = s, s && t.fp64 === !1 && (d = Float32Array), this.value = null, this.settings = {
      ...t,
      defaultType: d,
      defaultValue: c,
      logicalType: n,
      type: o,
      normalized: o.includes("norm"),
      size: this.size,
      bytesPerElement: d.BYTES_PER_ELEMENT
    }, this.state = {
      ...i,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * Df(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), Qg.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue(e = this.id, t = null) {
    const i = {};
    if (this.state.constant) {
      const n = this.value;
      if (t) {
        const s = Bv(this.getAccessor(), t), c = s.offset / n.BYTES_PER_ELEMENT, o = s.size || this.size;
        i[e] = n.subarray(c, c + o);
      } else
        i[e] = n;
    } else
      i[e] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? i[`${e}64Low`] = i[e] : i[`${e}64Low`] = new Float32Array(this.size)), i;
  }
  _getBufferLayout(e = this.id, t = null) {
    const i = this.getAccessor(), n = [], s = {
      name: this.id,
      byteStride: Df(i),
      attributes: n
    };
    if (this.doublePrecision) {
      const c = Vj(i, t || {});
      n.push(c_(e, {
        ...i,
        ...c.high
      }, this.device.type), c_(`${e}64Low`, {
        ...i,
        ...c.low
      }, this.device.type));
    } else if (t) {
      const c = Bv(i, t);
      n.push(c_(e, {
        ...i,
        ...c
      }, this.device.type));
    } else
      n.push(c_(e, i, this.device.type));
    return s;
  }
  setAccessor(e) {
    this.state.bufferAccessor = e;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const t = Array.from(this.value);
      e = [t, t];
    } else {
      const {
        value: t,
        numInstances: i,
        size: n
      } = this, s = i * n;
      if (t && s && t.length >= s) {
        const c = new Array(n).fill(1 / 0), o = new Array(n).fill(-1 / 0);
        for (let d = 0; d < s; )
          for (let m = 0; m < n; m++) {
            const y = t[d++];
            y < c[m] && (c[m] = y), y > o[m] && (o[m] = y);
          }
        e = [c, o];
      }
    }
    return this.state.bounds = e, e;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(e) {
    const {
      state: t
    } = this;
    let i;
    ArrayBuffer.isView(e) ? i = {
      value: e
    } : e instanceof us ? i = {
      buffer: e
    } : i = e;
    const n = {
      ...this.settings,
      ...i
    };
    if (ArrayBuffer.isView(i.value)) {
      if (!i.type)
        if (this.doublePrecision && i.value instanceof Float64Array)
          n.type = "float32";
        else {
          const c = zj(i.value);
          n.type = n.normalized ? c.replace("int", "norm") : c;
        }
      n.bytesPerElement = i.value.BYTES_PER_ELEMENT, n.stride = Df(n);
    }
    if (t.bounds = null, i.constant) {
      let s = i.value;
      if (s = this._normalizeValue(s, [], 0), this.settings.normalized && (s = this.normalizeConstant(s)), !(!t.constant || !this._areValuesEqual(s, this.value)))
        return !1;
      t.externalBuffer = null, t.constant = !0, this.value = ArrayBuffer.isView(s) ? s : new Float32Array(s);
    } else if (i.buffer) {
      const s = i.buffer;
      t.externalBuffer = s, t.constant = !1, this.value = i.value || null;
    } else if (i.value) {
      this._checkExternalBuffer(i);
      let s = i.value;
      t.externalBuffer = null, t.constant = !1, this.value = s;
      let {
        buffer: c
      } = this;
      const o = Df(n), d = (n.vertexOffset || 0) * o;
      if (this.doublePrecision && s instanceof Float64Array && (s = Mb(s, n)), this.settings.isIndexed) {
        const y = this.settings.defaultType;
        s.constructor !== y && (s = new y(s));
      }
      const m = s.byteLength + d + o * 2;
      (!c || c.byteLength < m) && (c = this._createBuffer(m)), c.write(s, d);
    }
    return this.setAccessor(n), !0;
  }
  updateSubBuffer(e = {}) {
    this.state.bounds = null;
    const t = this.value, {
      startOffset: i = 0,
      endOffset: n
    } = e;
    this.buffer.write(this.doublePrecision && t instanceof Float64Array ? Mb(t, {
      size: this.size,
      startIndex: i,
      endIndex: n
    }) : t.subarray(i, n), i * t.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(e, t = !1) {
    const {
      state: i
    } = this, n = i.allocatedValue, s = Qg.allocate(n, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: t
    });
    this.value = s;
    const {
      byteOffset: c
    } = this;
    let {
      buffer: o
    } = this;
    return (!o || o.byteLength < s.byteLength + c) && (o = this._createBuffer(s.byteLength + c), t && n && o.write(n instanceof Float64Array ? Mb(n, this) : n, c)), i.allocatedValue = s, i.constant = !1, i.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(e) {
    const {
      value: t
    } = e;
    if (!ArrayBuffer.isView(t))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const i = this.settings.defaultType;
    let n = !1;
    if (this.doublePrecision && (n = t.BYTES_PER_ELEMENT < 4), n)
      throw new Error(`Attribute ${this.id} does not support ${t.constructor.name}`);
    !(t instanceof i) && this.settings.normalized && !("normalized" in e) && Ni.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(e) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(e).map((t) => t / 255);
      case "unorm16":
        return new Float32Array(e).map((t) => t / 65535);
      default:
        return e;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(e, t, i) {
    const {
      defaultValue: n,
      size: s
    } = this.settings;
    if (Number.isFinite(e))
      return t[i] = e, t;
    if (!e) {
      let c = s;
      for (; --c >= 0; )
        t[i + c] = n[c];
      return t;
    }
    switch (s) {
      case 4:
        t[i + 3] = Number.isFinite(e[3]) ? e[3] : n[3];
      case 3:
        t[i + 2] = Number.isFinite(e[2]) ? e[2] : n[2];
      case 2:
        t[i + 1] = Number.isFinite(e[1]) ? e[1] : n[1];
      case 1:
        t[i + 0] = Number.isFinite(e[0]) ? e[0] : n[0];
        break;
      default:
        let c = s;
        for (; --c >= 0; )
          t[i + c] = Number.isFinite(e[c]) ? e[c] : n[c];
    }
    return t;
  }
  _areValuesEqual(e, t) {
    if (!e || !t)
      return !1;
    const {
      size: i
    } = this;
    for (let n = 0; n < i; n++)
      if (e[n] !== t[n])
        return !1;
    return !0;
  }
  _createBuffer(e) {
    this._buffer && this._buffer.destroy();
    const {
      isIndexed: t,
      type: i
    } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...this._buffer?.props,
      id: this.id,
      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read
      usage: (t ? us.INDEX : us.VERTEX) | us.COPY_DST,
      indexType: t ? i : void 0,
      byteLength: e
    }), this._buffer;
  }
}
const W3 = [], X3 = [];
function OP(r, e = 0, t = 1 / 0) {
  let i = W3;
  const n = {
    index: -1,
    data: r,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return r ? typeof r[Symbol.iterator] == "function" ? i = r : r.length > 0 && (X3.length = r.length, i = X3) : i = W3, (e > 0 || Number.isFinite(t)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(e, t), n.index = e - 1), {
    iterable: i,
    objectInfo: n
  };
}
function DP(r) {
  return r && r[Symbol.asyncIterator];
}
function $j(r, e) {
  const {
    size: t,
    stride: i,
    offset: n,
    startIndices: s,
    nested: c
  } = e, o = r.BYTES_PER_ELEMENT, d = i ? i / o : t, m = n ? n / o : 0, y = Math.floor((r.length - m) / d);
  return (T, {
    index: P,
    target: I
  }) => {
    if (!s) {
      const G = P * d + m;
      for (let te = 0; te < t; te++)
        I[te] = r[G + te];
      return I;
    }
    const D = s[P], k = s[P + 1] || y;
    let $;
    if (c) {
      $ = new Array(k - D);
      for (let G = D; G < k; G++) {
        const te = G * d + m;
        I = new Array(t);
        for (let Z = 0; Z < t; Z++)
          I[Z] = r[te + Z];
        $[G - D] = I;
      }
    } else if (d === t)
      $ = r.subarray(D * t + m, k * t + m);
    else {
      $ = new r.constructor((k - D) * t);
      let G = 0;
      for (let te = D; te < k; te++) {
        const Z = te * d + m;
        for (let H = 0; H < t; H++)
          $[G++] = r[Z + H];
      }
    }
    return $;
  };
}
const Hj = [], X_ = [[0, 1 / 0]];
function qj(r, e) {
  if (r === X_ || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return r;
  const t = [], i = r.length;
  let n = 0;
  for (let s = 0; s < i; s++) {
    const c = r[s];
    c[1] < e[0] ? (t.push(c), n = s + 1) : c[0] > e[1] ? t.push(c) : e = [Math.min(c[0], e[0]), Math.max(c[1], e[1])];
  }
  return t.splice(n, 0, e), t;
}
const Wj = {
  interpolation: {
    duration: 0,
    easing: (r) => r
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function NP(r, e) {
  if (!r)
    return null;
  Number.isFinite(r) && (r = {
    type: "interpolation",
    duration: r
  });
  const t = r.type || "interpolation";
  return {
    ...Wj[t],
    ...e,
    ...r,
    type: t
  };
}
class FP extends Gj {
  constructor(e, t) {
    super(e, t, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: X_
    }), this.constant = !1, this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({
    clearChangedFlags: e = !1
  } = {}) {
    const t = this.state.needsRedraw;
    return this.state.needsRedraw = t && !e, t;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(e) {
    var t;
    (t = this.state).layoutChanged || (t.layoutChanged = !jj(e, this.getAccessor())), super.setAccessor(e);
  }
  getUpdateTriggers() {
    const {
      accessor: e
    } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const {
      accessor: t
    } = this.settings, i = this.settings.transition, n = Array.isArray(t) ? (
      // @ts-ignore
      e[t.find((s) => e[s])]
    ) : (
      // @ts-ignore
      e[t]
    );
    return NP(n, i);
  }
  setNeedsUpdate(e = this.id, t) {
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
      const {
        startRow: i = 0,
        endRow: n = 1 / 0
      } = t;
      this.state.updateRanges = qj(this.state.updateRanges, [i, n]);
    } else
      this.state.updateRanges = X_;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = Hj;
  }
  setNeedsRedraw(e = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const {
      state: t,
      settings: i
    } = this;
    return i.noAlloc ? !1 : i.update ? (super.allocate(e, t.updateRanges !== X_), !0) : !1;
  }
  updateBuffer({
    numInstances: e,
    data: t,
    props: i,
    context: n
  }) {
    if (!this.needsUpdate())
      return !1;
    const {
      state: {
        updateRanges: s
      },
      settings: {
        update: c,
        noAlloc: o
      }
    } = this;
    let d = !0;
    if (c) {
      for (const [m, y] of s)
        c.call(n, this, {
          data: t,
          startRow: m,
          endRow: y,
          props: i,
          numInstances: e
        });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [m, y] of s) {
          const T = Number.isFinite(m) ? this.getVertexOffset(m) : 0, P = Number.isFinite(y) ? this.getVertexOffset(y) : o || !Number.isFinite(e) ? this.value.length : e * this.size;
          super.updateSubBuffer({
            startOffset: T,
            endOffset: P
          });
        }
      this._checkAttributeArray();
    } else
      d = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), d;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(e, t) {
    const i = this.device.type === "webgpu";
    if (i || t === void 0 || typeof t == "function") {
      if (i && typeof t != "function") {
        const c = this._normalizeValue(t, [], 0);
        this._areValuesEqual(c, this.value) || this.setNeedsUpdate("WebGPU constant updated");
      }
      return !1;
    }
    const n = this.settings.transform && e ? this.settings.transform.call(e, t) : t;
    return this.setData({
      constant: !0,
      value: n
    }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0;
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(e) {
    const {
      state: t
    } = this;
    return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(e, t = null) {
    const {
      state: i,
      settings: n
    } = this;
    if (!e)
      return i.binaryValue = null, i.binaryAccessor = null, !1;
    if (n.noAlloc)
      return !1;
    if (i.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (i.binaryValue = e, this.setNeedsRedraw(), n.transform || t !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = {
        value: e
      });
      const c = e;
      Ks(ArrayBuffer.isView(c.value), `invalid ${n.accessor}`);
      const o = !!c.size && c.size !== this.size;
      return i.binaryAccessor = $j(c.value, {
        size: c.size || this.size,
        stride: c.stride,
        offset: c.offset,
        startIndices: t,
        nested: o
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const {
      startIndices: t
    } = this;
    return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
  }
  getValue() {
    const e = this.settings.shaderAttributes, t = super.getValue();
    if (!e)
      return t;
    for (const i in e)
      Object.assign(t, super.getValue(i, e[i]));
    return t;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(e) {
    this.state.layoutChanged = !1;
    const t = this.settings.shaderAttributes, i = super._getBufferLayout(), {
      stepMode: n
    } = this.settings;
    if (n === "dynamic" ? i.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : i.stepMode = n ?? "vertex", !t)
      return i;
    for (const s in t) {
      const c = super._getBufferLayout(s, t[s]);
      i.attributes.push(...c.attributes);
    }
    return i;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(e, {
    data: t,
    startRow: i,
    endRow: n,
    props: s,
    numInstances: c
  }) {
    if (e.constant && this.context.device.type !== "webgpu")
      return;
    const {
      settings: o,
      state: d,
      value: m,
      size: y,
      startIndices: T
    } = e, {
      accessor: P,
      transform: I
    } = o;
    let D = d.binaryAccessor || // @ts-ignore
    (typeof P == "function" ? P : s[P]);
    typeof D != "function" && typeof P == "string" && (D = () => s[P]), Ks(typeof D == "function", `accessor "${P}" is not a function`);
    let k = e.getVertexOffset(i);
    const {
      iterable: $,
      objectInfo: G
    } = OP(t, i, n);
    for (const te of $) {
      G.index++;
      let Z = D(te, G);
      if (I && (Z = I.call(this, Z)), T) {
        const H = (G.index < T.length - 1 ? T[G.index + 1] : c) - T[G.index];
        if (Z && Array.isArray(Z[0])) {
          let J = k;
          for (const re of Z)
            e._normalizeValue(re, m, J), J += y;
        } else Z && Z.length > y ? m.set(Z, k) : (e._normalizeValue(Z, G.target, 0), p7({
          target: m,
          source: G.target,
          start: k,
          count: H
        }));
        k += H * y;
      } else
        e._normalizeValue(Z, m, k), k += y;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const {
      settings: e
    } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const {
      value: e
    } = this, t = Math.min(4, this.size);
    if (e && e.length >= t) {
      let i = !0;
      switch (t) {
        case 4:
          i = i && Number.isFinite(e[3]);
        case 3:
          i = i && Number.isFinite(e[2]);
        case 2:
          i = i && Number.isFinite(e[1]);
        case 1:
          i = i && Number.isFinite(e[0]);
          break;
        default:
          i = !1;
      }
      if (!i)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function jb(r) {
  const {
    source: e,
    target: t,
    start: i = 0,
    size: n,
    getData: s
  } = r, c = r.end || t.length, o = e.length, d = c - i;
  if (o > d) {
    t.set(e.subarray(0, d), i);
    return;
  }
  if (t.set(e, i), !s)
    return;
  let m = o;
  for (; m < d; ) {
    const y = s(m, e);
    for (let T = 0; T < n; T++)
      t[i + m] = y[T] || 0, m++;
  }
}
function Xj({
  source: r,
  target: e,
  size: t,
  getData: i,
  sourceStartIndices: n,
  targetStartIndices: s
}) {
  if (!n || !s)
    return jb({
      source: r,
      target: e,
      size: t,
      getData: i
    }), e;
  let c = 0, o = 0;
  const d = i && ((y, T) => i(y + o, T)), m = Math.min(n.length, s.length);
  for (let y = 1; y < m; y++) {
    const T = n[y] * t, P = s[y] * t;
    jb({
      source: r.subarray(c, T),
      target: e,
      start: o,
      end: P,
      size: t,
      getData: d
    }), c = T, o = P;
  }
  return o < e.length && jb({
    // @ts-ignore
    source: [],
    target: e,
    start: o,
    size: t,
    getData: d
  }), e;
}
function Zj(r) {
  const {
    device: e,
    settings: t,
    value: i
  } = r, n = new FP(e, t);
  return n.setData({
    value: i instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: t.normalized
  }), n;
}
function UP(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${r}"`);
  }
}
function zP(r) {
  switch (r) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function jP(r) {
  r.push(r.shift());
}
function Yj(r, e) {
  const {
    doublePrecision: t,
    settings: i,
    value: n,
    size: s
  } = r, c = t && n instanceof Float64Array ? 2 : 1;
  let o = 0;
  const {
    shaderAttributes: d
  } = r.settings;
  if (d)
    for (const m of Object.values(d))
      o = Math.max(o, m.vertexOffset ?? 0);
  return (i.noAlloc ? n.length : (e + o) * s) * c;
}
function VP({
  device: r,
  source: e,
  target: t
}) {
  return (!t || t.byteLength < e.byteLength) && (t?.destroy(), t = r.createBuffer({
    byteLength: e.byteLength,
    usage: e.usage
  })), t;
}
function GP({
  device: r,
  buffer: e,
  attribute: t,
  fromLength: i,
  toLength: n,
  fromStartIndices: s,
  getData: c = (o) => o
}) {
  const o = t.doublePrecision && t.value instanceof Float64Array ? 2 : 1, d = t.size * o, m = t.byteOffset, y = t.settings.bytesPerElement < 4 ? m / t.settings.bytesPerElement * 4 : m, T = t.startIndices, P = s && T, I = t.isConstant;
  if (!P && e && i >= n)
    return e;
  const D = t.value instanceof Float64Array ? Float32Array : t.value.constructor, k = I ? t.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new D(t.getBuffer().readSyncWebGL(m, n * D.BYTES_PER_ELEMENT).buffer)
  );
  if (t.settings.normalized && !I) {
    const Z = c;
    c = (H, J) => t.normalizeConstant(Z(H, J));
  }
  const $ = I ? (Z, H) => c(k, H) : (Z, H) => c(k.subarray(Z + m, Z + m + d), H), G = e ? new Float32Array(e.readSyncWebGL(y, i * 4).buffer) : new Float32Array(0), te = new Float32Array(n);
  return Xj({
    source: G,
    target: te,
    sourceStartIndices: s,
    targetStartIndices: T,
    size: d,
    getData: $
  }), (!e || e.byteLength < te.byteLength + y) && (e?.destroy(), e = r.createBuffer({
    byteLength: te.byteLength + y,
    usage: 35050
  })), e.write(te, y), e;
}
class $P {
  constructor({
    device: e,
    attribute: t,
    timeline: i
  }) {
    this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new t0(i), this.attribute = t, this.attributeInTransition = Zj(t), this.currentStartIndices = t.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t, i = 1 / 0) {
    this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = Yj(this.attribute, t), this.transition.start({
      ...e,
      duration: i
    });
  }
  update() {
    const e = this.transition.update();
    return e && this.onUpdate(), e;
  }
  setBuffer(e) {
    this.attributeInTransition.setData({
      buffer: e,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const e of this.buffers)
      e.destroy();
    this.buffers.length = 0;
  }
}
class Jj extends $P {
  constructor({
    device: e,
    attribute: t,
    timeline: i
  }) {
    super({
      device: e,
      attribute: t,
      timeline: i
    }), this.type = "interpolation", this.transform = tV(e, t);
  }
  start(e, t) {
    const i = this.currentLength, n = this.currentStartIndices;
    if (super.start(e, t, e.duration), e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const {
      buffers: s,
      attribute: c
    } = this;
    jP(s), s[0] = GP({
      device: this.device,
      buffer: s[0],
      attribute: c,
      fromLength: i,
      toLength: this.currentLength,
      fromStartIndices: n,
      getData: e.enter
    }), s[1] = VP({
      device: this.device,
      source: s[0],
      target: s[1]
    }), this.setBuffer(s[1]);
    const {
      transform: o
    } = this, d = o.model;
    let m = Math.floor(this.currentLength / c.size);
    HP(c) && (m /= 2), d.setVertexCount(m), c.isConstant ? (d.setAttributes({
      aFrom: s[0]
    }), d.setConstantAttributes({
      aTo: c.value
    })) : d.setAttributes({
      aFrom: s[0],
      aTo: c.getBuffer()
    }), o.transformFeedback.setBuffers({
      vCurrent: s[1]
    });
  }
  onUpdate() {
    const {
      duration: e,
      easing: t
    } = this.settings, {
      time: i
    } = this.transition;
    let n = i / e;
    t && (n = t(n));
    const {
      model: s
    } = this.transform, c = {
      time: n
    };
    s.shaderInputs.setProps({
      interpolation: c
    }), this.transform.run({
      discard: !0
    });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const Kj = `uniform interpolationUniforms {
  float time;
} interpolation;
`, Z3 = {
  name: "interpolation",
  vs: Kj,
  uniformTypes: {
    time: "f32"
  }
}, Qj = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`, eV = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function HP(r) {
  return r.doublePrecision && r.value instanceof Float64Array;
}
function tV(r, e) {
  const t = e.size, i = UP(t), n = zP(t), s = e.getBufferLayout();
  return HP(e) ? new Tp(r, {
    vs: eV,
    bufferLayout: [{
      name: "aFrom",
      byteStride: 8 * t,
      attributes: [{
        attribute: "aFrom",
        format: n,
        byteOffset: 0
      }, {
        attribute: "aFrom64Low",
        format: n,
        byteOffset: 4 * t
      }]
    }, {
      name: "aTo",
      byteStride: 8 * t,
      attributes: [{
        attribute: "aTo",
        format: n,
        byteOffset: 0
      }, {
        attribute: "aTo64Low",
        format: n,
        byteOffset: 4 * t
      }]
    }],
    // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
    modules: [l8, Z3],
    defines: {
      // @ts-expect-error TODO fix luma type
      ATTRIBUTE_TYPE: i,
      // @ts-expect-error TODO fix luma type
      ATTRIBUTE_SIZE: t
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    bufferMode: 35980,
    disableWarnings: !0
  }) : new Tp(r, {
    vs: Qj,
    bufferLayout: [{
      name: "aFrom",
      format: n
    }, {
      name: "aTo",
      format: s.attributes[0].format
    }],
    modules: [Z3],
    defines: {
      // @ts-expect-error TODO fix luma type
      ATTRIBUTE_TYPE: i
    },
    varyings: ["vCurrent"],
    // TODO investigate why this is needed
    disableWarnings: !0
  });
}
class rV extends $P {
  constructor({
    device: e,
    attribute: t,
    timeline: i
  }) {
    super({
      device: e,
      attribute: t,
      timeline: i
    }), this.type = "spring", this.texture = lV(e), this.framebuffer = cV(e, this.texture), this.transform = aV(e, t);
  }
  start(e, t) {
    const i = this.currentLength, n = this.currentStartIndices;
    super.start(e, t);
    const {
      buffers: s,
      attribute: c
    } = this;
    for (let d = 0; d < 2; d++)
      s[d] = GP({
        device: this.device,
        buffer: s[d],
        attribute: c,
        fromLength: i,
        toLength: this.currentLength,
        fromStartIndices: n,
        getData: e.enter
      });
    s[2] = VP({
      device: this.device,
      source: s[0],
      target: s[2]
    }), this.setBuffer(s[1]);
    const {
      model: o
    } = this.transform;
    o.setVertexCount(Math.floor(this.currentLength / c.size)), c.isConstant ? o.setConstantAttributes({
      aTo: c.value
    }) : o.setAttributes({
      aTo: c.getBuffer()
    });
  }
  onUpdate() {
    const {
      buffers: e,
      transform: t,
      framebuffer: i,
      transition: n
    } = this, s = this.settings;
    t.model.setAttributes({
      aPrev: e[0],
      aCur: e[1]
    }), t.transformFeedback.setBuffers({
      vNext: e[2]
    });
    const c = {
      stiffness: s.stiffness,
      damping: s.damping
    };
    t.model.shaderInputs.setProps({
      spring: c
    }), t.run({
      framebuffer: i,
      discard: !1,
      parameters: {
        viewport: [0, 0, 1, 1]
      },
      clearColor: [0, 0, 0, 0]
    }), jP(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(i)[0] > 0 || n.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const iV = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`, nV = {
  name: "spring",
  vs: iV,
  uniformTypes: {
    damping: "f32",
    stiffness: "f32"
  }
}, sV = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, oV = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function aV(r, e) {
  const t = UP(e.size), i = zP(e.size);
  return new Tp(r, {
    vs: sV,
    fs: oV,
    bufferLayout: [{
      name: "aPrev",
      format: i
    }, {
      name: "aCur",
      format: i
    }, {
      name: "aTo",
      format: e.getBufferLayout().attributes[0].format
    }],
    varyings: ["vNext"],
    modules: [nV],
    // @ts-expect-error TODO fix luma type
    defines: {
      ATTRIBUTE_TYPE: t
    },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function lV(r) {
  return r.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    width: 1,
    height: 1
  });
}
function cV(r, e) {
  return r.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [e]
  });
}
const uV = {
  interpolation: Jj,
  spring: rV
};
class hV {
  constructor(e, {
    id: t,
    timeline: i
  }) {
    if (!e) throw new Error("AttributeTransitionManager is constructed without device");
    this.id = t, this.device = e, this.timeline = i, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({
    attributes: e,
    transitions: t,
    numInstances: i
  }) {
    this.numInstances = i || 1;
    for (const n in e) {
      const s = e[n], c = s.getTransitionSetting(t);
      c && this._updateAttribute(n, s, c);
    }
    for (const n in this.transitions) {
      const s = e[n];
      (!s || !s.getTransitionSetting(t)) && this._removeTransition(n);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(e) {
    const t = this.transitions[e];
    return t && t.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const e = {};
    for (const t in this.transitions) {
      const i = this.transitions[t];
      i.inProgress && (e[t] = i.attributeInTransition);
    }
    return e;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const t in this.transitions)
      this.transitions[t].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(e) {
    this.transitions[e].delete(), delete this.transitions[e];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(e, t, i) {
    const n = this.transitions[e];
    let s = !n || n.type !== i.type;
    if (s) {
      n && this._removeTransition(e);
      const c = uV[i.type];
      c ? this.transitions[e] = new c({
        attribute: t,
        timeline: this.timeline,
        device: this.device
      }) : (Ni.error(`unsupported transition type '${i.type}'`)(), s = !1);
    }
    (s || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(i, this.numInstances));
  }
}
const Y3 = "attributeManager.invalidate", fV = "attributeManager.updateStart", dV = "attributeManager.updateEnd", pV = "attribute.updateStart", gV = "attribute.allocate", mV = "attribute.updateEnd";
class _V {
  constructor(e, {
    id: t = "attribute-manager",
    stats: i,
    timeline: n
  } = {}) {
    this.mergeBoundsMemoized = fm(Bz), this.id = t, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = i, this.attributeTransitionManager = new hV(e, {
      id: `${t}-transitions`,
      timeline: n
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(e = {
    clearRedrawFlags: !1
  }) {
    const t = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(e) {
    this._add(e);
  }
  // Adds attributes
  addInstanced(e) {
    this._add(e, {
      stepMode: "instance"
    });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(e) {
    for (const t of e)
      this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
  }
  // Marks an attribute for update
  invalidate(e, t) {
    const i = this._invalidateTrigger(e, t);
    Vo(Y3, this, e, i);
  }
  invalidateAll(e) {
    for (const t in this.attributes)
      this.attributes[t].setNeedsUpdate(t, e);
    Vo(Y3, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({
    data: e,
    numInstances: t,
    startIndices: i = null,
    transitions: n,
    props: s = {},
    buffers: c = {},
    context: o = {}
  }) {
    let d = !1;
    Vo(fV, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const m in this.attributes) {
      const y = this.attributes[m], T = y.settings.accessor;
      y.startIndices = i, y.numInstances = t, s[m] && Ni.removed(`props.${m}`, `data.attributes.${m}`)(), y.setExternalBuffer(c[m]) || y.setBinaryValue(typeof T == "string" ? c[T] : void 0, e.startIndices) || typeof T == "string" && !c[T] && y.setConstantValue(o, s[T]) || y.needsUpdate() && (d = !0, this._updateAttribute({
        attribute: y,
        numInstances: t,
        data: e,
        props: s,
        context: o
      })), this.needsRedraw = this.needsRedraw || y.needsRedraw();
    }
    d && Vo(dV, this, t), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: t,
      transitions: n
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const {
      attributeTransitionManager: e
    } = this, t = e.run();
    return this.needsRedraw = this.needsRedraw || t, t;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return {
      ...this.attributes,
      ...this.attributeTransitionManager.getAttributes()
    };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(e) {
    const t = e.map((i) => this.attributes[i]?.getBounds());
    return this.mergeBoundsMemoized(t);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(e = {
    clearChangedFlags: !1
  }) {
    const {
      attributes: t,
      attributeTransitionManager: i
    } = this, n = {
      ...i.getAttributes()
    };
    for (const s in t) {
      const c = t[s];
      c.needsRedraw(e) && !i.hasAttribute(s) && (n[s] = c);
    }
    return n;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(e) {
    return Object.values(this.getAttributes()).map((t) => t.getBufferLayout(e));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(e, t) {
    for (const i in e) {
      const n = e[i], s = {
        ...n,
        id: i,
        size: n.isIndexed && 1 || n.size || 1,
        ...t
      };
      this.attributes[i] = new FP(this.device, s);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const t in this.attributes)
      this.attributes[t].getUpdateTriggers().forEach((n) => {
        e[n] || (e[n] = []), e[n].push(t);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, t) {
    const {
      attributes: i,
      updateTriggers: n
    } = this, s = n[e];
    return s && s.forEach((c) => {
      const o = i[c];
      o && o.setNeedsUpdate(o.id, t);
    }), s;
  }
  _updateAttribute(e) {
    const {
      attribute: t,
      numInstances: i
    } = e;
    if (Vo(pV, t), t.constant) {
      t.setConstantValue(e.context, t.value);
      return;
    }
    t.allocate(i) && Vo(gV, t, i), t.updateBuffer(e) && (this.needsRedraw = !0, Vo(mV, t, i));
  }
}
class yV extends t0 {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time: e,
      settings: {
        fromValue: t,
        toValue: i,
        duration: n,
        easing: s
      }
    } = this, c = s(e / n);
    this._value = Iy(t, i, c);
  }
}
const J3 = 1e-5;
function K3(r, e, t, i, n) {
  const s = e - r, o = (t - e) * n, d = -s * i;
  return o + d + s + e;
}
function bV(r, e, t, i, n) {
  if (Array.isArray(t)) {
    const s = [];
    for (let c = 0; c < t.length; c++)
      s[c] = K3(r[c], e[c], t[c], i, n);
    return s;
  }
  return K3(r, e, t, i, n);
}
function Q3(r, e) {
  if (Array.isArray(r)) {
    let t = 0;
    for (let i = 0; i < r.length; i++) {
      const n = r[i] - e[i];
      t += n * n;
    }
    return Math.sqrt(t);
  }
  return Math.abs(r - e);
}
class vV extends t0 {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue: e,
      toValue: t,
      damping: i,
      stiffness: n
    } = this.settings, {
      _prevValue: s = e,
      _currValue: c = e
    } = this;
    let o = bV(s, c, t, i, n);
    const d = Q3(o, t), m = Q3(o, c);
    d < J3 && m < J3 && (o = t, this.end()), this._prevValue = c, this._currValue = o;
  }
}
const xV = {
  interpolation: yV,
  spring: vV
};
class wV {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, t, i, n) {
    const {
      transitions: s
    } = this;
    if (s.has(e)) {
      const d = s.get(e), {
        value: m = d.settings.fromValue
      } = d;
      t = m, this.remove(e);
    }
    if (n = NP(n), !n)
      return;
    const c = xV[n.type];
    if (!c) {
      Ni.error(`unsupported transition type '${n.type}'`)();
      return;
    }
    const o = new c(this.timeline);
    o.start({
      ...n,
      fromValue: t,
      toValue: i
    }), s.set(e, o);
  }
  remove(e) {
    const {
      transitions: t
    } = this;
    t.has(e) && (t.get(e).cancel(), t.delete(e));
  }
  update() {
    const e = {};
    for (const [t, i] of this.transitions)
      i.update(), e[t] = i.value, i.inProgress || this.remove(t);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function AV(r) {
  const e = r[$h];
  for (const t in e) {
    const i = e[t], {
      validate: n
    } = i;
    if (n && !n(r[t], i))
      throw new Error(`Invalid prop ${t}: ${r[t]}`);
  }
}
function TV(r, e) {
  const t = qP({
    newProps: r,
    oldProps: e,
    propTypes: r[$h],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  }), i = EV(r, e);
  let n = !1;
  return i || (n = CV(r, e)), {
    dataChanged: i,
    propsChanged: t,
    updateTriggersChanged: n,
    extensionsChanged: IV(r, e),
    transitionsChanged: SV(r, e)
  };
}
function SV(r, e) {
  if (!r.transitions)
    return !1;
  const t = {}, i = r[$h];
  let n = !1;
  for (const s in r.transitions) {
    const c = i[s], o = c && c.type;
    (o === "number" || o === "color" || o === "array") && kv(r[s], e[s], c) && (t[s] = !0, n = !0);
  }
  return n ? t : !1;
}
function qP({
  newProps: r,
  oldProps: e,
  ignoreProps: t = {},
  propTypes: i = {},
  triggerName: n = "props"
}) {
  if (e === r)
    return !1;
  if (typeof r != "object" || r === null)
    return `${n} changed shallowly`;
  if (typeof e != "object" || e === null)
    return `${n} changed shallowly`;
  for (const s of Object.keys(r))
    if (!(s in t)) {
      if (!(s in e))
        return `${n}.${s} added`;
      const c = kv(r[s], e[s], i[s]);
      if (c)
        return `${n}.${s} ${c}`;
    }
  for (const s of Object.keys(e))
    if (!(s in t)) {
      if (!(s in r))
        return `${n}.${s} dropped`;
      if (!Object.hasOwnProperty.call(r, s)) {
        const c = kv(r[s], e[s], i[s]);
        if (c)
          return `${n}.${s} ${c}`;
      }
    }
  return !1;
}
function kv(r, e, t) {
  let i = t && t.equal;
  return i && !i(r, e, t) || !i && (i = r && e && r.equals, i && !i.call(r, e)) ? "changed deeply" : !i && e !== r ? "changed shallowly" : null;
}
function EV(r, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let t = !1;
  const {
    dataComparator: i,
    _dataDiff: n
  } = r;
  return i ? i(r.data, e.data) || (t = "Data comparator detected a change") : r.data !== e.data && (t = "A new data container was supplied"), t && n && (t = n(r.data, e.data) || t), t;
}
function CV(r, e) {
  if (e === null)
    return {
      all: !0
    };
  if ("all" in r.updateTriggers && eS(r, e, "all"))
    return {
      all: !0
    };
  const t = {};
  let i = !1;
  for (const n in r.updateTriggers)
    n !== "all" && eS(r, e, n) && (t[n] = !0, i = !0);
  return i ? t : !1;
}
function IV(r, e) {
  if (e === null)
    return !0;
  const t = e.extensions, {
    extensions: i
  } = r;
  if (i === t)
    return !1;
  if (!t || !i || i.length !== t.length)
    return !0;
  for (let n = 0; n < i.length; n++)
    if (!i[n].equals(t[n]))
      return !0;
  return !1;
}
function eS(r, e, t) {
  let i = r.updateTriggers[t];
  i = i ?? {};
  let n = e.updateTriggers[t];
  return n = n ?? {}, qP({
    oldProps: n,
    newProps: i,
    triggerName: t
  });
}
const PV = "count(): argument not an object", MV = "count(): argument not a container";
function RV(r) {
  if (!BV(r))
    throw new Error(PV);
  if (typeof r.count == "function")
    return r.count();
  if (Number.isFinite(r.size))
    return r.size;
  if (Number.isFinite(r.length))
    return r.length;
  if (LV(r))
    return Object.keys(r).length;
  throw new Error(MV);
}
function LV(r) {
  return r !== null && typeof r == "object" && r.constructor === Object;
}
function BV(r) {
  return r !== null && typeof r == "object";
}
function tS(r, e) {
  if (!e)
    return r;
  const t = {
    ...r,
    ...e
  };
  if ("defines" in e && (t.defines = {
    ...r.defines,
    ...e.defines
  }), "modules" in e && (t.modules = (r.modules || []).concat(e.modules), e.modules.some((i) => i.name === "project64"))) {
    const i = t.modules.findIndex((n) => n.name === "project32");
    i >= 0 && t.modules.splice(i, 1);
  }
  if ("inject" in e)
    if (!r.inject)
      t.inject = e.inject;
    else {
      const i = {
        ...r.inject
      };
      for (const n in e.inject)
        i[n] = (i[n] || "") + e.inject[n];
      t.inject = i;
    }
  return t;
}
const kV = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, Ov = {};
function OV(r, e, t, i) {
  if (t instanceof Fs)
    return t;
  t.constructor && t.constructor.name !== "Object" && (t = {
    data: t
  });
  let n = null;
  t.compressed && (n = {
    minFilter: "linear",
    mipmapFilter: t.data.length > 1 ? "nearest" : "linear"
  });
  const {
    width: s,
    height: c
  } = t.data, o = e.createTexture({
    ...t,
    sampler: {
      ...kV,
      ...n,
      ...i
    },
    mipLevels: e.getMipLevelCount(s, c)
  });
  return o.generateMipmapsWebGL(), Ov[o.id] = r, o;
}
function DV(r, e) {
  !e || !(e instanceof Fs) || Ov[e.id] === r && (e.delete(), delete Ov[e.id]);
}
const NV = {
  boolean: {
    validate(r, e) {
      return !0;
    },
    equal(r, e, t) {
      return !!r == !!e;
    }
  },
  number: {
    validate(r, e) {
      return Number.isFinite(r) && (!("max" in e) || r <= e.max) && (!("min" in e) || r >= e.min);
    }
  },
  color: {
    validate(r, e) {
      return e.optional && !r || Dv(r) && (r.length === 3 || r.length === 4);
    },
    equal(r, e, t) {
      return Rl(r, e, 1);
    }
  },
  accessor: {
    validate(r, e) {
      const t = ky(r);
      return t === "function" || t === ky(e.value);
    },
    equal(r, e, t) {
      return typeof e == "function" ? !0 : Rl(r, e, 1);
    }
  },
  array: {
    validate(r, e) {
      return e.optional && !r || Dv(r);
    },
    equal(r, e, t) {
      const {
        compare: i
      } = t, n = Number.isInteger(i) ? i : i ? 1 : 0;
      return i ? Rl(r, e, n) : r === e;
    }
  },
  object: {
    equal(r, e, t) {
      if (t.ignore)
        return !0;
      const {
        compare: i
      } = t, n = Number.isInteger(i) ? i : i ? 1 : 0;
      return i ? Rl(r, e, n) : r === e;
    }
  },
  function: {
    validate(r, e) {
      return e.optional && !r || typeof r == "function";
    },
    equal(r, e, t) {
      return !t.compare && t.ignore !== !1 || r === e;
    }
  },
  data: {
    transform: (r, e, t) => {
      if (!r)
        return r;
      const {
        dataTransform: i
      } = t.props;
      return i ? i(r) : typeof r.shape == "string" && r.shape.endsWith("-table") && Array.isArray(r.data) ? r.data : r;
    }
  },
  image: {
    transform: (r, e, t) => {
      const i = t.context;
      return !i || !i.device ? null : OV(t.id, i.device, r, {
        ...e.parameters,
        ...t.props.textureParameters
      });
    },
    release: (r, e, t) => {
      DV(t.id, r);
    }
  }
};
function FV(r) {
  const e = {}, t = {}, i = {};
  for (const [n, s] of Object.entries(r)) {
    const c = s?.deprecatedFor;
    if (c)
      i[n] = Array.isArray(c) ? c : [c];
    else {
      const o = UV(n, s);
      e[n] = o, t[n] = o.value;
    }
  }
  return {
    propTypes: e,
    defaultProps: t,
    deprecatedProps: i
  };
}
function UV(r, e) {
  switch (ky(e)) {
    case "object":
      return dg(r, e);
    case "array":
      return dg(r, {
        type: "array",
        value: e,
        compare: !1
      });
    case "boolean":
      return dg(r, {
        type: "boolean",
        value: e
      });
    case "number":
      return dg(r, {
        type: "number",
        value: e
      });
    case "function":
      return dg(r, {
        type: "function",
        value: e,
        compare: !0
      });
    default:
      return {
        name: r,
        type: "unknown",
        value: e
      };
  }
}
function dg(r, e) {
  return "type" in e ? {
    name: r,
    ...NV[e.type],
    ...e
  } : "value" in e ? {
    name: r,
    type: ky(e.value),
    ...e
  } : {
    name: r,
    type: "object",
    value: e
  };
}
function Dv(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
function ky(r) {
  return Dv(r) ? "array" : r === null ? "null" : typeof r;
}
function zV(r, e) {
  let t;
  for (let s = e.length - 1; s >= 0; s--) {
    const c = e[s];
    "extensions" in c && (t = c.extensions);
  }
  const i = Nv(r.constructor, t), n = Object.create(i);
  n[By] = r, n[td] = {}, n[jh] = {};
  for (let s = 0; s < e.length; ++s) {
    const c = e[s];
    for (const o in c)
      n[o] = c[o];
  }
  return Object.freeze(n), n;
}
const jV = "_mergedDefaultProps";
function Nv(r, e) {
  if (!(r instanceof r0.constructor)) return {};
  let t = jV;
  if (e)
    for (const n of e) {
      const s = n.constructor;
      s && (t += `:${s.extensionName || s.name}`);
    }
  const i = WP(r, t);
  return i || (r[t] = VV(r, e || []));
}
function VV(r, e) {
  if (!r.prototype)
    return null;
  const i = Object.getPrototypeOf(r), n = Nv(i), s = WP(r, "defaultProps") || {}, c = FV(s), o = Object.assign(/* @__PURE__ */ Object.create(null), n, c.defaultProps), d = Object.assign(/* @__PURE__ */ Object.create(null), n?.[$h], c.propTypes), m = Object.assign(/* @__PURE__ */ Object.create(null), n?.[Ob], c.deprecatedProps);
  for (const y of e) {
    const T = Nv(y.constructor);
    T && (Object.assign(o, T), Object.assign(d, T[$h]), Object.assign(m, T[Ob]));
  }
  return GV(o, r), HV(o, d), $V(o, m), o[$h] = d, o[Ob] = m, e.length === 0 && !Tx(r, "_propTypes") && (r._propTypes = d), o;
}
function GV(r, e) {
  const t = WV(e);
  Object.defineProperties(r, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: t
    }
  });
}
function $V(r, e) {
  for (const t in e)
    Object.defineProperty(r, t, {
      enumerable: !1,
      set(i) {
        const n = `${this.id}: ${t}`;
        for (const s of e[t])
          Tx(this, s) || (this[s] = i);
        Ni.deprecated(n, e[t].join("/"))();
      }
    });
}
function HV(r, e) {
  const t = {}, i = {};
  for (const n in e) {
    const s = e[n], {
      name: c,
      value: o
    } = s;
    s.async && (t[c] = o, i[c] = qV(c));
  }
  r[pp] = t, r[td] = {}, Object.defineProperties(r, i);
}
function qV(r) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(e) {
      typeof e == "string" || e instanceof Promise || DP(e) ? this[td][r] = e : this[jh][r] = e;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[jh]) {
        if (r in this[jh])
          return this[jh][r] || this[pp][r];
        if (r in this[td]) {
          const e = this[By] && this[By].internalState;
          if (e && e.hasAsyncProp(r))
            return e.getAsyncProp(r) || this[pp][r];
        }
      }
      return this[pp][r];
    }
  };
}
function Tx(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function WP(r, e) {
  return Tx(r, e) && r[e];
}
function WV(r) {
  const e = r.componentName;
  return e || Ni.warn(`${r.name}.componentName not specified`)(), e || r.name;
}
let XV = 0;
class r0 {
  constructor(...e) {
    this.props = zV(this, e), this.id = this.props.id, this.count = XV++;
  }
  // clone this layer with modified props
  clone(e) {
    const {
      props: t
    } = this, i = {};
    for (const n in t[pp])
      n in t[jh] ? i[n] = t[jh][n] : n in t[td] && (i[n] = t[td][n]);
    return new this.constructor({
      ...t,
      ...i,
      ...e
    });
  }
}
r0.componentName = "Component";
r0.defaultProps = {};
const ZV = Object.freeze({});
class YV {
  constructor(e) {
    this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const t = this.asyncProps[e];
      t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || ZV;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(e) {
    const t = this.asyncProps[e];
    return t && t.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const t = this.asyncProps[e];
      return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
    }
    for (const t in this.asyncProps)
      if (this.isAsyncPropLoading(t))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(e, t) {
    this._watchPromise(e, Promise.resolve(t));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(e) {
    this.component = e[By] || this.component;
    const t = e[jh] || {}, i = e[td] || e, n = e[pp] || {};
    for (const s in t) {
      const c = t[s];
      this._createAsyncPropData(s, n[s]), this._updateAsyncProp(s, c), t[s] = this.getAsyncProp(s);
    }
    for (const s in i) {
      const c = i[s];
      this._createAsyncPropData(s, n[s]), this._updateAsyncProp(s, c);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(e, t) {
    return null;
  }
  _onResolve(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(e, t) {
    if (this._didAsyncInputValueChange(e, t)) {
      if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
        this._watchPromise(e, t);
        return;
      }
      if (DP(t)) {
        this._resolveAsyncIterable(e, t);
        return;
      }
      this._setPropValue(e, t);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(e, t) {
    const i = this.asyncProps[e];
    return t === i.resolvedValue || t === i.lastValue ? !1 : (i.lastValue = t, !0);
  }
  // Set normal, non-async value
  _setPropValue(e, t) {
    this._freezeAsyncOldProps();
    const i = this.asyncProps[e];
    i && (t = this._postProcessValue(i, t), i.resolvedValue = t, i.pendingLoadCount++, i.resolvedLoadCount = i.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(e, t, i) {
    const n = this.asyncProps[e];
    n && i >= n.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), n.resolvedValue = t, n.resolvedLoadCount = i, this.onAsyncPropUpdated(e, t));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(e, t) {
    const i = this.asyncProps[e];
    if (i) {
      i.pendingLoadCount++;
      const n = i.pendingLoadCount;
      t.then((s) => {
        this.component && (s = this._postProcessValue(i, s), this._setAsyncPropValue(e, s, n), this._onResolve(e, s));
      }).catch((s) => {
        this._onError(e, s);
      });
    }
  }
  async _resolveAsyncIterable(e, t) {
    if (e !== "data") {
      this._setPropValue(e, t);
      return;
    }
    const i = this.asyncProps[e];
    if (!i)
      return;
    i.pendingLoadCount++;
    const n = i.pendingLoadCount;
    let s = [], c = 0;
    for await (const o of t) {
      if (!this.component)
        return;
      const {
        dataTransform: d
      } = this.component.props;
      d ? s = d(o, s) : s = s.concat(o), Object.defineProperty(s, "__diff", {
        enumerable: !1,
        value: [{
          startRow: c,
          endRow: s.length
        }]
      }), c = s.length, this._setAsyncPropValue(e, s, n);
    }
    this._onResolve(e, s);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(e, t) {
    const i = e.type;
    return i && this.component && (i.release && i.release(e.resolvedValue, i, this.component), i.transform) ? i.transform(t, i, this.component) : t;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(e, t) {
    if (!this.asyncProps[e]) {
      const n = this.component && this.component.props[$h];
      this.asyncProps[e] = {
        type: n && n[e],
        lastValue: null,
        resolvedValue: t,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class JV extends YV {
  constructor({
    attributeManager: e,
    layer: t
  }) {
    super(t), this.attributeManager = e, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(e, t) {
    const i = this.layer, n = i?.props.fetch;
    return n ? n(t, {
      propName: e,
      layer: i
    }) : super._fetch(e, t);
  }
  _onResolve(e, t) {
    const i = this.layer;
    if (i) {
      const n = i.props.onDataLoad;
      e === "data" && n && n(t, {
        propName: e,
        layer: i
      });
    }
  }
  _onError(e, t) {
    const i = this.layer;
    i && i.raiseError(t, `loading ${e} of ${this.layer}`);
  }
}
const KV = "layer.changeFlag", QV = "layer.initialize", eG = "layer.update", tG = "layer.finalize", rG = "layer.matched", rS = 2 ** 24 - 1, iG = Object.freeze([]), nG = fm(({
  oldViewport: r,
  viewport: e
}) => r.equals(e));
let uc = new Uint8ClampedArray(0);
const sG = {
  // data: Special handling for null, see below
  data: {
    type: "data",
    value: iG,
    async: !0
  },
  dataComparator: {
    type: "function",
    value: null,
    optional: !0
  },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (r) => r && r.__diff,
    optional: !0
  },
  dataTransform: {
    type: "function",
    value: null,
    optional: !0
  },
  onDataLoad: {
    type: "function",
    value: null,
    optional: !0
  },
  onError: {
    type: "function",
    value: null,
    optional: !0
  },
  fetch: {
    type: "function",
    value: (r, {
      propName: e,
      layer: t,
      loaders: i,
      loadOptions: n,
      signal: s
    }) => {
      const {
        resourceManager: c
      } = t.context;
      n = n || t.getLoadOptions(), i = i || t.props.loaders, s && (n = {
        ...n,
        fetch: {
          ...n?.fetch,
          signal: s
        }
      });
      let o = c.contains(r);
      return !o && !n && (c.add({
        resourceId: r,
        data: Wh(r, i),
        persistent: !1
      }), o = !0), o ? c.subscribe({
        resourceId: r,
        onChange: (d) => t.internalState?.reloadAsyncProp(e, d),
        consumerId: t.id,
        requestId: e
      }) : Wh(r, i, n);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  operation: "draw",
  onHover: {
    type: "function",
    value: null,
    optional: !0
  },
  onClick: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragStart: {
    type: "function",
    value: null,
    optional: !0
  },
  onDrag: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragEnd: {
    type: "function",
    value: null,
    optional: !0
  },
  coordinateSystem: Mi.DEFAULT,
  coordinateOrigin: {
    type: "array",
    value: [0, 0, 0],
    compare: !0
  },
  modelMatrix: {
    type: "array",
    value: null,
    compare: !0,
    optional: !0
  },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: {
    type: "object",
    value: {},
    optional: !0,
    compare: 2
  },
  loadOptions: {
    type: "object",
    value: null,
    optional: !0,
    ignore: !0
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: "array",
    value: [],
    optional: !0,
    ignore: !0
  },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({
      layerIndex: r
    }) => [0, -r * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: {
    type: "accessor",
    value: [0, 0, 128, 128]
  }
};
class zp extends r0 {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = Yd.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(e) {
    Ks(this.internalState);
    const t = this.internalState.viewport || this.context.viewport, i = pP(e, {
      viewport: t,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [n, s, c] = uP(i, t.pixelProjectionMatrix);
    return e.length === 2 ? [n, s] : [n, s, c];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(e) {
    return Ks(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(e, t) {
    Ks(this.internalState);
    const i = this.internalState.viewport || this.context.viewport;
    return Uz(e, {
      viewport: i,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...t
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !0;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(e) {
    this.setChangeFlags({
      stateChanged: !0
    }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const e = this.state;
    return e && (e.models || e.model && [e.model]) || [];
  }
  /** Update shader input parameters */
  setShaderModuleProps(...e) {
    for (const t of this.getModels())
      t.shaderInputs.setProps(...e);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem: e
    } = this.props;
    return e === Mi.DEFAULT || e === Mi.LNGLAT || e === Mi.CARTESIAN;
  }
  // Event handling
  onHover(e, t) {
    return this.props.onHover && this.props.onHover(e, t) || !1;
  }
  onClick(e, t) {
    return this.props.onClick && this.props.onClick(e, t) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(e, t = []) {
    return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(e) {
    Ks(e instanceof Uint8Array);
    const [t, i, n] = e;
    return t + i * 256 + n * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : RV(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    e = tS(e, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const t of this.props.extensions)
      e = tS(e, t.getShaders.call(this, t));
    return e;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(e) {
    const t = this.getAttributeManager(), {
      dataChanged: i
    } = e.changeFlags;
    if (i && t)
      if (Array.isArray(i))
        for (const n of i)
          t.invalidateAll(n);
      else
        t.invalidateAll();
    if (t) {
      const {
        props: n
      } = e, s = this.internalState.hasPickingBuffer, c = Number.isInteger(n.highlightedObjectIndex) || n.pickable || n.extensions.some((o) => o.getNeedsPickingBuffer.call(this, o));
      if (s !== c) {
        this.internalState.hasPickingBuffer = c;
        const {
          pickingColors: o,
          instancePickingColors: d
        } = t.attributes, m = o || d;
        m && (c && m.constant && (m.constant = !1, t.invalidate(m.id)), !m.value && !c && (m.constant = !0, m.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(e) {
    for (const i of this.getModels())
      i.destroy();
    const t = this.getAttributeManager();
    t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
      consumerId: this.id
    }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(e) {
    for (const t of this.getModels())
      t.draw(e.renderPass);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({
    info: e,
    mode: t,
    sourceLayer: i
  }) {
    const {
      index: n
    } = e;
    return n >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[n]), e;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(e, t) {
    t && (e = new Error(`${t}: ${e.message}`, {
      cause: e
    })), this.props.onError?.(e) || this.context?.onError?.(e, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(e = {
    clearRedrawFlags: !1
  }) {
    return this._getNeedsRedraw(e);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    return this.internalState?.uniformTransitions.active || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(e) {
    if (!this.internalState)
      return;
    const t = this.internalState.viewport;
    this.internalState.viewport = e, (!t || !nG({
      oldViewport: t,
      viewport: e
    })) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(e = "all") {
    const t = this.getAttributeManager();
    t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(e) {
    let t = !1;
    for (const i in e)
      e[i].layoutChanged() && (t = !0);
    for (const i of this.getModels())
      this._setModelAttributes(i, e, t);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const t = this.props, i = this.getNumInstances(), n = this.getStartIndices();
    e.update({
      data: t.data,
      numInstances: i,
      startIndices: n,
      props: t,
      transitions: t.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: t.data.attributes,
      context: this
    });
    const s = e.getChangedAttributes({
      clearChangedFlags: !0
    });
    this.updateAttributes(s);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const {
      uniformTransitions: e
    } = this.internalState;
    if (e.active) {
      const t = e.update(), i = Object.create(this.props);
      for (const n in t)
        Object.defineProperty(i, n, {
          value: t[n]
        });
      return i;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(e, {
    numInstances: t
  }) {
    if (e.constant)
      return;
    const i = Math.floor(uc.length / 4);
    if (this.internalState.usesPickingColorCache = !0, i < t) {
      t > rS && Ni.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), uc = Qg.allocate(uc, t, {
        size: 4,
        copy: !0,
        maxCount: Math.max(t, rS)
      });
      const n = Math.floor(uc.length / 4), s = [0, 0, 0];
      for (let c = i; c < n; c++)
        this.encodePickingColor(c, s), uc[c * 4 + 0] = s[0], uc[c * 4 + 1] = s[1], uc[c * 4 + 2] = s[2], uc[c * 4 + 3] = 0;
    }
    e.value = uc.subarray(0, t * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(e, t, i = !1) {
    if (!Object.keys(t).length)
      return;
    if (i) {
      const o = this.getAttributeManager();
      e.setBufferLayout(o.getBufferLayouts(e)), t = o.getAttributes();
    }
    const n = e.userData?.excludeAttributes || {}, s = {}, c = {};
    for (const o in t) {
      if (n[o])
        continue;
      const d = t[o].getValue();
      for (const m in d) {
        const y = d[m];
        y instanceof us ? t[o].settings.isIndexed ? e.setIndexBuffer(y) : s[m] = y : y && (c[m] = y);
      }
    }
    e.setAttributes(s), e.setConstantAttributes(c);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(e) {
    const t = this.props.data;
    if (!("attributes" in t)) {
      this._disablePickingIndex(e);
      return;
    }
    const {
      pickingColors: i,
      instancePickingColors: n
    } = this.getAttributeManager().attributes, s = i || n, c = s && t.attributes && t.attributes[s.id];
    if (c && c.value) {
      const o = c.value, d = this.encodePickingColor(e);
      for (let m = 0; m < t.length; m++) {
        const y = s.getVertexOffset(m);
        o[y] === d[0] && o[y + 1] === d[1] && o[y + 2] === d[2] && this._disablePickingIndex(m);
      }
    } else
      this._disablePickingIndex(e);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(e) {
    const {
      pickingColors: t,
      instancePickingColors: i
    } = this.getAttributeManager().attributes, n = t || i;
    if (!n)
      return;
    const s = n.getVertexOffset(e), c = n.getVertexOffset(e + 1);
    n.buffer.write(new Uint8Array(c - s), s);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const {
      pickingColors: e,
      instancePickingColors: t
    } = this.getAttributeManager().attributes, i = e || t;
    i && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && i.value.buffer !== uc.buffer && (i.value = uc.subarray(0, i.value.length)), i.updateSubBuffer({
      startOffset: 0
    }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    Ks(!this.internalState), Ks(Number.isFinite(this.props.coordinateSystem)), Vo(QV, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new JV({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (Ni.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new wV(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const t of this.props.extensions)
      t.initializeState.call(this, this.context, t);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(e) {
    Vo(rG, this, this === e);
    const {
      state: t,
      internalState: i
    } = e;
    this !== e && (this.internalState = i, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const e = this.needsUpdate();
    if (Vo(eG, this, e), !e)
      return;
    const t = this.props, i = this.context, n = this.internalState, s = i.viewport, c = this._updateUniformTransition();
    n.propsInTransition = c, i.viewport = n.viewport || s, this.props = c;
    try {
      const o = this._getUpdateParams(), d = this.getModels();
      if (i.device)
        this.updateState(o);
      else
        try {
          this.updateState(o);
        } catch {
        }
      for (const y of this.props.extensions)
        y.updateState.call(this, o, y);
      this.setNeedsRedraw(), this._updateAttributes();
      const m = this.getModels()[0] !== d[0];
      this._postUpdate(o, m);
    } finally {
      i.viewport = s, this.props = t, this._clearChangeFlags(), n.needsUpdate = !1, n.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    Vo(tG, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  // Calculates uniforms
  _drawLayer({
    renderPass: e,
    shaderModuleProps: t = null,
    uniforms: i = {},
    parameters: n = {}
  }) {
    this._updateAttributeTransition();
    const s = this.props, c = this.context;
    this.props = this.internalState.propsInTransition || s;
    try {
      t && this.setShaderModuleProps(t);
      const {
        getPolygonOffset: o
      } = this.props, d = o && o(i) || [0, 0];
      c.device instanceof Lv && c.device.setParametersWebGL({
        polygonOffset: d
      });
      for (const m of this.getModels())
        m.device.type === "webgpu" ? m.setParameters({
          ...m.parameters,
          ...n
        }) : m.setParameters(n);
      if (c.device instanceof Lv)
        c.device.withParametersWebGL(n, () => {
          const m = {
            renderPass: e,
            shaderModuleProps: t,
            uniforms: i,
            parameters: n,
            context: c
          };
          for (const y of this.props.extensions)
            y.draw.call(this, m, y);
          this.draw(m);
        });
      else {
        const m = {
          renderPass: e,
          shaderModuleProps: t,
          uniforms: i,
          parameters: n,
          context: c
        };
        for (const y of this.props.extensions)
          y.draw.call(this, m, y);
        this.draw(m);
      }
    } finally {
      this.props = s;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    return this.internalState?.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const {
      changeFlags: t
    } = this.internalState;
    for (const n in e)
      if (e[n]) {
        let s = !1;
        switch (n) {
          case "dataChanged":
            const c = e[n], o = t[n];
            c && Array.isArray(o) && (t.dataChanged = Array.isArray(c) ? o.concat(c) : c, s = !0);
          default:
            t[n] || (t[n] = e[n], s = !0);
        }
        s && Vo(KV, this, n, e);
      }
    const i = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
    t.propsOrDataChanged = i, t.somethingChanged = i || t.viewportChanged || t.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(e, t) {
    const i = TV(e, t);
    if (i.updateTriggersChanged)
      for (const n in i.updateTriggersChanged)
        i.updateTriggersChanged[n] && this.invalidateAttribute(n);
    if (i.transitionsChanged)
      for (const n in i.transitionsChanged)
        this.internalState.uniformTransitions.add(n, t[n], e[n], e.transitions?.[n]);
    return this.setChangeFlags(i);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    AV(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(e) {
    const t = {
      // @ts-ignore
      highlightedObjectColor: e.picked ? e.color : null
    }, {
      highlightColor: i
    } = this.props;
    e.picked && typeof i == "function" && (t.highlightColor = i(e)), this.setShaderModuleProps({
      picking: t
    }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const e = this.context;
    return new _V(e.device, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  // eslint-disable-next-line complexity
  _postUpdate(e, t) {
    const {
      props: i,
      oldProps: n
    } = e, s = this.state.model;
    s?.isInstanced && s.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight: c,
      highlightedObjectIndex: o,
      highlightColor: d
    } = i;
    if (t || n.autoHighlight !== c || n.highlightedObjectIndex !== o || n.highlightColor !== d) {
      const m = {};
      Array.isArray(d) && (m.highlightColor = d), (t || n.autoHighlight !== c || o !== n.highlightedObjectIndex) && (m.highlightedObjectColor = Number.isFinite(o) && o >= 0 ? this.encodePickingColor(o) : null), this.setShaderModuleProps({
        picking: m
      });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let t = !1;
    t = t || this.internalState.needsRedraw && this.id;
    const i = this.getAttributeManager(), n = i ? i.getNeedsRedraw(e) : !1;
    if (t = t || n, t)
      for (const s of this.props.extensions)
        s.onNeedsRedraw.call(this, s);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
zp.defaultProps = sG;
zp.layerName = "Layer";
const oG = "compositeLayer.renderLayers";
class XP extends zp {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !0;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !1;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(e) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({
    info: e
  }) {
    const {
      object: t
    } = e;
    return t && t.__source && t.__source.parent && t.__source.parent.id === this.id && (e.object = t.__source.object, e.index = t.__source.index), e;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(e) {
    return !0;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(e, t) {
    return t && t.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(e, t) {
    const {
      _subLayerProps: i
    } = this.props;
    return i && i[e] && i[e].type || t;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(e, t, i) {
    return e.__source = {
      parent: this,
      object: t,
      index: i
    }, e;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const t = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (i, n) => i && i.__source ? (t.index = i.__source.index, e(i.__source.object, t)) : e(i, n);
    }
    return e;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(e = {}) {
    const {
      opacity: t,
      pickable: i,
      visible: n,
      parameters: s,
      getPolygonOffset: c,
      highlightedObjectIndex: o,
      autoHighlight: d,
      highlightColor: m,
      coordinateSystem: y,
      coordinateOrigin: T,
      wrapLongitude: P,
      positionFormat: I,
      modelMatrix: D,
      extensions: k,
      fetch: $,
      operation: G,
      _subLayerProps: te
    } = this.props, Z = {
      id: "",
      updateTriggers: {},
      opacity: t,
      pickable: i,
      visible: n,
      parameters: s,
      getPolygonOffset: c,
      highlightedObjectIndex: o,
      autoHighlight: d,
      highlightColor: m,
      coordinateSystem: y,
      coordinateOrigin: T,
      wrapLongitude: P,
      positionFormat: I,
      modelMatrix: D,
      extensions: k,
      fetch: $,
      operation: G
    }, H = te && e.id && te[e.id], J = H && H.updateTriggers, re = e.id || "sublayer";
    if (H) {
      const be = this.props[$h], pe = e.type ? e.type._propTypes : {};
      for (const oe in H) {
        const Ee = pe[oe] || be[oe];
        Ee && Ee.type === "accessor" && (H[oe] = this.getSubLayerAccessor(H[oe]));
      }
    }
    Object.assign(
      Z,
      e,
      // experimental feature that allows users to override sublayer props via parent layer prop
      H
    ), Z.id = `${this.props.id}-${re}`, Z.updateTriggers = {
      all: this.props.updateTriggers?.all,
      ...e.updateTriggers,
      ...J
    };
    for (const be of k) {
      const pe = be.getSubLayerProps.call(this, be);
      pe && Object.assign(Z, pe, {
        updateTriggers: Object.assign(Z.updateTriggers, pe.updateTriggers)
      });
    }
    return Z;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(e, t) {
    let i = this.internalState.subLayers;
    const n = !i || this.needsUpdate();
    if (n) {
      const s = this.renderLayers();
      i = rd(s, Boolean), this.internalState.subLayers = i;
    }
    Vo(oG, this, n, i);
    for (const s of i)
      s.parent = this;
  }
}
XP.layerName = "CompositeLayer";
const u_ = Math.PI / 180, iS = 180 / Math.PI, Z_ = 6370972, sp = 256;
function aG() {
  const r = sp / Z_, e = Math.PI / 180 * sp;
  return {
    unitsPerMeter: [r, r, r],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / r, 1 / r, 1 / r],
    unitsPerDegree: [e, e, r],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / e, 1 / e, 1 / r]
  };
}
class lG extends Dp {
  constructor(e = {}) {
    const {
      longitude: t = 0,
      zoom: i = 0,
      // Matches Maplibre defaults
      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633
      nearZMultiplier: n = 0.5,
      farZMultiplier: s = 1,
      resolution: c = 10
    } = e;
    let {
      latitude: o = 0,
      height: d,
      altitude: m = 1.5,
      fovy: y
    } = e;
    o = Math.max(Math.min(o, zh), -zh), d = d || 1, y ? m = ax(y) : y = Kg(m);
    const T = 1 / Math.PI / Math.cos(o * Math.PI / 180), P = Math.pow(2, i) * T, I = e.nearZ ?? n, D = e.farZ ?? (m + sp * 2 * P / d) * s, k = new Pi().lookAt({
      eye: [0, -m, 0],
      up: [0, 0, 1]
    });
    k.rotateX(o * u_), k.rotateZ(-t * u_), k.scale(P / d), super({
      ...e,
      // x, y, width,
      height: d,
      // view matrix
      viewMatrix: k,
      longitude: t,
      latitude: o,
      zoom: i,
      // projection matrix parameters
      distanceScales: aG(),
      fovy: y,
      focalDistance: m,
      near: I,
      far: D
    }), this.scale = P, this.latitude = o, this.longitude = t, this.resolution = c;
  }
  get projectionMode() {
    return nl.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds(e = {}) {
    const t = {
      targetZ: e.z || 0
    }, i = this.unproject([0, this.height / 2], t), n = this.unproject([this.width / 2, 0], t), s = this.unproject([this.width, this.height / 2], t), c = this.unproject([this.width / 2, this.height], t);
    return s[0] < this.longitude && (s[0] += 360), i[0] > this.longitude && (i[0] -= 360), [Math.min(i[0], s[0], n[0], c[0]), Math.min(i[1], s[1], n[1], c[1]), Math.max(i[0], s[0], n[0], c[0]), Math.max(i[1], s[1], n[1], c[1])];
  }
  unproject(e, {
    topLeft: t = !0,
    targetZ: i
  } = {}) {
    const [n, s, c] = e, o = t ? s : this.height - s, {
      pixelUnprojectionMatrix: d
    } = this;
    let m;
    if (Number.isFinite(c))
      m = Vb(d, [n, o, c, 1]);
    else {
      const I = Vb(d, [n, o, -1, 1]), D = Vb(d, [n, o, 1, 1]), k = ((i || 0) / Z_ + 1) * sp, $ = Ab(DI([], I, D)), G = Ab(I), te = Ab(D), H = 4 * ((4 * G * te - ($ - G - te) ** 2) / 16) / $, J = Math.sqrt(G - H), re = Math.sqrt(Math.max(0, k * k - H)), be = (J - re) / Math.sqrt($);
      m = YN([], I, D, be);
    }
    const [y, T, P] = this.unprojectPosition(m);
    return Number.isFinite(c) ? [y, T, P] : Number.isFinite(i) ? [y, T, i] : [y, T];
  }
  projectPosition(e) {
    const [t, i, n = 0] = e, s = t * u_, c = i * u_, o = Math.cos(c), d = (n / Z_ + 1) * sp;
    return [Math.sin(s) * o * d, -Math.cos(s) * o * d, Math.sin(c) * d];
  }
  unprojectPosition(e) {
    const [t, i, n] = e, s = NI(e), c = Math.asin(n / s), d = Math.atan2(t, -i) * iS, m = c * iS, y = (s / sp - 1) * Z_;
    return [d, m, y];
  }
  projectFlat(e) {
    return e;
  }
  unprojectFlat(e) {
    return e;
  }
  panByPosition(e, t) {
    const i = this.unproject(t);
    return {
      longitude: e[0] - i[0] + this.longitude,
      latitude: e[1] - i[1] + this.latitude
    };
  }
}
function Vb(r, e) {
  const t = Op([], e, r);
  return rx(t, t, 1 / t[3]), t;
}
class cG extends xP {
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: i,
      zoom: n
    } = e;
    e.zoom = vc(n, i, t);
    const {
      longitude: s,
      latitude: c
    } = e;
    return (s < -180 || s > 180) && (e.longitude = Pz(s + 180, 360) - 180), e.latitude = vc(c, -zh, zh), e;
  }
}
class uG extends vP {
  constructor() {
    super(...arguments), this.ControllerState = cG, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new gx(["longitude", "latitude", "zoom"])
    }, this.dragMode = "pan";
  }
  setProps(e) {
    super.setProps(e), this.dragRotate = !1, this.touchRotate = !1;
  }
}
class ZP extends bP {
  constructor(e = {}) {
    super(e);
  }
  getViewportType(e) {
    return e.zoom > 12 ? ed : lG;
  }
  get ControllerType() {
    return uG;
  }
}
ZP.displayName = "GlobeView";
const rm = "mapbox", Gb = 512, hG = Math.PI / 180;
function YP({
  map: r,
  gl: e,
  deck: t
}) {
  if (r.__deck)
    return r.__deck;
  const i = t?.props._customRender, n = t?.props.onLoad, s = {
    ...t?.props,
    _customRender: () => {
      r.triggerRepaint(), i?.("");
    }
  };
  s.parameters = {
    ...Y_(r, !0),
    ...s.parameters
  }, s.views || (s.views = jg(r));
  let c;
  return (!t || t.props.gl === e) && (Object.assign(s, {
    gl: e,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: im(r)
  }), t?.isInitialized ? nS(t, r) : s.onLoad = () => {
    n?.(), nS(c, r);
  }), t ? (c = t, t.setProps(s), t.userData.isExternal = !0) : (c = new tm(s), r.on("remove", () => {
    JP(r);
  })), c.userData.mapboxLayers = /* @__PURE__ */ new Set(), r.__deck = c, r.on("render", () => {
    c.isInitialized && _G(c, r);
  }), c;
}
function nS(r, e) {
  const t = () => {
    r.isInitialized ? yG(r, e) : e.off("move", t);
  };
  e.on("move", t);
}
function JP(r) {
  r.__deck?.finalize(), r.__deck = null;
}
function Y_(r, e) {
  const t = e ? {
    depthWriteEnabled: !0,
    depthCompare: "less-equal",
    depthBias: 0,
    blend: !0,
    blendColorSrcFactor: "src-alpha",
    blendColorDstFactor: "one-minus-src-alpha",
    blendAlphaSrcFactor: "one",
    blendAlphaDstFactor: "one-minus-src-alpha",
    blendColorOperation: "add",
    blendAlphaOperation: "add"
  } : {};
  return Sx(r) === "globe" && (t.cullMode = "back"), t;
}
function fG(r, e) {
  r.userData.mapboxLayers.add(e), Ex(r);
}
function dG(r, e) {
  r.userData.mapboxLayers.delete(e), Ex(r);
}
function pG(r, e) {
  Ex(r);
}
function gG(r, e, t, i) {
  let {
    currentViewport: n
  } = r.userData, s = !1;
  n || (n = KP(r, e, i), r.userData.currentViewport = n, s = !0), r.isInitialized && r._drawLayers("mapbox-repaint", {
    viewports: [n],
    layerFilter: (c) => (!r.props.layerFilter || r.props.layerFilter(c)) && (t.id === c.layer.id || c.layer.props.operation.includes("terrain")),
    clearStack: s,
    clearCanvas: !1
  });
}
function Sx(r) {
  const e = r.getProjection?.(), t = (
    // maplibre projection spec
    e?.type || // mapbox projection spec
    e?.name
  );
  if (t === "globe")
    return "globe";
  if (t && t !== "mercator")
    throw new Error("Unsupported projection");
  return "mercator";
}
function jg(r) {
  return Sx(r) === "globe" ? new ZP({
    id: rm
  }) : new mx({
    id: rm
  });
}
function im(r) {
  const {
    lng: e,
    lat: t
  } = r.getCenter(), i = {
    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
    // https://github.com/visgl/deck.gl/issues/6894
    longitude: (e + 540) % 360 - 180,
    latitude: t,
    zoom: r.getZoom(),
    bearing: r.getBearing(),
    pitch: r.getPitch(),
    padding: r.getPadding(),
    repeat: r.getRenderWorldCopies()
  };
  return r.getTerrain?.() && mG(r, i), i;
}
function mG(r, e) {
  if (r.getFreeCameraOptions) {
    const {
      position: t
    } = r.getFreeCameraOptions();
    if (!t || t.z === void 0)
      return;
    const i = r.transform.height, {
      longitude: n,
      latitude: s,
      pitch: c
    } = e, o = t.x * Gb, d = (1 - t.y) * Gb, m = t.z * Gb, y = Jg([n, s]), T = o - y[0], P = d - y[1], I = Math.sqrt(T * T + P * P), D = c * hG, k = 1.5 * i, $ = D < 1e-3 ? (
      // Pitch angle too small to deduce the look at point, assume elevation is 0
      k * Math.cos(D) / m
    ) : k * Math.sin(D) / I;
    e.zoom = Math.log2($);
    const G = k * Math.cos(D) / $, te = m - G;
    e.position = [0, 0, te / W_(s)];
  } else typeof r.transform.elevation == "number" && (e.position = [0, 0, r.transform.elevation]);
}
function KP(r, e, t) {
  const i = im(e), {
    views: n
  } = r.props, s = n && rd(n).find((d) => d.id === rm) || jg(e);
  t && (s.props.nearZMultiplier = 0.2);
  const c = t?.nearZ ?? e.transform._nearZ, o = t?.farZ ?? e.transform._farZ;
  return Number.isFinite(c) && (i.nearZ = c / e.transform.height, i.farZ = o / e.transform.height), s.makeViewport({
    width: r.width,
    height: r.height,
    viewState: i
  });
}
function _G(r, e) {
  const {
    mapboxLayers: t,
    isExternal: i
  } = r.userData;
  if (i) {
    const n = Array.from(t, (y) => y.id), c = rd(r.props.layers, Boolean).some((y) => y && !n.includes(y.id));
    let o = r.getViewports();
    const d = o.findIndex((y) => y.id === rm), m = o.length > 1 || d < 0;
    (c || m) && (d >= 0 && (o = o.slice(), o[d] = KP(r, e)), r._drawLayers("mapbox-repaint", {
      viewports: o,
      layerFilter: (y) => (!r.props.layerFilter || r.props.layerFilter(y)) && (y.viewport.id !== rm || !n.includes(y.layer.id)),
      clearCanvas: !1
    }));
  }
  r.userData.currentViewport = null;
}
function yG(r, e) {
  r.setProps({
    viewState: im(e)
  }), r.needsRedraw({
    clearRedrawFlags: !0
  });
}
function Ex(r) {
  if (r.userData.isExternal)
    return;
  const e = [];
  r.userData.mapboxLayers.forEach((t) => {
    const i = t.props.type, n = new i(t.props);
    e.push(n);
  }), r.setProps({
    layers: e
  });
}
class bG {
  /* eslint-disable no-this-before-super */
  constructor(e) {
    if (!e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.slot = e.slot, this.map = null, this.deck = null, this.props = e;
  }
  /* Mapbox custom layer methods */
  onAdd(e, t) {
    this.map = e, this.deck = YP({
      map: e,
      gl: t,
      deck: this.props.deck
    }), fG(this.deck, this);
  }
  onRemove() {
    this.deck && dG(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, {
      id: this.id
    }), this.deck && pG(this.deck);
  }
  render(e, t) {
    gG(this.deck, this.map, this, t);
  }
}
const $b = "__UNDEFINED__";
function h_(r, e, t, i) {
  if (!r || !e || !r.style || !r.style._loaded)
    return;
  const n = rd(i, Boolean);
  if (t !== i) {
    const o = rd(t, Boolean), d = new Set(o.map((m) => m.id));
    for (const m of n)
      d.delete(m.id);
    for (const m of d)
      r.getLayer(m) && r.removeLayer(m);
  }
  for (const o of n) {
    const d = r.getLayer(o.id);
    d ? (d.implementation || d).setProps(o.props) : r.addLayer(
      new bG({
        id: o.id,
        deck: e,
        // @ts-expect-error slot is not defined in LayerProps
        slot: o.props.slot
      }),
      // @ts-expect-error beforeId is not defined in LayerProps
      o.props.beforeId
    );
  }
  const s = r.style._order, c = {};
  for (const o of n) {
    let {
      beforeId: d
    } = o.props;
    (!d || !s.includes(d)) && (d = $b), c[d] = c[d] || [], c[d].push(o.id);
  }
  for (const o in c) {
    const d = c[o];
    let m = o === $b ? s.length : s.indexOf(o), y = o === $b ? void 0 : o;
    for (let T = d.length - 1; T >= 0; T--) {
      const P = d[T], I = s.indexOf(P);
      I !== m - 1 && (r.moveLayer(P, y), I > m && m++), m--, y = P;
    }
  }
}
class vG {
  constructor(e) {
    this._handleStyleChange = () => {
      if (h_(this._map, this._deck, this._props.layers, this._props.layers), !this._map) return;
      Sx(this._map) && !this._props.views && this._deck?.setProps({
        views: jg(this._map)
      });
    }, this._updateContainerSize = () => {
      if (this._map && this._container) {
        const {
          clientWidth: i,
          clientHeight: n
        } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${i}px`,
          height: `${n}px`
        });
      }
    }, this._updateViewState = () => {
      const i = this._deck, n = this._map;
      i && n && (i.setProps({
        views: this._props.views || jg(n),
        viewState: im(n)
      }), i.isInitialized && i.redraw());
    }, this._handleMouseEvent = (i) => {
      const n = this._deck;
      if (!n || !n.isInitialized)
        return;
      const s = {
        type: i.type,
        offsetCenter: i.point,
        srcEvent: i
      }, c = this._lastMouseDownPoint;
      switch (!i.point && c && (s.deltaX = i.originalEvent.clientX - c.clientX, s.deltaY = i.originalEvent.clientY - c.clientY, s.offsetCenter = {
        x: c.x + s.deltaX,
        y: c.y + s.deltaY
      }), s.type) {
        case "mousedown":
          n._onPointerDown(s), this._lastMouseDownPoint = {
            ...i.point,
            clientX: i.originalEvent.clientX,
            clientY: i.originalEvent.clientY
          };
          break;
        case "dragstart":
          s.type = "panstart", n._onEvent(s);
          break;
        case "drag":
          s.type = "panmove", n._onEvent(s);
          break;
        case "dragend":
          s.type = "panend", n._onEvent(s);
          break;
        case "click":
          s.tapCount = 1, n._onEvent(s);
          break;
        case "dblclick":
          s.type = "click", s.tapCount = 2, n._onEvent(s);
          break;
        case "mousemove":
          s.type = "pointermove", n._onPointerMove(s);
          break;
        case "mouseout":
          s.type = "pointerleave", n._onPointerMove(s);
          break;
        default:
          return;
      }
    };
    const {
      interleaved: t = !1
    } = e;
    this._interleaved = t, this._props = this.filterProps(e);
  }
  /** Filter out props to pass to Deck **/
  filterProps(e) {
    const {
      interleaved: t = !1,
      useDevicePixels: i,
      ...n
    } = e;
    return !t && i !== void 0 && (n.useDevicePixels = i), n;
  }
  /** Update (partial) props of the underlying Deck instance. */
  setProps(e) {
    this._interleaved && e.layers && h_(this._map, this._deck, this._props.layers, e.layers), Object.assign(this._props, this.filterProps(e)), this._deck && this._map && this._deck.setProps({
      ...this._props,
      parameters: {
        ...Y_(this._map, this._interleaved),
        ...this._props.parameters
      }
    });
  }
  // The local Map type is for internal typecheck only. It does not necesarily satisefy mapbox/maplibre types at runtime.
  // Do not restrict the argument type here to avoid type conflict.
  /** Called when the control is added to a map */
  onAdd(e) {
    return this._map = e, this._interleaved ? this._onAddInterleaved(e) : this._onAddOverlaid(e);
  }
  _onAddOverlaid(e) {
    const t = document.createElement("div");
    return Object.assign(t.style, {
      position: "absolute",
      left: 0,
      top: 0,
      textAlign: "initial",
      pointerEvents: "none"
    }), this._container = t, this._deck = new tm({
      ...this._props,
      parent: t,
      parameters: {
        ...Y_(e, !1),
        ...this._props.parameters
      },
      views: this._props.views || jg(e),
      viewState: im(e)
    }), e.on("resize", this._updateContainerSize), e.on("render", this._updateViewState), e.on("mousedown", this._handleMouseEvent), e.on("dragstart", this._handleMouseEvent), e.on("drag", this._handleMouseEvent), e.on("dragend", this._handleMouseEvent), e.on("mousemove", this._handleMouseEvent), e.on("mouseout", this._handleMouseEvent), e.on("click", this._handleMouseEvent), e.on("dblclick", this._handleMouseEvent), this._updateContainerSize(), t;
  }
  _onAddInterleaved(e) {
    const t = e.painter.context.gl;
    return t instanceof WebGLRenderingContext && Ni.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")(), this._deck = YP({
      map: e,
      gl: t,
      deck: new tm({
        ...this._props,
        gl: t,
        parameters: {
          ...Y_(e, !1),
          ...this._props.parameters
        },
        deviceProps: {
          createCanvasContext: {
            autoResize: !0
          }
        }
      })
    }), e.on("styledata", this._handleStyleChange), h_(e, this._deck, [], this._props.layers), document.createElement("div");
  }
  /** Called when the control is removed from a map */
  onRemove() {
    const e = this._map;
    e && (this._interleaved ? this._onRemoveInterleaved(e) : this._onRemoveOverlaid(e)), this._deck = void 0, this._map = void 0, this._container = void 0;
  }
  _onRemoveOverlaid(e) {
    e.off("resize", this._updateContainerSize), e.off("render", this._updateViewState), e.off("mousedown", this._handleMouseEvent), e.off("dragstart", this._handleMouseEvent), e.off("drag", this._handleMouseEvent), e.off("dragend", this._handleMouseEvent), e.off("mousemove", this._handleMouseEvent), e.off("mouseout", this._handleMouseEvent), e.off("click", this._handleMouseEvent), e.off("dblclick", this._handleMouseEvent), this._deck?.finalize();
  }
  _onRemoveInterleaved(e) {
    e.off("styledata", this._handleStyleChange), h_(e, this._deck, this._props.layers, []), JP(e);
  }
  getDefaultPosition() {
    return "top-left";
  }
  /** Forwards the Deck.pickObject method */
  pickObject(e) {
    return Ks(this._deck), this._deck.pickObject(e);
  }
  /** Forwards the Deck.pickMultipleObjects method */
  pickMultipleObjects(e) {
    return Ks(this._deck), this._deck.pickMultipleObjects(e);
  }
  /** Forwards the Deck.pickObjects method */
  pickObjects(e) {
    return Ks(this._deck), this._deck.pickObjects(e);
  }
  /** Remove from map and releases all resources */
  finalize() {
    this._map && this._map.removeControl(this);
  }
  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
  getCanvas() {
    return this._map ? this._interleaved ? this._map.getCanvas() : this._deck.getCanvas() : null;
  }
}
const xG = (
  /* wgsl */
  `struct PointCloudUniforms {
  radiusPixels: f32,
  sizeUnits: i32,
};

@group(0) @binding(3)
var<uniform> pointCloud: PointCloudUniforms;
`
), sS = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`, wG = {
  name: "pointCloud",
  source: xG,
  vs: sS,
  fs: sS,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
}, AG = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, TG = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, SG = (
  /* wgsl */
  `struct ConstantAttributes {
  instanceNormals: vec3<f32>,
  instanceColors: vec4<f32>,
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(1.0, 0.0, 0.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceNormals: vec3<f32>,
  @location(4) instanceColors: vec4<f32>,
  @location(5) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) unitPosition: vec2<f32>,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;
  
  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;
  // geometry.normal = project_normal(instanceNormals);

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  // Find the center of the point and add the current vertex
  let offset = vec3<f32>(attributes.positions.xy * project_unit_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
  // DECKGL_FILTER_SIZE(offset, geometry);

  varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
  // DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  let clipPixels = project_pixel_size_to_clipspace(offset.xy);
  varyings.position.x += clipPixels.x;
  varyings.position.y += clipPixels.y;

  // Apply lighting
  let lightColor = lighting_getLightColor2(attributes.instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);

  // Apply opacity to instance color, or return instance picking color
  varyings.vColor = vec4(lightColor, attributes.instanceColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(vColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition.xy;

  let distToCenter = length(varyings.unitPosition);
  if (distToCenter > 1.0) {
    discard;
  }

  var fragColor: vec4<f32>;

  fragColor = varyings.vColor;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
}
`
), QP = [0, 0, 0, 255], eM = [0, 0, 1], EG = {
  sizeUnits: "pixels",
  pointSize: {
    type: "number",
    min: 0,
    value: 10
  },
  //  point radius in pixels
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getNormal: {
    type: "accessor",
    value: eM
  },
  getColor: {
    type: "accessor",
    value: QP
  },
  material: !0,
  // Depreated
  radiusPixels: {
    deprecatedFor: "pointSize"
  }
};
function CG(r) {
  const {
    header: e,
    attributes: t
  } = r;
  if (!(!e || !t) && (r.length = e.vertexCount, t.POSITION && (t.instancePositions = t.POSITION), t.NORMAL && (t.instanceNormals = t.NORMAL), t.COLOR_0)) {
    const {
      size: i,
      value: n
    } = t.COLOR_0;
    t.instanceColors = {
      size: i,
      type: "unorm8",
      value: n
    };
  }
}
class Cx extends zp {
  getShaders() {
    return super.getShaders({
      vs: AG,
      fs: TG,
      source: SG,
      modules: [sx, S8, ZI, cx, wG]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: eM
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: QP
      }
    });
  }
  updateState(e) {
    const {
      changeFlags: t,
      props: i
    } = e;
    super.updateState(e), t.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), t.dataChanged && CG(i.data);
  }
  draw({
    uniforms: e
  }) {
    const {
      pointSize: t,
      sizeUnits: i
    } = this.props, n = this.state.model, s = {
      sizeUnits: Yg[i],
      radiusPixels: t
    };
    n.shaderInputs.setProps({
      pointCloud: s
    }), this.context.device.type === "webgpu" && (n.instanceCount = this.props.data.length), n.draw(this.context.renderPass);
  }
  _getModel() {
    const e = this.context.device.type === "webgpu" ? {
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    } : void 0, t = [];
    for (let i = 0; i < 3; i++) {
      const n = i / 3 * Math.PI * 2;
      t.push(Math.cos(n) * 2, Math.sin(n) * 2, 0);
    }
    return new Zh(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new dp({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(t)
        }
      }),
      parameters: e,
      isInstanced: !0
    });
  }
}
Cx.layerName = "PointCloudLayer";
Cx.defaultProps = EG;
const rl = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};
new xt();
new xt();
const pg = new xt(), oS = new xt();
class dm {
  /** Creates a bounding sphere */
  constructor(e = [0, 0, 0], t = 0) {
    this.radius = -0, this.center = new xt(), this.fromCenterRadius(e, t);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(e, t) {
    return this.center.from(e), this.radius = t, this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(e, t) {
    return t = pg.from(t), this.center = new xt().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new dm(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(e) {
    const t = this.center, i = this.radius, n = e.center, s = e.radius, c = pg.copy(n).subtract(t), o = c.magnitude();
    if (i >= o + s)
      return this.clone();
    if (s >= o + i)
      return e.clone();
    const d = (i + o + s) * 0.5;
    return oS.copy(c).scale((-i + d) / o).add(t), this.center.copy(oS), this.radius = d, this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(e) {
    const i = pg.from(e).subtract(this.center).magnitude();
    return i > this.radius && (this.radius = i), this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(e) {
    this.center.transform(e);
    const t = mF(pg, e);
    return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(e) {
    const t = this.distanceTo(e);
    return t * t;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(e) {
    const i = pg.from(e).subtract(this.center);
    return Math.max(0, i.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(e) {
    const t = this.center, i = this.radius, s = e.normal.dot(t) + e.distance;
    return s < -i ? rl.OUTSIDE : s < i ? rl.INTERSECTING : rl.INSIDE;
  }
}
const IG = new xt(), PG = new xt(), f_ = new xt(), d_ = new xt(), p_ = new xt(), MG = new xt(), RG = new xt(), Yu = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class pm {
  constructor(e = [0, 0, 0], t = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new xt().from(e), this.halfAxes = new hs(t);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), i = this.halfAxes.getColumn(2);
    return [new xt(e).len(), new xt(t).len(), new xt(i).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), i = this.halfAxes.getColumn(2), n = new xt(e).normalize(), s = new xt(t).normalize(), c = new xt(i).normalize();
    return new Xg().fromMatrix3(new hs([...n, ...s, ...c]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(e, t, i) {
    const n = new Xg(i), s = new hs().fromQuaternion(n);
    return s[0] = s[0] * t[0], s[1] = s[1] * t[0], s[2] = s[2] * t[0], s[3] = s[3] * t[1], s[4] = s[4] * t[1], s[5] = s[5] * t[1], s[6] = s[6] * t[2], s[7] = s[7] * t[2], s[8] = s[8] * t[2], this.center = new xt().from(e), this.halfAxes = s, this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new pm(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(e = new dm()) {
    const t = this.halfAxes, i = t.getColumn(0, f_), n = t.getColumn(1, d_), s = t.getColumn(2, p_), c = IG.copy(i).add(n).add(s);
    return e.center.copy(this.center), e.radius = c.magnitude(), e;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(e) {
    const t = this.center, i = e.normal, n = this.halfAxes, s = i.x, c = i.y, o = i.z, d = Math.abs(s * n[Yu.COLUMN0ROW0] + c * n[Yu.COLUMN0ROW1] + o * n[Yu.COLUMN0ROW2]) + Math.abs(s * n[Yu.COLUMN1ROW0] + c * n[Yu.COLUMN1ROW1] + o * n[Yu.COLUMN1ROW2]) + Math.abs(s * n[Yu.COLUMN2ROW0] + c * n[Yu.COLUMN2ROW1] + o * n[Yu.COLUMN2ROW2]), m = i.dot(t) + e.distance;
    return m <= -d ? rl.OUTSIDE : m >= d ? rl.INSIDE : rl.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(e) {
    const t = PG.from(e).subtract(this.center), i = this.halfAxes, n = i.getColumn(0, f_), s = i.getColumn(1, d_), c = i.getColumn(2, p_), o = n.magnitude(), d = s.magnitude(), m = c.magnitude();
    n.normalize(), s.normalize(), c.normalize();
    let y = 0, T;
    return T = Math.abs(t.dot(n)) - o, T > 0 && (y += T * T), T = Math.abs(t.dot(s)) - d, T > 0 && (y += T * T), T = Math.abs(t.dot(c)) - m, T > 0 && (y += T * T), y;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(e, t, i = [-0, -0]) {
    let n = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    const c = this.center, o = this.halfAxes, d = o.getColumn(0, f_), m = o.getColumn(1, d_), y = o.getColumn(2, p_), T = MG.copy(d).add(m).add(y).add(c), P = RG.copy(T).subtract(e);
    let I = t.dot(P);
    return n = Math.min(I, n), s = Math.max(I, s), T.copy(c).add(d).add(m).subtract(y), P.copy(T).subtract(e), I = t.dot(P), n = Math.min(I, n), s = Math.max(I, s), T.copy(c).add(d).subtract(m).add(y), P.copy(T).subtract(e), I = t.dot(P), n = Math.min(I, n), s = Math.max(I, s), T.copy(c).add(d).subtract(m).subtract(y), P.copy(T).subtract(e), I = t.dot(P), n = Math.min(I, n), s = Math.max(I, s), c.copy(T).subtract(d).add(m).add(y), P.copy(T).subtract(e), I = t.dot(P), n = Math.min(I, n), s = Math.max(I, s), c.copy(T).subtract(d).add(m).subtract(y), P.copy(T).subtract(e), I = t.dot(P), n = Math.min(I, n), s = Math.max(I, s), c.copy(T).subtract(d).subtract(m).add(y), P.copy(T).subtract(e), I = t.dot(P), n = Math.min(I, n), s = Math.max(I, s), c.copy(T).subtract(d).subtract(m).subtract(y), P.copy(T).subtract(e), I = t.dot(P), n = Math.min(I, n), s = Math.max(I, s), i[0] = n, i[1] = s, i;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    this.center.transformAsPoint(e);
    const t = this.halfAxes.getColumn(0, f_);
    t.transformAsPoint(e);
    const i = this.halfAxes.getColumn(1, d_);
    i.transformAsPoint(e);
    const n = this.halfAxes.getColumn(2, p_);
    return n.transformAsPoint(e), this.halfAxes = new hs([...t, ...i, ...n]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const aS = new xt(), lS = new xt();
class gu {
  constructor(e = [0, 0, 1], t = 0) {
    this.normal = new xt(), this.distance = -0, this.fromNormalDistance(e, t);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(e, t) {
    return bc(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(e, t) {
    e = aS.from(e), this.normal.from(t).normalize();
    const i = -this.normal.dot(e);
    return this.distance = i, this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(e, t, i, n) {
    return this.normal.set(e, t, i), bc(Ac(this.normal.len(), 1)), this.distance = n, this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new gu(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(e) {
    return Ac(this.distance, e.distance) && Ac(this.normal, e.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(e) {
    const t = lS.copy(this.normal).transformAsVector(e).normalize(), i = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(i, t);
  }
  projectPointOntoPlane(e, t = [0, 0, 0]) {
    const i = aS.from(e), n = this.getPointDistance(i), s = lS.copy(this.normal).scale(n);
    return i.subtract(s).to(t);
  }
}
const cS = [new xt([1, 0, 0]), new xt([0, 1, 0]), new xt([0, 0, 1])], uS = new xt(), LG = new xt();
class Ll {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(e = []) {
    this.planes = e;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(e) {
    this.planes.length = 2 * cS.length;
    const t = e.center, i = e.radius;
    let n = 0;
    for (const s of cS) {
      let c = this.planes[n], o = this.planes[n + 1];
      c || (c = this.planes[n] = new gu()), o || (o = this.planes[n + 1] = new gu());
      const d = uS.copy(s).scale(-i).add(t);
      c.fromPointNormal(d, s);
      const m = uS.copy(s).scale(i).add(t), y = LG.copy(s).negate();
      o.fromPointNormal(m, y), n += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(e) {
    let t = rl.INSIDE;
    for (const i of this.planes)
      switch (e.intersectPlane(i)) {
        case rl.OUTSIDE:
          return rl.OUTSIDE;
        case rl.INTERSECTING:
          t = rl.INTERSECTING;
          break;
      }
    return t;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(e, t) {
    if (bc(Number.isFinite(t), "parentPlaneMask is required."), t === Ll.MASK_OUTSIDE || t === Ll.MASK_INSIDE)
      return t;
    let i = Ll.MASK_INSIDE;
    const n = this.planes;
    for (let s = 0; s < this.planes.length; ++s) {
      const c = s < 31 ? 1 << s : 0;
      if (s < 31 && (t & c) === 0)
        continue;
      const o = n[s], d = e.intersectPlane(o);
      if (d === rl.OUTSIDE)
        return Ll.MASK_OUTSIDE;
      d === rl.INTERSECTING && (i |= c);
    }
    return i;
  }
}
Ll.MASK_OUTSIDE = 4294967295;
Ll.MASK_INSIDE = 0;
Ll.MASK_INDETERMINATE = 2147483647;
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
new xt();
const fu = new hs(), BG = new hs(), kG = new hs(), g_ = new hs(), hS = new hs();
function OG(r, e = {}) {
  const t = t8, i = 10;
  let n = 0, s = 0;
  const c = BG, o = kG;
  c.identity(), o.copy(r);
  const d = t * DG(o);
  for (; s < i && NG(o) > d; )
    FG(o, g_), hS.copy(g_).transpose(), o.multiplyRight(g_), o.multiplyLeft(hS), c.multiplyRight(g_), ++n > 2 && (++s, n = 0);
  return e.unitary = c.toTarget(e.unitary), e.diagonal = o.toTarget(e.diagonal), e;
}
function DG(r) {
  let e = 0;
  for (let t = 0; t < 9; ++t) {
    const i = r[t];
    e += i * i;
  }
  return Math.sqrt(e);
}
const Fv = [1, 0, 0], Uv = [2, 2, 1];
function NG(r) {
  let e = 0;
  for (let t = 0; t < 3; ++t) {
    const i = r[fu.getElementIndex(Uv[t], Fv[t])];
    e += 2 * i * i;
  }
  return Math.sqrt(e);
}
function FG(r, e) {
  const t = $I;
  let i = 0, n = 1;
  for (let m = 0; m < 3; ++m) {
    const y = Math.abs(r[fu.getElementIndex(Uv[m], Fv[m])]);
    y > i && (n = m, i = y);
  }
  const s = Fv[n], c = Uv[n];
  let o = 1, d = 0;
  if (Math.abs(r[fu.getElementIndex(c, s)]) > t) {
    const m = r[fu.getElementIndex(c, c)], y = r[fu.getElementIndex(s, s)], T = r[fu.getElementIndex(c, s)], P = (m - y) / 2 / T;
    let I;
    P < 0 ? I = -1 / (-P + Math.sqrt(1 + P * P)) : I = 1 / (P + Math.sqrt(1 + P * P)), o = 1 / Math.sqrt(1 + I * I), d = I * o;
  }
  return hs.IDENTITY.to(e), e[fu.getElementIndex(s, s)] = e[fu.getElementIndex(c, c)] = o, e[fu.getElementIndex(c, s)] = d, e[fu.getElementIndex(s, c)] = -d, e;
}
const Lh = new xt(), UG = new xt(), zG = new xt(), jG = new xt(), VG = new xt(), GG = new hs(), $G = {
  diagonal: new hs(),
  unitary: new hs()
};
function HG(r, e = new pm()) {
  if (!r || r.length === 0)
    return e.halfAxes = new hs([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new xt(), e;
  const t = r.length, i = new xt(0, 0, 0);
  for (const oe of r)
    i.add(oe);
  const n = 1 / t;
  i.multiplyByScalar(n);
  let s = 0, c = 0, o = 0, d = 0, m = 0, y = 0;
  for (const oe of r) {
    const Ee = Lh.copy(oe).subtract(i);
    s += Ee.x * Ee.x, c += Ee.x * Ee.y, o += Ee.x * Ee.z, d += Ee.y * Ee.y, m += Ee.y * Ee.z, y += Ee.z * Ee.z;
  }
  s *= n, c *= n, o *= n, d *= n, m *= n, y *= n;
  const T = GG;
  T[0] = s, T[1] = c, T[2] = o, T[3] = c, T[4] = d, T[5] = m, T[6] = o, T[7] = m, T[8] = y;
  const {
    unitary: P
  } = OG(T, $G), I = e.halfAxes.copy(P);
  let D = I.getColumn(0, zG), k = I.getColumn(1, jG), $ = I.getColumn(2, VG), G = -Number.MAX_VALUE, te = -Number.MAX_VALUE, Z = -Number.MAX_VALUE, H = Number.MAX_VALUE, J = Number.MAX_VALUE, re = Number.MAX_VALUE;
  for (const oe of r)
    Lh.copy(oe), G = Math.max(Lh.dot(D), G), te = Math.max(Lh.dot(k), te), Z = Math.max(Lh.dot($), Z), H = Math.min(Lh.dot(D), H), J = Math.min(Lh.dot(k), J), re = Math.min(Lh.dot($), re);
  D = D.multiplyByScalar(0.5 * (H + G)), k = k.multiplyByScalar(0.5 * (J + te)), $ = $.multiplyByScalar(0.5 * (re + Z)), e.center.copy(D).add(k).add($);
  const be = UG.set(G - H, te - J, Z - re).multiplyByScalar(0.5), pe = new hs([be[0], 0, 0, 0, be[1], 0, 0, 0, be[2]]);
  return e.halfAxes.multiplyRight(pe), e;
}
const Hb = Math.PI / 180, m_ = new Float32Array(16), fS = new Float32Array(12);
function dS(r, e, t) {
  const i = e[0] * Hb, n = e[1] * Hb, s = e[2] * Hb, c = Math.sin(s), o = Math.sin(i), d = Math.sin(n), m = Math.cos(s), y = Math.cos(i), T = Math.cos(n), P = t[0], I = t[1], D = t[2];
  r[0] = P * T * y, r[1] = P * d * y, r[2] = P * -o, r[3] = I * (-d * m + T * o * c), r[4] = I * (T * m + d * o * c), r[5] = I * y * c, r[6] = D * (d * c + T * o * m), r[7] = D * (-T * c + d * o * m), r[8] = D * y * m;
}
function pS(r) {
  return r[0] = r[0], r[1] = r[1], r[2] = r[2], r[3] = r[4], r[4] = r[5], r[5] = r[6], r[6] = r[8], r[7] = r[9], r[8] = r[10], r[9] = r[12], r[10] = r[13], r[11] = r[14], r.subarray(0, 12);
}
const tM = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(r, {
    startRow: e,
    endRow: t
  }) {
    const {
      data: i,
      getOrientation: n,
      getScale: s,
      getTranslation: c,
      getTransformMatrix: o
    } = this.props, d = Array.isArray(o), m = d && o.length === 16, y = Array.isArray(s), T = Array.isArray(n), P = Array.isArray(c), I = m || !d && !!o(i[0]);
    I ? r.constant = m : r.constant = T && y && P;
    const D = r.value;
    if (r.constant) {
      let k;
      I ? (m_.set(o), k = pS(m_)) : (k = fS, dS(k, n, s), k.set(c, 9)), r.value = new Float32Array(k);
    } else {
      let k = e * r.size;
      const {
        iterable: $,
        objectInfo: G
      } = OP(i, e, t);
      for (const te of $) {
        G.index++;
        let Z;
        if (I)
          m_.set(m ? o : o(te, G)), Z = pS(m_);
        else {
          Z = fS;
          const H = T ? n : n(te, G), J = y ? s : s(te, G);
          dS(Z, H, J), Z.set(P ? c : c(te, G), 9);
        }
        D[k++] = Z[0], D[k++] = Z[1], D[k++] = Z[2], D[k++] = Z[3], D[k++] = Z[4], D[k++] = Z[5], D[k++] = Z[6], D[k++] = Z[7], D[k++] = Z[8], D[k++] = Z[9], D[k++] = Z[10], D[k++] = Z[11];
      }
    }
  }
};
function rM(r, e) {
  return e === Mi.CARTESIAN || e === Mi.METER_OFFSETS || e === Mi.DEFAULT && !r.isGeospatial;
}
const gS = `uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`, qG = {
  name: "simpleMesh",
  vs: gS,
  fs: gS,
  uniformTypes: {
    sizeScale: "f32",
    composeModelMatrix: "f32",
    hasTexture: "f32",
    flatShading: "f32"
  }
}, WG = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;
if (simpleMesh.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, XG = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;
function qb(r) {
  const e = r.positions || r.POSITION;
  Ni.assert(e, 'no "postions" or "POSITION" attribute in mesh');
  const t = e.value.length / e.size;
  let i = r.COLOR_0 || r.colors;
  i || (i = {
    size: 3,
    value: new Float32Array(t * 3).fill(1)
  });
  let n = r.NORMAL || r.normals;
  n || (n = {
    size: 3,
    value: new Float32Array(t * 3).fill(0)
  });
  let s = r.TEXCOORD_0 || r.texCoords;
  return s || (s = {
    size: 2,
    value: new Float32Array(t * 2).fill(0)
  }), {
    positions: e,
    colors: i,
    normals: n,
    texCoords: s
  };
}
function mS(r) {
  return r instanceof dp ? (r.attributes = qb(r.attributes), r) : r.attributes ? new dp({
    ...r,
    topology: "triangle-list",
    attributes: qb(r.attributes)
  }) : new dp({
    topology: "triangle-list",
    attributes: qb(r)
  });
}
const ZG = [0, 0, 0, 255], YG = {
  mesh: {
    type: "object",
    value: null,
    async: !0
  },
  texture: {
    type: "image",
    value: null,
    async: !0
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: !0,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: !1,
  // Optional material for 'lighting' shader module
  material: !0,
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getColor: {
    type: "accessor",
    value: ZG
  },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  // 4x4 matrix
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: !0,
    value: null
  }
};
class Ix extends zp {
  getShaders() {
    return super.getShaders({
      vs: WG,
      fs: XG,
      modules: [sx, YI, cx, qG]
    });
  }
  getBounds() {
    if (this.props._instanced)
      return super.getBounds();
    let e = this.state.positionBounds;
    if (e)
      return e;
    const {
      mesh: t
    } = this.props;
    if (!t)
      return null;
    if (e = t.header?.boundingBox, !e) {
      const {
        attributes: i
      } = mS(t);
      i.POSITION = i.POSITION || i.positions, e = L6(i);
    }
    return this.state.positionBounds = e, e;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: !0,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: tM
    }), this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i,
      changeFlags: n
    } = e;
    if (t.mesh !== i.mesh || n.extensionsChanged) {
      if (this.state.positionBounds = null, this.state.model?.destroy(), t.mesh) {
        this.state.model = this.getModel(t.mesh);
        const s = t.mesh.attributes || t.mesh;
        this.setState({
          hasNormals: !!(s.NORMAL || s.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    t.texture !== i.texture && t.texture instanceof Fs && this.setTexture(t.texture), this.state.model && this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw({
    uniforms: e
  }) {
    const {
      model: t
    } = this.state;
    if (!t)
      return;
    const {
      viewport: i,
      renderPass: n
    } = this.context, {
      sizeScale: s,
      coordinateSystem: c,
      _instanced: o
    } = this.props, d = {
      sizeScale: s,
      composeModelMatrix: !o || rM(i, c),
      flatShading: !this.state.hasNormals
    };
    t.shaderInputs.setProps({
      simpleMesh: d
    }), t.draw(n);
  }
  get isLoaded() {
    return !!(this.state?.model && super.isLoaded);
  }
  getModel(e) {
    const t = new Zh(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: mS(e),
      isInstanced: !0
    }), {
      texture: i
    } = this.props, {
      emptyTexture: n
    } = this.state, s = {
      sampler: i || n,
      hasTexture: !!i
    };
    return t.shaderInputs.setProps({
      simpleMesh: s
    }), t;
  }
  setTexture(e) {
    const {
      emptyTexture: t,
      model: i
    } = this.state;
    if (i) {
      const n = {
        sampler: e || t,
        hasTexture: !!e
      };
      i.shaderInputs.setProps({
        simpleMesh: n
      });
    }
  }
}
Ix.defaultProps = YG;
Ix.layerName = "SimpleMeshLayer";
const JG = "4.3.3";
function KG(r) {
  globalThis.loaders ||= {}, globalThis.loaders.modules ||= {}, Object.assign(globalThis.loaders.modules, r);
}
function QG(r) {
  return globalThis.loaders?.modules?.[r] || null;
}
function e$() {
  return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.3"), globalThis._loadersgl_.version;
}
const t$ = e$();
function r$(r, e) {
  if (!r)
    throw new Error("loaders.gl assertion failed.");
}
const gm = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), Px = typeof importScripts == "function", _S = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
_S && parseFloat(_S[1]);
const Wb = {};
async function Oy(r, e = null, t = {}, i = null) {
  return e && (r = i$(r, e, t, i)), Wb[r] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  Wb[r] || n$(r), await Wb[r];
}
function i$(r, e, t = {}, i = null) {
  if (!t.useLocalLibraries && r.startsWith("http"))
    return r;
  i = i || r;
  const n = t.modules || {};
  return n[i] ? n[i] : gm ? t.CDN ? (r$(t.CDN.startsWith("http")), `${t.CDN}/${e}@${t$}/dist/libs/${i}`) : Px ? `../src/libs/${i}` : `modules/${e}/src/libs/${i}` : `modules/${e}/dist/libs/${i}`;
}
async function n$(r) {
  if (r.endsWith("wasm"))
    return await o$(r);
  if (!gm)
    try {
      const {
        requireFromFile: t
      } = globalThis.loaders || {};
      return await t?.(r);
    } catch (t) {
      return console.error(t), null;
    }
  if (Px)
    return importScripts(r);
  const e = await a$(r);
  return s$(e, r);
}
function s$(r, e) {
  if (!gm) {
    const {
      requireFromString: i
    } = globalThis.loaders || {};
    return i?.(r, e);
  }
  if (Px)
    return eval.call(globalThis, r), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(r));
  } catch {
    t.text = r;
  }
  return document.body.appendChild(t), null;
}
async function o$(r) {
  const {
    readFileAsArrayBuffer: e
  } = globalThis.loaders || {};
  return gm || !e || r.startsWith("http") ? await (await fetch(r)).arrayBuffer() : await e(r);
}
async function a$(r) {
  const {
    readFileAsText: e
  } = globalThis.loaders || {};
  return gm || !e || r.startsWith("http") ? await (await fetch(r)).text() : await e(r);
}
const Dy = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
let yS;
async function bS(r) {
  KG(r.modules);
  const e = QG("basis");
  return e || (yS ||= l$(r), await yS);
}
async function l$(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Oy(Dy.TRANSCODER, "textures", r), await Oy(Dy.TRANSCODER_WASM, "textures", r)]), e = e || globalThis.BASIS, await c$(e, t);
}
function c$(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    r(t).then((n) => {
      const {
        BasisFile: s,
        initializeBasis: c
      } = n;
      c(), i({
        BasisFile: s
      });
    });
  });
}
let Xb;
async function vS(r) {
  const e = r.modules || {};
  return e.basisEncoder ? e.basisEncoder : (Xb = Xb || u$(r), await Xb);
}
async function u$(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Oy(Dy.ENCODER, "textures", r), await Oy(Dy.ENCODER_WASM, "textures", r)]), e = e || globalThis.BASIS, await h$(e, t);
}
function h$(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    r(t).then((n) => {
      const {
        BasisFile: s,
        KTX2File: c,
        initializeBasis: o,
        BasisEncoder: d
      } = n;
      o(), i({
        BasisFile: s,
        KTX2File: c,
        BasisEncoder: d
      });
    });
  });
}
const Gd = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808
}, f$ = ["", "WEBKIT_", "MOZ_"], xS = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
let __ = null;
function d$(r) {
  if (!__) {
    r = r || p$() || void 0, __ = /* @__PURE__ */ new Set();
    for (const e of f$)
      for (const t in xS)
        if (r && r.getExtension(`${e}${t}`)) {
          const i = xS[t];
          __.add(i);
        }
  }
  return __;
}
function p$() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
const Qa = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function g$(r) {
  const e = new Uint8Array(r);
  return !(e.byteLength < Qa.length || e[0] !== Qa[0] || // '´'
  e[1] !== Qa[1] || // 'K'
  e[2] !== Qa[2] || // 'T'
  e[3] !== Qa[3] || // 'X'
  e[4] !== Qa[4] || // ' '
  e[5] !== Qa[5] || // '2'
  e[6] !== Qa[6] || // '0'
  e[7] !== Qa[7] || // 'ª'
  e[8] !== Qa[8] || // '\r'
  e[9] !== Qa[9] || // '\n'
  e[10] !== Qa[10] || // '\x1A'
  e[11] !== Qa[11]);
}
const m$ = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: Gd.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: {
    basisFormat: 1,
    compressed: !0
  },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: Gd.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: Gd.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: {
    basisFormat: 4,
    compressed: !0
  },
  bc5: {
    basisFormat: 5,
    compressed: !0
  },
  "bc7-m6-opaque-only": {
    basisFormat: 6,
    compressed: !0
  },
  "bc7-m5": {
    basisFormat: 7,
    compressed: !0
  },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: Gd.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: Gd.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: Gd.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": {
    basisFormat: 11,
    compressed: !0
  },
  "atc-rgba-interpolated-alpha": {
    basisFormat: 12,
    compressed: !0
  },
  rgba32: {
    basisFormat: 13,
    compressed: !1
  },
  rgb565: {
    basisFormat: 14,
    compressed: !1
  },
  bgr565: {
    basisFormat: 15,
    compressed: !1
  },
  rgba4444: {
    basisFormat: 16,
    compressed: !1
  }
};
async function _$(r, e) {
  if (e.basis.containerFormat === "auto") {
    if (g$(r)) {
      const i = await vS(e);
      return wS(i.KTX2File, r, e);
    }
    const {
      BasisFile: t
    } = await bS(e);
    return Zb(t, r, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const t = await vS(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return wS(t.KTX2File, r, e);
        case "basis":
        default:
          return Zb(t.BasisFile, r, e);
      }
    case "transcoder":
    default:
      const {
        BasisFile: i
      } = await bS(e);
      return Zb(i, r, e);
  }
}
function Zb(r, e, t) {
  const i = new r(new Uint8Array(e));
  try {
    if (!i.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const n = i.getNumImages(), s = [];
    for (let c = 0; c < n; c++) {
      const o = i.getNumLevels(c), d = [];
      for (let m = 0; m < o; m++)
        d.push(y$(i, c, m, t));
      s.push(d);
    }
    return s;
  } finally {
    i.close(), i.delete();
  }
}
function y$(r, e, t, i) {
  const n = r.getImageWidth(e, t), s = r.getImageHeight(e, t), c = r.getHasAlpha(
    /* imageIndex, levelIndex */
  ), {
    compressed: o,
    format: d,
    basisFormat: m
  } = iM(i, c), y = r.getImageTranscodedSizeInBytes(e, t, m), T = new Uint8Array(y);
  if (!r.transcodeImage(T, e, t, m, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    // standard loaders.gl image category payload
    width: n,
    height: s,
    data: T,
    compressed: o,
    format: d,
    // Additional fields
    // Add levelSize field.
    hasAlpha: c
  };
}
function wS(r, e, t) {
  const i = new r(new Uint8Array(e));
  try {
    if (!i.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const n = i.getLevels(), s = [];
    for (let c = 0; c < n; c++)
      s.push(b$(i, c, t));
    return [s];
  } finally {
    i.close(), i.delete();
  }
}
function b$(r, e, t) {
  const {
    alphaFlag: i,
    height: n,
    width: s
  } = r.getImageLevelInfo(e, 0, 0), {
    compressed: c,
    format: o,
    basisFormat: d
  } = iM(t, i), m = r.getImageTranscodedSizeInBytes(e, 0, 0, d), y = new Uint8Array(m);
  if (!r.transcodeImage(
    y,
    e,
    0,
    0,
    d,
    0,
    -1,
    -1
    /* channel1 */
  ))
    throw new Error("Failed to transcode KTX2 image");
  return {
    // standard loaders.gl image category payload
    width: s,
    height: n,
    data: y,
    compressed: c,
    // Additional fields
    levelSize: m,
    hasAlpha: i,
    format: o
  };
}
function iM(r, e) {
  let t = r && r.basis && r.basis.format;
  return t === "auto" && (t = nM()), typeof t == "object" && (t = e ? t.alpha : t.noAlpha), t = t.toLowerCase(), m$[t];
}
function nM() {
  const r = d$();
  return r.has("astc") ? "astc-4x4" : r.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : r.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : r.has("etc1") ? "etc1" : r.has("etc2") ? "etc2" : "rgb565";
}
const v$ = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: JG,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, x$ = {
  ...v$,
  parse: _$
};
function w$(r) {
  return {
    addressModeU: AS(r.wrapS),
    addressModeV: AS(r.wrapT),
    magFilter: A$(r.magFilter),
    ...T$(r.minFilter)
  };
}
function AS(r) {
  switch (r) {
    case 33071:
      return "clamp-to-edge";
    case 10497:
      return "repeat";
    case 33648:
      return "mirror-repeat";
    default:
      return;
  }
}
function A$(r) {
  switch (r) {
    case 9728:
      return "nearest";
    case 9729:
      return "linear";
    default:
      return;
  }
}
function T$(r) {
  switch (r) {
    case 9728:
      return {
        minFilter: "nearest"
      };
    case 9729:
      return {
        minFilter: "linear"
      };
    case 9984:
      return {
        minFilter: "nearest",
        mipmapFilter: "nearest"
      };
    case 9985:
      return {
        minFilter: "linear",
        mipmapFilter: "nearest"
      };
    case 9986:
      return {
        minFilter: "nearest",
        mipmapFilter: "linear"
      };
    case 9987:
      return {
        minFilter: "linear",
        mipmapFilter: "linear"
      };
    default:
      return {};
  }
}
function sM(r, e, t, i) {
  const n = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: !0,
      SRGB_FAST_APPROXIMATION: !0
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      camera: [0, 0, 0],
      // Model should override
      metallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  n.defines.USE_TEX_LOD = !0;
  const {
    imageBasedLightingEnvironment: s
  } = i;
  return s && (n.bindings.pbr_diffuseEnvSampler = s.diffuseEnvSampler.texture, n.bindings.pbr_specularEnvSampler = s.specularEnvSampler.texture, n.bindings.pbr_BrdfLUT = s.brdfLutTexture.texture, n.uniforms.scaleIBLAmbient = [1, 1]), i?.pbrDebug && (n.defines.PBR_DEBUG = !0, n.uniforms.scaleDiffBaseMR = [0, 0, 0, 0], n.uniforms.scaleFGDSpec = [0, 0, 0, 0]), t.NORMAL && (n.defines.HAS_NORMALS = !0), t.TANGENT && i?.useTangents && (n.defines.HAS_TANGENTS = !0), t.TEXCOORD_0 && (n.defines.HAS_UV = !0), i?.imageBasedLightingEnvironment && (n.defines.USE_IBL = !0), i?.lights && (n.defines.USE_LIGHTS = !0), e && S$(r, e, n), n;
}
function S$(r, e, t) {
  if (t.uniforms.unlit = !!e.unlit, e.pbrMetallicRoughness && E$(r, e.pbrMetallicRoughness, t), e.normalTexture) {
    Vg(r, e.normalTexture, "pbr_normalSampler", "HAS_NORMALMAP", t);
    const {
      scale: i = 1
    } = e.normalTexture;
    t.uniforms.normalScale = i;
  }
  if (e.occlusionTexture) {
    Vg(r, e.occlusionTexture, "pbr_occlusionSampler", "HAS_OCCLUSIONMAP", t);
    const {
      strength: i = 1
    } = e.occlusionTexture;
    t.uniforms.occlusionStrength = i;
  }
  switch (e.emissiveTexture && (Vg(r, e.emissiveTexture, "pbr_emissiveSampler", "HAS_EMISSIVEMAP", t), t.uniforms.emissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode || "MASK") {
    case "MASK":
      const {
        alphaCutoff: i = 0.5
      } = e;
      t.defines.ALPHA_CUTOFF = !0, t.uniforms.alphaCutoff = i;
      break;
    case "BLEND":
      Ht.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(), t.parameters.blend = !0, t.parameters.blendColorOperation = "add", t.parameters.blendColorSrcFactor = "src-alpha", t.parameters.blendColorDstFactor = "one-minus-src-alpha", t.parameters.blendAlphaOperation = "add", t.parameters.blendAlphaSrcFactor = "one", t.parameters.blendAlphaDstFactor = "one-minus-src-alpha", t.glParameters.blend = !0, t.glParameters.blendEquation = 32774, t.glParameters.blendFunc = [770, 771, 1, 771];
      break;
  }
}
function E$(r, e, t) {
  e.baseColorTexture && Vg(r, e.baseColorTexture, "pbr_baseColorSampler", "HAS_BASECOLORMAP", t), t.uniforms.baseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && Vg(r, e.metallicRoughnessTexture, "pbr_metallicRoughnessSampler", "HAS_METALROUGHNESSMAP", t);
  const {
    metallicFactor: i = 1,
    roughnessFactor: n = 1
  } = e;
  t.uniforms.metallicRoughnessValues = [i, n];
}
function Vg(r, e, t, i, n) {
  const s = e.texture.source.image;
  let c;
  s.compressed ? c = s : c = {
    data: s
  };
  const o = {
    wrapS: 10497,
    // default REPEAT S (U) wrapping mode.
    wrapT: 10497,
    // default REPEAT T (V) wrapping mode.
    ...e?.texture?.sampler
  }, d = r.createTexture({
    id: e.uniformName || e.id,
    sampler: w$(o),
    ...c
  });
  n.bindings[t] = d, i && (n.defines[i] = !0), n.generatedTextures.push(d);
}
var Rf;
(function(r) {
  r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(Rf || (Rf = {}));
function C$(r) {
  switch (r) {
    case Rf.POINTS:
      return "point-list";
    case Rf.LINES:
      return "line-list";
    case Rf.LINE_STRIP:
      return "line-strip";
    case Rf.TRIANGLES:
      return "triangle-list";
    case Rf.TRIANGLE_STRIP:
      return "triangle-strip";
    default:
      throw new Error(String(r));
  }
}
const I$ = (
  /* WGSL */
  `
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
), P$ = (
  /* glsl */
  `#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`
), M$ = (
  /* glsl */
  `#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
function R$(r, e) {
  const {
    id: t,
    geometry: i,
    parsedPPBRMaterial: n,
    vertexCount: s,
    modelOptions: c = {}
  } = e;
  Ht.info(4, "createGLTFModel defines: ", n.defines)();
  const o = [], d = {
    depthWriteEnabled: !0,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  }, m = {
    id: t,
    source: I$,
    vs: P$,
    fs: M$,
    geometry: i,
    topology: i.topology,
    vertexCount: s,
    modules: [ix],
    ...c,
    defines: {
      ...n.defines,
      ...c.defines
    },
    parameters: {
      ...d,
      ...n.parameters,
      ...c.parameters
    }
  }, y = new Zh(r, m), {
    camera: T,
    ...P
  } = {
    ...n.uniforms,
    ...c.uniforms,
    ...n.bindings,
    ...c.bindings
  };
  return y.shaderInputs.setProps({
    pbrMaterial: P,
    pbrProjection: {
      camera: T
    }
  }), new Ev({
    managedResources: o,
    model: y
  });
}
const L$ = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: void 0,
  lights: !0,
  useTangents: !1
};
function B$(r, e, t = {}) {
  const i = {
    ...L$,
    ...t
  };
  return e.scenes.map((s) => k$(r, s, e.nodes, i));
}
function k$(r, e, t, i) {
  const s = (e.nodes || []).map((o) => oM(r, o, t, i));
  return new Fp({
    id: e.name || e.id,
    children: s
  });
}
function oM(r, e, t, i) {
  if (!e._node) {
    const c = (e.children || []).map((d) => oM(r, d, t, i));
    e.mesh && c.push(O$(r, e.mesh, i));
    const o = new Fp({
      id: e.name || e.id,
      children: c
    });
    if (e.matrix)
      o.setMatrix(e.matrix);
    else {
      if (o.matrix.identity(), e.translation && o.matrix.translate(e.translation), e.rotation) {
        const d = new Pi().fromQuaternion(e.rotation);
        o.matrix.multiplyRight(d);
      }
      e.scale && o.matrix.scale(e.scale);
    }
    e._node = o;
  }
  const n = t.find((s) => s.id === e.id);
  return n._node = e._node, e._node;
}
function O$(r, e, t) {
  if (!e._mesh) {
    const n = (e.primitives || []).map((c, o) => D$(r, c, o, e, t)), s = new Fp({
      id: e.name || e.id,
      children: n
    });
    e._mesh = s;
  }
  return e._mesh;
}
function D$(r, e, t, i, n) {
  const s = e.name || `${i.name || i.id}-primitive-${t}`, c = C$(e.mode || 4), o = e.indices ? e.indices.count : N$(e.attributes), d = TS(s, e, c), m = sM(r, e.material, d.attributes, n), y = R$(r, {
    id: s,
    geometry: TS(s, e, c),
    parsedPPBRMaterial: m,
    modelOptions: n.modelOptions,
    vertexCount: o
  });
  return y.bounds = [e.attributes.POSITION.min, e.attributes.POSITION.max], y;
}
function N$(r) {
  throw new Error("getVertexCount not implemented");
}
function TS(r, e, t) {
  const i = {};
  for (const [n, s] of Object.entries(e.attributes)) {
    const {
      components: c,
      size: o,
      value: d
    } = s;
    i[n] = {
      size: o ?? c,
      value: d
    };
  }
  return new dp({
    id: r,
    topology: t,
    indices: e.indices.value,
    attributes: i
  });
}
const Yb = new Xg();
function F$(r, {
  input: e,
  interpolation: t,
  output: i
}, n, s) {
  const c = e[e.length - 1], o = r % c, d = e.findIndex((P) => P >= o), m = Math.max(0, d - 1);
  if (!Array.isArray(n[s]))
    switch (s) {
      case "translation":
        n[s] = [0, 0, 0];
        break;
      case "rotation":
        n[s] = [0, 0, 0, 1];
        break;
      case "scale":
        n[s] = [1, 1, 1];
        break;
      default:
        Ht.warn(`Bad animation path ${s}`)();
    }
  const y = e[m], T = e[d];
  switch (t) {
    case "STEP":
      j$(n, s, i[m]);
      break;
    case "LINEAR":
      if (T > y) {
        const P = (o - y) / (T - y);
        U$(n, s, i[m], i[d], P);
      }
      break;
    case "CUBICSPLINE":
      if (T > y) {
        const P = (o - y) / (T - y), I = T - y, D = i[3 * m + 1], k = i[3 * m + 2], $ = i[3 * d + 0], G = i[3 * d + 1];
        z$(n, s, {
          p0: D,
          outTangent0: k,
          inTangent1: $,
          p1: G,
          tDiff: I,
          ratio: P
        });
      }
      break;
    default:
      Ht.warn(`Interpolation ${t} not supported`)();
      break;
  }
}
function U$(r, e, t, i, n) {
  if (!r[e])
    throw new Error();
  if (e === "rotation") {
    Yb.slerp({
      start: t,
      target: i,
      ratio: n
    });
    for (let s = 0; s < Yb.length; s++)
      r[e][s] = Yb[s];
  } else
    for (let s = 0; s < t.length; s++)
      r[e][s] = n * i[s] + (1 - n) * t[s];
}
function z$(r, e, {
  p0: t,
  outTangent0: i,
  inTangent1: n,
  p1: s,
  tDiff: c,
  ratio: o
}) {
  if (!r[e])
    throw new Error();
  for (let d = 0; d < r[e].length; d++) {
    const m = i[d] * c, y = n[d] * c;
    r[e][d] = (2 * Math.pow(o, 3) - 3 * Math.pow(o, 2) + 1) * t[d] + (Math.pow(o, 3) - 2 * Math.pow(o, 2) + o) * m + (-2 * Math.pow(o, 3) + 3 * Math.pow(o, 2)) * s[d] + (Math.pow(o, 3) - Math.pow(o, 2)) * y;
  }
}
function j$(r, e, t) {
  if (!r[e])
    throw new Error();
  for (let i = 0; i < t.length; i++)
    r[e][i] = t[i];
}
class V$ {
  animation;
  startTime = 0;
  playing = !0;
  speed = 1;
  constructor(e) {
    this.animation = e.animation, this.animation.name ||= "unnamed", Object.assign(this, e);
  }
  setTime(e) {
    if (!this.playing)
      return;
    const i = (e / 1e3 - this.startTime) * this.speed;
    this.animation.channels.forEach(({
      sampler: n,
      target: s,
      path: c
    }) => {
      F$(i, n, s, c), H$(s, s._node);
    });
  }
}
class G$ {
  animations;
  constructor(e) {
    this.animations = e.animations.map((t, i) => {
      const n = t.name || `Animation-${i}`;
      return new V$({
        animation: {
          name: n,
          channels: t.channels
        }
      });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(e) {
    Ht.warn("GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead")(), this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((t) => t.setTime(e));
  }
  getAnimations() {
    return this.animations;
  }
}
const $$ = new Pi();
function H$(r, e) {
  if (e.matrix.identity(), r.translation && e.matrix.translate(r.translation), r.rotation) {
    const t = $$.fromQuaternion(r.rotation);
    e.matrix.multiplyRight(t);
  }
  r.scale && e.matrix.scale(r.scale);
}
const q$ = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, W$ = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function X$(r) {
  const e = W$[r.componentType], t = q$[r.type], i = t * r.count, {
    buffer: n,
    byteOffset: s = 0
  } = r.bufferView?.data ?? {};
  return {
    typedArray: new e(n, s + (r.byteOffset || 0), i),
    components: t
  };
}
function Z$(r) {
  return (r.animations || []).map((t, i) => {
    const n = t.name || `Animation-${i}`, s = t.samplers.map(({
      input: o,
      interpolation: d = "LINEAR",
      output: m
    }) => ({
      input: SS(r.accessors[o]),
      interpolation: d,
      output: SS(r.accessors[m])
    })), c = t.channels.map(({
      sampler: o,
      target: d
    }) => ({
      sampler: s[o],
      target: r.nodes[d.node ?? 0],
      path: d.path
    }));
    return {
      name: n,
      channels: c
    };
  });
}
function SS(r) {
  if (!r._animation) {
    const {
      typedArray: e,
      components: t
    } = X$(r);
    if (t === 1)
      r._animation = Array.from(e);
    else {
      const i = [];
      for (let n = 0; n < e.length; n += t)
        i.push(Array.from(e.slice(n, n + t)));
      r._animation = i;
    }
  }
  return r._animation;
}
function zv(r) {
  if (ArrayBuffer.isView(r) || r instanceof ArrayBuffer || r instanceof ImageBitmap)
    return r;
  if (Array.isArray(r))
    return r.map(zv);
  if (r && typeof r == "object") {
    const e = {};
    for (const t in r)
      e[t] = zv(r[t]);
    return e;
  }
  return r;
}
function Y$(r, e, t) {
  e = zv(e);
  const i = B$(r, e, t), n = Z$(e), s = new G$({
    animations: n
  });
  return {
    scenes: i,
    animator: s
  };
}
const J$ = "4.3.3";
async function aM(r, e, t, i) {
  return i._parse(r, e, t, i);
}
function id(r, e) {
  if (!r)
    throw new Error("loader assertion failed.");
}
const lM = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), ES = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
ES && parseFloat(ES[1]);
function K$(r, e = 5) {
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? CS(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? CS(r, 0, e) : "";
}
function CS(r, e, t) {
  if (r.byteLength <= e + t)
    return "";
  const i = new DataView(r);
  let n = "";
  for (let s = 0; s < t; s++)
    n += String.fromCharCode(i.getUint8(e + s));
  return n;
}
function Q$(r) {
  try {
    return JSON.parse(r);
  } catch {
    throw new Error(`Failed to parse JSON from data starting with "${K$(r)}"`);
  }
}
function cM(r, e, t) {
  const i = t !== void 0 ? new Uint8Array(r).subarray(e, e + t) : new Uint8Array(r).subarray(e);
  return new Uint8Array(i).buffer;
}
function mm(r, e) {
  return id(r >= 0), id(e > 0), r + (e - 1) & -4;
}
function eH(r, e, t) {
  let i;
  if (r instanceof ArrayBuffer)
    i = new Uint8Array(r);
  else {
    const n = r.byteOffset, s = r.byteLength;
    i = new Uint8Array(r.buffer || r.arrayBuffer, n, s);
  }
  return e.set(i, t), t + mm(i.byteLength, 4);
}
const tH = globalThis.loaders?.parseImageNode, jv = typeof Image < "u", Vv = typeof ImageBitmap < "u", rH = !!tH, Gv = lM ? !0 : rH;
function iH(r) {
  switch (r) {
    case "auto":
      return Vv || jv || Gv;
    case "imagebitmap":
      return Vv;
    case "image":
      return jv;
    case "data":
      return Gv;
    default:
      throw new Error(`@loaders.gl/images: image ${r} not supported in this environment`);
  }
}
function nH() {
  if (Vv)
    return "imagebitmap";
  if (jv)
    return "image";
  if (Gv)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function sH(r) {
  const e = oH(r);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function uM(r) {
  switch (sH(r)) {
    case "data":
      return r;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = r.width, e.height = r.height, t.drawImage(r, 0, 0), t.getImageData(0, 0, r.width, r.height);
    default:
      throw new Error("getImageData");
  }
}
function oH(r) {
  return typeof ImageBitmap < "u" && r instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && r instanceof Image ? "image" : r && typeof r == "object" && r.data && r.width && r.height ? "data" : null;
}
const aH = /^data:image\/svg\+xml/, lH = /\.svg((\?|#).*)?$/;
function Mx(r) {
  return r && (aH.test(r) || lH.test(r));
}
function cH(r, e) {
  if (Mx(e)) {
    let i = new TextDecoder().decode(r);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (i = unescape(encodeURIComponent(i)));
    } catch (s) {
      throw new Error(s.message);
    }
    return `data:image/svg+xml;base64,${btoa(i)}`;
  }
  return hM(r, e);
}
function hM(r, e) {
  if (Mx(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(r)]);
}
async function fM(r, e, t) {
  const i = cH(r, t), n = self.URL || self.webkitURL, s = typeof i != "string" && n.createObjectURL(i);
  try {
    return await uH(s || i, e);
  } finally {
    s && n.revokeObjectURL(s);
  }
}
async function uH(r, e) {
  const t = new Image();
  return t.src = r, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((i, n) => {
    try {
      t.onload = () => i(t), t.onerror = (s) => {
        const c = s instanceof Error ? s.message : "error";
        n(new Error(c));
      };
    } catch (s) {
      n(s);
    }
  });
}
const hH = {};
let IS = !0;
async function fH(r, e, t) {
  let i;
  Mx(t) ? i = await fM(r, e, t) : i = hM(r, t);
  const n = e && e.imagebitmap;
  return await dH(i, n);
}
async function dH(r, e = null) {
  if ((pH(e) || !IS) && (e = null), e)
    try {
      return await createImageBitmap(r, e);
    } catch (t) {
      console.warn(t), IS = !1;
    }
  return await createImageBitmap(r);
}
function pH(r) {
  for (const e in r || hH)
    return !1;
  return !0;
}
function gH(r) {
  return !bH(r, "ftyp", 4) || (r[8] & 96) === 0 ? null : mH(r);
}
function mH(r) {
  switch (_H(r, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function _H(r, e, t) {
  return String.fromCharCode(...r.slice(e, t));
}
function yH(r) {
  return [...r].map((e) => e.charCodeAt(0));
}
function bH(r, e, t = 0) {
  const i = yH(e);
  for (let n = 0; n < i.length; ++n)
    if (i[n] !== r[n + t])
      return !1;
  return !0;
}
const _u = !1, Gg = !0;
function Rx(r) {
  const e = _m(r);
  return xH(e) || TH(e) || wH(e) || AH(e) || vH(e);
}
function vH(r) {
  const e = new Uint8Array(r instanceof DataView ? r.buffer : r), t = gH(e);
  return t ? {
    mimeType: t.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function xH(r) {
  const e = _m(r);
  return e.byteLength >= 24 && e.getUint32(0, _u) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, _u),
    height: e.getUint32(20, _u)
  } : null;
}
function wH(r) {
  const e = _m(r);
  return e.byteLength >= 10 && e.getUint32(0, _u) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, Gg),
    height: e.getUint16(8, Gg)
  } : null;
}
function AH(r) {
  const e = _m(r);
  return e.byteLength >= 14 && e.getUint16(0, _u) === 16973 && e.getUint32(2, Gg) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, Gg),
    height: e.getUint32(22, Gg)
  } : null;
}
function TH(r) {
  const e = _m(r);
  if (!(e.byteLength >= 3 && e.getUint16(0, _u) === 65496 && e.getUint8(2) === 255))
    return null;
  const {
    tableMarkers: i,
    sofMarkers: n
  } = SH();
  let s = 2;
  for (; s + 9 < e.byteLength; ) {
    const c = e.getUint16(s, _u);
    if (n.has(c))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(s + 5, _u),
        // Number of lines
        width: e.getUint16(s + 7, _u)
        // Number of pixels per line
      };
    if (!i.has(c))
      return null;
    s += 2, s += e.getUint16(s, _u);
  }
  return null;
}
function SH() {
  const r = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    r.add(t);
  return {
    tableMarkers: r,
    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
  };
}
function _m(r) {
  if (r instanceof DataView)
    return r;
  if (ArrayBuffer.isView(r))
    return new DataView(r.buffer);
  if (r instanceof ArrayBuffer)
    return new DataView(r);
  throw new Error("toDataView");
}
async function EH(r, e) {
  const {
    mimeType: t
  } = Rx(r) || {}, i = globalThis.loaders?.parseImageNode;
  return id(i), await i(r, t);
}
async function CH(r, e, t) {
  e = e || {};
  const n = (e.image || {}).type || "auto", {
    url: s
  } = t || {}, c = IH(n);
  let o;
  switch (c) {
    case "imagebitmap":
      o = await fH(r, e, s);
      break;
    case "image":
      o = await fM(r, e, s);
      break;
    case "data":
      o = await EH(r);
      break;
    default:
      id(!1);
  }
  return n === "data" && (o = uM(o)), o;
}
function IH(r) {
  switch (r) {
    case "auto":
    case "data":
      return nH();
    default:
      return iH(r), r;
  }
}
const PH = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], MH = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], RH = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, LH = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: J$,
  mimeTypes: MH,
  extensions: PH,
  parse: CH,
  // TODO: byteOffset, byteLength;
  tests: [(r) => !!Rx(new DataView(r))],
  options: RH
}, Jb = {};
function BH(r) {
  if (Jb[r] === void 0) {
    const e = lM ? OH(r) : kH(r);
    Jb[r] = e;
  }
  return Jb[r];
}
function kH(r) {
  const e = ["image/png", "image/jpeg", "image/gif"], t = globalThis.loaders?.imageFormatsNode || e;
  return !!globalThis.loaders?.parseImageNode && t.includes(r);
}
function OH(r) {
  switch (r) {
    case "image/avif":
    // Will fail
    case "image/webp":
      return DH(r);
    default:
      return !0;
  }
}
function DH(r) {
  try {
    return document.createElement("canvas").toDataURL(r).indexOf(`data:${r}`) === 0;
  } catch {
    return !1;
  }
}
function sl(r, e) {
  if (!r)
    throw new Error(e || "assert failed: gltf");
}
const dM = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, pM = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, NH = 1.33, PS = ["SCALAR", "VEC2", "VEC3", "VEC4"], FH = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], UH = new Map(FH), zH = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, jH = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, VH = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function gM(r) {
  return PS[r - 1] || PS[0];
}
function i0(r) {
  const e = UH.get(r.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function Lx(r, e) {
  const t = VH[r.componentType], i = zH[r.type], n = jH[r.componentType], s = r.count * i, c = r.count * i * n;
  sl(c >= 0 && c <= e.byteLength);
  const o = pM[r.componentType], d = dM[r.type];
  return {
    ArrayType: t,
    length: s,
    byteLength: c,
    componentByteSize: o,
    numberOfComponentsInElement: d
  };
}
function mM(r) {
  let {
    images: e,
    bufferViews: t
  } = r;
  e = e || [], t = t || [];
  const i = e.map((c) => c.bufferView);
  t = t.filter((c) => !i.includes(c));
  const n = t.reduce((c, o) => c + o.byteLength, 0), s = e.reduce((c, o) => {
    const {
      width: d,
      height: m
    } = o.image;
    return c + d * m;
  }, 0);
  return n + Math.ceil(4 * s * NH);
}
function GH(r, e, t) {
  const i = r.bufferViews[t];
  sl(i);
  const n = i.buffer, s = e[n];
  sl(s);
  const c = (i.byteOffset || 0) + s.byteOffset;
  return new Uint8Array(s.arrayBuffer, c, i.byteLength);
}
function $H(r, e, t) {
  const i = typeof t == "number" ? r.accessors?.[t] : t;
  if (!i)
    throw new Error(`No gltf accessor ${JSON.stringify(t)}`);
  const n = r.bufferViews?.[i.bufferView || 0];
  if (!n)
    throw new Error(`No gltf buffer view for accessor ${n}`);
  const {
    arrayBuffer: s,
    byteOffset: c
  } = e[n.buffer], o = (c || 0) + (i.byteOffset || 0) + (n.byteOffset || 0), {
    ArrayType: d,
    length: m,
    componentByteSize: y,
    numberOfComponentsInElement: T
  } = Lx(i, n), P = y * T, I = n.byteStride || P;
  if (typeof n.byteStride > "u" || n.byteStride === P)
    return new d(s, o, m);
  const D = new d(m);
  for (let k = 0; k < i.count; k++) {
    const $ = new d(s, o + k * I, T);
    D.set($, k * T);
  }
  return D;
}
function HH() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
class fo {
  // internal
  gltf;
  sourceBuffers;
  byteLength;
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(e) {
    this.gltf = {
      json: e?.json || HH(),
      buffers: e?.buffers || [],
      images: e?.images || []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  hasExtension(e) {
    const t = this.getUsedExtensions().find((n) => n === e), i = this.getRequiredExtensions().find((n) => n === e);
    return typeof t == "string" || typeof i == "string";
  }
  getExtension(e) {
    const t = this.getUsedExtensions().find((n) => n === e), i = this.json.extensions || {};
    return t ? i[e] : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((i) => i === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, t) {
    return (e.extensions || {})[t];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, t) {
    if (typeof t == "object")
      return t;
    const i = this.json[e] && this.json[e][t];
    if (!i)
      throw new Error(`glTF file error: Could not find ${e}[${t}]`);
    return i;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const t = e.buffer, i = this.gltf.buffers[t];
    sl(i);
    const n = (e.byteOffset || 0) + i.byteOffset;
    return new Uint8Array(i.arrayBuffer, n, e.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(e) {
    const t = this.getAccessor(e);
    return $H(this.gltf.json, this.gltf.buffers, t);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), n = this.getBuffer(t.buffer).data, s = t.byteOffset || 0;
    return new Uint8Array(n, s, t.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(e, t) {
    return this.json[e] = t, this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(e, t) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this;
  }
  addObjectExtension(e, t, i) {
    return e.extensions = e.extensions || {}, e.extensions[t] = i, this.registerUsedExtension(t), this;
  }
  setObjectExtension(e, t, i) {
    const n = e.extensions || {};
    n[t] = i;
  }
  removeObjectExtension(e, t) {
    const i = e?.extensions || {};
    if (i[t]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const n = this.json.extensionsRemoved;
      n.includes(t) || n.push(t);
    }
    delete i[t];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(e, t = {}) {
    return sl(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(e, t = {}) {
    return sl(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(e) {
    if (this.json.extensions?.[e]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const t = this.json.extensionsRemoved;
      t.includes(e) || t.push(e);
    }
    this.json.extensions && delete this.json.extensions[e], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e);
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(e) {
    this.json.scene = e;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(e) {
    const {
      nodeIndices: t
    } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({
      nodes: t
    }), this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(e) {
    const {
      meshIndex: t,
      matrix: i
    } = e;
    this.json.nodes = this.json.nodes || [];
    const n = {
      mesh: t
    };
    return i && (n.matrix = i), this.json.nodes.push(n), this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(e) {
    const {
      attributes: t,
      indices: i,
      material: n,
      mode: s = 4
    } = e, o = {
      primitives: [{
        attributes: this._addAttributes(t),
        mode: s
      }]
    };
    if (i) {
      const d = this._addIndices(i);
      o.primitives[0].indices = d;
    }
    return Number.isFinite(n) && (o.primitives[0].material = n), this.json.meshes = this.json.meshes || [], this.json.meshes.push(o), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const i = {
      primitives: [{
        attributes: this._addAttributes(e),
        mode: 0
        // GL.POINTS
      }]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(i), this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(e, t) {
    const i = Rx(e), n = t || i?.mimeType, c = {
      bufferView: this.addBufferView(e),
      mimeType: n
    };
    return this.json.images = this.json.images || [], this.json.images.push(c), this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(e, t = 0, i = this.byteLength) {
    const n = e.byteLength;
    sl(Number.isFinite(n)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const s = {
      buffer: t,
      // Write offset from the start of the binary body
      byteOffset: i,
      byteLength: n
    };
    return this.byteLength += mm(n, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(s), this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(e, t) {
    const i = {
      bufferView: e,
      // @ts-ignore
      type: gM(t.size),
      // @ts-ignore
      componentType: t.componentType,
      // @ts-ignore
      count: t.count,
      // @ts-ignore
      max: t.max,
      // @ts-ignore
      min: t.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(i), this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(e, t = {
    size: 3
  }) {
    const i = this.addBufferView(e);
    let n = {
      min: t.min,
      max: t.max
    };
    (!n.min || !n.max) && (n = this._getAccessorMinMax(e, t.size));
    const s = {
      // @ts-ignore
      size: t.size,
      componentType: i0(e),
      // @ts-ignore
      count: Math.round(e.length / t.size),
      min: n.min,
      max: n.max
    };
    return this.addAccessor(i, Object.assign(s, t));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(e) {
    const {
      imageIndex: t
    } = e, i = {
      source: t
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(i), this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    const e = this.byteLength, t = new ArrayBuffer(e), i = new Uint8Array(t);
    let n = 0;
    for (const s of this.sourceBuffers || [])
      n = eH(s, i, n);
    this.json?.buffers?.[0] ? this.json.buffers[0].byteLength = e : this.json.buffers = [{
      byteLength: e
    }], this.gltf.binary = t, this.sourceBuffers = [t], this.gltf.buffers = [{
      arrayBuffer: t,
      byteOffset: 0,
      byteLength: t.byteLength
    }];
  }
  // PRIVATE
  _removeStringFromArray(e, t) {
    let i = !0;
    for (; i; ) {
      const n = e.indexOf(t);
      n > -1 ? e.splice(n, 1) : i = !1;
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(e = {}) {
    const t = {};
    for (const i in e) {
      const n = e[i], s = this._getGltfAttributeName(i), c = this.addBinaryBuffer(n.value, n);
      t[s] = c;
    }
    return t;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(e) {
    return this.addBinaryBuffer(e, {
      size: 1
    });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(e, t) {
    const i = {
      min: null,
      max: null
    };
    if (e.length < t)
      return i;
    i.min = [], i.max = [];
    const n = e.subarray(0, t);
    for (const s of n)
      i.min.push(s), i.max.push(s);
    for (let s = t; s < e.length; s += t)
      for (let c = 0; c < t; c++)
        i.min[0 + c] = Math.min(
          // @ts-ignore
          i.min[0 + c],
          e[s + c]
        ), i.max[0 + c] = Math.max(
          // @ts-ignore
          i.max[0 + c],
          e[s + c]
        );
    return i;
  }
}
function MS(r) {
  return (r % 1 + 1) % 1;
}
const _M = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
}, qH = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
}, yM = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function Bx(r, e) {
  return yM[e] * _M[r];
}
function n0(r, e, t, i) {
  if (t !== "UINT8" && t !== "UINT16" && t !== "UINT32" && t !== "UINT64")
    return null;
  const n = r.getTypedArrayForBufferView(e), s = s0(
    n,
    "SCALAR",
    // offsets consist of ONE component
    t,
    i + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  return s instanceof BigInt64Array || s instanceof BigUint64Array ? null : s;
}
function s0(r, e, t, i = 1) {
  const n = _M[e], s = qH[t], c = yM[t], o = i * n, d = o * c;
  let m = r.buffer, y = r.byteOffset;
  return y % c !== 0 && (m = new Uint8Array(m).slice(y, y + d).buffer, y = 0), new s(m, y, o);
}
function kx(r, e, t) {
  const i = `TEXCOORD_${e.texCoord || 0}`, n = t.attributes[i], s = r.getTypedArrayForAccessor(n), c = r.gltf.json, o = e.index, d = c.textures?.[o]?.source;
  if (typeof d < "u") {
    const m = c.images?.[d]?.mimeType, y = r.gltf.images?.[d];
    if (y && typeof y.width < "u") {
      const T = [];
      for (let P = 0; P < s.length; P += 2) {
        const I = WH(y, m, s, P, e.channels);
        T.push(I);
      }
      return T;
    }
  }
  return [];
}
function bM(r, e, t, i, n) {
  if (!t?.length)
    return;
  const s = [];
  for (const y of t) {
    let T = i.findIndex((P) => P === y);
    T === -1 && (T = i.push(y) - 1), s.push(T);
  }
  const c = new Uint32Array(s), o = r.gltf.buffers.push({
    arrayBuffer: c.buffer,
    byteOffset: c.byteOffset,
    byteLength: c.byteLength
  }) - 1, d = r.addBufferView(c, o, 0), m = r.addAccessor(d, {
    size: 1,
    componentType: i0(c),
    count: c.length
  });
  n.attributes[e] = m;
}
function WH(r, e, t, i, n = [0]) {
  const s = {
    r: {
      offset: 0,
      shift: 0
    },
    g: {
      offset: 1,
      shift: 8
    },
    b: {
      offset: 2,
      shift: 16
    },
    a: {
      offset: 3,
      shift: 24
    }
  }, c = t[i], o = t[i + 1];
  let d = 1;
  e && (e.indexOf("image/jpeg") !== -1 || e.indexOf("image/png") !== -1) && (d = 4);
  const m = XH(c, o, r, d);
  let y = 0;
  for (const T of n) {
    const P = typeof T == "number" ? Object.values(s)[T] : s[T], I = m + P.offset, D = uM(r);
    if (D.data.length <= I)
      throw new Error(`${D.data.length} <= ${I}`);
    const k = D.data[I];
    y |= k << P.shift;
  }
  return y;
}
function XH(r, e, t, i = 1) {
  const n = t.width, s = MS(r) * (n - 1), c = Math.round(s), o = t.height, d = MS(e) * (o - 1), m = Math.round(d), y = t.components ? t.components : i;
  return (m * n + c) * y;
}
function vM(r, e, t, i, n) {
  const s = [];
  for (let c = 0; c < e; c++) {
    const o = t[c], d = t[c + 1] - t[c];
    if (d + o > i)
      break;
    const m = o / n, y = d / n;
    s.push(r.slice(m, m + y));
  }
  return s;
}
function xM(r, e, t) {
  const i = [];
  for (let n = 0; n < e; n++) {
    const s = n * t;
    i.push(r.slice(s, s + t));
  }
  return i;
}
function wM(r, e, t, i) {
  if (t)
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  if (i) {
    const n = [], s = new TextDecoder("utf8");
    let c = 0;
    for (let o = 0; o < r; o++) {
      const d = i[o + 1] - i[o];
      if (d + c <= e.length) {
        const m = e.subarray(c, d + c), y = s.decode(m);
        n.push(y), c += d;
      }
    }
    return n;
  }
  return [];
}
const gp = "EXT_mesh_features", ZH = gp;
async function YH(r, e) {
  const t = new fo(r);
  KH(t, e);
}
function JH(r, e) {
  const t = new fo(r);
  return eq(t), t.createBinaryChunk(), t.gltf;
}
function KH(r, e) {
  const t = r.gltf.json;
  if (t.meshes)
    for (const i of t.meshes)
      for (const n of i.primitives)
        QH(r, n, e);
}
function QH(r, e, t) {
  if (!t?.gltf?.loadBuffers)
    return;
  const n = e.extensions?.[gp]?.featureIds;
  if (n)
    for (const s of n) {
      let c;
      if (typeof s.attribute < "u") {
        const o = `_FEATURE_ID_${s.attribute}`, d = e.attributes[o];
        c = r.getTypedArrayForAccessor(d);
      } else typeof s.texture < "u" && t?.gltf?.loadImages ? c = kx(r, s.texture, e) : c = [];
      s.data = c;
    }
}
function eq(r, e) {
  const t = r.gltf.json.meshes;
  if (t)
    for (const i of t)
      for (const n of i.primitives)
        rq(r, n);
}
function tq(r, e, t, i) {
  e.extensions || (e.extensions = {});
  let n = e.extensions[gp];
  n || (n = {
    featureIds: []
  }, e.extensions[gp] = n);
  const {
    featureIds: s
  } = n, c = {
    featureCount: t.length,
    propertyTable: i,
    data: t
  };
  s.push(c), r.addObjectExtension(e, gp, n);
}
function rq(r, e) {
  const t = e.extensions?.[gp];
  if (!t)
    return;
  const i = t.featureIds;
  i.forEach((n, s) => {
    if (n.data) {
      const {
        accessorKey: c,
        index: o
      } = iq(e.attributes), d = new Uint32Array(n.data);
      i[s] = {
        featureCount: d.length,
        propertyTable: n.propertyTable,
        attribute: o
      }, r.gltf.buffers.push({
        arrayBuffer: d.buffer,
        byteOffset: d.byteOffset,
        byteLength: d.byteLength
      });
      const m = r.addBufferView(d), y = r.addAccessor(m, {
        size: 1,
        componentType: i0(d),
        count: d.length
      });
      e.attributes[c] = y;
    }
  });
}
function iq(r) {
  const e = "_FEATURE_ID_", t = Object.keys(r).filter((s) => s.indexOf(e) === 0);
  let i = -1;
  for (const s of t) {
    const c = Number(s.substring(e.length));
    c > i && (i = c);
  }
  return i++, {
    accessorKey: `${e}${i}`,
    index: i
  };
}
const nq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtMeshFeatures: tq,
  decode: YH,
  encode: JH,
  name: ZH
}, Symbol.toStringTag, { value: "Module" })), Ep = "EXT_structural_metadata", sq = Ep;
async function oq(r, e) {
  const t = new fo(r);
  lq(t, e);
}
function aq(r, e) {
  const t = new fo(r);
  return Tq(t), t.createBinaryChunk(), t.gltf;
}
function lq(r, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const t = r.getExtension(Ep);
  t && (e.gltf?.loadImages && cq(r, t), uq(r, t));
}
function cq(r, e) {
  const t = e.propertyTextures, i = r.gltf.json;
  if (t && i.meshes)
    for (const n of i.meshes)
      for (const s of n.primitives)
        fq(r, t, s, e);
}
function uq(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const i = t.classes, n = e.propertyTables;
  if (i && n)
    for (const s in i) {
      const c = hq(n, s);
      c && pq(r, t, c);
    }
}
function hq(r, e) {
  for (const t of r)
    if (t.class === e)
      return t;
  return null;
}
function fq(r, e, t, i) {
  if (!e)
    return;
  const s = t.extensions?.[Ep]?.propertyTextures;
  if (s)
    for (const c of s) {
      const o = e[c];
      dq(r, o, t, i);
    }
}
function dq(r, e, t, i) {
  if (!e.properties)
    return;
  i.dataAttributeNames || (i.dataAttributeNames = []);
  const n = e.class;
  for (const s in e.properties) {
    const c = `${n}_${s}`, o = e.properties?.[s];
    if (!o)
      continue;
    o.data || (o.data = []);
    const d = o.data, m = kx(r, o, t);
    m !== null && (bM(r, c, m, d, t), o.data = d, i.dataAttributeNames.push(c));
  }
}
function pq(r, e, t) {
  const i = e.classes?.[t.class];
  if (!i)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const n = t.count;
  for (const s in i.properties) {
    const c = i.properties[s], o = t.properties?.[s];
    if (o) {
      const d = gq(r, e, c, n, o);
      o.data = d;
    }
  }
}
function gq(r, e, t, i, n) {
  let s = [];
  const c = n.values, o = r.getTypedArrayForBufferView(c), d = mq(r, t, n, i), m = _q(r, n, i);
  switch (t.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      s = yq(t, i, o, d);
      break;
    }
    case "BOOLEAN":
      throw new Error(`Not implemented - classProperty.type=${t.type}`);
    case "STRING": {
      s = wM(i, o, d, m);
      break;
    }
    case "ENUM": {
      s = bq(e, t, i, o, d);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${t.type}`);
  }
  return s;
}
function mq(r, e, t, i) {
  return e.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof e.count > "u" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsets < "u" ? n0(r, t.arrayOffsets, t.arrayOffsetType || "UINT32", i) : null;
}
function _q(r, e, t) {
  return typeof e.stringOffsets < "u" ? n0(r, e.stringOffsets, e.stringOffsetType || "UINT32", t) : null;
}
function yq(r, e, t, i) {
  const n = r.array, s = r.count, c = Bx(r.type, r.componentType), o = t.byteLength / c;
  let d;
  return r.componentType ? d = s0(
    t,
    r.type,
    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
    r.componentType,
    o
  ) : d = t, n ? i ? vM(d, e, i, t.length, c) : s ? xM(d, e, s) : [] : d;
}
function bq(r, e, t, i, n) {
  const s = e.enumType;
  if (!s)
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  const c = r.enums?.[s];
  if (!c)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${s}`);
  const o = c.valueType || "UINT16", d = Bx(e.type, o), m = i.byteLength / d;
  let y = s0(i, e.type, o, m);
  if (y || (y = i), e.array) {
    if (n)
      return vq({
        valuesData: y,
        numberOfElements: t,
        arrayOffsets: n,
        valuesDataBytesLength: i.length,
        elementSize: d,
        enumEntry: c
      });
    const T = e.count;
    return T ? xq(y, t, T, c) : [];
  }
  return Ox(y, 0, t, c);
}
function vq(r) {
  const {
    valuesData: e,
    numberOfElements: t,
    arrayOffsets: i,
    valuesDataBytesLength: n,
    elementSize: s,
    enumEntry: c
  } = r, o = [];
  for (let d = 0; d < t; d++) {
    const m = i[d], y = i[d + 1] - i[d];
    if (y + m > n)
      break;
    const T = m / s, P = y / s, I = Ox(e, T, P, c);
    o.push(I);
  }
  return o;
}
function xq(r, e, t, i) {
  const n = [];
  for (let s = 0; s < e; s++) {
    const c = t * s, o = Ox(r, c, t, i);
    n.push(o);
  }
  return n;
}
function Ox(r, e, t, i) {
  const n = [];
  for (let s = 0; s < t; s++)
    if (r instanceof BigInt64Array || r instanceof BigUint64Array)
      n.push("");
    else {
      const c = r[e + s], o = wq(i, c);
      o ? n.push(o.name) : n.push("");
    }
  return n;
}
function wq(r, e) {
  for (const t of r.values)
    if (t.value === e)
      return t;
  return null;
}
const Aq = "schemaClassId";
function Tq(r, e) {
  const t = r.getExtension(Ep);
  if (t && t.propertyTables)
    for (const i of t.propertyTables) {
      const n = i.class, s = t.schema?.classes?.[n];
      i.properties && s && Sq(i, s, r);
    }
}
function Sq(r, e, t) {
  for (const i in r.properties) {
    const n = r.properties[i].data;
    if (n) {
      const s = e.properties[i];
      if (s) {
        const c = Pq(n, s, t);
        r.properties[i] = c;
      }
    }
  }
}
function Eq(r, e, t = Aq) {
  let i = r.getExtension(Ep);
  i || (i = r.addExtension(Ep)), i.schema = Cq(e, t, i.schema);
  const n = Iq(e, t, i.schema);
  return i.propertyTables || (i.propertyTables = []), i.propertyTables.push(n) - 1;
}
function Cq(r, e, t) {
  const i = t ?? {
    id: "schema_id"
  }, n = {
    properties: {}
  };
  for (const s of r) {
    const c = {
      type: s.elementType,
      componentType: s.componentType
    };
    n.properties[s.name] = c;
  }
  return i.classes = {}, i.classes[e] = n, i;
}
function Iq(r, e, t) {
  const i = {
    class: e,
    count: 0
  };
  let n = 0;
  const s = t.classes?.[e];
  for (const c of r) {
    if (n === 0 && (n = c.values.length), n !== c.values.length && c.values.length)
      throw new Error("Illegal values in attributes");
    s?.properties[c.name] && (i.properties || (i.properties = {}), i.properties[c.name] = {
      values: 0,
      data: c.values
    });
  }
  return i.count = n, i;
}
function Pq(r, e, t) {
  const i = {
    values: 0
  };
  if (e.type === "STRING") {
    const {
      stringData: n,
      stringOffsets: s
    } = Lq(r);
    i.stringOffsets = Kb(s, t), i.values = Kb(n, t);
  } else if (e.type === "SCALAR" && e.componentType) {
    const n = Rq(r, e.componentType);
    i.values = Kb(n, t);
  }
  return i;
}
const Mq = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function Rq(r, e) {
  const t = [];
  for (const n of r)
    t.push(Number(n));
  const i = Mq[e];
  if (!i)
    throw new Error("Illegal component type");
  return new i(t);
}
function Lq(r) {
  const e = new TextEncoder(), t = [];
  let i = 0;
  for (const d of r) {
    const m = e.encode(d);
    i += m.length, t.push(m);
  }
  const n = new Uint8Array(i), s = [];
  let c = 0;
  for (const d of t)
    n.set(d, c), s.push(c), c += d.length;
  s.push(c);
  const o = new Uint32Array(s);
  return {
    stringData: n,
    stringOffsets: o
  };
}
function Kb(r, e) {
  return e.gltf.buffers.push({
    arrayBuffer: r.buffer,
    byteOffset: r.byteOffset,
    byteLength: r.byteLength
  }), e.addBufferView(r);
}
const Bq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtStructuralMetadata: Eq,
  decode: oq,
  encode: aq,
  name: sq
}, Symbol.toStringTag, { value: "Module" })), AM = "EXT_feature_metadata", kq = AM;
async function Oq(r, e) {
  const t = new fo(r);
  Dq(t, e);
}
function Dq(r, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const t = r.getExtension(AM);
  t && (e.gltf?.loadImages && Nq(r, t), Fq(r, t));
}
function Nq(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const i = t.classes, {
    featureTextures: n
  } = e;
  if (i && n)
    for (const s in i) {
      const c = i[s], o = zq(n, s);
      o && Vq(r, o, c);
    }
}
function Fq(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const i = t.classes, n = e.featureTables;
  if (i && n)
    for (const s in i) {
      const c = Uq(n, s);
      c && jq(r, t, c);
    }
}
function Uq(r, e) {
  for (const t in r) {
    const i = r[t];
    if (i.class === e)
      return i;
  }
  return null;
}
function zq(r, e) {
  for (const t in r) {
    const i = r[t];
    if (i.class === e)
      return i;
  }
  return null;
}
function jq(r, e, t) {
  if (!t.class)
    return;
  const i = e.classes?.[t.class];
  if (!i)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const n = t.count;
  for (const s in i.properties) {
    const c = i.properties[s], o = t.properties?.[s];
    if (o) {
      const d = Gq(r, e, c, n, o);
      o.data = d;
    }
  }
}
function Vq(r, e, t) {
  const i = e.class;
  for (const n in t.properties) {
    const s = e?.properties?.[n];
    if (s) {
      const c = Xq(r, s, i);
      s.data = c;
    }
  }
}
function Gq(r, e, t, i, n) {
  let s = [];
  const c = n.bufferView, o = r.getTypedArrayForBufferView(c), d = $q(r, t, n, i), m = Hq(r, t, n, i);
  return t.type === "STRING" || t.componentType === "STRING" ? s = wM(i, o, d, m) : qq(t) && (s = Wq(t, i, o, d)), s;
}
function $q(r, e, t, i) {
  return e.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof e.componentCount > "u" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsetBufferView < "u" ? n0(
    r,
    t.arrayOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    i
  ) : null;
}
function Hq(r, e, t, i) {
  return typeof t.stringOffsetBufferView < "u" ? n0(
    r,
    t.stringOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    i
  ) : null;
}
function qq(r) {
  const e = ["UINT8", "INT16", "UINT16", "INT32", "UINT32", "INT64", "UINT64", "FLOAT32", "FLOAT64"];
  return e.includes(r.type) || typeof r.componentType < "u" && e.includes(r.componentType);
}
function Wq(r, e, t, i) {
  const n = r.type === "ARRAY", s = r.componentCount, c = "SCALAR", o = r.componentType || r.type, d = Bx(c, o), m = t.byteLength / d, y = s0(t, c, o, m);
  return n ? i ? vM(y, e, i, t.length, d) : s ? xM(y, e, s) : [] : y;
}
function Xq(r, e, t) {
  const i = r.gltf.json;
  if (!i.meshes)
    return [];
  const n = [];
  for (const s of i.meshes)
    for (const c of s.primitives)
      Zq(r, t, e, n, c);
  return n;
}
function Zq(r, e, t, i, n) {
  const s = {
    channels: t.channels,
    ...t.texture
  }, c = kx(r, s, n);
  c && bM(r, e, c, i, n);
}
const Yq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Oq,
  name: kq
}, Symbol.toStringTag, { value: "Module" })), Jq = "4.3.3", Cp = !0, RS = 1735152710, Dx = 12, Ny = 8, Kq = 1313821514, Qq = 5130562, eW = 0, tW = 0, rW = 1;
function iW(r, e = 0) {
  return `${String.fromCharCode(r.getUint8(e + 0))}${String.fromCharCode(r.getUint8(e + 1))}${String.fromCharCode(r.getUint8(e + 2))}${String.fromCharCode(r.getUint8(e + 3))}`;
}
function nW(r, e = 0, t = {}) {
  const i = new DataView(r), {
    magic: n = RS
  } = t, s = i.getUint32(e, !1);
  return s === n || s === RS;
}
function sW(r, e, t = 0, i = {}) {
  const n = new DataView(e), s = iW(n, t + 0), c = n.getUint32(t + 4, Cp), o = n.getUint32(t + 8, Cp);
  switch (Object.assign(r, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset: t,
      // Byte offset into the initial arrayBuffer
      byteLength: o,
      hasBinChunk: !1
    },
    type: s,
    version: c,
    json: {},
    binChunks: []
  }), t += Dx, r.version) {
    case 1:
      return oW(r, n, t);
    case 2:
      return aW(r, n, t, i = {});
    default:
      throw new Error(`Invalid GLB version ${r.version}. Only supports version 1 and 2.`);
  }
}
function oW(r, e, t) {
  id(r.header.byteLength > Dx + Ny);
  const i = e.getUint32(t + 0, Cp), n = e.getUint32(t + 4, Cp);
  return t += Ny, id(n === eW), $v(r, e, t, i), t += i, t += Hv(r, e, t, r.header.byteLength), t;
}
function aW(r, e, t, i) {
  return id(r.header.byteLength > Dx + Ny), lW(r, e, t, i), t + r.header.byteLength;
}
function lW(r, e, t, i) {
  for (; t + 8 <= r.header.byteLength; ) {
    const n = e.getUint32(t + 0, Cp), s = e.getUint32(t + 4, Cp);
    switch (t += Ny, s) {
      case Kq:
        $v(r, e, t, n);
        break;
      case Qq:
        Hv(r, e, t, n);
        break;
      // Backward compatibility for very old xviz files
      case tW:
        i.strict || $v(r, e, t, n);
        break;
      case rW:
        i.strict || Hv(r, e, t, n);
        break;
    }
    t += mm(n, 4);
  }
  return t;
}
function $v(r, e, t, i) {
  const n = new Uint8Array(e.buffer, t, i), c = new TextDecoder("utf8").decode(n);
  return r.json = JSON.parse(c), mm(i, 4);
}
function Hv(r, e, t, i) {
  return r.header.hasBinChunk = !0, r.binChunks.push({
    byteOffset: t,
    byteLength: i,
    arrayBuffer: e.buffer
    // TODO - copy, or create typed array view?
  }), mm(i, 4);
}
function TM(r, e) {
  if (r.startsWith("data:") || r.startsWith("http:") || r.startsWith("https:"))
    return r;
  const i = e.baseUri || e.uri;
  if (!i)
    throw new Error(`'baseUri' must be provided to resolve relative url ${r}`);
  return i.substr(0, i.lastIndexOf("/") + 1) + r;
}
const cW = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", uW = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", hW = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), fW = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), dW = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, pW = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function gW(r, e, t, i, n, s = "NONE") {
  const c = await mW();
  bW(c, c.exports[pW[n]], r, e, t, i, c.exports[dW[s || "NONE"]]);
}
let Qb;
async function mW() {
  return Qb || (Qb = _W()), Qb;
}
async function _W() {
  let r = cW;
  WebAssembly.validate(hW) && (r = uW, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(yW(r), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function yW(r) {
  const e = new Uint8Array(r.length);
  for (let i = 0; i < r.length; ++i) {
    const n = r.charCodeAt(i);
    e[i] = n > 96 ? n - 71 : n > 64 ? n - 65 : n > 47 ? n + 4 : n > 46 ? 63 : 62;
  }
  let t = 0;
  for (let i = 0; i < r.length; ++i)
    e[t++] = e[i] < 60 ? fW[e[i]] : (e[i] - 60) * 64 + e[++i];
  return e.buffer.slice(0, t);
}
function bW(r, e, t, i, n, s, c) {
  const o = r.exports.sbrk, d = i + 3 & -4, m = o(d * n), y = o(s.length), T = new Uint8Array(r.exports.memory.buffer);
  T.set(s, y);
  const P = e(m, i, n, y, s.length);
  if (P === 0 && c && c(m, d, n), t.set(T.subarray(m, m + i * n)), o(m - o(0)), P !== 0)
    throw new Error(`Malformed buffer data: ${P}`);
}
const Fy = "EXT_meshopt_compression", vW = Fy;
async function xW(r, e) {
  const t = new fo(r);
  if (!e?.gltf?.decompressMeshes || !e.gltf?.loadBuffers)
    return;
  const i = [];
  for (const n of r.json.bufferViews || [])
    i.push(wW(t, n));
  await Promise.all(i), t.removeExtension(Fy);
}
async function wW(r, e) {
  const t = r.getObjectExtension(e, Fy);
  if (t) {
    const {
      byteOffset: i = 0,
      byteLength: n = 0,
      byteStride: s,
      count: c,
      mode: o,
      filter: d = "NONE",
      buffer: m
    } = t, y = r.gltf.buffers[m], T = new Uint8Array(y.arrayBuffer, y.byteOffset + i, n), P = new Uint8Array(r.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    await gW(P, c, s, T, o, d), r.removeObjectExtension(e, Fy);
  }
}
const AW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: xW,
  name: vW
}, Symbol.toStringTag, { value: "Module" })), Jd = "EXT_texture_webp", TW = Jd;
function SW(r, e) {
  const t = new fo(r);
  if (!BH("image/webp")) {
    if (t.getRequiredExtensions().includes(Jd))
      throw new Error(`gltf: Required extension ${Jd} not supported by browser`);
    return;
  }
  const {
    json: i
  } = t;
  for (const n of i.textures || []) {
    const s = t.getObjectExtension(n, Jd);
    s && (n.source = s.source), t.removeObjectExtension(n, Jd);
  }
  t.removeExtension(Jd);
}
const EW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: TW,
  preprocess: SW
}, Symbol.toStringTag, { value: "Module" })), J_ = "KHR_texture_basisu", CW = J_;
function IW(r, e) {
  const t = new fo(r), {
    json: i
  } = t;
  for (const n of i.textures || []) {
    const s = t.getObjectExtension(n, J_);
    s && (n.source = s.source, t.removeObjectExtension(n, J_));
  }
  t.removeExtension(J_);
}
const PW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: CW,
  preprocess: IW
}, Symbol.toStringTag, { value: "Module" })), MW = "4.3.3", RW = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: MW,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};
function LW(r) {
  switch (r.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}
function BW(r) {
  let e = 1 / 0, t = 1 / 0, i = 1 / 0, n = -1 / 0, s = -1 / 0, c = -1 / 0;
  const o = r.POSITION ? r.POSITION.value : [], d = o && o.length;
  for (let m = 0; m < d; m += 3) {
    const y = o[m], T = o[m + 1], P = o[m + 2];
    e = y < e ? y : e, t = T < t ? T : t, i = P < i ? P : i, n = y > n ? y : n, s = T > s ? T : s, c = P > c ? P : c;
  }
  return [[e, t, i], [n, s, c]];
}
function kW(r, e, t) {
  const i = LW(e.value), n = t || OW(e);
  return {
    name: r,
    type: {
      type: "fixed-size-list",
      listSize: e.size,
      children: [{
        name: "value",
        type: i
      }]
    },
    nullable: !1,
    metadata: n
  };
}
function OW(r) {
  const e = {};
  return "byteOffset" in r && (e.byteOffset = r.byteOffset.toString(10)), "byteStride" in r && (e.byteStride = r.byteStride.toString(10)), "normalized" in r && (e.normalized = r.normalized.toString()), e;
}
function DW(r, e, t) {
  const i = SM(e.metadata), n = [], s = NW(e.attributes);
  for (const c in r) {
    const o = r[c], d = LS(c, o, s[c]);
    n.push(d);
  }
  if (t) {
    const c = LS("indices", t);
    n.push(c);
  }
  return {
    fields: n,
    metadata: i
  };
}
function NW(r) {
  const e = {};
  for (const t in r) {
    const i = r[t];
    e[i.name || "undefined"] = i;
  }
  return e;
}
function LS(r, e, t) {
  const i = t ? SM(t.metadata) : void 0;
  return kW(r, e, i);
}
function SM(r) {
  Object.entries(r);
  const e = {};
  for (const t in r)
    e[`${t}.string`] = JSON.stringify(r[t]);
  return e;
}
const BS = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, FW = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
}, UW = 4;
class zW {
  draco;
  decoder;
  metadataQuerier;
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(e) {
    this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(e, t = {}) {
    const i = new this.draco.DecoderBuffer();
    i.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t);
    const n = this.decoder.GetEncodedGeometryType(i), s = n === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let c;
      switch (n) {
        case this.draco.TRIANGULAR_MESH:
          c = this.decoder.DecodeBufferToMesh(i, s);
          break;
        case this.draco.POINT_CLOUD:
          c = this.decoder.DecodeBufferToPointCloud(i, s);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!c.ok() || !s.ptr) {
        const P = `DRACO decompression failed: ${c.error_msg()}`;
        throw new Error(P);
      }
      const o = this._getDracoLoaderData(s, n, t), d = this._getMeshData(s, o, t), m = BW(d.attributes), y = DW(d.attributes, o, d.indices);
      return {
        loader: "draco",
        loaderData: o,
        header: {
          vertexCount: s.num_points(),
          boundingBox: m
        },
        ...d,
        schema: y
      };
    } finally {
      this.draco.destroy(i), s && this.draco.destroy(s);
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(e, t, i) {
    const n = this._getTopLevelMetadata(e), s = this._getDracoAttributes(e, i);
    return {
      geometry_type: t,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: n,
      attributes: s
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(e, t) {
    const i = {};
    for (let n = 0; n < e.num_attributes(); n++) {
      const s = this.decoder.GetAttribute(e, n), c = this._getAttributeMetadata(e, n);
      i[s.unique_id()] = {
        unique_id: s.unique_id(),
        attribute_type: s.attribute_type(),
        data_type: s.data_type(),
        num_components: s.num_components(),
        byte_offset: s.byte_offset(),
        byte_stride: s.byte_stride(),
        normalized: s.normalized(),
        attribute_index: n,
        metadata: c
      };
      const o = this._getQuantizationTransform(s, t);
      o && (i[s.unique_id()].quantization_transform = o);
      const d = this._getOctahedronTransform(s, t);
      d && (i[s.unique_id()].octahedron_transform = d);
    }
    return i;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(e, t, i) {
    const n = this._getMeshAttributes(t, e, i);
    if (!n.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (i.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes: n,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes: n,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes: n
    };
  }
  _getMeshAttributes(e, t, i) {
    const n = {};
    for (const s of Object.values(e.attributes)) {
      const c = this._deduceAttributeName(s, i);
      s.name = c;
      const o = this._getAttributeValues(t, s);
      if (o) {
        const {
          value: d,
          size: m
        } = o;
        n[c] = {
          value: d,
          size: m,
          byteOffset: s.byte_offset,
          byteStride: s.byte_stride,
          normalized: s.normalized
        };
      }
    }
    return n;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(e) {
    const i = e.num_faces() * 3, n = i * UW, s = this.draco._malloc(n);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, n, s), new Uint32Array(this.draco.HEAPF32.buffer, s, i).slice();
    } finally {
      this.draco._free(s);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(e) {
    const t = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, t), GW(t);
    } finally {
      this.draco.destroy(t);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(e, t) {
    const i = FW[t.data_type];
    if (!i)
      return console.warn(`DRACO: Unsupported attribute type ${t.data_type}`), null;
    const n = t.num_components, c = e.num_points() * n, o = c * i.BYTES_PER_ELEMENT, d = jW(this.draco, i);
    let m;
    const y = this.draco._malloc(o);
    try {
      const T = this.decoder.GetAttribute(e, t.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, T, d, o, y), m = new i(this.draco.HEAPF32.buffer, y, c).slice();
    } finally {
      this.draco._free(y);
    }
    return {
      value: m,
      size: n
    };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(e, t) {
    const i = e.unique_id;
    for (const [c, o] of Object.entries(t.extraAttributes || {}))
      if (o === i)
        return c;
    const n = e.attribute_type;
    for (const c in BS)
      if (this.draco[c] === n)
        return BS[c];
    const s = t.attributeNameEntry || "name";
    return e.metadata[s] ? e.metadata[s].string : `CUSTOM_ATTRIBUTE_${i}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(e) {
    const t = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(t);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(e, t) {
    const i = this.decoder.GetAttributeMetadata(e, t);
    return this._getDracoMetadata(i);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const t = {}, i = this.metadataQuerier.NumEntries(e);
    for (let n = 0; n < i; n++) {
      const s = this.metadataQuerier.GetEntryName(e, n);
      t[s] = this._getDracoMetadataField(e, s);
    }
    return t;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(e, t) {
    const i = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, t, i);
      const n = VW(i);
      return {
        int: this.metadataQuerier.GetIntEntry(e, t),
        string: this.metadataQuerier.GetStringEntry(e, t),
        double: this.metadataQuerier.GetDoubleEntry(e, t),
        intArray: n
      };
    } finally {
      this.draco.destroy(i);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(e) {
    const {
      quantizedAttributes: t = [],
      octahedronAttributes: i = []
    } = e, n = [...t, ...i];
    for (const s of n)
      this.decoder.SkipAttributeTransform(this.draco[s]);
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(e, t) {
    const {
      quantizedAttributes: i = []
    } = t, n = e.attribute_type();
    if (i.map((c) => this.decoder[c]).includes(n)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits(),
            range: c.range(),
            min_values: new Float32Array([1, 2, 3]).map((o) => c.min_value(o))
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, t) {
    const {
      octahedronAttributes: i = []
    } = t, n = e.attribute_type();
    if (i.map((c) => this.decoder[c]).includes(n)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits()
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
}
function jW(r, e) {
  switch (e) {
    case Float32Array:
      return r.DT_FLOAT32;
    case Int8Array:
      return r.DT_INT8;
    case Int16Array:
      return r.DT_INT16;
    case Int32Array:
      return r.DT_INT32;
    case Uint8Array:
      return r.DT_UINT8;
    case Uint16Array:
      return r.DT_UINT16;
    case Uint32Array:
      return r.DT_UINT32;
    default:
      return r.DT_INVALID;
  }
}
function VW(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let i = 0; i < e; i++)
    t[i] = r.GetValue(i);
  return t;
}
function GW(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let i = 0; i < e; i++)
    t[i] = r.GetValue(i);
  return t;
}
function $W() {
  return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.3"), globalThis._loadersgl_.version;
}
const HW = $W();
function qW(r, e) {
  if (!r)
    throw new Error("loaders.gl assertion failed.");
}
const ym = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), Nx = typeof importScripts == "function", kS = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
kS && parseFloat(kS[1]);
const e1 = {};
async function t1(r, e = null, t = {}, i = null) {
  return e && (r = WW(r, e, t, i)), e1[r] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  e1[r] || XW(r), await e1[r];
}
function WW(r, e, t = {}, i = null) {
  if (!t.useLocalLibraries && r.startsWith("http"))
    return r;
  i = i || r;
  const n = t.modules || {};
  return n[i] ? n[i] : ym ? t.CDN ? (qW(t.CDN.startsWith("http")), `${t.CDN}/${e}@${HW}/dist/libs/${i}`) : Nx ? `../src/libs/${i}` : `modules/${e}/src/libs/${i}` : `modules/${e}/dist/libs/${i}`;
}
async function XW(r) {
  if (r.endsWith("wasm"))
    return await YW(r);
  if (!ym)
    try {
      const {
        requireFromFile: t
      } = globalThis.loaders || {};
      return await t?.(r);
    } catch (t) {
      return console.error(t), null;
    }
  if (Nx)
    return importScripts(r);
  const e = await JW(r);
  return ZW(e, r);
}
function ZW(r, e) {
  if (!ym) {
    const {
      requireFromString: i
    } = globalThis.loaders || {};
    return i?.(r, e);
  }
  if (Nx)
    return eval.call(globalThis, r), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(r));
  } catch {
    t.text = r;
  }
  return document.body.appendChild(t), null;
}
async function YW(r) {
  const {
    readFileAsArrayBuffer: e
  } = globalThis.loaders || {};
  return ym || !e || r.startsWith("http") ? await (await fetch(r)).arrayBuffer() : await e(r);
}
async function JW(r) {
  const {
    readFileAsText: e
  } = globalThis.loaders || {};
  return ym || !e || r.startsWith("http") ? await (await fetch(r)).text() : await e(r);
}
const KW = "1.5.6", QW = "1.4.1", r1 = `https://www.gstatic.com/draco/versioned/decoders/${KW}`, Ca = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
}, i1 = {
  [Ca.DECODER]: `${r1}/${Ca.DECODER}`,
  [Ca.DECODER_WASM]: `${r1}/${Ca.DECODER_WASM}`,
  [Ca.FALLBACK_DECODER]: `${r1}/${Ca.FALLBACK_DECODER}`,
  [Ca.ENCODER]: `https://raw.githubusercontent.com/google/draco/${QW}/javascript/${Ca.ENCODER}`
};
let n1;
async function eX(r) {
  const e = r.modules || {};
  return e.draco3d ? n1 ||= e.draco3d.createDecoderModule({}).then((t) => ({
    draco: t
  })) : n1 ||= tX(r), await n1;
}
async function tX(r) {
  let e, t;
  switch (r.draco && r.draco.decoderType) {
    case "js":
      e = await t1(i1[Ca.FALLBACK_DECODER], "draco", r, Ca.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [e, t] = await Promise.all([await t1(i1[Ca.DECODER], "draco", r, Ca.DECODER), await t1(i1[Ca.DECODER_WASM], "draco", r, Ca.DECODER_WASM)]);
  }
  return e = e || globalThis.DracoDecoderModule, await rX(e, t);
}
function rX(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    r({
      ...t,
      onModuleLoaded: (n) => i({
        draco: n
      })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}
const EM = {
  ...RW,
  parse: iX
};
async function iX(r, e) {
  const {
    draco: t
  } = await eX(e), i = new zW(t);
  try {
    return i.parseSync(r, e?.draco);
  } finally {
    i.destroy();
  }
}
function nX(r) {
  const e = {};
  for (const t in r) {
    const i = r[t];
    if (t !== "indices") {
      const n = CM(i);
      e[t] = n;
    }
  }
  return e;
}
function CM(r) {
  const {
    buffer: e,
    size: t,
    count: i
  } = sX(r);
  return {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: e,
    size: t,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count: i,
    type: gM(t),
    componentType: i0(e)
  };
}
function sX(r) {
  let e = r, t = 1, i = 0;
  return r && r.value && (e = r.value, t = r.size || 1), e && (ArrayBuffer.isView(e) || (e = oX(e, Float32Array)), i = e.length / t), {
    buffer: e,
    size: t,
    count: i
  };
}
function oX(r, e, t = !1) {
  return r ? Array.isArray(r) ? new e(r) : t && !(r instanceof e) ? new e(r) : r : null;
}
const Yh = "KHR_draco_mesh_compression", aX = Yh;
function lX(r, e, t) {
  const i = new fo(r);
  for (const n of IM(i))
    i.getObjectExtension(n, Yh);
}
async function cX(r, e, t) {
  if (!e?.gltf?.decompressMeshes)
    return;
  const i = new fo(r), n = [];
  for (const s of IM(i))
    i.getObjectExtension(s, Yh) && n.push(hX(i, s, e, t));
  await Promise.all(n), i.removeExtension(Yh);
}
function uX(r, e = {}) {
  const t = new fo(r);
  for (const i of t.json.meshes || [])
    fX(i), t.addRequiredExtension(Yh);
}
async function hX(r, e, t, i) {
  const n = r.getObjectExtension(e, Yh);
  if (!n)
    return;
  const s = r.getTypedArrayForBufferView(n.bufferView), c = cM(s.buffer, s.byteOffset), o = {
    ...t
  };
  delete o["3d-tiles"];
  const d = await aM(c, EM, o, i), m = nX(d.attributes);
  for (const [y, T] of Object.entries(m))
    if (y in e.attributes) {
      const P = e.attributes[y], I = r.getAccessor(P);
      I?.min && I?.max && (T.min = I.min, T.max = I.max);
    }
  e.attributes = m, d.indices && (e.indices = CM(d.indices)), r.removeObjectExtension(e, Yh), dX(e);
}
function fX(r, e, t = 4, i, n) {
  if (!i.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const s = i.DracoWriter.encodeSync({
    attributes: r
  }), c = n?.parseSync?.({
    attributes: r
  }), o = i._addFauxAttributes(c.attributes), d = i.addBufferView(s);
  return {
    primitives: [{
      attributes: o,
      // TODO - verify with spec
      mode: t,
      // GL.POINTS
      extensions: {
        [Yh]: {
          bufferView: d,
          attributes: o
          // TODO - verify with spec
        }
      }
    }]
  };
}
function dX(r) {
  if (!r.attributes && Object.keys(r.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* IM(r) {
  for (const e of r.json.meshes || [])
    for (const t of e.primitives)
      yield t;
}
const pX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: cX,
  encode: uX,
  name: aX,
  preprocess: lX
}, Symbol.toStringTag, { value: "Module" })), o0 = "KHR_texture_transform", gX = o0, y_ = new xt(), mX = new hs(), _X = new hs();
async function yX(r, e) {
  if (!new fo(r).hasExtension(o0) || !e.gltf?.loadBuffers)
    return;
  const n = r.json.materials || [];
  for (let s = 0; s < n.length; s++)
    bX(s, r);
}
function bX(r, e) {
  const t = e.json.materials?.[r], i = [t?.pbrMetallicRoughness?.baseColorTexture, t?.emissiveTexture, t?.normalTexture, t?.occlusionTexture, t?.pbrMetallicRoughness?.metallicRoughnessTexture], n = [];
  for (const s of i)
    s && s?.extensions?.[o0] && vX(e, r, s, n);
}
function vX(r, e, t, i) {
  const n = xX(t, i);
  if (!n)
    return;
  const s = r.json.meshes || [];
  for (const c of s)
    for (const o of c.primitives) {
      const d = o.material;
      Number.isFinite(d) && e === d && wX(r, o, n);
    }
}
function xX(r, e) {
  const t = r.extensions?.[o0], {
    texCoord: i = 0
  } = r, {
    texCoord: n = i
  } = t;
  if (!(e.findIndex(([c, o]) => c === i && o === n) !== -1)) {
    const c = SX(t);
    return i !== n && (r.texCoord = n), e.push([i, n]), {
      originalTexCoord: i,
      texCoord: n,
      matrix: c
    };
  }
  return null;
}
function wX(r, e, t) {
  const {
    originalTexCoord: i,
    texCoord: n,
    matrix: s
  } = t, c = e.attributes[`TEXCOORD_${i}`];
  if (Number.isFinite(c)) {
    const o = r.json.accessors?.[c];
    if (o && o.bufferView) {
      const d = r.json.bufferViews?.[o.bufferView];
      if (d) {
        const {
          arrayBuffer: m,
          byteOffset: y
        } = r.buffers[d.buffer], T = (y || 0) + (o.byteOffset || 0) + (d.byteOffset || 0), {
          ArrayType: P,
          length: I
        } = Lx(o, d), D = pM[o.componentType], k = dM[o.type], $ = d.byteStride || D * k, G = new Float32Array(I);
        for (let te = 0; te < o.count; te++) {
          const Z = new P(m, T + te * $, 2);
          y_.set(Z[0], Z[1], 1), y_.transformByMatrix3(s), G.set([y_[0], y_[1]], te * k);
        }
        i === n ? AX(o, d, r.buffers, G) : TX(n, o, e, r, G);
      }
    }
  }
}
function AX(r, e, t, i) {
  r.componentType = 5126, t.push({
    arrayBuffer: i.buffer,
    byteOffset: 0,
    byteLength: i.buffer.byteLength
  }), e.buffer = t.length - 1, e.byteLength = i.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function TX(r, e, t, i, n) {
  i.buffers.push({
    arrayBuffer: n.buffer,
    byteOffset: 0,
    byteLength: n.buffer.byteLength
  });
  const s = i.json.bufferViews;
  if (!s)
    return;
  s.push({
    buffer: i.buffers.length - 1,
    byteLength: n.buffer.byteLength,
    byteOffset: 0
  });
  const c = i.json.accessors;
  c && (c.push({
    bufferView: s?.length - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), t.attributes[`TEXCOORD_${r}`] = c.length - 1);
}
function SX(r) {
  const {
    offset: e = [0, 0],
    rotation: t = 0,
    scale: i = [1, 1]
  } = r, n = new hs().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), s = mX.set(Math.cos(t), Math.sin(t), 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 1), c = _X.set(i[0], 0, 0, 0, i[1], 0, 0, 0, 1);
  return n.multiplyRight(s).multiplyRight(c);
}
const EX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: yX,
  name: gX
}, Symbol.toStringTag, { value: "Module" })), Nf = "KHR_lights_punctual", CX = Nf;
async function IX(r) {
  const e = new fo(r), {
    json: t
  } = e, i = e.getExtension(Nf);
  i && (e.json.lights = i.lights, e.removeExtension(Nf));
  for (const n of t.nodes || []) {
    const s = e.getObjectExtension(n, Nf);
    s && (n.light = s.light), e.removeObjectExtension(n, Nf);
  }
}
async function PX(r) {
  const e = new fo(r), {
    json: t
  } = e;
  if (t.lights) {
    const i = e.addExtension(Nf);
    sl(!i.lights), i.lights = t.lights, delete t.lights;
  }
  if (e.json.lights) {
    for (const i of e.json.lights) {
      const n = i.node;
      e.addObjectExtension(n, Nf, i);
    }
    delete e.json.lights;
  }
}
const MX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: IX,
  encode: PX,
  name: CX
}, Symbol.toStringTag, { value: "Module" })), nm = "KHR_materials_unlit", RX = nm;
async function LX(r) {
  const e = new fo(r), {
    json: t
  } = e;
  for (const i of t.materials || [])
    i.extensions && i.extensions.KHR_materials_unlit && (i.unlit = !0), e.removeObjectExtension(i, nm);
  e.removeExtension(nm);
}
function BX(r) {
  const e = new fo(r), {
    json: t
  } = e;
  if (e.materials)
    for (const i of t.materials || [])
      i.unlit && (delete i.unlit, e.addObjectExtension(i, nm, {}), e.addExtension(nm));
}
const kX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: LX,
  encode: BX,
  name: RX
}, Symbol.toStringTag, { value: "Module" })), Cg = "KHR_techniques_webgl", OX = Cg;
async function DX(r) {
  const e = new fo(r), {
    json: t
  } = e, i = e.getExtension(Cg);
  if (i) {
    const n = FX(i, e);
    for (const s of t.materials || []) {
      const c = e.getObjectExtension(s, Cg);
      c && (s.technique = Object.assign(
        {},
        c,
        // @ts-ignore
        n[c.technique]
      ), s.technique.values = UX(s.technique, e)), e.removeObjectExtension(s, Cg);
    }
    e.removeExtension(Cg);
  }
}
async function NX(r, e) {
}
function FX(r, e) {
  const {
    programs: t = [],
    shaders: i = [],
    techniques: n = []
  } = r, s = new TextDecoder();
  return i.forEach((c) => {
    if (Number.isFinite(c.bufferView))
      c.code = s.decode(e.getTypedArrayForBufferView(c.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), t.forEach((c) => {
    c.fragmentShader = i[c.fragmentShader], c.vertexShader = i[c.vertexShader];
  }), n.forEach((c) => {
    c.program = t[c.program];
  }), n;
}
function UX(r, e) {
  const t = Object.assign({}, r.values);
  return Object.keys(r.uniforms || {}).forEach((i) => {
    r.uniforms[i].value && !(i in t) && (t[i] = r.uniforms[i].value);
  }), Object.keys(t).forEach((i) => {
    typeof t[i] == "object" && t[i].index !== void 0 && (t[i].texture = e.getTexture(t[i].index));
  }), t;
}
const zX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: DX,
  encode: NX,
  name: OX
}, Symbol.toStringTag, { value: "Module" })), PM = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  Bq,
  nq,
  AW,
  EW,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  PW,
  pX,
  MX,
  kX,
  zX,
  EX,
  Yq
];
function jX(r, e = {}, t) {
  const i = PM.filter((n) => MM(n.name, e));
  for (const n of i)
    n.preprocess?.(r, e, t);
}
async function VX(r, e = {}, t) {
  const i = PM.filter((n) => MM(n.name, e));
  for (const n of i)
    await n.decode?.(r, e, t);
}
function MM(r, e) {
  const t = e?.gltf?.excludeExtensions || {};
  return !(r in t && !t[r]);
}
const s1 = "KHR_binary_glTF";
function GX(r) {
  const e = new fo(r), {
    json: t
  } = e;
  for (const i of t.images || []) {
    const n = e.getObjectExtension(i, s1);
    n && Object.assign(i, n), e.removeObjectExtension(i, s1);
  }
  t.buffers && t.buffers[0] && delete t.buffers[0].uri, e.removeExtension(s1);
}
const OS = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, $X = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class HX {
  idToIndexMap = {
    animations: {},
    accessors: {},
    buffers: {},
    bufferViews: {},
    images: {},
    materials: {},
    meshes: {},
    nodes: {},
    samplers: {},
    scenes: {},
    skins: {},
    textures: {}
  };
  json;
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(e, t) {
    this.json = e.json;
    const i = e.json;
    switch (i.asset && i.asset.version) {
      // We are converting to v2 format. Return if there is nothing to do
      case "2.0":
        return;
      // This class is written to convert 1.0
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${i.asset.version}`);
        return;
    }
    if (!t.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(i), this._convertTopLevelObjectsToArrays(i), GX(e), this._convertObjectIdsToArrayIndices(i), this._updateObjects(i), this._updateMaterial(i);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const t in OS)
      this._convertTopLevelObjectToArray(e, t);
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(e, t) {
    const i = e[t];
    if (!(!i || Array.isArray(i))) {
      e[t] = [];
      for (const n in i) {
        const s = i[n];
        s.id = s.id || n;
        const c = e[t].length;
        e[t].push(s), this.idToIndexMap[t][n] = c;
      }
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(e) {
    for (const t in OS)
      this._convertIdsToIndices(e, t);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const t of e.textures)
      this._convertTextureIds(t);
    for (const t of e.meshes)
      this._convertMeshIds(t);
    for (const t of e.nodes)
      this._convertNodeIds(t);
    for (const t of e.scenes)
      this._convertSceneIds(t);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const t of e.primitives) {
      const {
        attributes: i,
        indices: n,
        material: s
      } = t;
      for (const c in i)
        i[c] = this._convertIdToIndex(i[c], "accessor");
      n && (t.indices = this._convertIdToIndex(n, "accessor")), s && (t.material = this._convertIdToIndex(s, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((t) => this._convertIdToIndex(t, "node"))), e.meshes && (e.meshes = e.meshes.map((t) => this._convertIdToIndex(t, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((t) => this._convertIdToIndex(t, "node")));
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(e, t) {
    e[t] || (console.warn(`gltf v1: json doesn't contain attribute ${t}`), e[t] = []);
    for (const i of e[t])
      for (const n in i) {
        const s = i[n], c = this._convertIdToIndex(s, n);
        i[n] = c;
      }
  }
  _convertIdToIndex(e, t) {
    const i = $X[t];
    if (i in this.idToIndexMap) {
      const n = this.idToIndexMap[i][e];
      if (!Number.isFinite(n))
        throw new Error(`gltf v1: failed to resolve ${t} with id ${e}`);
      return n;
    }
    return e;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(e) {
    for (const t of this.json.buffers)
      delete t.type;
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(e) {
    for (const t of e.materials) {
      t.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const i = t.values?.tex || t.values?.texture2d_0 || t.values?.diffuseTex, n = e.textures.findIndex((s) => s.id === i);
      n !== -1 && (t.pbrMetallicRoughness.baseColorTexture = {
        index: n
      });
    }
  }
}
function qX(r, e = {}) {
  return new HX().normalize(r, e);
}
async function WX(r, e, t = 0, i, n) {
  return XX(r, e, t, i), qX(r, {
    normalize: i?.gltf?.normalize
  }), jX(r, i, n), i?.gltf?.loadBuffers && r.json.buffers && await ZX(r, i, n), i?.gltf?.loadImages && await YX(r, i, n), await VX(r, i, n), r;
}
function XX(r, e, t, i) {
  if (i.uri && (r.baseUri = i.uri), e instanceof ArrayBuffer && !nW(e, t, i) && (e = new TextDecoder().decode(e)), typeof e == "string")
    r.json = Q$(e);
  else if (e instanceof ArrayBuffer) {
    const c = {};
    t = sW(c, e, t, i.glb), sl(c.type === "glTF", `Invalid GLB magic string ${c.type}`), r._glb = c, r.json = c.json;
  } else
    sl(!1, "GLTF: must be ArrayBuffer or string");
  const n = r.json.buffers || [];
  if (r.buffers = new Array(n.length).fill(null), r._glb && r._glb.header.hasBinChunk) {
    const {
      binChunks: c
    } = r._glb;
    r.buffers[0] = {
      arrayBuffer: c[0].arrayBuffer,
      byteOffset: c[0].byteOffset,
      byteLength: c[0].byteLength
    };
  }
  const s = r.json.images || [];
  r.images = new Array(s.length).fill({});
}
async function ZX(r, e, t) {
  const i = r.json.buffers || [];
  for (let n = 0; n < i.length; ++n) {
    const s = i[n];
    if (s.uri) {
      const {
        fetch: c
      } = t;
      sl(c);
      const o = TM(s.uri, e), m = await (await t?.fetch?.(o))?.arrayBuffer?.();
      r.buffers[n] = {
        arrayBuffer: m,
        byteOffset: 0,
        byteLength: m.byteLength
      }, delete s.uri;
    } else r.buffers[n] === null && (r.buffers[n] = {
      arrayBuffer: new ArrayBuffer(s.byteLength),
      byteOffset: 0,
      byteLength: s.byteLength
    });
  }
}
async function YX(r, e, t) {
  const i = JX(r), n = r.json.images || [], s = [];
  for (const c of i)
    s.push(KX(r, n[c], c, e, t));
  return await Promise.all(s);
}
function JX(r) {
  const e = /* @__PURE__ */ new Set(), t = r.json.textures || [];
  for (const i of t)
    i.source !== void 0 && e.add(i.source);
  return Array.from(e).sort();
}
async function KX(r, e, t, i, n) {
  let s;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const o = TM(e.uri, i), {
      fetch: d
    } = n;
    s = await (await d(o)).arrayBuffer(), e.bufferView = {
      data: s
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const o = GH(r.json, r.buffers, e.bufferView);
    s = cM(o.buffer, o.byteOffset, o.byteLength);
  }
  sl(s, "glTF image has no data");
  let c = await aM(s, [LH, x$], {
    ...i,
    mimeType: e.mimeType,
    basis: i.basis || {
      format: nM()
    }
  }, n);
  c && c[0] && (c = {
    compressed: !0,
    // @ts-expect-error
    mipmaps: !1,
    width: c[0].width,
    height: c[0].height,
    data: c[0]
  }), r.images = r.images || [], r.images[t] = c;
}
const sm = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: Jq,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: QX,
  options: {
    gltf: {
      normalize: !0,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: !0,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: !0,
      // Create image objects
      decompressMeshes: !0
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function QX(r, e = {}, t) {
  e = {
    ...sm.options,
    ...e
  }, e.gltf = {
    ...sm.options.gltf,
    ...e.gltf
  };
  const {
    byteOffset: i = 0
  } = e;
  return await WX({}, r, i, e, t);
}
const eZ = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, tZ = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, Ml = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, rZ = {
  magFilter: Ml.TEXTURE_MAG_FILTER,
  minFilter: Ml.TEXTURE_MIN_FILTER,
  wrapS: Ml.TEXTURE_WRAP_S,
  wrapT: Ml.TEXTURE_WRAP_T
}, iZ = {
  [Ml.TEXTURE_MAG_FILTER]: Ml.LINEAR,
  [Ml.TEXTURE_MIN_FILTER]: Ml.NEAREST_MIPMAP_LINEAR,
  [Ml.TEXTURE_WRAP_S]: Ml.REPEAT,
  [Ml.TEXTURE_WRAP_T]: Ml.REPEAT
};
function nZ() {
  return {
    id: "default-sampler",
    parameters: iZ
  };
}
function sZ(r) {
  return tZ[r];
}
function oZ(r) {
  return eZ[r];
}
class aZ {
  baseUri = "";
  // @ts-expect-error
  jsonUnprocessed;
  // @ts-expect-error
  json;
  buffers = [];
  images = [];
  postProcess(e, t = {}) {
    const {
      json: i,
      buffers: n = [],
      images: s = []
    } = e, {
      baseUri: c = ""
    } = e;
    return sl(i), this.baseUri = c, this.buffers = n, this.images = s, this.jsonUnprocessed = i, this.json = this._resolveTree(e.json, t), this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(e, t = {}) {
    const i = {
      ...e
    };
    return this.json = i, e.bufferViews && (i.bufferViews = e.bufferViews.map((n, s) => this._resolveBufferView(n, s))), e.images && (i.images = e.images.map((n, s) => this._resolveImage(n, s))), e.samplers && (i.samplers = e.samplers.map((n, s) => this._resolveSampler(n, s))), e.textures && (i.textures = e.textures.map((n, s) => this._resolveTexture(n, s))), e.accessors && (i.accessors = e.accessors.map((n, s) => this._resolveAccessor(n, s))), e.materials && (i.materials = e.materials.map((n, s) => this._resolveMaterial(n, s))), e.meshes && (i.meshes = e.meshes.map((n, s) => this._resolveMesh(n, s))), e.nodes && (i.nodes = e.nodes.map((n, s) => this._resolveNode(n, s)), i.nodes = i.nodes.map((n, s) => this._resolveNodeChildren(n))), e.skins && (i.skins = e.skins.map((n, s) => this._resolveSkin(n, s))), e.scenes && (i.scenes = e.scenes.map((n, s) => this._resolveScene(n, s))), typeof this.json.scene == "number" && i.scenes && (i.scene = i.scenes[this.json.scene]), i;
  }
  getScene(e) {
    return this._get(this.json.scenes, e);
  }
  getNode(e) {
    return this._get(this.json.nodes, e);
  }
  getSkin(e) {
    return this._get(this.json.skins, e);
  }
  getMesh(e) {
    return this._get(this.json.meshes, e);
  }
  getMaterial(e) {
    return this._get(this.json.materials, e);
  }
  getAccessor(e) {
    return this._get(this.json.accessors, e);
  }
  getCamera(e) {
    return this._get(this.json.cameras, e);
  }
  getTexture(e) {
    return this._get(this.json.textures, e);
  }
  getSampler(e) {
    return this._get(this.json.samplers, e);
  }
  getImage(e) {
    return this._get(this.json.images, e);
  }
  getBufferView(e) {
    return this._get(this.json.bufferViews, e);
  }
  getBuffer(e) {
    return this._get(this.json.buffers, e);
  }
  _get(e, t) {
    if (typeof t == "object")
      return t;
    const i = e && e[t];
    return i || console.warn(`glTF file error: Could not find ${e}[${t}]`), i;
  }
  // PARSING HELPERS
  _resolveScene(e, t) {
    return {
      ...e,
      // @ts-ignore
      id: e.id || `scene-${t}`,
      nodes: (e.nodes || []).map((i) => this.getNode(i))
    };
  }
  _resolveNode(e, t) {
    const i = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e?.id || `node-${t}`
    };
    return e.mesh !== void 0 && (i.mesh = this.getMesh(e.mesh)), e.camera !== void 0 && (i.camera = this.getCamera(e.camera)), e.skin !== void 0 && (i.skin = this.getSkin(e.skin)), e.meshes !== void 0 && e.meshes.length && (i.mesh = e.meshes.reduce((n, s) => {
      const c = this.getMesh(s);
      return n.id = c.id, n.primitives = n.primitives.concat(c.primitives), n;
    }, {
      primitives: []
    })), i;
  }
  _resolveNodeChildren(e) {
    return e.children && (e.children = e.children.map((t) => this.getNode(t))), e;
  }
  _resolveSkin(e, t) {
    const i = typeof e.inverseBindMatrices == "number" ? this.getAccessor(e.inverseBindMatrices) : void 0;
    return {
      ...e,
      id: e.id || `skin-${t}`,
      inverseBindMatrices: i
    };
  }
  _resolveMesh(e, t) {
    const i = {
      ...e,
      id: e.id || `mesh-${t}`,
      primitives: []
    };
    return e.primitives && (i.primitives = e.primitives.map((n) => {
      const s = {
        ...n,
        attributes: {},
        indices: void 0,
        material: void 0
      }, c = n.attributes;
      for (const o in c)
        s.attributes[o] = this.getAccessor(c[o]);
      return n.indices !== void 0 && (s.indices = this.getAccessor(n.indices)), n.material !== void 0 && (s.material = this.getMaterial(n.material)), s;
    })), i;
  }
  _resolveMaterial(e, t) {
    const i = {
      ...e,
      // @ts-expect-error
      id: e.id || `material-${t}`
    };
    if (i.normalTexture && (i.normalTexture = {
      ...i.normalTexture
    }, i.normalTexture.texture = this.getTexture(i.normalTexture.index)), i.occlusionTexture && (i.occlusionTexture = {
      ...i.occlusionTexture
    }, i.occlusionTexture.texture = this.getTexture(i.occlusionTexture.index)), i.emissiveTexture && (i.emissiveTexture = {
      ...i.emissiveTexture
    }, i.emissiveTexture.texture = this.getTexture(i.emissiveTexture.index)), i.emissiveFactor || (i.emissiveFactor = i.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), i.pbrMetallicRoughness) {
      i.pbrMetallicRoughness = {
        ...i.pbrMetallicRoughness
      };
      const n = i.pbrMetallicRoughness;
      n.baseColorTexture && (n.baseColorTexture = {
        ...n.baseColorTexture
      }, n.baseColorTexture.texture = this.getTexture(n.baseColorTexture.index)), n.metallicRoughnessTexture && (n.metallicRoughnessTexture = {
        ...n.metallicRoughnessTexture
      }, n.metallicRoughnessTexture.texture = this.getTexture(n.metallicRoughnessTexture.index));
    }
    return i;
  }
  _resolveAccessor(e, t) {
    const i = sZ(e.componentType), n = oZ(e.type), s = i * n, c = {
      ...e,
      // @ts-expect-error
      id: e.id || `accessor-${t}`,
      bytesPerComponent: i,
      components: n,
      bytesPerElement: s,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (e.bufferView !== void 0 && (c.bufferView = this.getBufferView(e.bufferView)), c.bufferView) {
      const o = c.bufferView.buffer, {
        ArrayType: d,
        byteLength: m
      } = Lx(c, c.bufferView), y = (c.bufferView.byteOffset || 0) + (c.byteOffset || 0) + o.byteOffset;
      let T = o.arrayBuffer.slice(y, y + m);
      c.bufferView.byteStride && (T = this._getValueFromInterleavedBuffer(o, y, c.bufferView.byteStride, c.bytesPerElement, c.count)), c.value = new d(T);
    }
    return c;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(e, t, i, n, s) {
    const c = new Uint8Array(s * n);
    for (let o = 0; o < s; o++) {
      const d = t + o * i;
      c.set(new Uint8Array(e.arrayBuffer.slice(d, d + n)), o * n);
    }
    return c.buffer;
  }
  _resolveTexture(e, t) {
    return {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `texture-${t}`,
      sampler: typeof e.sampler == "number" ? this.getSampler(e.sampler) : nZ(),
      source: typeof e.source == "number" ? this.getImage(e.source) : void 0
    };
  }
  _resolveSampler(e, t) {
    const i = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `sampler-${t}`,
      ...e,
      parameters: {}
    };
    for (const n in i) {
      const s = this._enumSamplerParameter(n);
      s !== void 0 && (i.parameters[s] = i[n]);
    }
    return i;
  }
  _enumSamplerParameter(e) {
    return rZ[e];
  }
  _resolveImage(e, t) {
    const i = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `image-${t}`,
      image: null,
      bufferView: e.bufferView !== void 0 ? this.getBufferView(e.bufferView) : void 0
    }, n = this.images[t];
    return n && (i.image = n), i;
  }
  _resolveBufferView(e, t) {
    const i = e.buffer, n = this.buffers[i].arrayBuffer;
    let s = this.buffers[i].byteOffset || 0;
    return e.byteOffset && (s += e.byteOffset), {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${t}`,
      ...e,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[i],
      data: new Uint8Array(n, s, e.byteLength)
    };
  }
  _resolveCamera(e, t) {
    const i = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `camera-${t}`
    };
    return i.perspective, i.orthographic, i;
  }
}
function Fx(r, e) {
  return new aZ().postProcess(r, e);
}
async function lZ(r) {
  const e = [];
  return r.scenes.forEach((t) => {
    t.traverse((i) => {
    });
  }), await cZ(() => e.some((t) => !t.loaded));
}
async function cZ(r) {
  for (; r(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const DS = `uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`, uZ = {
  name: "scenegraph",
  vs: DS,
  fs: DS,
  uniformTypes: {
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    sceneModelMatrix: "mat4x4<f32>",
    composeModelMatrix: "f32"
  }
}, hZ = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef LIGHTING_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(LIGHTING_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(scenegraph.sizeScale);
float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(scenegraph.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef LIGHTING_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, fZ = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
in vec4 vColor;
out vec4 fragColor;
#ifndef LIGHTING_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D pbr_baseColorSampler;
#endif
#endif
void main(void) {
#ifdef LIGHTING_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= layer.opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, RM = [255, 255, 255, 255], dZ = {
  scenegraph: {
    type: "object",
    value: null,
    async: !0
  },
  getScene: (r) => r && r.scenes ? typeof r.scene == "object" ? r.scene : r.scenes[r.scene || 0] : r,
  getAnimator: (r) => r && r.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getColor: {
    type: "accessor",
    value: RM
  },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  // 4x4 matrix
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [sm]
};
class Ux extends zp {
  getShaders() {
    const e = {};
    let t;
    this.props._lighting === "pbr" ? (t = ix, e.LIGHTING_PBR = 1) : t = {
      name: "pbrMaterial"
    };
    const i = [sx, cx, uZ, t];
    return super.getShaders({
      defines: e,
      vs: hZ,
      fs: fZ,
      modules: i
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: RM,
        transition: !0
      },
      instanceModelMatrix: tM
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i
    } = e;
    t.scenegraph !== i.scenegraph ? this._updateScenegraph() : t._animations !== i._animations && this._applyAnimationsProp(this.state.animator, t._animations);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.scenegraph?.destroy();
  }
  get isLoaded() {
    return !!(this.state?.scenegraph && super.isLoaded);
  }
  _updateScenegraph() {
    const e = this.props, {
      device: t
    } = this.context;
    let i = null;
    if (e.scenegraph instanceof Ly)
      i = {
        scenes: [e.scenegraph]
      };
    else if (e.scenegraph && typeof e.scenegraph == "object") {
      const o = e.scenegraph, d = o.json ? Fx(o) : o, m = Y$(t, d, this._getModelOptions());
      i = {
        gltf: d,
        ...m
      }, lZ(m).then(() => {
        this.setNeedsRedraw();
      }).catch((y) => {
        this.raiseError(y, "loading glTF");
      });
    }
    const n = {
      layer: this,
      device: this.context.device
    }, s = e.getScene(i, n), c = e.getAnimator(i, n);
    if (s instanceof Fp) {
      this.state.scenegraph?.destroy(), this._applyAnimationsProp(c, e._animations);
      const o = [];
      s.traverse((d) => {
        d instanceof Ev && o.push(d.model);
      }), this.setState({
        scenegraph: s,
        animator: c,
        models: o
      }), this.getAttributeManager().invalidateAll();
    } else s !== null && Ni.warn("invalid scenegraph:", s)();
  }
  _applyAnimationsProp(e, t) {
    if (!e || !t)
      return;
    const i = e.getAnimations();
    Object.keys(t).sort().forEach((n) => {
      const s = t[n];
      if (n === "*")
        i.forEach((c) => {
          Object.assign(c, s);
        });
      else if (Number.isFinite(Number(n))) {
        const c = Number(n);
        c >= 0 && c < i.length ? Object.assign(i[c], s) : Ni.warn(`animation ${n} not found`)();
      } else {
        const c = i.find(({
          animation: o
        }) => o.name === n);
        c ? Object.assign(c, s) : Ni.warn(`animation ${n} not found`)();
      }
    });
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment: e
    } = this.props;
    let t;
    return e && (typeof e == "function" ? t = e({
      gl: this.context.gl,
      layer: this
    }) : t = e), {
      imageBasedLightingEnvironment: t,
      modelOptions: {
        id: this.props.id,
        isInstanced: !0,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: !1
    };
  }
  draw({
    context: e
  }) {
    if (!this.state.scenegraph) return;
    this.props._animations && this.state.animator && (this.state.animator.animate(e.timeline.getTime()), this.setNeedsRedraw());
    const {
      viewport: t,
      renderPass: i
    } = this.context, {
      sizeScale: n,
      sizeMinPixels: s,
      sizeMaxPixels: c,
      coordinateSystem: o
    } = this.props, d = {
      camera: t.cameraPosition
    }, m = this.getNumInstances();
    this.state.scenegraph.traverse((y, {
      worldMatrix: T
    }) => {
      if (y instanceof Ev) {
        const {
          model: P
        } = y;
        P.setInstanceCount(m);
        const I = {
          sizeScale: n,
          sizeMinPixels: s,
          sizeMaxPixels: c,
          composeModelMatrix: rM(t, o),
          sceneModelMatrix: T
        };
        P.shaderInputs.setProps({
          pbrProjection: d,
          scenegraph: I
        }), P.draw(i);
      }
    });
  }
}
Ux.defaultProps = dZ;
Ux.layerName = "ScenegraphLayer";
const NS = `uniform meshUniforms {
  bool pickFeatureIds;
} mesh;
`, pZ = {
  name: "mesh",
  vs: NS,
  fs: NS,
  uniformTypes: {
    pickFeatureIds: "f32"
  }
}, gZ = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (mesh.pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBRMATERIAL
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, mZ = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBRMATERIAL
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= layer.opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function _Z(r) {
  const e = r.positions || r.POSITION, t = e.value.length / e.size;
  r.COLOR_0 || r.colors || (r.colors = {
    size: 4,
    value: new Uint8Array(t * 4).fill(255),
    normalized: !0
  });
}
const yZ = {
  pbrMaterial: {
    type: "object",
    value: null
  },
  featureIds: {
    type: "array",
    value: null,
    optional: !0
  }
};
class zx extends Ix {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(ix, pZ), {
      ...e,
      vs: gZ,
      fs: mZ
    };
  }
  initializeState() {
    const {
      featureIds: e
    } = this.props;
    super.initializeState();
    const t = this.getAttributeManager();
    e && t.add({
      featureIdsPickingColors: {
        type: "uint8",
        size: 3,
        noAlloc: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i
    } = e;
    t.pbrMaterial !== i.pbrMaterial && this.updatePbrMaterialUniforms(t.pbrMaterial);
  }
  draw(e) {
    const {
      featureIds: t
    } = this.props, {
      model: i
    } = this.state;
    if (!i)
      return;
    const n = {
      pickFeatureIds: !!t
    }, s = {
      camera: this.context.viewport.cameraPosition
    };
    i.shaderInputs.setProps({
      pbrProjection: s,
      mesh: n
    }), super.draw(e);
  }
  getModel(e) {
    const {
      id: t
    } = this.props, i = this.parseMaterial(this.props.pbrMaterial, e);
    this.setState({
      parsedPBRMaterial: i
    });
    const n = this.getShaders();
    return _Z(e.attributes), new Zh(this.context.device, {
      ...this.getShaders(),
      id: t,
      geometry: e,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...n.defines,
        ...i?.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions ? 1 : 0
      },
      parameters: i?.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const {
      model: t
    } = this.state;
    if (t) {
      const {
        mesh: i
      } = this.props, n = this.parseMaterial(e, i);
      this.setState({
        parsedPBRMaterial: n
      });
      const {
        pbr_baseColorSampler: s
      } = n.bindings, {
        emptyTexture: c
      } = this.state, o = {
        sampler: s || c,
        hasTexture: !!s
      }, {
        camera: d,
        ...m
      } = {
        ...n.bindings,
        ...n.uniforms
      };
      t.shaderInputs.setProps({
        simpleMesh: o,
        pbrMaterial: m
      });
    }
  }
  parseMaterial(e, t) {
    const i = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return sM(this.context.device, {
      unlit: i,
      ...e
    }, {
      NORMAL: t.attributes.normals,
      TEXCOORD_0: t.attributes.texCoords
    }, {
      pbrDebug: !1,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const t = this.props.featureIds, i = new Uint8ClampedArray(t.length * e.size), n = [];
    for (let s = 0; s < t.length; s++)
      this.encodePickingColor(t[s], n), i[s * 3] = n[0], i[s * 3 + 1] = n[1], i[s * 3 + 2] = n[2];
    e.value = i;
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.parsedPBRMaterial?.generatedTextures.forEach((t) => t.destroy()), this.setState({
      parsedPBRMaterial: null
    });
  }
}
zx.layerName = "MeshLayer";
zx.defaultProps = yZ;
const bZ = 6378137, vZ = 6378137, xZ = 6356752314245179e-9;
function a0(r) {
  return r;
}
new xt();
function wZ(r, e = [], t = a0) {
  return "longitude" in r ? (e[0] = t(r.longitude), e[1] = t(r.latitude), e[2] = r.height) : "x" in r ? (e[0] = t(r.x), e[1] = t(r.y), e[2] = r.z) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function AZ(r, e = []) {
  return wZ(r, e, Qs._cartographicRadians ? a0 : kN);
}
function TZ(r, e, t = a0) {
  return "longitude" in e ? (e.longitude = t(r[0]), e.latitude = t(r[1]), e.height = r[2]) : "x" in e ? (e.x = t(r[0]), e.y = t(r[1]), e.z = r[2]) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function SZ(r, e) {
  return TZ(r, e, Qs._cartographicRadians ? a0 : ON);
}
const FS = 1e-14, EZ = new xt(), US = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, o1 = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, gg = {
  east: new xt(),
  north: new xt(),
  up: new xt(),
  west: new xt(),
  south: new xt(),
  down: new xt()
}, CZ = new xt(), IZ = new xt(), PZ = new xt();
function zS(r, e, t, i, n, s) {
  const c = US[e] && US[e][t];
  bc(c && (!i || i === c));
  let o, d, m;
  const y = EZ.copy(n);
  if (Ac(y.x, 0, FS) && Ac(y.y, 0, FS)) {
    const P = Math.sign(y.z);
    o = CZ.fromArray(o1[e]), e !== "east" && e !== "west" && o.scale(P), d = IZ.fromArray(o1[t]), t !== "east" && t !== "west" && d.scale(P), m = PZ.fromArray(o1[i]), i !== "east" && i !== "west" && m.scale(P);
  } else {
    const {
      up: P,
      east: I,
      north: D
    } = gg;
    I.set(-y.y, y.x, 0).normalize(), r.geodeticSurfaceNormal(y, P), D.copy(P).cross(I);
    const {
      down: k,
      west: $,
      south: G
    } = gg;
    k.copy(P).scale(-1), $.copy(I).scale(-1), G.copy(D).scale(-1), o = gg[e], d = gg[t], m = gg[i];
  }
  return s[0] = o.x, s[1] = o.y, s[2] = o.z, s[3] = 0, s[4] = d.x, s[5] = d.y, s[6] = d.z, s[7] = 0, s[8] = m.x, s[9] = m.y, s[10] = m.z, s[11] = 0, s[12] = y.x, s[13] = y.y, s[14] = y.z, s[15] = 1, s;
}
const $d = new xt(), MZ = new xt(), RZ = new xt();
function LZ(r, e, t = []) {
  const {
    oneOverRadii: i,
    oneOverRadiiSquared: n,
    centerToleranceSquared: s
  } = e;
  $d.from(r);
  const c = $d.x, o = $d.y, d = $d.z, m = i.x, y = i.y, T = i.z, P = c * c * m * m, I = o * o * y * y, D = d * d * T * T, k = P + I + D, $ = Math.sqrt(1 / k);
  if (!Number.isFinite($))
    return;
  const G = MZ;
  if (G.copy(r).scale($), k < s)
    return G.to(t);
  const te = n.x, Z = n.y, H = n.z, J = RZ;
  J.set(G.x * te * 2, G.y * Z * 2, G.z * H * 2);
  let re = (1 - $) * $d.len() / (0.5 * J.len()), be = 0, pe, oe, Ee, le;
  do {
    re -= be, pe = 1 / (1 + re * te), oe = 1 / (1 + re * Z), Ee = 1 / (1 + re * H);
    const _e = pe * pe, Ve = oe * oe, Be = Ee * Ee, gt = _e * pe, St = Ve * oe, Mt = Be * Ee;
    le = P * _e + I * Ve + D * Be - 1;
    const wt = -2 * (P * gt * te + I * St * Z + D * Mt * H);
    be = le / wt;
  } while (Math.abs(le) > e8);
  return $d.scale([pe, oe, Ee]).to(t);
}
const b_ = new xt(), jS = new xt(), BZ = new xt(), hc = new xt(), kZ = new xt(), v_ = new xt();
class Tn {
  constructor(e = 0, t = 0, i = 0) {
    this.centerToleranceSquared = QF, bc(e >= 0), bc(t >= 0), bc(i >= 0), this.radii = new xt(e, t, i), this.radiiSquared = new xt(e * e, t * t, i * i), this.radiiToTheFourth = new xt(e * e * e * e, t * t * t * t, i * i * i * i), this.oneOverRadii = new xt(e === 0 ? 0 : 1 / e, t === 0 ? 0 : 1 / t, i === 0 ? 0 : 1 / i), this.oneOverRadiiSquared = new xt(e === 0 ? 0 : 1 / (e * e), t === 0 ? 0 : 1 / (t * t), i === 0 ? 0 : 1 / (i * i)), this.minimumRadius = Math.min(e, t, i), this.maximumRadius = Math.max(e, t, i), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e, t = [0, 0, 0]) {
    const i = jS, n = BZ, [, , s] = e;
    this.geodeticSurfaceNormalCartographic(e, i), n.copy(this.radiiSquared).scale(i);
    const c = Math.sqrt(i.dot(n));
    return n.scale(1 / c), i.scale(s), n.add(i), n.to(t);
  }
  cartesianToCartographic(e, t = [0, 0, 0]) {
    v_.from(e);
    const i = this.scaleToGeodeticSurface(v_, hc);
    if (!i)
      return;
    const n = this.geodeticSurfaceNormal(i, jS), s = kZ;
    s.copy(v_).subtract(i);
    const c = Math.atan2(n.y, n.x), o = Math.asin(n.z), d = Math.sign(K2(s, v_)) * BI(s);
    return SZ([c, o, d], t);
  }
  eastNorthUpToFixedFrame(e, t = new Pi()) {
    return zS(this, "east", "north", "up", e, t);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(e, t, i, n, s = new Pi()) {
    return zS(this, e, t, i, n, s);
  }
  geocentricSurfaceNormal(e, t = [0, 0, 0]) {
    return b_.from(e).normalize().to(t);
  }
  geodeticSurfaceNormalCartographic(e, t = [0, 0, 0]) {
    const i = AZ(e), n = i[0], s = i[1], c = Math.cos(s);
    return b_.set(c * Math.cos(n), c * Math.sin(n), Math.sin(s)).normalize(), b_.to(t);
  }
  geodeticSurfaceNormal(e, t = [0, 0, 0]) {
    return b_.from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(e, t) {
    return LZ(e, this, t);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(e, t = [0, 0, 0]) {
    hc.from(e);
    const i = hc.x, n = hc.y, s = hc.z, c = this.oneOverRadiiSquared, o = 1 / Math.sqrt(i * i * c.x + n * n * c.y + s * s * c.z);
    return hc.multiplyScalar(o).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(e, t = [0, 0, 0]) {
    return hc.from(e).scale(this.oneOverRadii).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(e, t = [0, 0, 0]) {
    return hc.from(e).scale(this.radii).to(t);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(e, t = 0, i = [0, 0, 0]) {
    bc(Ac(this.radii.x, this.radii.y, $I)), bc(this.radii.z > 0), hc.from(e);
    const n = hc.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(n) >= this.radii.z - t))
      return hc.set(0, 0, n).to(i);
  }
}
Tn.WGS84 = new Tn(bZ, vZ, xZ);
function Ff(r, e) {
  if (!r)
    throw new Error(e || "loader assertion failed.");
}
const OZ = "Queued Requests", DZ = "Active Requests", NZ = "Cancelled Requests", FZ = "Queued Requests Ever", UZ = "Active Requests Ever", zZ = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: !0,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
class jZ {
  props;
  stats;
  activeRequestCount = 0;
  /** Tracks the number of active requests and prioritizes/cancels queued requests. */
  requestQueue = [];
  requestMap = /* @__PURE__ */ new Map();
  updateTimer = null;
  constructor(e = {}) {
    this.props = {
      ...zZ,
      ...e
    }, this.stats = new kp({
      id: this.props.id
    }), this.stats.get(OZ), this.stats.get(DZ), this.stats.get(NZ), this.stats.get(FZ), this.stats.get(UZ);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(e, t = () => 0) {
    if (!this.props.throttleRequests)
      return Promise.resolve({
        done: () => {
        }
      });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const i = {
      handle: e,
      priority: 0,
      getPriority: t
    }, n = new Promise((s) => (i.resolve = s, i));
    return this.requestQueue.push(i), this.requestMap.set(e, n), this._issueNewRequests(), n;
  }
  // PRIVATE
  _issueRequest(e) {
    const {
      handle: t,
      resolve: i
    } = e;
    let n = !1;
    const s = () => {
      n || (n = !0, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, i ? i({
      done: s
    }) : Promise.resolve({
      done: s
    });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let t = 0; t < e; ++t) {
        const i = this.requestQueue.shift();
        i && this._issueRequest(i);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let t = 0; t < e.length; ++t) {
      const i = e[t];
      this._updateRequest(i) || (e.splice(t, 1), this.requestMap.delete(i.handle), t--);
    }
    e.sort((t, i) => t.priority - i.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
function VZ(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(0, e) : "";
}
class GZ {
  item;
  previous;
  next;
  constructor(e, t, i) {
    this.item = e, this.previous = t, this.next = i;
  }
}
class $Z {
  head = null;
  tail = null;
  _length = 0;
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(e) {
    const t = new GZ(e, this.tail, null);
    return this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(e, t) {
    e !== t && (this.remove(t), this._insert(e, t));
  }
  _insert(e, t) {
    const i = e.next;
    e.next = t, this.tail === e ? this.tail = t : i.previous = t, t.next = i, t.previous = e, ++this._length;
  }
}
class HZ {
  _list;
  _sentinel;
  _trimTiles;
  constructor() {
    this._list = new $Z(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const t = e._cacheNode;
    t && this._list.splice(this._sentinel, t);
  }
  add(e, t, i) {
    t._cacheNode || (t._cacheNode = this._list.add(t), i && i(e, t));
  }
  unloadTile(e, t, i) {
    const n = t._cacheNode;
    n && (this._list.remove(n), t._cacheNode = null, i && i(e, t));
  }
  unloadTiles(e, t) {
    const i = this._trimTiles;
    this._trimTiles = !1;
    const n = this._list, s = e.maximumMemoryUsage * 1024 * 1024, c = this._sentinel;
    let o = n.head;
    for (; o !== c && (e.gpuMemoryUsageInBytes > s || i); ) {
      const d = o.item;
      o = o.next, this.unloadTile(e, d, t);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function qZ(r, e) {
  Ff(r), Ff(e);
  const {
    rtcCenter: t,
    gltfUpAxis: i
  } = e, {
    computedTransform: n,
    boundingVolume: {
      center: s
    }
  } = r;
  let c = new Pi(n);
  switch (t && c.translate(t), i) {
    case "Z":
      break;
    case "Y":
      const T = new Pi().rotateX(Math.PI / 2);
      c = c.multiplyRight(T);
      break;
    case "X":
      const P = new Pi().rotateY(-Math.PI / 2);
      c = c.multiplyRight(P);
      break;
  }
  e.isQuantized && c.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const o = new xt(s);
  e.cartesianModelMatrix = c, e.cartesianOrigin = o;
  const d = Tn.WGS84.cartesianToCartographic(o, new xt()), y = Tn.WGS84.eastNorthUpToFixedFrame(o).invert();
  e.cartographicModelMatrix = y.multiplyRight(c), e.cartographicOrigin = d, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const VS = new xt(), a1 = new xt(), qv = new Ll([new gu(), new gu(), new gu(), new gu(), new gu(), new gu()]);
function WZ(r, e) {
  const {
    cameraDirection: t,
    cameraUp: i,
    height: n
  } = r, {
    metersPerUnit: s
  } = r.distanceScales, c = K_(r, r.center), o = Tn.WGS84.eastNorthUpToFixedFrame(c), d = r.unprojectPosition(r.cameraPosition), m = Tn.WGS84.cartographicToCartesian(d, new xt()), y = new xt(
    // @ts-ignore
    o.transformAsVector(new xt(t).scale(s))
  ).normalize(), T = new xt(
    // @ts-ignore
    o.transformAsVector(new xt(i).scale(s))
  ).normalize();
  ZZ(r);
  const P = r.constructor, {
    longitude: I,
    latitude: D,
    width: k,
    bearing: $,
    zoom: G
  } = r, te = new P({
    longitude: I,
    latitude: D,
    height: n,
    width: k,
    bearing: $,
    zoom: G,
    pitch: 0
  });
  return {
    camera: {
      position: m,
      direction: y,
      up: T
    },
    viewport: r,
    topDownViewport: te,
    height: n,
    cullingVolume: qv,
    frameNumber: e,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function XZ(r, e, t) {
  if (t === 0 || r.length <= t)
    return [r, []];
  const i = [], {
    longitude: n,
    latitude: s
  } = e.viewport;
  for (const [m, y] of r.entries()) {
    const [T, P] = y.header.mbs, I = Math.abs(n - T), D = Math.abs(s - P), k = Math.sqrt(D * D + I * I);
    i.push([m, k]);
  }
  const c = i.sort((m, y) => m[1] - y[1]), o = [];
  for (let m = 0; m < t; m++)
    o.push(r[c[m][0]]);
  const d = [];
  for (let m = t; m < c.length; m++)
    d.push(r[c[m][0]]);
  return [o, d];
}
function ZZ(r) {
  const e = r.getFrustumPlanes(), t = GS(e.near, r.cameraPosition), i = K_(r, t), n = K_(r, r.cameraPosition, a1);
  let s = 0;
  qv.planes[s++].fromPointNormal(i, VS.copy(i).subtract(n));
  for (const c in e) {
    if (c === "near")
      continue;
    const o = e[c], d = GS(o, t, a1), m = K_(r, d, a1);
    qv.planes[s++].fromPointNormal(
      m,
      // Want the normal to point into the frustum since that's what culling expects
      VS.copy(i).subtract(m)
    );
  }
}
function GS(r, e, t = new xt()) {
  const i = r.normal.dot(e);
  return t.copy(r.normal).scale(r.distance - i).add(e), t;
}
function K_(r, e, t = new xt()) {
  const i = r.unprojectPosition(e);
  return Tn.WGS84.cartographicToCartesian(i, t);
}
const YZ = 6378137, JZ = 6378137, Wv = 6356752314245179e-9, op = new xt();
function KZ(r, e) {
  if (r instanceof pm) {
    const {
      halfAxes: t
    } = r, i = eY(t);
    return Math.log2(Wv / (i + e[2]));
  } else if (r instanceof dm) {
    const {
      radius: t
    } = r;
    return Math.log2(Wv / (t + e[2]));
  } else if (r.width && r.height) {
    const {
      width: t,
      height: i
    } = r, n = Math.log2(YZ / t), s = Math.log2(JZ / i);
    return (n + s) / 2;
  }
  return 1;
}
function LM(r, e, t) {
  Tn.WGS84.cartographicToCartesian([r.xmax, r.ymax, r.zmax], op);
  const i = Math.sqrt(Math.pow(op[0] - t[0], 2) + Math.pow(op[1] - t[1], 2) + Math.pow(op[2] - t[2], 2));
  return Math.log2(Wv / (i + e[2]));
}
function QZ(r, e, t) {
  const [i, n, s, c] = r;
  return LM({
    xmax: s,
    ymax: c,
    zmax: 0
  }, e, t);
}
function eY(r) {
  r.getColumn(0, op);
  const e = r.getColumn(1), t = r.getColumn(2);
  return op.add(e).add(t).len();
}
const el = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var Tc;
(function(r) {
  r[r.ADD = 1] = "ADD", r[r.REPLACE = 2] = "REPLACE";
})(Tc || (Tc = {}));
var sh;
(function(r) {
  r.EMPTY = "empty", r.SCENEGRAPH = "scenegraph", r.POINTCLOUD = "pointcloud", r.MESH = "mesh";
})(sh || (sh = {}));
var Ea;
(function(r) {
  r.I3S = "I3S", r.TILES3D = "TILES3D";
})(Ea || (Ea = {}));
var Ip;
(function(r) {
  r.GEOMETRIC_ERROR = "geometricError", r.MAX_SCREEN_THRESHOLD = "maxScreenThreshold";
})(Ip || (Ip = {}));
const tY = {
  USE_OPTIMIZATION: 1
};
function BM(r) {
  return r != null;
}
const Go = new xt(), Q_ = new xt(), rY = new xt(), iY = new xt(), Sf = new xt(), $S = new xt(), HS = new xt(), qS = new xt();
function l1(r, e, t) {
  if (Ff(r, "3D Tile: boundingVolume must be defined"), r.box)
    return kM(r.box, e, t);
  if (r.region)
    return oY(r.region);
  if (r.sphere)
    return sY(r.sphere, e, t);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function nY(r, e) {
  if (r.box)
    return aY(e);
  if (r.region) {
    const [t, i, n, s, c, o] = r.region;
    return [[yc(t), yc(i), c], [yc(n), yc(s), o]];
  }
  if (r.sphere)
    return lY(e);
  throw new Error("Unkown boundingVolume type");
}
function kM(r, e, t) {
  const i = new xt(r[0], r[1], r[2]);
  e.transform(i, i);
  let n = [];
  if (r.length === 10) {
    const m = r.slice(3, 6), y = new Xg();
    y.fromArray(r, 6);
    const T = new xt([1, 0, 0]), P = new xt([0, 1, 0]), I = new xt([0, 0, 1]);
    T.transformByQuaternion(y), T.scale(m[0]), P.transformByQuaternion(y), P.scale(m[1]), I.transformByQuaternion(y), I.scale(m[2]), n = [...T.toArray(), ...P.toArray(), ...I.toArray()];
  } else
    n = [...r.slice(3, 6), ...r.slice(6, 9), ...r.slice(9, 12)];
  const s = e.transformAsVector(n.slice(0, 3)), c = e.transformAsVector(n.slice(3, 6)), o = e.transformAsVector(n.slice(6, 9)), d = new hs([s[0], s[1], s[2], c[0], c[1], c[2], o[0], o[1], o[2]]);
  return BM(t) ? (t.center = i, t.halfAxes = d, t) : new pm(i, d);
}
function sY(r, e, t) {
  const i = new xt(r[0], r[1], r[2]);
  e.transform(i, i);
  const n = e.getScale(Q_), s = Math.max(Math.max(n[0], n[1]), n[2]), c = r[3] * s;
  return BM(t) ? (t.center = i, t.radius = c, t) : new dm(i, c);
}
function oY(r) {
  const [e, t, i, n, s, c] = r, o = Tn.WGS84.cartographicToCartesian([yc(e), yc(n), s], rY), d = Tn.WGS84.cartographicToCartesian([yc(i), yc(t), c], iY), m = new xt().addVectors(o, d).multiplyByScalar(0.5);
  return Tn.WGS84.cartesianToCartographic(m, Sf), Tn.WGS84.cartographicToCartesian([yc(i), Sf[1], Sf[2]], $S), Tn.WGS84.cartographicToCartesian([Sf[0], yc(n), Sf[2]], HS), Tn.WGS84.cartographicToCartesian([Sf[0], Sf[1], c], qS), kM([...m, ...$S.subtract(m), ...HS.subtract(m), ...qS.subtract(m)], new Pi());
}
function aY(r) {
  const e = OM(), {
    halfAxes: t
  } = r, i = new xt(t.getColumn(0)), n = new xt(t.getColumn(1)), s = new xt(t.getColumn(2));
  for (let c = 0; c < 2; c++) {
    for (let o = 0; o < 2; o++) {
      for (let d = 0; d < 2; d++)
        Go.copy(r.center), Go.add(i), Go.add(n), Go.add(s), DM(e, Go), s.negate();
      n.negate();
    }
    i.negate();
  }
  return e;
}
function lY(r) {
  const e = OM(), {
    center: t,
    radius: i
  } = r, n = Tn.WGS84.scaleToGeodeticSurface(t, Go);
  let s;
  n ? s = Tn.WGS84.geodeticSurfaceNormal(n) : s = new xt(0, 0, 1);
  let c = new xt(s[2], -s[1], 0);
  c.len() > 0 ? c.normalize() : c = new xt(0, 1, 0);
  const o = c.clone().cross(s);
  for (const d of [c, o, s]) {
    Q_.copy(d).scale(i);
    for (let m = 0; m < 2; m++)
      Go.copy(t), Go.add(Q_), DM(e, Go), Q_.negate();
  }
  return e;
}
function OM() {
  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
}
function DM(r, e) {
  Tn.WGS84.cartesianToCartographic(e, Go), r[0][0] = Math.min(r[0][0], Go[0]), r[0][1] = Math.min(r[0][1], Go[1]), r[0][2] = Math.min(r[0][2], Go[2]), r[1][0] = Math.max(r[1][0], Go[0]), r[1][1] = Math.max(r[1][1], Go[1]), r[1][2] = Math.max(r[1][2], Go[2]);
}
new xt();
new xt();
new Pi();
new xt();
new xt();
new xt();
function cY(r, e) {
  const t = r * e;
  return 1 - Math.exp(-(t * t));
}
function uY(r, e) {
  if (r.dynamicScreenSpaceError && r.dynamicScreenSpaceErrorComputedDensity) {
    const t = r.dynamicScreenSpaceErrorComputedDensity, i = r.dynamicScreenSpaceErrorFactor;
    return cY(e, t) * i;
  }
  return 0;
}
function hY(r, e, t) {
  const i = r.tileset, n = r.parent && r.parent.lodMetricValue || r.lodMetricValue, s = t ? n : r.lodMetricValue;
  if (s === 0)
    return 0;
  const c = Math.max(r._distanceToCamera, 1e-7), {
    height: o,
    sseDenominator: d
  } = e, {
    viewDistanceScale: m
  } = i.options;
  let y = s * o * (m || 1) / (c * d);
  return y -= uY(i, c), y;
}
const c1 = new xt(), WS = new xt(), Bh = new xt(), XS = new xt(), fY = new xt(), u1 = new Pi(), ZS = new Pi();
function dY(r, e) {
  if (r.lodMetricValue === 0 || isNaN(r.lodMetricValue))
    return "DIG";
  const t = 2 * NM(r, e);
  return t < 2 ? "OUT" : !r.header.children || t <= r.lodMetricValue ? "DRAW" : r.header.children ? "DIG" : "OUT";
}
function NM(r, e) {
  const {
    topDownViewport: t
  } = e, i = r.header.mbs[1], n = r.header.mbs[0], s = r.header.mbs[2], c = r.header.mbs[3], o = [...r.boundingVolume.center], d = t.unprojectPosition(t.cameraPosition);
  Tn.WGS84.cartographicToCartesian(d, c1), WS.copy(c1).subtract(o).normalize(), Tn.WGS84.eastNorthUpToFixedFrame(o, u1), ZS.copy(u1).invert(), Bh.copy(c1).transform(ZS);
  const m = Math.sqrt(Bh[0] * Bh[0] + Bh[1] * Bh[1]), y = m * m / Bh[2];
  XS.copy([Bh[0], Bh[1], y]);
  const P = XS.transform(u1).subtract(o).normalize(), D = WS.cross(P).normalize().scale(c).add(o), k = Tn.WGS84.cartesianToCartographic(D), $ = t.project([n, i, s]), G = t.project(k);
  return fY.copy($).subtract(G).magnitude();
}
function pY(r) {
  return {
    assetGltfUpAxis: r.asset && r.asset.gltfUpAxis || "Y"
  };
}
class YS {
  _map = /* @__PURE__ */ new Map();
  _array;
  _length;
  constructor(e = 0) {
    this._array = new Array(e), this._length = e;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(e) {
    return Ff(e < this._array.length), this._array[e];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(e, t) {
    Ff(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = t, this._map.set(t, e);
  }
  delete(e) {
    const t = this._map.get(e);
    t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(e) {
    if (!this._map.has(e)) {
      const t = this.length++;
      this._array[t] = e, this._map.set(e, t);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(e) {
    Ff(e >= 0), e > this._array.length && (this._array.length = e);
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(e) {
    Ff(e >= 0), this.length = e;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const gY = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class l0 {
  options;
  // fulfill in traverse call
  root = null;
  // tiles should be rendered
  selectedTiles = {};
  // tiles should be loaded from server
  requestedTiles = {};
  // tiles does not have render content
  emptyTiles = {};
  lastUpdate = (/* @__PURE__ */ new Date()).getTime();
  updateDebounceTime = 1e3;
  /** temporary storage to hold the traversed tiles during a traversal */
  _traversalStack = new YS();
  _emptyTraversalStack = new YS();
  /** set in every traverse cycle */
  _frameNumber = null;
  // RESULT
  traversalFinished(e) {
    return !0;
  }
  // TODO nested props
  constructor(e) {
    this.options = {
      ...gY,
      ...e
    };
  }
  // tiles should be visible
  traverse(e, t, i) {
    this.root = e, this.options = {
      ...this.options,
      ...i
    }, this.reset(), this.updateTile(e, t), this._frameNumber = t.frameNumber, this.executeTraversal(e, t);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(e, t) {
    const i = this._traversalStack;
    for (e._selectionDepth = 1, i.push(e); i.length > 0; ) {
      const s = i.pop();
      let c = !1;
      this.canTraverse(s, t) && (this.updateChildTiles(s, t), c = this.updateAndPushChildren(s, t, i, s.hasRenderContent ? s._selectionDepth + 1 : s._selectionDepth));
      const o = s.parent, d = !!(!o || o._shouldRefine), m = !c;
      s.hasRenderContent ? s.refine === Tc.ADD ? (this.loadTile(s, t), this.selectTile(s, t)) : s.refine === Tc.REPLACE && (this.loadTile(s, t), m && this.selectTile(s, t)) : (this.emptyTiles[s.id] = s, this.loadTile(s, t), m && this.selectTile(s, t)), this.touchTile(s, t), s._shouldRefine = c && d;
    }
    const n = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(t) || n - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = n, this.options.onTraversalEnd(t));
  }
  updateChildTiles(e, t) {
    const i = e.children;
    for (const n of i)
      this.updateTile(n, t);
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(e, t, i, n) {
    const {
      loadSiblings: s,
      skipLevelOfDetail: c
    } = this.options, o = e.children;
    o.sort(this.compareDistanceToCamera.bind(this));
    const d = e.refine === Tc.REPLACE && e.hasRenderContent && !c;
    let m = !1, y = !0;
    for (const T of o)
      if (T._selectionDepth = n, T.isVisibleAndInRequestVolume ? (i.find(T) && i.delete(T), i.push(T), m = !0) : (d || s) && (this.loadTile(T, t), this.touchTile(T, t)), d) {
        let P;
        if (T._inRequestVolume ? T.hasRenderContent ? P = T.contentAvailable : P = this.executeEmptyTraversal(T, t) : P = !1, y = y && P, !y)
          return !1;
      }
    return m || (y = !1), y;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(e, t) {
    this.updateTileVisibility(e, t);
  }
  // tile to render in the browser
  selectTile(e, t) {
    this.shouldSelectTile(e) && (e._selectedFrame = t.frameNumber, this.selectedTiles[e.id] = e);
  }
  // tile to load from server
  loadTile(e, t) {
    this.shouldLoadTile(e) && (e._requestedFrame = t.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  // cache tile
  touchTile(e, t) {
    e.tileset._cache.touch(e), e._touchedFrame = t.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(e, t) {
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, t) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(e, t, i = !1) {
    let n = e._screenSpaceError;
    return i && (n = e.getScreenSpaceError(t, !0)), n > e.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(e, t) {
    const i = [];
    if (this.options.viewportTraversersMap)
      for (const n in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[n] === t.viewport.id && i.push(n);
    else
      i.push(t.viewport.id);
    e.updateVisibility(t, i);
  }
  // UTILITIES
  compareDistanceToCamera(e, t) {
    return e._distanceToCamera - t._distanceToCamera;
  }
  anyChildrenVisible(e, t) {
    let i = !1;
    for (const n of e.children)
      n.updateVisibility(t), i = i || n.isVisibleAndInRequestVolume;
    return i;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(e, t) {
    let i = !0;
    const n = this._emptyTraversalStack;
    for (n.push(e); n.length > 0; ) {
      const s = n.pop(), c = !s.hasRenderContent && this.canTraverse(s, t), o = !s.hasRenderContent && s.children.length === 0;
      if (!c && !s.contentAvailable && !o && (i = !1), this.updateTile(s, t), s.isVisibleAndInRequestVolume || (this.loadTile(s, t), this.touchTile(s, t)), c) {
        const d = s.children;
        for (const m of d)
          n.push(m);
      }
    }
    return i;
  }
}
const JS = new xt();
function mY(r) {
  return r != null;
}
class Xv {
  tileset;
  header;
  id;
  url;
  parent;
  /* Specifies the type of refine that is used when traversing this tile for rendering. */
  refine;
  type;
  contentUrl;
  /** Different refinement algorithms used by I3S and 3D tiles */
  lodMetricType = "geometricError";
  /** The error, in meters, introduced if this tile is rendered and its children are not. */
  lodMetricValue = 0;
  /** @todo math.gl is not exporting BoundingVolume base type? */
  boundingVolume = null;
  /**
   * The tile's content.  This represents the actual tile's payload,
   * not the content's metadata in the tileset JSON file.
   */
  content = null;
  contentState = el.UNLOADED;
  gpuMemoryUsageInBytes = 0;
  /** The tile's children - an array of Tile3D objects. */
  children = [];
  depth = 0;
  viewportIds = [];
  transform = new Pi();
  extensions = null;
  /** TODO Cesium 3d tiles specific */
  implicitTiling = null;
  /** Container to store application specific data */
  userData = {};
  computedTransform;
  hasEmptyContent = !1;
  hasTilesetContent = !1;
  traverser = new l0({});
  /** Used by TilesetCache */
  _cacheNode = null;
  _frameNumber = null;
  // TODO Cesium 3d tiles specific
  _expireDate = null;
  _expiredContent = null;
  _boundingBox = void 0;
  /** updated every frame for tree traversal and rendering optimizations: */
  _distanceToCamera = 0;
  _screenSpaceError = 0;
  _visibilityPlaneMask;
  _visible = void 0;
  _contentBoundingVolume;
  _viewerRequestVolume;
  _initialTransform = new Pi();
  // Used by traverser, cannot be marked private
  _priority = 0;
  _selectedFrame = 0;
  _requestedFrame = 0;
  _selectionDepth = 0;
  _touchedFrame = 0;
  _centerZDepth = 0;
  _shouldRefine = !1;
  _stackLength = 0;
  _visitedFrame = 0;
  _inRequestVolume = !1;
  _lodJudge = null;
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(e, t, i, n = "") {
    this.header = t, this.tileset = e, this.id = n || t.id, this.url = t.url, this.parent = i, this.refine = this._getRefine(t.refine), this.type = t.type, this.contentUrl = t.contentUrl, this._initializeLodMetric(t), this._initializeTransforms(t), this._initializeBoundingVolumes(t), this._initializeContent(t), this._initializeRenderingState(t), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === el.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === el.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === el.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === el.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = nY(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(e, t) {
    switch (this.tileset.type) {
      case Ea.I3S:
        return NM(this, e);
      case Ea.TILES3D:
        return hY(this, e, t);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const e = this.tileset._traverser, {
      skipLevelOfDetail: t
    } = e.options, i = this.refine === Tc.ADD || t;
    if (i && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === el.UNLOADED)
      return -1;
    const n = this.parent, c = n && (!i || this._screenSpaceError === 0 || n.hasTilesetContent) ? n._screenSpaceError : this._screenSpaceError, o = e.root ? e.root._screenSpaceError : 0;
    return Math.max(o - c, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = el.LOADING;
    const t = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!t)
      return this.contentState = el.UNLOADED, !1;
    try {
      const i = this.tileset.getTileUrl(this.contentUrl), n = this.tileset.loader, s = {
        ...this.tileset.loadOptions,
        [n.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[n.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(n.id)
        }
      };
      return this.content = await Wh(i, n, s), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = el.READY, this._onContentLoaded(), !0;
    } catch (i) {
      throw this.contentState = el.FAILED, i;
    } finally {
      t.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = el.UNLOADED, !0;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(e, t) {
    if (this._frameNumber === e.frameNumber)
      return;
    const i = this.parent, n = i ? i._visibilityPlaneMask : Ll.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const s = i ? i.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(s);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, n), this._visible = this._visibilityPlaneMask !== Ll.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = t;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(e, t) {
    const {
      cullingVolume: i
    } = e, {
      boundingVolume: n
    } = this;
    return i.computeVisibilityWithPlaneMask(n, t);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return !0;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(e) {
    const t = this.boundingVolume;
    return Math.sqrt(Math.max(t.distanceSquaredTo(e.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth({
    camera: e
  }) {
    const t = this.boundingVolume;
    return JS.subVectors(t.center, e.position), e.direction.dot(JS);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(e) {
    const t = this._viewerRequestVolume;
    return !t || t.distanceSquaredTo(e.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (mY(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = el.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new Pi(e.transform) : new Pi();
    const t = this.parent, i = this.tileset, n = t && t.computedTransform ? t.computedTransform.clone() : i.modelMatrix.clone();
    this.computedTransform = new Pi(n).multiplyRight(this.transform);
    const s = t && t._initialTransform ? t._initialTransform.clone() : new Pi();
    this._initialTransform = new Pi(s).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = {
      _tileset: this.tileset,
      _tile: this
    }, this.hasEmptyContent = !0, this.contentState = el.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = Ll.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || Tc.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = l1(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const t = e.content;
    t && (t.boundingVolume && (this._contentBoundingVolume = l1(t.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = l1(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(e = new Pi()) {
    const t = e.clone().multiplyRight(this.transform);
    t.equals(this.computedTransform) || (this.computedTransform = t, this._updateBoundingVolume(this.header));
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return pY(this.tileset.tileset);
    }
  }
}
class _Y extends l0 {
  compareDistanceToCamera(e, t) {
    return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, t) {
    if (super.updateTileVisibility(e, t), !e.isVisibleAndInRequestVolume)
      return;
    const i = e.children.length > 0;
    if (e.hasTilesetContent && i) {
      const c = e.children[0];
      this.updateTileVisibility(c, t), e._visible = c._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, t)) {
      e._visible = !1;
      return;
    }
    const n = e.refine === Tc.REPLACE, s = e._optimChildrenWithinParent === tY.USE_OPTIMIZATION;
    if (n && s && i && !this.anyChildrenVisible(e, t)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, t) {
    const {
      parent: i
    } = e;
    return !i || i.hasTilesetContent || i.refine !== Tc.ADD ? !1 : !this.shouldRefine(e, t, !0);
  }
}
class yY {
  frameNumberMap = /* @__PURE__ */ new Map();
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(e, t) {
    const i = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), n = i.get(t) || 0;
    i.set(t, n + 1), this.frameNumberMap.set(e, i);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(e, t) {
    const i = this.frameNumberMap.get(e);
    if (!i)
      return;
    const n = i.get(t) || 1;
    i.set(t, n - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(e, t) {
    return (this.frameNumberMap.get(e)?.get(t) || 0) === 0;
  }
}
const h1 = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class bY {
  _statusMap;
  pendingTilesRegister = new yY();
  constructor() {
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(e, t, i, n) {
    if (!this._statusMap[t]) {
      const {
        frameNumber: s,
        viewport: {
          id: c
        }
      } = n;
      this._statusMap[t] = {
        request: e,
        callback: i,
        key: t,
        frameState: n,
        status: h1.REQUESTED
      }, this.pendingTilesRegister.register(c, s), e().then((o) => {
        this._statusMap[t].status = h1.COMPLETED;
        const {
          frameNumber: d,
          viewport: {
            id: m
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, d), this._statusMap[t].callback(o, n);
      }).catch((o) => {
        this._statusMap[t].status = h1.ERROR;
        const {
          frameNumber: d,
          viewport: {
            id: m
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, d), i(o);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(e, t) {
    if (this._statusMap[e]) {
      const {
        frameNumber: i,
        viewport: {
          id: n
        }
      } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(n, i);
      const {
        frameNumber: s,
        viewport: {
          id: c
        }
      } = t;
      this.pendingTilesRegister.register(c, s), this._statusMap[e].frameState = t;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(e) {
    return this._statusMap[e];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(e, t) {
    return !this.pendingTilesRegister.isZero(e, t);
  }
}
class vY extends l0 {
  _tileManager;
  constructor(e) {
    super(e), this._tileManager = new bY();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(e) {
    return !this._tileManager.hasPendingTiles(e.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(e, t) {
    return e._lodJudge = dY(e, t), e._lodJudge === "DIG";
  }
  updateChildTiles(e, t) {
    const i = e.header.children || [], n = e.children, s = e.tileset;
    for (const c of i) {
      const o = `${c.id}-${t.viewport.id}`, d = n && n.find((m) => m.id === o);
      if (d)
        d && this.updateTile(d, t);
      else {
        let m = () => this._loadTile(c.id, s);
        this._tileManager.find(o) ? this._tileManager.update(o, t) : (s.tileset.nodePages && (m = () => s.tileset.nodePagesTile.formTileFromNodePages(c.id)), this._tileManager.add(m, o, (T) => this._onTileLoad(T, e, o), t));
      }
    }
    return !1;
  }
  async _loadTile(e, t) {
    const {
      loader: i
    } = t, n = t.getTileUrl(`${t.url}/nodes/${e}`), s = {
      ...t.loadOptions,
      i3s: {
        ...t.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await Wh(n, i, s);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(e, t, i) {
    const n = new Xv(t.tileset, e, t, i);
    t.children.push(n);
    const s = this._tileManager.find(n.id).frameState;
    this.updateTile(n, s), this._frameNumber === s.frameNumber && (this.traversalFinished(s) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(n, s);
  }
}
const xY = {
  description: "",
  ellipsoid: Tn.WGS84,
  modelMatrix: new Pi(),
  throttleRequests: !0,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (r) => r,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: !1,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: {
    fetch: {}
  },
  attributions: [],
  basePath: "",
  i3s: {}
}, x_ = "Tiles In Tileset(s)", f1 = "Tiles In Memory", KS = "Tiles In View", QS = "Tiles To Render", eE = "Tiles Loaded", d1 = "Tiles Loading", tE = "Tiles Unloaded", rE = "Failed Tile Loads", iE = "Points/Vertices", p1 = "Tile Memory Use", nE = "Maximum Screen Space Error";
class wY {
  // props: Tileset3DProps;
  options;
  loadOptions;
  type;
  tileset;
  loader;
  url;
  basePath;
  modelMatrix;
  ellipsoid;
  lodMetricType;
  lodMetricValue;
  refine;
  root = null;
  roots = {};
  /** @todo any->unknown */
  asset = {};
  // Metadata for the entire tileset
  description = "";
  properties;
  extras = null;
  attributions = {};
  credits = {};
  stats;
  /** flags that contain information about data types in nested tiles */
  contentFormats = {
    draco: !1,
    meshopt: !1,
    dds: !1,
    ktx2: !1
  };
  // view props
  cartographicCenter = null;
  cartesianCenter = null;
  zoom = 1;
  boundingVolume = null;
  /** Updated based on the camera position and direction */
  dynamicScreenSpaceErrorComputedDensity = 0;
  // METRICS
  /**
   * The maximum amount of GPU memory (in MB) that may be used to cache tiles
   * Tiles not in view are unloaded to enforce private
   */
  maximumMemoryUsage = 32;
  /** The total amount of GPU memory in bytes used by the tileset. */
  gpuMemoryUsageInBytes = 0;
  /**
   * If loading the level of detail required by maximumScreenSpaceError
   * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
   * will instead use this (larger) adjusted screen space error to achieve the
   * best possible visual quality within the available memory.
   */
  memoryAdjustedScreenSpaceError = 0;
  _cacheBytes = 0;
  _cacheOverflowBytes = 0;
  /** Update tracker. increase in each update cycle. */
  _frameNumber = 0;
  _queryParams = {};
  _extensionsUsed = [];
  _tiles = {};
  /** counter for tracking tiles requests */
  _pendingCount = 0;
  /** Hold traversal results */
  selectedTiles = [];
  // TRAVERSAL
  traverseCounter = 0;
  geometricError = 0;
  lastUpdatedVieports = null;
  _requestedTiles = [];
  _emptyTiles = [];
  frameStateData = {};
  _traverser;
  _cache = new HZ();
  _requestScheduler;
  // Promise tracking
  updatePromise = null;
  tilesetInitializationPromise;
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(e, t) {
    this.options = {
      ...xY,
      ...t
    }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || VZ(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new jZ({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new kp({
      id: this.url
    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(e) {
    if (e.startsWith("data:"))
      return e;
    let i = e;
    return this.queryParams.length && (i = `${e}${e.includes("?") ? "&" : "?"}${this.queryParams}`), i;
  }
  // TODO CESIUM specific
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update(e = null) {
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles(e = null) {
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((t) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), t(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  adjustScreenSpaceError() {
    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const t = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = t.length;
    const i = [];
    for (const n of t) {
      const s = n.id;
      this._needTraverse(s) ? i.push(s) : this.traverseCounter--;
    }
    for (const n of t) {
      const s = n.id;
      if (this.roots[s] || (this.roots[s] = this._initializeTileHeaders(this.tileset, null)), !i.includes(s))
        continue;
      const c = WZ(n, this._frameNumber);
      this._traverser.traverse(this.roots[s], c, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(e) {
    let t = e;
    return this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(e) {
    const t = e.viewport.id;
    this.frameStateData[t] || (this.frameStateData[t] = {
      selectedTiles: [],
      _requestedTiles: [],
      _emptyTiles: []
    });
    const i = this.frameStateData[t], n = Object.values(this._traverser.selectedTiles), [s, c] = XZ(n, e, this.options.maximumTilesSelected);
    i.selectedTiles = s;
    for (const o of c)
      o.unselect();
    i._requestedTiles = Object.values(this._traverser.requestedTiles), i._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const t = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(t.selectedTiles), this._requestedTiles = this._requestedTiles.concat(t._requestedTiles), this._emptyTiles = this._emptyTiles.concat(t._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, t) {
    if (e.length !== t.length)
      return !0;
    const i = new Set(e.map((c) => c.id)), n = new Set(t.map((c) => c.id));
    let s = e.filter((c) => !n.has(c.id)).length > 0;
    return s = s || t.filter((c) => !i.has(c.id)).length > 0, s;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
  }
  _updateStats() {
    let e = 0, t = 0;
    for (const i of this.selectedTiles)
      i.contentAvailable && i.content && (e++, i.content.pointCount ? t += i.content.pointCount : t += i.content.vertexCount);
    this.stats.get(KS).count = this.selectedTiles.length, this.stats.get(QS).count = e, this.stats.get(iE).count = t, this.stats.get(nE).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(e) {
    this.type === Ea.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === Ea.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === Ea.I3S && this._initializeI3STileset();
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    const e = this.tileset.fullExtent;
    if (e) {
      const {
        xmin: i,
        xmax: n,
        ymin: s,
        ymax: c,
        zmin: o,
        zmax: d
      } = e;
      this.cartographicCenter = new xt(i + (n - i) / 2, s + (c - s) / 2, o + (d - o) / 2), this.cartesianCenter = new xt(), Tn.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = LM(e, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const t = this.tileset.store?.extent;
    if (t) {
      const [i, n, s, c] = t;
      this.cartographicCenter = new xt(i + (s - i) / 2, n + (c - n) / 2, 0), this.cartesianCenter = new xt(), Tn.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = QZ(t, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new xt(), this.zoom = 1;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const e = this.root, {
      center: t
    } = e.boundingVolume;
    if (!t) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new xt(), this.zoom = 1;
      return;
    }
    t[0] !== 0 || t[1] !== 0 || t[2] !== 0 ? (this.cartographicCenter = new xt(), Tn.WGS84.cartesianToCartographic(t, this.cartographicCenter)) : this.cartographicCenter = new xt(0, 0, -Tn.WGS84.radii[0]), this.cartesianCenter = t, this.zoom = KZ(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(x_), this.stats.get(d1), this.stats.get(f1), this.stats.get(KS), this.stats.get(QS), this.stats.get(eE), this.stats.get(tE), this.stats.get(rE), this.stats.get(iE), this.stats.get(p1, "memory"), this.stats.get(nE);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(e, t) {
    const i = new Xv(this, e.root, t);
    if (t && (t.children.push(i), i.depth = t.depth + 1), this.type === Ea.TILES3D) {
      const n = [];
      for (n.push(i); n.length > 0; ) {
        const s = n.pop();
        this.stats.get(x_).incrementCount();
        const c = s.header.children || [];
        for (const o of c) {
          const d = new Xv(this, o, s);
          if (d.contentUrl?.includes("?session=")) {
            const y = new URL(d.contentUrl).searchParams.get("session");
            y && (this._queryParams.session = y);
          }
          s.children.push(d), d.depth = s.depth + 1, n.push(d);
        }
      }
    }
    return i;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case Ea.TILES3D:
        e = _Y;
        break;
      case Ea.I3S:
        e = vY;
        break;
      default:
        e = l0;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let t;
    try {
      this._onStartTileLoading(), t = await e.loadContent();
    } catch (i) {
      this._onTileLoadError(e, i instanceof Error ? i : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, t);
    }
  }
  _onTileLoadError(e, t) {
    this.stats.get(rE).incrementCount();
    const i = t.message || t.toString(), n = e.url;
    console.error(`A 3D tile failed to load: ${e.url} ${i}`), this.options.onTileError(e, i, n);
  }
  _onTileLoad(e, t) {
    if (t) {
      if (this.type === Ea.I3S) {
        const i = this.tileset?.nodePagesTile?.nodesInNodePages || 0;
        this.stats.get(x_).reset(), this.stats.get(x_).addCount(i);
      }
      e && e.content && qZ(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(e) {
    if (this.type === Ea.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === Ea.TILES3D) {
      const {
        extensionsRemoved: t = []
      } = e.content?.gltf || {};
      t.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), t.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), t.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(d1).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(d1).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (t) => t._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(eE).incrementCount(), this.stats.get(f1).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(p1).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(f1).decrementCount(), this.stats.get(tE).incrementCount(), this.stats.get(p1).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const t = e.pop();
      for (const i of t.children)
        e.push(i);
      this._destroyTile(t);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(e) {
    const t = e, i = [];
    for (i.push(t); i.length > 0; ) {
      e = i.pop();
      for (const n of e.children)
        i.push(n);
      e !== t && this._destroyTile(e);
    }
    t.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const t = new URLSearchParams(e.queryString), i = Object.fromEntries(t.entries());
      this._queryParams = {
        ...this._queryParams,
        ...i
      };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1")
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
async function jx(r, e, t, i) {
  return i._parse(r, e, t, i);
}
function mc(r, e) {
  if (!r)
    throw new Error(e || "loader assertion failed.");
}
function AY(r, e, t) {
  const i = t !== void 0 ? new Uint8Array(r).subarray(e, e + t) : new Uint8Array(r).subarray(e);
  return new Uint8Array(i).buffer;
}
function TY() {
  if (typeof process < "u" && typeof process.cwd < "u")
    return process.cwd();
  const r = window.location?.pathname;
  return r?.slice(0, r.lastIndexOf("/") + 1) || "";
}
function SY(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(0, e) : "";
}
function EY(...r) {
  const e = [];
  for (let s = 0; s < r.length; s++)
    e[s] = r[s];
  let t = "", i = !1, n;
  for (let s = e.length - 1; s >= -1 && !i; s--) {
    let c;
    s >= 0 ? c = e[s] : (n === void 0 && (n = TY()), c = n), c.length !== 0 && (t = `${c}/${t}`, i = c.charCodeAt(0) === Ig);
  }
  return t = CY(t, !i), i ? `/${t}` : t.length > 0 ? t : ".";
}
const Ig = 47, g1 = 46;
function CY(r, e) {
  let t = "", i = -1, n = 0, s, c = !1;
  for (let o = 0; o <= r.length; ++o) {
    if (o < r.length)
      s = r.charCodeAt(o);
    else {
      if (s === Ig)
        break;
      s = Ig;
    }
    if (s === Ig) {
      if (!(i === o - 1 || n === 1)) if (i !== o - 1 && n === 2) {
        if (t.length < 2 || !c || t.charCodeAt(t.length - 1) !== g1 || t.charCodeAt(t.length - 2) !== g1) {
          if (t.length > 2) {
            const d = t.length - 1;
            let m = d;
            for (; m >= 0 && t.charCodeAt(m) !== Ig; --m)
              ;
            if (m !== d) {
              t = m === -1 ? "" : t.slice(0, m), i = o, n = 0, c = !1;
              continue;
            }
          } else if (t.length === 2 || t.length === 1) {
            t = "", i = o, n = 0, c = !1;
            continue;
          }
        }
        e && (t.length > 0 ? t += "/.." : t = "..", c = !0);
      } else {
        const d = r.slice(i + 1, o);
        t.length > 0 ? t += `/${d}` : t = d, c = !1;
      }
      i = o, n = 0;
    } else s === g1 && n !== -1 ? ++n : n = -1;
  }
  return t;
}
const FM = "4.3.3", mg = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GLTF: "glTF"
};
function UM(r, e, t) {
  mc(r instanceof ArrayBuffer);
  const i = new TextDecoder("utf8"), n = new Uint8Array(r, e, t);
  return i.decode(n);
}
function IY(r, e = 0) {
  const t = new DataView(r);
  return `${String.fromCharCode(t.getUint8(e + 0))}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(t.getUint8(e + 2))}${String.fromCharCode(t.getUint8(e + 3))}`;
}
const PY = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
}, Ns = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, zi = {
  ...PY,
  ...Ns
}, m1 = {
  [Ns.DOUBLE]: Float64Array,
  [Ns.FLOAT]: Float32Array,
  [Ns.UNSIGNED_SHORT]: Uint16Array,
  [Ns.UNSIGNED_INT]: Uint32Array,
  [Ns.UNSIGNED_BYTE]: Uint8Array,
  [Ns.BYTE]: Int8Array,
  [Ns.SHORT]: Int16Array,
  [Ns.INT]: Int32Array
}, MY = {
  DOUBLE: Ns.DOUBLE,
  FLOAT: Ns.FLOAT,
  UNSIGNED_SHORT: Ns.UNSIGNED_SHORT,
  UNSIGNED_INT: Ns.UNSIGNED_INT,
  UNSIGNED_BYTE: Ns.UNSIGNED_BYTE,
  BYTE: Ns.BYTE,
  SHORT: Ns.SHORT,
  INT: Ns.INT
}, _1 = "Failed to convert GL type";
class vu {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const t in m1)
      if (m1[t] === e)
        return t;
    throw new Error(_1);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(e) {
    const t = MY[e];
    if (!t)
      throw new Error(_1);
    return t;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(e) {
    switch (e) {
      /*eslint-disable*/
      // @ts-ignore
      case Ns.UNSIGNED_SHORT_5_6_5:
      // @ts-ignore
      case Ns.UNSIGNED_SHORT_4_4_4_4:
      // @ts-ignore
      case Ns.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const t = m1[e];
        if (!t)
          throw new Error(_1);
        return t;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(e) {
    return vu.getArrayType(e).BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(e) {
    return !!vu.getArrayType(e);
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(e, t, i = 0, n) {
    n === void 0 && (n = (t.byteLength - i) / vu.getByteSize(e));
    const s = vu.getArrayType(e);
    return new s(t, i, n);
  }
}
function RY(r, e) {
  if (!r)
    throw new Error(`math.gl assertion failed. ${e}`);
}
function LY(r, e = [0, 0, 0]) {
  const t = r >> 11 & 31, i = r >> 5 & 63, n = r & 31;
  return e[0] = t << 3, e[1] = i << 2, e[2] = n << 3, e;
}
new J2();
new xt();
new J2();
new J2();
function sE(r, e = 255) {
  return vc(r, 0, e) / e * 2 - 1;
}
function oE(r) {
  return r < 0 ? -1 : 1;
}
function BY(r, e, t, i) {
  if (RY(i), r < 0 || r > t || e < 0 || e > t)
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${t}`);
  if (i.x = sE(r, t), i.y = sE(e, t), i.z = 1 - (Math.abs(i.x) + Math.abs(i.y)), i.z < 0) {
    const n = i.x;
    i.x = (1 - Math.abs(i.y)) * oE(n), i.y = (1 - Math.abs(n)) * oE(i.y);
  }
  return i.normalize();
}
function kY(r, e, t) {
  return BY(r, e, 255, t);
}
class Vx {
  json;
  buffer;
  featuresLength = 0;
  _cachedTypedArrays = {};
  constructor(e, t) {
    this.json = e, this.buffer = t;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e, t = zi.UNSIGNED_INT, i = 1) {
    const n = this.json[e];
    return n && Number.isFinite(n.byteOffset) ? this._getTypedArrayFromBinary(e, t, i, 1, n.byteOffset) : n;
  }
  getPropertyArray(e, t, i) {
    const n = this.json[e];
    return n && Number.isFinite(n.byteOffset) ? ("componentType" in n && (t = vu.fromName(n.componentType)), this._getTypedArrayFromBinary(e, t, i, this.featuresLength, n.byteOffset)) : this._getTypedArrayFromArray(e, t, n);
  }
  getProperty(e, t, i, n, s) {
    const c = this.json[e];
    if (!c)
      return c;
    const o = this.getPropertyArray(e, t, i);
    if (i === 1)
      return o[n];
    for (let d = 0; d < i; ++d)
      s[d] = o[i * n + d];
    return s;
  }
  // HELPERS
  _getTypedArrayFromBinary(e, t, i, n, s) {
    const c = this._cachedTypedArrays;
    let o = c[e];
    return o || (o = vu.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + s, n * i), c[e] = o), o;
  }
  _getTypedArrayFromArray(e, t, i) {
    const n = this._cachedTypedArrays;
    let s = n[e];
    return s || (s = vu.createTypedArray(t, i), n[e] = s), s;
  }
}
const OY = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, DY = {
  SCALAR: (r, e) => r[e],
  VEC2: (r, e) => [r[2 * e + 0], r[2 * e + 1]],
  VEC3: (r, e) => [r[3 * e + 0], r[3 * e + 1], r[3 * e + 2]],
  VEC4: (r, e) => [r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]],
  // TODO: check column major
  MAT2: (r, e) => [r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]],
  MAT3: (r, e) => [r[9 * e + 0], r[9 * e + 1], r[9 * e + 2], r[9 * e + 3], r[9 * e + 4], r[9 * e + 5], r[9 * e + 6], r[9 * e + 7], r[9 * e + 8]],
  MAT4: (r, e) => [r[16 * e + 0], r[16 * e + 1], r[16 * e + 2], r[16 * e + 3], r[16 * e + 4], r[16 * e + 5], r[16 * e + 6], r[16 * e + 7], r[16 * e + 8], r[16 * e + 9], r[16 * e + 10], r[16 * e + 11], r[16 * e + 12], r[16 * e + 13], r[16 * e + 14], r[16 * e + 15]]
}, NY = {
  SCALAR: (r, e, t) => {
    e[t] = r;
  },
  VEC2: (r, e, t) => {
    e[2 * t + 0] = r[0], e[2 * t + 1] = r[1];
  },
  VEC3: (r, e, t) => {
    e[3 * t + 0] = r[0], e[3 * t + 1] = r[1], e[3 * t + 2] = r[2];
  },
  VEC4: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  // TODO: check column major correctness
  MAT2: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  MAT3: (r, e, t) => {
    e[9 * t + 0] = r[0], e[9 * t + 1] = r[1], e[9 * t + 2] = r[2], e[9 * t + 3] = r[3], e[9 * t + 4] = r[4], e[9 * t + 5] = r[5], e[9 * t + 6] = r[6], e[9 * t + 7] = r[7], e[9 * t + 8] = r[8], e[9 * t + 9] = r[9];
  },
  MAT4: (r, e, t) => {
    e[16 * t + 0] = r[0], e[16 * t + 1] = r[1], e[16 * t + 2] = r[2], e[16 * t + 3] = r[3], e[16 * t + 4] = r[4], e[16 * t + 5] = r[5], e[16 * t + 6] = r[6], e[16 * t + 7] = r[7], e[16 * t + 8] = r[8], e[16 * t + 9] = r[9], e[16 * t + 10] = r[10], e[16 * t + 11] = r[11], e[16 * t + 12] = r[12], e[16 * t + 13] = r[13], e[16 * t + 14] = r[14], e[16 * t + 15] = r[15];
  }
};
function FY(r, e, t, i) {
  const {
    componentType: n
  } = r;
  mc(r.componentType);
  const s = typeof n == "string" ? vu.fromName(n) : n, c = OY[r.type], o = DY[r.type], d = NY[r.type];
  return t += r.byteOffset, {
    values: vu.createTypedArray(s, e, t, c * i),
    type: s,
    size: c,
    unpacker: o,
    packer: d
  };
}
const yu = (r) => r !== void 0;
function UY(r, e, t) {
  if (!e)
    return null;
  let i = r.getExtension("3DTILES_batch_table_hierarchy");
  const n = e.HIERARCHY;
  return n && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = n, i = n), i ? zY(i, t) : null;
}
function zY(r, e) {
  let t, i, n;
  const s = r.instancesLength, c = r.classes;
  let o = r.classIds, d = r.parentCounts, m = r.parentIds, y = s;
  yu(o.byteOffset) && (o.componentType = defaultValue(o.componentType, GL.UNSIGNED_SHORT), o.type = AttributeType.SCALAR, n = getBinaryAccessor(o), o = n.createArrayBufferView(e.buffer, e.byteOffset + o.byteOffset, s));
  let T;
  if (yu(d))
    for (yu(d.byteOffset) && (d.componentType = defaultValue(d.componentType, GL.UNSIGNED_SHORT), d.type = AttributeType.SCALAR, n = getBinaryAccessor(d), d = n.createArrayBufferView(e.buffer, e.byteOffset + d.byteOffset, s)), T = new Uint16Array(s), y = 0, t = 0; t < s; ++t)
      T[t] = y, y += d[t];
  yu(m) && yu(m.byteOffset) && (m.componentType = defaultValue(m.componentType, GL.UNSIGNED_SHORT), m.type = AttributeType.SCALAR, n = getBinaryAccessor(m), m = n.createArrayBufferView(e.buffer, e.byteOffset + m.byteOffset, y));
  const P = c.length;
  for (t = 0; t < P; ++t) {
    const $ = c[t].length, G = c[t].instances, te = getBinaryProperties($, G, e);
    c[t].instances = combine(te, G);
  }
  const I = new Array(P).fill(0), D = new Uint16Array(s);
  for (t = 0; t < s; ++t)
    i = o[t], D[t] = I[i], ++I[i];
  const k = {
    classes: c,
    classIds: o,
    classIndexes: D,
    parentCounts: d,
    parentIndexes: T,
    parentIds: m
  };
  return GY(k), k;
}
function _g(r, e, t) {
  if (!r)
    return;
  const i = r.parentCounts;
  return r.parentIds ? t(r, e) : i > 0 ? jY(r, e, t) : VY(r, e, t);
}
function jY(r, e, t) {
  const i = r.classIds, n = r.parentCounts, s = r.parentIds, c = r.parentIndexes, o = i.length, d = scratchVisited;
  d.length = Math.max(d.length, o);
  const m = ++marker, y = scratchStack;
  for (y.length = 0, y.push(e); y.length > 0; ) {
    if (e = y.pop(), d[e] === m)
      continue;
    d[e] = m;
    const T = t(r, e);
    if (yu(T))
      return T;
    const P = n[e], I = c[e];
    for (let D = 0; D < P; ++D) {
      const k = s[I + D];
      k !== e && y.push(k);
    }
  }
  return null;
}
function VY(r, e, t) {
  let i = !0;
  for (; i; ) {
    const n = t(r, e);
    if (yu(n))
      return n;
    const s = r.parentIds[e];
    i = s !== e, e = s;
  }
  throw new Error("traverseHierarchySingleParent");
}
function GY(r) {
  const t = r.classIds.length;
  for (let i = 0; i < t; ++i)
    zM(r, i, stack);
}
function zM(r, e, t) {
  const i = r.parentCounts, n = r.parentIds, s = r.parentIndexes, o = r.classIds.length;
  if (!yu(n))
    return;
  assert(e < o, `Parent index ${e} exceeds the total number of instances: ${o}`), assert(t.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), t.push(e);
  const d = yu(i) ? i[e] : 1, m = yu(i) ? s[e] : e;
  for (let y = 0; y < d; ++y) {
    const T = n[m + y];
    T !== e && zM(r, T, t);
  }
  t.pop(e);
}
function Ta(r) {
  return r != null;
}
const w_ = (r, e) => r, $Y = {
  HIERARCHY: !0,
  // Deprecated HIERARCHY property
  extensions: !0,
  extras: !0
};
class jM {
  json;
  binary;
  featureCount;
  _extensions;
  // Copy all top-level property fields from the json object, ignoring special fields
  _properties;
  _binaryProperties;
  // TODO: hierarchy support is only partially implemented and not tested
  _hierarchy;
  constructor(e, t, i, n = {}) {
    mc(i >= 0), this.json = e || {}, this.binary = t, this.featureCount = i, this._extensions = this.json?.extensions || {}, this._properties = {};
    for (const s in this.json)
      $Y[s] || (this._properties[s] = this.json[s]);
    this._binaryProperties = this._initializeBinaryProperties(), n["3DTILES_batch_table_hierarchy"] && (this._hierarchy = UY(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, t) {
    if (this._checkBatchId(e), mc(typeof t == "string", t), this._hierarchy) {
      const i = _g(this._hierarchy, e, (n, s) => {
        const c = n.classIds[s];
        return n.classes[c].name === t;
      });
      return Ta(i);
    }
    return !1;
  }
  isExactClass(e, t) {
    return mc(typeof t == "string", t), this.getExactClassName(e) === t;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const t = this._hierarchy.classIds[e];
      return this._hierarchy.classes[t].name;
    }
  }
  hasProperty(e, t) {
    return this._checkBatchId(e), mc(typeof t == "string", t), Ta(this._properties[t]) || this._hasPropertyInHierarchy(e, t);
  }
  getPropertyNames(e, t) {
    this._checkBatchId(e), t = Ta(t) ? t : [], t.length = 0;
    const i = Object.keys(this._properties);
    return t.push(...i), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
  }
  getProperty(e, t) {
    if (this._checkBatchId(e), mc(typeof t == "string", t), this._binaryProperties) {
      const n = this._binaryProperties[t];
      if (Ta(n))
        return this._getBinaryProperty(n, e);
    }
    const i = this._properties[t];
    if (Ta(i))
      return w_(i[e]);
    if (this._hierarchy) {
      const n = this._getHierarchyProperty(e, t);
      if (Ta(n))
        return n;
    }
  }
  setProperty(e, t, i) {
    const n = this.featureCount;
    if (this._checkBatchId(e), mc(typeof t == "string", t), this._binaryProperties) {
      const c = this._binaryProperties[t];
      if (c) {
        this._setBinaryProperty(c, e, i);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, t, i))
      return;
    let s = this._properties[t];
    Ta(s) || (this._properties[t] = new Array(n), s = this._properties[t]), s[e] = w_(i);
  }
  // PRIVATE METHODS
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, t) {
    return e.unpack(e.typedArray, t);
  }
  _setBinaryProperty(e, t, i) {
    e.pack(i, e.typedArray, t);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const t in this._properties) {
      const i = this._properties[t], n = this._initializeBinaryProperty(t, i);
      n && (e = e || {}, e[t] = n);
    }
    return e;
  }
  _initializeBinaryProperty(e, t) {
    if ("byteOffset" in t) {
      const i = t;
      mc(this.binary, `Property ${e} requires a batch table binary.`), mc(i.type, `Property ${e} requires a type.`);
      const n = FY(i, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: n.values,
        componentCount: n.size,
        unpack: n.unpacker,
        pack: n.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(e, t) {
    if (!this._hierarchy)
      return !1;
    const i = _g(this._hierarchy, e, (n, s) => {
      const c = n.classIds[s], o = n.classes[c].instances;
      return Ta(o[t]);
    });
    return Ta(i);
  }
  _getPropertyNamesInHierarchy(e, t) {
    _g(this._hierarchy, e, (i, n) => {
      const s = i.classIds[n], c = i.classes[s].instances;
      for (const o in c)
        c.hasOwnProperty(o) && t.indexOf(o) === -1 && t.push(o);
    });
  }
  _getHierarchyProperty(e, t) {
    return _g(this._hierarchy, e, (i, n) => {
      const s = i.classIds[n], c = i.classes[s], o = i.classIndexes[n], d = c.instances[t];
      return Ta(d) ? Ta(d.typedArray) ? this._getBinaryProperty(d, o) : w_(d[o]) : null;
    });
  }
  _setHierarchyProperty(e, t, i, n) {
    const s = _g(this._hierarchy, t, (c, o) => {
      const d = c.classIds[o], m = c.classes[d], y = c.classIndexes[o], T = m.instances[i];
      return Ta(T) ? (mc(o === t, `Inherited property "${i}" is read-only.`), Ta(T.typedArray) ? this._setBinaryProperty(T, y, n) : T[y] = w_(n), !0) : !1;
    });
    return Ta(s);
  }
}
const y1 = 4;
function c0(r, e, t = 0) {
  const i = new DataView(e);
  if (r.magic = i.getUint32(t, !0), t += y1, r.version = i.getUint32(t, !0), t += y1, r.byteLength = i.getUint32(t, !0), t += y1, r.version !== 1)
    throw new Error(`3D Tile Version ${r.version} not supported`);
  return t;
}
const Hd = 4, aE = "b3dm tile in legacy format.";
function Gx(r, e, t) {
  const i = new DataView(e);
  let n;
  r.header = r.header || {};
  let s = i.getUint32(t, !0);
  t += Hd;
  let c = i.getUint32(t, !0);
  t += Hd;
  let o = i.getUint32(t, !0);
  t += Hd;
  let d = i.getUint32(t, !0);
  return t += Hd, o >= 570425344 ? (t -= Hd * 2, n = s, o = c, d = 0, s = 0, c = 0, console.warn(aE)) : d >= 570425344 && (t -= Hd, n = o, o = s, d = c, s = 0, c = 0, console.warn(aE)), r.header.featureTableJsonByteLength = s, r.header.featureTableBinaryByteLength = c, r.header.batchTableJsonByteLength = o, r.header.batchTableBinaryByteLength = d, r.header.batchLength = n, t;
}
function $x(r, e, t, i) {
  return t = HY(r, e, t), t = qY(r, e, t), t;
}
function HY(r, e, t, i) {
  const {
    featureTableJsonByteLength: n,
    featureTableBinaryByteLength: s,
    batchLength: c
  } = r.header || {};
  if (r.featureTableJson = {
    BATCH_LENGTH: c || 0
  }, n && n > 0) {
    const o = UM(e, t, n);
    r.featureTableJson = JSON.parse(o);
  }
  return t += n || 0, r.featureTableBinary = new Uint8Array(e, t, s), t += s || 0, t;
}
function qY(r, e, t, i) {
  const {
    batchTableJsonByteLength: n,
    batchTableBinaryByteLength: s
  } = r.header || {};
  if (n && n > 0) {
    const c = UM(e, t, n);
    r.batchTableJson = JSON.parse(c), t += n, s && s > 0 && (r.batchTableBinary = new Uint8Array(e, t, s), r.batchTableBinary = new Uint8Array(r.batchTableBinary), t += s);
  }
  return t;
}
function VM(r, e, t) {
  if (!e && (!r || !r.batchIds || !t))
    return null;
  const {
    batchIds: i,
    isRGB565: n,
    pointCount: s = 0
  } = r;
  if (i && t) {
    const c = new Uint8ClampedArray(s * 3);
    for (let o = 0; o < s; o++) {
      const d = i[o], y = t.getProperty(d, "dimensions").map((T) => T * 255);
      c[o * 3] = y[0], c[o * 3 + 1] = y[1], c[o * 3 + 2] = y[2];
    }
    return {
      type: zi.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  if (e && n) {
    const c = new Uint8ClampedArray(s * 3);
    for (let o = 0; o < s; o++) {
      const d = LY(e[o]);
      c[o * 3] = d[0], c[o * 3 + 1] = d[1], c[o * 3 + 2] = d[2];
    }
    return {
      type: zi.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === s * 3 ? {
    type: zi.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: zi.UNSIGNED_BYTE,
    value: e || new Uint8ClampedArray(),
    size: 4,
    normalized: !0
  };
}
const lE = new xt();
function WY(r, e) {
  if (!e)
    return null;
  if (r.isOctEncoded16P) {
    const t = new Float32Array((r.pointsLength || 0) * 3);
    for (let i = 0; i < (r.pointsLength || 0); i++)
      kY(e[i * 2], e[i * 2 + 1], lE), lE.toArray(t, i * 3);
    return {
      type: zi.FLOAT,
      size: 2,
      value: t
    };
  }
  return {
    type: zi.FLOAT,
    size: 2,
    value: e
  };
}
function XY(r, e, t) {
  return r.isQuantized ? t["3d-tiles"] && t["3d-tiles"].decodeQuantizedPositions ? (r.isQuantized = !1, ZY(r, e)) : {
    type: zi.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function ZY(r, e) {
  const t = new xt(), i = new Float32Array(r.pointCount * 3);
  for (let n = 0; n < r.pointCount; n++)
    t.set(e[n * 3], e[n * 3 + 1], e[n * 3 + 2]).scale(1 / r.quantizedRange).multiply(r.quantizedVolumeScale).add(r.quantizedVolumeOffset).toArray(i, n * 3);
  return i;
}
async function YY(r, e, t, i, n) {
  t = c0(r, e, t), t = Gx(r, e, t), t = $x(r, e, t), JY(r);
  const {
    featureTable: s,
    batchTable: c
  } = KY(r);
  return await iJ(r, s, c, i, n), QY(r, s, i), eJ(r, s, c), tJ(r, s), t;
}
function JY(r) {
  r.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, r.isQuantized = !1, r.isTranslucent = !1, r.isRGB565 = !1, r.isOctEncoded16P = !1;
}
function KY(r) {
  const e = new Vx(r.featureTableJson, r.featureTableBinary), t = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(t))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = t, r.featuresLength = t, r.pointsLength = t, r.pointCount = t, r.rtcCenter = e.getGlobalProperty("RTC_CENTER", zi.FLOAT, 3);
  const i = rJ(r, e);
  return {
    featureTable: e,
    batchTable: i
  };
}
function QY(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.positions) {
    if (e.hasProperty("POSITION"))
      r.attributes.positions = e.getPropertyArray("POSITION", zi.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const i = e.getPropertyArray("POSITION_QUANTIZED", zi.UNSIGNED_SHORT, 3);
      if (r.isQuantized = !0, r.quantizedRange = 65535, r.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", zi.FLOAT, 3), !r.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (r.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", zi.FLOAT, 3), !r.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      r.attributes.positions = XY(r, i, t);
    }
  }
  if (!r.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function eJ(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.colors) {
    let i = null;
    e.hasProperty("RGBA") ? (i = e.getPropertyArray("RGBA", zi.UNSIGNED_BYTE, 4), r.isTranslucent = !0) : e.hasProperty("RGB") ? i = e.getPropertyArray("RGB", zi.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (i = e.getPropertyArray("RGB565", zi.UNSIGNED_SHORT, 1), r.isRGB565 = !0), r.attributes.colors = VM(r, i, t);
  }
  e.hasProperty("CONSTANT_RGBA") && (r.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", zi.UNSIGNED_BYTE, 4));
}
function tJ(r, e) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.normals) {
    let t = null;
    e.hasProperty("NORMAL") ? t = e.getPropertyArray("NORMAL", zi.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (t = e.getPropertyArray("NORMAL_OCT16P", zi.UNSIGNED_BYTE, 2), r.isOctEncoded16P = !0), r.attributes.normals = WY(r, t);
  }
}
function rJ(r, e) {
  let t = null;
  if (!r.batchIds && e.hasProperty("BATCH_ID") && (r.batchIds = e.getPropertyArray("BATCH_ID", zi.UNSIGNED_SHORT, 1), r.batchIds)) {
    const i = e.getGlobalProperty("BATCH_LENGTH");
    if (!i)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const {
      batchTableJson: n,
      batchTableBinary: s
    } = r;
    t = new jM(n, s, i);
  }
  return t;
}
async function iJ(r, e, t, i, n) {
  let s, c, o;
  const d = r.batchTableJson && r.batchTableJson.extensions && r.batchTableJson.extensions["3DTILES_draco_point_compression"];
  d && (o = d.properties);
  const m = e.getExtension("3DTILES_draco_point_compression");
  if (m) {
    c = m.properties;
    const T = m.byteOffset, P = m.byteLength;
    if (!c || !Number.isFinite(T) || !P)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    s = (r.featureTableBinary || []).slice(T, T + P), r.hasPositions = Number.isFinite(c.POSITION), r.hasColors = Number.isFinite(c.RGB) || Number.isFinite(c.RGBA), r.hasNormals = Number.isFinite(c.NORMAL), r.hasBatchIds = Number.isFinite(c.BATCH_ID), r.isTranslucent = Number.isFinite(c.RGBA);
  }
  if (!s)
    return !0;
  const y = {
    buffer: s,
    properties: {
      ...c,
      ...o
    },
    batchTableProperties: o
  };
  return await nJ(r, y, i, n);
}
async function nJ(r, e, t, i) {
  if (!i)
    return;
  const n = {
    ...t,
    draco: {
      ...t?.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete n["3d-tiles"];
  const s = await jx(e.buffer, EM, n, i), c = s.attributes.POSITION && s.attributes.POSITION.value, o = s.attributes.COLOR_0 && s.attributes.COLOR_0.value, d = s.attributes.NORMAL && s.attributes.NORMAL.value, m = s.attributes.BATCH_ID && s.attributes.BATCH_ID.value, y = c && s.attributes.POSITION.value.quantization, T = d && s.attributes.NORMAL.value.quantization;
  if (y) {
    const I = s.POSITION.data.quantization, D = I.range;
    r.quantizedVolumeScale = new xt(D, D, D), r.quantizedVolumeOffset = new xt(I.minValues), r.quantizedRange = (1 << I.quantizationBits) - 1, r.isQuantizedDraco = !0;
  }
  T && (r.octEncodedRange = (1 << s.NORMAL.data.quantization.quantizationBits) - 1, r.isOctEncodedDraco = !0);
  const P = {};
  if (e.batchTableProperties)
    for (const I of Object.keys(e.batchTableProperties))
      s.attributes[I] && s.attributes[I].value && (P[I.toLowerCase()] = s.attributes[I].value);
  r.attributes = {
    // @ts-expect-error
    positions: c,
    // @ts-expect-error
    colors: VM(r, o, void 0),
    // @ts-expect-error
    normals: d,
    // @ts-expect-error
    batchIds: m,
    ...P
  };
}
const Zv = {
  URI: 0,
  EMBEDDED: 1
};
function GM(r, e, t, i) {
  r.rotateYtoZ = !0;
  const n = (r.byteOffset || 0) + (r.byteLength || 0) - t;
  if (n === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return r.gltfUpAxis = i?.["3d-tiles"] && i["3d-tiles"].assetGltfUpAxis ? i["3d-tiles"].assetGltfUpAxis : "Y", r.gltfArrayBuffer = AY(e, t, n), r.gltfByteOffset = 0, r.gltfByteLength = n, t % 4 === 0 || console.warn(`${r.type}: embedded glb is not aligned to a 4-byte boundary.`), (r.byteOffset || 0) + (r.byteLength || 0);
}
async function $M(r, e, t, i) {
  const n = t?.["3d-tiles"] || {};
  if (sJ(r, e), n.loadGLTF) {
    if (!i)
      return;
    if (r.gltfUrl) {
      const {
        fetch: s
      } = i, c = await s(r.gltfUrl, t);
      r.gltfArrayBuffer = await c.arrayBuffer(), r.gltfByteOffset = 0;
    }
    if (r.gltfArrayBuffer) {
      const s = await jx(r.gltfArrayBuffer, sm, t, i);
      r.gltf = Fx(s), r.gpuMemoryUsageInBytes = mM(r.gltf), delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
    }
  }
}
function sJ(r, e, t) {
  switch (e) {
    case Zv.URI:
      if (r.gltfArrayBuffer) {
        const i = new Uint8Array(r.gltfArrayBuffer, r.gltfByteOffset), s = new TextDecoder().decode(i);
        r.gltfUrl = s.replace(/[\s\0]+$/, "");
      }
      delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
      break;
    case Zv.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function oJ(r, e, t, i, n) {
  t = aJ(r, e, t, i), await $M(r, Zv.EMBEDDED, i, n);
  const s = r?.gltf?.extensions;
  return s && s.CESIUM_RTC && (r.rtcCenter = s.CESIUM_RTC.center), t;
}
function aJ(r, e, t, i, n) {
  t = c0(r, e, t), t = Gx(r, e, t), t = $x(r, e, t), t = GM(r, e, t, i);
  const s = new Vx(r.featureTableJson, r.featureTableBinary);
  return r.rtcCenter = s.getGlobalProperty("RTC_CENTER", zi.FLOAT, 3), t;
}
async function lJ(r, e, t, i, n) {
  return t = cJ(r, e, t, i), await $M(r, r.gltfFormat || 0, i, n), t;
}
function cJ(r, e, t, i, n) {
  if (t = c0(r, e, t), r.version !== 1)
    throw new Error(`Instanced 3D Model version ${r.version} is not supported`);
  t = Gx(r, e, t);
  const s = new DataView(e);
  if (r.gltfFormat = s.getUint32(t, !0), t += 4, t = $x(r, e, t), t = GM(r, e, t, i), !r?.header?.featureTableJsonByteLength || r.header.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const c = new Vx(r.featureTableJson, r.featureTableBinary), o = c.getGlobalProperty("INSTANCES_LENGTH");
  if (c.featuresLength = o, !Number.isFinite(o))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  r.eastNorthUp = c.getGlobalProperty("EAST_NORTH_UP"), r.rtcCenter = c.getGlobalProperty("RTC_CENTER", zi.FLOAT, 3);
  const d = new jM(r.batchTableJson, r.batchTableBinary, o);
  return uJ(r, c, d, o), t;
}
function uJ(r, e, t, i) {
  const n = new Array(i), s = new xt();
  new xt(), new xt(), new xt();
  const c = new hs(), o = new Xg(), d = new xt(), m = {}, y = new Pi(), T = [], P = [], I = [], D = [];
  for (let k = 0; k < i; k++) {
    let $;
    if (e.hasProperty("POSITION"))
      $ = e.getProperty("POSITION", zi.FLOAT, 3, k, s);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      $ = e.getProperty("POSITION_QUANTIZED", zi.UNSIGNED_SHORT, 3, k, s);
      const re = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", zi.FLOAT, 3);
      if (!re)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const be = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", zi.FLOAT, 3);
      if (!be)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const pe = 65535;
      for (let oe = 0; oe < 3; oe++)
        $[oe] = $[oe] / pe * be[oe] + re[oe];
    }
    if (!$)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (s.copy($), m.translation = s, r.normalUp = e.getProperty("NORMAL_UP", zi.FLOAT, 3, k, T), r.normalRight = e.getProperty("NORMAL_RIGHT", zi.FLOAT, 3, k, P), r.normalUp) {
      if (!r.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      r.hasCustomOrientation = !0;
    } else {
      if (r.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", zi.UNSIGNED_SHORT, 2, k, T), r.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", zi.UNSIGNED_SHORT, 2, k, P), r.octNormalUp)
        throw r.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      r.eastNorthUp ? (Tn.WGS84.eastNorthUpToFixedFrame(s, y), y.getRotationMatrix3(c)) : c.identity();
    }
    o.fromMatrix3(c), m.rotation = o, d.set(1, 1, 1);
    const G = e.getProperty("SCALE", zi.FLOAT, 1, k, I);
    Number.isFinite(G) && d.multiplyByScalar(G);
    const te = e.getProperty("SCALE_NON_UNIFORM", zi.FLOAT, 3, k, T);
    te && d.scale(te), m.scale = d;
    let Z = e.getProperty("BATCH_ID", zi.UNSIGNED_SHORT, 1, k, D);
    Z === void 0 && (Z = k);
    const H = new Pi().fromQuaternion(m.rotation);
    y.identity(), y.translate(m.translation), y.multiplyRight(H), y.scale(m.scale);
    const J = y.clone();
    n[k] = {
      modelMatrix: J,
      batchId: Z
    };
  }
  r.instances = n;
}
async function hJ(r, e, t, i, n, s) {
  t = c0(r, e, t);
  const c = new DataView(e);
  for (r.tilesLength = c.getUint32(t, !0), t += 4, r.tiles = []; r.tiles.length < r.tilesLength && (r.byteLength || 0) - t > 12; ) {
    const o = {
      shape: "tile3d"
    };
    r.tiles.push(o), t = await s(e, t, i, n, o);
  }
  return t;
}
async function fJ(r, e, t, i) {
  if (r.rotateYtoZ = !0, r.gltfUpAxis = t?.["3d-tiles"]?.assetGltfUpAxis ? t["3d-tiles"].assetGltfUpAxis : "Y", t?.["3d-tiles"]?.loadGLTF) {
    if (!i)
      return e.byteLength;
    const n = await jx(e, sm, t, i);
    r.gltf = Fx(n), r.gpuMemoryUsageInBytes = mM(r.gltf);
  } else
    r.gltfArrayBuffer = e;
  return e.byteLength;
}
async function HM(r, e = 0, t, i, n = {
  shape: "tile3d"
}) {
  switch (n.byteOffset = e, n.type = IY(r, e), n.type) {
    case mg.COMPOSITE:
      return await hJ(n, r, e, t, i, HM);
    case mg.BATCHED_3D_MODEL:
      return await oJ(n, r, e, t, i);
    case mg.GLTF:
      return await fJ(n, r, t, i);
    case mg.INSTANCED_3D_MODEL:
      return await lJ(n, r, e, t, i);
    case mg.POINT_CLOUD:
      return await YY(n, r, e, t, i);
    default:
      throw new Error(`3DTileLoader: unknown type ${n.type}`);
  }
}
const dJ = 1952609651, pJ = 1;
async function gJ(r, e, t) {
  if (new Uint32Array(r.slice(0, 4))[0] !== dJ)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(r.slice(4, 8))[0] !== pJ)
    throw new Error("Wrong subtree file verson, must be 1");
  const s = cE(r.slice(8, 16)), c = new Uint8Array(r, 24, s), d = new TextDecoder("utf8").decode(c), m = JSON.parse(d), y = cE(r.slice(16, 24));
  let T = new ArrayBuffer(0);
  if (y && (T = r.slice(24 + s)), await A_(m, m.tileAvailability, T, t), Array.isArray(m.contentAvailability))
    for (const P of m.contentAvailability)
      await A_(m, P, T, t);
  else
    await A_(m, m.contentAvailability, T, t);
  return await A_(m, m.childSubtreeAvailability, T, t), m;
}
async function A_(r, e, t, i) {
  const n = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
  if (typeof n != "number")
    return;
  const s = r.bufferViews[n], c = r.buffers[s.buffer];
  if (!i?.baseUrl)
    throw new Error("Url is not provided");
  if (!i.fetch)
    throw new Error("fetch is not provided");
  if (c.uri) {
    const d = `${i?.baseUrl || ""}/${c.uri}`, y = await (await i.fetch(d)).arrayBuffer();
    e.explicitBitstream = new Uint8Array(y, s.byteOffset, s.byteLength);
    return;
  }
  const o = r.buffers.slice(0, s.buffer).reduce((d, m) => d + m.byteLength, 0);
  e.explicitBitstream = new Uint8Array(t.slice(o, o + c.byteLength), s.byteOffset, s.byteLength);
}
function cE(r) {
  const e = new DataView(r), t = e.getUint32(0, !0), i = e.getUint32(4, !0);
  return t + 2 ** 32 * i;
}
const qM = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: FM,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: gJ,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var Bl = null;
try {
  Bl = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
function hn(r, e, t) {
  this.low = r | 0, this.high = e | 0, this.unsigned = !!t;
}
hn.prototype.__isLong__;
Object.defineProperty(hn.prototype, "__isLong__", {
  value: !0
});
function Ho(r) {
  return (r && r.__isLong__) === !0;
}
function uE(r) {
  var e = Math.clz32(r & -r);
  return r ? 31 - e : e;
}
hn.isLong = Ho;
var hE = {}, fE = {};
function ud(r, e) {
  var t, i, n;
  return e ? (r >>>= 0, (n = 0 <= r && r < 256) && (i = fE[r], i) ? i : (t = Hi(r, 0, !0), n && (fE[r] = t), t)) : (r |= 0, (n = -128 <= r && r < 128) && (i = hE[r], i) ? i : (t = Hi(r, r < 0 ? -1 : 0, !1), n && (hE[r] = t), t));
}
hn.fromInt = ud;
function kl(r, e) {
  if (isNaN(r)) return e ? oh : wc;
  if (e) {
    if (r < 0) return oh;
    if (r >= WM) return YM;
  } else {
    if (r <= -pE) return Ia;
    if (r + 1 >= pE) return ZM;
  }
  return r < 0 ? kl(-r, e).neg() : Hi(r % Pp | 0, r / Pp | 0, e);
}
hn.fromNumber = kl;
function Hi(r, e, t) {
  return new hn(r, e, t);
}
hn.fromBits = Hi;
var Uy = Math.pow;
function Hx(r, e, t) {
  if (r.length === 0) throw Error("empty string");
  if (typeof e == "number" ? (t = e, e = !1) : e = !!e, r === "NaN" || r === "Infinity" || r === "+Infinity" || r === "-Infinity") return e ? oh : wc;
  if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix");
  var i;
  if ((i = r.indexOf("-")) > 0) throw Error("interior hyphen");
  if (i === 0)
    return Hx(r.substring(1), e, t).neg();
  for (var n = kl(Uy(t, 8)), s = wc, c = 0; c < r.length; c += 8) {
    var o = Math.min(8, r.length - c), d = parseInt(r.substring(c, c + o), t);
    if (o < 8) {
      var m = kl(Uy(t, o));
      s = s.mul(m).add(kl(d));
    } else
      s = s.mul(n), s = s.add(kl(d));
  }
  return s.unsigned = e, s;
}
hn.fromString = Hx;
function Pc(r, e) {
  return typeof r == "number" ? kl(r, e) : typeof r == "string" ? Hx(r, e) : Hi(r.low, r.high, typeof e == "boolean" ? e : r.unsigned);
}
hn.fromValue = Pc;
var dE = 65536, mJ = 1 << 24, Pp = dE * dE, WM = Pp * Pp, pE = WM / 2, gE = ud(mJ), wc = ud(0);
hn.ZERO = wc;
var oh = ud(0, !0);
hn.UZERO = oh;
var ap = ud(1);
hn.ONE = ap;
var XM = ud(1, !0);
hn.UONE = XM;
var Yv = ud(-1);
hn.NEG_ONE = Yv;
var ZM = Hi(-1, 2147483647, !1);
hn.MAX_VALUE = ZM;
var YM = Hi(-1, -1, !0);
hn.MAX_UNSIGNED_VALUE = YM;
var Ia = Hi(0, -2147483648, !1);
hn.MIN_VALUE = Ia;
var ar = hn.prototype;
ar.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
ar.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * Pp + (this.low >>> 0) : this.high * Pp + (this.low >>> 0);
};
ar.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative())
    if (this.eq(Ia)) {
      var t = kl(e), i = this.div(t), n = i.mul(t).sub(this);
      return i.toString(e) + n.toInt().toString(e);
    } else return "-" + this.neg().toString(e);
  for (var s = kl(Uy(e, 6), this.unsigned), c = this, o = ""; ; ) {
    var d = c.div(s), m = c.sub(d.mul(s)).toInt() >>> 0, y = m.toString(e);
    if (c = d, c.isZero()) return y + o;
    for (; y.length < 6; ) y = "0" + y;
    o = "" + y + o;
  }
};
ar.getHighBits = function() {
  return this.high;
};
ar.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
ar.getLowBits = function() {
  return this.low;
};
ar.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
ar.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Ia) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && (e & 1 << t) == 0; t--) ;
  return this.high != 0 ? t + 33 : t + 1;
};
ar.isZero = function() {
  return this.high === 0 && this.low === 0;
};
ar.eqz = ar.isZero;
ar.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
ar.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
ar.isOdd = function() {
  return (this.low & 1) === 1;
};
ar.isEven = function() {
  return (this.low & 1) === 0;
};
ar.equals = function(e) {
  return Ho(e) || (e = Pc(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
ar.eq = ar.equals;
ar.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
ar.neq = ar.notEquals;
ar.ne = ar.notEquals;
ar.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
ar.lt = ar.lessThan;
ar.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
ar.lte = ar.lessThanOrEqual;
ar.le = ar.lessThanOrEqual;
ar.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
ar.gt = ar.greaterThan;
ar.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
ar.gte = ar.greaterThanOrEqual;
ar.ge = ar.greaterThanOrEqual;
ar.compare = function(e) {
  if (Ho(e) || (e = Pc(e)), this.eq(e)) return 0;
  var t = this.isNegative(), i = e.isNegative();
  return t && !i ? -1 : !t && i ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
ar.comp = ar.compare;
ar.negate = function() {
  return !this.unsigned && this.eq(Ia) ? Ia : this.not().add(ap);
};
ar.neg = ar.negate;
ar.add = function(e) {
  Ho(e) || (e = Pc(e));
  var t = this.high >>> 16, i = this.high & 65535, n = this.low >>> 16, s = this.low & 65535, c = e.high >>> 16, o = e.high & 65535, d = e.low >>> 16, m = e.low & 65535, y = 0, T = 0, P = 0, I = 0;
  return I += s + m, P += I >>> 16, I &= 65535, P += n + d, T += P >>> 16, P &= 65535, T += i + o, y += T >>> 16, T &= 65535, y += t + c, y &= 65535, Hi(P << 16 | I, y << 16 | T, this.unsigned);
};
ar.subtract = function(e) {
  return Ho(e) || (e = Pc(e)), this.add(e.neg());
};
ar.sub = ar.subtract;
ar.multiply = function(e) {
  if (this.isZero()) return this;
  if (Ho(e) || (e = Pc(e)), Bl) {
    var t = Bl.mul(this.low, this.high, e.low, e.high);
    return Hi(t, Bl.get_high(), this.unsigned);
  }
  if (e.isZero()) return this.unsigned ? oh : wc;
  if (this.eq(Ia)) return e.isOdd() ? Ia : wc;
  if (e.eq(Ia)) return this.isOdd() ? Ia : wc;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(gE) && e.lt(gE)) return kl(this.toNumber() * e.toNumber(), this.unsigned);
  var i = this.high >>> 16, n = this.high & 65535, s = this.low >>> 16, c = this.low & 65535, o = e.high >>> 16, d = e.high & 65535, m = e.low >>> 16, y = e.low & 65535, T = 0, P = 0, I = 0, D = 0;
  return D += c * y, I += D >>> 16, D &= 65535, I += s * y, P += I >>> 16, I &= 65535, I += c * m, P += I >>> 16, I &= 65535, P += n * y, T += P >>> 16, P &= 65535, P += s * m, T += P >>> 16, P &= 65535, P += c * d, T += P >>> 16, P &= 65535, T += i * y + n * m + s * d + c * o, T &= 65535, Hi(I << 16 | D, T << 16 | P, this.unsigned);
};
ar.mul = ar.multiply;
ar.divide = function(e) {
  if (Ho(e) || (e = Pc(e)), e.isZero()) throw Error("division by zero");
  if (Bl) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var t = (this.unsigned ? Bl.div_u : Bl.div_s)(this.low, this.high, e.low, e.high);
    return Hi(t, Bl.get_high(), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? oh : wc;
  var i, n, s;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return oh;
    if (e.gt(this.shru(1)))
      return XM;
    s = oh;
  } else {
    if (this.eq(Ia)) {
      if (e.eq(ap) || e.eq(Yv)) return Ia;
      if (e.eq(Ia)) return ap;
      var c = this.shr(1);
      return i = c.div(e).shl(1), i.eq(wc) ? e.isNegative() ? ap : Yv : (n = this.sub(e.mul(i)), s = i.add(n.div(e)), s);
    } else if (e.eq(Ia)) return this.unsigned ? oh : wc;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    s = wc;
  }
  for (n = this; n.gte(e); ) {
    i = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));
    for (var o = Math.ceil(Math.log(i) / Math.LN2), d = o <= 48 ? 1 : Uy(2, o - 48), m = kl(i), y = m.mul(e); y.isNegative() || y.gt(n); )
      i -= d, m = kl(i, this.unsigned), y = m.mul(e);
    m.isZero() && (m = ap), s = s.add(m), n = n.sub(y);
  }
  return s;
};
ar.div = ar.divide;
ar.modulo = function(e) {
  if (Ho(e) || (e = Pc(e)), Bl) {
    var t = (this.unsigned ? Bl.rem_u : Bl.rem_s)(this.low, this.high, e.low, e.high);
    return Hi(t, Bl.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
ar.mod = ar.modulo;
ar.rem = ar.modulo;
ar.not = function() {
  return Hi(~this.low, ~this.high, this.unsigned);
};
ar.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
ar.clz = ar.countLeadingZeros;
ar.countTrailingZeros = function() {
  return this.low ? uE(this.low) : uE(this.high) + 32;
};
ar.ctz = ar.countTrailingZeros;
ar.and = function(e) {
  return Ho(e) || (e = Pc(e)), Hi(this.low & e.low, this.high & e.high, this.unsigned);
};
ar.or = function(e) {
  return Ho(e) || (e = Pc(e)), Hi(this.low | e.low, this.high | e.high, this.unsigned);
};
ar.xor = function(e) {
  return Ho(e) || (e = Pc(e)), Hi(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
ar.shiftLeft = function(e) {
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Hi(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : Hi(0, this.low << e - 32, this.unsigned);
};
ar.shl = ar.shiftLeft;
ar.shiftRight = function(e) {
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Hi(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : Hi(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
ar.shr = ar.shiftRight;
ar.shiftRightUnsigned = function(e) {
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Hi(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? Hi(this.high, 0, this.unsigned) : Hi(this.high >>> e - 32, 0, this.unsigned);
};
ar.shru = ar.shiftRightUnsigned;
ar.shr_u = ar.shiftRightUnsigned;
ar.rotateLeft = function(e) {
  var t;
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Hi(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Hi(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)) : (e -= 32, t = 32 - e, Hi(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned));
};
ar.rotl = ar.rotateLeft;
ar.rotateRight = function(e) {
  var t;
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Hi(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Hi(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)) : (e -= 32, t = 32 - e, Hi(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned));
};
ar.rotr = ar.rotateRight;
ar.toSigned = function() {
  return this.unsigned ? Hi(this.low, this.high, !1) : this;
};
ar.toUnsigned = function() {
  return this.unsigned ? this : Hi(this.low, this.high, !0);
};
ar.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
ar.toBytesLE = function() {
  var e = this.high, t = this.low;
  return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
};
ar.toBytesBE = function() {
  var e = this.high, t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
};
hn.fromBytes = function(e, t, i) {
  return i ? hn.fromBytesLE(e, t) : hn.fromBytesBE(e, t);
};
hn.fromBytesLE = function(e, t) {
  return new hn(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
};
hn.fromBytesBE = function(e, t) {
  return new hn(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
const _J = 16;
function JM(r) {
  r === "X" && (r = "");
  const e = r.padEnd(_J, "0");
  return hn.fromString(e, !0, 16);
}
function yJ(r) {
  if (r.isZero())
    return "X";
  let e = r.countTrailingZeros();
  const t = e % 4;
  e = (e - t) / 4;
  const i = e;
  e *= 4;
  const s = r.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - i - s.length).join("0") + s;
}
function bJ(r, e) {
  const t = vJ(r).shiftRightUnsigned(2);
  return r.add(hn.fromNumber(2 * e + 1 - 4).multiply(t));
}
function vJ(r) {
  return r.and(r.not().add(1));
}
const xJ = 3, wJ = 30, AJ = 2 * wJ + 1, mE = 180 / Math.PI;
function TJ(r) {
  if (r.length === 0)
    throw new Error(`Invalid Hilbert quad key ${r}`);
  const e = r.split("/"), t = parseInt(e[0], 10), i = e[1], n = i.length;
  let s = 0;
  const c = [0, 0];
  for (let o = n - 1; o >= 0; o--) {
    s = n - o;
    const d = i[o];
    let m = 0, y = 0;
    d === "1" ? y = 1 : d === "2" ? (m = 1, y = 1) : d === "3" && (m = 1);
    const T = Math.pow(2, s - 1);
    EJ(T, c, m, y), c[0] += T * m, c[1] += T * y;
  }
  if (t % 2 === 1) {
    const o = c[0];
    c[0] = c[1], c[1] = o;
  }
  return {
    face: t,
    ij: c,
    level: s
  };
}
function SJ(r) {
  if (r.isZero())
    return "";
  let e = r.toString(2);
  for (; e.length < xJ + AJ; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), i = e.substring(0, 3), n = e.substring(3, t), s = n.length / 2, c = hn.fromString(i, !0, 2).toString(10);
  let o = "";
  if (s !== 0)
    for (o = hn.fromString(n, !0, 2).toString(4); o.length < s; )
      o = "0" + o;
  return `${c}/${o}`;
}
function KM(r, e, t) {
  const i = 1 << e;
  return [(r[0] + t[0]) / i, (r[1] + t[1]) / i];
}
function _E(r) {
  return r >= 0.5 ? 1 / 3 * (4 * r * r - 1) : 1 / 3 * (1 - 4 * (1 - r) * (1 - r));
}
function QM(r) {
  return [_E(r[0]), _E(r[1])];
}
function eR(r, [e, t]) {
  switch (r) {
    case 0:
      return [1, e, t];
    case 1:
      return [-e, 1, t];
    case 2:
      return [-e, -t, 1];
    case 3:
      return [-1, -t, -e];
    case 4:
      return [t, -1, -e];
    case 5:
      return [t, e, -1];
    default:
      throw new Error("Invalid face");
  }
}
function tR([r, e, t]) {
  const i = Math.atan2(t, Math.sqrt(r * r + e * e));
  return [Math.atan2(e, r) * mE, i * mE];
}
function EJ(r, e, t, i) {
  if (i === 0) {
    t === 1 && (e[0] = r - 1 - e[0], e[1] = r - 1 - e[1]);
    const n = e[0];
    e[0] = e[1], e[1] = n;
  }
}
function CJ(r) {
  const e = KM(r.ij, r.level, [0.5, 0.5]), t = QM(e), i = eR(r.face, t);
  return tR(i);
}
const IJ = 100;
function yE(r) {
  const {
    face: e,
    ij: t,
    level: i
  } = r, n = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], s = Math.max(1, Math.ceil(IJ * Math.pow(2, -i))), c = new Float64Array(4 * s * 2 + 2);
  let o = 0, d = 0;
  for (let m = 0; m < 4; m++) {
    const y = n[m].slice(0), T = n[m + 1], P = (T[0] - y[0]) / s, I = (T[1] - y[1]) / s;
    for (let D = 0; D < s; D++) {
      y[0] += P, y[1] += I;
      const k = KM(t, i, y), $ = QM(k), G = eR(e, $), te = tR(G);
      Math.abs(te[1]) > 89.999 && (te[0] = d);
      const Z = te[0] - d;
      te[0] += Z > 180 ? -360 : Z < -180 ? 360 : 0, c[o++] = te[0], c[o++] = te[1], d = te[0];
    }
  }
  return c[o++] = c[0], c[o++] = c[1], c;
}
function qx(r) {
  const e = PJ(r);
  return TJ(e);
}
function PJ(r) {
  if (r.indexOf("/") > 0)
    return r;
  const e = JM(r);
  return SJ(e);
}
function MJ(r) {
  const e = qx(r);
  return CJ(e);
}
function RJ(r) {
  let e;
  if (r.face === 2 || r.face === 5) {
    let t = null, i = 0;
    for (let n = 0; n < 4; n++) {
      const s = `${r.face}/${n}`, c = qx(s), o = yE(c);
      (typeof t > "u" || t === null) && (t = new Float64Array(4 * o.length)), t.set(o, i), i += o.length;
    }
    e = bE(t);
  } else {
    const t = yE(r);
    e = bE(t);
  }
  return e;
}
function bE(r) {
  if (r.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], t = [];
  for (let i = 0; i < r.length; i += 2)
    e.push(r[i]), t.push(r[i + 1]);
  return e.sort((i, n) => i - n), t.sort((i, n) => i - n), {
    west: e[0],
    east: e[e.length - 1],
    north: t[t.length - 1],
    south: t[0]
  };
}
function LJ(r, e) {
  const t = e?.minimumHeight || 0, i = e?.maximumHeight || 0, n = qx(r), s = RJ(n), c = s.west, o = s.south, d = s.east, m = s.north, y = [];
  return y.push(new xt(c, m, t)), y.push(new xt(d, m, t)), y.push(new xt(d, o, t)), y.push(new xt(c, o, t)), y.push(new xt(c, m, i)), y.push(new xt(d, m, i)), y.push(new xt(d, o, i)), y.push(new xt(c, o, i)), y;
}
function rR(r) {
  const e = r.token, t = {
    minimumHeight: r.minimumHeight,
    maximumHeight: r.maximumHeight
  }, i = LJ(e, t), n = MJ(e), s = n[0], c = n[1], o = Tn.WGS84.cartographicToCartesian([s, c, t.maximumHeight]), d = new xt(o[0], o[1], o[2]);
  i.push(d);
  const m = HG(i);
  return [...m.center, ...m.halfAxes];
}
const BJ = 4, kJ = 8, OJ = {
  QUADTREE: BJ,
  OCTREE: kJ
};
function DJ(r, e, t) {
  if (r?.box) {
    const i = JM(r.s2VolumeInfo.token), n = bJ(i, e), s = yJ(n), c = {
      ...r.s2VolumeInfo
    };
    switch (c.token = s, t) {
      case "OCTREE":
        const m = r.s2VolumeInfo, y = m.maximumHeight - m.minimumHeight, T = y / 2, P = m.minimumHeight + y / 2;
        m.minimumHeight = P - T, m.maximumHeight = P + T;
        break;
    }
    return {
      box: rR(c),
      s2VolumeInfo: c
    };
  }
}
async function iR(r) {
  const {
    subtree: e,
    subtreeData: t = {
      level: 0,
      x: 0,
      y: 0,
      z: 0
    },
    parentData: i = {
      mortonIndex: 0,
      localLevel: -1,
      localX: 0,
      localY: 0,
      localZ: 0
    },
    childIndex: n = 0,
    implicitOptions: s,
    loaderOptions: c,
    s2VolumeBox: o
  } = r, {
    subdivisionScheme: d,
    subtreeLevels: m,
    maximumLevel: y,
    contentUrlTemplate: T,
    subtreesUriTemplate: P,
    basePath: I
  } = s, D = {
    children: [],
    lodMetricValue: 0,
    contentUrl: ""
  };
  if (!y)
    return w5.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${T} won't be loaded...`), D;
  const k = i.localLevel + 1, $ = t.level + k;
  if ($ > y)
    return D;
  const G = OJ[d], te = Math.log2(G), Z = n & 1, H = n >> 1 & 1, J = n >> 2 & 1, re = Ef(i.localX, Z, 1), be = Ef(i.localY, H, 1), pe = Ef(i.localZ, J, 1), oe = Ef(t.x, re, k), Ee = Ef(t.y, be, k), le = Ef(t.z, pe, k), _e = Ef(i.mortonIndex, n, te), Ve = k === m && b1(e.childSubtreeAvailability, _e);
  let Be, gt, St, Mt;
  if (Ve) {
    const Yt = `${I}/${P}`, Dt = Jv(Yt, $, oe, Ee, le);
    Be = await Wh(Dt, qM, c), Mt = 0, gt = {
      level: $,
      x: oe,
      y: Ee,
      z: le
    }, St = {
      mortonIndex: 0,
      localLevel: 0,
      localX: 0,
      localY: 0,
      localZ: 0
    };
  } else
    Be = e, Mt = (G ** k - 1) / (G - 1) + _e, gt = t, St = {
      mortonIndex: _e,
      localLevel: k,
      localX: re,
      localY: be,
      localZ: pe
    };
  if (!b1(Be.tileAvailability, Mt))
    return D;
  b1(Be.contentAvailability, Mt) && (D.contentUrl = Jv(T, $, oe, Ee, le));
  for (let Yt = 0; Yt < G; Yt++) {
    const Dt = DJ(o, Yt, d), fe = await iR({
      subtree: Be,
      subtreeData: gt,
      parentData: St,
      childIndex: Yt,
      implicitOptions: s,
      loaderOptions: c,
      s2VolumeBox: Dt
    });
    (fe.contentUrl || fe.children.length) && D.children.push(fe);
  }
  return D.contentUrl || D.children.length ? NJ(D, {
    level: $,
    x: oe,
    y: Ee,
    z: le
  }, s, o) : D;
}
function b1(r, e) {
  let t;
  return Array.isArray(r) ? (t = r[0], r.length > 1 && w5.once('Not supported extension "3DTILES_multiple_contents" has been detected')) : t = r, "constant" in t ? !!t.constant : t.explicitBitstream ? zJ(e, t.explicitBitstream) : !1;
}
function NJ(r, e, t, i) {
  const {
    basePath: n,
    refine: s,
    getRefine: c,
    lodMetricType: o,
    getTileType: d,
    rootLodMetricValue: m,
    rootBoundingVolume: y
  } = t, T = r.contentUrl && r.contentUrl.replace(`${n}/`, ""), P = m / 2 ** e.level, I = i?.box ? {
    box: i.box
  } : y, D = FJ(I, e, t.subdivisionScheme);
  return {
    children: r.children,
    contentUrl: r.contentUrl,
    content: {
      uri: T
    },
    id: r.contentUrl,
    refine: c(s),
    type: d(r),
    lodMetricType: o,
    lodMetricValue: P,
    geometricError: P,
    transform: r.transform,
    boundingVolume: D
  };
}
function FJ(r, e, t) {
  if (r.region) {
    const {
      level: i,
      x: n,
      y: s,
      z: c
    } = e, [o, d, m, y, T, P] = r.region, I = 2 ** i, D = (m - o) / I, [k, $] = [o + D * n, o + D * (n + 1)], G = (y - d) / I, [te, Z] = [d + G * s, d + G * (s + 1)];
    let H, J;
    if (t === "OCTREE") {
      const re = (P - T) / I;
      [H, J] = [T + re * c, T + re * (c + 1)];
    } else
      [H, J] = [T, P];
    return {
      region: [k, te, $, Z, H, J]
    };
  }
  if (r.box)
    return r;
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(r)}`);
}
function Ef(r, e, t) {
  return (r << t) + e;
}
function Jv(r, e, t, i, n) {
  const s = UJ({
    level: e,
    x: t,
    y: i,
    z: n
  });
  return r.replace(/{level}|{x}|{y}|{z}/gi, (c) => s[c]);
}
function UJ(r) {
  const e = {};
  for (const t in r)
    e[`{${t}}`] = r[t];
  return e;
}
function zJ(r, e) {
  const t = Math.floor(r / 8), i = r % 8;
  return (e[t] >> i & 1) === 1;
}
function Wx(r, e = "") {
  if (!e)
    return sh.EMPTY;
  const i = e.split("?")[0].split(".").pop();
  switch (i) {
    case "pnts":
      return sh.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return sh.SCENEGRAPH;
    default:
      return i || sh.EMPTY;
  }
}
function Xx(r) {
  switch (r) {
    case "REPLACE":
    case "replace":
      return Tc.REPLACE;
    case "ADD":
    case "add":
      return Tc.ADD;
    default:
      return r;
  }
}
function Kv(r, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const i = new URL(r, `${e}/`);
    return decodeURI(i.toString());
  } else if (r.startsWith("/"))
    return r;
  return EY(e, r);
}
function vE(r, e) {
  if (!r)
    return null;
  let t;
  if (r.content) {
    const n = r.content.uri || r.content?.url;
    typeof n < "u" && (t = Kv(n, e));
  }
  return {
    ...r,
    id: t,
    contentUrl: t,
    lodMetricType: Ip.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: Wx(r, t),
    refine: Xx(r.refine)
  };
}
async function jJ(r, e, t) {
  let i = null;
  const n = wE(r.root);
  n && r.root ? i = await xE(r.root, r, e, n, t) : i = vE(r.root, e);
  const s = [];
  for (s.push(i); s.length > 0; ) {
    const c = s.pop() || {}, o = c.children || [], d = [];
    for (const m of o) {
      const y = wE(m);
      let T;
      y ? T = await xE(m, r, e, y, t) : T = vE(m, e), T && (d.push(T), s.push(T));
    }
    c.children = d;
  }
  return i;
}
async function xE(r, e, t, i, n) {
  const {
    subdivisionScheme: s,
    maximumLevel: c,
    availableLevels: o,
    subtreeLevels: d,
    subtrees: {
      uri: m
    }
  } = i, y = Jv(m, 0, 0, 0, 0), T = Kv(y, t), P = await Wh(T, qM, n), I = r.content?.uri, D = I ? Kv(I, t) : "", k = e?.root?.refine, $ = r.geometricError, G = r.boundingVolume.extensions?.["3DTILES_bounding_volume_S2"];
  if (G) {
    const J = {
      box: rR(G),
      s2VolumeInfo: G
    };
    r.boundingVolume = J;
  }
  const te = r.boundingVolume, Z = {
    contentUrlTemplate: D,
    subtreesUriTemplate: m,
    subdivisionScheme: s,
    subtreeLevels: d,
    maximumLevel: Number.isFinite(o) ? o - 1 : c,
    refine: k,
    basePath: t,
    lodMetricType: Ip.GEOMETRIC_ERROR,
    rootLodMetricValue: $,
    rootBoundingVolume: te,
    getTileType: Wx,
    getRefine: Xx
  };
  return await VJ(r, t, P, Z, n);
}
async function VJ(r, e, t, i, n) {
  if (!r)
    return null;
  const {
    children: s,
    contentUrl: c
  } = await iR({
    subtree: t,
    implicitOptions: i,
    loaderOptions: n
  });
  let o, d = null;
  return c && (o = c, d = {
    uri: c.replace(`${e}/`, "")
  }), {
    ...r,
    id: o,
    contentUrl: o,
    lodMetricType: Ip.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: Wx(r, o),
    refine: Xx(r.refine),
    content: d || r.content,
    children: s
  };
}
function wE(r) {
  return r?.extensions?.["3DTILES_implicit_tiling"] || r?.implicitTiling;
}
const Zx = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: FM,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: GJ,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function GJ(r, e = {}, t) {
  const i = e["3d-tiles"] || {};
  let n;
  return i.isTileset === "auto" ? n = t?.url && t.url.indexOf(".json") !== -1 : n = i.isTileset, n ? $J(r, e, t) : HJ(r, e, t);
}
async function $J(r, e, t) {
  const i = JSON.parse(new TextDecoder().decode(r)), n = t?.url || "", s = qJ(n), c = await jJ(i, s, e || {});
  return {
    ...i,
    shape: "tileset3d",
    loader: Zx,
    url: n,
    queryString: t?.queryString || "",
    basePath: s,
    root: c || i.root,
    type: Ea.TILES3D,
    lodMetricType: Ip.GEOMETRIC_ERROR,
    lodMetricValue: i.root?.geometricError || 0
  };
}
async function HJ(r, e, t) {
  const i = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  return await HM(r, 0, e, t, i.content), i.content;
}
function qJ(r) {
  return SY(r);
}
const AE = [0], WJ = {
  getPointColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: Zx,
  onTilesetLoad: {
    type: "function",
    value: (r) => {
    }
  },
  onTileLoad: {
    type: "function",
    value: (r) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (r) => {
    }
  },
  onTileError: {
    type: "function",
    value: (r, e, t) => {
    }
  },
  _getMeshColor: {
    type: "function",
    value: (r) => [255, 255, 255]
  }
};
class Yx extends XP {
  initializeState() {
    "onTileLoadFail" in this.props && Ni.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    return !!(this.state?.tileset3d?.isLoaded() && super.isLoaded);
  }
  shouldUpdateState({
    changeFlags: e
  }) {
    return e.somethingChanged;
  }
  updateState({
    props: e,
    oldProps: t,
    changeFlags: i
  }) {
    if (e.data && e.data !== t.data && this._loadTileset(e.data), i.viewportChanged) {
      const {
        activeViewports: n
      } = this.state;
      Object.keys(n).length && (this._updateTileset(n), this.state.lastUpdatedViewports = n, this.state.activeViewports = {});
    }
    if (i.propsChanged) {
      const {
        layerMap: n
      } = this.state;
      for (const s in n)
        n[s].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const {
      activeViewports: t,
      lastUpdatedViewports: i
    } = this.state;
    this.internalState.viewport = e, t[e.id] = e;
    const n = i?.[e.id];
    (!n || !e.equals(n)) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.setNeedsUpdate());
  }
  getPickingInfo({
    info: e,
    sourceLayer: t
  }) {
    const i = t && t.props.tile;
    return e.picked && (e.object = i), e.sourceTile = i, e;
  }
  filterSubLayer({
    layer: e,
    viewport: t
  }) {
    const {
      tile: i
    } = e.props, {
      id: n
    } = t;
    return i.selected && i.viewportIds.includes(n);
  }
  _updateAutoHighlight(e) {
    const t = e.sourceTile, i = this.state.layerMap[t?.id];
    i && i.layer && i.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const {
      loadOptions: t = {}
    } = this.props, i = this.props.loader || this.props.loaders, n = Array.isArray(i) ? i[0] : i, s = {
      loadOptions: {
        ...t
      }
    };
    let c = e;
    if (n.preload) {
      const m = await n.preload(e, t);
      m.url && (c = m.url), m.headers && (s.loadOptions.fetch = {
        ...s.loadOptions.fetch,
        headers: m.headers
      }), Object.assign(s, m);
    }
    const o = await Wh(c, n, s.loadOptions), d = new wY(o, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...s
    });
    this.setState({
      tileset3d: d,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(d);
  }
  _onTileLoad(e) {
    const {
      lastUpdatedViewports: t
    } = this.state;
    this.props.onTileLoad(e), this._updateTileset(t), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const {
      tileset3d: t
    } = this.state, {
      timeline: i
    } = this.context, n = Object.keys(e).length;
    !i || !n || !t || t.selectTiles(Object.values(e)).then((s) => {
      this.state.frameNumber !== s && this.setState({
        frameNumber: s
      });
    });
  }
  _getSubLayer(e, t) {
    if (!e.content)
      return null;
    switch (e.type) {
      case sh.POINTCLOUD:
        return this._makePointCloudLayer(e, t);
      case sh.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case sh.MESH:
        return this._makeSimpleMeshLayer(e, t);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`);
    }
  }
  _makePointCloudLayer(e, t) {
    const {
      attributes: i,
      pointCount: n,
      constantRGBA: s,
      cartographicOrigin: c,
      modelMatrix: o
    } = e.content, {
      positions: d,
      normals: m,
      colors: y
    } = i;
    if (!d)
      return null;
    const T = t && t.props.data || {
      header: {
        vertexCount: n
      },
      attributes: {
        POSITION: d,
        NORMAL: m,
        COLOR_0: y
      }
    }, {
      pointSize: P,
      getPointColor: I
    } = this.props, D = this.getSubLayerClass("pointcloud", Cx);
    return new D({
      pointSize: P
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${e.id}`,
      tile: e,
      data: T,
      coordinateSystem: Mi.METER_OFFSETS,
      coordinateOrigin: c,
      modelMatrix: o,
      getColor: s || I,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const {
      gltf: t,
      instances: i,
      cartographicOrigin: n,
      modelMatrix: s
    } = e.content, c = this.getSubLayerClass("scenegraph", Ux);
    return new c({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${e.id}`,
      tile: e,
      data: i || AE,
      scenegraph: t,
      coordinateSystem: Mi.METER_OFFSETS,
      coordinateOrigin: n,
      modelMatrix: s,
      getTransformMatrix: (o) => o.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, t) {
    const i = e.content, {
      attributes: n,
      indices: s,
      modelMatrix: c,
      cartographicOrigin: o,
      coordinateSystem: d = Mi.METER_OFFSETS,
      material: m,
      featureIds: y
    } = i, {
      _getMeshColor: T
    } = this.props, P = t && t.props.mesh || new dp({
      topology: "triangle-list",
      attributes: XJ(n),
      indices: s
    }), I = this.getSubLayerClass("mesh", zx);
    return new I(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${e.id}`,
      tile: e,
      mesh: P,
      data: AE,
      getColor: T(e),
      pbrMaterial: m,
      modelMatrix: c,
      coordinateOrigin: o,
      coordinateSystem: d,
      featureIds: y,
      _offset: 0
    });
  }
  renderLayers() {
    const {
      tileset3d: e,
      layerMap: t
    } = this.state;
    return e ? e.tiles.map((i) => {
      const n = t[i.id] = t[i.id] || {
        tile: i
      };
      let {
        layer: s
      } = n;
      return i.selected && (s ? n.needsUpdate && (s = this._getSubLayer(i, s), n.needsUpdate = !1) : s = this._getSubLayer(i)), n.layer = s, s;
    }).filter(Boolean) : null;
  }
}
Yx.defaultProps = WJ;
Yx.layerName = "Tile3DLayer";
function XJ(r) {
  const e = {};
  return e.positions = {
    ...r.positions,
    value: new Float32Array(r.positions.value)
  }, r.normals && (e.normals = r.normals), r.texCoords && (e.texCoords = r.texCoords), r.colors && (e.colors = r.colors), r.uvRegions && (e.uvRegions = r.uvRegions), e;
}
class ZJ {
  map;
  width;
  height;
  svgCanvas;
  xLine;
  yLine;
  color = "#535353";
  constructor(e) {
    this.map = e, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    this.width = this.map?.getCanvas().clientWidth, this.height = this.map?.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const e = this.width / 2, t = this.height / 2;
      this.yLine.setAttribute("x1", `${e}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${e}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${t}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${t}px`);
    } else console.error("element value is null");
  }
  createCanvas(e) {
    if (this.width !== void 0 && this.height !== void 0) {
      const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t.style.position = "relative", t.setAttribute("width", `${this.width}px`), t.setAttribute("height", `${this.height}px`);
      const i = this.width / 2, n = this.height / 2;
      this.yLine = t.appendChild(this.createLine(i, 0, i, this.height, this.color, "2px")), this.xLine = t.appendChild(this.createLine(0, n, this.width, n, this.color, "2px")), e?.appendChild(t), this.svgCanvas = t;
    }
  }
  createLine(e, t, i, n, s, c) {
    const o = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return o.setAttribute("x1", e), o.setAttribute("y1", t), o.setAttribute("x2", i), o.setAttribute("y2", n), o.setAttribute("stroke-dasharray", "5,5"), o.setAttribute("stroke", s), o.setAttribute("stroke-width", c), o;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Qv = { 72: 72, 96: 96, 200: 200, 300: 300, 400: 400 }, ih = { JPEG: "jpg", PNG: "png", PDF: "pdf", SVG: "svg" }, Pg = { Landscape: "landscape", Portrait: "portrait" }, Uf = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, Mp = {
  // don't use inch unit. because page size setting is using mm unit.
  mm: "mm"
};
class YJ {
  map;
  width;
  height;
  unit;
  svgCanvas;
  svgPath;
  constructor(e) {
    if (this.map = e, this.map === void 0) return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const t = this.map?.getCanvas().clientWidth, i = this.map?.getCanvas().clientHeight, n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    n.style.position = "absolute", n.style.top = "0px", n.style.left = "0px", n.setAttribute("width", `${t}px`), n.setAttribute("height", `${i}px`);
    const s = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s.setAttribute("style", "fill:#888888;stroke-width:0"), s.setAttribute("fill-opacity", "0.5"), n.append(s), this.map?.getCanvasContainer().appendChild(n), this.svgCanvas = n, this.svgPath = s;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(e, t) {
    this.width = e, this.height = t, this.unit = Mp.mm, this.generateCutOut();
  }
  generateCutOut() {
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0) return;
    const e = this.toPixels(this.width), t = this.toPixels(this.height), i = this.map?.getCanvas().clientWidth, n = this.map?.getCanvas().clientHeight, s = i / 2 - e / 2, c = s + e, o = n / 2 - t / 2, d = o + t;
    this.svgCanvas.setAttribute("width", `${i}px`), this.svgCanvas.setAttribute("height", `${n}px`), this.svgPath.setAttribute("d", `M 0 0 L ${i} 0 L ${i} ${n} L 0 ${n} M ${s} ${o} L ${s} ${d} L ${c} ${d} L ${c} ${o}`);
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e, t = 96) {
    return this.unit === Mp.mm && (t /= 25.4), t * e;
  }
}
const nR = { PageSize: "Page Size", PageOrientation: "Page Orientation", Format: "Format", DPI: "DPI", Generate: "Generate", LanguageName: "English", LanguageCode: "en" }, JJ = { PageSize: "Taille de page", PageOrientation: "Orientation de la page", Format: "Format", DPI: "DPI", Generate: "Générer", LanguageName: "Français", LanguageCode: "fr" }, KJ = { PageSize: "Sivukoko", PageOrientation: "Sivun suunta", Format: "Muoto", DPI: "DPI", Generate: "Generoi", LanguageName: "Suomalainen", LanguageCode: "fi" }, QJ = { PageSize: "Papierformat", PageOrientation: "Papierausrichtung", Format: "Dateiformat", DPI: "Druckauflösung", Generate: "Erstellen", LanguageName: "Deutsch", LanguageCode: "de" }, eK = { PageSize: "Sidstorlek", PageOrientation: "Sidorientering", Format: "Format", DPI: "DPI", Generate: "Generera", LanguageName: "Svenska", LanguageCode: "sv" }, tK = { PageSize: "Tamaño de página", PageOrientation: "Orientación de página", Format: "Formato", DPI: "DPI", Generate: "Generar", LanguageName: "Española", LanguageCode: "es" }, rK = { PageSize: "Mida", PageOrientation: "Orientació", Format: "Format", DPI: "DPI", Generate: "Genera", LanguageName: "Catalan", LanguageCode: "ca" }, iK = { PageSize: "Kích thước trang", PageOrientation: "Loại trang", Format: "Định dạng", DPI: "Mật độ điểm ảnh (DPI)", Generate: "Tạo", LanguageName: "Tiếng Việt", LanguageCode: "vi" }, nK = { PageSize: "Розмір сторінки", PageOrientation: "Орієнтація сторінки", Format: "Формат", DPI: "DPI", Generate: "Згенерувати", LanguageName: "українська", LanguageCode: "uk" }, sK = { PageSize: "页面大小", PageOrientation: "页面方向", Format: "格式", DPI: "像素", Generate: "导出", LanguageName: "简体字", LanguageCode: "zhHans" }, oK = { PageSize: "頁面大小", PageOrientation: "頁面方向", Format: "格式", DPI: "像素", Generate: "導出", LanguageName: "繁体字", LanguageCode: "zhHant" }, aK = { PageSize: "ページサイズ", PageOrientation: "ページ方向", Format: "フォーマット", DPI: "DPI（解像度）", Generate: "出力", LanguageName: "日本語", LanguageCode: "ja" }, lK = { PageSize: "Tamanho da página", PageOrientation: "Orientação da página", Format: "Formato", DPI: "DPI", Generate: "Gerar", LanguageName: "Português", LanguageCode: "pt" }, cK = { PageSize: "Размер страницы", PageOrientation: "Ориентация страницы", Format: "Формат", DPI: "Разрешение (DPI)", Generate: "Сгенерировать", LanguageName: "русский", LanguageCode: "ru" }, uK = [nR, JJ, KJ, QJ, eK, tK, rK, iK, nK, sK, oK, aK, lK, cK], hK = (r) => uK.find((e) => e.LanguageCode === r) ?? nR;
function un(r) {
  "@babel/helpers - typeof";
  return un = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, un(r);
}
var Ec = Uint8Array, Ol = Uint16Array, Jx = Int32Array, Kx = new Ec([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Qx = new Ec([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), TE = new Ec([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), sR = function(r, e) {
  for (var t = new Ol(31), i = 0; i < 31; ++i) t[i] = e += 1 << r[i - 1];
  for (var n = new Jx(t[30]), i = 1; i < 30; ++i) for (var s = t[i]; s < t[i + 1]; ++s) n[s] = s - t[i] << 5 | i;
  return { b: t, r: n };
}, oR = sR(Kx, 2), fK = oR.b, e2 = oR.r;
fK[28] = 258, e2[258] = 28;
var dK = sR(Qx, 0), SE = dK.r, aR = new Ol(32768);
for (var Nn = 0; Nn < 32768; ++Nn) {
  var kh = (Nn & 43690) >> 1 | (Nn & 21845) << 1;
  kh = (kh & 52428) >> 2 | (kh & 13107) << 2, kh = (kh & 61680) >> 4 | (kh & 3855) << 4, aR[Nn] = ((kh & 65280) >> 8 | (kh & 255) << 8) >> 1;
}
var $g = function(r, e, t) {
  for (var i = r.length, n = 0, s = new Ol(e); n < i; ++n) r[n] && ++s[r[n] - 1];
  var c = new Ol(e);
  for (n = 1; n < e; ++n) c[n] = c[n - 1] + s[n - 1] << 1;
  var o;
  for (o = new Ol(i), n = 0; n < i; ++n) r[n] && (o[n] = aR[c[r[n] - 1]++] >> 15 - r[n]);
  return o;
}, nd = new Ec(288);
for (var Nn = 0; Nn < 144; ++Nn) nd[Nn] = 8;
for (var Nn = 144; Nn < 256; ++Nn) nd[Nn] = 9;
for (var Nn = 256; Nn < 280; ++Nn) nd[Nn] = 7;
for (var Nn = 280; Nn < 288; ++Nn) nd[Nn] = 8;
var zy = new Ec(32);
for (var Nn = 0; Nn < 32; ++Nn) zy[Nn] = 5;
var pK = /* @__PURE__ */ $g(nd, 9), gK = /* @__PURE__ */ $g(zy, 5), lR = function(r) {
  return (r + 7) / 8 | 0;
}, mK = function(r, e, t) {
  return (t == null || t > r.length) && (t = r.length), new Ec(r.subarray(e, t));
}, Ju = function(r, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  r[i] |= t, r[i + 1] |= t >> 8;
}, yg = function(r, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  r[i] |= t, r[i + 1] |= t >> 8, r[i + 2] |= t >> 16;
}, v1 = function(r, e) {
  for (var t = [], i = 0; i < r.length; ++i) r[i] && t.push({ s: i, f: r[i] });
  var n = t.length, s = t.slice();
  if (!n) return { t: uR, l: 0 };
  if (n == 1) {
    var c = new Ec(t[0].s + 1);
    return c[t[0].s] = 1, { t: c, l: 1 };
  }
  t.sort(function(J, re) {
    return J.f - re.f;
  }), t.push({ s: -1, f: 25001 });
  var o = t[0], d = t[1], m = 0, y = 1, T = 2;
  for (t[0] = { s: -1, f: o.f + d.f, l: o, r: d }; y != n - 1; ) o = t[t[m].f < t[T].f ? m++ : T++], d = t[m != y && t[m].f < t[T].f ? m++ : T++], t[y++] = { s: -1, f: o.f + d.f, l: o, r: d };
  for (var P = s[0].s, i = 1; i < n; ++i) s[i].s > P && (P = s[i].s);
  var I = new Ol(P + 1), D = t2(t[y - 1], I, 0);
  if (D > e) {
    var i = 0, k = 0, $ = D - e, G = 1 << $;
    for (s.sort(function(re, be) {
      return I[be.s] - I[re.s] || re.f - be.f;
    }); i < n; ++i) {
      var te = s[i].s;
      if (I[te] > e) k += G - (1 << D - I[te]), I[te] = e;
      else break;
    }
    for (k >>= $; k > 0; ) {
      var Z = s[i].s;
      I[Z] < e ? k -= 1 << e - I[Z]++ - 1 : ++i;
    }
    for (; i >= 0 && k; --i) {
      var H = s[i].s;
      I[H] == e && (--I[H], ++k);
    }
    D = e;
  }
  return { t: new Ec(I), l: D };
}, t2 = function(r, e, t) {
  return r.s == -1 ? Math.max(t2(r.l, e, t + 1), t2(r.r, e, t + 1)) : e[r.s] = t;
}, EE = function(r) {
  for (var e = r.length; e && !r[--e]; ) ;
  for (var t = new Ol(++e), i = 0, n = r[0], s = 1, c = function(d) {
    t[i++] = d;
  }, o = 1; o <= e; ++o) if (r[o] == n && o != e) ++s;
  else {
    if (!n && s > 2) {
      for (; s > 138; s -= 138) c(32754);
      s > 2 && (c(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
    } else if (s > 3) {
      for (c(n), --s; s > 6; s -= 6) c(8304);
      s > 2 && (c(s - 3 << 5 | 8208), s = 0);
    }
    for (; s--; ) c(n);
    s = 1, n = r[o];
  }
  return { c: t.subarray(0, i), n: e };
}, bg = function(r, e) {
  for (var t = 0, i = 0; i < e.length; ++i) t += r[i] * e[i];
  return t;
}, cR = function(r, e, t) {
  var i = t.length, n = lR(e + 2);
  r[n] = i & 255, r[n + 1] = i >> 8, r[n + 2] = r[n] ^ 255, r[n + 3] = r[n + 1] ^ 255;
  for (var s = 0; s < i; ++s) r[n + s + 4] = t[s];
  return (n + 4 + i) * 8;
}, CE = function(r, e, t, i, n, s, c, o, d, m, y) {
  Ju(e, y++, t), ++n[256];
  for (var T = v1(n, 15), P = T.t, I = T.l, D = v1(s, 15), k = D.t, $ = D.l, G = EE(P), te = G.c, Z = G.n, H = EE(k), J = H.c, re = H.n, be = new Ol(19), pe = 0; pe < te.length; ++pe) ++be[te[pe] & 31];
  for (var pe = 0; pe < J.length; ++pe) ++be[J[pe] & 31];
  for (var oe = v1(be, 7), Ee = oe.t, le = oe.l, _e = 19; _e > 4 && !Ee[TE[_e - 1]]; --_e) ;
  var Ve = m + 5 << 3, Be = bg(n, nd) + bg(s, zy) + c, gt = bg(n, P) + bg(s, k) + c + 14 + 3 * _e + bg(be, Ee) + 2 * be[16] + 3 * be[17] + 7 * be[18];
  if (d >= 0 && Ve <= Be && Ve <= gt) return cR(e, y, r.subarray(d, d + m));
  var St, Mt, mt, wt;
  if (Ju(e, y, 1 + (gt < Be)), y += 2, gt < Be) {
    St = $g(P, I), Mt = P, mt = $g(k, $), wt = k;
    var Yt = $g(Ee, le);
    Ju(e, y, Z - 257), Ju(e, y + 5, re - 1), Ju(e, y + 10, _e - 4), y += 14;
    for (var pe = 0; pe < _e; ++pe) Ju(e, y + 3 * pe, Ee[TE[pe]]);
    y += 3 * _e;
    for (var Dt = [te, J], fe = 0; fe < 2; ++fe) for (var De = Dt[fe], pe = 0; pe < De.length; ++pe) {
      var je = De[pe] & 31;
      Ju(e, y, Yt[je]), y += Ee[je], je > 15 && (Ju(e, y, De[pe] >> 5 & 127), y += De[pe] >> 12);
    }
  } else St = pK, Mt = nd, mt = gK, wt = zy;
  for (var pe = 0; pe < o; ++pe) {
    var Ke = i[pe];
    if (Ke > 255) {
      var je = Ke >> 18 & 31;
      yg(e, y, St[je + 257]), y += Mt[je + 257], je > 7 && (Ju(e, y, Ke >> 23 & 31), y += Kx[je]);
      var rt = Ke & 31;
      yg(e, y, mt[rt]), y += wt[rt], rt > 3 && (yg(e, y, Ke >> 5 & 8191), y += Qx[rt]);
    } else yg(e, y, St[Ke]), y += Mt[Ke];
  }
  return yg(e, y, St[256]), y + Mt[256];
}, _K = /* @__PURE__ */ new Jx([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), uR = /* @__PURE__ */ new Ec(0), yK = function(r, e, t, i, n, s) {
  var c = s.z || r.length, o = new Ec(i + c + 5 * (1 + Math.ceil(c / 7e3)) + n), d = o.subarray(i, o.length - n), m = s.l, y = (s.r || 0) & 7;
  if (e) {
    y && (d[0] = s.r >> 3);
    for (var T = _K[e - 1], P = T >> 13, I = T & 8191, D = (1 << t) - 1, k = s.p || new Ol(32768), $ = s.h || new Ol(D + 1), G = Math.ceil(t / 3), te = 2 * G, Z = function(Ct) {
      return (r[Ct] ^ r[Ct + 1] << G ^ r[Ct + 2] << te) & D;
    }, H = new Jx(25e3), J = new Ol(288), re = new Ol(32), be = 0, pe = 0, oe = s.i || 0, Ee = 0, le = s.w || 0, _e = 0; oe + 2 < c; ++oe) {
      var Ve = Z(oe), Be = oe & 32767, gt = $[Ve];
      if (k[Be] = gt, $[Ve] = Be, le <= oe) {
        var St = c - oe;
        if ((be > 7e3 || Ee > 24576) && (St > 423 || !m)) {
          y = CE(r, d, 0, H, J, re, pe, Ee, _e, oe - _e, y), Ee = be = pe = 0, _e = oe;
          for (var Mt = 0; Mt < 286; ++Mt) J[Mt] = 0;
          for (var Mt = 0; Mt < 30; ++Mt) re[Mt] = 0;
        }
        var mt = 2, wt = 0, Yt = I, Dt = Be - gt & 32767;
        if (St > 2 && Ve == Z(oe - Dt)) for (var fe = Math.min(P, St) - 1, De = Math.min(32767, oe), je = Math.min(258, St); Dt <= De && --Yt && Be != gt; ) {
          if (r[oe + mt] == r[oe + mt - Dt]) {
            for (var Ke = 0; Ke < je && r[oe + Ke] == r[oe + Ke - Dt]; ++Ke) ;
            if (Ke > mt) {
              if (mt = Ke, wt = Dt, Ke > fe) break;
              for (var rt = Math.min(Dt, Ke - 2), at = 0, Mt = 0; Mt < rt; ++Mt) {
                var Et = oe - Dt + Mt & 32767, Tt = k[Et], Vt = Et - Tt & 32767;
                Vt > at && (at = Vt, gt = Et);
              }
            }
          }
          Be = gt, gt = k[Be], Dt += Be - gt & 32767;
        }
        if (wt) {
          H[Ee++] = 268435456 | e2[mt] << 18 | SE[wt];
          var tr = e2[mt] & 31, ur = SE[wt] & 31;
          pe += Kx[tr] + Qx[ur], ++J[257 + tr], ++re[ur], le = oe + mt, ++be;
        } else H[Ee++] = r[oe], ++J[r[oe]];
      }
    }
    for (oe = Math.max(oe, le); oe < c; ++oe) H[Ee++] = r[oe], ++J[r[oe]];
    y = CE(r, d, m, H, J, re, pe, Ee, _e, oe - _e, y), m || (s.r = y & 7 | d[y / 8 | 0] << 3, y -= 7, s.h = $, s.p = k, s.i = oe, s.w = le);
  } else {
    for (var oe = s.w || 0; oe < c + m; oe += 65535) {
      var dr = oe + 65535;
      dr >= c && (d[y / 8 | 0] = m, dr = c), y = cR(d, y + 1, r.subarray(oe, dr));
    }
    s.i = c;
  }
  return mK(o, 0, i + lR(y) + n);
}, hR = function() {
  var r = 1, e = 0;
  return { p: function(t) {
    for (var i = r, n = e, s = t.length | 0, c = 0; c != s; ) {
      for (var o = Math.min(c + 2655, s); c < o; ++c) n += i += t[c];
      i = (i & 65535) + 15 * (i >> 16), n = (n & 65535) + 15 * (n >> 16);
    }
    r = i, e = n;
  }, d: function() {
    return r %= 65521, e %= 65521, (r & 255) << 24 | (r & 65280) << 8 | (e & 255) << 8 | e >> 8;
  } };
}, bK = function(r, e, t, i, n) {
  if (!n && (n = { l: 1 }, e.dictionary)) {
    var s = e.dictionary.subarray(-32768), c = new Ec(s.length + r.length);
    c.set(s), c.set(r, s.length), r = c, n.w = s.length;
  }
  return yK(r, e.level == null ? 6 : e.level, e.mem == null ? n.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 20 : 12 + e.mem, t, i, n);
}, fR = function(r, e, t) {
  for (; t; ++e) r[e] = t, t >>>= 8;
}, vK = function(r, e) {
  var t = e.level, i = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  if (r[0] = 120, r[1] = i << 6 | (e.dictionary && 32), r[1] |= 31 - (r[0] << 8 | r[1]) % 31, e.dictionary) {
    var n = hR();
    n.p(e.dictionary), fR(r, 2, n.d());
  }
};
function r2(r, e) {
  e || (e = {});
  var t = hR();
  t.p(r);
  var i = bK(r, e, e.dictionary ? 6 : 2, 4);
  return vK(i, e), fR(i, i.length - 4, t.d()), i;
}
var xK = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), wK = 0;
try {
  xK.decode(uR, { stream: !0 }), wK = 1;
} catch {
}
function AK(r) {
  if (Array.isArray(r)) return r;
}
function TK(r, e) {
  var t = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (t != null) {
    var i, n, s, c, o = [], d = !0, m = !1;
    try {
      if (s = (t = t.call(r)).next, e !== 0) for (; !(d = (i = s.call(t)).done) && (o.push(i.value), o.length !== e); d = !0) ;
    } catch (y) {
      m = !0, n = y;
    } finally {
      try {
        if (!d && t.return != null && (c = t.return(), Object(c) !== c)) return;
      } finally {
        if (m) throw n;
      }
    }
    return o;
  }
}
function IE(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, i = Array(e); t < e; t++) i[t] = r[t];
  return i;
}
function SK(r, e) {
  if (r) {
    if (typeof r == "string") return IE(r, e);
    var t = {}.toString.call(r).slice(8, -1);
    return t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set" ? Array.from(r) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? IE(r, e) : void 0;
  }
}
function EK() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function PE(r, e) {
  return AK(r) || TK(r, e) || SK(r, e) || EK();
}
function ME(r, e = "utf8") {
  return new TextDecoder(e).decode(r);
}
const CK = new TextEncoder();
function IK(r) {
  return CK.encode(r);
}
const PK = 1024 * 8, MK = (() => {
  const r = new Uint8Array(4), e = new Uint32Array(r.buffer);
  return !((e[0] = 1) & r[0]);
})(), x1 = { int8: globalThis.Int8Array, uint8: globalThis.Uint8Array, int16: globalThis.Int16Array, uint16: globalThis.Uint16Array, int32: globalThis.Int32Array, uint32: globalThis.Uint32Array, uint64: globalThis.BigUint64Array, int64: globalThis.BigInt64Array, float32: globalThis.Float32Array, float64: globalThis.Float64Array };
class ew {
  /**
  * Reference to the internal ArrayBuffer object.
  */
  buffer;
  /**
  * Byte length of the internal ArrayBuffer.
  */
  byteLength;
  /**
  * Byte offset of the internal ArrayBuffer.
  */
  byteOffset;
  /**
  * Byte length of the internal ArrayBuffer.
  */
  length;
  /**
  * The current offset of the buffer's pointer.
  */
  offset;
  lastWrittenByte;
  littleEndian;
  _data;
  _mark;
  _marks;
  /**
  * Create a new IOBuffer.
  * @param data - The data to construct the IOBuffer with.
  * If data is a number, it will be the new buffer's length<br>
  * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
  * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
  * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
  * @param options - An object for the options.
  * @returns A new IOBuffer instance.
  */
  constructor(e = PK, t = {}) {
    let i = !1;
    typeof e == "number" ? e = new ArrayBuffer(e) : (i = !0, this.lastWrittenByte = e.byteLength);
    const n = t.offset ? t.offset >>> 0 : 0, s = e.byteLength - n;
    let c = n;
    (ArrayBuffer.isView(e) || e instanceof ew) && (e.byteLength !== e.buffer.byteLength && (c = e.byteOffset + n), e = e.buffer), i ? this.lastWrittenByte = s : this.lastWrittenByte = 0, this.buffer = e, this.length = s, this.byteLength = s, this.byteOffset = c, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, c, s), this._mark = 0, this._marks = [];
  }
  /**
  * Checks if the memory allocated to the buffer is sufficient to store more
  * bytes after the offset.
  * @param byteLength - The needed memory in bytes.
  * @returns `true` if there is sufficient space and `false` otherwise.
  */
  available(e = 1) {
    return this.offset + e <= this.length;
  }
  /**
  * Check if little-endian mode is used for reading and writing multi-byte
  * values.
  * @returns `true` if little-endian mode is used, `false` otherwise.
  */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
  * Set little-endian mode for reading and writing multi-byte values.
  * @returns This.
  */
  setLittleEndian() {
    return this.littleEndian = !0, this;
  }
  /**
  * Check if big-endian mode is used for reading and writing multi-byte values.
  * @returns `true` if big-endian mode is used, `false` otherwise.
  */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
  * Switches to big-endian mode for reading and writing multi-byte values.
  * @returns This.
  */
  setBigEndian() {
    return this.littleEndian = !1, this;
  }
  /**
  * Move the pointer n bytes forward.
  * @param n - Number of bytes to skip.
  * @returns This.
  */
  skip(e = 1) {
    return this.offset += e, this;
  }
  /**
  * Move the pointer n bytes backward.
  * @param n - Number of bytes to move back.
  * @returns This.
  */
  back(e = 1) {
    return this.offset -= e, this;
  }
  /**
  * Move the pointer to the given offset.
  * @param offset - The offset to move to.
  * @returns This.
  */
  seek(e) {
    return this.offset = e, this;
  }
  /**
  * Store the current pointer offset.
  * @see {@link IOBuffer#reset}
  * @returns This.
  */
  mark() {
    return this._mark = this.offset, this;
  }
  /**
  * Move the pointer back to the last pointer offset set by mark.
  * @see {@link IOBuffer#mark}
  * @returns This.
  */
  reset() {
    return this.offset = this._mark, this;
  }
  /**
  * Push the current pointer offset to the mark stack.
  * @see {@link IOBuffer#popMark}
  * @returns This.
  */
  pushMark() {
    return this._marks.push(this.offset), this;
  }
  /**
  * Pop the last pointer offset from the mark stack, and set the current
  * pointer offset to the popped value.
  * @see {@link IOBuffer#pushMark}
  * @returns This.
  */
  popMark() {
    const e = this._marks.pop();
    if (e === void 0) throw new Error("Mark stack empty");
    return this.seek(e), this;
  }
  /**
  * Move the pointer offset back to 0.
  * @returns This.
  */
  rewind() {
    return this.offset = 0, this;
  }
  /**
  * Make sure the buffer has sufficient memory to write a given byteLength at
  * the current pointer offset.
  * If the buffer's memory is insufficient, this method will create a new
  * buffer (a copy) with a length that is twice (byteLength + current offset).
  * @param byteLength - The needed memory in bytes.
  * @returns This.
  */
  ensureAvailable(e = 1) {
    if (!this.available(e)) {
      const t = (this.offset + e) * 2, i = new Uint8Array(t);
      i.set(new Uint8Array(this.buffer)), this.buffer = i.buffer, this.length = t, this.byteLength = t, this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
  * Read a byte and return false if the byte's value is 0, or true otherwise.
  * Moves pointer forward by one byte.
  * @returns The read boolean.
  */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
  * Read a signed 8-bit integer and move pointer forward by 1 byte.
  * @returns The read byte.
  */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
  * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
  * @returns The read byte.
  */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
  * Alias for {@link IOBuffer#readUint8}.
  * @returns The read byte.
  */
  readByte() {
    return this.readUint8();
  }
  /**
  * Read `n` bytes and move pointer forward by `n` bytes.
  * @param n - Number of bytes to read.
  * @returns The read bytes.
  */
  readBytes(e = 1) {
    return this.readArray(e, "uint8");
  }
  /**
  * Creates an array of corresponding to the type `type` and size `size`.
  * For example type `uint8` will create a `Uint8Array`.
  * @param size - size of the resulting array
  * @param type - number type of elements to read
  * @returns The read array.
  */
  readArray(e, t) {
    const i = x1[t].BYTES_PER_ELEMENT * e, n = this.byteOffset + this.offset, s = this.buffer.slice(n, n + i);
    if (this.littleEndian === MK && t !== "uint8" && t !== "int8") {
      const o = new Uint8Array(this.buffer.slice(n, n + i));
      o.reverse();
      const d = new x1[t](o.buffer);
      return this.offset += i, d.reverse(), d;
    }
    const c = new x1[t](s);
    return this.offset += i, c;
  }
  /**
  * Read a 16-bit signed integer and move pointer forward by 2 bytes.
  * @returns The read value.
  */
  readInt16() {
    const e = this._data.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  /**
  * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
  * @returns The read value.
  */
  readUint16() {
    const e = this._data.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  /**
  * Read a 32-bit signed integer and move pointer forward by 4 bytes.
  * @returns The read value.
  */
  readInt32() {
    const e = this._data.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  /**
  * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
  * @returns The read value.
  */
  readUint32() {
    const e = this._data.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  /**
  * Read a 32-bit floating number and move pointer forward by 4 bytes.
  * @returns The read value.
  */
  readFloat32() {
    const e = this._data.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  /**
  * Read a 64-bit floating number and move pointer forward by 8 bytes.
  * @returns The read value.
  */
  readFloat64() {
    const e = this._data.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  /**
  * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
  * @returns The read value.
  */
  readBigInt64() {
    const e = this._data.getBigInt64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  /**
  * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
  * @returns The read value.
  */
  readBigUint64() {
    const e = this._data.getBigUint64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  /**
  * Read a 1-byte ASCII character and move pointer forward by 1 byte.
  * @returns The read character.
  */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
  * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
  * @param n - Number of characters to read.
  * @returns The read characters.
  */
  readChars(e = 1) {
    let t = "";
    for (let i = 0; i < e; i++) t += this.readChar();
    return t;
  }
  /**
  * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
  * forward by `n` bytes.
  * @param n - Number of bytes to read.
  * @returns The decoded string.
  */
  readUtf8(e = 1) {
    return ME(this.readBytes(e));
  }
  /**
  * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
  * forward by `n` bytes.
  * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
  * @param n - Number of bytes to read.
  * @param encoding - The encoding to use. Default is 'utf8'.
  * @returns The decoded string.
  */
  decodeText(e = 1, t = "utf8") {
    return ME(this.readBytes(e), t);
  }
  /**
  * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
  * forward by 1 byte.
  * @param value - The value to write.
  * @returns This.
  */
  writeBoolean(e) {
    return this.writeUint8(e ? 255 : 0), this;
  }
  /**
  * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
  * @param value - The value to write.
  * @returns This.
  */
  writeInt8(e) {
    return this.ensureAvailable(1), this._data.setInt8(this.offset++, e), this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
  * byte.
  * @param value - The value to write.
  * @returns This.
  */
  writeUint8(e) {
    return this.ensureAvailable(1), this._data.setUint8(this.offset++, e), this._updateLastWrittenByte(), this;
  }
  /**
  * An alias for {@link IOBuffer#writeUint8}.
  * @param value - The value to write.
  * @returns This.
  */
  writeByte(e) {
    return this.writeUint8(e);
  }
  /**
  * Write all elements of `bytes` as uint8 values and move pointer forward by
  * `bytes.length` bytes.
  * @param bytes - The array of bytes to write.
  * @returns This.
  */
  writeBytes(e) {
    this.ensureAvailable(e.length);
    for (let t = 0; t < e.length; t++) this._data.setUint8(this.offset++, e[t]);
    return this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 16-bit signed integer and move pointer forward by 2
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeInt16(e) {
    return this.ensureAvailable(2), this._data.setInt16(this.offset, e, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeUint16(e) {
    return this.ensureAvailable(2), this._data.setUint16(this.offset, e, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 32-bit signed integer and move pointer forward by 4
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeInt32(e) {
    return this.ensureAvailable(4), this._data.setInt32(this.offset, e, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeUint32(e) {
    return this.ensureAvailable(4), this._data.setUint32(this.offset, e, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 32-bit floating number and move pointer forward by 4
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeFloat32(e) {
    return this.ensureAvailable(4), this._data.setFloat32(this.offset, e, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 64-bit floating number and move pointer forward by 8
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeFloat64(e) {
    return this.ensureAvailable(8), this._data.setFloat64(this.offset, e, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 64-bit signed bigint and move pointer forward by 8
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeBigInt64(e) {
    return this.ensureAvailable(8), this._data.setBigInt64(this.offset, e, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
  * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
  * bytes.
  * @param value - The value to write.
  * @returns This.
  */
  writeBigUint64(e) {
    return this.ensureAvailable(8), this._data.setBigUint64(this.offset, e, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
  * Write the charCode of `str`'s first character as an 8-bit unsigned integer
  * and move pointer forward by 1 byte.
  * @param str - The character to write.
  * @returns This.
  */
  writeChar(e) {
    return this.writeUint8(e.charCodeAt(0));
  }
  /**
  * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
  * and move pointer forward by `str.length` bytes.
  * @param str - The characters to write.
  * @returns This.
  */
  writeChars(e) {
    for (let t = 0; t < e.length; t++) this.writeUint8(e.charCodeAt(t));
    return this;
  }
  /**
  * UTF-8 encode and write `str` to the current pointer offset and move pointer
  * forward according to the encoded length.
  * @param str - The string to write.
  * @returns This.
  */
  writeUtf8(e) {
    return this.writeBytes(IK(e));
  }
  /**
  * Export a Uint8Array view of the internal buffer.
  * The view starts at the byte offset and its length
  * is calculated to stop at the last written byte or the original length.
  * @returns A new Uint8Array view.
  */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
  *  Get the total number of bytes written so far, regardless of the current offset.
  * @returns - Total number of bytes.
  */
  getWrittenByteLength() {
    return this.lastWrittenByte - this.byteOffset;
  }
  /**
  * Update the last written byte offset
  * @private
  */
  _updateLastWrittenByte() {
    this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
  }
}
function jp(r) {
  let e = r.length;
  for (; --e >= 0; ) r[e] = 0;
}
const RK = 3, LK = 258, dR = 29, BK = 256, kK = BK + 1 + dR, pR = 30, OK = 512, DK = new Array((kK + 2) * 2);
jp(DK);
const NK = new Array(pR * 2);
jp(NK);
const FK = new Array(OK);
jp(FK);
const UK = new Array(LK - RK + 1);
jp(UK);
const zK = new Array(dR);
jp(zK);
const jK = new Array(pR);
jp(jK);
const VK = (r, e, t, i) => {
  let n = r & 65535 | 0, s = r >>> 16 & 65535 | 0, c = 0;
  for (; t !== 0; ) {
    c = t > 2e3 ? 2e3 : t, t -= c;
    do
      n = n + e[i++] | 0, s = s + n | 0;
    while (--c);
    n %= 65521, s %= 65521;
  }
  return n | s << 16 | 0;
};
var i2 = VK;
const GK = () => {
  let r, e = [];
  for (var t = 0; t < 256; t++) {
    r = t;
    for (var i = 0; i < 8; i++) r = r & 1 ? 3988292384 ^ r >>> 1 : r >>> 1;
    e[t] = r;
  }
  return e;
}, $K = new Uint32Array(GK()), HK = (r, e, t, i) => {
  const n = $K, s = i + t;
  r ^= -1;
  for (let c = i; c < s; c++) r = r >>> 8 ^ n[(r ^ e[c]) & 255];
  return r ^ -1;
};
var uu = HK, n2 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, gR = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const qK = (r, e) => Object.prototype.hasOwnProperty.call(r, e);
var WK = function(r) {
  const e = Array.prototype.slice.call(arguments, 1);
  for (; e.length; ) {
    const t = e.shift();
    if (t) {
      if (typeof t != "object") throw new TypeError(t + "must be non-object");
      for (const i in t) qK(t, i) && (r[i] = t[i]);
    }
  }
  return r;
}, XK = (r) => {
  let e = 0;
  for (let i = 0, n = r.length; i < n; i++) e += r[i].length;
  const t = new Uint8Array(e);
  for (let i = 0, n = 0, s = r.length; i < s; i++) {
    let c = r[i];
    t.set(c, n), n += c.length;
  }
  return t;
}, mR = { assign: WK, flattenChunks: XK };
let _R = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  _R = !1;
}
const om = new Uint8Array(256);
for (let r = 0; r < 256; r++) om[r] = r >= 252 ? 6 : r >= 248 ? 5 : r >= 240 ? 4 : r >= 224 ? 3 : r >= 192 ? 2 : 1;
om[254] = om[254] = 1;
var ZK = (r) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(r);
  let e, t, i, n, s, c = r.length, o = 0;
  for (n = 0; n < c; n++) t = r.charCodeAt(n), (t & 64512) === 55296 && n + 1 < c && (i = r.charCodeAt(n + 1), (i & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (i - 56320), n++)), o += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
  for (e = new Uint8Array(o), s = 0, n = 0; s < o; n++) t = r.charCodeAt(n), (t & 64512) === 55296 && n + 1 < c && (i = r.charCodeAt(n + 1), (i & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (i - 56320), n++)), t < 128 ? e[s++] = t : t < 2048 ? (e[s++] = 192 | t >>> 6, e[s++] = 128 | t & 63) : t < 65536 ? (e[s++] = 224 | t >>> 12, e[s++] = 128 | t >>> 6 & 63, e[s++] = 128 | t & 63) : (e[s++] = 240 | t >>> 18, e[s++] = 128 | t >>> 12 & 63, e[s++] = 128 | t >>> 6 & 63, e[s++] = 128 | t & 63);
  return e;
};
const YK = (r, e) => {
  if (e < 65534 && r.subarray && _R) return String.fromCharCode.apply(null, r.length === e ? r : r.subarray(0, e));
  let t = "";
  for (let i = 0; i < e; i++) t += String.fromCharCode(r[i]);
  return t;
};
var JK = (r, e) => {
  const t = e || r.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(r.subarray(0, e));
  let i, n;
  const s = new Array(t * 2);
  for (n = 0, i = 0; i < t; ) {
    let c = r[i++];
    if (c < 128) {
      s[n++] = c;
      continue;
    }
    let o = om[c];
    if (o > 4) {
      s[n++] = 65533, i += o - 1;
      continue;
    }
    for (c &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && i < t; ) c = c << 6 | r[i++] & 63, o--;
    if (o > 1) {
      s[n++] = 65533;
      continue;
    }
    c < 65536 ? s[n++] = c : (c -= 65536, s[n++] = 55296 | c >> 10 & 1023, s[n++] = 56320 | c & 1023);
  }
  return YK(s, n);
}, KK = (r, e) => {
  e = e || r.length, e > r.length && (e = r.length);
  let t = e - 1;
  for (; t >= 0 && (r[t] & 192) === 128; ) t--;
  return t < 0 || t === 0 ? e : t + om[r[t]] > e ? t : e;
}, s2 = { string2buf: ZK, buf2string: JK, utf8border: KK };
function QK() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var eQ = QK;
const T_ = 16209, tQ = 16191;
var rQ = function(r, e) {
  let t, i, n, s, c, o, d, m, y, T, P, I, D, k, $, G, te, Z, H, J, re, be, pe, oe;
  const Ee = r.state;
  t = r.next_in, pe = r.input, i = t + (r.avail_in - 5), n = r.next_out, oe = r.output, s = n - (e - r.avail_out), c = n + (r.avail_out - 257), o = Ee.dmax, d = Ee.wsize, m = Ee.whave, y = Ee.wnext, T = Ee.window, P = Ee.hold, I = Ee.bits, D = Ee.lencode, k = Ee.distcode, $ = (1 << Ee.lenbits) - 1, G = (1 << Ee.distbits) - 1;
  e: do {
    I < 15 && (P += pe[t++] << I, I += 8, P += pe[t++] << I, I += 8), te = D[P & $];
    t: for (; ; ) {
      if (Z = te >>> 24, P >>>= Z, I -= Z, Z = te >>> 16 & 255, Z === 0) oe[n++] = te & 65535;
      else if (Z & 16) {
        H = te & 65535, Z &= 15, Z && (I < Z && (P += pe[t++] << I, I += 8), H += P & (1 << Z) - 1, P >>>= Z, I -= Z), I < 15 && (P += pe[t++] << I, I += 8, P += pe[t++] << I, I += 8), te = k[P & G];
        r: for (; ; ) {
          if (Z = te >>> 24, P >>>= Z, I -= Z, Z = te >>> 16 & 255, Z & 16) {
            if (J = te & 65535, Z &= 15, I < Z && (P += pe[t++] << I, I += 8, I < Z && (P += pe[t++] << I, I += 8)), J += P & (1 << Z) - 1, J > o) {
              r.msg = "invalid distance too far back", Ee.mode = T_;
              break e;
            }
            if (P >>>= Z, I -= Z, Z = n - s, J > Z) {
              if (Z = J - Z, Z > m && Ee.sane) {
                r.msg = "invalid distance too far back", Ee.mode = T_;
                break e;
              }
              if (re = 0, be = T, y === 0) {
                if (re += d - Z, Z < H) {
                  H -= Z;
                  do
                    oe[n++] = T[re++];
                  while (--Z);
                  re = n - J, be = oe;
                }
              } else if (y < Z) {
                if (re += d + y - Z, Z -= y, Z < H) {
                  H -= Z;
                  do
                    oe[n++] = T[re++];
                  while (--Z);
                  if (re = 0, y < H) {
                    Z = y, H -= Z;
                    do
                      oe[n++] = T[re++];
                    while (--Z);
                    re = n - J, be = oe;
                  }
                }
              } else if (re += y - Z, Z < H) {
                H -= Z;
                do
                  oe[n++] = T[re++];
                while (--Z);
                re = n - J, be = oe;
              }
              for (; H > 2; ) oe[n++] = be[re++], oe[n++] = be[re++], oe[n++] = be[re++], H -= 3;
              H && (oe[n++] = be[re++], H > 1 && (oe[n++] = be[re++]));
            } else {
              re = n - J;
              do
                oe[n++] = oe[re++], oe[n++] = oe[re++], oe[n++] = oe[re++], H -= 3;
              while (H > 2);
              H && (oe[n++] = oe[re++], H > 1 && (oe[n++] = oe[re++]));
            }
          } else if ((Z & 64) === 0) {
            te = k[(te & 65535) + (P & (1 << Z) - 1)];
            continue r;
          } else {
            r.msg = "invalid distance code", Ee.mode = T_;
            break e;
          }
          break;
        }
      } else if ((Z & 64) === 0) {
        te = D[(te & 65535) + (P & (1 << Z) - 1)];
        continue t;
      } else if (Z & 32) {
        Ee.mode = tQ;
        break e;
      } else {
        r.msg = "invalid literal/length code", Ee.mode = T_;
        break e;
      }
      break;
    }
  } while (t < i && n < c);
  H = I >> 3, t -= H, I -= H << 3, P &= (1 << I) - 1, r.next_in = t, r.next_out = n, r.avail_in = t < i ? 5 + (i - t) : 5 - (t - i), r.avail_out = n < c ? 257 + (c - n) : 257 - (n - c), Ee.hold = P, Ee.bits = I;
};
const qd = 15, RE = 852, LE = 592, BE = 0, w1 = 1, kE = 2, iQ = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), nQ = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), sQ = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), oQ = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), aQ = (r, e, t, i, n, s, c, o) => {
  const d = o.bits;
  let m = 0, y = 0, T = 0, P = 0, I = 0, D = 0, k = 0, $ = 0, G = 0, te = 0, Z, H, J, re, be, pe = null, oe;
  const Ee = new Uint16Array(qd + 1), le = new Uint16Array(qd + 1);
  let _e = null, Ve, Be, gt;
  for (m = 0; m <= qd; m++) Ee[m] = 0;
  for (y = 0; y < i; y++) Ee[e[t + y]]++;
  for (I = d, P = qd; P >= 1 && Ee[P] === 0; P--) ;
  if (I > P && (I = P), P === 0) return n[s++] = 1 << 24 | 64 << 16 | 0, n[s++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
  for (T = 1; T < P && Ee[T] === 0; T++) ;
  for (I < T && (I = T), $ = 1, m = 1; m <= qd; m++) if ($ <<= 1, $ -= Ee[m], $ < 0) return -1;
  if ($ > 0 && (r === BE || P !== 1)) return -1;
  for (le[1] = 0, m = 1; m < qd; m++) le[m + 1] = le[m] + Ee[m];
  for (y = 0; y < i; y++) e[t + y] !== 0 && (c[le[e[t + y]]++] = y);
  if (r === BE ? (pe = _e = c, oe = 20) : r === w1 ? (pe = iQ, _e = nQ, oe = 257) : (pe = sQ, _e = oQ, oe = 0), te = 0, y = 0, m = T, be = s, D = I, k = 0, J = -1, G = 1 << I, re = G - 1, r === w1 && G > RE || r === kE && G > LE) return 1;
  for (; ; ) {
    Ve = m - k, c[y] + 1 < oe ? (Be = 0, gt = c[y]) : c[y] >= oe ? (Be = _e[c[y] - oe], gt = pe[c[y] - oe]) : (Be = 96, gt = 0), Z = 1 << m - k, H = 1 << D, T = H;
    do
      H -= Z, n[be + (te >> k) + H] = Ve << 24 | Be << 16 | gt | 0;
    while (H !== 0);
    for (Z = 1 << m - 1; te & Z; ) Z >>= 1;
    if (Z !== 0 ? (te &= Z - 1, te += Z) : te = 0, y++, --Ee[m] === 0) {
      if (m === P) break;
      m = e[t + c[y]];
    }
    if (m > I && (te & re) !== J) {
      for (k === 0 && (k = I), be += T, D = m - k, $ = 1 << D; D + k < P && ($ -= Ee[D + k], !($ <= 0)); ) D++, $ <<= 1;
      if (G += 1 << D, r === w1 && G > RE || r === kE && G > LE) return 1;
      J = te & re, n[J] = I << 24 | D << 16 | be - s | 0;
    }
  }
  return te !== 0 && (n[be + te] = m - k << 24 | 64 << 16 | 0), o.bits = I, 0;
};
var Hg = aQ;
const lQ = 0, yR = 1, bR = 2, { Z_FINISH: OE, Z_BLOCK: cQ, Z_TREES: S_, Z_OK: sd, Z_STREAM_END: uQ, Z_NEED_DICT: hQ, Z_STREAM_ERROR: Cc, Z_DATA_ERROR: vR, Z_MEM_ERROR: xR, Z_BUF_ERROR: fQ, Z_DEFLATED: DE } = gR, u0 = 16180, NE = 16181, FE = 16182, UE = 16183, zE = 16184, jE = 16185, VE = 16186, GE = 16187, $E = 16188, HE = 16189, jy = 16190, Ku = 16191, A1 = 16192, qE = 16193, T1 = 16194, WE = 16195, XE = 16196, ZE = 16197, YE = 16198, E_ = 16199, C_ = 16200, JE = 16201, KE = 16202, QE = 16203, eC = 16204, tC = 16205, S1 = 16206, rC = 16207, iC = 16208, Gn = 16209, wR = 16210, AR = 16211, dQ = 852, pQ = 592, gQ = 15, mQ = gQ, nC = (r) => (r >>> 24 & 255) + (r >>> 8 & 65280) + ((r & 65280) << 8) + ((r & 255) << 24);
function _Q() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const hd = (r) => {
  if (!r) return 1;
  const e = r.state;
  return !e || e.strm !== r || e.mode < u0 || e.mode > AR ? 1 : 0;
}, TR = (r) => {
  if (hd(r)) return Cc;
  const e = r.state;
  return r.total_in = r.total_out = e.total = 0, r.msg = "", e.wrap && (r.adler = e.wrap & 1), e.mode = u0, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(dQ), e.distcode = e.distdyn = new Int32Array(pQ), e.sane = 1, e.back = -1, sd;
}, SR = (r) => {
  if (hd(r)) return Cc;
  const e = r.state;
  return e.wsize = 0, e.whave = 0, e.wnext = 0, TR(r);
}, ER = (r, e) => {
  let t;
  if (hd(r)) return Cc;
  const i = r.state;
  return e < 0 ? (t = 0, e = -e) : (t = (e >> 4) + 5, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? Cc : (i.window !== null && i.wbits !== e && (i.window = null), i.wrap = t, i.wbits = e, SR(r));
}, CR = (r, e) => {
  if (!r) return Cc;
  const t = new _Q();
  r.state = t, t.strm = r, t.window = null, t.mode = u0;
  const i = ER(r, e);
  return i !== sd && (r.state = null), i;
}, yQ = (r) => CR(r, mQ);
let sC = !0, E1, C1;
const bQ = (r) => {
  if (sC) {
    E1 = new Int32Array(512), C1 = new Int32Array(32);
    let e = 0;
    for (; e < 144; ) r.lens[e++] = 8;
    for (; e < 256; ) r.lens[e++] = 9;
    for (; e < 280; ) r.lens[e++] = 7;
    for (; e < 288; ) r.lens[e++] = 8;
    for (Hg(yR, r.lens, 0, 288, E1, 0, r.work, { bits: 9 }), e = 0; e < 32; ) r.lens[e++] = 5;
    Hg(bR, r.lens, 0, 32, C1, 0, r.work, { bits: 5 }), sC = !1;
  }
  r.lencode = E1, r.lenbits = 9, r.distcode = C1, r.distbits = 5;
}, IR = (r, e, t, i) => {
  let n;
  const s = r.state;
  return s.window === null && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), i >= s.wsize ? (s.window.set(e.subarray(t - s.wsize, t), 0), s.wnext = 0, s.whave = s.wsize) : (n = s.wsize - s.wnext, n > i && (n = i), s.window.set(e.subarray(t - i, t - i + n), s.wnext), i -= n, i ? (s.window.set(e.subarray(t - i, t), 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += n, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += n))), 0;
}, vQ = (r, e) => {
  let t, i, n, s, c, o, d, m, y, T, P, I, D, k, $ = 0, G, te, Z, H, J, re, be, pe;
  const oe = new Uint8Array(4);
  let Ee, le;
  const _e = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (hd(r) || !r.output || !r.input && r.avail_in !== 0) return Cc;
  t = r.state, t.mode === Ku && (t.mode = A1), c = r.next_out, n = r.output, d = r.avail_out, s = r.next_in, i = r.input, o = r.avail_in, m = t.hold, y = t.bits, T = o, P = d, pe = sd;
  e: for (; ; ) switch (t.mode) {
    case u0:
      if (t.wrap === 0) {
        t.mode = A1;
        break;
      }
      for (; y < 16; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      if (t.wrap & 2 && m === 35615) {
        t.wbits === 0 && (t.wbits = 15), t.check = 0, oe[0] = m & 255, oe[1] = m >>> 8 & 255, t.check = uu(t.check, oe, 2, 0), m = 0, y = 0, t.mode = NE;
        break;
      }
      if (t.head && (t.head.done = !1), !(t.wrap & 1) || /* check if zlib header allowed */
      (((m & 255) << 8) + (m >> 8)) % 31) {
        r.msg = "incorrect header check", t.mode = Gn;
        break;
      }
      if ((m & 15) !== DE) {
        r.msg = "unknown compression method", t.mode = Gn;
        break;
      }
      if (m >>>= 4, y -= 4, be = (m & 15) + 8, t.wbits === 0 && (t.wbits = be), be > 15 || be > t.wbits) {
        r.msg = "invalid window size", t.mode = Gn;
        break;
      }
      t.dmax = 1 << t.wbits, t.flags = 0, r.adler = t.check = 1, t.mode = m & 512 ? HE : Ku, m = 0, y = 0;
      break;
    case NE:
      for (; y < 16; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      if (t.flags = m, (t.flags & 255) !== DE) {
        r.msg = "unknown compression method", t.mode = Gn;
        break;
      }
      if (t.flags & 57344) {
        r.msg = "unknown header flags set", t.mode = Gn;
        break;
      }
      t.head && (t.head.text = m >> 8 & 1), t.flags & 512 && t.wrap & 4 && (oe[0] = m & 255, oe[1] = m >>> 8 & 255, t.check = uu(t.check, oe, 2, 0)), m = 0, y = 0, t.mode = FE;
    /* falls through */
    case FE:
      for (; y < 32; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      t.head && (t.head.time = m), t.flags & 512 && t.wrap & 4 && (oe[0] = m & 255, oe[1] = m >>> 8 & 255, oe[2] = m >>> 16 & 255, oe[3] = m >>> 24 & 255, t.check = uu(t.check, oe, 4, 0)), m = 0, y = 0, t.mode = UE;
    /* falls through */
    case UE:
      for (; y < 16; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      t.head && (t.head.xflags = m & 255, t.head.os = m >> 8), t.flags & 512 && t.wrap & 4 && (oe[0] = m & 255, oe[1] = m >>> 8 & 255, t.check = uu(t.check, oe, 2, 0)), m = 0, y = 0, t.mode = zE;
    /* falls through */
    case zE:
      if (t.flags & 1024) {
        for (; y < 16; ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        t.length = m, t.head && (t.head.extra_len = m), t.flags & 512 && t.wrap & 4 && (oe[0] = m & 255, oe[1] = m >>> 8 & 255, t.check = uu(t.check, oe, 2, 0)), m = 0, y = 0;
      } else t.head && (t.head.extra = null);
      t.mode = jE;
    /* falls through */
    case jE:
      if (t.flags & 1024 && (I = t.length, I > o && (I = o), I && (t.head && (be = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(
        i.subarray(
          s,
          // extra field is limited to 65536 bytes
          // - no need for additional size check
          s + I
        ),
        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
        be
      )), t.flags & 512 && t.wrap & 4 && (t.check = uu(t.check, i, I, s)), o -= I, s += I, t.length -= I), t.length)) break e;
      t.length = 0, t.mode = VE;
    /* falls through */
    case VE:
      if (t.flags & 2048) {
        if (o === 0) break e;
        I = 0;
        do
          be = i[s + I++], t.head && be && t.length < 65536 && (t.head.name += String.fromCharCode(be));
        while (be && I < o);
        if (t.flags & 512 && t.wrap & 4 && (t.check = uu(t.check, i, I, s)), o -= I, s += I, be) break e;
      } else t.head && (t.head.name = null);
      t.length = 0, t.mode = GE;
    /* falls through */
    case GE:
      if (t.flags & 4096) {
        if (o === 0) break e;
        I = 0;
        do
          be = i[s + I++], t.head && be && t.length < 65536 && (t.head.comment += String.fromCharCode(be));
        while (be && I < o);
        if (t.flags & 512 && t.wrap & 4 && (t.check = uu(t.check, i, I, s)), o -= I, s += I, be) break e;
      } else t.head && (t.head.comment = null);
      t.mode = $E;
    /* falls through */
    case $E:
      if (t.flags & 512) {
        for (; y < 16; ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        if (t.wrap & 4 && m !== (t.check & 65535)) {
          r.msg = "header crc mismatch", t.mode = Gn;
          break;
        }
        m = 0, y = 0;
      }
      t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), r.adler = t.check = 0, t.mode = Ku;
      break;
    case HE:
      for (; y < 32; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      r.adler = t.check = nC(m), m = 0, y = 0, t.mode = jy;
    /* falls through */
    case jy:
      if (t.havedict === 0) return r.next_out = c, r.avail_out = d, r.next_in = s, r.avail_in = o, t.hold = m, t.bits = y, hQ;
      r.adler = t.check = 1, t.mode = Ku;
    /* falls through */
    case Ku:
      if (e === cQ || e === S_) break e;
    /* falls through */
    case A1:
      if (t.last) {
        m >>>= y & 7, y -= y & 7, t.mode = S1;
        break;
      }
      for (; y < 3; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      switch (t.last = m & 1, m >>>= 1, y -= 1, m & 3) {
        case 0:
          t.mode = qE;
          break;
        case 1:
          if (bQ(t), t.mode = E_, e === S_) {
            m >>>= 2, y -= 2;
            break e;
          }
          break;
        case 2:
          t.mode = XE;
          break;
        case 3:
          r.msg = "invalid block type", t.mode = Gn;
      }
      m >>>= 2, y -= 2;
      break;
    case qE:
      for (m >>>= y & 7, y -= y & 7; y < 32; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      if ((m & 65535) !== (m >>> 16 ^ 65535)) {
        r.msg = "invalid stored block lengths", t.mode = Gn;
        break;
      }
      if (t.length = m & 65535, m = 0, y = 0, t.mode = T1, e === S_) break e;
    /* falls through */
    case T1:
      t.mode = WE;
    /* falls through */
    case WE:
      if (I = t.length, I) {
        if (I > o && (I = o), I > d && (I = d), I === 0) break e;
        n.set(i.subarray(s, s + I), c), o -= I, s += I, d -= I, c += I, t.length -= I;
        break;
      }
      t.mode = Ku;
      break;
    case XE:
      for (; y < 14; ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      if (t.nlen = (m & 31) + 257, m >>>= 5, y -= 5, t.ndist = (m & 31) + 1, m >>>= 5, y -= 5, t.ncode = (m & 15) + 4, m >>>= 4, y -= 4, t.nlen > 286 || t.ndist > 30) {
        r.msg = "too many length or distance symbols", t.mode = Gn;
        break;
      }
      t.have = 0, t.mode = ZE;
    /* falls through */
    case ZE:
      for (; t.have < t.ncode; ) {
        for (; y < 3; ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        t.lens[_e[t.have++]] = m & 7, m >>>= 3, y -= 3;
      }
      for (; t.have < 19; ) t.lens[_e[t.have++]] = 0;
      if (t.lencode = t.lendyn, t.lenbits = 7, Ee = { bits: t.lenbits }, pe = Hg(lQ, t.lens, 0, 19, t.lencode, 0, t.work, Ee), t.lenbits = Ee.bits, pe) {
        r.msg = "invalid code lengths set", t.mode = Gn;
        break;
      }
      t.have = 0, t.mode = YE;
    /* falls through */
    case YE:
      for (; t.have < t.nlen + t.ndist; ) {
        for (; $ = t.lencode[m & (1 << t.lenbits) - 1], G = $ >>> 24, te = $ >>> 16 & 255, Z = $ & 65535, !(G <= y); ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        if (Z < 16) m >>>= G, y -= G, t.lens[t.have++] = Z;
        else {
          if (Z === 16) {
            for (le = G + 2; y < le; ) {
              if (o === 0) break e;
              o--, m += i[s++] << y, y += 8;
            }
            if (m >>>= G, y -= G, t.have === 0) {
              r.msg = "invalid bit length repeat", t.mode = Gn;
              break;
            }
            be = t.lens[t.have - 1], I = 3 + (m & 3), m >>>= 2, y -= 2;
          } else if (Z === 17) {
            for (le = G + 3; y < le; ) {
              if (o === 0) break e;
              o--, m += i[s++] << y, y += 8;
            }
            m >>>= G, y -= G, be = 0, I = 3 + (m & 7), m >>>= 3, y -= 3;
          } else {
            for (le = G + 7; y < le; ) {
              if (o === 0) break e;
              o--, m += i[s++] << y, y += 8;
            }
            m >>>= G, y -= G, be = 0, I = 11 + (m & 127), m >>>= 7, y -= 7;
          }
          if (t.have + I > t.nlen + t.ndist) {
            r.msg = "invalid bit length repeat", t.mode = Gn;
            break;
          }
          for (; I--; ) t.lens[t.have++] = be;
        }
      }
      if (t.mode === Gn) break;
      if (t.lens[256] === 0) {
        r.msg = "invalid code -- missing end-of-block", t.mode = Gn;
        break;
      }
      if (t.lenbits = 9, Ee = { bits: t.lenbits }, pe = Hg(yR, t.lens, 0, t.nlen, t.lencode, 0, t.work, Ee), t.lenbits = Ee.bits, pe) {
        r.msg = "invalid literal/lengths set", t.mode = Gn;
        break;
      }
      if (t.distbits = 6, t.distcode = t.distdyn, Ee = { bits: t.distbits }, pe = Hg(bR, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, Ee), t.distbits = Ee.bits, pe) {
        r.msg = "invalid distances set", t.mode = Gn;
        break;
      }
      if (t.mode = E_, e === S_) break e;
    /* falls through */
    case E_:
      t.mode = C_;
    /* falls through */
    case C_:
      if (o >= 6 && d >= 258) {
        r.next_out = c, r.avail_out = d, r.next_in = s, r.avail_in = o, t.hold = m, t.bits = y, rQ(r, P), c = r.next_out, n = r.output, d = r.avail_out, s = r.next_in, i = r.input, o = r.avail_in, m = t.hold, y = t.bits, t.mode === Ku && (t.back = -1);
        break;
      }
      for (t.back = 0; $ = t.lencode[m & (1 << t.lenbits) - 1], G = $ >>> 24, te = $ >>> 16 & 255, Z = $ & 65535, !(G <= y); ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      if (te && (te & 240) === 0) {
        for (H = G, J = te, re = Z; $ = t.lencode[re + ((m & (1 << H + J) - 1) >> H)], G = $ >>> 24, te = $ >>> 16 & 255, Z = $ & 65535, !(H + G <= y); ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        m >>>= H, y -= H, t.back += H;
      }
      if (m >>>= G, y -= G, t.back += G, t.length = Z, te === 0) {
        t.mode = tC;
        break;
      }
      if (te & 32) {
        t.back = -1, t.mode = Ku;
        break;
      }
      if (te & 64) {
        r.msg = "invalid literal/length code", t.mode = Gn;
        break;
      }
      t.extra = te & 15, t.mode = JE;
    /* falls through */
    case JE:
      if (t.extra) {
        for (le = t.extra; y < le; ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        t.length += m & (1 << t.extra) - 1, m >>>= t.extra, y -= t.extra, t.back += t.extra;
      }
      t.was = t.length, t.mode = KE;
    /* falls through */
    case KE:
      for (; $ = t.distcode[m & (1 << t.distbits) - 1], G = $ >>> 24, te = $ >>> 16 & 255, Z = $ & 65535, !(G <= y); ) {
        if (o === 0) break e;
        o--, m += i[s++] << y, y += 8;
      }
      if ((te & 240) === 0) {
        for (H = G, J = te, re = Z; $ = t.distcode[re + ((m & (1 << H + J) - 1) >> H)], G = $ >>> 24, te = $ >>> 16 & 255, Z = $ & 65535, !(H + G <= y); ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        m >>>= H, y -= H, t.back += H;
      }
      if (m >>>= G, y -= G, t.back += G, te & 64) {
        r.msg = "invalid distance code", t.mode = Gn;
        break;
      }
      t.offset = Z, t.extra = te & 15, t.mode = QE;
    /* falls through */
    case QE:
      if (t.extra) {
        for (le = t.extra; y < le; ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        t.offset += m & (1 << t.extra) - 1, m >>>= t.extra, y -= t.extra, t.back += t.extra;
      }
      if (t.offset > t.dmax) {
        r.msg = "invalid distance too far back", t.mode = Gn;
        break;
      }
      t.mode = eC;
    /* falls through */
    case eC:
      if (d === 0) break e;
      if (I = P - d, t.offset > I) {
        if (I = t.offset - I, I > t.whave && t.sane) {
          r.msg = "invalid distance too far back", t.mode = Gn;
          break;
        }
        I > t.wnext ? (I -= t.wnext, D = t.wsize - I) : D = t.wnext - I, I > t.length && (I = t.length), k = t.window;
      } else k = n, D = c - t.offset, I = t.length;
      I > d && (I = d), d -= I, t.length -= I;
      do
        n[c++] = k[D++];
      while (--I);
      t.length === 0 && (t.mode = C_);
      break;
    case tC:
      if (d === 0) break e;
      n[c++] = t.length, d--, t.mode = C_;
      break;
    case S1:
      if (t.wrap) {
        for (; y < 32; ) {
          if (o === 0) break e;
          o--, m |= i[s++] << y, y += 8;
        }
        if (P -= d, r.total_out += P, t.total += P, t.wrap & 4 && P && (r.adler = t.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
        t.flags ? uu(t.check, n, P, c - P) : i2(t.check, n, P, c - P)), P = d, t.wrap & 4 && (t.flags ? m : nC(m)) !== t.check) {
          r.msg = "incorrect data check", t.mode = Gn;
          break;
        }
        m = 0, y = 0;
      }
      t.mode = rC;
    /* falls through */
    case rC:
      if (t.wrap && t.flags) {
        for (; y < 32; ) {
          if (o === 0) break e;
          o--, m += i[s++] << y, y += 8;
        }
        if (t.wrap & 4 && m !== (t.total & 4294967295)) {
          r.msg = "incorrect length check", t.mode = Gn;
          break;
        }
        m = 0, y = 0;
      }
      t.mode = iC;
    /* falls through */
    case iC:
      pe = uQ;
      break e;
    case Gn:
      pe = vR;
      break e;
    case wR:
      return xR;
    case AR:
    /* falls through */
    default:
      return Cc;
  }
  return r.next_out = c, r.avail_out = d, r.next_in = s, r.avail_in = o, t.hold = m, t.bits = y, (t.wsize || P !== r.avail_out && t.mode < Gn && (t.mode < S1 || e !== OE)) && IR(r, r.output, r.next_out, P - r.avail_out), T -= r.avail_in, P -= r.avail_out, r.total_in += T, r.total_out += P, t.total += P, t.wrap & 4 && P && (r.adler = t.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  t.flags ? uu(t.check, n, P, r.next_out - P) : i2(t.check, n, P, r.next_out - P)), r.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === Ku ? 128 : 0) + (t.mode === E_ || t.mode === T1 ? 256 : 0), (T === 0 && P === 0 || e === OE) && pe === sd && (pe = fQ), pe;
}, xQ = (r) => {
  if (hd(r)) return Cc;
  let e = r.state;
  return e.window && (e.window = null), r.state = null, sd;
}, wQ = (r, e) => {
  if (hd(r)) return Cc;
  const t = r.state;
  return (t.wrap & 2) === 0 ? Cc : (t.head = e, e.done = !1, sd);
}, AQ = (r, e) => {
  const t = e.length;
  let i, n, s;
  return hd(r) || (i = r.state, i.wrap !== 0 && i.mode !== jy) ? Cc : i.mode === jy && (n = 1, n = i2(n, e, t, 0), n !== i.check) ? vR : (s = IR(r, e, t, t), s ? (i.mode = wR, xR) : (i.havedict = 1, sd));
};
var TQ = SR, SQ = ER, EQ = TR, CQ = yQ, IQ = CR, PQ = vQ, MQ = xQ, RQ = wQ, LQ = AQ, BQ = "pako inflate (from Nodeca project)", th = { inflateReset: TQ, inflateReset2: SQ, inflateResetKeep: EQ, inflateInit: CQ, inflateInit2: IQ, inflate: PQ, inflateEnd: MQ, inflateGetHeader: RQ, inflateSetDictionary: LQ, inflateInfo: BQ };
function kQ() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var OQ = kQ;
const PR = Object.prototype.toString, { Z_NO_FLUSH: DQ, Z_FINISH: NQ, Z_OK: am, Z_STREAM_END: I1, Z_NEED_DICT: P1, Z_STREAM_ERROR: FQ, Z_DATA_ERROR: oC, Z_MEM_ERROR: UQ } = gR;
function bm(r) {
  this.options = mR.assign({ chunkSize: 1024 * 64, windowBits: 15, to: "" }, r || {});
  const e = this.options;
  e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(r && r.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15) === 0 && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new eQ(), this.strm.avail_out = 0;
  let t = th.inflateInit2(this.strm, e.windowBits);
  if (t !== am) throw new Error(n2[t]);
  if (this.header = new OQ(), th.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = s2.string2buf(e.dictionary) : PR.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (t = th.inflateSetDictionary(this.strm, e.dictionary), t !== am))) throw new Error(n2[t]);
}
bm.prototype.push = function(r, e) {
  const t = this.strm, i = this.options.chunkSize, n = this.options.dictionary;
  let s, c, o;
  if (this.ended) return !1;
  for (e === ~~e ? c = e : c = e === !0 ? NQ : DQ, PR.call(r) === "[object ArrayBuffer]" ? t.input = new Uint8Array(r) : t.input = r, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    for (t.avail_out === 0 && (t.output = new Uint8Array(i), t.next_out = 0, t.avail_out = i), s = th.inflate(t, c), s === P1 && n && (s = th.inflateSetDictionary(t, n), s === am ? s = th.inflate(t, c) : s === oC && (s = P1)); t.avail_in > 0 && s === I1 && t.state.wrap > 0 && r[t.next_in] !== 0; ) th.inflateReset(t), s = th.inflate(t, c);
    switch (s) {
      case FQ:
      case oC:
      case P1:
      case UQ:
        return this.onEnd(s), this.ended = !0, !1;
    }
    if (o = t.avail_out, t.next_out && (t.avail_out === 0 || s === I1)) if (this.options.to === "string") {
      let d = s2.utf8border(t.output, t.next_out), m = t.next_out - d, y = s2.buf2string(t.output, d);
      t.next_out = m, t.avail_out = i - m, m && t.output.set(t.output.subarray(d, d + m), 0), this.onData(y);
    } else this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
    if (!(s === am && o === 0)) {
      if (s === I1) return s = th.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
      if (t.avail_in === 0) break;
    }
  }
  return !0;
};
bm.prototype.onData = function(r) {
  this.chunks.push(r);
};
bm.prototype.onEnd = function(r) {
  r === am && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = mR.flattenChunks(this.chunks)), this.chunks = [], this.err = r, this.msg = this.strm.msg;
};
function zQ(r, e) {
  const t = new bm(e);
  if (t.push(r), t.err) throw t.msg || n2[t.err];
  return t.result;
}
var jQ = bm, VQ = zQ, GQ = { Inflate: jQ, inflate: VQ };
const { Inflate: $Q, inflate: HQ } = GQ;
var aC = $Q, qQ = HQ;
const MR = [];
for (let r = 0; r < 256; r++) {
  let e = r;
  for (let t = 0; t < 8; t++) e & 1 ? e = 3988292384 ^ e >>> 1 : e = e >>> 1;
  MR[r] = e;
}
const lC = 4294967295;
function WQ(r, e, t) {
  let i = r;
  for (let n = 0; n < t; n++) i = MR[(i ^ e[n]) & 255] ^ i >>> 8;
  return i;
}
function XQ(r, e) {
  return (WQ(lC, r, e) ^ lC) >>> 0;
}
function cC(r, e, t) {
  const i = r.readUint32(), n = XQ(new Uint8Array(r.buffer, r.byteOffset + r.offset - e - 4, e), e);
  if (n !== i) throw new Error(`CRC mismatch for chunk ${t}. Expected ${i}, found ${n}`);
}
function RR(r, e, t) {
  for (let i = 0; i < t; i++) e[i] = r[i];
}
function LR(r, e, t, i) {
  let n = 0;
  for (; n < i; n++) e[n] = r[n];
  for (; n < t; n++) e[n] = r[n] + e[n - i] & 255;
}
function BR(r, e, t, i) {
  let n = 0;
  if (t.length === 0) for (; n < i; n++) e[n] = r[n];
  else for (; n < i; n++) e[n] = r[n] + t[n] & 255;
}
function kR(r, e, t, i, n) {
  let s = 0;
  if (t.length === 0) {
    for (; s < n; s++) e[s] = r[s];
    for (; s < i; s++) e[s] = r[s] + (e[s - n] >> 1) & 255;
  } else {
    for (; s < n; s++) e[s] = r[s] + (t[s] >> 1) & 255;
    for (; s < i; s++) e[s] = r[s] + (e[s - n] + t[s] >> 1) & 255;
  }
}
function OR(r, e, t, i, n) {
  let s = 0;
  if (t.length === 0) {
    for (; s < n; s++) e[s] = r[s];
    for (; s < i; s++) e[s] = r[s] + e[s - n] & 255;
  } else {
    for (; s < n; s++) e[s] = r[s] + t[s] & 255;
    for (; s < i; s++) e[s] = r[s] + ZQ(e[s - n], t[s], t[s - n]) & 255;
  }
}
function ZQ(r, e, t) {
  const i = r + e - t, n = Math.abs(i - r), s = Math.abs(i - e), c = Math.abs(i - t);
  return n <= s && n <= c ? r : s <= c ? e : t;
}
function YQ(r, e, t, i, n, s) {
  switch (r) {
    case 0:
      RR(e, t, n);
      break;
    case 1:
      LR(e, t, n, s);
      break;
    case 2:
      BR(e, t, i, n);
      break;
    case 3:
      kR(e, t, i, n, s);
      break;
    case 4:
      OR(e, t, i, n, s);
      break;
    default:
      throw new Error(`Unsupported filter: ${r}`);
  }
}
const JQ = new Uint16Array([255]), KQ = new Uint8Array(JQ.buffer), QQ = KQ[0] === 255;
function eee(r) {
  const { data: e, width: t, height: i, channels: n, depth: s } = r, c = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    // Pass 1
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    // Pass 2
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    // Pass 3
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    // Pass 4
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    // Pass 5
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    // Pass 6
    { x: 0, y: 1, xStep: 1, yStep: 2 }
    // Pass 7
  ], o = Math.ceil(s / 8) * n, d = new Uint8Array(i * t * o);
  let m = 0;
  for (let y = 0; y < 7; y++) {
    const T = c[y], P = Math.ceil((t - T.x) / T.xStep), I = Math.ceil((i - T.y) / T.yStep);
    if (P <= 0 || I <= 0) continue;
    const D = P * o, k = new Uint8Array(D);
    for (let $ = 0; $ < I; $++) {
      const G = e[m++], te = e.subarray(m, m + D);
      m += D;
      const Z = new Uint8Array(D);
      YQ(G, te, Z, k, D, o), k.set(Z);
      for (let H = 0; H < P; H++) {
        const J = T.x + H * T.xStep, re = T.y + $ * T.yStep;
        if (!(J >= t || re >= i)) for (let be = 0; be < o; be++) d[(re * t + J) * o + be] = Z[H * o + be];
      }
    }
  }
  if (s === 16) {
    const y = new Uint16Array(d.buffer);
    if (QQ) for (let T = 0; T < y.length; T++) y[T] = tee(y[T]);
    return y;
  } else return d;
}
function tee(r) {
  return (r & 255) << 8 | r >> 8 & 255;
}
const ree = new Uint16Array([255]), iee = new Uint8Array(ree.buffer), nee = iee[0] === 255, see = new Uint8Array(0);
function uC(r) {
  const { data: e, width: t, height: i, channels: n, depth: s } = r, c = Math.ceil(s / 8) * n, o = Math.ceil(s / 8 * n * t), d = new Uint8Array(i * o);
  let m = see, y = 0, T, P;
  for (let I = 0; I < i; I++) {
    switch (T = e.subarray(y + 1, y + 1 + o), P = d.subarray(I * o, (I + 1) * o), e[y]) {
      case 0:
        RR(T, P, o);
        break;
      case 1:
        LR(T, P, o, c);
        break;
      case 2:
        BR(T, P, m, o);
        break;
      case 3:
        kR(T, P, m, o, c);
        break;
      case 4:
        OR(T, P, m, o, c);
        break;
      default:
        throw new Error(`Unsupported filter: ${e[y]}`);
    }
    m = P, y += o + 1;
  }
  if (s === 16) {
    const I = new Uint16Array(d.buffer);
    if (nee) for (let D = 0; D < I.length; D++) I[D] = oee(I[D]);
    return I;
  } else return d;
}
function oee(r) {
  return (r & 255) << 8 | r >> 8 & 255;
}
const ey = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
function hC(r) {
  if (!aee(r.readBytes(ey.length))) throw new Error("wrong PNG signature");
}
function aee(r) {
  if (r.length < ey.length) return !1;
  for (let e = 0; e < ey.length; e++) if (r[e] !== ey[e]) return !1;
  return !0;
}
const lee = "tEXt", cee = 0, DR = new TextDecoder("latin1");
function uee(r) {
  if (fee(r), r.length === 0 || r.length > 79) throw new Error("keyword length must be between 1 and 79");
}
const hee = /^[\u0000-\u00FF]*$/;
function fee(r) {
  if (!hee.test(r)) throw new Error("invalid latin1 text");
}
function dee(r, e, t) {
  const i = NR(e);
  r[i] = pee(e, t - i.length - 1);
}
function NR(r) {
  for (r.mark(); r.readByte() !== cee; ) ;
  const e = r.offset;
  r.reset();
  const t = DR.decode(r.readBytes(e - r.offset - 1));
  return r.skip(1), uee(t), t;
}
function pee(r, e) {
  return DR.decode(r.readBytes(e));
}
const tl = { UNKNOWN: -1, GREYSCALE: 0, TRUECOLOUR: 2, INDEXED_COLOUR: 3, GREYSCALE_ALPHA: 4, TRUECOLOUR_ALPHA: 6 }, M1 = { UNKNOWN: -1, DEFLATE: 0 }, fC = { UNKNOWN: -1, ADAPTIVE: 0 }, R1 = { UNKNOWN: -1, NO_INTERLACE: 0, ADAM7: 1 }, I_ = { NONE: 0, BACKGROUND: 1, PREVIOUS: 2 }, L1 = { SOURCE: 0, OVER: 1 };
class gee extends ew {
  _checkCrc;
  _inflator;
  _png;
  _apng;
  _end;
  _hasPalette;
  _palette;
  _hasTransparency;
  _transparency;
  _compressionMethod;
  _filterMethod;
  _interlaceMethod;
  _colorType;
  _isAnimated;
  _numberOfFrames;
  _numberOfPlays;
  _frames;
  _writingDataChunks;
  constructor(e, t = {}) {
    super(e);
    const { checkCrc: i = !1 } = t;
    this._checkCrc = i, this._inflator = new aC(), this._png = { width: -1, height: -1, channels: -1, data: new Uint8Array(0), depth: 1, text: {} }, this._apng = { width: -1, height: -1, channels: -1, depth: 1, numberOfFrames: 1, numberOfPlays: 0, text: {}, frames: [] }, this._end = !1, this._hasPalette = !1, this._palette = [], this._hasTransparency = !1, this._transparency = new Uint16Array(0), this._compressionMethod = M1.UNKNOWN, this._filterMethod = fC.UNKNOWN, this._interlaceMethod = R1.UNKNOWN, this._colorType = tl.UNKNOWN, this._isAnimated = !1, this._numberOfFrames = 1, this._numberOfPlays = 0, this._frames = [], this._writingDataChunks = !1, this.setBigEndian();
  }
  decode() {
    for (hC(this); !this._end; ) {
      const e = this.readUint32(), t = this.readChars(4);
      this.decodeChunk(e, t);
    }
    return this.decodeImage(), this._png;
  }
  decodeApng() {
    for (hC(this); !this._end; ) {
      const e = this.readUint32(), t = this.readChars(4);
      this.decodeApngChunk(e, t);
    }
    return this.decodeApngImage(), this._apng;
  }
  // https://www.w3.org/TR/PNG/#5Chunk-layout
  decodeChunk(e, t) {
    const i = this.offset;
    switch (t) {
      // 11.2 Critical chunks
      case "IHDR":
        this.decodeIHDR();
        break;
      case "PLTE":
        this.decodePLTE(e);
        break;
      case "IDAT":
        this.decodeIDAT(e);
        break;
      case "IEND":
        this._end = !0;
        break;
      // 11.3 Ancillary chunks
      case "tRNS":
        this.decodetRNS(e);
        break;
      case "iCCP":
        this.decodeiCCP(e);
        break;
      case lee:
        dee(this._png.text, this, e);
        break;
      case "pHYs":
        this.decodepHYs();
        break;
      default:
        this.skip(e);
        break;
    }
    if (this.offset - i !== e) throw new Error(`Length mismatch while decoding chunk ${t}`);
    this._checkCrc ? cC(this, e + 4, t) : this.skip(4);
  }
  decodeApngChunk(e, t) {
    const i = this.offset;
    switch (t !== "fdAT" && t !== "IDAT" && this._writingDataChunks && this.pushDataToFrame(), t) {
      case "acTL":
        this.decodeACTL();
        break;
      case "fcTL":
        this.decodeFCTL();
        break;
      case "fdAT":
        this.decodeFDAT(e);
        break;
      default:
        this.decodeChunk(e, t), this.offset = i + e;
        break;
    }
    if (this.offset - i !== e) throw new Error(`Length mismatch while decoding chunk ${t}`);
    this._checkCrc ? cC(this, e + 4, t) : this.skip(4);
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  decodeIHDR() {
    const e = this._png;
    e.width = this.readUint32(), e.height = this.readUint32(), e.depth = mee(this.readUint8());
    const t = this.readUint8();
    this._colorType = t;
    let i;
    switch (t) {
      case tl.GREYSCALE:
        i = 1;
        break;
      case tl.TRUECOLOUR:
        i = 3;
        break;
      case tl.INDEXED_COLOUR:
        i = 1;
        break;
      case tl.GREYSCALE_ALPHA:
        i = 2;
        break;
      case tl.TRUECOLOUR_ALPHA:
        i = 4;
        break;
      // Kept for exhaustiveness.
      // eslint-disable-next-line unicorn/no-useless-switch-case
      case tl.UNKNOWN:
      default:
        throw new Error(`Unknown color type: ${t}`);
    }
    if (this._png.channels = i, this._compressionMethod = this.readUint8(), this._compressionMethod !== M1.DEFLATE) throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
    this._filterMethod = this.readUint8(), this._interlaceMethod = this.readUint8();
  }
  decodeACTL() {
    this._numberOfFrames = this.readUint32(), this._numberOfPlays = this.readUint32(), this._isAnimated = !0;
  }
  decodeFCTL() {
    const e = { sequenceNumber: this.readUint32(), width: this.readUint32(), height: this.readUint32(), xOffset: this.readUint32(), yOffset: this.readUint32(), delayNumber: this.readUint16(), delayDenominator: this.readUint16(), disposeOp: this.readUint8(), blendOp: this.readUint8(), data: new Uint8Array(0) };
    this._frames.push(e);
  }
  // https://www.w3.org/TR/PNG/#11PLTE
  decodePLTE(e) {
    if (e % 3 !== 0) throw new RangeError(`PLTE field length must be a multiple of 3. Got ${e}`);
    const t = e / 3;
    this._hasPalette = !0;
    const i = [];
    this._palette = i;
    for (let n = 0; n < t; n++) i.push([this.readUint8(), this.readUint8(), this.readUint8()]);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  decodeIDAT(e) {
    this._writingDataChunks = !0;
    const t = e, i = this.offset + this.byteOffset;
    if (this._inflator.push(new Uint8Array(this.buffer, i, t)), this._inflator.err) throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    this.skip(e);
  }
  decodeFDAT(e) {
    this._writingDataChunks = !0;
    let t = e, i = this.offset + this.byteOffset;
    if (i += 4, t -= 4, this._inflator.push(new Uint8Array(this.buffer, i, t)), this._inflator.err) throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    this.skip(e);
  }
  // https://www.w3.org/TR/PNG/#11tRNS
  decodetRNS(e) {
    switch (this._colorType) {
      case tl.GREYSCALE:
      case tl.TRUECOLOUR: {
        if (e % 2 !== 0) throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${e}`);
        if (e / 2 > this._png.width * this._png.height) throw new Error(`tRNS chunk contains more alpha values than there are pixels (${e / 2} vs ${this._png.width * this._png.height})`);
        this._hasTransparency = !0, this._transparency = new Uint16Array(e / 2);
        for (let t = 0; t < e / 2; t++) this._transparency[t] = this.readUint16();
        break;
      }
      case tl.INDEXED_COLOUR: {
        if (e > this._palette.length) throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${e} vs ${this._palette.length})`);
        let t = 0;
        for (; t < e; t++) {
          const i = this.readByte();
          this._palette[t].push(i);
        }
        for (; t < this._palette.length; t++) this._palette[t].push(255);
        break;
      }
      // Kept for exhaustiveness.
      /* eslint-disable unicorn/no-useless-switch-case */
      case tl.UNKNOWN:
      case tl.GREYSCALE_ALPHA:
      case tl.TRUECOLOUR_ALPHA:
      default:
        throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
    }
  }
  // https://www.w3.org/TR/PNG/#11iCCP
  decodeiCCP(e) {
    const t = NR(this), i = this.readUint8();
    if (i !== M1.DEFLATE) throw new Error(`Unsupported iCCP compression method: ${i}`);
    const n = this.readBytes(e - t.length - 2);
    this._png.iccEmbeddedProfile = { name: t, profile: qQ(n) };
  }
  // https://www.w3.org/TR/PNG/#11pHYs
  decodepHYs() {
    const e = this.readUint32(), t = this.readUint32(), i = this.readByte();
    this._png.resolution = { x: e, y: t, unit: i };
  }
  decodeApngImage() {
    this._apng.width = this._png.width, this._apng.height = this._png.height, this._apng.channels = this._png.channels, this._apng.depth = this._png.depth, this._apng.numberOfFrames = this._numberOfFrames, this._apng.numberOfPlays = this._numberOfPlays, this._apng.text = this._png.text, this._apng.resolution = this._png.resolution;
    for (let e = 0; e < this._numberOfFrames; e++) {
      const t = { sequenceNumber: this._frames[e].sequenceNumber, delayNumber: this._frames[e].delayNumber, delayDenominator: this._frames[e].delayDenominator, data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels) }, i = this._frames.at(e);
      if (i) {
        if (i.data = uC({ data: i.data, width: i.width, height: i.height, channels: this._apng.channels, depth: this._apng.depth }), this._hasPalette && (this._apng.palette = this._palette), this._hasTransparency && (this._apng.transparency = this._transparency), e === 0 || i.xOffset === 0 && i.yOffset === 0 && i.width === this._png.width && i.height === this._png.height) t.data = i.data;
        else {
          const n = this._apng.frames.at(e - 1);
          this.disposeFrame(i, n, t), this.addFrameDataToCanvas(t, i);
        }
        this._apng.frames.push(t);
      }
    }
    return this._apng;
  }
  disposeFrame(e, t, i) {
    switch (e.disposeOp) {
      case I_.NONE:
        break;
      case I_.BACKGROUND:
        for (let n = 0; n < this._png.height; n++) for (let s = 0; s < this._png.width; s++) {
          const c = (n * e.width + s) * this._png.channels;
          for (let o = 0; o < this._png.channels; o++) i.data[c + o] = 0;
        }
        break;
      case I_.PREVIOUS:
        i.data.set(t.data);
        break;
      default:
        throw new Error("Unknown disposeOp");
    }
  }
  addFrameDataToCanvas(e, t) {
    const i = 1 << this._png.depth, n = (s, c) => {
      const o = ((s + t.yOffset) * this._png.width + t.xOffset + c) * this._png.channels, d = (s * t.width + c) * this._png.channels;
      return { index: o, frameIndex: d };
    };
    switch (t.blendOp) {
      case L1.SOURCE:
        for (let s = 0; s < t.height; s++) for (let c = 0; c < t.width; c++) {
          const { index: o, frameIndex: d } = n(s, c);
          for (let m = 0; m < this._png.channels; m++) e.data[o + m] = t.data[d + m];
        }
        break;
      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
      case L1.OVER:
        for (let s = 0; s < t.height; s++) for (let c = 0; c < t.width; c++) {
          const { index: o, frameIndex: d } = n(s, c);
          for (let m = 0; m < this._png.channels; m++) {
            const y = t.data[d + this._png.channels - 1] / i, T = m % (this._png.channels - 1) === 0 ? 1 : t.data[d + m], P = Math.floor(y * T + (1 - y) * e.data[o + m]);
            e.data[o + m] += P;
          }
        }
        break;
      default:
        throw new Error("Unknown blendOp");
    }
  }
  decodeImage() {
    if (this._inflator.err) throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    const e = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;
    if (this._filterMethod !== fC.ADAPTIVE) throw new Error(`Filter method ${this._filterMethod} not supported`);
    if (this._interlaceMethod === R1.NO_INTERLACE) this._png.data = uC({ data: e, width: this._png.width, height: this._png.height, channels: this._png.channels, depth: this._png.depth });
    else if (this._interlaceMethod === R1.ADAM7) this._png.data = eee({ data: e, width: this._png.width, height: this._png.height, channels: this._png.channels, depth: this._png.depth });
    else throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
    this._hasPalette && (this._png.palette = this._palette), this._hasTransparency && (this._png.transparency = this._transparency);
  }
  pushDataToFrame() {
    const e = this._inflator.result, t = this._frames.at(-1);
    t ? t.data = e : this._frames.push({ sequenceNumber: 0, width: this._png.width, height: this._png.height, xOffset: 0, yOffset: 0, delayNumber: 0, delayDenominator: 0, disposeOp: I_.NONE, blendOp: L1.SOURCE, data: e }), this._inflator = new aC(), this._writingDataChunks = !1;
  }
}
function mee(r) {
  if (r !== 1 && r !== 2 && r !== 4 && r !== 8 && r !== 16) throw new Error(`invalid bit depth: ${r}`);
  return r;
}
var dC;
(function(r) {
  r[r.UNKNOWN = 0] = "UNKNOWN", r[r.METRE = 1] = "METRE";
})(dC || (dC = {}));
function _ee(r, e) {
  return new gee(r, e).decode();
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 3.0.2 Built on 2025-08-26T11:48:30.930Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var ai = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function B1() {
  ai.console && typeof ai.console.log == "function" && ai.console.log.apply(ai.console, arguments);
}
var An = { log: B1, warn: function(r) {
  ai.console && (typeof ai.console.warn == "function" ? ai.console.warn.apply(ai.console, arguments) : B1.call(null, arguments));
}, error: function(r) {
  ai.console && (typeof ai.console.error == "function" ? ai.console.error.apply(ai.console, arguments) : B1(r));
} };
function k1(r, e, t) {
  var i = new XMLHttpRequest();
  i.open("GET", r), i.responseType = "blob", i.onload = function() {
    If(i.response, e, t);
  }, i.onerror = function() {
    An.error("could not download file");
  }, i.send();
}
function pC(r) {
  var e = new XMLHttpRequest();
  e.open("HEAD", r, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function P_(r) {
  try {
    r.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), r.dispatchEvent(e);
  }
}
var If = ai.saveAs || ((typeof window > "u" ? "undefined" : un(window)) !== "object" || window !== ai ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(r, e, t) {
  var i = ai.URL || ai.webkitURL, n = document.createElement("a");
  e = e || r.name || "download", n.download = e, n.rel = "noopener", typeof r == "string" ? (n.href = r, n.origin !== location.origin ? pC(n.href) ? k1(r, e, t) : P_(n, n.target = "_blank") : P_(n)) : (n.href = i.createObjectURL(r), setTimeout(function() {
    i.revokeObjectURL(n.href);
  }, 4e4), setTimeout(function() {
    P_(n);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(r, e, t) {
  if (e = e || r.name || "download", typeof r == "string")
    if (pC(r)) k1(r, e, t);
    else {
      var i = document.createElement("a");
      i.href = r, i.target = "_blank", setTimeout(function() {
        P_(i);
      });
    }
  else navigator.msSaveOrOpenBlob(function(n, s) {
    return s === void 0 ? s = { autoBom: !1 } : un(s) !== "object" && (An.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(n.type) ? new Blob(["\uFEFF", n], { type: n.type }) : n;
  }(r, t), e);
} : function(r, e, t, i) {
  if ((i = i || open("", "_blank")) && (i.document.title = i.document.body.innerText = "downloading..."), typeof r == "string") return k1(r, e, t);
  var n = r.type === "application/octet-stream", s = /constructor/i.test(ai.HTMLElement) || ai.safari, c = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((c || n && s) && (typeof FileReader > "u" ? "undefined" : un(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var y = o.result;
      y = c ? y : y.replace(/^data:[^;]*;/, "data:attachment/file;"), i ? i.location.href = y : location = y, i = null;
    }, o.readAsDataURL(r);
  } else {
    var d = ai.URL || ai.webkitURL, m = d.createObjectURL(r);
    i ? i.location = m : location.href = m, i = null, setTimeout(function() {
      d.revokeObjectURL(m);
    }, 4e4);
  }
});
/**
* A class to parse color values
* @author Stoyan Stefanov <sstoo@gmail.com>
* {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
* @license Use it if you like it
*/
function FR(r) {
  var e;
  r = r || "", this.ok = !1, r.charAt(0) == "#" && (r = r.substr(1, 6)), r = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[r = (r = r.replace(/ /g, "")).toLowerCase()] || r;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], i = 0; i < t.length; i++) {
    var n = t[i].re, s = t[i].process, c = n.exec(r);
    c && (e = s(c), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), d = this.g.toString(16), m = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), d.length == 1 && (d = "0" + d), m.length == 1 && (m = "0" + m), "#" + o + d + m;
  };
}
var ty = ai.atob.bind(ai), gC = ai.btoa.bind(ai);
/**
* @license
* Joseph Myers does not specify a particular license for his work.
*
* Author: Joseph Myers
* Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
*
* Modified by: Owen Leong
*/
function O1(r, e) {
  var t = r[0], i = r[1], n = r[2], s = r[3];
  t = Do(t, i, n, s, e[0], 7, -680876936), s = Do(s, t, i, n, e[1], 12, -389564586), n = Do(n, s, t, i, e[2], 17, 606105819), i = Do(i, n, s, t, e[3], 22, -1044525330), t = Do(t, i, n, s, e[4], 7, -176418897), s = Do(s, t, i, n, e[5], 12, 1200080426), n = Do(n, s, t, i, e[6], 17, -1473231341), i = Do(i, n, s, t, e[7], 22, -45705983), t = Do(t, i, n, s, e[8], 7, 1770035416), s = Do(s, t, i, n, e[9], 12, -1958414417), n = Do(n, s, t, i, e[10], 17, -42063), i = Do(i, n, s, t, e[11], 22, -1990404162), t = Do(t, i, n, s, e[12], 7, 1804603682), s = Do(s, t, i, n, e[13], 12, -40341101), n = Do(n, s, t, i, e[14], 17, -1502002290), t = No(t, i = Do(i, n, s, t, e[15], 22, 1236535329), n, s, e[1], 5, -165796510), s = No(s, t, i, n, e[6], 9, -1069501632), n = No(n, s, t, i, e[11], 14, 643717713), i = No(i, n, s, t, e[0], 20, -373897302), t = No(t, i, n, s, e[5], 5, -701558691), s = No(s, t, i, n, e[10], 9, 38016083), n = No(n, s, t, i, e[15], 14, -660478335), i = No(i, n, s, t, e[4], 20, -405537848), t = No(t, i, n, s, e[9], 5, 568446438), s = No(s, t, i, n, e[14], 9, -1019803690), n = No(n, s, t, i, e[3], 14, -187363961), i = No(i, n, s, t, e[8], 20, 1163531501), t = No(t, i, n, s, e[13], 5, -1444681467), s = No(s, t, i, n, e[2], 9, -51403784), n = No(n, s, t, i, e[7], 14, 1735328473), t = Fo(t, i = No(i, n, s, t, e[12], 20, -1926607734), n, s, e[5], 4, -378558), s = Fo(s, t, i, n, e[8], 11, -2022574463), n = Fo(n, s, t, i, e[11], 16, 1839030562), i = Fo(i, n, s, t, e[14], 23, -35309556), t = Fo(t, i, n, s, e[1], 4, -1530992060), s = Fo(s, t, i, n, e[4], 11, 1272893353), n = Fo(n, s, t, i, e[7], 16, -155497632), i = Fo(i, n, s, t, e[10], 23, -1094730640), t = Fo(t, i, n, s, e[13], 4, 681279174), s = Fo(s, t, i, n, e[0], 11, -358537222), n = Fo(n, s, t, i, e[3], 16, -722521979), i = Fo(i, n, s, t, e[6], 23, 76029189), t = Fo(t, i, n, s, e[9], 4, -640364487), s = Fo(s, t, i, n, e[12], 11, -421815835), n = Fo(n, s, t, i, e[15], 16, 530742520), t = Uo(t, i = Fo(i, n, s, t, e[2], 23, -995338651), n, s, e[0], 6, -198630844), s = Uo(s, t, i, n, e[7], 10, 1126891415), n = Uo(n, s, t, i, e[14], 15, -1416354905), i = Uo(i, n, s, t, e[5], 21, -57434055), t = Uo(t, i, n, s, e[12], 6, 1700485571), s = Uo(s, t, i, n, e[3], 10, -1894986606), n = Uo(n, s, t, i, e[10], 15, -1051523), i = Uo(i, n, s, t, e[1], 21, -2054922799), t = Uo(t, i, n, s, e[8], 6, 1873313359), s = Uo(s, t, i, n, e[15], 10, -30611744), n = Uo(n, s, t, i, e[6], 15, -1560198380), i = Uo(i, n, s, t, e[13], 21, 1309151649), t = Uo(t, i, n, s, e[4], 6, -145523070), s = Uo(s, t, i, n, e[11], 10, -1120210379), n = Uo(n, s, t, i, e[2], 15, 718787259), i = Uo(i, n, s, t, e[9], 21, -343485551), r[0] = Vh(t, r[0]), r[1] = Vh(i, r[1]), r[2] = Vh(n, r[2]), r[3] = Vh(s, r[3]);
}
function h0(r, e, t, i, n, s) {
  return e = Vh(Vh(e, r), Vh(i, s)), Vh(e << n | e >>> 32 - n, t);
}
function Do(r, e, t, i, n, s, c) {
  return h0(e & t | ~e & i, r, e, n, s, c);
}
function No(r, e, t, i, n, s, c) {
  return h0(e & i | t & ~i, r, e, n, s, c);
}
function Fo(r, e, t, i, n, s, c) {
  return h0(e ^ t ^ i, r, e, n, s, c);
}
function Uo(r, e, t, i, n, s, c) {
  return h0(t ^ (e | ~i), r, e, n, s, c);
}
function UR(r) {
  var e, t = r.length, i = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= r.length; e += 64) O1(i, yee(r.substring(e - 64, e)));
  r = r.substring(e - 64);
  var n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < r.length; e++) n[e >> 2] |= r.charCodeAt(e) << (e % 4 << 3);
  if (n[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (O1(i, n), e = 0; e < 16; e++) n[e] = 0;
  return n[14] = 8 * t, O1(i, n), i;
}
function yee(r) {
  var e, t = [];
  for (e = 0; e < 64; e += 4) t[e >> 2] = r.charCodeAt(e) + (r.charCodeAt(e + 1) << 8) + (r.charCodeAt(e + 2) << 16) + (r.charCodeAt(e + 3) << 24);
  return t;
}
var mC = "0123456789abcdef".split("");
function bee(r) {
  for (var e = "", t = 0; t < 4; t++) e += mC[r >> 8 * t + 4 & 15] + mC[r >> 8 * t & 15];
  return e;
}
function vee(r) {
  return String.fromCharCode(255 & r, (65280 & r) >> 8, (16711680 & r) >> 16, (4278190080 & r) >> 24);
}
function o2(r) {
  return UR(r).map(vee).join("");
}
var xee = function(r) {
  for (var e = 0; e < r.length; e++) r[e] = bee(r[e]);
  return r.join("");
}(UR("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Vh(r, e) {
  if (xee) {
    var t = (65535 & r) + (65535 & e);
    return (r >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return r + e & 4294967295;
}
/**
* @license
* FPDF is released under a permissive license: there is no usage restriction.
* You may embed it freely in your application (commercial or not), with or
* without modifications.
*
* Reference: http://www.fpdf.org/en/script/script37.php
*/
function a2(r, e) {
  var t, i, n, s;
  if (r !== t) {
    for (var c = (n = r, s = 1 + (256 / r.length | 0), new Array(s + 1).join(n)), o = [], d = 0; d < 256; d++) o[d] = d;
    var m = 0;
    for (d = 0; d < 256; d++) {
      var y = o[d];
      m = (m + y + c.charCodeAt(d)) % 256, o[d] = o[m], o[m] = y;
    }
    t = r, i = o;
  } else o = i;
  var T = e.length, P = 0, I = 0, D = "";
  for (d = 0; d < T; d++) I = (I + (y = o[P = (P + 1) % 256])) % 256, o[P] = o[I], o[I] = y, c = o[(o[P] + o[I]) % 256], D += String.fromCharCode(e.charCodeAt(d) ^ c);
  return D;
}
/**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
* Author: Owen Leong (@owenl131)
* Date: 15 Oct 2020
* References:
* https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
* https://github.com/foliojs/pdfkit/blob/master/lib/security.js
* http://www.fpdf.org/en/script/script37.php
*/
var _C = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Kd(r, e, t, i) {
  this.v = 1, this.r = 2;
  var n = 192;
  r.forEach(function(o) {
    if (_C.perm !== void 0) throw new Error("Invalid permission: " + o);
    n += _C[o];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var s = (e + this.padding).substr(0, 32), c = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, c), this.P = -(1 + (255 ^ n)), this.encryptionKey = o2(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(i)).substr(0, 5), this.U = a2(this.encryptionKey, this.padding);
}
function Qd(r) {
  if (/[^\u0000-\u00ff]/.test(r)) throw new Error("Invalid PDF Name Object: " + r + ", Only accept ASCII characters.");
  for (var e = "", t = r.length, i = 0; i < t; i++) {
    var n = r.charCodeAt(i);
    e += n < 33 || n === 35 || n === 37 || n === 40 || n === 41 || n === 47 || n === 60 || n === 62 || n === 91 || n === 93 || n === 123 || n === 125 || n > 126 ? "#" + ("0" + n.toString(16)).slice(-2) : r[i];
  }
  return e;
}
function yC(r) {
  if (un(r) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, i, n) {
    if (n = n || !1, typeof t != "string" || typeof i != "function" || typeof n != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var s = Math.random().toString(35);
    return e[t][s] = [i, !!n], s;
  }, this.unsubscribe = function(t) {
    for (var i in e) if (e[i][t]) return delete e[i][t], Object.keys(e[i]).length === 0 && delete e[i], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var i = Array.prototype.slice.call(arguments, 1), n = [];
      for (var s in e[t]) {
        var c = e[t][s];
        try {
          c[0].apply(r, i);
        } catch (o) {
          ai.console && An.error("jsPDF PubSub Error", o.message, o);
        }
        c[1] && n.push(s);
      }
      n.length && n.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function Vy(r) {
  if (!(this instanceof Vy)) return new Vy(r);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in r) r.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = r[t]);
  this.id = "", this.objectNumber = -1;
}
function zR(r, e) {
  this.gState = r, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function Lf(r, e, t, i, n) {
  if (!(this instanceof Lf)) return new Lf(r, e, t, i, n);
  this.type = r === "axial" ? 2 : 3, this.coords = e, this.colors = t, zR.call(this, i, n);
}
function lp(r, e, t, i, n) {
  if (!(this instanceof lp)) return new lp(r, e, t, i, n);
  this.boundingBox = r, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, zR.call(this, i, n);
}
function Ur(r) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", i = arguments[1], n = arguments[2], s = arguments[3], c = [], o = 1, d = 16, m = "S", y = null;
  un(r = r || {}) === "object" && (t = r.orientation, i = r.unit || i, n = r.format || n, s = r.compress || r.compressPdf || s, (y = r.encryption || null) !== null && (y.userPassword = y.userPassword || "", y.ownerPassword = y.ownerPassword || "", y.userPermissions = y.userPermissions || []), o = typeof r.userUnit == "number" ? Math.abs(r.userUnit) : 1, r.precision !== void 0 && (e = r.precision), r.floatPrecision !== void 0 && (d = r.floatPrecision), m = r.defaultPathOperation || "S"), c = r.filters || (s === !0 ? ["FlateEncode"] : c), i = i || "mm", t = ("" + (t || "P")).toLowerCase();
  var T = r.putOnlyUsedFonts || !1, P = {}, I = { internal: {}, __private__: {} };
  I.__private__.PubSub = yC;
  var D = "1.3", k = I.__private__.getPdfVersion = function() {
    return D;
  };
  I.__private__.setPdfVersion = function(F) {
    D = F;
  };
  var $ = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  I.__private__.getPageFormats = function() {
    return $;
  };
  var G = I.__private__.getPageFormat = function(F) {
    return $[F];
  };
  n = n || "a4";
  var te = "compat", Z = "advanced", H = te;
  function J() {
    this.saveGraphicsState(), Oe(new _r(Ue, 0, 0, -Ue, 0, Ts() * Ue).toString() + " cm"), this.setFontSize(this.getFontSize() / Ue), m = "n", H = Z;
  }
  function re() {
    this.restoreGraphicsState(), m = "S", H = te;
  }
  var be = I.__private__.combineFontStyleAndFontWeight = function(F, se) {
    if (F == "bold" && se == "normal" || F == "bold" && se == 400 || F == "normal" && se == "italic" || F == "bold" && se == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return se && (F = se == 400 || se === "normal" ? F === "italic" ? "italic" : "normal" : se != 700 && se !== "bold" || F !== "normal" ? (se == 700 ? "bold" : se) + "" + F : "bold"), F;
  };
  I.advancedAPI = function(F) {
    var se = H === te;
    return se && J.call(this), typeof F != "function" || (F(this), se && re.call(this)), this;
  }, I.compatAPI = function(F) {
    var se = H === Z;
    return se && re.call(this), typeof F != "function" || (F(this), se && J.call(this)), this;
  }, I.isAdvancedAPI = function() {
    return H === Z;
  };
  var pe, oe = function(F) {
    if (H !== Z) throw new Error(F + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, Ee = I.roundToPrecision = I.__private__.roundToPrecision = function(F, se) {
    var Ie = e || se;
    if (isNaN(F) || isNaN(Ie)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return F.toFixed(Ie).replace(/0+$/, "");
  };
  pe = I.hpf = I.__private__.hpf = typeof d == "number" ? function(F) {
    if (isNaN(F)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ee(F, d);
  } : d === "smart" ? function(F) {
    if (isNaN(F)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ee(F, F > -1 && F < 1 ? 16 : 5);
  } : function(F) {
    if (isNaN(F)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ee(F, 16);
  };
  var le = I.f2 = I.__private__.f2 = function(F) {
    if (isNaN(F)) throw new Error("Invalid argument passed to jsPDF.f2");
    return Ee(F, 2);
  }, _e = I.__private__.f3 = function(F) {
    if (isNaN(F)) throw new Error("Invalid argument passed to jsPDF.f3");
    return Ee(F, 3);
  }, Ve = I.scale = I.__private__.scale = function(F) {
    if (isNaN(F)) throw new Error("Invalid argument passed to jsPDF.scale");
    return H === te ? F * Ue : H === Z ? F : void 0;
  }, Be = function(F) {
    return Ve(function(se) {
      return H === te ? Ts() - se : H === Z ? se : void 0;
    }(F));
  };
  I.__private__.setPrecision = I.setPrecision = function(F) {
    typeof parseInt(F, 10) == "number" && (e = parseInt(F, 10));
  };
  var gt, St = "00000000000000000000000000000000", Mt = I.__private__.getFileId = function() {
    return St;
  }, mt = I.__private__.setFileId = function(F) {
    return St = F !== void 0 && /^[a-fA-F0-9]{32}$/.test(F) ? F.toUpperCase() : St.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), y !== null && (Sn = new Kd(y.userPermissions, y.userPassword, y.ownerPassword, St)), St;
  };
  I.setFileId = function(F) {
    return mt(F), this;
  }, I.getFileId = function() {
    return Mt();
  };
  var wt = I.__private__.convertDateToPDFDate = function(F) {
    var se = F.getTimezoneOffset(), Ie = se < 0 ? "+" : "-", Ye = Math.floor(Math.abs(se / 60)), ut = Math.abs(se % 60), Nt = [Ie, je(Ye), "'", je(ut), "'"].join("");
    return ["D:", F.getFullYear(), je(F.getMonth() + 1), je(F.getDate()), je(F.getHours()), je(F.getMinutes()), je(F.getSeconds()), Nt].join("");
  }, Yt = I.__private__.convertPDFDateToDate = function(F) {
    var se = parseInt(F.substr(2, 4), 10), Ie = parseInt(F.substr(6, 2), 10) - 1, Ye = parseInt(F.substr(8, 2), 10), ut = parseInt(F.substr(10, 2), 10), Nt = parseInt(F.substr(12, 2), 10), Ut = parseInt(F.substr(14, 2), 10);
    return new Date(se, Ie, Ye, ut, Nt, Ut, 0);
  }, Dt = I.__private__.setCreationDate = function(F) {
    var se;
    if (F === void 0 && (F = /* @__PURE__ */ new Date()), F instanceof Date) se = wt(F);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(F)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      se = F;
    }
    return gt = se;
  }, fe = I.__private__.getCreationDate = function(F) {
    var se = gt;
    return F === "jsDate" && (se = Yt(gt)), se;
  };
  I.setCreationDate = function(F) {
    return Dt(F), this;
  }, I.getCreationDate = function(F) {
    return fe(F);
  };
  var De, je = I.__private__.padd2 = function(F) {
    return ("0" + parseInt(F)).slice(-2);
  }, Ke = I.__private__.padd2Hex = function(F) {
    return ("00" + (F = F.toString())).substr(F.length);
  }, rt = 0, at = [], Et = [], Tt = 0, Vt = [], tr = [], ur = !1, dr = Et;
  I.__private__.setCustomOutputDestination = function(F) {
    ur = !0, dr = F;
  };
  var Ct = function(F) {
    ur || (dr = F);
  };
  I.__private__.resetCustomOutputDestination = function() {
    ur = !1, dr = Et;
  };
  var Oe = I.__private__.out = function(F) {
    return F = F.toString(), Tt += F.length + 1, dr.push(F), dr;
  }, ii = I.__private__.write = function(F) {
    return Oe(arguments.length === 1 ? F.toString() : Array.prototype.join.call(arguments, " "));
  }, Zr = I.__private__.getArrayBuffer = function(F) {
    for (var se = F.length, Ie = new ArrayBuffer(se), Ye = new Uint8Array(Ie); se--; ) Ye[se] = F.charCodeAt(se);
    return Ie;
  }, Rr = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  I.__private__.getStandardFonts = function() {
    return Rr;
  };
  var Jt = r.fontSize || 16;
  I.__private__.setFontSize = I.setFontSize = function(F) {
    return Jt = H === Z ? F / Ue : F, this;
  };
  var Sr, hr = I.__private__.getFontSize = I.getFontSize = function() {
    return H === te ? Jt : Jt * Ue;
  }, qr = r.R2L || !1;
  I.__private__.setR2L = I.setR2L = function(F) {
    return qr = F, this;
  }, I.__private__.getR2L = I.getR2L = function() {
    return qr;
  };
  var xr, bi = I.__private__.setZoomMode = function(F) {
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(F)) Sr = F;
    else if (isNaN(F)) {
      if ([void 0, null, "fullwidth", "fullheight", "fullpage", "original"].indexOf(F) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + F + '" is not recognized.');
      Sr = F;
    } else Sr = parseInt(F, 10);
  };
  I.__private__.getZoomMode = function() {
    return Sr;
  };
  var Yr, Fr = I.__private__.setPageMode = function(F) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(F) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + F + '" is not recognized.');
    xr = F;
  };
  I.__private__.getPageMode = function() {
    return xr;
  };
  var Ri = I.__private__.setLayoutMode = function(F) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(F) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + F + '" is not recognized.');
    Yr = F;
  };
  I.__private__.getLayoutMode = function() {
    return Yr;
  }, I.__private__.setDisplayMode = I.setDisplayMode = function(F, se, Ie) {
    return bi(F), Ri(se), Fr(Ie), this;
  };
  var Kr = { title: "", subject: "", author: "", keywords: "", creator: "" };
  I.__private__.getDocumentProperty = function(F) {
    if (Object.keys(Kr).indexOf(F) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Kr[F];
  }, I.__private__.getDocumentProperties = function() {
    return Kr;
  }, I.__private__.setDocumentProperties = I.setProperties = I.setDocumentProperties = function(F) {
    for (var se in Kr) Kr.hasOwnProperty(se) && F[se] && (Kr[se] = F[se]);
    return this;
  }, I.__private__.setDocumentProperty = function(F, se) {
    if (Object.keys(Kr).indexOf(F) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Kr[F] = se;
  };
  var wr, Ue, K, ne, de, Te = {}, Pe = {}, qe = [], Je = {}, He = {}, nt = {}, Bt = {}, It = null, rr = 0, We = [], mr = new yC(I), Li = r.hotfixes || [], fr = {}, Hr = {}, li = [], _r = function F(se, Ie, Ye, ut, Nt, Ut) {
    if (!(this instanceof F)) return new F(se, Ie, Ye, ut, Nt, Ut);
    isNaN(se) && (se = 1), isNaN(Ie) && (Ie = 0), isNaN(Ye) && (Ye = 0), isNaN(ut) && (ut = 1), isNaN(Nt) && (Nt = 0), isNaN(Ut) && (Ut = 0), this._matrix = [se, Ie, Ye, ut, Nt, Ut];
  };
  Object.defineProperty(_r.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(F) {
    this._matrix[0] = F;
  } }), Object.defineProperty(_r.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(F) {
    this._matrix[1] = F;
  } }), Object.defineProperty(_r.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(F) {
    this._matrix[2] = F;
  } }), Object.defineProperty(_r.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(F) {
    this._matrix[3] = F;
  } }), Object.defineProperty(_r.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(F) {
    this._matrix[4] = F;
  } }), Object.defineProperty(_r.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(F) {
    this._matrix[5] = F;
  } }), Object.defineProperty(_r.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(F) {
    this._matrix[0] = F;
  } }), Object.defineProperty(_r.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(F) {
    this._matrix[1] = F;
  } }), Object.defineProperty(_r.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(F) {
    this._matrix[2] = F;
  } }), Object.defineProperty(_r.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(F) {
    this._matrix[3] = F;
  } }), Object.defineProperty(_r.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(F) {
    this._matrix[4] = F;
  } }), Object.defineProperty(_r.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(F) {
    this._matrix[5] = F;
  } }), Object.defineProperty(_r.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(_r.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(_r.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(_r.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), _r.prototype.join = function(F) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(pe).join(F);
  }, _r.prototype.multiply = function(F) {
    var se = F.sx * this.sx + F.shy * this.shx, Ie = F.sx * this.shy + F.shy * this.sy, Ye = F.shx * this.sx + F.sy * this.shx, ut = F.shx * this.shy + F.sy * this.sy, Nt = F.tx * this.sx + F.ty * this.shx + this.tx, Ut = F.tx * this.shy + F.ty * this.sy + this.ty;
    return new _r(se, Ie, Ye, ut, Nt, Ut);
  }, _r.prototype.decompose = function() {
    var F = this.sx, se = this.shy, Ie = this.shx, Ye = this.sy, ut = this.tx, Nt = this.ty, Ut = Math.sqrt(F * F + se * se), vr = (F /= Ut) * Ie + (se /= Ut) * Ye;
    Ie -= F * vr, Ye -= se * vr;
    var Cr = Math.sqrt(Ie * Ie + Ye * Ye);
    return vr /= Cr, F * (Ye /= Cr) < se * (Ie /= Cr) && (F = -F, se = -se, vr = -vr, Ut = -Ut), { scale: new _r(Ut, 0, 0, Cr, 0, 0), translate: new _r(1, 0, 0, 1, ut, Nt), rotate: new _r(F, se, -se, F, 0, 0), skew: new _r(1, 0, vr, 1, 0, 0) };
  }, _r.prototype.toString = function(F) {
    return this.join(" ");
  }, _r.prototype.inversed = function() {
    var F = this.sx, se = this.shy, Ie = this.shx, Ye = this.sy, ut = this.tx, Nt = this.ty, Ut = 1 / (F * Ye - se * Ie), vr = Ye * Ut, Cr = -se * Ut, Ir = -Ie * Ut, ni = F * Ut;
    return new _r(vr, Cr, Ir, ni, -vr * ut - Ir * Nt, -Cr * ut - ni * Nt);
  }, _r.prototype.applyToPoint = function(F) {
    var se = F.x * this.sx + F.y * this.shx + this.tx, Ie = F.x * this.shy + F.y * this.sy + this.ty;
    return new Da(se, Ie);
  }, _r.prototype.applyToRectangle = function(F) {
    var se = this.applyToPoint(F), Ie = this.applyToPoint(new Da(F.x + F.w, F.y + F.h));
    return new ro(se.x, se.y, Ie.x - se.x, Ie.y - se.y);
  }, _r.prototype.clone = function() {
    var F = this.sx, se = this.shy, Ie = this.shx, Ye = this.sy, ut = this.tx, Nt = this.ty;
    return new _r(F, se, Ie, Ye, ut, Nt);
  }, I.Matrix = _r;
  var qi = I.matrixMult = function(F, se) {
    return se.multiply(F);
  }, nn = new _r(1, 0, 0, 1, 0, 0);
  I.unitMatrix = I.identityMatrix = nn;
  var Ei = function(F, se) {
    if (!He[F]) {
      var Ie = (se instanceof Lf ? "Sh" : "P") + (Object.keys(Je).length + 1).toString(10);
      se.id = Ie, He[F] = Ie, Je[Ie] = se, mr.publish("addPattern", se);
    }
  };
  I.ShadingPattern = Lf, I.TilingPattern = lp, I.addShadingPattern = function(F, se) {
    return oe("addShadingPattern()"), Ei(F, se), this;
  }, I.beginTilingPattern = function(F) {
    oe("beginTilingPattern()"), ta(F.boundingBox[0], F.boundingBox[1], F.boundingBox[2] - F.boundingBox[0], F.boundingBox[3] - F.boundingBox[1], F.matrix);
  }, I.endTilingPattern = function(F, se) {
    oe("endTilingPattern()"), se.stream = tr[De].join(`
`), Ei(F, se), mr.publish("endTilingPattern", se), li.pop().restore();
  };
  var vi, ci = I.__private__.newObject = function() {
    var F = Lt();
    return pi(F, !0), F;
  }, Lt = I.__private__.newObjectDeferred = function() {
    return rt++, at[rt] = function() {
      return Tt;
    }, rt;
  }, pi = function(F, se) {
    return se = typeof se == "boolean" && se, at[F] = Tt, se && Oe(F + " 0 obj"), F;
  }, Rn = I.__private__.newAdditionalObject = function() {
    var F = { objId: Lt(), content: "" };
    return Vt.push(F), F;
  }, eo = Lt(), sn = Lt(), Xt = I.__private__.decodeColorString = function(F) {
    var se = F.split(" ");
    if (se.length !== 2 || se[1] !== "g" && se[1] !== "G") se.length !== 5 || se[4] !== "k" && se[4] !== "K" || (se = [(1 - se[0]) * (1 - se[3]), (1 - se[1]) * (1 - se[3]), (1 - se[2]) * (1 - se[3]), "r"]);
    else {
      var Ie = parseFloat(se[0]);
      se = [Ie, Ie, Ie, "r"];
    }
    for (var Ye = "#", ut = 0; ut < 3; ut++) Ye += ("0" + Math.floor(255 * parseFloat(se[ut])).toString(16)).slice(-2);
    return Ye;
  }, Dr = I.__private__.encodeColorString = function(F) {
    var se;
    typeof F == "string" && (F = { ch1: F });
    var Ie = F.ch1, Ye = F.ch2, ut = F.ch3, Nt = F.ch4, Ut = F.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof Ie == "string" && Ie.charAt(0) !== "#") {
      var vr = new FR(Ie);
      if (vr.ok) Ie = vr.toHex();
      else if (!/^\d*\.?\d*$/.test(Ie)) throw new Error('Invalid color "' + Ie + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof Ie == "string" && /^#[0-9A-Fa-f]{3}$/.test(Ie) && (Ie = "#" + Ie[1] + Ie[1] + Ie[2] + Ie[2] + Ie[3] + Ie[3]), typeof Ie == "string" && /^#[0-9A-Fa-f]{6}$/.test(Ie)) {
      var Cr = parseInt(Ie.substr(1), 16);
      Ie = Cr >> 16 & 255, Ye = Cr >> 8 & 255, ut = 255 & Cr;
    }
    if (Ye === void 0 || Nt === void 0 && Ie === Ye && Ye === ut) se = typeof Ie == "string" ? Ie + " " + Ut[0] : F.precision === 2 ? le(Ie / 255) + " " + Ut[0] : _e(Ie / 255) + " " + Ut[0];
    else if (Nt === void 0 || un(Nt) === "object") {
      if (Nt && !isNaN(Nt.a) && Nt.a === 0) return ["1.", "1.", "1.", Ut[1]].join(" ");
      se = typeof Ie == "string" ? [Ie, Ye, ut, Ut[1]].join(" ") : F.precision === 2 ? [le(Ie / 255), le(Ye / 255), le(ut / 255), Ut[1]].join(" ") : [_e(Ie / 255), _e(Ye / 255), _e(ut / 255), Ut[1]].join(" ");
    } else se = typeof Ie == "string" ? [Ie, Ye, ut, Nt, Ut[2]].join(" ") : F.precision === 2 ? [le(Ie), le(Ye), le(ut), le(Nt), Ut[2]].join(" ") : [_e(Ie), _e(Ye), _e(ut), _e(Nt), Ut[2]].join(" ");
    return se;
  }, zr = I.__private__.getFilters = function() {
    return c;
  }, bn = I.__private__.putStream = function(F) {
    var se = (F = F || {}).data || "", Ie = F.filters || zr(), Ye = F.alreadyAppliedFilters || [], ut = F.addLength1 || !1, Nt = se.length, Ut = F.objectId, vr = function(an) {
      return an;
    };
    if (y !== null && Ut === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    y !== null && (vr = Sn.encryptor(Ut, 0));
    var Cr = {};
    Ie === !0 && (Ie = ["FlateEncode"]);
    var Ir = F.additionalKeyValues || [], ni = (Cr = Ur.API.processDataByFilters !== void 0 ? Ur.API.processDataByFilters(se, Ie) : { data: se, reverseChain: [] }).reverseChain + (Array.isArray(Ye) ? Ye.join(" ") : Ye.toString());
    if (Cr.data.length !== 0 && (Ir.push({ key: "Length", value: Cr.data.length }), ut === !0 && Ir.push({ key: "Length1", value: Nt })), ni.length != 0) if (ni.split("/").length - 1 == 1) Ir.push({ key: "Filter", value: ni });
    else {
      Ir.push({ key: "Filter", value: "[" + ni + "]" });
      for (var ri = 0; ri < Ir.length; ri += 1) if (Ir[ri].key === "DecodeParms") {
        for (var Fi = [], En = 0; En < Cr.reverseChain.split("/").length - 1; En += 1) Fi.push("null");
        Fi.push(Ir[ri].value), Ir[ri].value = "[" + Fi.join(" ") + "]";
      }
    }
    Oe("<<");
    for (var Ui = 0; Ui < Ir.length; Ui++) Oe("/" + Ir[Ui].key + " " + Ir[Ui].value);
    Oe(">>"), Cr.data.length !== 0 && (Oe("stream"), Oe(vr(Cr.data)), Oe("endstream"));
  }, qo = I.__private__.putPage = function(F) {
    var se = F.number, Ie = F.data, Ye = F.objId, ut = F.contentsObjId;
    pi(Ye, !0), Oe("<</Type /Page"), Oe("/Parent " + F.rootDictionaryObjId + " 0 R"), Oe("/Resources " + F.resourceDictionaryObjId + " 0 R"), Oe("/MediaBox [" + parseFloat(pe(F.mediaBox.bottomLeftX)) + " " + parseFloat(pe(F.mediaBox.bottomLeftY)) + " " + pe(F.mediaBox.topRightX) + " " + pe(F.mediaBox.topRightY) + "]"), F.cropBox !== null && Oe("/CropBox [" + pe(F.cropBox.bottomLeftX) + " " + pe(F.cropBox.bottomLeftY) + " " + pe(F.cropBox.topRightX) + " " + pe(F.cropBox.topRightY) + "]"), F.bleedBox !== null && Oe("/BleedBox [" + pe(F.bleedBox.bottomLeftX) + " " + pe(F.bleedBox.bottomLeftY) + " " + pe(F.bleedBox.topRightX) + " " + pe(F.bleedBox.topRightY) + "]"), F.trimBox !== null && Oe("/TrimBox [" + pe(F.trimBox.bottomLeftX) + " " + pe(F.trimBox.bottomLeftY) + " " + pe(F.trimBox.topRightX) + " " + pe(F.trimBox.topRightY) + "]"), F.artBox !== null && Oe("/ArtBox [" + pe(F.artBox.bottomLeftX) + " " + pe(F.artBox.bottomLeftY) + " " + pe(F.artBox.topRightX) + " " + pe(F.artBox.topRightY) + "]"), typeof F.userUnit == "number" && F.userUnit !== 1 && Oe("/UserUnit " + F.userUnit), mr.publish("putPage", { objId: Ye, pageContext: We[se], pageNumber: se, page: Ie }), Oe("/Contents " + ut + " 0 R"), Oe(">>"), Oe("endobj");
    var Nt = Ie.join(`
`);
    return H === Z && (Nt += `
Q`), pi(ut, !0), bn({ data: Nt, filters: zr(), objectId: ut }), Oe("endobj"), Ye;
  }, Qn = I.__private__.putPages = function() {
    var F, se, Ie = [];
    for (F = 1; F <= rr; F++) We[F].objId = Lt(), We[F].contentsObjId = Lt();
    for (F = 1; F <= rr; F++) Ie.push(qo({ number: F, data: tr[F], objId: We[F].objId, contentsObjId: We[F].contentsObjId, mediaBox: We[F].mediaBox, cropBox: We[F].cropBox, bleedBox: We[F].bleedBox, trimBox: We[F].trimBox, artBox: We[F].artBox, userUnit: We[F].userUnit, rootDictionaryObjId: eo, resourceDictionaryObjId: sn }));
    pi(eo, !0), Oe("<</Type /Pages");
    var Ye = "/Kids [";
    for (se = 0; se < rr; se++) Ye += Ie[se] + " 0 R ";
    Oe(Ye + "]"), Oe("/Count " + rr), Oe(">>"), Oe("endobj"), mr.publish("postPutPages");
  }, Nr = function(F) {
    mr.publish("putFont", { font: F, out: Oe, newObject: ci, putStream: bn }), F.isAlreadyPutted !== !0 && (F.objectNumber = ci(), Oe("<<"), Oe("/Type /Font"), Oe("/BaseFont /" + Qd(F.postScriptName)), Oe("/Subtype /Type1"), typeof F.encoding == "string" && Oe("/Encoding /" + F.encoding), Oe("/FirstChar 32"), Oe("/LastChar 255"), Oe(">>"), Oe("endobj"));
  }, wo = function(F) {
    F.objectNumber = ci();
    var se = [];
    se.push({ key: "Type", value: "/XObject" }), se.push({ key: "Subtype", value: "/Form" }), se.push({ key: "BBox", value: "[" + [pe(F.x), pe(F.y), pe(F.x + F.width), pe(F.y + F.height)].join(" ") + "]" }), se.push({ key: "Matrix", value: "[" + F.matrix.toString() + "]" });
    var Ie = F.pages[1].join(`
`);
    bn({ data: Ie, additionalKeyValues: se, objectId: F.objectNumber }), Oe("endobj");
  }, Wo = function(F, se) {
    se || (se = 21);
    var Ie = ci(), Ye = function(Ut, vr) {
      var Cr, Ir = [], ni = 1 / (vr - 1);
      for (Cr = 0; Cr < 1; Cr += ni) Ir.push(Cr);
      if (Ir.push(1), Ut[0].offset != 0) {
        var ri = { offset: 0, color: Ut[0].color };
        Ut.unshift(ri);
      }
      if (Ut[Ut.length - 1].offset != 1) {
        var Fi = { offset: 1, color: Ut[Ut.length - 1].color };
        Ut.push(Fi);
      }
      for (var En = "", Ui = 0, an = 0; an < Ir.length; an++) {
        for (Cr = Ir[an]; Cr > Ut[Ui + 1].offset; ) Ui++;
        var vn = Ut[Ui].offset, Un = (Cr - vn) / (Ut[Ui + 1].offset - vn), qn = Ut[Ui].color, Fa = Ut[Ui + 1].color;
        En += Ke(Math.round((1 - Un) * qn[0] + Un * Fa[0]).toString(16)) + Ke(Math.round((1 - Un) * qn[1] + Un * Fa[1]).toString(16)) + Ke(Math.round((1 - Un) * qn[2] + Un * Fa[2]).toString(16));
      }
      return En.trim();
    }(F.colors, se), ut = [];
    ut.push({ key: "FunctionType", value: "0" }), ut.push({ key: "Domain", value: "[0.0 1.0]" }), ut.push({ key: "Size", value: "[" + se + "]" }), ut.push({ key: "BitsPerSample", value: "8" }), ut.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ut.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), bn({ data: Ye, additionalKeyValues: ut, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Ie }), Oe("endobj"), F.objectNumber = ci(), Oe("<< /ShadingType " + F.type), Oe("/ColorSpace /DeviceRGB");
    var Nt = "/Coords [" + pe(parseFloat(F.coords[0])) + " " + pe(parseFloat(F.coords[1])) + " ";
    F.type === 2 ? Nt += pe(parseFloat(F.coords[2])) + " " + pe(parseFloat(F.coords[3])) : Nt += pe(parseFloat(F.coords[2])) + " " + pe(parseFloat(F.coords[3])) + " " + pe(parseFloat(F.coords[4])) + " " + pe(parseFloat(F.coords[5])), Oe(Nt += "]"), F.matrix && Oe("/Matrix [" + F.matrix.toString() + "]"), Oe("/Function " + Ie + " 0 R"), Oe("/Extend [true true]"), Oe(">>"), Oe("endobj");
  }, Xo = function(F, se) {
    var Ie = Lt(), Ye = ci();
    se.push({ resourcesOid: Ie, objectOid: Ye }), F.objectNumber = Ye;
    var ut = [];
    ut.push({ key: "Type", value: "/Pattern" }), ut.push({ key: "PatternType", value: "1" }), ut.push({ key: "PaintType", value: "1" }), ut.push({ key: "TilingType", value: "1" }), ut.push({ key: "BBox", value: "[" + F.boundingBox.map(pe).join(" ") + "]" }), ut.push({ key: "XStep", value: pe(F.xStep) }), ut.push({ key: "YStep", value: pe(F.yStep) }), ut.push({ key: "Resources", value: Ie + " 0 R" }), F.matrix && ut.push({ key: "Matrix", value: "[" + F.matrix.toString() + "]" }), bn({ data: F.stream, additionalKeyValues: ut, objectId: F.objectNumber }), Oe("endobj");
  }, Ul = function(F) {
    for (var se in F.objectNumber = ci(), Oe("<<"), F) switch (se) {
      case "opacity":
        Oe("/ca " + le(F[se]));
        break;
      case "stroke-opacity":
        Oe("/CA " + le(F[se]));
    }
    Oe(">>"), Oe("endobj");
  }, Zo = function(F) {
    pi(F.resourcesOid, !0), Oe("<<"), Oe("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), function() {
      for (var se in Oe("/Font <<"), Te) Te.hasOwnProperty(se) && (T === !1 || T === !0 && P.hasOwnProperty(se)) && Oe("/" + se + " " + Te[se].objectNumber + " 0 R");
      Oe(">>");
    }(), function() {
      if (Object.keys(Je).length > 0) {
        for (var se in Oe("/Shading <<"), Je) Je.hasOwnProperty(se) && Je[se] instanceof Lf && Je[se].objectNumber >= 0 && Oe("/" + se + " " + Je[se].objectNumber + " 0 R");
        mr.publish("putShadingPatternDict"), Oe(">>");
      }
    }(), function(se) {
      if (Object.keys(Je).length > 0) {
        for (var Ie in Oe("/Pattern <<"), Je) Je.hasOwnProperty(Ie) && Je[Ie] instanceof I.TilingPattern && Je[Ie].objectNumber >= 0 && Je[Ie].objectNumber < se && Oe("/" + Ie + " " + Je[Ie].objectNumber + " 0 R");
        mr.publish("putTilingPatternDict"), Oe(">>");
      }
    }(F.objectOid), function() {
      if (Object.keys(nt).length > 0) {
        var se;
        for (se in Oe("/ExtGState <<"), nt) nt.hasOwnProperty(se) && nt[se].objectNumber >= 0 && Oe("/" + se + " " + nt[se].objectNumber + " 0 R");
        mr.publish("putGStateDict"), Oe(">>");
      }
    }(), function() {
      for (var se in Oe("/XObject <<"), fr) fr.hasOwnProperty(se) && fr[se].objectNumber >= 0 && Oe("/" + se + " " + fr[se].objectNumber + " 0 R");
      mr.publish("putXobjectDict"), Oe(">>");
    }(), Oe(">>"), Oe("endobj");
  }, ol = function(F) {
    Pe[F.fontName] = Pe[F.fontName] || {}, Pe[F.fontName][F.fontStyle] = F.id;
  }, Ao = function(F, se, Ie, Ye, ut) {
    var Nt = { id: "F" + (Object.keys(Te).length + 1).toString(10), postScriptName: F, fontName: se, fontStyle: Ie, encoding: Ye, isStandardFont: ut || !1, metadata: {} };
    return mr.publish("addFont", { font: Nt, instance: this }), Te[Nt.id] = Nt, ol(Nt), Nt.id;
  }, Qi = I.__private__.pdfEscape = I.pdfEscape = function(F, se) {
    return function(Ie, Ye) {
      var ut, Nt, Ut, vr, Cr, Ir, ni, ri, Fi;
      if (Ut = (Ye = Ye || {}).sourceEncoding || "Unicode", Cr = Ye.outputEncoding, (Ye.autoencode || Cr) && Te[wr].metadata && Te[wr].metadata[Ut] && Te[wr].metadata[Ut].encoding && (vr = Te[wr].metadata[Ut].encoding, !Cr && Te[wr].encoding && (Cr = Te[wr].encoding), !Cr && vr.codePages && (Cr = vr.codePages[0]), typeof Cr == "string" && (Cr = vr[Cr]), Cr)) {
        for (ni = !1, Ir = [], ut = 0, Nt = Ie.length; ut < Nt; ut++) (ri = Cr[Ie.charCodeAt(ut)]) ? Ir.push(String.fromCharCode(ri)) : Ir.push(Ie[ut]), Ir[ut].charCodeAt(0) >> 8 && (ni = !0);
        Ie = Ir.join("");
      }
      for (ut = Ie.length; ni === void 0 && ut !== 0; ) Ie.charCodeAt(ut - 1) >> 8 && (ni = !0), ut--;
      if (!ni) return Ie;
      for (Ir = Ye.noBOM ? [] : [254, 255], ut = 0, Nt = Ie.length; ut < Nt; ut++) {
        if ((Fi = (ri = Ie.charCodeAt(ut)) >> 8) >> 8) throw new Error("Character at position " + ut + " of string '" + Ie + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
        Ir.push(Fi), Ir.push(ri - (Fi << 8));
      }
      return String.fromCharCode.apply(void 0, Ir);
    }(F, se).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, ti = I.__private__.beginPage = function(F) {
    tr[++rr] = [], We[rr] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(F[0]), topRightY: Number(F[1]) } }, fa(rr), Ct(tr[De]);
  }, ch = function(F, se) {
    var Ie, Ye, ut;
    switch (t = se || t, typeof F == "string" && (Ie = G(F.toLowerCase()), Array.isArray(Ie) && (Ye = Ie[0], ut = Ie[1])), Array.isArray(F) && (Ye = F[0] * Ue, ut = F[1] * Ue), isNaN(Ye) && (Ye = n[0], ut = n[1]), (Ye > 14400 || ut > 14400) && (An.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Ye = Math.min(14400, Ye), ut = Math.min(14400, ut)), n = [Ye, ut], t.substr(0, 1)) {
      case "l":
        ut > Ye && (n = [ut, Ye]);
        break;
      case "p":
        Ye > ut && (n = [ut, Ye]);
    }
    ti(n), Fn(ka), Oe(fl), Or !== 0 && Oe(Or + " J"), dl !== 0 && Oe(dl + " j"), mr.publish("addPage", { pageNumber: rr });
  }, ha = function(F) {
    F > 0 && F <= rr && (tr.splice(F, 1), We.splice(F, 1), rr--, De > rr && (De = rr), this.setPage(De));
  }, fa = function(F) {
    F > 0 && F <= rr && (De = F);
  }, Yo = I.__private__.getNumberOfPages = I.getNumberOfPages = function() {
    return tr.length - 1;
  }, Jo = function(F, se, Ie) {
    var Ye, ut = void 0;
    return Ie = Ie || {}, F = F !== void 0 ? F : Te[wr].fontName, se = se !== void 0 ? se : Te[wr].fontStyle, Ye = F.toLowerCase(), Pe[Ye] !== void 0 && Pe[Ye][se] !== void 0 ? ut = Pe[Ye][se] : Pe[F] !== void 0 && Pe[F][se] !== void 0 ? ut = Pe[F][se] : Ie.disableWarning === !1 && An.warn("Unable to look up font label for font '" + F + "', '" + se + "'. Refer to getFontList() for available fonts."), ut || Ie.noFallback || (ut = Pe.times[se]) == null && (ut = Pe.times.normal), ut;
  }, zl = I.__private__.putInfo = function() {
    var F = ci(), se = function(Ye) {
      return Ye;
    };
    for (var Ie in y !== null && (se = Sn.encryptor(F, 0)), Oe("<<"), Oe("/Producer (" + Qi(se("jsPDF " + Ur.version)) + ")"), Kr) Kr.hasOwnProperty(Ie) && Kr[Ie] && Oe("/" + Ie.substr(0, 1).toUpperCase() + Ie.substr(1) + " (" + Qi(se(Kr[Ie])) + ")");
    Oe("/CreationDate (" + Qi(se(gt)) + ")"), Oe(">>"), Oe("endobj");
  }, Tu = I.__private__.putCatalog = function(F) {
    var se = (F = F || {}).rootDictionaryObjId || eo;
    switch (ci(), Oe("<<"), Oe("/Type /Catalog"), Oe("/Pages " + se + " 0 R"), Sr || (Sr = "fullwidth"), Sr) {
      case "fullwidth":
        Oe("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Oe("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Oe("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Oe("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var Ie = "" + Sr;
        Ie.substr(Ie.length - 1) === "%" && (Sr = parseInt(Sr) / 100), typeof Sr == "number" && Oe("/OpenAction [3 0 R /XYZ null null " + le(Sr) + "]");
    }
    switch (Yr || (Yr = "continuous"), Yr) {
      case "continuous":
        Oe("/PageLayout /OneColumn");
        break;
      case "single":
        Oe("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Oe("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Oe("/PageLayout /TwoColumnRight");
    }
    xr && Oe("/PageMode /" + xr), mr.publish("putCatalog"), Oe(">>"), Oe("endobj");
  }, Ln = I.__private__.putTrailer = function() {
    Oe("trailer"), Oe("<<"), Oe("/Size " + (rt + 1)), Oe("/Root " + rt + " 0 R"), Oe("/Info " + (rt - 1) + " 0 R"), y !== null && Oe("/Encrypt " + Sn.oid + " 0 R"), Oe("/ID [ <" + St + "> <" + St + "> ]"), Oe(">>");
  }, da = I.__private__.putHeader = function() {
    Oe("%PDF-" + D), Oe("%ºß¬à");
  }, Su = I.__private__.putXRef = function() {
    var F = "0000000000";
    Oe("xref"), Oe("0 " + (rt + 1)), Oe("0000000000 65535 f ");
    for (var se = 1; se <= rt; se++) typeof at[se] == "function" ? Oe((F + at[se]()).slice(-10) + " 00000 n ") : at[se] !== void 0 ? Oe((F + at[se]).slice(-10) + " 00000 n ") : Oe("0000000000 00000 n ");
  }, La = I.__private__.buildDocument = function() {
    var F;
    rt = 0, Tt = 0, Et = [], at = [], Vt = [], eo = Lt(), sn = Lt(), Ct(Et), mr.publish("buildDocument"), da(), Qn(), function() {
      mr.publish("putAdditionalObjects");
      for (var Ie = 0; Ie < Vt.length; Ie++) {
        var Ye = Vt[Ie];
        pi(Ye.objId, !0), Oe(Ye.content), Oe("endobj");
      }
      mr.publish("postPutAdditionalObjects");
    }(), F = [], function() {
      for (var Ie in Te) Te.hasOwnProperty(Ie) && (T === !1 || T === !0 && P.hasOwnProperty(Ie)) && Nr(Te[Ie]);
    }(), function() {
      var Ie;
      for (Ie in nt) nt.hasOwnProperty(Ie) && Ul(nt[Ie]);
    }(), function() {
      for (var Ie in fr) fr.hasOwnProperty(Ie) && wo(fr[Ie]);
    }(), function(Ie) {
      var Ye;
      for (Ye in Je) Je.hasOwnProperty(Ye) && (Je[Ye] instanceof Lf ? Wo(Je[Ye]) : Je[Ye] instanceof lp && Xo(Je[Ye], Ie));
    }(F), mr.publish("putResources"), F.forEach(Zo), Zo({ resourcesOid: sn, objectOid: Number.MAX_SAFE_INTEGER }), mr.publish("postPutResources"), y !== null && (Sn.oid = ci(), Oe("<<"), Oe("/Filter /Standard"), Oe("/V " + Sn.v), Oe("/R " + Sn.r), Oe("/U <" + Sn.toHexString(Sn.U) + ">"), Oe("/O <" + Sn.toHexString(Sn.O) + ">"), Oe("/P " + Sn.P), Oe(">>"), Oe("endobj")), zl(), Tu();
    var se = Tt;
    return Su(), Ln(), Oe("startxref"), Oe("" + se), Oe("%%EOF"), Ct(tr[De]), Et.join(`
`);
  }, jl = I.__private__.getBlob = function(F) {
    return new Blob([Zr(F)], { type: "application/pdf" });
  }, Ko = I.output = I.__private__.output = (vi = function(F, se) {
    switch (typeof (se = se || {}) == "string" ? se = { filename: se } : se.filename = se.filename || "generated.pdf", F) {
      case void 0:
        return La();
      case "save":
        I.save(se.filename);
        break;
      case "arraybuffer":
        return Zr(La());
      case "blob":
        return jl(La());
      case "bloburi":
      case "bloburl":
        if (ai.URL !== void 0 && typeof ai.URL.createObjectURL == "function") return ai.URL && ai.URL.createObjectURL(jl(La())) || void 0;
        An.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var Ie = "", Ye = La();
        try {
          Ie = gC(Ye);
        } catch {
          Ie = gC(unescape(encodeURIComponent(Ye)));
        }
        return "data:application/pdf;filename=" + se.filename + ";base64," + Ie;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(ai) === "[object Window]") {
          var ut = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Nt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          se.pdfObjectUrl && (ut = se.pdfObjectUrl, Nt = "");
          var Ut = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + ut + '"' + Nt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(se) + ");<\/script></body></html>", vr = ai.open();
          return vr !== null && vr.document.write(Ut), vr;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(ai) === "[object Window]") {
          var Cr = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (se.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + se.filename + '" width="500px" height="400px" /></body></html>', Ir = ai.open();
          if (Ir !== null) {
            Ir.document.write(Cr);
            var ni = this;
            Ir.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Ir.document.title = se.filename, Ir.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(ni.output("bloburl"));
            };
          }
          return Ir;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(ai) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var ri = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", se) + '"></iframe></body></html>', Fi = ai.open();
        if (Fi !== null && (Fi.document.write(ri), Fi.document.title = se.filename), Fi || typeof safari > "u") return Fi;
        break;
      case "datauri":
      case "dataurl":
        return ai.document.location.href = this.output("datauristring", se);
      default:
        return null;
    }
  }, vi.foo = function() {
    try {
      return vi.apply(this, arguments);
    } catch (Ie) {
      var F = Ie.stack || "";
      ~F.indexOf(" at ") && (F = F.split(" at ")[1]);
      var se = "Error in function " + F.split(`
`)[0].split("<")[0] + ": " + Ie.message;
      if (!ai.console) throw new Error(se);
      ai.console.error(se, Ie), ai.alert && alert(se);
    }
  }, vi.foo.bar = vi, vi.foo), al = function(F) {
    return Array.isArray(Li) === !0 && Li.indexOf(F) > -1;
  };
  switch (i) {
    case "pt":
      Ue = 1;
      break;
    case "mm":
      Ue = 72 / 25.4;
      break;
    case "cm":
      Ue = 72 / 2.54;
      break;
    case "in":
      Ue = 72;
      break;
    case "px":
      Ue = al("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Ue = 12;
      break;
    case "ex":
      Ue = 6;
      break;
    default:
      if (typeof i != "number") throw new Error("Invalid unit: " + i);
      Ue = i;
  }
  var Sn = null;
  Dt(), mt();
  var Vl = I.__private__.getPageInfo = I.getPageInfo = function(F) {
    if (isNaN(F) || F % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: We[F].objId, pageNumber: F, pageContext: We[F] };
  }, Bc = I.__private__.getPageInfoByObjId = function(F) {
    if (isNaN(F) || F % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var se in We) if (We[se].objId === F) break;
    return Vl(se);
  }, ll = I.__private__.getCurrentPageInfo = I.getCurrentPageInfo = function() {
    return { objId: We[De].objId, pageNumber: De, pageContext: We[De] };
  };
  I.addPage = function() {
    return ch.apply(this, arguments), this;
  }, I.setPage = function() {
    return fa.apply(this, arguments), Ct.call(this, tr[De]), this;
  }, I.insertPage = function(F) {
    return this.addPage(), this.movePage(De, F), this;
  }, I.movePage = function(F, se) {
    var Ie, Ye;
    if (F > se) {
      Ie = tr[F], Ye = We[F];
      for (var ut = F; ut > se; ut--) tr[ut] = tr[ut - 1], We[ut] = We[ut - 1];
      tr[se] = Ie, We[se] = Ye, this.setPage(se);
    } else if (F < se) {
      Ie = tr[F], Ye = We[F];
      for (var Nt = F; Nt < se; Nt++) tr[Nt] = tr[Nt + 1], We[Nt] = We[Nt + 1];
      tr[se] = Ie, We[se] = Ye, this.setPage(se);
    }
    return this;
  }, I.deletePage = function() {
    return ha.apply(this, arguments), this;
  }, I.__private__.text = I.text = function(F, se, Ie, Ye, ut) {
    var Nt, Ut, vr, Cr, Ir, ni, ri, Fi, En, Ui = (Ye = Ye || {}).scope || this;
    if (typeof F == "number" && typeof se == "number" && (typeof Ie == "string" || Array.isArray(Ie))) {
      var an = Ie;
      Ie = se, se = F, F = an;
    }
    if (arguments[3] instanceof _r == 0 ? (vr = arguments[4], Cr = arguments[5], un(ri = arguments[3]) === "object" && ri !== null || (typeof vr == "string" && (Cr = vr, vr = null), typeof ri == "string" && (Cr = ri, ri = null), typeof ri == "number" && (vr = ri, ri = null), Ye = { flags: ri, angle: vr, align: Cr })) : (oe("The transform parameter of text() with a Matrix value"), En = ut), isNaN(se) || isNaN(Ie) || F == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (F.length === 0) return Ui;
    var vn, Un = "", qn = typeof Ye.lineHeightFactor == "number" ? Ye.lineHeightFactor : hl, Fa = Ui.internal.scaleFactor;
    function Dc(Wi) {
      return Wi = Wi.split("	").join(Array(Ye.TabLen || 9).join(" ")), Qi(Wi, ri);
    }
    function uh(Wi) {
      for (var Lr, Xi = Wi.concat(), xn = [], Ga = Xi.length; Ga--; ) typeof (Lr = Xi.shift()) == "string" ? xn.push(Lr) : Array.isArray(Wi) && (Lr.length === 1 || Lr[1] === void 0 && Lr[2] === void 0) ? xn.push(Lr[0]) : xn.push([Lr[0], Lr[1], Lr[2]]);
      return xn;
    }
    function Eo(Wi, Lr) {
      var Xi;
      if (typeof Wi == "string") Xi = Lr(Wi)[0];
      else if (Array.isArray(Wi)) {
        for (var xn, Ga, zc = Wi.concat(), ya = [], Iu = zc.length; Iu--; ) typeof (xn = zc.shift()) == "string" ? ya.push(Lr(xn)[0]) : Array.isArray(xn) && typeof xn[0] == "string" && (Ga = Lr(xn[0], xn[1], xn[2]), ya.push([Ga[0], Ga[1], Ga[2]]));
        Xi = ya;
      }
      return Xi;
    }
    var go = !1, gl = !0;
    if (typeof F == "string") go = !0;
    else if (Array.isArray(F)) {
      var ml = F.concat();
      Ut = [];
      for (var ga, Oi = ml.length; Oi--; ) (typeof (ga = ml.shift()) != "string" || Array.isArray(ga) && typeof ga[0] != "string") && (gl = !1);
      go = gl;
    }
    if (go === !1) throw new Error('Type of text must be string or Array. "' + F + '" is not recognized.');
    typeof F == "string" && (F = F.match(/[\r?\n]/) ? F.split(/\r\n|\r|\n/g) : [F]);
    var Ua = Jt / Ui.internal.scaleFactor, Co = Ua * (qn - 1);
    switch (Ye.baseline) {
      case "bottom":
        Ie -= Co;
        break;
      case "top":
        Ie += Ua - Co;
        break;
      case "hanging":
        Ie += Ua - 2 * Co;
        break;
      case "middle":
        Ie += Ua / 2 - Co;
    }
    if ((ni = Ye.maxWidth || 0) > 0 && (typeof F == "string" ? F = Ui.splitTextToSize(F, ni) : Object.prototype.toString.call(F) === "[object Array]" && (F = F.reduce(function(Wi, Lr) {
      return Wi.concat(Ui.splitTextToSize(Lr, ni));
    }, []))), Nt = { text: F, x: se, y: Ie, options: Ye, mutex: { pdfEscape: Qi, activeFontKey: wr, fonts: Te, activeFontSize: Jt } }, mr.publish("preProcessText", Nt), F = Nt.text, vr = (Ye = Nt.options).angle, En instanceof _r == 0 && vr && typeof vr == "number") {
      vr *= Math.PI / 180, Ye.rotationDirection === 0 && (vr = -vr), H === Z && (vr = -vr);
      var ia = Math.cos(vr), za = Math.sin(vr);
      En = new _r(ia, za, -za, ia, 0, 0);
    } else vr && vr instanceof _r && (En = vr);
    H !== Z || En || (En = nn), (Ir = Ye.charSpace || to) !== void 0 && (Un += pe(Ve(Ir)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (Fi = Ye.horizontalScale) !== void 0 && (Un += pe(100 * Fi) + ` Tz
`), Ye.lang;
    var Ss = -1, Gl = Ye.renderingMode !== void 0 ? Ye.renderingMode : Ye.stroke, Nc = Ui.internal.getCurrentPageInfo().pageContext;
    switch (Gl) {
      case 0:
      case !1:
      case "fill":
        Ss = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Ss = 1;
        break;
      case 2:
      case "fillThenStroke":
        Ss = 2;
        break;
      case 3:
      case "invisible":
        Ss = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Ss = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Ss = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Ss = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Ss = 7;
    }
    var ja = Nc.usedRenderingMode !== void 0 ? Nc.usedRenderingMode : -1;
    Ss !== -1 ? Un += Ss + ` Tr
` : ja !== -1 && (Un += `0 Tr
`), Ss !== -1 && (Nc.usedRenderingMode = Ss), Cr = Ye.align || "left";
    var ts, mo = Jt * qn, Fc = Ui.internal.pageSize.getWidth(), $l = Te[wr];
    Ir = Ye.charSpace || to, ni = Ye.maxWidth || 0, ri = Object.assign({ autoencode: !0, noBOM: !0 }, Ye.flags);
    var na = [], Hl = function(Wi) {
      return Ui.getStringUnitWidth(Wi, { font: $l, charSpace: Ir, fontSize: Jt, doKerning: !1 }) * Jt / Fa;
    };
    if (Object.prototype.toString.call(F) === "[object Array]") {
      var zs;
      Ut = uh(F), Cr !== "left" && (ts = Ut.map(Hl));
      var js, _l = 0;
      if (Cr === "right") {
        se -= ts[0], F = [], Oi = Ut.length;
        for (var Wn = 0; Wn < Oi; Wn++) Wn === 0 ? (js = Oa(se), zs = on(Ie)) : (js = Ve(_l - ts[Wn]), zs = -mo), F.push([Ut[Wn], js, zs]), _l = ts[Wn];
      } else if (Cr === "center") {
        se -= ts[0] / 2, F = [], Oi = Ut.length;
        for (var Va = 0; Va < Oi; Va++) Va === 0 ? (js = Oa(se), zs = on(Ie)) : (js = Ve((_l - ts[Va]) / 2), zs = -mo), F.push([Ut[Va], js, zs]), _l = ts[Va];
      } else if (Cr === "left") {
        F = [], Oi = Ut.length;
        for (var Uc = 0; Uc < Oi; Uc++) F.push(Ut[Uc]);
      } else if (Cr === "justify" && $l.encoding === "Identity-H") {
        F = [], Oi = Ut.length, ni = ni !== 0 ? ni : Fc;
        for (var Io = 0, kn = 0; kn < Oi; kn++) if (zs = kn === 0 ? on(Ie) : -mo, js = kn === 0 ? Oa(se) : Io, kn < Oi - 1) {
          var yl = Ve((ni - ts[kn]) / (Ut[kn].split(" ").length - 1)), sa = Ut[kn].split(" ");
          F.push([sa[0] + " ", js, zs]), Io = 0;
          for (var ma = 1; ma < sa.length; ma++) {
            var ql = (Hl(sa[ma - 1] + " " + sa[ma]) - Hl(sa[ma])) * Fa + yl;
            ma == sa.length - 1 ? F.push([sa[ma], ql, 0]) : F.push([sa[ma] + " ", ql, 0]), Io -= ql;
          }
        } else F.push([Ut[kn], js, zs]);
        F.push(["", Io, 0]);
      } else {
        if (Cr !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (F = [], Oi = Ut.length, ni = ni !== 0 ? ni : Fc, kn = 0; kn < Oi; kn++) zs = kn === 0 ? on(Ie) : -mo, js = kn === 0 ? Oa(se) : 0, kn < Oi - 1 ? na.push(pe(Ve((ni - ts[kn]) / (Ut[kn].split(" ").length - 1)))) : na.push(0), F.push([Ut[kn], js, zs]);
      }
    }
    (typeof Ye.R2L == "boolean" ? Ye.R2L : qr) === !0 && (F = Eo(F, function(Wi, Lr, Xi) {
      return [Wi.split("").reverse().join(""), Lr, Xi];
    })), Nt = { text: F, x: se, y: Ie, options: Ye, mutex: { pdfEscape: Qi, activeFontKey: wr, fonts: Te, activeFontSize: Jt } }, mr.publish("postProcessText", Nt), F = Nt.text, vn = Nt.mutex.isHex || !1;
    var Wl = Te[wr].encoding;
    Wl !== "WinAnsiEncoding" && Wl !== "StandardEncoding" || (F = Eo(F, function(Wi, Lr, Xi) {
      return [Dc(Wi), Lr, Xi];
    })), Ut = uh(F), F = [];
    for (var bl, vl, xl, _a = Array.isArray(Ut[0]) ? 1 : 0, rs = "", Xl = function(Wi, Lr, Xi) {
      var xn = "";
      return Xi instanceof _r ? (Xi = typeof Ye.angle == "number" ? qi(Xi, new _r(1, 0, 0, 1, Wi, Lr)) : qi(new _r(1, 0, 0, 1, Wi, Lr), Xi), H === Z && (Xi = qi(new _r(1, 0, 0, -1, 0, 0), Xi)), xn = Xi.join(" ") + ` Tm
`) : xn = pe(Wi) + " " + pe(Lr) + ` Td
`, xn;
    }, Vs = 0; Vs < Ut.length; Vs++) {
      switch (rs = "", _a) {
        case 1:
          xl = (vn ? "<" : "(") + Ut[Vs][0] + (vn ? ">" : ")"), bl = parseFloat(Ut[Vs][1]), vl = parseFloat(Ut[Vs][2]);
          break;
        case 0:
          xl = (vn ? "<" : "(") + Ut[Vs] + (vn ? ">" : ")"), bl = Oa(se), vl = on(Ie);
      }
      na !== void 0 && na[Vs] !== void 0 && (rs = na[Vs] + ` Tw
`), Vs === 0 ? F.push(rs + Xl(bl, vl, En) + xl) : _a === 0 ? F.push(rs + xl) : _a === 1 && F.push(rs + Xl(bl, vl, En) + xl);
    }
    F = _a === 0 ? F.join(` Tj
T* `) : F.join(` Tj
`), F += ` Tj
`;
    var Po = `BT
/`;
    return Po += wr + " " + Jt + ` Tf
`, Po += pe(Jt * qn) + ` TL
`, Po += ki + `
`, Po += Un, Po += F, Oe(Po += "ET"), P[wr] = !0, Ui;
  };
  var Eu = I.__private__.clip = I.clip = function(F) {
    return Oe(F === "evenodd" ? "W*" : "W"), this;
  };
  I.clipEvenOdd = function() {
    return Eu("evenodd");
  }, I.__private__.discardPath = I.discardPath = function() {
    return Oe("n"), this;
  };
  var To = I.__private__.isValidStyle = function(F) {
    var se = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(F) !== -1 && (se = !0), se;
  };
  I.__private__.setDefaultPathOperation = I.setDefaultPathOperation = function(F) {
    return To(F) && (m = F), this;
  };
  var cl = I.__private__.getStyle = I.getStyle = function(F) {
    var se = m;
    switch (F) {
      case "D":
      case "S":
        se = "S";
        break;
      case "F":
        se = "f";
        break;
      case "FD":
      case "DF":
        se = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        se = F;
    }
    return se;
  }, ul = I.close = function() {
    return Oe("h"), this;
  };
  I.stroke = function() {
    return Oe("S"), this;
  }, I.fill = function(F) {
    return Qo("f", F), this;
  }, I.fillEvenOdd = function(F) {
    return Qo("f*", F), this;
  }, I.fillStroke = function(F) {
    return Qo("B", F), this;
  }, I.fillStrokeEvenOdd = function(F) {
    return Qo("B*", F), this;
  };
  var Qo = function(F, se) {
    un(se) === "object" ? Cu(se, F) : Oe(F);
  }, kc = function(F) {
    F === null || H === Z && F === void 0 || (F = cl(F), Oe(F));
  };
  function Ba(F, se, Ie, Ye, ut) {
    var Nt = new lp(se || this.boundingBox, Ie || this.xStep, Ye || this.yStep, this.gState, ut || this.matrix);
    Nt.stream = this.stream;
    var Ut = F + "$$" + this.cloneIndex++ + "$$";
    return Ei(Ut, Nt), Nt;
  }
  var Cu = function(F, se) {
    var Ie = He[F.key], Ye = Je[Ie];
    if (Ye instanceof Lf) Oe("q"), Oe(So(se)), Ye.gState && I.setGState(Ye.gState), Oe(F.matrix.toString() + " cm"), Oe("/" + Ie + " sh"), Oe("Q");
    else if (Ye instanceof lp) {
      var ut = new _r(1, 0, 0, -1, 0, Ts());
      F.matrix && (ut = ut.multiply(F.matrix || nn), Ie = Ba.call(Ye, F.key, F.boundingBox, F.xStep, F.yStep, ut).id), Oe("q"), Oe("/Pattern cs"), Oe("/" + Ie + " scn"), Ye.gState && I.setGState(Ye.gState), Oe(se), Oe("Q");
    }
  }, So = function(F) {
    switch (F) {
      case "f":
      case "F":
      case "n":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
      case "S":
        return "W S";
      case "B*":
        return "W* S";
    }
  }, Jr = I.moveTo = function(F, se) {
    return Oe(pe(Ve(F)) + " " + pe(Be(se)) + " m"), this;
  }, fs = I.lineTo = function(F, se) {
    return Oe(pe(Ve(F)) + " " + pe(Be(se)) + " l"), this;
  }, jr = I.curveTo = function(F, se, Ie, Ye, ut, Nt) {
    return Oe([pe(Ve(F)), pe(Be(se)), pe(Ve(Ie)), pe(Be(Ye)), pe(Ve(ut)), pe(Be(Nt)), "c"].join(" ")), this;
  };
  I.__private__.line = I.line = function(F, se, Ie, Ye, ut) {
    if (isNaN(F) || isNaN(se) || isNaN(Ie) || isNaN(Ye) || !To(ut)) throw new Error("Invalid arguments passed to jsPDF.line");
    return H === te ? this.lines([[Ie - F, Ye - se]], F, se, [1, 1], ut || "S") : this.lines([[Ie - F, Ye - se]], F, se, [1, 1]).stroke();
  }, I.__private__.lines = I.lines = function(F, se, Ie, Ye, ut, Nt) {
    var Ut, vr, Cr, Ir, ni, ri, Fi, En, Ui, an, vn, Un;
    if (typeof F == "number" && (Un = Ie, Ie = se, se = F, F = Un), Ye = Ye || [1, 1], Nt = Nt || !1, isNaN(se) || isNaN(Ie) || !Array.isArray(F) || !Array.isArray(Ye) || !To(ut) || typeof Nt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Jr(se, Ie), Ut = Ye[0], vr = Ye[1], Ir = F.length, an = se, vn = Ie, Cr = 0; Cr < Ir; Cr++) (ni = F[Cr]).length === 2 ? (an = ni[0] * Ut + an, vn = ni[1] * vr + vn, fs(an, vn)) : (ri = ni[0] * Ut + an, Fi = ni[1] * vr + vn, En = ni[2] * Ut + an, Ui = ni[3] * vr + vn, an = ni[4] * Ut + an, vn = ni[5] * vr + vn, jr(ri, Fi, En, Ui, an, vn));
    return Nt && ul(), kc(ut), this;
  }, I.path = function(F) {
    for (var se = 0; se < F.length; se++) {
      var Ie = F[se], Ye = Ie.c;
      switch (Ie.op) {
        case "m":
          Jr(Ye[0], Ye[1]);
          break;
        case "l":
          fs(Ye[0], Ye[1]);
          break;
        case "c":
          jr.apply(this, Ye);
          break;
        case "h":
          ul();
      }
    }
    return this;
  }, I.__private__.rect = I.rect = function(F, se, Ie, Ye, ut) {
    if (isNaN(F) || isNaN(se) || isNaN(Ie) || isNaN(Ye) || !To(ut)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return H === te && (Ye = -Ye), Oe([pe(Ve(F)), pe(Be(se)), pe(Ve(Ie)), pe(Ve(Ye)), "re"].join(" ")), kc(ut), this;
  }, I.__private__.triangle = I.triangle = function(F, se, Ie, Ye, ut, Nt, Ut) {
    if (isNaN(F) || isNaN(se) || isNaN(Ie) || isNaN(Ye) || isNaN(ut) || isNaN(Nt) || !To(Ut)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[Ie - F, Ye - se], [ut - Ie, Nt - Ye], [F - ut, se - Nt]], F, se, [1, 1], Ut, !0), this;
  }, I.__private__.roundedRect = I.roundedRect = function(F, se, Ie, Ye, ut, Nt, Ut) {
    if (isNaN(F) || isNaN(se) || isNaN(Ie) || isNaN(Ye) || isNaN(ut) || isNaN(Nt) || !To(Ut)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var vr = 4 / 3 * (Math.SQRT2 - 1);
    return ut = Math.min(ut, 0.5 * Ie), Nt = Math.min(Nt, 0.5 * Ye), this.lines([[Ie - 2 * ut, 0], [ut * vr, 0, ut, Nt - Nt * vr, ut, Nt], [0, Ye - 2 * Nt], [0, Nt * vr, -ut * vr, Nt, -ut, Nt], [2 * ut - Ie, 0], [-ut * vr, 0, -ut, -Nt * vr, -ut, -Nt], [0, 2 * Nt - Ye], [0, -Nt * vr, ut * vr, -Nt, ut, -Nt]], F + ut, se, [1, 1], Ut, !0), this;
  }, I.__private__.ellipse = I.ellipse = function(F, se, Ie, Ye, ut) {
    if (isNaN(F) || isNaN(se) || isNaN(Ie) || isNaN(Ye) || !To(ut)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Nt = 4 / 3 * (Math.SQRT2 - 1) * Ie, Ut = 4 / 3 * (Math.SQRT2 - 1) * Ye;
    return Jr(F + Ie, se), jr(F + Ie, se - Ut, F + Nt, se - Ye, F, se - Ye), jr(F - Nt, se - Ye, F - Ie, se - Ut, F - Ie, se), jr(F - Ie, se + Ut, F - Nt, se + Ye, F, se + Ye), jr(F + Nt, se + Ye, F + Ie, se + Ut, F + Ie, se), kc(ut), this;
  }, I.__private__.circle = I.circle = function(F, se, Ie, Ye) {
    if (isNaN(F) || isNaN(se) || isNaN(Ie) || !To(Ye)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(F, se, Ie, Ie, Ye);
  }, I.setFont = function(F, se, Ie) {
    return Ie && (se = be(se, Ie)), wr = Jo(F, se, { disableWarning: !1 }), this;
  };
  var Oc = I.__private__.getFont = I.getFont = function() {
    return Te[Jo.apply(I, arguments)];
  };
  I.__private__.getFontList = I.getFontList = function() {
    var F, se, Ie = {};
    for (F in Pe) if (Pe.hasOwnProperty(F)) for (se in Ie[F] = [], Pe[F]) Pe[F].hasOwnProperty(se) && Ie[F].push(se);
    return Ie;
  }, I.addFont = function(F, se, Ie, Ye, ut) {
    var Nt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Nt.indexOf(arguments[3]) !== -1 ? ut = arguments[3] : arguments[3] && Nt.indexOf(arguments[3]) == -1 && (Ie = be(Ie, Ye)), Ao.call(this, F, se, Ie, ut = ut || "Identity-H");
  };
  var hl, ka = r.lineWidth || 0.200025, Er = I.__private__.getLineWidth = I.getLineWidth = function() {
    return ka;
  }, Fn = I.__private__.setLineWidth = I.setLineWidth = function(F) {
    return ka = F, Oe(pe(Ve(F)) + " w"), this;
  };
  I.__private__.setLineDash = Ur.API.setLineDash = Ur.API.setLineDashPattern = function(F, se) {
    if (F = F || [], se = se || 0, isNaN(se) || !Array.isArray(F)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return F = F.map(function(Ie) {
      return pe(Ve(Ie));
    }).join(" "), se = pe(Ve(se)), Oe("[" + F + "] " + se + " d"), this;
  };
  var es = I.__private__.getLineHeight = I.getLineHeight = function() {
    return Jt * hl;
  };
  I.__private__.getLineHeight = I.getLineHeight = function() {
    return Jt * hl;
  };
  var Bn = I.__private__.setLineHeightFactor = I.setLineHeightFactor = function(F) {
    return typeof (F = F || 1.15) == "number" && (hl = F), this;
  }, ji = I.__private__.getLineHeightFactor = I.getLineHeightFactor = function() {
    return hl;
  };
  Bn(r.lineHeight);
  var Oa = I.__private__.getHorizontalCoordinate = function(F) {
    return Ve(F);
  }, on = I.__private__.getVerticalCoordinate = function(F) {
    return H === Z ? F : We[De].mediaBox.topRightY - We[De].mediaBox.bottomLeftY - Ve(F);
  }, Hn = I.__private__.getHorizontalCoordinateString = I.getHorizontalCoordinateString = function(F) {
    return pe(Oa(F));
  }, As = I.__private__.getVerticalCoordinateString = I.getVerticalCoordinateString = function(F) {
    return pe(on(F));
  }, fl = r.strokeColor || "0 G";
  I.__private__.getStrokeColor = I.getDrawColor = function() {
    return Xt(fl);
  }, I.__private__.setStrokeColor = I.setDrawColor = function(F, se, Ie, Ye) {
    return fl = Dr({ ch1: F, ch2: se, ch3: Ie, ch4: Ye, pdfColorType: "draw", precision: 2 }), Oe(fl), this;
  };
  var pa = r.fillColor || "0 g";
  I.__private__.getFillColor = I.getFillColor = function() {
    return Xt(pa);
  }, I.__private__.setFillColor = I.setFillColor = function(F, se, Ie, Ye) {
    return pa = Dr({ ch1: F, ch2: se, ch3: Ie, ch4: Ye, pdfColorType: "fill", precision: 2 }), Oe(pa), this;
  };
  var ki = r.textColor || "0 g", Si = I.__private__.getTextColor = I.getTextColor = function() {
    return Xt(ki);
  };
  I.__private__.setTextColor = I.setTextColor = function(F, se, Ie, Ye) {
    return ki = Dr({ ch1: F, ch2: se, ch3: Ie, ch4: Ye, pdfColorType: "text", precision: 3 }), this;
  };
  var to = r.charSpace, fi = I.__private__.getCharSpace = I.getCharSpace = function() {
    return parseFloat(to || 0);
  };
  I.__private__.setCharSpace = I.setCharSpace = function(F) {
    if (isNaN(F)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return to = F, this;
  };
  var Or = 0;
  I.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, I.__private__.setLineCap = I.setLineCap = function(F) {
    var se = I.CapJoinStyles[F];
    if (se === void 0) throw new Error("Line cap style of '" + F + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Or = se, Oe(se + " J"), this;
  };
  var dl = 0;
  I.__private__.setLineJoin = I.setLineJoin = function(F) {
    var se = I.CapJoinStyles[F];
    if (se === void 0) throw new Error("Line join style of '" + F + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return dl = se, Oe(se + " j"), this;
  }, I.__private__.setLineMiterLimit = I.__private__.setMiterLimit = I.setLineMiterLimit = I.setMiterLimit = function(F) {
    if (F = F || 0, isNaN(F)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Oe(pe(Ve(F)) + " M"), this;
  }, I.GState = Vy, I.setGState = function(F) {
    (F = typeof F == "string" ? nt[Bt[F]] : Qr(null, F)).equals(It) || (Oe("/" + F.id + " gs"), It = F);
  };
  var Qr = function(F, se) {
    if (!F || !Bt[F]) {
      var Ie = !1;
      for (var Ye in nt) if (nt.hasOwnProperty(Ye) && nt[Ye].equals(se)) {
        Ie = !0;
        break;
      }
      if (Ie) se = nt[Ye];
      else {
        var ut = "GS" + (Object.keys(nt).length + 1).toString(10);
        nt[ut] = se, se.id = ut;
      }
      return F && (Bt[F] = se.id), mr.publish("addGState", se), se;
    }
  };
  I.addGState = function(F, se) {
    return Qr(F, se), this;
  }, I.saveGraphicsState = function() {
    return Oe("q"), qe.push({ key: wr, size: Jt, color: ki }), this;
  }, I.restoreGraphicsState = function() {
    Oe("Q");
    var F = qe.pop();
    return wr = F.key, Jt = F.size, ki = F.color, It = null, this;
  }, I.setCurrentTransformationMatrix = function(F) {
    return Oe(F.toString() + " cm"), this;
  }, I.comment = function(F) {
    return Oe("#" + F), this;
  };
  var Da = function(F, se) {
    var Ie = F || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return Ie;
    }, set: function(Nt) {
      isNaN(Nt) || (Ie = parseFloat(Nt));
    } });
    var Ye = se || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Ye;
    }, set: function(Nt) {
      isNaN(Nt) || (Ye = parseFloat(Nt));
    } });
    var ut = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return ut;
    }, set: function(Nt) {
      ut = Nt.toString();
    } }), this;
  }, ro = function(F, se, Ie, Ye) {
    Da.call(this, F, se), this.type = "rect";
    var ut = Ie || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return ut;
    }, set: function(Ut) {
      isNaN(Ut) || (ut = parseFloat(Ut));
    } });
    var Nt = Ye || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Nt;
    }, set: function(Ut) {
      isNaN(Ut) || (Nt = parseFloat(Ut));
    } }), this;
  }, ea = function() {
    this.page = rr, this.currentPage = De, this.pages = tr.slice(0), this.pagesContext = We.slice(0), this.x = K, this.y = ne, this.matrix = de, this.width = Na(De), this.height = Ts(De), this.outputDestination = dr, this.id = "", this.objectNumber = -1;
  };
  ea.prototype.restore = function() {
    rr = this.page, De = this.currentPage, We = this.pagesContext, tr = this.pages, K = this.x, ne = this.y, de = this.matrix, pl(De, this.width), po(De, this.height), dr = this.outputDestination;
  };
  var ta = function(F, se, Ie, Ye, ut) {
    li.push(new ea()), rr = De = 0, tr = [], K = F, ne = se, de = ut, ti([Ie, Ye]);
  };
  for (var ra in I.beginFormObject = function(F, se, Ie, Ye, ut) {
    return ta(F, se, Ie, Ye, ut), this;
  }, I.endFormObject = function(F) {
    return function(se) {
      if (Hr[se]) li.pop().restore();
      else {
        var Ie = new ea(), Ye = "Xo" + (Object.keys(fr).length + 1).toString(10);
        Ie.id = Ye, Hr[se] = Ye, fr[Ye] = Ie, mr.publish("addFormObject", Ie), li.pop().restore();
      }
    }(F), this;
  }, I.doFormObject = function(F, se) {
    var Ie = fr[Hr[F]];
    return Oe("q"), Oe(se.toString() + " cm"), Oe("/" + Ie.id + " Do"), Oe("Q"), this;
  }, I.getFormObject = function(F) {
    var se = fr[Hr[F]];
    return { x: se.x, y: se.y, width: se.width, height: se.height, matrix: se.matrix };
  }, I.save = function(F, se) {
    return F = F || "generated.pdf", (se = se || {}).returnPromise = se.returnPromise || !1, se.returnPromise === !1 ? (If(jl(La()), F), typeof If.unload == "function" && ai.setTimeout && setTimeout(If.unload, 911), this) : new Promise(function(Ie, Ye) {
      try {
        var ut = If(jl(La()), F);
        typeof If.unload == "function" && ai.setTimeout && setTimeout(If.unload, 911), Ie(ut);
      } catch (Nt) {
        Ye(Nt.message);
      }
    });
  }, Ur.API) Ur.API.hasOwnProperty(ra) && (ra === "events" && Ur.API.events.length ? function(F, se) {
    var Ie, Ye, ut;
    for (ut = se.length - 1; ut !== -1; ut--) Ie = se[ut][0], Ye = se[ut][1], F.subscribe.apply(F, [Ie].concat(typeof Ye == "function" ? [Ye] : Ye));
  }(mr, Ur.API.events) : I[ra] = Ur.API[ra]);
  var Na = I.getPageWidth = function(F) {
    return (We[F = F || De].mediaBox.topRightX - We[F].mediaBox.bottomLeftX) / Ue;
  }, pl = I.setPageWidth = function(F, se) {
    We[F].mediaBox.topRightX = se * Ue + We[F].mediaBox.bottomLeftX;
  }, Ts = I.getPageHeight = function(F) {
    return (We[F = F || De].mediaBox.topRightY - We[F].mediaBox.bottomLeftY) / Ue;
  }, po = I.setPageHeight = function(F, se) {
    We[F].mediaBox.topRightY = se * Ue + We[F].mediaBox.bottomLeftY;
  };
  return I.internal = { pdfEscape: Qi, getStyle: cl, getFont: Oc, getFontSize: hr, getCharSpace: fi, getTextColor: Si, getLineHeight: es, getLineHeightFactor: ji, getLineWidth: Er, write: ii, getHorizontalCoordinate: Oa, getVerticalCoordinate: on, getCoordinateString: Hn, getVerticalCoordinateString: As, collections: {}, newObject: ci, newAdditionalObject: Rn, newObjectDeferred: Lt, newObjectDeferredBegin: pi, getFilters: zr, putStream: bn, events: mr, scaleFactor: Ue, pageSize: { getWidth: function() {
    return Na(De);
  }, setWidth: function(F) {
    pl(De, F);
  }, getHeight: function() {
    return Ts(De);
  }, setHeight: function(F) {
    po(De, F);
  } }, encryptionOptions: y, encryption: Sn, getEncryptor: function(F) {
    return y !== null ? Sn.encryptor(F, 0) : function(se) {
      return se;
    };
  }, output: Ko, getNumberOfPages: Yo, pages: tr, out: Oe, f2: le, f3: _e, getPageInfo: Vl, getPageInfoByObjId: Bc, getCurrentPageInfo: ll, getPDFVersion: k, Point: Da, Rectangle: ro, Matrix: _r, hasHotfix: al }, Object.defineProperty(I.internal.pageSize, "width", { get: function() {
    return Na(De);
  }, set: function(F) {
    pl(De, F);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(I.internal.pageSize, "height", { get: function() {
    return Ts(De);
  }, set: function(F) {
    po(De, F);
  }, enumerable: !0, configurable: !0 }), (function(F) {
    for (var se = 0, Ie = Rr.length; se < Ie; se++) {
      var Ye = Ao.call(this, F[se][0], F[se][1], F[se][2], Rr[se][3], !0);
      T === !1 && (P[Ye] = !0);
      var ut = F[se][0].split("-");
      ol({ id: Ye, fontName: ut[0], fontStyle: ut[1] || "" });
    }
    mr.publish("addFonts", { fonts: Te, dictionary: Pe });
  }).call(I, Rr), wr = "F1", ch(n, t), mr.publish("initialized"), I;
}
Kd.prototype.lsbFirstWord = function(r) {
  return String.fromCharCode(255 & r, r >> 8 & 255, r >> 16 & 255, r >> 24 & 255);
}, Kd.prototype.toHexString = function(r) {
  return r.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Kd.prototype.hexToBytes = function(r) {
  for (var e = [], t = 0; t < r.length; t += 2) e.push(String.fromCharCode(parseInt(r.substr(t, 2), 16)));
  return e.join("");
}, Kd.prototype.processOwnerPassword = function(r, e) {
  return a2(o2(e).substr(0, 5), r);
}, Kd.prototype.encryptor = function(r, e) {
  var t = o2(this.encryptionKey + String.fromCharCode(255 & r, r >> 8 & 255, r >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(i) {
    return a2(t, i);
  };
}, Vy.prototype.equals = function(r) {
  var e, t = "id,objectNumber,equals";
  if (!r || un(r) !== un(this)) return !1;
  var i = 0;
  for (e in this) if (!(t.indexOf(e) >= 0)) {
    if (this.hasOwnProperty(e) && !r.hasOwnProperty(e) || this[e] !== r[e]) return !1;
    i++;
  }
  for (e in r) r.hasOwnProperty(e) && t.indexOf(e) < 0 && i--;
  return i === 0;
}, Ur.API = { events: [] }, Ur.version = "3.0.2";
var ls = Ur.API, tw = 1, fd = function(r) {
  return r.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Wd = function(r) {
  return r.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, di = function(r) {
  return r.toFixed(2);
}, Oh = function(r) {
  return r.toFixed(5);
};
ls.__acroform__ = {};
var Ra = function(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r;
}, bC = function(r) {
  return r * tw;
}, du = function(r) {
  var e = new VR(), t = Mr.internal.getHeight(r) || 0, i = Mr.internal.getWidth(r) || 0;
  return e.BBox = [0, 0, Number(di(i)), Number(di(t))], e;
}, wee = ls.__acroform__.setBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return r | 1 << e;
}, Aee = ls.__acroform__.clearBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return r & ~(1 << e);
}, Tee = ls.__acroform__.getBit = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return r & 1 << e ? 1 : 0;
}, bs = ls.__acroform__.getBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return Tee(r, e - 1);
}, vs = ls.__acroform__.setBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return wee(r, e - 1);
}, xs = ls.__acroform__.clearBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Aee(r, e - 1);
}, See = ls.__acroform__.calculateCoordinates = function(r, e) {
  var t = e.internal.getHorizontalCoordinate, i = e.internal.getVerticalCoordinate, n = r[0], s = r[1], c = r[2], o = r[3], d = {};
  return d.lowerLeft_X = t(n) || 0, d.lowerLeft_Y = i(s + o) || 0, d.upperRight_X = t(n + c) || 0, d.upperRight_Y = i(s) || 0, [Number(di(d.lowerLeft_X)), Number(di(d.lowerLeft_Y)), Number(di(d.upperRight_X)), Number(di(d.upperRight_Y))];
}, Eee = function(r) {
  if (r.appearanceStreamContent) return r.appearanceStreamContent;
  if (r.V || r.DV) {
    var e = [], t = r._V || r.DV, i = l2(r, t), n = r.scope.internal.getFont(r.fontName, r.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(r.scope.__private__.encodeColorString(r.color)), e.push("/" + n + " " + di(i.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(i.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var s = du(r);
    return s.scope = r.scope, s.stream = e.join(`
`), s;
  }
}, l2 = function(r, e) {
  var t = r.fontSize === 0 ? r.maxFontSize : r.fontSize, i = { text: "", fontSize: "" }, n = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  n = r.multiline ? n.map(function(le) {
    return le.split(`
`);
  }) : n.map(function(le) {
    return [le];
  });
  var s = t, c = Mr.internal.getHeight(r) || 0;
  c = c < 0 ? -c : c;
  var o = Mr.internal.getWidth(r) || 0;
  o = o < 0 ? -o : o;
  var d = function(le, _e, Ve) {
    if (le + 1 < n.length) {
      var Be = _e + " " + n[le + 1][0];
      return M_(Be, r, Ve).width <= o - 4;
    }
    return !1;
  };
  s++;
  e: for (; s > 0; ) {
    e = "", s--;
    var m, y, T = M_("3", r, s).height, P = r.multiline ? c - s : (c - T) / 2, I = P += 2, D = 0, k = 0, $ = 0;
    if (s <= 0) {
      e = `(...) Tj
`, e += "% Width of Text: " + M_(e, r, s = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var G = "", te = 0, Z = 0; Z < n.length; Z++) if (n.hasOwnProperty(Z)) {
      var H = !1;
      if (n[Z].length !== 1 && $ !== n[Z].length - 1) {
        if ((T + 2) * (te + 2) + 2 > c) continue e;
        G += n[Z][$], H = !0, k = Z, Z--;
      } else {
        G = (G += n[Z][$] + " ").substr(G.length - 1) == " " ? G.substr(0, G.length - 1) : G;
        var J = parseInt(Z), re = d(J, G, s), be = Z >= n.length - 1;
        if (re && !be) {
          G += " ", $ = 0;
          continue;
        }
        if (re || be) {
          if (be) k = J;
          else if (r.multiline && (T + 2) * (te + 2) + 2 > c) continue e;
        } else {
          if (!r.multiline || (T + 2) * (te + 2) + 2 > c) continue e;
          k = J;
        }
      }
      for (var pe = "", oe = D; oe <= k; oe++) {
        var Ee = n[oe];
        if (r.multiline) {
          if (oe === k) {
            pe += Ee[$] + " ", $ = ($ + 1) % Ee.length;
            continue;
          }
          if (oe === D) {
            pe += Ee[Ee.length - 1] + " ";
            continue;
          }
        }
        pe += Ee[0] + " ";
      }
      switch (pe = pe.substr(pe.length - 1) == " " ? pe.substr(0, pe.length - 1) : pe, y = M_(pe, r, s).width, r.textAlign) {
        case "right":
          m = o - y - 2;
          break;
        case "center":
          m = (o - y) / 2;
          break;
        default:
          m = 2;
      }
      e += di(m) + " " + di(I) + ` Td
`, e += "(" + fd(pe) + `) Tj
`, e += -di(m) + ` 0 Td
`, I = -(s + 2), y = 0, D = H ? k : k + 1, te++, G = "";
    }
    break;
  }
  return i.text = e, i.fontSize = s, i;
}, M_ = function(r, e, t) {
  var i = e.scope.internal.getFont(e.fontName, e.fontStyle), n = e.scope.getStringUnitWidth(r, { font: i, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: i, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: n };
}, Cee = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Iee = function(r, e) {
  var t = { type: "reference", object: r };
  e.internal.getPageInfo(r.page).pageContext.annotations.find(function(i) {
    return i.type === t.type && i.object === t.object;
  }) === void 0 && e.internal.getPageInfo(r.page).pageContext.annotations.push(t);
}, Pee = function(r, e) {
  if (e.scope = r, r.internal !== void 0 && (r.internal.acroformPlugin === void 0 || r.internal.acroformPlugin.isInitialized === !1)) {
    if (Mc.FieldNum = 0, r.internal.acroformPlugin = JSON.parse(JSON.stringify(Cee)), r.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    tw = r.internal.scaleFactor, r.internal.acroformPlugin.acroFormDictionaryRoot = new GR(), r.internal.acroformPlugin.acroFormDictionaryRoot.scope = r, r.internal.acroformPlugin.acroFormDictionaryRoot._eventID = r.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(r);
    }), r.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var i = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var n in i) if (i.hasOwnProperty(n)) {
          var s = i[n];
          s.objId = void 0, s.hasAnnotation && Iee(s, t);
        }
      })(r);
    }), r.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(r);
    }), r.internal.events.subscribe("postPutPages", function(t) {
      (function(i, n) {
        var s = !i;
        for (var c in i || (n.internal.newObjectDeferredBegin(n.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), n.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), i = i || n.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (i.hasOwnProperty(c)) {
          var o = i[c], d = [], m = o.Rect;
          if (o.Rect && (o.Rect = See(o.Rect, n)), n.internal.newObjectDeferredBegin(o.objId, !0), o.DA = Mr.createDefaultAppearanceStream(o), un(o) === "object" && typeof o.getKeyValueListForStream == "function" && (d = o.getKeyValueListForStream()), o.Rect = m, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var y = Eee(o);
            d.push({ key: "AP", value: "<</N " + y + ">>" }), n.internal.acroformPlugin.xForms.push(y);
          }
          if (o.appearanceStreamContent) {
            var T = "";
            for (var P in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(P)) {
              var I = o.appearanceStreamContent[P];
              if (T += "/" + P + " ", T += "<<", Object.keys(I).length >= 1 || Array.isArray(I)) {
                for (var c in I) if (I.hasOwnProperty(c)) {
                  var D = I[c];
                  typeof D == "function" && (D = D.call(n, o)), T += "/" + c + " " + D + " ", n.internal.acroformPlugin.xForms.indexOf(D) >= 0 || n.internal.acroformPlugin.xForms.push(D);
                }
              } else typeof (D = I) == "function" && (D = D.call(n, o)), T += "/" + c + " " + D, n.internal.acroformPlugin.xForms.indexOf(D) >= 0 || n.internal.acroformPlugin.xForms.push(D);
              T += ">>";
            }
            d.push({ key: "AP", value: `<<
` + T + ">>" });
          }
          n.internal.putStream({ additionalKeyValues: d, objectId: o.objId }), n.internal.out("endobj");
        }
        s && function(k, $) {
          for (var G in k) if (k.hasOwnProperty(G)) {
            var te = G, Z = k[G];
            $.internal.newObjectDeferredBegin(Z.objId, !0), un(Z) === "object" && typeof Z.putStream == "function" && Z.putStream(), delete k[te];
          }
        }(n.internal.acroformPlugin.xForms, n);
      })(t, r);
    }), r.internal.acroformPlugin.isInitialized = !0;
  }
}, jR = ls.__acroform__.arrayToPdfArray = function(r, e, t) {
  var i = function(c) {
    return c;
  };
  if (Array.isArray(r)) {
    for (var n = "[", s = 0; s < r.length; s++) switch (s !== 0 && (n += " "), un(r[s])) {
      case "boolean":
      case "number":
      case "object":
        n += r[s].toString();
        break;
      case "string":
        r[s].substr(0, 1) !== "/" ? (e !== void 0 && t && (i = t.internal.getEncryptor(e)), n += "(" + fd(i(r[s].toString())) + ")") : n += r[s].toString();
    }
    return n + "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, D1 = function(r, e, t) {
  var i = function(n) {
    return n;
  };
  return e !== void 0 && t && (i = t.internal.getEncryptor(e)), (r = r || "").toString(), "(" + fd(i(r)) + ")";
}, xu = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(r) {
    this._objId = r;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
xu.prototype.toString = function() {
  return this.objId + " 0 R";
}, xu.prototype.putStream = function() {
  var r = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: r, objectId: this.objId }), this.scope.internal.out("endobj");
}, xu.prototype.getKeyValueListForStream = function() {
  var r = [], e = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var t in e) if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
    var i = e[t], n = this[i];
    n && (Array.isArray(n) ? r.push({ key: i, value: jR(n, this.objId, this.scope) }) : n instanceof xu ? (n.scope = this.scope, r.push({ key: i, value: n.objId + " 0 R" })) : typeof n != "function" && r.push({ key: i, value: n }));
  }
  return r;
};
var VR = function() {
  xu.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var r, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    r = t.trim();
  }, get: function() {
    return r || null;
  } });
};
Ra(VR, xu);
var GR = function() {
  xu.call(this);
  var r, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (r) {
      var t = function(i) {
        return i;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + fd(t(r)) + ")";
    }
  }, set: function(t) {
    r = t;
  } });
};
Ra(GR, xu);
var Mc = function r() {
  xu.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(G) {
    if (isNaN(G)) throw new Error('Invalid value "' + G + '" for attribute F supplied.');
    e = G;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(e, 3);
  }, set: function(G) {
    G ? this.F = vs(e, 3) : this.F = xs(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(G) {
    if (isNaN(G)) throw new Error('Invalid value "' + G + '" for attribute Ff supplied.');
    t = G;
  } });
  var i = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (i.length !== 0) return i;
  }, set: function(G) {
    i = G !== void 0 ? G : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[0]) ? 0 : i[0];
  }, set: function(G) {
    i[0] = G;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[1]) ? 0 : i[1];
  }, set: function(G) {
    i[1] = G;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[2]) ? 0 : i[2];
  }, set: function(G) {
    i[2] = G;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[3]) ? 0 : i[3];
  }, set: function(G) {
    i[3] = G;
  } });
  var n = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(G) {
    switch (G) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        n = G;
        break;
      default:
        throw new Error('Invalid value "' + G + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof Gy) return;
      s = "FieldObject" + r.FieldNum++;
    }
    var G = function(te) {
      return te;
    };
    return this.scope && (G = this.scope.internal.getEncryptor(this.objId)), "(" + fd(G(s)) + ")";
  }, set: function(G) {
    s = G.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(G) {
    s = G;
  } });
  var c = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return c;
  }, set: function(G) {
    c = G;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(G) {
    o = G;
  } });
  var d = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return d;
  }, set: function(G) {
    d = G;
  } });
  var m = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return m === void 0 ? 50 / tw : m;
  }, set: function(G) {
    m = G;
  } });
  var y = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return y;
  }, set: function(G) {
    y = G;
  } });
  var T = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!T || this instanceof Gy || this instanceof Wf)) return D1(T, this.objId, this.scope);
  }, set: function(G) {
    G = G.toString(), T = G;
  } });
  var P = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (P) return this instanceof ho == 0 ? D1(P, this.objId, this.scope) : P;
  }, set: function(G) {
    G = G.toString(), P = this instanceof ho == 0 ? G.substr(0, 1) === "(" ? Wd(G.substr(1, G.length - 2)) : Wd(G) : G;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ho == 1 ? Wd(P.substr(1, P.length - 1)) : P;
  }, set: function(G) {
    G = G.toString(), P = this instanceof ho == 1 ? "/" + G : G;
  } });
  var I = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (I) return I;
  }, set: function(G) {
    this.V = G;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (I) return this instanceof ho == 0 ? D1(I, this.objId, this.scope) : I;
  }, set: function(G) {
    G = G.toString(), I = this instanceof ho == 0 ? G.substr(0, 1) === "(" ? Wd(G.substr(1, G.length - 2)) : Wd(G) : G;
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ho == 1 ? Wd(I.substr(1, I.length - 1)) : I;
  }, set: function(G) {
    G = G.toString(), I = this instanceof ho == 1 ? "/" + G : G;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var D, k = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return k;
  }, set: function(G) {
    G = !!G, k = G;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (D) return D;
  }, set: function(G) {
    D = G;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 1);
  }, set: function(G) {
    G ? this.Ff = vs(this.Ff, 1) : this.Ff = xs(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 2);
  }, set: function(G) {
    G ? this.Ff = vs(this.Ff, 2) : this.Ff = xs(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 3);
  }, set: function(G) {
    G ? this.Ff = vs(this.Ff, 3) : this.Ff = xs(this.Ff, 3);
  } });
  var $ = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if ($ !== null) return $;
  }, set: function(G) {
    if ([0, 1, 2].indexOf(G) === -1) throw new Error('Invalid value "' + G + '" for attribute Q supplied.');
    $ = G;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var G;
    switch ($) {
      case 0:
      default:
        G = "left";
        break;
      case 1:
        G = "center";
        break;
      case 2:
        G = "right";
    }
    return G;
  }, configurable: !0, enumerable: !0, set: function(G) {
    switch (G) {
      case "right":
      case 2:
        $ = 2;
        break;
      case "center":
      case 1:
        $ = 1;
        break;
      default:
        $ = 0;
    }
  } });
};
Ra(Mc, xu);
var mp = function() {
  Mc.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var r = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return jR(e, this.objId, this.scope);
  }, set: function(t) {
    var i, n;
    n = [], typeof (i = t) == "string" && (n = function(s, c, o) {
      o || (o = 1);
      for (var d, m = []; d = c.exec(s); ) m.push(d[o]);
      return m;
    }(i, /\((.*?)\)/g)), e = n;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, i) {
    for (i = i || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), i !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 18) : this.Ff = xs(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = vs(this.Ff, 19) : this.Ff = xs(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = vs(this.Ff, 20), e.sort()) : this.Ff = xs(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 22) : this.Ff = xs(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 23) : this.Ff = xs(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 27) : this.Ff = xs(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Ra(mp, Mc);
var _p = function() {
  mp.call(this), this.fontName = "helvetica", this.combo = !1;
};
Ra(_p, mp);
var yp = function() {
  _p.call(this), this.combo = !0;
};
Ra(yp, _p);
var ry = function() {
  yp.call(this), this.edit = !0;
};
Ra(ry, yp);
var ho = function() {
  Mc.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 15) : this.Ff = xs(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 16) : this.Ff = xs(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 17) : this.Ff = xs(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = vs(this.Ff, 26) : this.Ff = xs(this.Ff, 26);
  } });
  var r, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(s) {
      return s;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var i, n = [];
      for (i in n.push("<<"), e) n.push("/" + i + " (" + fd(t(e[i])) + ")");
      return n.push(">>"), n.join(`
`);
    }
  }, set: function(t) {
    un(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return r.substr(1, r.length - 1);
  }, set: function(t) {
    r = "/" + t;
  } });
};
Ra(ho, Mc);
var iy = function() {
  ho.call(this), this.pushButton = !0;
};
Ra(iy, ho);
var bp = function() {
  ho.call(this), this.radio = !0, this.pushButton = !1;
  var r = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e !== void 0 ? e : [];
  } });
};
Ra(bp, ho);
var Gy = function() {
  var r, e;
  Mc.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(n) {
    r = n;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(n) {
    e = n;
  } });
  var t, i = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var n = function(o) {
      return o;
    };
    this.scope && (n = this.scope.internal.getEncryptor(this.objId));
    var s, c = [];
    for (s in c.push("<<"), i) c.push("/" + s + " (" + fd(n(i[s])) + ")");
    return c.push(">>"), c.join(`
`);
  }, set: function(n) {
    un(n) === "object" && (i = n);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return i.CA || "";
  }, set: function(n) {
    typeof n == "string" && (i.CA = n);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(n) {
    t = n;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(n) {
    t = "/" + n;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Mr.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Ra(Gy, Mc), bp.prototype.setAppearance = function(r) {
  if (!("createAppearanceStream" in r) || !("getCA" in r)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var t = this.Kids[e];
    t.appearanceStreamContent = r.createAppearanceStream(t.optionName), t.caption = r.getCA();
  }
}, bp.prototype.createOption = function(r) {
  var e = new Gy();
  return e.Parent = this, e.optionName = r, this.Kids.push(e), Mee.call(this.scope, e), e;
};
var ny = function() {
  ho.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Mr.CheckBox.createAppearanceStream();
};
Ra(ny, ho);
var Wf = function() {
  Mc.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = vs(this.Ff, 13) : this.Ff = xs(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = vs(this.Ff, 21) : this.Ff = xs(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = vs(this.Ff, 23) : this.Ff = xs(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = vs(this.Ff, 24) : this.Ff = xs(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = vs(this.Ff, 25) : this.Ff = xs(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = vs(this.Ff, 26) : this.Ff = xs(this.Ff, 26);
  } });
  var r = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(e) {
    Number.isInteger(e) && (r = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Ra(Wf, Mc);
var sy = function() {
  Wf.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!bs(this.Ff, 14);
  }, set: function(r) {
    r ? this.Ff = vs(this.Ff, 14) : this.Ff = xs(this.Ff, 14);
  } }), this.password = !0;
};
Ra(sy, Wf);
var Mr = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Mr.CheckBox.YesNormal }, D: { On: Mr.CheckBox.YesPushDown, Off: Mr.CheckBox.OffPushDown } };
}, YesPushDown: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = [], i = r.scope.internal.getFont(r.fontName, r.fontStyle).id, n = r.scope.__private__.encodeColorString(r.color), s = l2(r, r.caption);
  return t.push("0.749023 g"), t.push("0 0 " + di(Mr.internal.getWidth(r)) + " " + di(Mr.internal.getHeight(r)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + i + " " + di(s.fontSize) + " Tf " + n), t.push("BT"), t.push(s.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = r.scope.internal.getFont(r.fontName, r.fontStyle).id, i = r.scope.__private__.encodeColorString(r.color), n = [], s = Mr.internal.getHeight(r), c = Mr.internal.getWidth(r), o = l2(r, r.caption);
  return n.push("1 g"), n.push("0 0 " + di(c) + " " + di(s) + " re"), n.push("f"), n.push("q"), n.push("0 0 1 rg"), n.push("0 0 " + di(c - 1) + " " + di(s - 1) + " re"), n.push("W"), n.push("n"), n.push("0 g"), n.push("BT"), n.push("/" + t + " " + di(o.fontSize) + " Tf " + i), n.push(o.text), n.push("ET"), n.push("Q"), e.stream = n.join(`
`), e;
}, OffPushDown: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + di(Mr.internal.getWidth(r)) + " " + di(Mr.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(r) {
  var e = { D: { Off: Mr.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[r] = Mr.RadioButton.Circle.YesNormal, e.D[r] = Mr.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = [], i = Mr.internal.getWidth(r) <= Mr.internal.getHeight(r) ? Mr.internal.getWidth(r) / 4 : Mr.internal.getHeight(r) / 4;
  i = Number((0.9 * i).toFixed(5));
  var n = Mr.internal.Bezier_C, s = Number((i * n).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + Oh(Mr.internal.getWidth(r) / 2) + " " + Oh(Mr.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = [], i = Mr.internal.getWidth(r) <= Mr.internal.getHeight(r) ? Mr.internal.getWidth(r) / 4 : Mr.internal.getHeight(r) / 4;
  i = Number((0.9 * i).toFixed(5));
  var n = Number((2 * i).toFixed(5)), s = Number((n * Mr.internal.Bezier_C).toFixed(5)), c = Number((i * Mr.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + Oh(Mr.internal.getWidth(r) / 2) + " " + Oh(Mr.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + Oh(Mr.internal.getWidth(r) / 2) + " " + Oh(Mr.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + c + " " + c + " " + i + " 0 " + i + " c"), t.push("-" + c + " " + i + " -" + i + " " + c + " -" + i + " 0 c"), t.push("-" + i + " -" + c + " -" + c + " -" + i + " 0 -" + i + " c"), t.push(c + " -" + i + " " + i + " -" + c + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = [], i = Mr.internal.getWidth(r) <= Mr.internal.getHeight(r) ? Mr.internal.getWidth(r) / 4 : Mr.internal.getHeight(r) / 4;
  i = Number((0.9 * i).toFixed(5));
  var n = Number((2 * i).toFixed(5)), s = Number((n * Mr.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + Oh(Mr.internal.getWidth(r) / 2) + " " + Oh(Mr.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(r) {
  var e = { D: { Off: Mr.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[r] = Mr.RadioButton.Cross.YesNormal, e.D[r] = Mr.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = [], i = Mr.internal.calculateCross(r);
  return t.push("q"), t.push("1 1 " + di(Mr.internal.getWidth(r) - 2) + " " + di(Mr.internal.getHeight(r) - 2) + " re"), t.push("W"), t.push("n"), t.push(di(i.x1.x) + " " + di(i.x1.y) + " m"), t.push(di(i.x2.x) + " " + di(i.x2.y) + " l"), t.push(di(i.x4.x) + " " + di(i.x4.y) + " m"), t.push(di(i.x3.x) + " " + di(i.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = Mr.internal.calculateCross(r), i = [];
  return i.push("0.749023 g"), i.push("0 0 " + di(Mr.internal.getWidth(r)) + " " + di(Mr.internal.getHeight(r)) + " re"), i.push("f"), i.push("q"), i.push("1 1 " + di(Mr.internal.getWidth(r) - 2) + " " + di(Mr.internal.getHeight(r) - 2) + " re"), i.push("W"), i.push("n"), i.push(di(t.x1.x) + " " + di(t.x1.y) + " m"), i.push(di(t.x2.x) + " " + di(t.x2.y) + " l"), i.push(di(t.x4.x) + " " + di(t.x4.y) + " m"), i.push(di(t.x3.x) + " " + di(t.x3.y) + " l"), i.push("s"), i.push("Q"), e.stream = i.join(`
`), e;
}, OffPushDown: function(r) {
  var e = du(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + di(Mr.internal.getWidth(r)) + " " + di(Mr.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(r) {
  var e = r.scope.internal.getFont(r.fontName, r.fontStyle).id, t = r.scope.__private__.encodeColorString(r.color);
  return "/" + e + " " + r.fontSize + " Tf " + t;
} };
Mr.internal = { Bezier_C: 0.551915024494, calculateCross: function(r) {
  var e = Mr.internal.getWidth(r), t = Mr.internal.getHeight(r), i = Math.min(e, t);
  return { x1: { x: (e - i) / 2, y: (t - i) / 2 + i }, x2: { x: (e - i) / 2 + i, y: (t - i) / 2 }, x3: { x: (e - i) / 2, y: (t - i) / 2 }, x4: { x: (e - i) / 2 + i, y: (t - i) / 2 + i } };
} }, Mr.internal.getWidth = function(r) {
  var e = 0;
  return un(r) === "object" && (e = bC(r.Rect[2])), e;
}, Mr.internal.getHeight = function(r) {
  var e = 0;
  return un(r) === "object" && (e = bC(r.Rect[3])), e;
};
var Mee = ls.addField = function(r) {
  if (Pee(this, r), !(r instanceof Mc)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = r).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), r.page = r.scope.internal.getCurrentPageInfo().pageNumber, this;
};
ls.AcroFormChoiceField = mp, ls.AcroFormListBox = _p, ls.AcroFormComboBox = yp, ls.AcroFormEditBox = ry, ls.AcroFormButton = ho, ls.AcroFormPushButton = iy, ls.AcroFormRadioButton = bp, ls.AcroFormCheckBox = ny, ls.AcroFormTextField = Wf, ls.AcroFormPasswordField = sy, ls.AcroFormAppearance = Mr, ls.AcroForm = { ChoiceField: mp, ListBox: _p, ComboBox: yp, EditBox: ry, Button: ho, PushButton: iy, RadioButton: bp, CheckBox: ny, TextField: Wf, PasswordField: sy, Appearance: Mr }, Ur.AcroForm = { ChoiceField: mp, ListBox: _p, ComboBox: yp, EditBox: ry, Button: ho, PushButton: iy, RadioButton: bp, CheckBox: ny, TextField: Wf, PasswordField: sy, Appearance: Mr };
Ur.AcroForm;
function $R(r) {
  return r.reduce(function(e, t, i) {
    return e[t] = i, e;
  }, {});
}
(function(r) {
  var e = "addImage_";
  r.__addimage__ = {};
  var t = "UNKNOWN", i = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, n = r.__addimage__.getImageFileTypeByImageData = function(le, _e) {
    var Ve, Be, gt, St, Mt, mt = t;
    if ((_e = _e || t) === "RGBA" || le.data !== void 0 && le.data instanceof Uint8ClampedArray && "height" in le && "width" in le) return "RGBA";
    if (re(le)) for (Mt in i) for (gt = i[Mt], Ve = 0; Ve < gt.length; Ve += 1) {
      for (St = !0, Be = 0; Be < gt[Ve].length; Be += 1) if (gt[Ve][Be] !== void 0 && gt[Ve][Be] !== le[Be]) {
        St = !1;
        break;
      }
      if (St === !0) {
        mt = Mt;
        break;
      }
    }
    else for (Mt in i) for (gt = i[Mt], Ve = 0; Ve < gt.length; Ve += 1) {
      for (St = !0, Be = 0; Be < gt[Ve].length; Be += 1) if (gt[Ve][Be] !== void 0 && gt[Ve][Be] !== le.charCodeAt(Be)) {
        St = !1;
        break;
      }
      if (St === !0) {
        mt = Mt;
        break;
      }
    }
    return mt === t && _e !== t && (mt = _e), mt;
  }, s = function le(_e) {
    for (var Ve = this.internal.write, Be = this.internal.putStream, gt = (0, this.internal.getFilters)(); gt.indexOf("FlateEncode") !== -1; ) gt.splice(gt.indexOf("FlateEncode"), 1);
    _e.objectId = this.internal.newObject();
    var St = [];
    if (St.push({ key: "Type", value: "/XObject" }), St.push({ key: "Subtype", value: "/Image" }), St.push({ key: "Width", value: _e.width }), St.push({ key: "Height", value: _e.height }), _e.colorSpace === G.INDEXED ? St.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (_e.palette.length / 3 - 1) + " " + ("sMask" in _e && _e.sMask !== void 0 ? _e.objectId + 2 : _e.objectId + 1) + " 0 R]" }) : (St.push({ key: "ColorSpace", value: "/" + _e.colorSpace }), _e.colorSpace === G.DEVICE_CMYK && St.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), St.push({ key: "BitsPerComponent", value: _e.bitsPerComponent }), "decodeParameters" in _e && _e.decodeParameters !== void 0 && St.push({ key: "DecodeParms", value: "<<" + _e.decodeParameters + ">>" }), "transparency" in _e && Array.isArray(_e.transparency)) {
      for (var Mt = "", mt = 0, wt = _e.transparency.length; mt < wt; mt++) Mt += _e.transparency[mt] + " " + _e.transparency[mt] + " ";
      St.push({ key: "Mask", value: "[" + Mt + "]" });
    }
    _e.sMask !== void 0 && St.push({ key: "SMask", value: _e.objectId + 1 + " 0 R" });
    var Yt = _e.filter !== void 0 ? ["/" + _e.filter] : void 0;
    if (Be({ data: _e.data, additionalKeyValues: St, alreadyAppliedFilters: Yt, objectId: _e.objectId }), Ve("endobj"), "sMask" in _e && _e.sMask !== void 0) {
      var Dt = (_e.predictor != null ? "/Predictor " + _e.predictor : "") + " /Colors 1 /BitsPerComponent 8 /Columns " + _e.width, fe = { width: _e.width, height: _e.height, colorSpace: "DeviceGray", bitsPerComponent: _e.bitsPerComponent, decodeParameters: Dt, data: _e.sMask };
      "filter" in _e && (fe.filter = _e.filter), le.call(this, fe);
    }
    if (_e.colorSpace === G.INDEXED) {
      var De = this.internal.newObject();
      Be({ data: pe(new Uint8Array(_e.palette)), objectId: De }), Ve("endobj");
    }
  }, c = function() {
    var le = this.internal.collections[e + "images"];
    for (var _e in le) s.call(this, le[_e]);
  }, o = function() {
    var le, _e = this.internal.collections[e + "images"], Ve = this.internal.write;
    for (var Be in _e) Ve("/I" + (le = _e[Be]).index, le.objectId, "0", "R");
  }, d = function() {
    this.internal.collections[e + "images"] || (this.internal.collections[e + "images"] = {}, this.internal.events.subscribe("putResources", c), this.internal.events.subscribe("putXobjectDict", o));
  }, m = function() {
    var le = this.internal.collections[e + "images"];
    return d.call(this), le;
  }, y = function() {
    return Object.keys(this.internal.collections[e + "images"]).length;
  }, T = function(le) {
    return typeof r["process" + le.toUpperCase()] == "function";
  }, P = function(le) {
    return un(le) === "object" && le.nodeType === 1;
  }, I = function(le, _e) {
    if (le.nodeName === "IMG" && le.hasAttribute("src")) {
      var Ve = "" + le.getAttribute("src");
      if (Ve.indexOf("data:image/") === 0) return ty(unescape(Ve).split("base64,").pop());
      var Be = r.loadFile(Ve, !0);
      if (Be !== void 0) return Be;
    }
    if (le.nodeName === "CANVAS") {
      if (le.width === 0 || le.height === 0) throw new Error("Given canvas must have data. Canvas width: " + le.width + ", height: " + le.height);
      var gt;
      switch (_e) {
        case "PNG":
          gt = "image/png";
          break;
        case "WEBP":
          gt = "image/webp";
          break;
        default:
          gt = "image/jpeg";
      }
      return ty(le.toDataURL(gt, 1).split("base64,").pop());
    }
  }, D = function(le) {
    var _e = this.internal.collections[e + "images"];
    if (_e) {
      for (var Ve in _e) if (le === _e[Ve].alias) return _e[Ve];
    }
  }, k = function(le, _e, Ve) {
    return le || _e || (le = -96, _e = -96), le < 0 && (le = -1 * Ve.width * 72 / le / this.internal.scaleFactor), _e < 0 && (_e = -1 * Ve.height * 72 / _e / this.internal.scaleFactor), le === 0 && (le = _e * Ve.width / Ve.height), _e === 0 && (_e = le * Ve.height / Ve.width), [le, _e];
  }, $ = function(le, _e, Ve, Be, gt, St) {
    var Mt = k.call(this, Ve, Be, gt), mt = this.internal.getCoordinateString, wt = this.internal.getVerticalCoordinateString, Yt = m.call(this);
    if (Ve = Mt[0], Be = Mt[1], Yt[gt.index] = gt, St) {
      St *= Math.PI / 180;
      var Dt = Math.cos(St), fe = Math.sin(St), De = function(Ke) {
        return Ke.toFixed(4);
      }, je = [De(Dt), De(fe), De(-1 * fe), De(Dt), 0, 0, "cm"];
    }
    this.internal.write("q"), St ? (this.internal.write([1, "0", "0", 1, mt(le), wt(_e + Be), "cm"].join(" ")), this.internal.write(je.join(" ")), this.internal.write([mt(Ve), "0", "0", mt(Be), "0", "0", "cm"].join(" "))) : this.internal.write([mt(Ve), "0", "0", mt(Be), mt(le), wt(_e + Be), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + gt.index + " Do"), this.internal.write("Q");
  }, G = r.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  r.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var te = r.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, Z = r.__addimage__.sHashCode = function(le) {
    var _e, Ve, Be = 0;
    if (typeof le == "string") for (Ve = le.length, _e = 0; _e < Ve; _e++) Be = (Be << 5) - Be + le.charCodeAt(_e), Be |= 0;
    else if (re(le)) for (Ve = le.byteLength / 2, _e = 0; _e < Ve; _e++) Be = (Be << 5) - Be + le[_e], Be |= 0;
    return Be;
  }, H = r.__addimage__.validateStringAsBase64 = function(le) {
    (le = le || "").toString().trim();
    var _e = !0;
    return le.length === 0 && (_e = !1), le.length % 4 != 0 && (_e = !1), /^[A-Za-z0-9+/]+$/.test(le.substr(0, le.length - 2)) === !1 && (_e = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(le.substr(-2)) === !1 && (_e = !1), _e;
  }, J = r.__addimage__.extractImageFromDataUrl = function(le) {
    if (le == null || !(le = le.trim()).startsWith("data:")) return null;
    var _e = le.indexOf(",");
    return _e < 0 ? null : le.substring(0, _e).trim().endsWith("base64") ? le.substring(_e + 1) : null;
  };
  r.__addimage__.isArrayBuffer = function(le) {
    return le instanceof ArrayBuffer;
  };
  var re = r.__addimage__.isArrayBufferView = function(le) {
    return le instanceof Int8Array || le instanceof Uint8Array || le instanceof Uint8ClampedArray || le instanceof Int16Array || le instanceof Uint16Array || le instanceof Int32Array || le instanceof Uint32Array || le instanceof Float32Array || le instanceof Float64Array;
  }, be = r.__addimage__.binaryStringToUint8Array = function(le) {
    for (var _e = le.length, Ve = new Uint8Array(_e), Be = 0; Be < _e; Be++) Ve[Be] = le.charCodeAt(Be);
    return Ve;
  }, pe = r.__addimage__.arrayBufferToBinaryString = function(le) {
    for (var _e = "", Ve = re(le) ? le : new Uint8Array(le), Be = 0; Be < Ve.length; Be += 8192) _e += String.fromCharCode.apply(null, Ve.subarray(Be, Be + 8192));
    return _e;
  };
  r.addImage = function() {
    var le, _e, Ve, Be, gt, St, Mt, mt, wt;
    if (typeof arguments[1] == "number" ? (_e = t, Ve = arguments[1], Be = arguments[2], gt = arguments[3], St = arguments[4], Mt = arguments[5], mt = arguments[6], wt = arguments[7]) : (_e = arguments[1], Ve = arguments[2], Be = arguments[3], gt = arguments[4], St = arguments[5], Mt = arguments[6], mt = arguments[7], wt = arguments[8]), un(le = arguments[0]) === "object" && !P(le) && "imageData" in le) {
      var Yt = le;
      le = Yt.imageData, _e = Yt.format || _e || t, Ve = Yt.x || Ve || 0, Be = Yt.y || Be || 0, gt = Yt.w || Yt.width || gt, St = Yt.h || Yt.height || St, Mt = Yt.alias || Mt, mt = Yt.compression || mt, wt = Yt.rotation || Yt.angle || wt;
    }
    var Dt = this.internal.getFilters();
    if (mt === void 0 && Dt.indexOf("FlateEncode") !== -1 && (mt = "SLOW"), isNaN(Ve) || isNaN(Be)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    d.call(this);
    var fe = oe.call(this, le, _e, Mt, mt);
    return $.call(this, Ve, Be, gt, St, fe, wt), this;
  };
  var oe = function(le, _e, Ve, Be) {
    var gt, St, Mt;
    if (typeof le == "string" && n(le) === t) {
      le = unescape(le);
      var mt = Ee(le, !1);
      (mt !== "" || (mt = r.loadFile(le, !0)) !== void 0) && (le = mt);
    }
    if (P(le) && (le = I(le, _e)), _e = n(le, _e), !T(_e)) throw new Error("addImage does not support files of type '" + _e + "', please ensure that a plugin for '" + _e + "' support is added.");
    if (((Mt = Ve) == null || Mt.length === 0) && (Ve = function(wt) {
      return typeof wt == "string" || re(wt) ? Z(wt) : re(wt.data) ? Z(wt.data) : null;
    }(le)), (gt = D.call(this, Ve)) || (le instanceof Uint8Array || _e === "RGBA" || (St = le, le = be(le)), gt = this["process" + _e.toUpperCase()](le, y.call(this), Ve, function(wt) {
      return wt && typeof wt == "string" && (wt = wt.toUpperCase()), wt in r.image_compression ? wt : te.NONE;
    }(Be), St)), !gt) throw new Error("An unknown error occurred whilst processing the image.");
    return gt;
  }, Ee = r.__addimage__.convertBase64ToBinaryString = function(le, _e) {
    _e = typeof _e != "boolean" || _e;
    var Ve, Be = "";
    if (typeof le == "string") {
      var gt;
      Ve = (gt = J(le)) !== null && gt !== void 0 ? gt : le;
      try {
        Be = ty(Ve);
      } catch (St) {
        if (_e) throw H(Ve) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + St.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Be;
  };
  r.getImageProperties = function(le) {
    var _e, Ve, Be = "";
    if (P(le) && (le = I(le)), typeof le == "string" && n(le) === t && ((Be = Ee(le, !1)) === "" && (Be = r.loadFile(le) || ""), le = Be), Ve = n(le), !T(Ve)) throw new Error("addImage does not support files of type '" + Ve + "', please ensure that a plugin for '" + Ve + "' support is added.");
    if (le instanceof Uint8Array || (le = be(le)), !(_e = this["process" + Ve.toUpperCase()](le))) throw new Error("An unknown error occurred whilst processing the image");
    return _e.fileType = Ve, _e;
  };
})(Ur.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(t) {
    if (t !== void 0 && t != "") return !0;
  };
  Ur.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), r.events.push(["putPage", function(t) {
    for (var i, n, s, c = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, d = this.internal.getPageInfoByObjId(t.objId), m = t.pageContext.annotations, y = !1, T = 0; T < m.length && !y; T++) switch ((i = m[T]).type) {
      case "link":
        (e(i.options.url) || e(i.options.pageNumber)) && (y = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        y = !0;
    }
    if (y != 0) {
      this.internal.write("/Annots [");
      for (var P = 0; P < m.length; P++) {
        i = m[P];
        var I = this.internal.pdfEscape, D = this.internal.getEncryptor(t.objId);
        switch (i.type) {
          case "reference":
            this.internal.write(" " + i.object.objId + " 0 R ");
            break;
          case "text":
            var k = this.internal.newAdditionalObject(), $ = this.internal.newAdditionalObject(), G = this.internal.getEncryptor(k.objId), te = i.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (n = "/Rect [" + c(i.bounds.x) + " " + o(i.bounds.y + i.bounds.h) + " " + c(i.bounds.x + i.bounds.w) + " " + o(i.bounds.y) + "] ") + "/Contents (" + I(G(i.contents)) + ")", s += " /Popup " + $.objId + " 0 R", s += " /P " + d.objId + " 0 R", s += " /T (" + I(G(te)) + ") >>", k.content = s;
            var Z = k.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (n = "/Rect [" + c(i.bounds.x + 30) + " " + o(i.bounds.y + i.bounds.h) + " " + c(i.bounds.x + i.bounds.w + 30) + " " + o(i.bounds.y) + "] ") + " /Parent " + Z, i.open && (s += " /Open true"), s += " >>", $.content = s, this.internal.write(k.objId, "0 R", $.objId, "0 R");
            break;
          case "freetext":
            n = "/Rect [" + c(i.bounds.x) + " " + o(i.bounds.y) + " " + c(i.bounds.x + i.bounds.w) + " " + o(i.bounds.y + i.bounds.h) + "] ";
            var H = i.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + n + "/Contents (" + I(D(i.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + H + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (i.options.name) {
              var J = this.annotations._nameMap[i.options.name];
              i.options.pageNumber = J.page, i.options.top = J.y;
            } else i.options.top || (i.options.top = 0);
            if (n = "/Rect [" + i.finalBounds.x + " " + i.finalBounds.y + " " + i.finalBounds.w + " " + i.finalBounds.h + "] ", s = "", i.options.url) s = "<</Type /Annot /Subtype /Link " + n + "/Border [0 0 0] /A <</S /URI /URI (" + I(D(i.options.url)) + ") >>";
            else if (i.options.pageNumber) switch (s = "<</Type /Annot /Subtype /Link " + n + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(i.options.pageNumber).objId + " 0 R", i.options.magFactor = i.options.magFactor || "XYZ", i.options.magFactor) {
              case "Fit":
                s += " /Fit]";
                break;
              case "FitH":
                s += " /FitH " + i.options.top + "]";
                break;
              case "FitV":
                i.options.left = i.options.left || 0, s += " /FitV " + i.options.left + "]";
                break;
              default:
                var re = o(i.options.top);
                i.options.left = i.options.left || 0, i.options.zoom === void 0 && (i.options.zoom = 0), s += " /XYZ " + i.options.left + " " + re + " " + i.options.zoom + "]";
            }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), r.createAnnotation = function(t) {
    var i = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        i.pageContext.annotations.push(t);
    }
  }, r.link = function(t, i, n, s, c) {
    var o = this.internal.getCurrentPageInfo(), d = this.internal.getCoordinateString, m = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: d(t), y: m(i), w: d(t + n), h: m(i + s) }, options: c, type: "link" });
  }, r.textWithLink = function(t, i, n, s) {
    var c, o, d = this.getTextWidth(t), m = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      o = s.maxWidth;
      var y = this.splitTextToSize(t, o).length;
      c = Math.ceil(m * y);
    } else o = d, c = m;
    return this.text(t, i, n, s), n += 0.2 * m, s.align === "center" && (i -= d / 2), s.align === "right" && (i -= d), this.link(i, n - m, o, c, s), d;
  }, r.getTextWidth = function(t) {
    var i = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * i / this.internal.scaleFactor;
  };
}(Ur.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, i = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, n = [1570, 1571, 1573, 1575];
  r.__arabicParser__ = {};
  var s = r.__arabicParser__.isInArabicSubstitutionA = function(k) {
    return e[k.charCodeAt(0)] !== void 0;
  }, c = r.__arabicParser__.isArabicLetter = function(k) {
    return typeof k == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(k);
  }, o = r.__arabicParser__.isArabicEndLetter = function(k) {
    return c(k) && s(k) && e[k.charCodeAt(0)].length <= 2;
  }, d = r.__arabicParser__.isArabicAlfLetter = function(k) {
    return c(k) && n.indexOf(k.charCodeAt(0)) >= 0;
  };
  r.__arabicParser__.arabicLetterHasIsolatedForm = function(k) {
    return c(k) && s(k) && e[k.charCodeAt(0)].length >= 1;
  };
  var m = r.__arabicParser__.arabicLetterHasFinalForm = function(k) {
    return c(k) && s(k) && e[k.charCodeAt(0)].length >= 2;
  };
  r.__arabicParser__.arabicLetterHasInitialForm = function(k) {
    return c(k) && s(k) && e[k.charCodeAt(0)].length >= 3;
  };
  var y = r.__arabicParser__.arabicLetterHasMedialForm = function(k) {
    return c(k) && s(k) && e[k.charCodeAt(0)].length == 4;
  }, T = r.__arabicParser__.resolveLigatures = function(k) {
    var $ = 0, G = t, te = "", Z = 0;
    for ($ = 0; $ < k.length; $ += 1) G[k.charCodeAt($)] !== void 0 ? (Z++, typeof (G = G[k.charCodeAt($)]) == "number" && (te += String.fromCharCode(G), G = t, Z = 0), $ === k.length - 1 && (G = t, te += k.charAt($ - (Z - 1)), $ -= Z - 1, Z = 0)) : (G = t, te += k.charAt($ - Z), $ -= Z, Z = 0);
    return te;
  };
  r.__arabicParser__.isArabicDiacritic = function(k) {
    return k !== void 0 && i[k.charCodeAt(0)] !== void 0;
  };
  var P = r.__arabicParser__.getCorrectForm = function(k, $, G) {
    return c(k) ? s(k) === !1 ? -1 : !m(k) || !c($) && !c(G) || !c(G) && o($) || o(k) && !c($) || o(k) && d($) || o(k) && o($) ? 0 : y(k) && c($) && !o($) && c(G) && m(G) ? 3 : o(k) || !c(G) ? 1 : 2 : -1;
  }, I = function(k) {
    var $ = 0, G = 0, te = 0, Z = "", H = "", J = "", re = (k = k || "").split("\\s+"), be = [];
    for ($ = 0; $ < re.length; $ += 1) {
      for (be.push(""), G = 0; G < re[$].length; G += 1) Z = re[$][G], H = re[$][G - 1], J = re[$][G + 1], c(Z) ? (te = P(Z, H, J), be[$] += te !== -1 ? String.fromCharCode(e[Z.charCodeAt(0)][te]) : Z) : be[$] += Z;
      be[$] = T(be[$]);
    }
    return be.join(" ");
  }, D = r.__arabicParser__.processArabic = r.processArabic = function() {
    var k, $ = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, G = [];
    if (Array.isArray($)) {
      var te = 0;
      for (G = [], te = 0; te < $.length; te += 1) Array.isArray($[te]) ? G.push([I($[te][0]), $[te][1], $[te][2]]) : G.push([I($[te])]);
      k = G;
    } else k = I($);
    return typeof arguments[0] == "string" ? k : (arguments[0].text = k, arguments[0]);
  };
  r.events.push(["preProcessText", D]);
}(Ur.API), Ur.API.autoPrint = function(r) {
  var e;
  return (r = r || {}).variant = r.variant || "non-conform", r.variant === "javascript" ? this.addJS("print({});") : (this.internal.events.subscribe("postPutResources", function() {
    e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    this.internal.out("/OpenAction " + e + " 0 R");
  })), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(o) {
      t = o;
    } });
    var i = 150;
    Object.defineProperty(this, "width", { get: function() {
      return i;
    }, set: function(o) {
      i = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = i + 1);
    } });
    var n = 300;
    Object.defineProperty(this, "height", { get: function() {
      return n;
    }, set: function(o) {
      n = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = n + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(o) {
      s = o;
    } });
    var c = {};
    Object.defineProperty(this, "style", { get: function() {
      return c;
    }, set: function(o) {
      c = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, i) {
    var n;
    if ((t = t || "2d") !== "2d") return null;
    for (n in i) this.pdf.context2d.hasOwnProperty(n) && (this.pdf.context2d[n] = i[n]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, r.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(Ur.API), function(r) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, i = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), n.call(this));
  }, n = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var d = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return d;
    }, set: function(k) {
      d = k;
    } });
    var m = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return m;
    }, set: function(k) {
      m = k;
    } });
    var y = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return y;
    }, set: function(k) {
      y = k;
    } });
    var T = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return T;
    }, set: function(k) {
      T = k;
    } });
    var P = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return P;
    }, set: function(k) {
      P = k;
    } });
    var I = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return I;
    }, set: function(k) {
      I = k;
    } });
    var D = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return D;
    }, set: function(k) {
      D = k;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, r.setHeaderFunction = function(d) {
    return i.call(this), this.internal.__cell__.headerFunction = typeof d == "function" ? d : void 0, this;
  }, r.getTextDimensions = function(d, m) {
    i.call(this);
    var y = (m = m || {}).fontSize || this.getFontSize(), T = m.font || this.getFont(), P = m.scaleFactor || this.internal.scaleFactor, I = 0, D = 0, k = 0, $ = this;
    if (!Array.isArray(d) && typeof d != "string") {
      if (typeof d != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      d = String(d);
    }
    var G = m.maxWidth;
    G > 0 ? typeof d == "string" ? d = this.splitTextToSize(d, G) : Object.prototype.toString.call(d) === "[object Array]" && (d = d.reduce(function(Z, H) {
      return Z.concat($.splitTextToSize(H, G));
    }, [])) : d = Array.isArray(d) ? d : [d];
    for (var te = 0; te < d.length; te++) I < (k = this.getStringUnitWidth(d[te], { font: T }) * y) && (I = k);
    return I !== 0 && (D = d.length), { w: I /= P, h: Math.max((D * y * this.getLineHeightFactor() - y * (this.getLineHeightFactor() - 1)) / P, 0) };
  }, r.cellAddPage = function() {
    i.call(this), this.addPage();
    var d = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new s(d.left, d.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var c = r.cell = function() {
    var d;
    d = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var m = this.internal.__cell__.lastCell, y = this.internal.__cell__.padding, T = this.internal.__cell__.margins || e, P = this.internal.__cell__.tableHeaderRow, I = this.internal.__cell__.printHeaders;
    return m.lineNumber !== void 0 && (m.lineNumber === d.lineNumber ? (d.x = (m.x || 0) + (m.width || 0), d.y = m.y || 0) : m.y + m.height + d.height + T.bottom > this.getPageHeight() ? (this.cellAddPage(), d.y = T.top, I && P && (this.printHeaderRow(d.lineNumber, !0), d.y += P[0].height)) : d.y = m.y + m.height || d.y), d.text[0] !== void 0 && (this.rect(d.x, d.y, d.width, d.height, t === !0 ? "FD" : void 0), d.align === "right" ? this.text(d.text, d.x + d.width - y, d.y + y, { align: "right", baseline: "top" }) : d.align === "center" ? this.text(d.text, d.x + d.width / 2, d.y + y, { align: "center", baseline: "top", maxWidth: d.width - y - y }) : this.text(d.text, d.x + y, d.y + y, { align: "left", baseline: "top", maxWidth: d.width - y - y })), this.internal.__cell__.lastCell = d, this;
  };
  r.table = function(d, m, y, T, P) {
    if (i.call(this), !y) throw new Error("No data for PDF table.");
    var I, D, k, $, G = [], te = [], Z = [], H = {}, J = {}, re = [], be = [], pe = (P = P || {}).autoSize || !1, oe = P.printHeaders !== !1, Ee = P.css && P.css["font-size"] !== void 0 ? 16 * P.css["font-size"] : P.fontSize || 12, le = P.margins || Object.assign({ width: this.getPageWidth() }, e), _e = typeof P.padding == "number" ? P.padding : 3, Ve = P.headerBackgroundColor || "#c8c8c8", Be = P.headerTextColor || "#000";
    if (n.call(this), this.internal.__cell__.printHeaders = oe, this.internal.__cell__.margins = le, this.internal.__cell__.table_font_size = Ee, this.internal.__cell__.padding = _e, this.internal.__cell__.headerBackgroundColor = Ve, this.internal.__cell__.headerTextColor = Be, this.setFontSize(Ee), T == null) te = G = Object.keys(y[0]), Z = G.map(function() {
      return "left";
    });
    else if (Array.isArray(T) && un(T[0]) === "object") for (G = T.map(function(Yt) {
      return Yt.name;
    }), te = T.map(function(Yt) {
      return Yt.prompt || Yt.name || "";
    }), Z = T.map(function(Yt) {
      return Yt.align || "left";
    }), I = 0; I < T.length; I += 1) J[T[I].name] = 0.7499990551181103 * T[I].width;
    else Array.isArray(T) && typeof T[0] == "string" && (te = G = T, Z = G.map(function() {
      return "left";
    }));
    if (pe || Array.isArray(T) && typeof T[0] == "string") for (I = 0; I < G.length; I += 1) {
      for (H[$ = G[I]] = y.map(function(Yt) {
        return Yt[$];
      }), this.setFont(void 0, "bold"), re.push(this.getTextDimensions(te[I], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), D = H[$], this.setFont(void 0, "normal"), k = 0; k < D.length; k += 1) re.push(this.getTextDimensions(D[k], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      J[$] = Math.max.apply(null, re) + _e + _e, re = [];
    }
    if (oe) {
      var gt = {};
      for (I = 0; I < G.length; I += 1) gt[G[I]] = {}, gt[G[I]].text = te[I], gt[G[I]].align = Z[I];
      var St = o.call(this, gt, J);
      be = G.map(function(Yt) {
        return new s(d, m, J[Yt], St, gt[Yt].text, void 0, gt[Yt].align);
      }), this.setTableHeaderRow(be), this.printHeaderRow(1, !1);
    }
    var Mt = T.reduce(function(Yt, Dt) {
      return Yt[Dt.name] = Dt.align, Yt;
    }, {});
    for (I = 0; I < y.length; I += 1) {
      "rowStart" in P && P.rowStart instanceof Function && P.rowStart({ row: I, data: y[I] }, this);
      var mt = o.call(this, y[I], J);
      for (k = 0; k < G.length; k += 1) {
        var wt = y[I][G[k]];
        "cellStart" in P && P.cellStart instanceof Function && P.cellStart({ row: I, col: k, data: wt }, this), c.call(this, new s(d, m, J[G[k]], mt, wt, I + 2, Mt[G[k]]));
      }
    }
    return this.internal.__cell__.table_x = d, this.internal.__cell__.table_y = m, this;
  };
  var o = function(d, m) {
    var y = this.internal.__cell__.padding, T = this.internal.__cell__.table_font_size, P = this.internal.scaleFactor;
    return Object.keys(d).map(function(I) {
      var D = d[I];
      return this.splitTextToSize(D.hasOwnProperty("text") ? D.text : D, m[I] - y - y);
    }, this).map(function(I) {
      return this.getLineHeightFactor() * I.length * T / P + y + y;
    }, this).reduce(function(I, D) {
      return Math.max(I, D);
    }, 0);
  };
  r.setTableHeaderRow = function(d) {
    i.call(this), this.internal.__cell__.tableHeaderRow = d;
  }, r.printHeaderRow = function(d, m) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var y;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var T = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(T[0], T[1], T[2], T[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var P = [], I = 0; I < this.internal.__cell__.tableHeaderRow.length; I += 1) {
      y = this.internal.__cell__.tableHeaderRow[I].clone(), m && (y.y = this.internal.__cell__.margins.top || 0, P.push(y)), y.lineNumber = d;
      var D = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), c.call(this, y), this.setTextColor(D);
    }
    P.length > 0 && this.setTableHeaderRow(P), this.setFont(void 0, "normal"), t = !1;
  };
}(Ur.API);
var HR = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, qR = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], c2 = $R(qR), WR = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ree = $R(WR);
function N1(r) {
  var e = r.family.replace(/"|'/g, "").toLowerCase(), t = function(s) {
    return HR[s = s || "normal"] ? s : "normal";
  }(r.style), i = function(s) {
    return s ? typeof s == "number" ? s >= 100 && s <= 900 && s % 100 == 0 ? s : 400 : /^\d00$/.test(s) ? parseInt(s) : s === "bold" ? 700 : 400 : 400;
  }(r.weight), n = function(s) {
    return typeof c2[s = s || "normal"] == "number" ? s : "normal";
  }(r.stretch);
  return { family: e, style: t, weight: i, stretch: n, src: r.src || [], ref: r.ref || { name: e, style: [n, t, i].join(" ") } };
}
function vC(r, e, t, i) {
  var n;
  for (n = t; n >= 0 && n < e.length; n += i) if (r[e[n]]) return r[e[n]];
  for (n = t; n >= 0 && n < e.length; n -= i) if (r[e[n]]) return r[e[n]];
}
var Lee = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, xC = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function wC(r) {
  return [r.stretch, r.style, r.weight, r.family].join(" ");
}
function AC(r) {
  return r.trimLeft();
}
function Bee(r, e) {
  for (var t = 0; t < r.length; ) {
    if (r.charAt(t) === e) return [r.substring(0, t), r.substring(t + 1)];
    t += 1;
  }
  return null;
}
function kee(r) {
  var e = r.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], r.substring(e[0].length)];
}
var R_, TC, SC, Xd, L_, EC, CC, IC, PC = ["times"];
function MC(r, e, t, i) {
  var n = 4, s = LC;
  switch (i) {
    case Ur.API.image_compression.FAST:
      n = 1, s = RC;
      break;
    case Ur.API.image_compression.MEDIUM:
      n = 6, s = BC;
      break;
    case Ur.API.image_compression.SLOW:
      n = 9, s = kC;
  }
  r = function(o, d, m, y) {
    for (var T, P = o.length / d, I = new Uint8Array(o.length + P), D = [Oee, RC, LC, BC, kC], k = 0; k < P; k += 1) {
      var $ = k * d, G = o.subarray($, $ + d);
      if (y) I.set(y(G, m, T), $ + k);
      else {
        for (var te = D.length, Z = [], H = 0; H < te; H += 1) Z[H] = D[H](G, m, T);
        var J = Nee(Z.concat());
        I.set(Z[J], $ + k);
      }
      T = G;
    }
    return I;
  }(r, e, t, s);
  var c = r2(r, { level: n });
  return Ur.API.__addimage__.arrayBufferToBinaryString(c);
}
function Oee(r) {
  var e = Array.apply([], r);
  return e.unshift(0), e;
}
function RC(r, e) {
  var t = r.length, i = [];
  i[0] = 1;
  for (var n = 0; n < t; n += 1) {
    var s = r[n - e] || 0;
    i[n + 1] = r[n] - s + 256 & 255;
  }
  return i;
}
function LC(r, e, t) {
  var i = r.length, n = [];
  n[0] = 2;
  for (var s = 0; s < i; s += 1) {
    var c = t && t[s] || 0;
    n[s + 1] = r[s] - c + 256 & 255;
  }
  return n;
}
function BC(r, e, t) {
  var i = r.length, n = [];
  n[0] = 3;
  for (var s = 0; s < i; s += 1) {
    var c = r[s - e] || 0, o = t && t[s] || 0;
    n[s + 1] = r[s] + 256 - (c + o >>> 1) & 255;
  }
  return n;
}
function kC(r, e, t) {
  var i = r.length, n = [];
  n[0] = 4;
  for (var s = 0; s < i; s += 1) {
    var c = Dee(r[s - e] || 0, t && t[s] || 0, t && t[s - e] || 0);
    n[s + 1] = r[s] - c + 256 & 255;
  }
  return n;
}
function Dee(r, e, t) {
  if (r === e && e === t) return r;
  var i = Math.abs(e - t), n = Math.abs(r - t), s = Math.abs(r + e - t - t);
  return i <= n && i <= s ? r : n <= s ? e : t;
}
function Nee(r) {
  var e = r.map(function(t) {
    return t.reduce(function(i, n) {
      return i + Math.abs(n);
    }, 0);
  });
  return e.indexOf(Math.min.apply(null, e));
}
function F1(r, e, t) {
  var i = e * t, n = Math.floor(i / 8), s = 16 - (i - 8 * n + t), c = (1 << t) - 1;
  return XR(r, n) >> s & c;
}
function OC(r, e, t, i) {
  var n = t * i, s = Math.floor(n / 8), c = 16 - (n - 8 * s + i), o = (1 << i) - 1, d = (e & o) << c;
  (function(m, y, T) {
    if (y + 1 < m.byteLength) m.setUint16(y, T, !1);
    else {
      var P = T >> 8 & 255;
      m.setUint8(y, P);
    }
  })(r, s, XR(r, s) & ~(o << c) & 65535 | d);
}
function XR(r, e) {
  return e + 1 < r.byteLength ? r.getUint16(e, !1) : r.getUint8(e) << 8;
}
function Fee(r) {
  var e = 0;
  if (r[e++] !== 71 || r[e++] !== 73 || r[e++] !== 70 || r[e++] !== 56 || (r[e++] + 1 & 253) != 56 || r[e++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var t = r[e++] | r[e++] << 8, i = r[e++] | r[e++] << 8, n = r[e++], s = n >> 7, c = 1 << 1 + (7 & n);
  r[e++], r[e++];
  var o = null, d = null;
  s && (o = e, d = c, e += 3 * c);
  var m = !0, y = [], T = 0, P = null, I = 0, D = null;
  for (this.width = t, this.height = i; m && e < r.length; ) switch (r[e++]) {
    case 33:
      switch (r[e++]) {
        case 255:
          if (r[e] !== 11 || r[e + 1] == 78 && r[e + 2] == 69 && r[e + 3] == 84 && r[e + 4] == 83 && r[e + 5] == 67 && r[e + 6] == 65 && r[e + 7] == 80 && r[e + 8] == 69 && r[e + 9] == 50 && r[e + 10] == 46 && r[e + 11] == 48 && r[e + 12] == 3 && r[e + 13] == 1 && r[e + 16] == 0) e += 14, D = r[e++] | r[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((le = r[e++]) >= 0)) throw Error("Invalid block size");
            if (le === 0) break;
            e += le;
          }
          break;
        case 249:
          if (r[e++] !== 4 || r[e + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var k = r[e++];
          T = r[e++] | r[e++] << 8, P = r[e++], 1 & k || (P = null), I = k >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((le = r[e++]) >= 0)) throw Error("Invalid block size");
            if (le === 0) break;
            e += le;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + r[e - 1].toString(16));
      }
      break;
    case 44:
      var $ = r[e++] | r[e++] << 8, G = r[e++] | r[e++] << 8, te = r[e++] | r[e++] << 8, Z = r[e++] | r[e++] << 8, H = r[e++], J = H >> 6 & 1, re = 1 << 1 + (7 & H), be = o, pe = d, oe = !1;
      H >> 7 && (oe = !0, be = e, pe = re, e += 3 * re);
      var Ee = e;
      for (e++; ; ) {
        var le;
        if (!((le = r[e++]) >= 0)) throw Error("Invalid block size");
        if (le === 0) break;
        e += le;
      }
      y.push({ x: $, y: G, width: te, height: Z, has_local_palette: oe, palette_offset: be, palette_size: pe, data_offset: Ee, data_length: e - Ee, transparent_index: P, interlaced: !!J, delay: T, disposal: I });
      break;
    case 59:
      m = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + r[e - 1].toString(16));
  }
  this.numFrames = function() {
    return y.length;
  }, this.loopCount = function() {
    return D;
  }, this.frameInfo = function(_e) {
    if (_e < 0 || _e >= y.length) throw new Error("Frame index out of range.");
    return y[_e];
  }, this.decodeAndBlitFrameBGRA = function(_e, Ve) {
    var Be = this.frameInfo(_e), gt = Be.width * Be.height, St = new Uint8Array(gt);
    DC(r, Be.data_offset, St, gt);
    var Mt = Be.palette_offset, mt = Be.transparent_index;
    mt === null && (mt = 256);
    var wt = Be.width, Yt = t - wt, Dt = wt, fe = 4 * (Be.y * t + Be.x), De = 4 * ((Be.y + Be.height) * t + Be.x), je = fe, Ke = 4 * Yt;
    Be.interlaced === !0 && (Ke += 4 * t * 7);
    for (var rt = 8, at = 0, Et = St.length; at < Et; ++at) {
      var Tt = St[at];
      if (Dt === 0 && (Dt = wt, (je += Ke) >= De && (Ke = 4 * Yt + 4 * t * (rt - 1), je = fe + (wt + Yt) * (rt << 1), rt >>= 1)), Tt === mt) je += 4;
      else {
        var Vt = r[Mt + 3 * Tt], tr = r[Mt + 3 * Tt + 1], ur = r[Mt + 3 * Tt + 2];
        Ve[je++] = ur, Ve[je++] = tr, Ve[je++] = Vt, Ve[je++] = 255;
      }
      --Dt;
    }
  }, this.decodeAndBlitFrameRGBA = function(_e, Ve) {
    var Be = this.frameInfo(_e), gt = Be.width * Be.height, St = new Uint8Array(gt);
    DC(r, Be.data_offset, St, gt);
    var Mt = Be.palette_offset, mt = Be.transparent_index;
    mt === null && (mt = 256);
    var wt = Be.width, Yt = t - wt, Dt = wt, fe = 4 * (Be.y * t + Be.x), De = 4 * ((Be.y + Be.height) * t + Be.x), je = fe, Ke = 4 * Yt;
    Be.interlaced === !0 && (Ke += 4 * t * 7);
    for (var rt = 8, at = 0, Et = St.length; at < Et; ++at) {
      var Tt = St[at];
      if (Dt === 0 && (Dt = wt, (je += Ke) >= De && (Ke = 4 * Yt + 4 * t * (rt - 1), je = fe + (wt + Yt) * (rt << 1), rt >>= 1)), Tt === mt) je += 4;
      else {
        var Vt = r[Mt + 3 * Tt], tr = r[Mt + 3 * Tt + 1], ur = r[Mt + 3 * Tt + 2];
        Ve[je++] = Vt, Ve[je++] = tr, Ve[je++] = ur, Ve[je++] = 255;
      }
      --Dt;
    }
  };
}
function DC(r, e, t, i) {
  for (var n = r[e++], s = 1 << n, c = s + 1, o = c + 1, d = n + 1, m = (1 << d) - 1, y = 0, T = 0, P = 0, I = r[e++], D = new Int32Array(4096), k = null; ; ) {
    for (; y < 16 && I !== 0; ) T |= r[e++] << y, y += 8, I === 1 ? I = r[e++] : --I;
    if (y < d) break;
    var $ = T & m;
    if (T >>= d, y -= d, $ !== s) {
      if ($ === c) break;
      for (var G = $ < o ? $ : k, te = 0, Z = G; Z > s; ) Z = D[Z] >> 8, ++te;
      var H = Z;
      if (P + te + (G !== $ ? 1 : 0) > i) return void An.log("Warning, gif stream longer than expected.");
      t[P++] = H;
      var J = P += te;
      for (G !== $ && (t[P++] = H), Z = G; te--; ) Z = D[Z], t[--J] = 255 & Z, Z >>= 8;
      k !== null && o < 4096 && (D[o++] = k << 8 | H, o >= m + 1 && d < 12 && (++d, m = m << 1 | 1)), k = $;
    } else o = c + 1, m = (1 << (d = n + 1)) - 1, k = null;
  }
  return P !== i && An.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function U1(r) {
  var e, t, i, n, s, c = Math.floor, o = new Array(64), d = new Array(64), m = new Array(64), y = new Array(64), T = new Array(65535), P = new Array(65535), I = new Array(64), D = new Array(64), k = [], $ = 0, G = 7, te = new Array(64), Z = new Array(64), H = new Array(64), J = new Array(256), re = new Array(2048), be = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], pe = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], oe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Ee = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], le = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], _e = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Ve = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Be = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], gt = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function St(fe, De) {
    for (var je = 0, Ke = 0, rt = new Array(), at = 1; at <= 16; at++) {
      for (var Et = 1; Et <= fe[at]; Et++) rt[De[Ke]] = [], rt[De[Ke]][0] = je, rt[De[Ke]][1] = at, Ke++, je++;
      je *= 2;
    }
    return rt;
  }
  function Mt(fe) {
    for (var De = fe[0], je = fe[1] - 1; je >= 0; ) De & 1 << je && ($ |= 1 << G), je--, --G < 0 && ($ == 255 ? (mt(255), mt(0)) : mt($), G = 7, $ = 0);
  }
  function mt(fe) {
    k.push(fe);
  }
  function wt(fe) {
    mt(fe >> 8 & 255), mt(255 & fe);
  }
  function Yt(fe, De, je, Ke, rt) {
    for (var at, Et = rt[0], Tt = rt[240], Vt = function(Jt, Sr) {
      var hr, qr, xr, bi, Yr, Fr, Ri, Kr, wr, Ue, K = 0;
      for (wr = 0; wr < 8; ++wr) {
        hr = Jt[K], qr = Jt[K + 1], xr = Jt[K + 2], bi = Jt[K + 3], Yr = Jt[K + 4], Fr = Jt[K + 5], Ri = Jt[K + 6];
        var ne = hr + (Kr = Jt[K + 7]), de = hr - Kr, Te = qr + Ri, Pe = qr - Ri, qe = xr + Fr, Je = xr - Fr, He = bi + Yr, nt = bi - Yr, Bt = ne + He, It = ne - He, rr = Te + qe, We = Te - qe;
        Jt[K] = Bt + rr, Jt[K + 4] = Bt - rr;
        var mr = 0.707106781 * (We + It);
        Jt[K + 2] = It + mr, Jt[K + 6] = It - mr;
        var Li = 0.382683433 * ((Bt = nt + Je) - (We = Pe + de)), fr = 0.5411961 * Bt + Li, Hr = 1.306562965 * We + Li, li = 0.707106781 * (rr = Je + Pe), _r = de + li, qi = de - li;
        Jt[K + 5] = qi + fr, Jt[K + 3] = qi - fr, Jt[K + 1] = _r + Hr, Jt[K + 7] = _r - Hr, K += 8;
      }
      for (K = 0, wr = 0; wr < 8; ++wr) {
        hr = Jt[K], qr = Jt[K + 8], xr = Jt[K + 16], bi = Jt[K + 24], Yr = Jt[K + 32], Fr = Jt[K + 40], Ri = Jt[K + 48];
        var nn = hr + (Kr = Jt[K + 56]), Ei = hr - Kr, vi = qr + Ri, ci = qr - Ri, Lt = xr + Fr, pi = xr - Fr, Rn = bi + Yr, eo = bi - Yr, sn = nn + Rn, Xt = nn - Rn, Dr = vi + Lt, zr = vi - Lt;
        Jt[K] = sn + Dr, Jt[K + 32] = sn - Dr;
        var bn = 0.707106781 * (zr + Xt);
        Jt[K + 16] = Xt + bn, Jt[K + 48] = Xt - bn;
        var qo = 0.382683433 * ((sn = eo + pi) - (zr = ci + Ei)), Qn = 0.5411961 * sn + qo, Nr = 1.306562965 * zr + qo, wo = 0.707106781 * (Dr = pi + ci), Wo = Ei + wo, Xo = Ei - wo;
        Jt[K + 40] = Xo + Qn, Jt[K + 24] = Xo - Qn, Jt[K + 8] = Wo + Nr, Jt[K + 56] = Wo - Nr, K++;
      }
      for (wr = 0; wr < 64; ++wr) Ue = Jt[wr] * Sr[wr], I[wr] = Ue > 0 ? Ue + 0.5 | 0 : Ue - 0.5 | 0;
      return I;
    }(fe, De), tr = 0; tr < 64; ++tr) D[be[tr]] = Vt[tr];
    var ur = D[0] - je;
    je = D[0], ur == 0 ? Mt(Ke[0]) : (Mt(Ke[P[at = 32767 + ur]]), Mt(T[at]));
    for (var dr = 63; dr > 0 && D[dr] == 0; ) dr--;
    if (dr == 0) return Mt(Et), je;
    for (var Ct, Oe = 1; Oe <= dr; ) {
      for (var ii = Oe; D[Oe] == 0 && Oe <= dr; ) ++Oe;
      var Zr = Oe - ii;
      if (Zr >= 16) {
        Ct = Zr >> 4;
        for (var Rr = 1; Rr <= Ct; ++Rr) Mt(Tt);
        Zr &= 15;
      }
      at = 32767 + D[Oe], Mt(rt[(Zr << 4) + P[at]]), Mt(T[at]), Oe++;
    }
    return dr != 63 && Mt(Et), je;
  }
  function Dt(fe) {
    fe = Math.min(Math.max(fe, 1), 100), s != fe && (function(De) {
      for (var je = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Ke = 0; Ke < 64; Ke++) {
        var rt = c((je[Ke] * De + 50) / 100);
        rt = Math.min(Math.max(rt, 1), 255), o[be[Ke]] = rt;
      }
      for (var at = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], Et = 0; Et < 64; Et++) {
        var Tt = c((at[Et] * De + 50) / 100);
        Tt = Math.min(Math.max(Tt, 1), 255), d[be[Et]] = Tt;
      }
      for (var Vt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], tr = 0, ur = 0; ur < 8; ur++) for (var dr = 0; dr < 8; dr++) m[tr] = 1 / (o[be[tr]] * Vt[ur] * Vt[dr] * 8), y[tr] = 1 / (d[be[tr]] * Vt[ur] * Vt[dr] * 8), tr++;
    }(fe < 50 ? Math.floor(5e3 / fe) : Math.floor(200 - 2 * fe)), s = fe);
  }
  this.encode = function(fe, De) {
    De && Dt(De), k = new Array(), $ = 0, G = 7, wt(65496), wt(65504), wt(16), mt(74), mt(70), mt(73), mt(70), mt(0), mt(1), mt(1), mt(0), wt(1), wt(1), mt(0), mt(0), function() {
      wt(65499), wt(132), mt(0);
      for (var qr = 0; qr < 64; qr++) mt(o[qr]);
      mt(1);
      for (var xr = 0; xr < 64; xr++) mt(d[xr]);
    }(), function(qr, xr) {
      wt(65472), wt(17), mt(8), wt(xr), wt(qr), mt(3), mt(1), mt(17), mt(0), mt(2), mt(17), mt(1), mt(3), mt(17), mt(1);
    }(fe.width, fe.height), function() {
      wt(65476), wt(418), mt(0);
      for (var qr = 0; qr < 16; qr++) mt(pe[qr + 1]);
      for (var xr = 0; xr <= 11; xr++) mt(oe[xr]);
      mt(16);
      for (var bi = 0; bi < 16; bi++) mt(Ee[bi + 1]);
      for (var Yr = 0; Yr <= 161; Yr++) mt(le[Yr]);
      mt(1);
      for (var Fr = 0; Fr < 16; Fr++) mt(_e[Fr + 1]);
      for (var Ri = 0; Ri <= 11; Ri++) mt(Ve[Ri]);
      mt(17);
      for (var Kr = 0; Kr < 16; Kr++) mt(Be[Kr + 1]);
      for (var wr = 0; wr <= 161; wr++) mt(gt[wr]);
    }(), wt(65498), wt(12), mt(3), mt(1), mt(0), mt(2), mt(17), mt(3), mt(17), mt(0), mt(63), mt(0);
    var je = 0, Ke = 0, rt = 0;
    $ = 0, G = 7, this.encode.displayName = "_encode_";
    for (var at, Et, Tt, Vt, tr, ur, dr, Ct, Oe, ii = fe.data, Zr = fe.width, Rr = fe.height, Jt = 4 * Zr, Sr = 0; Sr < Rr; ) {
      for (at = 0; at < Jt; ) {
        for (tr = Jt * Sr + at, dr = -1, Ct = 0, Oe = 0; Oe < 64; Oe++) ur = tr + (Ct = Oe >> 3) * Jt + (dr = 4 * (7 & Oe)), Sr + Ct >= Rr && (ur -= Jt * (Sr + 1 + Ct - Rr)), at + dr >= Jt && (ur -= at + dr - Jt + 4), Et = ii[ur++], Tt = ii[ur++], Vt = ii[ur++], te[Oe] = (re[Et] + re[Tt + 256 | 0] + re[Vt + 512 | 0] >> 16) - 128, Z[Oe] = (re[Et + 768 | 0] + re[Tt + 1024 | 0] + re[Vt + 1280 | 0] >> 16) - 128, H[Oe] = (re[Et + 1280 | 0] + re[Tt + 1536 | 0] + re[Vt + 1792 | 0] >> 16) - 128;
        je = Yt(te, m, je, e, i), Ke = Yt(Z, y, Ke, t, n), rt = Yt(H, y, rt, t, n), at += 32;
      }
      Sr += 8;
    }
    if (G >= 0) {
      var hr = [];
      hr[1] = G + 1, hr[0] = (1 << G + 1) - 1, Mt(hr);
    }
    return wt(65497), new Uint8Array(k);
  }, r = r || 50, function() {
    for (var fe = String.fromCharCode, De = 0; De < 256; De++) J[De] = fe(De);
  }(), e = St(pe, oe), t = St(_e, Ve), i = St(Ee, le), n = St(Be, gt), function() {
    for (var fe = 1, De = 2, je = 1; je <= 15; je++) {
      for (var Ke = fe; Ke < De; Ke++) P[32767 + Ke] = je, T[32767 + Ke] = [], T[32767 + Ke][1] = je, T[32767 + Ke][0] = Ke;
      for (var rt = -(De - 1); rt <= -fe; rt++) P[32767 + rt] = je, T[32767 + rt] = [], T[32767 + rt][1] = je, T[32767 + rt][0] = De - 1 + rt;
      fe <<= 1, De <<= 1;
    }
  }(), function() {
    for (var fe = 0; fe < 256; fe++) re[fe] = 19595 * fe, re[fe + 256 | 0] = 38470 * fe, re[fe + 512 | 0] = 7471 * fe + 32768, re[fe + 768 | 0] = -11059 * fe, re[fe + 1024 | 0] = -21709 * fe, re[fe + 1280 | 0] = 32768 * fe + 8421375, re[fe + 1536 | 0] = -27439 * fe, re[fe + 1792 | 0] = -5329 * fe;
  }(), Dt(r);
}
/**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function fc(r, e) {
  if (this.pos = 0, this.buffer = r, this.datav = new DataView(r.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function NC(r) {
  function e(oe) {
    if (!oe) throw Error("assert :P");
  }
  function t(oe, Ee, le) {
    for (var _e = 0; 4 > _e; _e++) if (oe[Ee + _e] != le.charCodeAt(_e)) return !0;
    return !1;
  }
  function i(oe, Ee, le, _e, Ve) {
    for (var Be = 0; Be < Ve; Be++) oe[Ee + Be] = le[_e + Be];
  }
  function n(oe, Ee, le, _e) {
    for (var Ve = 0; Ve < _e; Ve++) oe[Ee + Ve] = le;
  }
  function s(oe) {
    return new Int32Array(oe);
  }
  function c(oe, Ee) {
    for (var le = [], _e = 0; _e < oe; _e++) le.push(new Ee());
    return le;
  }
  function o(oe, Ee) {
    var le = [];
    return function _e(Ve, Be, gt) {
      for (var St = gt[Be], Mt = 0; Mt < St && (Ve.push(gt.length > Be + 1 ? [] : new Ee()), !(gt.length < Be + 1)); Mt++) _e(Ve[Mt], Be + 1, gt);
    }(le, 0, oe), le;
  }
  var d = function() {
    var oe = this;
    function Ee(C, L) {
      for (var z = 1 << L - 1 >>> 0; C & z; ) z >>>= 1;
      return z ? (C & z - 1) + z : C;
    }
    function le(C, L, z, W, ae) {
      e(!(W % z));
      do
        C[L + (W -= z)] = ae;
      while (0 < W);
    }
    function _e(C, L, z, W, ae) {
      if (e(2328 >= ae), 512 >= ae) var he = s(512);
      else if ((he = s(ae)) == null) return 0;
      return function(ge, ye, xe, me, et, bt) {
        var ke, st, ht = ye, kt = 1 << xe, tt = s(16), Ot = s(16);
        for (e(et != 0), e(me != null), e(ge != null), e(0 < xe), st = 0; st < et; ++st) {
          if (15 < me[st]) return 0;
          ++tt[me[st]];
        }
        if (tt[0] == et) return 0;
        for (Ot[1] = 0, ke = 1; 15 > ke; ++ke) {
          if (tt[ke] > 1 << ke) return 0;
          Ot[ke + 1] = Ot[ke] + tt[ke];
        }
        for (st = 0; st < et; ++st) ke = me[st], 0 < me[st] && (bt[Ot[ke]++] = st);
        if (Ot[15] == 1) return (me = new Ve()).g = 0, me.value = bt[0], le(ge, ht, 1, kt, me), kt;
        var jt, Kt = -1, Wt = kt - 1, Br = 0, yr = 1, si = 1, Tr = 1 << xe;
        for (st = 0, ke = 1, et = 2; ke <= xe; ++ke, et <<= 1) {
          if (yr += si <<= 1, 0 > (si -= tt[ke])) return 0;
          for (; 0 < tt[ke]; --tt[ke]) (me = new Ve()).g = ke, me.value = bt[st++], le(ge, ht + Br, et, Tr, me), Br = Ee(Br, ke);
        }
        for (ke = xe + 1, et = 2; 15 >= ke; ++ke, et <<= 1) {
          if (yr += si <<= 1, 0 > (si -= tt[ke])) return 0;
          for (; 0 < tt[ke]; --tt[ke]) {
            if (me = new Ve(), (Br & Wt) != Kt) {
              for (ht += Tr, jt = 1 << (Kt = ke) - xe; 15 > Kt && !(0 >= (jt -= tt[Kt])); ) ++Kt, jt <<= 1;
              kt += Tr = 1 << (jt = Kt - xe), ge[ye + (Kt = Br & Wt)].g = jt + xe, ge[ye + Kt].value = ht - ye - Kt;
            }
            me.g = ke - xe, me.value = bt[st++], le(ge, ht + (Br >> xe), et, Tr, me), Br = Ee(Br, ke);
          }
        }
        return yr != 2 * Ot[15] - 1 ? 0 : kt;
      }(C, L, z, W, ae, he);
    }
    function Ve() {
      this.value = this.g = 0;
    }
    function Be() {
      this.value = this.g = 0;
    }
    function gt() {
      this.G = c(5, Ve), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = c(Wn, Be);
    }
    function St(C, L, z, W) {
      e(C != null), e(L != null), e(2147483648 > W), C.Ca = 254, C.I = 0, C.b = -8, C.Ka = 0, C.oa = L, C.pa = z, C.Jd = L, C.Yc = z + W, C.Zc = 4 <= W ? z + W - 4 + 1 : z, Et(C);
    }
    function Mt(C, L) {
      for (var z = 0; 0 < L--; ) z |= Vt(C, 128) << L;
      return z;
    }
    function mt(C, L) {
      var z = Mt(C, L);
      return Tt(C) ? -z : z;
    }
    function wt(C, L, z, W) {
      var ae, he = 0;
      for (e(C != null), e(L != null), e(4294967288 > W), C.Sb = W, C.Ra = 0, C.u = 0, C.h = 0, 4 < W && (W = 4), ae = 0; ae < W; ++ae) he += L[z + ae] << 8 * ae;
      C.Ra = he, C.bb = W, C.oa = L, C.pa = z;
    }
    function Yt(C) {
      for (; 8 <= C.u && C.bb < C.Sb; ) C.Ra >>>= 8, C.Ra += C.oa[C.pa + C.bb] << Io - 8 >>> 0, ++C.bb, C.u -= 8;
      Ke(C) && (C.h = 1, C.u = 0);
    }
    function Dt(C, L) {
      if (e(0 <= L), !C.h && L <= Uc) {
        var z = je(C) & Va[L];
        return C.u += L, Yt(C), z;
      }
      return C.h = 1, C.u = 0;
    }
    function fe() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function De() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function je(C) {
      return C.Ra >>> (C.u & Io - 1) >>> 0;
    }
    function Ke(C) {
      return e(C.bb <= C.Sb), C.h || C.bb == C.Sb && C.u > Io;
    }
    function rt(C, L) {
      C.u = L, C.h = Ke(C);
    }
    function at(C) {
      C.u >= kn && (e(C.u >= kn), Yt(C));
    }
    function Et(C) {
      e(C != null && C.oa != null), C.pa < C.Zc ? (C.I = (C.oa[C.pa++] | C.I << 8) >>> 0, C.b += 8) : (e(C != null && C.oa != null), C.pa < C.Yc ? (C.b += 8, C.I = C.oa[C.pa++] | C.I << 8) : C.Ka ? C.b = 0 : (C.I <<= 8, C.b += 8, C.Ka = 1));
    }
    function Tt(C) {
      return Mt(C, 1);
    }
    function Vt(C, L) {
      var z = C.Ca;
      0 > C.b && Et(C);
      var W = C.b, ae = z * L >>> 8, he = (C.I >>> W > ae) + 0;
      for (he ? (z -= ae, C.I -= ae + 1 << W >>> 0) : z = ae + 1, W = z, ae = 0; 256 <= W; ) ae += 8, W >>= 8;
      return W = 7 ^ ae + yl[W], C.b -= W, C.Ca = (z << W) - 1, he;
    }
    function tr(C, L, z) {
      C[L + 0] = z >> 24 & 255, C[L + 1] = z >> 16 & 255, C[L + 2] = z >> 8 & 255, C[L + 3] = 255 & z;
    }
    function ur(C, L) {
      return C[L + 0] | C[L + 1] << 8;
    }
    function dr(C, L) {
      return ur(C, L) | C[L + 2] << 16;
    }
    function Ct(C, L) {
      return ur(C, L) | ur(C, L + 2) << 16;
    }
    function Oe(C, L) {
      var z = 1 << L;
      return e(C != null), e(0 < L), C.X = s(z), C.X == null ? 0 : (C.Mb = 32 - L, C.Xa = L, 1);
    }
    function ii(C, L) {
      e(C != null), e(L != null), e(C.Xa == L.Xa), i(L.X, 0, C.X, 0, 1 << L.Xa);
    }
    function Zr() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function Rr(C, L, z, W) {
      e(z != null), e(W != null);
      var ae = z[0], he = W[0];
      return ae == 0 && (ae = (C * he + L / 2) / L), he == 0 && (he = (L * ae + C / 2) / C), 0 >= ae || 0 >= he ? 0 : (z[0] = ae, W[0] = he, 1);
    }
    function Jt(C, L) {
      return C + (1 << L) - 1 >>> L;
    }
    function Sr(C, L) {
      return ((4278255360 & C) + (4278255360 & L) >>> 0 & 4278255360) + ((16711935 & C) + (16711935 & L) >>> 0 & 16711935) >>> 0;
    }
    function hr(C, L) {
      oe[L] = function(z, W, ae, he, ge, ye, xe) {
        var me;
        for (me = 0; me < ge; ++me) {
          var et = oe[C](ye[xe + me - 1], ae, he + me);
          ye[xe + me] = Sr(z[W + me], et);
        }
      };
    }
    function qr() {
      this.ud = this.hd = this.jd = 0;
    }
    function xr(C, L) {
      return ((4278124286 & (C ^ L)) >>> 1) + (C & L) >>> 0;
    }
    function bi(C) {
      return 0 <= C && 256 > C ? C : 0 > C ? 0 : 255 < C ? 255 : void 0;
    }
    function Yr(C, L) {
      return bi(C + (C - L + 0.5 >> 1));
    }
    function Fr(C, L, z) {
      return Math.abs(L - z) - Math.abs(C - z);
    }
    function Ri(C, L, z, W, ae, he, ge) {
      for (W = he[ge - 1], z = 0; z < ae; ++z) he[ge + z] = W = Sr(C[L + z], W);
    }
    function Kr(C, L, z, W, ae) {
      var he;
      for (he = 0; he < z; ++he) {
        var ge = C[L + he], ye = ge >> 8 & 255, xe = 16711935 & (xe = (xe = 16711935 & ge) + ((ye << 16) + ye));
        W[ae + he] = (4278255360 & ge) + xe >>> 0;
      }
    }
    function wr(C, L) {
      L.jd = 255 & C, L.hd = C >> 8 & 255, L.ud = C >> 16 & 255;
    }
    function Ue(C, L, z, W, ae, he) {
      var ge;
      for (ge = 0; ge < W; ++ge) {
        var ye = L[z + ge], xe = ye >>> 8, me = ye, et = 255 & (et = (et = ye >>> 16) + ((C.jd << 24 >> 24) * (xe << 24 >> 24) >>> 5));
        me = 255 & (me = (me += (C.hd << 24 >> 24) * (xe << 24 >> 24) >>> 5) + ((C.ud << 24 >> 24) * (et << 24 >> 24) >>> 5)), ae[he + ge] = (4278255360 & ye) + (et << 16) + me;
      }
    }
    function K(C, L, z, W, ae) {
      oe[L] = function(he, ge, ye, xe, me, et, bt, ke, st) {
        for (xe = bt; xe < ke; ++xe) for (bt = 0; bt < st; ++bt) me[et++] = ae(ye[W(he[ge++])]);
      }, oe[C] = function(he, ge, ye, xe, me, et, bt) {
        var ke = 8 >> he.b, st = he.Ea, ht = he.K[0], kt = he.w;
        if (8 > ke) for (he = (1 << he.b) - 1, kt = (1 << ke) - 1; ge < ye; ++ge) {
          var tt, Ot = 0;
          for (tt = 0; tt < st; ++tt) tt & he || (Ot = W(xe[me++])), et[bt++] = ae(ht[Ot & kt]), Ot >>= ke;
        }
        else oe["VP8LMapColor" + z](xe, me, ht, kt, et, bt, ge, ye, st);
      };
    }
    function ne(C, L, z, W, ae) {
      for (z = L + z; L < z; ) {
        var he = C[L++];
        W[ae++] = he >> 16 & 255, W[ae++] = he >> 8 & 255, W[ae++] = 255 & he;
      }
    }
    function de(C, L, z, W, ae) {
      for (z = L + z; L < z; ) {
        var he = C[L++];
        W[ae++] = he >> 16 & 255, W[ae++] = he >> 8 & 255, W[ae++] = 255 & he, W[ae++] = he >> 24 & 255;
      }
    }
    function Te(C, L, z, W, ae) {
      for (z = L + z; L < z; ) {
        var he = (ge = C[L++]) >> 16 & 240 | ge >> 12 & 15, ge = 240 & ge | ge >> 28 & 15;
        W[ae++] = he, W[ae++] = ge;
      }
    }
    function Pe(C, L, z, W, ae) {
      for (z = L + z; L < z; ) {
        var he = (ge = C[L++]) >> 16 & 248 | ge >> 13 & 7, ge = ge >> 5 & 224 | ge >> 3 & 31;
        W[ae++] = he, W[ae++] = ge;
      }
    }
    function qe(C, L, z, W, ae) {
      for (z = L + z; L < z; ) {
        var he = C[L++];
        W[ae++] = 255 & he, W[ae++] = he >> 8 & 255, W[ae++] = he >> 16 & 255;
      }
    }
    function Je(C, L, z, W, ae, he) {
      if (he == 0) for (z = L + z; L < z; ) tr(W, ((he = C[L++])[0] >> 24 | he[1] >> 8 & 65280 | he[2] << 8 & 16711680 | he[3] << 24) >>> 0), ae += 32;
      else i(W, ae, C, L, z);
    }
    function He(C, L) {
      oe[L][0] = oe[C + "0"], oe[L][1] = oe[C + "1"], oe[L][2] = oe[C + "2"], oe[L][3] = oe[C + "3"], oe[L][4] = oe[C + "4"], oe[L][5] = oe[C + "5"], oe[L][6] = oe[C + "6"], oe[L][7] = oe[C + "7"], oe[L][8] = oe[C + "8"], oe[L][9] = oe[C + "9"], oe[L][10] = oe[C + "10"], oe[L][11] = oe[C + "11"], oe[L][12] = oe[C + "12"], oe[L][13] = oe[C + "13"], oe[L][14] = oe[C + "0"], oe[L][15] = oe[C + "0"];
    }
    function nt(C) {
      return C == $c || C == Hc || C == Jl || C == qc;
    }
    function Bt() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function It() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function rr() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Bt(), this.f.kb = new It(), this.sd = null;
    }
    function We() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function mr() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function Li(C) {
      return alert("todo:WebPSamplerProcessPlane"), C.T;
    }
    function fr(C, L) {
      var z = C.T, W = L.ba.f.RGBA, ae = W.eb, he = W.fb + C.ka * W.A, ge = $s[L.ba.S], ye = C.y, xe = C.O, me = C.f, et = C.N, bt = C.ea, ke = C.W, st = L.cc, ht = L.dc, kt = L.Mc, tt = L.Nc, Ot = C.ka, jt = C.ka + C.T, Kt = C.U, Wt = Kt + 1 >> 1;
      for (Ot == 0 ? ge(ye, xe, null, null, me, et, bt, ke, me, et, bt, ke, ae, he, null, null, Kt) : (ge(L.ec, L.fc, ye, xe, st, ht, kt, tt, me, et, bt, ke, ae, he - W.A, ae, he, Kt), ++z); Ot + 2 < jt; Ot += 2) st = me, ht = et, kt = bt, tt = ke, et += C.Rc, ke += C.Rc, he += 2 * W.A, ge(ye, (xe += 2 * C.fa) - C.fa, ye, xe, st, ht, kt, tt, me, et, bt, ke, ae, he - W.A, ae, he, Kt);
      return xe += C.fa, C.j + jt < C.o ? (i(L.ec, L.fc, ye, xe, Kt), i(L.cc, L.dc, me, et, Wt), i(L.Mc, L.Nc, bt, ke, Wt), z--) : 1 & jt || ge(ye, xe, null, null, me, et, bt, ke, me, et, bt, ke, ae, he + W.A, null, null, Kt), z;
    }
    function Hr(C, L, z) {
      var W = C.F, ae = [C.J];
      if (W != null) {
        var he = C.U, ge = L.ba.S, ye = ge == Du || ge == Jl;
        L = L.ba.f.RGBA;
        var xe = [0], me = C.ka;
        xe[0] = C.T, C.Kb && (me == 0 ? --xe[0] : (--me, ae[0] -= C.width), C.j + C.ka + C.T == C.o && (xe[0] = C.o - C.j - me));
        var et = L.eb;
        me = L.fb + me * L.A, C = Al(W, ae[0], C.width, he, xe, et, me + (ye ? 0 : 3), L.A), e(z == xe), C && nt(ge) && Vc(et, me, ye, he, xe, L.A);
      }
      return 0;
    }
    function li(C) {
      var L = C.ma, z = L.ba.S, W = 11 > z, ae = z == dh || z == Sl || z == Du || z == nf || z == 12 || nt(z);
      if (L.memory = null, L.Ib = null, L.Jb = null, L.Nd = null, !zs(L.Oa, C, ae ? 11 : 12)) return 0;
      if (ae && nt(z) && gl(), C.da) alert("todo:use_scaling");
      else {
        if (W) {
          if (L.Ib = Li, C.Kb) {
            if (z = C.U + 1 >> 1, L.memory = s(C.U + 2 * z), L.memory == null) return 0;
            L.ec = L.memory, L.fc = 0, L.cc = L.ec, L.dc = L.fc + C.U, L.Mc = L.cc, L.Nc = L.dc + z, L.Ib = fr, gl();
          }
        } else alert("todo:EmitYUV");
        ae && (L.Jb = Hr, W && Eo());
      }
      if (W && !ff) {
        for (C = 0; 256 > C; ++C) md[C] = 89858 * (C - 128) + Vu >> Yc, bd[C] = -22014 * (C - 128) + Vu, yd[C] = -45773 * (C - 128), _d[C] = 113618 * (C - 128) + Vu >> Yc;
        for (C = tc; C < xa; ++C) L = 76283 * (C - 16) + Vu >> Yc, vd[C - tc] = ts(L, 255), Kc[C - tc] = ts(L + 8 >> 4, 15);
        ff = 1;
      }
      return 1;
    }
    function _r(C) {
      var L = C.ma, z = C.U, W = C.T;
      return e(!(1 & C.ka)), 0 >= z || 0 >= W ? 0 : (z = L.Ib(C, L), L.Jb != null && L.Jb(C, L, z), L.Dc += z, 1);
    }
    function qi(C) {
      C.ma.memory = null;
    }
    function nn(C, L, z, W) {
      return Dt(C, 8) != 47 ? 0 : (L[0] = Dt(C, 14) + 1, z[0] = Dt(C, 14) + 1, W[0] = Dt(C, 1), Dt(C, 3) != 0 ? 0 : !C.h);
    }
    function Ei(C, L) {
      if (4 > C) return C + 1;
      var z = C - 2 >> 1;
      return (2 + (1 & C) << z) + Dt(L, z) + 1;
    }
    function vi(C, L) {
      return 120 < L ? L - 120 : 1 <= (z = ((z = gh[L - 1]) >> 4) * C + (8 - (15 & z))) ? z : 1;
      var z;
    }
    function ci(C, L, z) {
      var W = je(z), ae = C[L += 255 & W].g - 8;
      return 0 < ae && (rt(z, z.u + 8), W = je(z), L += C[L].value, L += W & (1 << ae) - 1), rt(z, z.u + C[L].g), C[L].value;
    }
    function Lt(C, L, z) {
      return z.g += C.g, z.value += C.value << L >>> 0, e(8 >= z.g), C.g;
    }
    function pi(C, L, z) {
      var W = C.xc;
      return e((L = W == 0 ? 0 : C.vc[C.md * (z >> W) + (L >> W)]) < C.Wb), C.Ya[L];
    }
    function Rn(C, L, z, W) {
      var ae = C.ab, he = C.c * L, ge = C.C;
      L = ge + L;
      var ye = z, xe = W;
      for (W = C.Ta, z = C.Ua; 0 < ae--; ) {
        var me = C.gc[ae], et = ge, bt = L, ke = ye, st = xe, ht = (xe = W, ye = z, me.Ea);
        switch (e(et < bt), e(bt <= me.nc), me.hc) {
          case 2:
            ql(ke, st, (bt - et) * ht, xe, ye);
            break;
          case 0:
            var kt = et, tt = bt, Ot = xe, jt = ye, Kt = (Tr = me).Ea;
            kt == 0 && (sa(ke, st, null, null, 1, Ot, jt), Ri(ke, st + 1, 0, 0, Kt - 1, Ot, jt + 1), st += Kt, jt += Kt, ++kt);
            for (var Wt = 1 << Tr.b, Br = Wt - 1, yr = Jt(Kt, Tr.b), si = Tr.K, Tr = Tr.w + (kt >> Tr.b) * yr; kt < tt; ) {
              var xi = si, zn = Tr, ui = 1;
              for (ma(ke, st, Ot, jt - Kt, 1, Ot, jt); ui < Kt; ) {
                var Pr = (ui & ~Br) + Wt;
                Pr > Kt && (Pr = Kt), (0, _a[xi[zn++] >> 8 & 15])(ke, st + +ui, Ot, jt + ui - Kt, Pr - ui, Ot, jt + ui), ui = Pr;
              }
              st += Kt, jt += Kt, ++kt & Br || (Tr += yr);
            }
            bt != me.nc && i(xe, ye - ht, xe, ye + (bt - et - 1) * ht, ht);
            break;
          case 1:
            for (ht = ke, tt = st, Kt = (ke = me.Ea) - (jt = ke & ~(Ot = (st = 1 << me.b) - 1)), kt = Jt(ke, me.b), Wt = me.K, me = me.w + (et >> me.b) * kt; et < bt; ) {
              for (Br = Wt, yr = me, si = new qr(), Tr = tt + jt, xi = tt + ke; tt < Tr; ) wr(Br[yr++], si), rs(si, ht, tt, st, xe, ye), tt += st, ye += st;
              tt < xi && (wr(Br[yr++], si), rs(si, ht, tt, Kt, xe, ye), tt += Kt, ye += Kt), ++et & Ot || (me += kt);
            }
            break;
          case 3:
            if (ke == xe && st == ye && 0 < me.b) {
              for (tt = xe, ke = ht = ye + (bt - et) * ht - (jt = (bt - et) * Jt(me.Ea, me.b)), st = xe, Ot = ye, kt = [], jt = (Kt = jt) - 1; 0 <= jt; --jt) kt[jt] = st[Ot + jt];
              for (jt = Kt - 1; 0 <= jt; --jt) tt[ke + jt] = kt[jt];
              Wl(me, et, bt, xe, ht, xe, ye);
            } else Wl(me, et, bt, ke, st, xe, ye);
        }
        ye = W, xe = z;
      }
      xe != z && i(W, z, ye, xe, he);
    }
    function eo(C, L) {
      var z = C.V, W = C.Ba + C.c * C.C, ae = L - C.C;
      if (e(L <= C.l.o), e(16 >= ae), 0 < ae) {
        var he = C.l, ge = C.Ta, ye = C.Ua, xe = he.width;
        if (Rn(C, ae, z, W), ae = ye = [ye], e((z = C.C) < (W = L)), e(he.v < he.va), W > he.o && (W = he.o), z < he.j) {
          var me = he.j - z;
          z = he.j, ae[0] += me * xe;
        }
        if (z >= W ? z = 0 : (ae[0] += 4 * he.v, he.ka = z - he.j, he.U = he.va - he.v, he.T = W - z, z = 1), z) {
          if (ye = ye[0], 11 > (z = C.ca).S) {
            var et = z.f.RGBA, bt = (W = z.S, ae = he.U, he = he.T, me = et.eb, et.A), ke = he;
            for (et = et.fb + C.Ma * et.A; 0 < ke--; ) {
              var st = ge, ht = ye, kt = ae, tt = me, Ot = et;
              switch (W) {
                case $a:
                  Xl(st, ht, kt, tt, Ot);
                  break;
                case dh:
                  Vs(st, ht, kt, tt, Ot);
                  break;
                case $c:
                  Vs(st, ht, kt, tt, Ot), Vc(tt, Ot, 0, kt, 1, 0);
                  break;
                case rf:
                  Lr(st, ht, kt, tt, Ot);
                  break;
                case Sl:
                  Je(st, ht, kt, tt, Ot, 1);
                  break;
                case Hc:
                  Je(st, ht, kt, tt, Ot, 1), Vc(tt, Ot, 0, kt, 1, 0);
                  break;
                case Du:
                  Je(st, ht, kt, tt, Ot, 0);
                  break;
                case Jl:
                  Je(st, ht, kt, tt, Ot, 0), Vc(tt, Ot, 1, kt, 1, 0);
                  break;
                case nf:
                  Po(st, ht, kt, tt, Ot);
                  break;
                case qc:
                  Po(st, ht, kt, tt, Ot), fh(tt, Ot, kt, 1, 0);
                  break;
                case sf:
                  Wi(st, ht, kt, tt, Ot);
                  break;
                default:
                  e(0);
              }
              ye += xe, et += bt;
            }
            C.Ma += he;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(C.Ma <= z.height);
        }
      }
      C.C = L, e(C.C <= C.i);
    }
    function sn(C) {
      var L;
      if (0 < C.ua) return 0;
      for (L = 0; L < C.Wb; ++L) {
        var z = C.Ya[L].G, W = C.Ya[L].H;
        if (0 < z[1][W[1] + 0].g || 0 < z[2][W[2] + 0].g || 0 < z[3][W[3] + 0].g) return 0;
      }
      return 1;
    }
    function Xt(C, L, z, W, ae, he) {
      if (C.Z != 0) {
        var ge = C.qd, ye = C.rd;
        for (e(va[C.Z] != null); L < z; ++L) va[C.Z](ge, ye, W, ae, W, ae, he), ge = W, ye = ae, ae += he;
        C.qd = ge, C.rd = ye;
      }
    }
    function Dr(C, L) {
      var z = C.l.ma, W = z.Z == 0 || z.Z == 1 ? C.l.j : C.C;
      if (W = C.C < W ? W : C.C, e(L <= C.l.o), L > W) {
        var ae = C.l.width, he = z.ca, ge = z.tb + ae * W, ye = C.V, xe = C.Ba + C.c * W, me = C.gc;
        e(C.ab == 1), e(me[0].hc == 3), vl(me[0], W, L, ye, xe, he, ge), Xt(z, W, L, he, ge, ae);
      }
      C.C = C.Ma = L;
    }
    function zr(C, L, z, W, ae, he, ge) {
      var ye = C.$ / W, xe = C.$ % W, me = C.m, et = C.s, bt = z + C.$, ke = bt;
      ae = z + W * ae;
      var st = z + W * he, ht = 280 + et.ua, kt = C.Pb ? ye : 16777216, tt = 0 < et.ua ? et.Wa : null, Ot = et.wc, jt = bt < st ? pi(et, xe, ye) : null;
      e(C.C < he), e(st <= ae);
      var Kt = !1;
      e: for (; ; ) {
        for (; Kt || bt < st; ) {
          var Wt = 0;
          if (ye >= kt) {
            var Br = bt - z;
            e((kt = C).Pb), kt.wd = kt.m, kt.xd = Br, 0 < kt.s.ua && ii(kt.s.Wa, kt.s.vb), kt = ye + mh;
          }
          if (xe & Ot || (jt = pi(et, xe, ye)), e(jt != null), jt.Qb && (L[bt] = jt.qb, Kt = !0), !Kt) if (at(me), jt.jc) {
            Wt = me, Br = L;
            var yr = bt, si = jt.pd[je(Wt) & Wn - 1];
            e(jt.jc), 256 > si.g ? (rt(Wt, Wt.u + si.g), Br[yr] = si.value, Wt = 0) : (rt(Wt, Wt.u + si.g - 256), e(256 <= si.value), Wt = si.value), Wt == 0 && (Kt = !0);
          } else Wt = ci(jt.G[0], jt.H[0], me);
          if (me.h) break;
          if (Kt || 256 > Wt) {
            if (!Kt) if (jt.nd) L[bt] = (jt.qb | Wt << 8) >>> 0;
            else {
              if (at(me), Kt = ci(jt.G[1], jt.H[1], me), at(me), Br = ci(jt.G[2], jt.H[2], me), yr = ci(jt.G[3], jt.H[3], me), me.h) break;
              L[bt] = (yr << 24 | Kt << 16 | Wt << 8 | Br) >>> 0;
            }
            if (Kt = !1, ++bt, ++xe >= W && (xe = 0, ++ye, ge != null && ye <= he && !(ye % 16) && ge(C, ye), tt != null)) for (; ke < bt; ) Wt = L[ke++], tt.X[(506832829 * Wt & 4294967295) >>> tt.Mb] = Wt;
          } else if (280 > Wt) {
            if (Wt = Ei(Wt - 256, me), Br = ci(jt.G[4], jt.H[4], me), at(me), Br = vi(W, Br = Ei(Br, me)), me.h) break;
            if (bt - z < Br || ae - bt < Wt) break e;
            for (yr = 0; yr < Wt; ++yr) L[bt + yr] = L[bt + yr - Br];
            for (bt += Wt, xe += Wt; xe >= W; ) xe -= W, ++ye, ge != null && ye <= he && !(ye % 16) && ge(C, ye);
            if (e(bt <= ae), xe & Ot && (jt = pi(et, xe, ye)), tt != null) for (; ke < bt; ) Wt = L[ke++], tt.X[(506832829 * Wt & 4294967295) >>> tt.Mb] = Wt;
          } else {
            if (!(Wt < ht)) break e;
            for (Kt = Wt - 280, e(tt != null); ke < bt; ) Wt = L[ke++], tt.X[(506832829 * Wt & 4294967295) >>> tt.Mb] = Wt;
            Wt = bt, e(!(Kt >>> (Br = tt).Xa)), L[Wt] = Br.X[Kt], Kt = !0;
          }
          Kt || e(me.h == Ke(me));
        }
        if (C.Pb && me.h && bt < ae) e(C.m.h), C.a = 5, C.m = C.wd, C.$ = C.xd, 0 < C.s.ua && ii(C.s.vb, C.s.Wa);
        else {
          if (me.h) break e;
          ge?.(C, ye > he ? he : ye), C.a = 0, C.$ = bt - z;
        }
        return 1;
      }
      return C.a = 3, 0;
    }
    function bn(C) {
      e(C != null), C.vc = null, C.yc = null, C.Ya = null;
      var L = C.Wa;
      L != null && (L.X = null), C.vb = null, e(C != null);
    }
    function qo() {
      var C = new Fi();
      return C == null ? null : (C.a = 0, C.xb = yo, He("Predictor", "VP8LPredictors"), He("Predictor", "VP8LPredictors_C"), He("PredictorAdd", "VP8LPredictorsAdd"), He("PredictorAdd", "VP8LPredictorsAdd_C"), ql = Kr, rs = Ue, Xl = ne, Vs = de, Po = Te, Wi = Pe, Lr = qe, oe.VP8LMapColor32b = bl, oe.VP8LMapColor8b = xl, C);
    }
    function Qn(C, L, z, W, ae) {
      var he = 1, ge = [C], ye = [L], xe = W.m, me = W.s, et = null, bt = 0;
      e: for (; ; ) {
        if (z) for (; he && Dt(xe, 1); ) {
          var ke = ge, st = ye, ht = W, kt = 1, tt = ht.m, Ot = ht.gc[ht.ab], jt = Dt(tt, 2);
          if (ht.Oc & 1 << jt) he = 0;
          else {
            switch (ht.Oc |= 1 << jt, Ot.hc = jt, Ot.Ea = ke[0], Ot.nc = st[0], Ot.K = [null], ++ht.ab, e(4 >= ht.ab), jt) {
              case 0:
              case 1:
                Ot.b = Dt(tt, 3) + 2, kt = Qn(Jt(Ot.Ea, Ot.b), Jt(Ot.nc, Ot.b), 0, ht, Ot.K), Ot.K = Ot.K[0];
                break;
              case 3:
                var Kt, Wt = Dt(tt, 8) + 1, Br = 16 < Wt ? 0 : 4 < Wt ? 1 : 2 < Wt ? 2 : 3;
                if (ke[0] = Jt(Ot.Ea, Br), Ot.b = Br, Kt = kt = Qn(Wt, 1, 0, ht, Ot.K)) {
                  var yr, si = Wt, Tr = Ot, xi = 1 << (8 >> Tr.b), zn = s(xi);
                  if (zn == null) Kt = 0;
                  else {
                    var ui = Tr.K[0], Pr = Tr.w;
                    for (zn[0] = Tr.K[0][0], yr = 1; yr < 1 * si; ++yr) zn[yr] = Sr(ui[Pr + yr], zn[yr - 1]);
                    for (; yr < 4 * xi; ++yr) zn[yr] = 0;
                    Tr.K[0] = null, Tr.K[0] = zn, Kt = 1;
                  }
                }
                kt = Kt;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            he = kt;
          }
        }
        if (ge = ge[0], ye = ye[0], he && Dt(xe, 1) && !(he = 1 <= (bt = Dt(xe, 4)) && 11 >= bt)) {
          W.a = 3;
          break e;
        }
        var lr;
        if (lr = he) t: {
          var Wr, oi, _i, Vi = W, Xn = ge, ps = ye, fn = bt, Zn = z, dn = Vi.m, pn = Vi.s, Qt = [null], cr = 1, Zi = 0, Bi = Wc[fn];
          r: for (; ; ) {
            if (Zn && Dt(dn, 1)) {
              var On = Dt(dn, 3) + 2, ln = Jt(Xn, On), Cn = Jt(ps, On), gn = ln * Cn;
              if (!Qn(ln, Cn, 0, Vi, Qt)) break r;
              for (Qt = Qt[0], pn.xc = On, Wr = 0; Wr < gn; ++Wr) {
                var Gi = Qt[Wr] >> 8 & 65535;
                Qt[Wr] = Gi, Gi >= cr && (cr = Gi + 1);
              }
            }
            if (dn.h) break r;
            for (oi = 0; 5 > oi; ++oi) {
              var Yn = af[oi];
              !oi && 0 < fn && (Yn += 1 << fn), Zi < Yn && (Zi = Yn);
            }
            var is = c(cr * Bi, Ve), Hs = cr, gs = c(Hs, gt);
            if (gs == null) var wi = null;
            else e(65536 >= Hs), wi = gs;
            var Ai = s(Zi);
            if (wi == null || Ai == null || is == null) {
              Vi.a = 1;
              break r;
            }
            var no = is;
            for (Wr = _i = 0; Wr < cr; ++Wr) {
              var Di = wi[Wr], In = Di.G, so = Di.H, oa = 0, Ro = 1, wn = 0;
              for (oi = 0; 5 > oi; ++oi) {
                Yn = af[oi], In[oi] = no, so[oi] = _i, !oi && 0 < fn && (Yn += 1 << fn);
                n: {
                  var Qc, Cl = Yn, wa = Vi, rc = Ai, vh = no, ic = _i, Gu = 0, Aa = wa.m, xh = Dt(Aa, 1);
                  if (n(rc, 0, 0, Cl), xh) {
                    var wh = Dt(Aa, 1) + 1, v = Dt(Aa, 1), a = Dt(Aa, v == 0 ? 1 : 8);
                    rc[a] = 1, wh == 2 && (rc[a = Dt(Aa, 8)] = 1);
                    var f = 1;
                  } else {
                    var g = s(19), b = Dt(Aa, 4) + 4;
                    if (19 < b) {
                      wa.a = 3;
                      var w = 0;
                      break n;
                    }
                    for (Qc = 0; Qc < b; ++Qc) g[Fu[Qc]] = Dt(Aa, 3);
                    var S = void 0, R = void 0, B = wa, U = g, j = Cl, X = rc, q = 0, Q = B.m, ce = 8, we = c(128, Ve);
                    i: for (; _e(we, 0, 7, U, 19); ) {
                      if (Dt(Q, 1)) {
                        var Ae = 2 + 2 * Dt(Q, 3);
                        if ((S = 2 + Dt(Q, Ae)) > j) break i;
                      } else S = j;
                      for (R = 0; R < j && S--; ) {
                        at(Q);
                        var Se = we[0 + (127 & je(Q))];
                        rt(Q, Q.u + Se.g);
                        var Me = Se.value;
                        if (16 > Me) X[R++] = Me, Me != 0 && (ce = Me);
                        else {
                          var Ge = Me == 16, Le = Me - 16, $e = of[Le], Xe = Dt(Q, ph[Le]) + $e;
                          if (R + Xe > j) break i;
                          for (var Fe = Ge ? ce : 0; 0 < Xe--; ) X[R++] = Fe;
                        }
                      }
                      q = 1;
                      break i;
                    }
                    q || (B.a = 3), f = q;
                  }
                  (f = f && !Aa.h) && (Gu = _e(vh, ic, 8, rc, Cl)), f && Gu != 0 ? w = Gu : (wa.a = 3, w = 0);
                }
                if (w == 0) break r;
                if (Ro && Nu[oi] == 1 && (Ro = no[_i].g == 0), oa += no[_i].g, _i += w, 3 >= oi) {
                  var Qe, At = Ai[0];
                  for (Qe = 1; Qe < Yn; ++Qe) Ai[Qe] > At && (At = Ai[Qe]);
                  wn += At;
                }
              }
              if (Di.nd = Ro, Di.Qb = 0, Ro && (Di.qb = (In[3][so[3] + 0].value << 24 | In[1][so[1] + 0].value << 16 | In[2][so[2] + 0].value) >>> 0, oa == 0 && 256 > In[0][so[0] + 0].value && (Di.Qb = 1, Di.qb += In[0][so[0] + 0].value << 8)), Di.jc = !Di.Qb && 6 > wn, Di.jc) {
                var ft, dt = Di;
                for (ft = 0; ft < Wn; ++ft) {
                  var _t = ft, qt = dt.pd[_t], Zt = dt.G[0][dt.H[0] + _t];
                  256 <= Zt.value ? (qt.g = Zt.g + 256, qt.value = Zt.value) : (qt.g = 0, qt.value = 0, _t >>= Lt(Zt, 8, qt), _t >>= Lt(dt.G[1][dt.H[1] + _t], 16, qt), _t >>= Lt(dt.G[2][dt.H[2] + _t], 0, qt), Lt(dt.G[3][dt.H[3] + _t], 24, qt));
                }
              }
            }
            pn.vc = Qt, pn.Wb = cr, pn.Ya = wi, pn.yc = is, lr = 1;
            break t;
          }
          lr = 0;
        }
        if (!(he = lr)) {
          W.a = 3;
          break e;
        }
        if (0 < bt) {
          if (me.ua = 1 << bt, !Oe(me.Wa, bt)) {
            W.a = 1, he = 0;
            break e;
          }
        } else me.ua = 0;
        var zt = W, pr = ge, Vr = ye, Ti = zt.s, $i = Ti.xc;
        if (zt.c = pr, zt.i = Vr, Ti.md = Jt(pr, $i), Ti.wc = $i == 0 ? -1 : (1 << $i) - 1, z) {
          W.xb = Kl;
          break e;
        }
        if ((et = s(ge * ye)) == null) {
          W.a = 1, he = 0;
          break e;
        }
        he = (he = zr(W, et, 0, ge, ye, ye, null)) && !xe.h;
        break e;
      }
      return he ? (ae != null ? ae[0] = et : (e(et == null), e(z)), W.$ = 0, z || bn(me)) : bn(me), he;
    }
    function Nr(C, L) {
      var z = C.c * C.i, W = z + L + 16 * L;
      return e(C.c <= L), C.V = s(W), C.V == null ? (C.Ta = null, C.Ua = 0, C.a = 1, 0) : (C.Ta = C.V, C.Ua = C.Ba + z + L, 1);
    }
    function wo(C, L) {
      var z = C.C, W = L - z, ae = C.V, he = C.Ba + C.c * z;
      for (e(L <= C.l.o); 0 < W; ) {
        var ge = 16 < W ? 16 : W, ye = C.l.ma, xe = C.l.width, me = xe * ge, et = ye.ca, bt = ye.tb + xe * z, ke = C.Ta, st = C.Ua;
        Rn(C, ge, ae, he), Lu(ke, st, et, bt, me), Xt(ye, z, z + ge, et, bt, xe), W -= ge, ae += ge * C.c, z += ge;
      }
      e(z == L), C.C = C.Ma = L;
    }
    function Wo() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Xo() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Ul() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function Zo() {
      this.Yb = function() {
        var C = [];
        return function L(z, W, ae) {
          for (var he = ae[W], ge = 0; ge < he && (z.push(ae.length > W + 1 ? [] : 0), !(ae.length < W + 1)); ge++) L(z[ge], W + 1, ae);
        }(C, 0, [3, 11]), C;
      }();
    }
    function ol() {
      this.jb = s(3), this.Wc = o([4, 8], Zo), this.Xc = o([4, 17], Zo);
    }
    function Ao() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function Qi() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function ti() {
      this.Na = this.la = 0;
    }
    function ch() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function ha() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function fa() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Qi()), this.Y = 0, this.ya = Array(new ha()), this.aa = 0, this.l = new zl();
    }
    function Yo() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function Jo() {
      this.cb = this.a = 0, this.sc = "", this.m = new fe(), this.Od = new Wo(), this.Kc = new Xo(), this.ed = new Ao(), this.Qa = new Ul(), this.Ic = this.$c = this.Aa = 0, this.D = new fa(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = c(8, fe), this.ia = 0, this.pb = c(4, ch), this.Pa = new ol(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Yo()), this.Hd = 0, this.rb = Array(new ti()), this.sb = 0, this.wa = Array(new Qi()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new ha()), this.L = this.aa = 0, this.gd = o([4, 2], Qi), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function zl() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Tu() {
      var C = new Jo();
      return C != null && (C.a = 0, C.sc = "OK", C.cb = 0, C.Xb = 0, Uu || (Uu = La)), C;
    }
    function Ln(C, L, z) {
      return C.a == 0 && (C.a = L, C.sc = z, C.cb = 0), 0;
    }
    function da(C, L, z) {
      return 3 <= z && C[L + 0] == 157 && C[L + 1] == 1 && C[L + 2] == 42;
    }
    function Su(C, L) {
      if (C == null) return 0;
      if (C.a = 0, C.sc = "OK", L == null) return Ln(C, 2, "null VP8Io passed to VP8GetHeaders()");
      var z = L.data, W = L.w, ae = L.ha;
      if (4 > ae) return Ln(C, 7, "Truncated header.");
      var he = z[W + 0] | z[W + 1] << 8 | z[W + 2] << 16, ge = C.Od;
      if (ge.Rb = !(1 & he), ge.td = he >> 1 & 7, ge.yd = he >> 4 & 1, ge.ub = he >> 5, 3 < ge.td) return Ln(C, 3, "Incorrect keyframe parameters.");
      if (!ge.yd) return Ln(C, 4, "Frame not displayable.");
      W += 3, ae -= 3;
      var ye = C.Kc;
      if (ge.Rb) {
        if (7 > ae) return Ln(C, 7, "cannot parse picture header");
        if (!da(z, W, ae)) return Ln(C, 3, "Bad code word");
        ye.c = 16383 & (z[W + 4] << 8 | z[W + 3]), ye.Td = z[W + 4] >> 6, ye.i = 16383 & (z[W + 6] << 8 | z[W + 5]), ye.Ud = z[W + 6] >> 6, W += 7, ae -= 7, C.za = ye.c + 15 >> 4, C.Ub = ye.i + 15 >> 4, L.width = ye.c, L.height = ye.i, L.Da = 0, L.j = 0, L.v = 0, L.va = L.width, L.o = L.height, L.da = 0, L.ib = L.width, L.hb = L.height, L.U = L.width, L.T = L.height, n((he = C.Pa).jb, 0, 255, he.jb.length), e((he = C.Qa) != null), he.Cb = 0, he.Bb = 0, he.Fb = 1, n(he.Zb, 0, 0, he.Zb.length), n(he.Lb, 0, 0, he.Lb);
      }
      if (ge.ub > ae) return Ln(C, 7, "bad partition length");
      St(he = C.m, z, W, ge.ub), W += ge.ub, ae -= ge.ub, ge.Rb && (ye.Ld = Tt(he), ye.Kd = Tt(he)), ye = C.Qa;
      var xe, me = C.Pa;
      if (e(he != null), e(ye != null), ye.Cb = Tt(he), ye.Cb) {
        if (ye.Bb = Tt(he), Tt(he)) {
          for (ye.Fb = Tt(he), xe = 0; 4 > xe; ++xe) ye.Zb[xe] = Tt(he) ? mt(he, 7) : 0;
          for (xe = 0; 4 > xe; ++xe) ye.Lb[xe] = Tt(he) ? mt(he, 6) : 0;
        }
        if (ye.Bb) for (xe = 0; 3 > xe; ++xe) me.jb[xe] = Tt(he) ? Mt(he, 8) : 255;
      } else ye.Bb = 0;
      if (he.Ka) return Ln(C, 3, "cannot parse segment header");
      if ((ye = C.ed).zd = Tt(he), ye.Tb = Mt(he, 6), ye.wb = Mt(he, 3), ye.Pc = Tt(he), ye.Pc && Tt(he)) {
        for (me = 0; 4 > me; ++me) Tt(he) && (ye.vd[me] = mt(he, 6));
        for (me = 0; 4 > me; ++me) Tt(he) && (ye.od[me] = mt(he, 6));
      }
      if (C.L = ye.Tb == 0 ? 0 : ye.zd ? 1 : 2, he.Ka) return Ln(C, 3, "cannot parse filter header");
      var et = ae;
      if (ae = xe = W, W = xe + et, ye = et, C.Xb = (1 << Mt(C.m, 2)) - 1, et < 3 * (me = C.Xb)) z = 7;
      else {
        for (xe += 3 * me, ye -= 3 * me, et = 0; et < me; ++et) {
          var bt = z[ae + 0] | z[ae + 1] << 8 | z[ae + 2] << 16;
          bt > ye && (bt = ye), St(C.Jc[+et], z, xe, bt), xe += bt, ye -= bt, ae += 3;
        }
        St(C.Jc[+me], z, xe, ye), z = xe < W ? 0 : 5;
      }
      if (z != 0) return Ln(C, z, "cannot parse partitions");
      for (z = Mt(xe = C.m, 7), ae = Tt(xe) ? mt(xe, 4) : 0, W = Tt(xe) ? mt(xe, 4) : 0, ye = Tt(xe) ? mt(xe, 4) : 0, me = Tt(xe) ? mt(xe, 4) : 0, xe = Tt(xe) ? mt(xe, 4) : 0, et = C.Qa, bt = 0; 4 > bt; ++bt) {
        if (et.Cb) {
          var ke = et.Zb[bt];
          et.Fb || (ke += z);
        } else {
          if (0 < bt) {
            C.pb[bt] = C.pb[0];
            continue;
          }
          ke = z;
        }
        var st = C.pb[bt];
        st.Sc[0] = _h[ts(ke + ae, 127)], st.Sc[1] = El[ts(ke + 0, 127)], st.Eb[0] = 2 * _h[ts(ke + W, 127)], st.Eb[1] = 101581 * El[ts(ke + ye, 127)] >> 16, 8 > st.Eb[1] && (st.Eb[1] = 8), st.Qc[0] = _h[ts(ke + me, 117)], st.Qc[1] = El[ts(ke + xe, 127)], st.lc = ke + xe;
      }
      if (!ge.Rb) return Ln(C, 4, "Not a key frame.");
      for (Tt(he), ge = C.Pa, z = 0; 4 > z; ++z) {
        for (ae = 0; 8 > ae; ++ae) for (W = 0; 3 > W; ++W) for (ye = 0; 11 > ye; ++ye) me = Vt(he, Xc[z][ae][W][ye]) ? Mt(he, 8) : lf[z][ae][W][ye], ge.Wc[z][ae].Yb[W][ye] = me;
        for (ae = 0; 17 > ae; ++ae) ge.Xc[z][ae] = ge.Wc[z][zu[ae]];
      }
      return C.kc = Tt(he), C.kc && (C.Bd = Mt(he, 8)), C.cb = 1;
    }
    function La(C, L, z, W, ae, he, ge) {
      var ye = L[ae].Yb[z];
      for (z = 0; 16 > ae; ++ae) {
        if (!Vt(C, ye[z + 0])) return ae;
        for (; !Vt(C, ye[z + 1]); ) if (ye = L[++ae].Yb[0], z = 0, ae == 16) return 16;
        var xe = L[ae + 1].Yb;
        if (Vt(C, ye[z + 2])) {
          var me = C, et = 0;
          if (Vt(me, (ke = ye)[(bt = z) + 3]))
            if (Vt(me, ke[bt + 6])) {
              for (ye = 0, bt = 2 * (et = Vt(me, ke[bt + 8])) + (ke = Vt(me, ke[bt + 9 + et])), et = 0, ke = pd[bt]; ke[ye]; ++ye) et += et + Vt(me, ke[ye]);
              et += 3 + (8 << bt);
            } else Vt(me, ke[bt + 7]) ? (et = 7 + 2 * Vt(me, 165), et += Vt(me, 145)) : et = 5 + Vt(me, 159);
          else et = Vt(me, ke[bt + 4]) ? 3 + Vt(me, ke[bt + 5]) : 2;
          ye = xe[2];
        } else et = 1, ye = xe[1];
        xe = ge + yh[ae], 0 > (me = C).b && Et(me);
        var bt, ke = me.b, st = (bt = me.Ca >> 1) - (me.I >> ke) >> 31;
        --me.b, me.Ca += st, me.Ca |= 1, me.I -= (bt + 1 & st) << ke, he[xe] = ((et ^ st) - st) * W[(0 < ae) + 0];
      }
      return 16;
    }
    function jl(C) {
      var L = C.rb[C.sb - 1];
      L.la = 0, L.Na = 0, n(C.zc, 0, 0, C.zc.length), C.ja = 0;
    }
    function Ko(C, L, z, W, ae) {
      ae = C[L + z + 32 * W] + (ae >> 3), C[L + z + 32 * W] = -256 & ae ? 0 > ae ? 0 : 255 : ae;
    }
    function al(C, L, z, W, ae, he) {
      Ko(C, L, 0, z, W + ae), Ko(C, L, 1, z, W + he), Ko(C, L, 2, z, W - he), Ko(C, L, 3, z, W - ae);
    }
    function Sn(C) {
      return (20091 * C >> 16) + C;
    }
    function Vl(C, L, z, W) {
      var ae, he = 0, ge = s(16);
      for (ae = 0; 4 > ae; ++ae) {
        var ye = C[L + 0] + C[L + 8], xe = C[L + 0] - C[L + 8], me = (35468 * C[L + 4] >> 16) - Sn(C[L + 12]), et = Sn(C[L + 4]) + (35468 * C[L + 12] >> 16);
        ge[he + 0] = ye + et, ge[he + 1] = xe + me, ge[he + 2] = xe - me, ge[he + 3] = ye - et, he += 4, L++;
      }
      for (ae = he = 0; 4 > ae; ++ae) ye = (C = ge[he + 0] + 4) + ge[he + 8], xe = C - ge[he + 8], me = (35468 * ge[he + 4] >> 16) - Sn(ge[he + 12]), Ko(z, W, 0, 0, ye + (et = Sn(ge[he + 4]) + (35468 * ge[he + 12] >> 16))), Ko(z, W, 1, 0, xe + me), Ko(z, W, 2, 0, xe - me), Ko(z, W, 3, 0, ye - et), he++, W += 32;
    }
    function Bc(C, L, z, W) {
      var ae = C[L + 0] + 4, he = 35468 * C[L + 4] >> 16, ge = Sn(C[L + 4]), ye = 35468 * C[L + 1] >> 16;
      al(z, W, 0, ae + ge, C = Sn(C[L + 1]), ye), al(z, W, 1, ae + he, C, ye), al(z, W, 2, ae - he, C, ye), al(z, W, 3, ae - ge, C, ye);
    }
    function ll(C, L, z, W, ae) {
      Vl(C, L, z, W), ae && Vl(C, L + 16, z, W + 4);
    }
    function Eu(C, L, z, W) {
      xn(C, L + 0, z, W, 1), xn(C, L + 32, z, W + 128, 1);
    }
    function To(C, L, z, W) {
      var ae;
      for (C = C[L + 0] + 4, ae = 0; 4 > ae; ++ae) for (L = 0; 4 > L; ++L) Ko(z, W, L, ae, C);
    }
    function cl(C, L, z, W) {
      C[L + 0] && ya(C, L + 0, z, W), C[L + 16] && ya(C, L + 16, z, W + 4), C[L + 32] && ya(C, L + 32, z, W + 128), C[L + 48] && ya(C, L + 48, z, W + 128 + 4);
    }
    function ul(C, L, z, W) {
      var ae, he = s(16);
      for (ae = 0; 4 > ae; ++ae) {
        var ge = C[L + 0 + ae] + C[L + 12 + ae], ye = C[L + 4 + ae] + C[L + 8 + ae], xe = C[L + 4 + ae] - C[L + 8 + ae], me = C[L + 0 + ae] - C[L + 12 + ae];
        he[0 + ae] = ge + ye, he[8 + ae] = ge - ye, he[4 + ae] = me + xe, he[12 + ae] = me - xe;
      }
      for (ae = 0; 4 > ae; ++ae) ge = (C = he[0 + 4 * ae] + 3) + he[3 + 4 * ae], ye = he[1 + 4 * ae] + he[2 + 4 * ae], xe = he[1 + 4 * ae] - he[2 + 4 * ae], me = C - he[3 + 4 * ae], z[W + 0] = ge + ye >> 3, z[W + 16] = me + xe >> 3, z[W + 32] = ge - ye >> 3, z[W + 48] = me - xe >> 3, W += 64;
    }
    function Qo(C, L, z) {
      var W, ae = L - 32, he = Gs, ge = 255 - C[ae - 1];
      for (W = 0; W < z; ++W) {
        var ye, xe = he, me = ge + C[L - 1];
        for (ye = 0; ye < z; ++ye) C[L + ye] = xe[me + C[ae + ye]];
        L += 32;
      }
    }
    function kc(C, L) {
      Qo(C, L, 4);
    }
    function Ba(C, L) {
      Qo(C, L, 8);
    }
    function Cu(C, L) {
      Qo(C, L, 16);
    }
    function So(C, L) {
      var z;
      for (z = 0; 16 > z; ++z) i(C, L + 32 * z, C, L - 32, 16);
    }
    function Jr(C, L) {
      var z;
      for (z = 16; 0 < z; --z) n(C, L, C[L - 1], 16), L += 32;
    }
    function fs(C, L, z) {
      var W;
      for (W = 0; 16 > W; ++W) n(L, z + 32 * W, C, 16);
    }
    function jr(C, L) {
      var z, W = 16;
      for (z = 0; 16 > z; ++z) W += C[L - 1 + 32 * z] + C[L + z - 32];
      fs(W >> 5, C, L);
    }
    function Oc(C, L) {
      var z, W = 8;
      for (z = 0; 16 > z; ++z) W += C[L - 1 + 32 * z];
      fs(W >> 4, C, L);
    }
    function hl(C, L) {
      var z, W = 8;
      for (z = 0; 16 > z; ++z) W += C[L + z - 32];
      fs(W >> 4, C, L);
    }
    function ka(C, L) {
      fs(128, C, L);
    }
    function Er(C, L, z) {
      return C + 2 * L + z + 2 >> 2;
    }
    function Fn(C, L) {
      var z, W = L - 32;
      for (W = new Uint8Array([Er(C[W - 1], C[W + 0], C[W + 1]), Er(C[W + 0], C[W + 1], C[W + 2]), Er(C[W + 1], C[W + 2], C[W + 3]), Er(C[W + 2], C[W + 3], C[W + 4])]), z = 0; 4 > z; ++z) i(C, L + 32 * z, W, 0, W.length);
    }
    function es(C, L) {
      var z = C[L - 1], W = C[L - 1 + 32], ae = C[L - 1 + 64], he = C[L - 1 + 96];
      tr(C, L + 0, 16843009 * Er(C[L - 1 - 32], z, W)), tr(C, L + 32, 16843009 * Er(z, W, ae)), tr(C, L + 64, 16843009 * Er(W, ae, he)), tr(C, L + 96, 16843009 * Er(ae, he, he));
    }
    function Bn(C, L) {
      var z, W = 4;
      for (z = 0; 4 > z; ++z) W += C[L + z - 32] + C[L - 1 + 32 * z];
      for (W >>= 3, z = 0; 4 > z; ++z) n(C, L + 32 * z, W, 4);
    }
    function ji(C, L) {
      var z = C[L - 1 + 0], W = C[L - 1 + 32], ae = C[L - 1 + 64], he = C[L - 1 - 32], ge = C[L + 0 - 32], ye = C[L + 1 - 32], xe = C[L + 2 - 32], me = C[L + 3 - 32];
      C[L + 0 + 96] = Er(W, ae, C[L - 1 + 96]), C[L + 1 + 96] = C[L + 0 + 64] = Er(z, W, ae), C[L + 2 + 96] = C[L + 1 + 64] = C[L + 0 + 32] = Er(he, z, W), C[L + 3 + 96] = C[L + 2 + 64] = C[L + 1 + 32] = C[L + 0 + 0] = Er(ge, he, z), C[L + 3 + 64] = C[L + 2 + 32] = C[L + 1 + 0] = Er(ye, ge, he), C[L + 3 + 32] = C[L + 2 + 0] = Er(xe, ye, ge), C[L + 3 + 0] = Er(me, xe, ye);
    }
    function Oa(C, L) {
      var z = C[L + 1 - 32], W = C[L + 2 - 32], ae = C[L + 3 - 32], he = C[L + 4 - 32], ge = C[L + 5 - 32], ye = C[L + 6 - 32], xe = C[L + 7 - 32];
      C[L + 0 + 0] = Er(C[L + 0 - 32], z, W), C[L + 1 + 0] = C[L + 0 + 32] = Er(z, W, ae), C[L + 2 + 0] = C[L + 1 + 32] = C[L + 0 + 64] = Er(W, ae, he), C[L + 3 + 0] = C[L + 2 + 32] = C[L + 1 + 64] = C[L + 0 + 96] = Er(ae, he, ge), C[L + 3 + 32] = C[L + 2 + 64] = C[L + 1 + 96] = Er(he, ge, ye), C[L + 3 + 64] = C[L + 2 + 96] = Er(ge, ye, xe), C[L + 3 + 96] = Er(ye, xe, xe);
    }
    function on(C, L) {
      var z = C[L - 1 + 0], W = C[L - 1 + 32], ae = C[L - 1 + 64], he = C[L - 1 - 32], ge = C[L + 0 - 32], ye = C[L + 1 - 32], xe = C[L + 2 - 32], me = C[L + 3 - 32];
      C[L + 0 + 0] = C[L + 1 + 64] = he + ge + 1 >> 1, C[L + 1 + 0] = C[L + 2 + 64] = ge + ye + 1 >> 1, C[L + 2 + 0] = C[L + 3 + 64] = ye + xe + 1 >> 1, C[L + 3 + 0] = xe + me + 1 >> 1, C[L + 0 + 96] = Er(ae, W, z), C[L + 0 + 64] = Er(W, z, he), C[L + 0 + 32] = C[L + 1 + 96] = Er(z, he, ge), C[L + 1 + 32] = C[L + 2 + 96] = Er(he, ge, ye), C[L + 2 + 32] = C[L + 3 + 96] = Er(ge, ye, xe), C[L + 3 + 32] = Er(ye, xe, me);
    }
    function Hn(C, L) {
      var z = C[L + 0 - 32], W = C[L + 1 - 32], ae = C[L + 2 - 32], he = C[L + 3 - 32], ge = C[L + 4 - 32], ye = C[L + 5 - 32], xe = C[L + 6 - 32], me = C[L + 7 - 32];
      C[L + 0 + 0] = z + W + 1 >> 1, C[L + 1 + 0] = C[L + 0 + 64] = W + ae + 1 >> 1, C[L + 2 + 0] = C[L + 1 + 64] = ae + he + 1 >> 1, C[L + 3 + 0] = C[L + 2 + 64] = he + ge + 1 >> 1, C[L + 0 + 32] = Er(z, W, ae), C[L + 1 + 32] = C[L + 0 + 96] = Er(W, ae, he), C[L + 2 + 32] = C[L + 1 + 96] = Er(ae, he, ge), C[L + 3 + 32] = C[L + 2 + 96] = Er(he, ge, ye), C[L + 3 + 64] = Er(ge, ye, xe), C[L + 3 + 96] = Er(ye, xe, me);
    }
    function As(C, L) {
      var z = C[L - 1 + 0], W = C[L - 1 + 32], ae = C[L - 1 + 64], he = C[L - 1 + 96];
      C[L + 0 + 0] = z + W + 1 >> 1, C[L + 2 + 0] = C[L + 0 + 32] = W + ae + 1 >> 1, C[L + 2 + 32] = C[L + 0 + 64] = ae + he + 1 >> 1, C[L + 1 + 0] = Er(z, W, ae), C[L + 3 + 0] = C[L + 1 + 32] = Er(W, ae, he), C[L + 3 + 32] = C[L + 1 + 64] = Er(ae, he, he), C[L + 3 + 64] = C[L + 2 + 64] = C[L + 0 + 96] = C[L + 1 + 96] = C[L + 2 + 96] = C[L + 3 + 96] = he;
    }
    function fl(C, L) {
      var z = C[L - 1 + 0], W = C[L - 1 + 32], ae = C[L - 1 + 64], he = C[L - 1 + 96], ge = C[L - 1 - 32], ye = C[L + 0 - 32], xe = C[L + 1 - 32], me = C[L + 2 - 32];
      C[L + 0 + 0] = C[L + 2 + 32] = z + ge + 1 >> 1, C[L + 0 + 32] = C[L + 2 + 64] = W + z + 1 >> 1, C[L + 0 + 64] = C[L + 2 + 96] = ae + W + 1 >> 1, C[L + 0 + 96] = he + ae + 1 >> 1, C[L + 3 + 0] = Er(ye, xe, me), C[L + 2 + 0] = Er(ge, ye, xe), C[L + 1 + 0] = C[L + 3 + 32] = Er(z, ge, ye), C[L + 1 + 32] = C[L + 3 + 64] = Er(W, z, ge), C[L + 1 + 64] = C[L + 3 + 96] = Er(ae, W, z), C[L + 1 + 96] = Er(he, ae, W);
    }
    function pa(C, L) {
      var z;
      for (z = 0; 8 > z; ++z) i(C, L + 32 * z, C, L - 32, 8);
    }
    function ki(C, L) {
      var z;
      for (z = 0; 8 > z; ++z) n(C, L, C[L - 1], 8), L += 32;
    }
    function Si(C, L, z) {
      var W;
      for (W = 0; 8 > W; ++W) n(L, z + 32 * W, C, 8);
    }
    function to(C, L) {
      var z, W = 8;
      for (z = 0; 8 > z; ++z) W += C[L + z - 32] + C[L - 1 + 32 * z];
      Si(W >> 4, C, L);
    }
    function fi(C, L) {
      var z, W = 4;
      for (z = 0; 8 > z; ++z) W += C[L + z - 32];
      Si(W >> 3, C, L);
    }
    function Or(C, L) {
      var z, W = 4;
      for (z = 0; 8 > z; ++z) W += C[L - 1 + 32 * z];
      Si(W >> 3, C, L);
    }
    function dl(C, L) {
      Si(128, C, L);
    }
    function Qr(C, L, z) {
      var W = C[L - z], ae = C[L + 0], he = 3 * (ae - W) + Tl[1020 + C[L - 2 * z] - C[L + z]], ge = Ou[112 + (he + 4 >> 3)];
      C[L - z] = Gs[255 + W + Ou[112 + (he + 3 >> 3)]], C[L + 0] = Gs[255 + ae - ge];
    }
    function Da(C, L, z, W) {
      var ae = C[L + 0], he = C[L + z];
      return $r[255 + C[L - 2 * z] - C[L - z]] > W || $r[255 + he - ae] > W;
    }
    function ro(C, L, z, W) {
      return 4 * $r[255 + C[L - z] - C[L + 0]] + $r[255 + C[L - 2 * z] - C[L + z]] <= W;
    }
    function ea(C, L, z, W, ae) {
      var he = C[L - 3 * z], ge = C[L - 2 * z], ye = C[L - z], xe = C[L + 0], me = C[L + z], et = C[L + 2 * z], bt = C[L + 3 * z];
      return 4 * $r[255 + ye - xe] + $r[255 + ge - me] > W ? 0 : $r[255 + C[L - 4 * z] - he] <= ae && $r[255 + he - ge] <= ae && $r[255 + ge - ye] <= ae && $r[255 + bt - et] <= ae && $r[255 + et - me] <= ae && $r[255 + me - xe] <= ae;
    }
    function ta(C, L, z, W) {
      var ae = 2 * W + 1;
      for (W = 0; 16 > W; ++W) ro(C, L + W, z, ae) && Qr(C, L + W, z);
    }
    function ra(C, L, z, W) {
      var ae = 2 * W + 1;
      for (W = 0; 16 > W; ++W) ro(C, L + W * z, 1, ae) && Qr(C, L + W * z, 1);
    }
    function Na(C, L, z, W) {
      var ae;
      for (ae = 3; 0 < ae; --ae) ta(C, L += 4 * z, z, W);
    }
    function pl(C, L, z, W) {
      var ae;
      for (ae = 3; 0 < ae; --ae) ra(C, L += 4, z, W);
    }
    function Ts(C, L, z, W, ae, he, ge, ye) {
      for (he = 2 * he + 1; 0 < ae--; ) {
        if (ea(C, L, z, he, ge)) if (Da(C, L, z, ye)) Qr(C, L, z);
        else {
          var xe = C, me = L, et = z, bt = xe[me - 2 * et], ke = xe[me - et], st = xe[me + 0], ht = xe[me + et], kt = xe[me + 2 * et], tt = 27 * (jt = Tl[1020 + 3 * (st - ke) + Tl[1020 + bt - ht]]) + 63 >> 7, Ot = 18 * jt + 63 >> 7, jt = 9 * jt + 63 >> 7;
          xe[me - 3 * et] = Gs[255 + xe[me - 3 * et] + jt], xe[me - 2 * et] = Gs[255 + bt + Ot], xe[me - et] = Gs[255 + ke + tt], xe[me + 0] = Gs[255 + st - tt], xe[me + et] = Gs[255 + ht - Ot], xe[me + 2 * et] = Gs[255 + kt - jt];
        }
        L += W;
      }
    }
    function po(C, L, z, W, ae, he, ge, ye) {
      for (he = 2 * he + 1; 0 < ae--; ) {
        if (ea(C, L, z, he, ge)) if (Da(C, L, z, ye)) Qr(C, L, z);
        else {
          var xe = C, me = L, et = z, bt = xe[me - et], ke = xe[me + 0], st = xe[me + et], ht = Ou[112 + (4 + (kt = 3 * (ke - bt)) >> 3)], kt = Ou[112 + (kt + 3 >> 3)], tt = ht + 1 >> 1;
          xe[me - 2 * et] = Gs[255 + xe[me - 2 * et] + tt], xe[me - et] = Gs[255 + bt + kt], xe[me + 0] = Gs[255 + ke - ht], xe[me + et] = Gs[255 + st - tt];
        }
        L += W;
      }
    }
    function F(C, L, z, W, ae, he) {
      Ts(C, L, z, 1, 16, W, ae, he);
    }
    function se(C, L, z, W, ae, he) {
      Ts(C, L, 1, z, 16, W, ae, he);
    }
    function Ie(C, L, z, W, ae, he) {
      var ge;
      for (ge = 3; 0 < ge; --ge) po(C, L += 4 * z, z, 1, 16, W, ae, he);
    }
    function Ye(C, L, z, W, ae, he) {
      var ge;
      for (ge = 3; 0 < ge; --ge) po(C, L += 4, 1, z, 16, W, ae, he);
    }
    function ut(C, L, z, W, ae, he, ge, ye) {
      Ts(C, L, ae, 1, 8, he, ge, ye), Ts(z, W, ae, 1, 8, he, ge, ye);
    }
    function Nt(C, L, z, W, ae, he, ge, ye) {
      Ts(C, L, 1, ae, 8, he, ge, ye), Ts(z, W, 1, ae, 8, he, ge, ye);
    }
    function Ut(C, L, z, W, ae, he, ge, ye) {
      po(C, L + 4 * ae, ae, 1, 8, he, ge, ye), po(z, W + 4 * ae, ae, 1, 8, he, ge, ye);
    }
    function vr(C, L, z, W, ae, he, ge, ye) {
      po(C, L + 4, 1, ae, 8, he, ge, ye), po(z, W + 4, 1, ae, 8, he, ge, ye);
    }
    function Cr() {
      this.ba = new rr(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new mr(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function Ir() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ni() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ri() {
      this.ua = 0, this.Wa = new Zr(), this.vb = new Zr(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new gt(), this.yc = new Ve();
    }
    function Fi() {
      this.xb = this.a = 0, this.l = new zl(), this.ca = new rr(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new De(), this.Pb = 0, this.wd = new De(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ri(), this.ab = 0, this.gc = c(4, ni), this.Oc = 0;
    }
    function En() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new zl(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Ui(C, L, z, W, ae, he, ge) {
      for (C = C == null ? 0 : C[L + 0], L = 0; L < ge; ++L) ae[he + L] = C + z[W + L] & 255, C = ae[he + L];
    }
    function an(C, L, z, W, ae, he, ge) {
      var ye;
      if (C == null) Ui(null, null, z, W, ae, he, ge);
      else for (ye = 0; ye < ge; ++ye) ae[he + ye] = C[L + ye] + z[W + ye] & 255;
    }
    function vn(C, L, z, W, ae, he, ge) {
      if (C == null) Ui(null, null, z, W, ae, he, ge);
      else {
        var ye, xe = C[L + 0], me = xe, et = xe;
        for (ye = 0; ye < ge; ++ye) me = et + (xe = C[L + ye]) - me, et = z[W + ye] + (-256 & me ? 0 > me ? 0 : 255 : me) & 255, me = xe, ae[he + ye] = et;
      }
    }
    function Un(C, L, z, W) {
      var ae = L.width, he = L.o;
      if (e(C != null && L != null), 0 > z || 0 >= W || z + W > he) return null;
      if (!C.Cc) {
        if (C.ga == null) {
          var ge;
          if (C.ga = new En(), (ge = C.ga == null) || (ge = L.width * L.o, e(C.Gb.length == 0), C.Gb = s(ge), C.Uc = 0, C.Gb == null ? ge = 0 : (C.mb = C.Gb, C.nb = C.Uc, C.rc = null, ge = 1), ge = !ge), !ge) {
            ge = C.ga;
            var ye = C.Fa, xe = C.P, me = C.qc, et = C.mb, bt = C.nb, ke = xe + 1, st = me - 1, ht = ge.l;
            if (e(ye != null && et != null && L != null), va[0] = null, va[1] = Ui, va[2] = an, va[3] = vn, ge.ca = et, ge.tb = bt, ge.c = L.width, ge.i = L.height, e(0 < ge.c && 0 < ge.i), 1 >= me) L = 0;
            else if (ge.$a = 3 & ye[xe + 0], ge.Z = ye[xe + 0] >> 2 & 3, ge.Lc = ye[xe + 0] >> 4 & 3, xe = ye[xe + 0] >> 6 & 3, 0 > ge.$a || 1 < ge.$a || 4 <= ge.Z || 1 < ge.Lc || xe) L = 0;
            else if (ht.put = _r, ht.ac = li, ht.bc = qi, ht.ma = ge, ht.width = L.width, ht.height = L.height, ht.Da = L.Da, ht.v = L.v, ht.va = L.va, ht.j = L.j, ht.o = L.o, ge.$a) e: {
              e(ge.$a == 1), L = qo();
              t: for (; ; ) {
                if (L == null) {
                  L = 0;
                  break e;
                }
                if (e(ge != null), ge.mc = L, L.c = ge.c, L.i = ge.i, L.l = ge.l, L.l.ma = ge, L.l.width = ge.c, L.l.height = ge.i, L.a = 0, wt(L.m, ye, ke, st), !Qn(ge.c, ge.i, 1, L, null) || (L.ab == 1 && L.gc[0].hc == 3 && sn(L.s) ? (ge.ic = 1, ye = L.c * L.i, L.Ta = null, L.Ua = 0, L.V = s(ye), L.Ba = 0, L.V == null ? (L.a = 1, L = 0) : L = 1) : (ge.ic = 0, L = Nr(L, ge.c)), !L)) break t;
                L = 1;
                break e;
              }
              ge.mc = null, L = 0;
            }
            else L = st >= ge.c * ge.i;
            ge = !L;
          }
          if (ge) return null;
          C.ga.Lc != 1 ? C.Ga = 0 : W = he - z;
        }
        e(C.ga != null), e(z + W <= he);
        e: {
          if (L = (ye = C.ga).c, he = ye.l.o, ye.$a == 0) {
            if (ke = C.rc, st = C.Vc, ht = C.Fa, xe = C.P + 1 + z * L, me = C.mb, et = C.nb + z * L, e(xe <= C.P + C.qc), ye.Z != 0) for (e(va[ye.Z] != null), ge = 0; ge < W; ++ge) va[ye.Z](ke, st, ht, xe, me, et, L), ke = me, st = et, et += L, xe += L;
            else for (ge = 0; ge < W; ++ge) i(me, et, ht, xe, L), ke = me, st = et, et += L, xe += L;
            C.rc = ke, C.Vc = st;
          } else {
            if (e(ye.mc != null), L = z + W, e((ge = ye.mc) != null), e(L <= ge.i), ge.C >= L) L = 1;
            else if (ye.ic || Eo(), ye.ic) {
              ye = ge.V, ke = ge.Ba, st = ge.c;
              var kt = ge.i, tt = (ht = 1, xe = ge.$ / st, me = ge.$ % st, et = ge.m, bt = ge.s, ge.$), Ot = st * kt, jt = st * L, Kt = bt.wc, Wt = tt < jt ? pi(bt, me, xe) : null;
              e(tt <= Ot), e(L <= kt), e(sn(bt));
              t: for (; ; ) {
                for (; !et.h && tt < jt; ) {
                  if (me & Kt || (Wt = pi(bt, me, xe)), e(Wt != null), at(et), 256 > (kt = ci(Wt.G[0], Wt.H[0], et))) ye[ke + tt] = kt, ++tt, ++me >= st && (me = 0, ++xe <= L && !(xe % 16) && Dr(ge, xe));
                  else {
                    if (!(280 > kt)) {
                      ht = 0;
                      break t;
                    }
                    kt = Ei(kt - 256, et);
                    var Br, yr = ci(Wt.G[4], Wt.H[4], et);
                    if (at(et), !(tt >= (yr = vi(st, yr = Ei(yr, et))) && Ot - tt >= kt)) {
                      ht = 0;
                      break t;
                    }
                    for (Br = 0; Br < kt; ++Br) ye[ke + tt + Br] = ye[ke + tt + Br - yr];
                    for (tt += kt, me += kt; me >= st; ) me -= st, ++xe <= L && !(xe % 16) && Dr(ge, xe);
                    tt < jt && me & Kt && (Wt = pi(bt, me, xe));
                  }
                  e(et.h == Ke(et));
                }
                Dr(ge, xe > L ? L : xe);
                break t;
              }
              !ht || et.h && tt < Ot ? (ht = 0, ge.a = et.h ? 5 : 3) : ge.$ = tt, L = ht;
            } else L = zr(ge, ge.V, ge.Ba, ge.c, ge.i, L, wo);
            if (!L) {
              W = 0;
              break e;
            }
          }
          z + W >= he && (C.Cc = 1), W = 1;
        }
        if (!W) return null;
        if (C.Cc && ((W = C.ga) != null && (W.mc = null), C.ga = null, 0 < C.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return C.nb + z * ae;
    }
    function qn(C, L, z, W, ae, he) {
      for (; 0 < ae--; ) {
        var ge, ye = C, xe = L + (z ? 1 : 0), me = C, et = L + (z ? 0 : 3);
        for (ge = 0; ge < W; ++ge) {
          var bt = me[et + 4 * ge];
          bt != 255 && (bt *= 32897, ye[xe + 4 * ge + 0] = ye[xe + 4 * ge + 0] * bt >> 23, ye[xe + 4 * ge + 1] = ye[xe + 4 * ge + 1] * bt >> 23, ye[xe + 4 * ge + 2] = ye[xe + 4 * ge + 2] * bt >> 23);
        }
        L += he;
      }
    }
    function Fa(C, L, z, W, ae) {
      for (; 0 < W--; ) {
        var he;
        for (he = 0; he < z; ++he) {
          var ge = C[L + 2 * he + 0], ye = 15 & (me = C[L + 2 * he + 1]), xe = 4369 * ye, me = (240 & me | me >> 4) * xe >> 16;
          C[L + 2 * he + 0] = (240 & ge | ge >> 4) * xe >> 16 & 240 | (15 & ge | ge << 4) * xe >> 16 >> 4 & 15, C[L + 2 * he + 1] = 240 & me | ye;
        }
        L += ae;
      }
    }
    function Dc(C, L, z, W, ae, he, ge, ye) {
      var xe, me, et = 255;
      for (me = 0; me < ae; ++me) {
        for (xe = 0; xe < W; ++xe) {
          var bt = C[L + xe];
          he[ge + 4 * xe] = bt, et &= bt;
        }
        L += z, ge += ye;
      }
      return et != 255;
    }
    function uh(C, L, z, W, ae) {
      var he;
      for (he = 0; he < ae; ++he) z[W + he] = C[L + he] >> 8;
    }
    function Eo() {
      Vc = qn, fh = Fa, Al = Dc, Lu = uh;
    }
    function go(C, L, z) {
      oe[C] = function(W, ae, he, ge, ye, xe, me, et, bt, ke, st, ht, kt, tt, Ot, jt, Kt) {
        var Wt, Br = Kt - 1 >> 1, yr = ye[xe + 0] | me[et + 0] << 16, si = bt[ke + 0] | st[ht + 0] << 16;
        e(W != null);
        var Tr = 3 * yr + si + 131074 >> 2;
        for (L(W[ae + 0], 255 & Tr, Tr >> 16, kt, tt), he != null && (Tr = 3 * si + yr + 131074 >> 2, L(he[ge + 0], 255 & Tr, Tr >> 16, Ot, jt)), Wt = 1; Wt <= Br; ++Wt) {
          var xi = ye[xe + Wt] | me[et + Wt] << 16, zn = bt[ke + Wt] | st[ht + Wt] << 16, ui = yr + xi + si + zn + 524296, Pr = ui + 2 * (xi + si) >> 3;
          Tr = Pr + yr >> 1, yr = (ui = ui + 2 * (yr + zn) >> 3) + xi >> 1, L(W[ae + 2 * Wt - 1], 255 & Tr, Tr >> 16, kt, tt + (2 * Wt - 1) * z), L(W[ae + 2 * Wt - 0], 255 & yr, yr >> 16, kt, tt + (2 * Wt - 0) * z), he != null && (Tr = ui + si >> 1, yr = Pr + zn >> 1, L(he[ge + 2 * Wt - 1], 255 & Tr, Tr >> 16, Ot, jt + (2 * Wt - 1) * z), L(he[ge + 2 * Wt + 0], 255 & yr, yr >> 16, Ot, jt + (2 * Wt + 0) * z)), yr = xi, si = zn;
        }
        1 & Kt || (Tr = 3 * yr + si + 131074 >> 2, L(W[ae + Kt - 1], 255 & Tr, Tr >> 16, kt, tt + (Kt - 1) * z), he != null && (Tr = 3 * si + yr + 131074 >> 2, L(he[ge + Kt - 1], 255 & Tr, Tr >> 16, Ot, jt + (Kt - 1) * z)));
      };
    }
    function gl() {
      $s[$a] = gd, $s[dh] = ju, $s[rf] = Zc, $s[Sl] = Ql, $s[Du] = ec, $s[nf] = uf, $s[sf] = hf, $s[$c] = ju, $s[Hc] = Ql, $s[Jl] = ec, $s[qc] = uf;
    }
    function ml(C) {
      return C & -16384 ? 0 > C ? 0 : 255 : C >> Jc;
    }
    function ga(C, L) {
      return ml((19077 * C >> 8) + (26149 * L >> 8) - 14234);
    }
    function Oi(C, L, z) {
      return ml((19077 * C >> 8) - (6419 * L >> 8) - (13320 * z >> 8) + 8708);
    }
    function Ua(C, L) {
      return ml((19077 * C >> 8) + (33050 * L >> 8) - 17685);
    }
    function Co(C, L, z, W, ae) {
      W[ae + 0] = ga(C, z), W[ae + 1] = Oi(C, L, z), W[ae + 2] = Ua(C, L);
    }
    function ia(C, L, z, W, ae) {
      W[ae + 0] = Ua(C, L), W[ae + 1] = Oi(C, L, z), W[ae + 2] = ga(C, z);
    }
    function za(C, L, z, W, ae) {
      var he = Oi(C, L, z);
      L = he << 3 & 224 | Ua(C, L) >> 3, W[ae + 0] = 248 & ga(C, z) | he >> 5, W[ae + 1] = L;
    }
    function Ss(C, L, z, W, ae) {
      var he = 240 & Ua(C, L) | 15;
      W[ae + 0] = 240 & ga(C, z) | Oi(C, L, z) >> 4, W[ae + 1] = he;
    }
    function Gl(C, L, z, W, ae) {
      W[ae + 0] = 255, Co(C, L, z, W, ae + 1);
    }
    function Nc(C, L, z, W, ae) {
      ia(C, L, z, W, ae), W[ae + 3] = 255;
    }
    function ja(C, L, z, W, ae) {
      Co(C, L, z, W, ae), W[ae + 3] = 255;
    }
    function ts(C, L) {
      return 0 > C ? 0 : C > L ? L : C;
    }
    function mo(C, L, z) {
      oe[C] = function(W, ae, he, ge, ye, xe, me, et, bt) {
        for (var ke = et + (-2 & bt) * z; et != ke; ) L(W[ae + 0], he[ge + 0], ye[xe + 0], me, et), L(W[ae + 1], he[ge + 0], ye[xe + 0], me, et + z), ae += 2, ++ge, ++xe, et += 2 * z;
        1 & bt && L(W[ae + 0], he[ge + 0], ye[xe + 0], me, et);
      };
    }
    function Fc(C, L, z) {
      return z == 0 ? C == 0 ? L == 0 ? 6 : 5 : L == 0 ? 4 : 0 : z;
    }
    function $l(C, L, z, W, ae) {
      switch (C >>> 30) {
        case 3:
          xn(L, z, W, ae, 0);
          break;
        case 2:
          Ga(L, z, W, ae);
          break;
        case 1:
          ya(L, z, W, ae);
      }
    }
    function na(C, L) {
      var z, W, ae = L.M, he = L.Nb, ge = C.oc, ye = C.pc + 40, xe = C.oc, me = C.pc + 584, et = C.oc, bt = C.pc + 600;
      for (z = 0; 16 > z; ++z) ge[ye + 32 * z - 1] = 129;
      for (z = 0; 8 > z; ++z) xe[me + 32 * z - 1] = 129, et[bt + 32 * z - 1] = 129;
      for (0 < ae ? ge[ye - 1 - 32] = xe[me - 1 - 32] = et[bt - 1 - 32] = 129 : (n(ge, ye - 32 - 1, 127, 21), n(xe, me - 32 - 1, 127, 9), n(et, bt - 32 - 1, 127, 9)), W = 0; W < C.za; ++W) {
        var ke = L.ya[L.aa + W];
        if (0 < W) {
          for (z = -1; 16 > z; ++z) i(ge, ye + 32 * z - 4, ge, ye + 32 * z + 12, 4);
          for (z = -1; 8 > z; ++z) i(xe, me + 32 * z - 4, xe, me + 32 * z + 4, 4), i(et, bt + 32 * z - 4, et, bt + 32 * z + 4, 4);
        }
        var st = C.Gd, ht = C.Hd + W, kt = ke.ad, tt = ke.Hc;
        if (0 < ae && (i(ge, ye - 32, st[ht].y, 0, 16), i(xe, me - 32, st[ht].f, 0, 8), i(et, bt - 32, st[ht].ea, 0, 8)), ke.Za) {
          var Ot = ge, jt = ye - 32 + 16;
          for (0 < ae && (W >= C.za - 1 ? n(Ot, jt, st[ht].y[15], 4) : i(Ot, jt, st[ht + 1].y, 0, 4)), z = 0; 4 > z; z++) Ot[jt + 128 + z] = Ot[jt + 256 + z] = Ot[jt + 384 + z] = Ot[jt + 0 + z];
          for (z = 0; 16 > z; ++z, tt <<= 2) Ot = ge, jt = ye + Ha[z], io[ke.Ob[z]](Ot, jt), $l(tt, kt, 16 * +z, Ot, jt);
        } else if (Ot = Fc(W, ae, ke.Ob[0]), ba[Ot](ge, ye), tt != 0) for (z = 0; 16 > z; ++z, tt <<= 2) $l(tt, kt, 16 * +z, ge, ye + Ha[z]);
        for (z = ke.Gc, Ot = Fc(W, ae, ke.Dd), Ci[Ot](xe, me), Ci[Ot](et, bt), tt = kt, Ot = xe, jt = me, 255 & (ke = 0 | z) && (170 & ke ? zc(tt, 256, Ot, jt) : Iu(tt, 256, Ot, jt)), ke = et, tt = bt, 255 & (z >>= 8) && (170 & z ? zc(kt, 320, ke, tt) : Iu(kt, 320, ke, tt)), ae < C.Ub - 1 && (i(st[ht].y, 0, ge, ye + 480, 16), i(st[ht].f, 0, xe, me + 224, 8), i(st[ht].ea, 0, et, bt + 224, 8)), z = 8 * he * C.B, st = C.sa, ht = C.ta + 16 * W + 16 * he * C.R, kt = C.qa, ke = C.ra + 8 * W + z, tt = C.Ha, Ot = C.Ia + 8 * W + z, z = 0; 16 > z; ++z) i(st, ht + z * C.R, ge, ye + 32 * z, 16);
        for (z = 0; 8 > z; ++z) i(kt, ke + z * C.B, xe, me + 32 * z, 8), i(tt, Ot + z * C.B, et, bt + 32 * z, 8);
      }
    }
    function Hl(C, L, z, W, ae, he, ge, ye, xe) {
      var me = [0], et = [0], bt = 0, ke = xe != null ? xe.kd : 0, st = xe ?? new Ir();
      if (C == null || 12 > z) return 7;
      st.data = C, st.w = L, st.ha = z, L = [L], z = [z], st.gb = [st.gb];
      e: {
        var ht = L, kt = z, tt = st.gb;
        if (e(C != null), e(kt != null), e(tt != null), tt[0] = 0, 12 <= kt[0] && !t(C, ht[0], "RIFF")) {
          if (t(C, ht[0] + 8, "WEBP")) {
            tt = 3;
            break e;
          }
          var Ot = Ct(C, ht[0] + 4);
          if (12 > Ot || 4294967286 < Ot) {
            tt = 3;
            break e;
          }
          if (ke && Ot > kt[0] - 8) {
            tt = 7;
            break e;
          }
          tt[0] = Ot, ht[0] += 12, kt[0] -= 12;
        }
        tt = 0;
      }
      if (tt != 0) return tt;
      for (Ot = 0 < st.gb[0], z = z[0]; ; ) {
        e: {
          var jt = C;
          kt = L, tt = z;
          var Kt = me, Wt = et, Br = ht = [0];
          if ((Tr = bt = [bt])[0] = 0, 8 > tt[0]) tt = 7;
          else {
            if (!t(jt, kt[0], "VP8X")) {
              if (Ct(jt, kt[0] + 4) != 10) {
                tt = 3;
                break e;
              }
              if (18 > tt[0]) {
                tt = 7;
                break e;
              }
              var yr = Ct(jt, kt[0] + 8), si = 1 + dr(jt, kt[0] + 12);
              if (2147483648 <= si * (jt = 1 + dr(jt, kt[0] + 15))) {
                tt = 3;
                break e;
              }
              Br != null && (Br[0] = yr), Kt != null && (Kt[0] = si), Wt != null && (Wt[0] = jt), kt[0] += 18, tt[0] -= 18, Tr[0] = 1;
            }
            tt = 0;
          }
        }
        if (bt = bt[0], ht = ht[0], tt != 0) return tt;
        if (kt = !!(2 & ht), !Ot && bt) return 3;
        if (he != null && (he[0] = !!(16 & ht)), ge != null && (ge[0] = kt), ye != null && (ye[0] = 0), ge = me[0], ht = et[0], bt && kt && xe == null) {
          tt = 0;
          break;
        }
        if (4 > z) {
          tt = 7;
          break;
        }
        if (Ot && bt || !Ot && !bt && !t(C, L[0], "ALPH")) {
          z = [z], st.na = [st.na], st.P = [st.P], st.Sa = [st.Sa];
          e: {
            yr = C, tt = L, Ot = z;
            var Tr = st.gb;
            Kt = st.na, Wt = st.P, Br = st.Sa, si = 22, e(yr != null), e(Ot != null), jt = tt[0];
            var xi = Ot[0];
            for (e(Kt != null), e(Br != null), Kt[0] = null, Wt[0] = null, Br[0] = 0; ; ) {
              if (tt[0] = jt, Ot[0] = xi, 8 > xi) {
                tt = 7;
                break e;
              }
              var zn = Ct(yr, jt + 4);
              if (4294967286 < zn) {
                tt = 3;
                break e;
              }
              var ui = 8 + zn + 1 & -2;
              if (si += ui, 0 < Tr && si > Tr) {
                tt = 3;
                break e;
              }
              if (!t(yr, jt, "VP8 ") || !t(yr, jt, "VP8L")) {
                tt = 0;
                break e;
              }
              if (xi[0] < ui) {
                tt = 7;
                break e;
              }
              t(yr, jt, "ALPH") || (Kt[0] = yr, Wt[0] = jt + 8, Br[0] = zn), jt += ui, xi -= ui;
            }
          }
          if (z = z[0], st.na = st.na[0], st.P = st.P[0], st.Sa = st.Sa[0], tt != 0) break;
        }
        z = [z], st.Ja = [st.Ja], st.xa = [st.xa];
        e: if (Tr = C, tt = L, Ot = z, Kt = st.gb[0], Wt = st.Ja, Br = st.xa, yr = tt[0], jt = !t(Tr, yr, "VP8 "), si = !t(Tr, yr, "VP8L"), e(Tr != null), e(Ot != null), e(Wt != null), e(Br != null), 8 > Ot[0]) tt = 7;
        else {
          if (jt || si) {
            if (Tr = Ct(Tr, yr + 4), 12 <= Kt && Tr > Kt - 12) {
              tt = 3;
              break e;
            }
            if (ke && Tr > Ot[0] - 8) {
              tt = 7;
              break e;
            }
            Wt[0] = Tr, tt[0] += 8, Ot[0] -= 8, Br[0] = si;
          } else Br[0] = 5 <= Ot[0] && Tr[yr + 0] == 47 && !(Tr[yr + 4] >> 5), Wt[0] = Ot[0];
          tt = 0;
        }
        if (z = z[0], st.Ja = st.Ja[0], st.xa = st.xa[0], L = L[0], tt != 0) break;
        if (4294967286 < st.Ja) return 3;
        if (ye == null || kt || (ye[0] = st.xa ? 2 : 1), ge = [ge], ht = [ht], st.xa) {
          if (5 > z) {
            tt = 7;
            break;
          }
          ye = ge, ke = ht, kt = he, C == null || 5 > z ? C = 0 : 5 <= z && C[L + 0] == 47 && !(C[L + 4] >> 5) ? (Ot = [0], Tr = [0], Kt = [0], wt(Wt = new De(), C, L, z), nn(Wt, Ot, Tr, Kt) ? (ye != null && (ye[0] = Ot[0]), ke != null && (ke[0] = Tr[0]), kt != null && (kt[0] = Kt[0]), C = 1) : C = 0) : C = 0;
        } else {
          if (10 > z) {
            tt = 7;
            break;
          }
          ye = ht, C == null || 10 > z || !da(C, L + 3, z - 3) ? C = 0 : (ke = C[L + 0] | C[L + 1] << 8 | C[L + 2] << 16, kt = 16383 & (C[L + 7] << 8 | C[L + 6]), C = 16383 & (C[L + 9] << 8 | C[L + 8]), 1 & ke || 3 < (ke >> 1 & 7) || !(ke >> 4 & 1) || ke >> 5 >= st.Ja || !kt || !C ? C = 0 : (ge && (ge[0] = kt), ye && (ye[0] = C), C = 1));
        }
        if (!C || (ge = ge[0], ht = ht[0], bt && (me[0] != ge || et[0] != ht))) return 3;
        xe != null && (xe[0] = st, xe.offset = L - xe.w, e(4294967286 > L - xe.w), e(xe.offset == xe.ha - z));
        break;
      }
      return tt == 0 || tt == 7 && bt && xe == null ? (he != null && (he[0] |= st.na != null && 0 < st.na.length), W != null && (W[0] = ge), ae != null && (ae[0] = ht), 0) : tt;
    }
    function zs(C, L, z) {
      var W = L.width, ae = L.height, he = 0, ge = 0, ye = W, xe = ae;
      if (L.Da = C != null && 0 < C.Da, L.Da && (ye = C.cd, xe = C.bd, he = C.v, ge = C.j, 11 > z || (he &= -2, ge &= -2), 0 > he || 0 > ge || 0 >= ye || 0 >= xe || he + ye > W || ge + xe > ae)) return 0;
      if (L.v = he, L.j = ge, L.va = he + ye, L.o = ge + xe, L.U = ye, L.T = xe, L.da = C != null && 0 < C.da, L.da) {
        if (!Rr(ye, xe, z = [C.ib], he = [C.hb])) return 0;
        L.ib = z[0], L.hb = he[0];
      }
      return L.ob = C != null && C.ob, L.Kb = C == null || !C.Sd, L.da && (L.ob = L.ib < 3 * W / 4 && L.hb < 3 * ae / 4, L.Kb = 0), 1;
    }
    function js(C) {
      if (C == null) return 2;
      if (11 > C.S) {
        var L = C.f.RGBA;
        L.fb += (C.height - 1) * L.A, L.A = -L.A;
      } else L = C.f.kb, C = C.height, L.O += (C - 1) * L.fa, L.fa = -L.fa, L.N += (C - 1 >> 1) * L.Ab, L.Ab = -L.Ab, L.W += (C - 1 >> 1) * L.Db, L.Db = -L.Db, L.F != null && (L.J += (C - 1) * L.lb, L.lb = -L.lb);
      return 0;
    }
    function _l(C, L, z, W) {
      if (W == null || 0 >= C || 0 >= L) return 2;
      if (z != null) {
        if (z.Da) {
          var ae = z.cd, he = z.bd, ge = -2 & z.v, ye = -2 & z.j;
          if (0 > ge || 0 > ye || 0 >= ae || 0 >= he || ge + ae > C || ye + he > L) return 2;
          C = ae, L = he;
        }
        if (z.da) {
          if (!Rr(C, L, ae = [z.ib], he = [z.hb])) return 2;
          C = ae[0], L = he[0];
        }
      }
      W.width = C, W.height = L;
      e: {
        var xe = W.width, me = W.height;
        if (C = W.S, 0 >= xe || 0 >= me || !(C >= $a && 13 > C)) C = 2;
        else {
          if (0 >= W.Rd && W.sd == null) {
            ge = he = ae = L = 0;
            var et = (ye = xe * df[C]) * me;
            if (11 > C || (he = (me + 1) / 2 * (L = (xe + 1) / 2), C == 12 && (ge = (ae = xe) * me)), (me = s(et + 2 * he + ge)) == null) {
              C = 1;
              break e;
            }
            W.sd = me, 11 > C ? ((xe = W.f.RGBA).eb = me, xe.fb = 0, xe.A = ye, xe.size = et) : ((xe = W.f.kb).y = me, xe.O = 0, xe.fa = ye, xe.Fd = et, xe.f = me, xe.N = 0 + et, xe.Ab = L, xe.Cd = he, xe.ea = me, xe.W = 0 + et + he, xe.Db = L, xe.Ed = he, C == 12 && (xe.F = me, xe.J = 0 + et + 2 * he), xe.Tc = ge, xe.lb = ae);
          }
          if (L = 1, ae = W.S, he = W.width, ge = W.height, ae >= $a && 13 > ae)
            if (11 > ae) C = W.f.RGBA, L &= (ye = Math.abs(C.A)) * (ge - 1) + he <= C.size, L &= ye >= he * df[ae], L &= C.eb != null;
            else {
              C = W.f.kb, ye = (he + 1) / 2, et = (ge + 1) / 2, xe = Math.abs(C.fa), me = Math.abs(C.Ab);
              var bt = Math.abs(C.Db), ke = Math.abs(C.lb), st = ke * (ge - 1) + he;
              L &= xe * (ge - 1) + he <= C.Fd, L &= me * (et - 1) + ye <= C.Cd, L = (L &= bt * (et - 1) + ye <= C.Ed) & xe >= he & me >= ye & bt >= ye, L &= C.y != null, L &= C.f != null, L &= C.ea != null, ae == 12 && (L &= ke >= he, L &= st <= C.Tc, L &= C.F != null);
            }
          else L = 0;
          C = L ? 0 : 2;
        }
      }
      return C != 0 || z != null && z.fd && (C = js(W)), C;
    }
    var Wn = 64, Va = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Uc = 24, Io = 32, kn = 8, yl = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    hr("Predictor0", "PredictorAdd0"), oe.Predictor0 = function() {
      return 4278190080;
    }, oe.Predictor1 = function(C) {
      return C;
    }, oe.Predictor2 = function(C, L, z) {
      return L[z + 0];
    }, oe.Predictor3 = function(C, L, z) {
      return L[z + 1];
    }, oe.Predictor4 = function(C, L, z) {
      return L[z - 1];
    }, oe.Predictor5 = function(C, L, z) {
      return xr(xr(C, L[z + 1]), L[z + 0]);
    }, oe.Predictor6 = function(C, L, z) {
      return xr(C, L[z - 1]);
    }, oe.Predictor7 = function(C, L, z) {
      return xr(C, L[z + 0]);
    }, oe.Predictor8 = function(C, L, z) {
      return xr(L[z - 1], L[z + 0]);
    }, oe.Predictor9 = function(C, L, z) {
      return xr(L[z + 0], L[z + 1]);
    }, oe.Predictor10 = function(C, L, z) {
      return xr(xr(C, L[z - 1]), xr(L[z + 0], L[z + 1]));
    }, oe.Predictor11 = function(C, L, z) {
      var W = L[z + 0];
      return 0 >= Fr(W >> 24 & 255, C >> 24 & 255, (L = L[z - 1]) >> 24 & 255) + Fr(W >> 16 & 255, C >> 16 & 255, L >> 16 & 255) + Fr(W >> 8 & 255, C >> 8 & 255, L >> 8 & 255) + Fr(255 & W, 255 & C, 255 & L) ? W : C;
    }, oe.Predictor12 = function(C, L, z) {
      var W = L[z + 0];
      return (bi((C >> 24 & 255) + (W >> 24 & 255) - ((L = L[z - 1]) >> 24 & 255)) << 24 | bi((C >> 16 & 255) + (W >> 16 & 255) - (L >> 16 & 255)) << 16 | bi((C >> 8 & 255) + (W >> 8 & 255) - (L >> 8 & 255)) << 8 | bi((255 & C) + (255 & W) - (255 & L))) >>> 0;
    }, oe.Predictor13 = function(C, L, z) {
      var W = L[z - 1];
      return (Yr((C = xr(C, L[z + 0])) >> 24 & 255, W >> 24 & 255) << 24 | Yr(C >> 16 & 255, W >> 16 & 255) << 16 | Yr(C >> 8 & 255, W >> 8 & 255) << 8 | Yr(255 & C, 255 & W)) >>> 0;
    };
    var sa = oe.PredictorAdd0;
    oe.PredictorAdd1 = Ri, hr("Predictor2", "PredictorAdd2"), hr("Predictor3", "PredictorAdd3"), hr("Predictor4", "PredictorAdd4"), hr("Predictor5", "PredictorAdd5"), hr("Predictor6", "PredictorAdd6"), hr("Predictor7", "PredictorAdd7"), hr("Predictor8", "PredictorAdd8"), hr("Predictor9", "PredictorAdd9"), hr("Predictor10", "PredictorAdd10"), hr("Predictor11", "PredictorAdd11"), hr("Predictor12", "PredictorAdd12"), hr("Predictor13", "PredictorAdd13");
    var ma = oe.PredictorAdd2;
    K("ColorIndexInverseTransform", "MapARGB", "32b", function(C) {
      return C >> 8 & 255;
    }, function(C) {
      return C;
    }), K("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(C) {
      return C;
    }, function(C) {
      return C >> 8 & 255;
    });
    var ql, Wl = oe.ColorIndexInverseTransform, bl = oe.MapARGB, vl = oe.VP8LColorIndexInverseTransformAlpha, xl = oe.MapAlpha, _a = oe.VP8LPredictorsAdd = [];
    _a.length = 16, (oe.VP8LPredictors = []).length = 16, (oe.VP8LPredictorsAdd_C = []).length = 16, (oe.VP8LPredictors_C = []).length = 16;
    var rs, Xl, Vs, Po, Wi, Lr, Xi, xn, Ga, zc, ya, Iu, Kh, dd, Qh, Pu, Mu, Ru, hh, wl, jc, Zl, _o, ef, Vc, fh, Al, Lu, Bu = s(511), Gc = s(2041), ku = s(225), tf = s(767), Yl = 0, Tl = Gc, Ou = ku, Gs = tf, $r = Bu, $a = 0, dh = 1, rf = 2, Sl = 3, Du = 4, nf = 5, sf = 6, $c = 7, Hc = 8, Jl = 9, qc = 10, ph = [2, 3, 7], of = [3, 3, 11], af = [280, 256, 256, 256, 40], Nu = [0, 1, 1, 1, 0], Fu = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], gh = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Wc = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], mh = 8, _h = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], El = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], Uu = null, pd = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], yh = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], bh = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], lf = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], cf = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Xc = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], zu = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], ba = [], io = [], Ci = [], Kl = 1, yo = 2, va = [], $s = [];
    go("UpsampleRgbLinePair", Co, 3), go("UpsampleBgrLinePair", ia, 3), go("UpsampleRgbaLinePair", ja, 4), go("UpsampleBgraLinePair", Nc, 4), go("UpsampleArgbLinePair", Gl, 4), go("UpsampleRgba4444LinePair", Ss, 2), go("UpsampleRgb565LinePair", za, 2);
    var gd = oe.UpsampleRgbLinePair, Zc = oe.UpsampleBgrLinePair, ju = oe.UpsampleRgbaLinePair, Ql = oe.UpsampleBgraLinePair, ec = oe.UpsampleArgbLinePair, uf = oe.UpsampleRgba4444LinePair, hf = oe.UpsampleRgb565LinePair, Yc = 16, Vu = 1 << Yc - 1, tc = -227, xa = 482, Jc = 6, ff = 0, md = s(256), _d = s(256), yd = s(256), bd = s(256), vd = s(xa - tc), Kc = s(xa - tc);
    mo("YuvToRgbRow", Co, 3), mo("YuvToBgrRow", ia, 3), mo("YuvToRgbaRow", ja, 4), mo("YuvToBgraRow", Nc, 4), mo("YuvToArgbRow", Gl, 4), mo("YuvToRgba4444Row", Ss, 2), mo("YuvToRgb565Row", za, 2);
    var Ha = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], ds = [0, 2, 8], Es = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Mo = 1;
    this.WebPDecodeRGBA = function(C, L, z, W, ae) {
      var he = dh, ge = new Cr(), ye = new rr();
      ge.ba = ye, ye.S = he, ye.width = [ye.width], ye.height = [ye.height];
      var xe = ye.width, me = ye.height, et = new We();
      if (et == null || C == null) var bt = 2;
      else e(et != null), bt = Hl(C, L, z, et.width, et.height, et.Pd, et.Qd, et.format, null);
      if (bt != 0 ? xe = 0 : (xe != null && (xe[0] = et.width[0]), me != null && (me[0] = et.height[0]), xe = 1), xe) {
        ye.width = ye.width[0], ye.height = ye.height[0], W != null && (W[0] = ye.width), ae != null && (ae[0] = ye.height);
        e: {
          if (W = new zl(), (ae = new Ir()).data = C, ae.w = L, ae.ha = z, ae.kd = 1, L = [0], e(ae != null), ((C = Hl(ae.data, ae.w, ae.ha, null, null, null, L, null, ae)) == 0 || C == 7) && L[0] && (C = 4), (L = C) == 0) {
            if (e(ge != null), W.data = ae.data, W.w = ae.w + ae.offset, W.ha = ae.ha - ae.offset, W.put = _r, W.ac = li, W.bc = qi, W.ma = ge, ae.xa) {
              if ((C = qo()) == null) {
                ge = 1;
                break e;
              }
              if (function(ke, st) {
                var ht = [0], kt = [0], tt = [0];
                t: for (; ; ) {
                  if (ke == null) return 0;
                  if (st == null) return ke.a = 2, 0;
                  if (ke.l = st, ke.a = 0, wt(ke.m, st.data, st.w, st.ha), !nn(ke.m, ht, kt, tt)) {
                    ke.a = 3;
                    break t;
                  }
                  if (ke.xb = yo, st.width = ht[0], st.height = kt[0], !Qn(ht[0], kt[0], 1, ke, null)) break t;
                  return 1;
                }
                return e(ke.a != 0), 0;
              }(C, W)) {
                if (W = (L = _l(W.width, W.height, ge.Oa, ge.ba)) == 0) {
                  t: {
                    W = C;
                    r: for (; ; ) {
                      if (W == null) {
                        W = 0;
                        break t;
                      }
                      if (e(W.s.yc != null), e(W.s.Ya != null), e(0 < W.s.Wb), e((z = W.l) != null), e((ae = z.ma) != null), W.xb != 0) {
                        if (W.ca = ae.ba, W.tb = ae.tb, e(W.ca != null), !zs(ae.Oa, z, Sl)) {
                          W.a = 2;
                          break r;
                        }
                        if (!Nr(W, z.width) || z.da) break r;
                        if ((z.da || nt(W.ca.S)) && Eo(), 11 > W.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), W.ca.f.kb.F != null && Eo()), W.Pb && 0 < W.s.ua && W.s.vb.X == null && !Oe(W.s.vb, W.s.Wa.Xa)) {
                          W.a = 1;
                          break r;
                        }
                        W.xb = 0;
                      }
                      if (!zr(W, W.V, W.Ba, W.c, W.i, z.o, eo)) break r;
                      ae.Dc = W.Ma, W = 1;
                      break t;
                    }
                    e(W.a != 0), W = 0;
                  }
                  W = !W;
                }
                W && (L = C.a);
              } else L = C.a;
            } else {
              if ((C = new Tu()) == null) {
                ge = 1;
                break e;
              }
              if (C.Fa = ae.na, C.P = ae.P, C.qc = ae.Sa, Su(C, W)) {
                if ((L = _l(W.width, W.height, ge.Oa, ge.ba)) == 0) {
                  if (C.Aa = 0, z = ge.Oa, e((ae = C) != null), z != null) {
                    if (0 < (xe = 0 > (xe = z.Md) ? 0 : 100 < xe ? 255 : 255 * xe / 100)) {
                      for (me = et = 0; 4 > me; ++me) 12 > (bt = ae.pb[me]).lc && (bt.ia = xe * Es[0 > bt.lc ? 0 : bt.lc] >> 3), et |= bt.ia;
                      et && (alert("todo:VP8InitRandom"), ae.ia = 1);
                    }
                    ae.Ga = z.Id, 100 < ae.Ga ? ae.Ga = 100 : 0 > ae.Ga && (ae.Ga = 0);
                  }
                  (function(ke, st) {
                    if (ke == null) return 0;
                    if (st == null) return Ln(ke, 2, "NULL VP8Io parameter in VP8Decode().");
                    if (!ke.cb && !Su(ke, st)) return 0;
                    if (e(ke.cb), st.ac == null || st.ac(st)) {
                      st.ob && (ke.L = 0);
                      var ht = ds[ke.L];
                      if (ke.L == 2 ? (ke.yb = 0, ke.zb = 0) : (ke.yb = st.v - ht >> 4, ke.zb = st.j - ht >> 4, 0 > ke.yb && (ke.yb = 0), 0 > ke.zb && (ke.zb = 0)), ke.Va = st.o + 15 + ht >> 4, ke.Hb = st.va + 15 + ht >> 4, ke.Hb > ke.za && (ke.Hb = ke.za), ke.Va > ke.Ub && (ke.Va = ke.Ub), 0 < ke.L) {
                        var kt = ke.ed;
                        for (ht = 0; 4 > ht; ++ht) {
                          var tt;
                          if (ke.Qa.Cb) {
                            var Ot = ke.Qa.Lb[ht];
                            ke.Qa.Fb || (Ot += kt.Tb);
                          } else Ot = kt.Tb;
                          for (tt = 0; 1 >= tt; ++tt) {
                            var jt = ke.gd[ht][tt], Kt = Ot;
                            if (kt.Pc && (Kt += kt.vd[0], tt && (Kt += kt.od[0])), 0 < (Kt = 0 > Kt ? 0 : 63 < Kt ? 63 : Kt)) {
                              var Wt = Kt;
                              0 < kt.wb && (Wt = 4 < kt.wb ? Wt >> 2 : Wt >> 1) > 9 - kt.wb && (Wt = 9 - kt.wb), 1 > Wt && (Wt = 1), jt.dd = Wt, jt.tc = 2 * Kt + Wt, jt.ld = 40 <= Kt ? 2 : 15 <= Kt ? 1 : 0;
                            } else jt.tc = 0;
                            jt.La = tt;
                          }
                        }
                      }
                      ht = 0;
                    } else Ln(ke, 6, "Frame setup failed"), ht = ke.a;
                    if (ht = ht == 0) {
                      if (ht) {
                        ke.$c = 0, 0 < ke.Aa || (ke.Ic = Mo);
                        t: {
                          ht = ke.Ic, kt = 4 * (Wt = ke.za);
                          var Br = 32 * Wt, yr = Wt + 1, si = 0 < ke.L ? Wt * (0 < ke.Aa ? 2 : 1) : 0, Tr = (ke.Aa == 2 ? 2 : 1) * Wt;
                          if ((jt = kt + 832 + (tt = 3 * (16 * ht + ds[ke.L]) / 2 * Br) + (Ot = ke.Fa != null && 0 < ke.Fa.length ? ke.Kc.c * ke.Kc.i : 0)) != jt) ht = 0;
                          else {
                            if (jt > ke.Vb) {
                              if (ke.Vb = 0, ke.Ec = s(jt), ke.Fc = 0, ke.Ec == null) {
                                ht = Ln(ke, 1, "no memory during frame initialization.");
                                break t;
                              }
                              ke.Vb = jt;
                            }
                            jt = ke.Ec, Kt = ke.Fc, ke.Ac = jt, ke.Bc = Kt, Kt += kt, ke.Gd = c(Br, Yo), ke.Hd = 0, ke.rb = c(yr + 1, ti), ke.sb = 1, ke.wa = si ? c(si, Qi) : null, ke.Y = 0, ke.D.Nb = 0, ke.D.wa = ke.wa, ke.D.Y = ke.Y, 0 < ke.Aa && (ke.D.Y += Wt), e(!0), ke.oc = jt, ke.pc = Kt, Kt += 832, ke.ya = c(Tr, ha), ke.aa = 0, ke.D.ya = ke.ya, ke.D.aa = ke.aa, ke.Aa == 2 && (ke.D.aa += Wt), ke.R = 16 * Wt, ke.B = 8 * Wt, Wt = (Br = ds[ke.L]) * ke.R, Br = Br / 2 * ke.B, ke.sa = jt, ke.ta = Kt + Wt, ke.qa = ke.sa, ke.ra = ke.ta + 16 * ht * ke.R + Br, ke.Ha = ke.qa, ke.Ia = ke.ra + 8 * ht * ke.B + Br, ke.$c = 0, Kt += tt, ke.mb = Ot ? jt : null, ke.nb = Ot ? Kt : null, e(Kt + Ot <= ke.Fc + ke.Vb), jl(ke), n(ke.Ac, ke.Bc, 0, kt), ht = 1;
                          }
                        }
                        if (ht) {
                          if (st.ka = 0, st.y = ke.sa, st.O = ke.ta, st.f = ke.qa, st.N = ke.ra, st.ea = ke.Ha, st.Vd = ke.Ia, st.fa = ke.R, st.Rc = ke.B, st.F = null, st.J = 0, !Yl) {
                            for (ht = -255; 255 >= ht; ++ht) Bu[255 + ht] = 0 > ht ? -ht : ht;
                            for (ht = -1020; 1020 >= ht; ++ht) Gc[1020 + ht] = -128 > ht ? -128 : 127 < ht ? 127 : ht;
                            for (ht = -112; 112 >= ht; ++ht) ku[112 + ht] = -16 > ht ? -16 : 15 < ht ? 15 : ht;
                            for (ht = -255; 510 >= ht; ++ht) tf[255 + ht] = 0 > ht ? 0 : 255 < ht ? 255 : ht;
                            Yl = 1;
                          }
                          Xi = ul, xn = ll, zc = Eu, ya = To, Iu = cl, Ga = Bc, Kh = F, dd = se, Qh = ut, Pu = Nt, Mu = Ie, Ru = Ye, hh = Ut, wl = vr, jc = ta, Zl = ra, _o = Na, ef = pl, io[0] = Bn, io[1] = kc, io[2] = Fn, io[3] = es, io[4] = ji, io[5] = on, io[6] = Oa, io[7] = Hn, io[8] = fl, io[9] = As, ba[0] = jr, ba[1] = Cu, ba[2] = So, ba[3] = Jr, ba[4] = Oc, ba[5] = hl, ba[6] = ka, Ci[0] = to, Ci[1] = Ba, Ci[2] = pa, Ci[3] = ki, Ci[4] = Or, Ci[5] = fi, Ci[6] = dl, ht = 1;
                        } else ht = 0;
                      }
                      ht && (ht = function(xi, zn) {
                        for (xi.M = 0; xi.M < xi.Va; ++xi.M) {
                          var ui, Pr = xi.Jc[xi.M & xi.Xb], lr = xi.m, Wr = xi;
                          for (ui = 0; ui < Wr.za; ++ui) {
                            var oi = lr, _i = Wr, Vi = _i.Ac, Xn = _i.Bc + 4 * ui, ps = _i.zc, fn = _i.ya[_i.aa + ui];
                            if (_i.Qa.Bb ? fn.$b = Vt(oi, _i.Pa.jb[0]) ? 2 + Vt(oi, _i.Pa.jb[2]) : Vt(oi, _i.Pa.jb[1]) : fn.$b = 0, _i.kc && (fn.Ad = Vt(oi, _i.Bd)), fn.Za = !Vt(oi, 145) + 0, fn.Za) {
                              var Zn = fn.Ob, dn = 0;
                              for (_i = 0; 4 > _i; ++_i) {
                                var pn, Qt = ps[0 + _i];
                                for (pn = 0; 4 > pn; ++pn) {
                                  Qt = cf[Vi[Xn + pn]][Qt];
                                  for (var cr = bh[Vt(oi, Qt[0])]; 0 < cr; ) cr = bh[2 * cr + Vt(oi, Qt[cr])];
                                  Qt = -cr, Vi[Xn + pn] = Qt;
                                }
                                i(Zn, dn, Vi, Xn, 4), dn += 4, ps[0 + _i] = Qt;
                              }
                            } else Qt = Vt(oi, 156) ? Vt(oi, 128) ? 1 : 3 : Vt(oi, 163) ? 2 : 0, fn.Ob[0] = Qt, n(Vi, Xn, Qt, 4), n(ps, 0, Qt, 4);
                            fn.Dd = Vt(oi, 142) ? Vt(oi, 114) ? Vt(oi, 183) ? 1 : 3 : 2 : 0;
                          }
                          if (Wr.m.Ka) return Ln(xi, 7, "Premature end-of-partition0 encountered.");
                          for (; xi.ja < xi.za; ++xi.ja) {
                            if (Wr = Pr, oi = (lr = xi).rb[lr.sb - 1], Vi = lr.rb[lr.sb + lr.ja], ui = lr.ya[lr.aa + lr.ja], Xn = lr.kc ? ui.Ad : 0) oi.la = Vi.la = 0, ui.Za || (oi.Na = Vi.Na = 0), ui.Hc = 0, ui.Gc = 0, ui.ia = 0;
                            else {
                              var Zi, Bi;
                              if (oi = Vi, Vi = Wr, Xn = lr.Pa.Xc, ps = lr.ya[lr.aa + lr.ja], fn = lr.pb[ps.$b], _i = ps.ad, Zn = 0, dn = lr.rb[lr.sb - 1], Qt = pn = 0, n(_i, Zn, 0, 384), ps.Za) var On = 0, ln = Xn[3];
                              else {
                                cr = s(16);
                                var Cn = oi.Na + dn.Na;
                                if (Cn = Uu(Vi, Xn[1], Cn, fn.Eb, 0, cr, 0), oi.Na = dn.Na = (0 < Cn) + 0, 1 < Cn) Xi(cr, 0, _i, Zn);
                                else {
                                  var gn = cr[0] + 3 >> 3;
                                  for (cr = 0; 256 > cr; cr += 16) _i[Zn + cr] = gn;
                                }
                                On = 1, ln = Xn[0];
                              }
                              var Gi = 15 & oi.la, Yn = 15 & dn.la;
                              for (cr = 0; 4 > cr; ++cr) {
                                var is = 1 & Yn;
                                for (gn = Bi = 0; 4 > gn; ++gn) Gi = Gi >> 1 | (is = (Cn = Uu(Vi, ln, Cn = is + (1 & Gi), fn.Sc, On, _i, Zn)) > On) << 7, Bi = Bi << 2 | (3 < Cn ? 3 : 1 < Cn ? 2 : _i[Zn + 0] != 0), Zn += 16;
                                Gi >>= 4, Yn = Yn >> 1 | is << 7, pn = (pn << 8 | Bi) >>> 0;
                              }
                              for (ln = Gi, On = Yn >> 4, Zi = 0; 4 > Zi; Zi += 2) {
                                for (Bi = 0, Gi = oi.la >> 4 + Zi, Yn = dn.la >> 4 + Zi, cr = 0; 2 > cr; ++cr) {
                                  for (is = 1 & Yn, gn = 0; 2 > gn; ++gn) Cn = is + (1 & Gi), Gi = Gi >> 1 | (is = 0 < (Cn = Uu(Vi, Xn[2], Cn, fn.Qc, 0, _i, Zn))) << 3, Bi = Bi << 2 | (3 < Cn ? 3 : 1 < Cn ? 2 : _i[Zn + 0] != 0), Zn += 16;
                                  Gi >>= 2, Yn = Yn >> 1 | is << 5;
                                }
                                Qt |= Bi << 4 * Zi, ln |= Gi << 4 << Zi, On |= (240 & Yn) << Zi;
                              }
                              oi.la = ln, dn.la = On, ps.Hc = pn, ps.Gc = Qt, ps.ia = 43690 & Qt ? 0 : fn.ia, Xn = !(pn | Qt);
                            }
                            if (0 < lr.L && (lr.wa[lr.Y + lr.ja] = lr.gd[ui.$b][ui.Za], lr.wa[lr.Y + lr.ja].La |= !Xn), Wr.Ka) return Ln(xi, 7, "Premature end-of-file encountered.");
                          }
                          if (jl(xi), lr = zn, Wr = 1, ui = (Pr = xi).D, oi = 0 < Pr.L && Pr.M >= Pr.zb && Pr.M <= Pr.Va, Pr.Aa == 0) t: {
                            if (ui.M = Pr.M, ui.uc = oi, na(Pr, ui), Wr = 1, ui = (Bi = Pr.D).Nb, oi = (Qt = ds[Pr.L]) * Pr.R, Vi = Qt / 2 * Pr.B, cr = 16 * ui * Pr.R, gn = 8 * ui * Pr.B, Xn = Pr.sa, ps = Pr.ta - oi + cr, fn = Pr.qa, _i = Pr.ra - Vi + gn, Zn = Pr.Ha, dn = Pr.Ia - Vi + gn, Yn = (Gi = Bi.M) == 0, pn = Gi >= Pr.Va - 1, Pr.Aa == 2 && na(Pr, Bi), Bi.uc) for (is = (Cn = Pr).D.M, e(Cn.D.uc), Bi = Cn.yb; Bi < Cn.Hb; ++Bi) {
                              On = Bi, ln = is;
                              var Hs = (gs = (wn = Cn).D).Nb;
                              Zi = wn.R;
                              var gs = gs.wa[gs.Y + On], wi = wn.sa, Ai = wn.ta + 16 * Hs * Zi + 16 * On, no = gs.dd, Di = gs.tc;
                              if (Di != 0) if (e(3 <= Di), wn.L == 1) 0 < On && Zl(wi, Ai, Zi, Di + 4), gs.La && ef(wi, Ai, Zi, Di), 0 < ln && jc(wi, Ai, Zi, Di + 4), gs.La && _o(wi, Ai, Zi, Di);
                              else {
                                var In = wn.B, so = wn.qa, oa = wn.ra + 8 * Hs * In + 8 * On, Ro = wn.Ha, wn = wn.Ia + 8 * Hs * In + 8 * On;
                                Hs = gs.ld, 0 < On && (dd(wi, Ai, Zi, Di + 4, no, Hs), Pu(so, oa, Ro, wn, In, Di + 4, no, Hs)), gs.La && (Ru(wi, Ai, Zi, Di, no, Hs), wl(so, oa, Ro, wn, In, Di, no, Hs)), 0 < ln && (Kh(wi, Ai, Zi, Di + 4, no, Hs), Qh(so, oa, Ro, wn, In, Di + 4, no, Hs)), gs.La && (Mu(wi, Ai, Zi, Di, no, Hs), hh(so, oa, Ro, wn, In, Di, no, Hs));
                              }
                            }
                            if (Pr.ia && alert("todo:DitherRow"), lr.put != null) {
                              if (Bi = 16 * Gi, Gi = 16 * (Gi + 1), Yn ? (lr.y = Pr.sa, lr.O = Pr.ta + cr, lr.f = Pr.qa, lr.N = Pr.ra + gn, lr.ea = Pr.Ha, lr.W = Pr.Ia + gn) : (Bi -= Qt, lr.y = Xn, lr.O = ps, lr.f = fn, lr.N = _i, lr.ea = Zn, lr.W = dn), pn || (Gi -= Qt), Gi > lr.o && (Gi = lr.o), lr.F = null, lr.J = null, Pr.Fa != null && 0 < Pr.Fa.length && Bi < Gi && (lr.J = Un(Pr, lr, Bi, Gi - Bi), lr.F = Pr.mb, lr.F == null && lr.F.length == 0)) {
                                Wr = Ln(Pr, 3, "Could not decode alpha data.");
                                break t;
                              }
                              Bi < lr.j && (Qt = lr.j - Bi, Bi = lr.j, e(!(1 & Qt)), lr.O += Pr.R * Qt, lr.N += Pr.B * (Qt >> 1), lr.W += Pr.B * (Qt >> 1), lr.F != null && (lr.J += lr.width * Qt)), Bi < Gi && (lr.O += lr.v, lr.N += lr.v >> 1, lr.W += lr.v >> 1, lr.F != null && (lr.J += lr.v), lr.ka = Bi - lr.j, lr.U = lr.va - lr.v, lr.T = Gi - Bi, Wr = lr.put(lr));
                            }
                            ui + 1 != Pr.Ic || pn || (i(Pr.sa, Pr.ta - oi, Xn, ps + 16 * Pr.R, oi), i(Pr.qa, Pr.ra - Vi, fn, _i + 8 * Pr.B, Vi), i(Pr.Ha, Pr.Ia - Vi, Zn, dn + 8 * Pr.B, Vi));
                          }
                          if (!Wr) return Ln(xi, 6, "Output aborted.");
                        }
                        return 1;
                      }(ke, st)), st.bc != null && st.bc(st), ht &= 1;
                    }
                    return ht ? (ke.cb = 0, ht) : 0;
                  })(C, W) || (L = C.a);
                }
              } else L = C.a;
            }
            L == 0 && ge.Oa != null && ge.Oa.fd && (L = js(ge.ba));
          }
          ge = L;
        }
        he = ge != 0 ? null : 11 > he ? ye.f.RGBA.eb : ye.f.kb.y;
      } else he = null;
      return he;
    };
    var df = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function m(oe, Ee) {
    for (var le = "", _e = 0; _e < 4; _e++) le += String.fromCharCode(oe[Ee++]);
    return le;
  }
  function y(oe, Ee) {
    return oe[Ee + 0] | oe[Ee + 1] << 8;
  }
  function T(oe, Ee) {
    return (oe[Ee + 0] | oe[Ee + 1] << 8 | oe[Ee + 2] << 16) >>> 0;
  }
  function P(oe, Ee) {
    return (oe[Ee + 0] | oe[Ee + 1] << 8 | oe[Ee + 2] << 16 | oe[Ee + 3] << 24) >>> 0;
  }
  new d();
  var I = [0], D = [0], k = [], $ = new d(), G = r, te = function(oe, Ee) {
    var le = {}, _e = 0, Ve = !1, Be = 0, gt = 0;
    if (le.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(fe, De) {
      for (var je = 0; je < 4; je++) if (fe[De + je] != "RIFF".charCodeAt(je)) return !0;
      return !1;
    }(oe, Ee)) {
      for (P(oe, Ee += 4), Ee += 8; Ee < oe.length; ) {
        var St = m(oe, Ee), Mt = P(oe, Ee += 4);
        Ee += 4;
        var mt = Mt + (1 & Mt);
        switch (St) {
          case "VP8 ":
          case "VP8L":
            le.frames[_e] === void 0 && (le.frames[_e] = {}), (Dt = le.frames[_e]).src_off = Ve ? gt : Ee - 8, Dt.src_size = Be + Mt + 8, _e++, Ve && (Ve = !1, Be = 0, gt = 0);
            break;
          case "VP8X":
            (Dt = le.header = {}).feature_flags = oe[Ee];
            var wt = Ee + 4;
            Dt.canvas_width = 1 + T(oe, wt), wt += 3, Dt.canvas_height = 1 + T(oe, wt), wt += 3;
            break;
          case "ALPH":
            Ve = !0, Be = mt + 8, gt = Ee - 8;
            break;
          case "ANIM":
            (Dt = le.header).bgcolor = P(oe, Ee), wt = Ee + 4, Dt.loop_count = y(oe, wt), wt += 2;
            break;
          case "ANMF":
            var Yt, Dt;
            (Dt = le.frames[_e] = {}).offset_x = 2 * T(oe, Ee), Ee += 3, Dt.offset_y = 2 * T(oe, Ee), Ee += 3, Dt.width = 1 + T(oe, Ee), Ee += 3, Dt.height = 1 + T(oe, Ee), Ee += 3, Dt.duration = T(oe, Ee), Ee += 3, Yt = oe[Ee++], Dt.dispose = 1 & Yt, Dt.blend = Yt >> 1 & 1;
        }
        St != "ANMF" && (Ee += mt);
      }
      return le;
    }
  }(G, 0);
  te.response = G, te.rgbaoutput = !0, te.dataurl = !1;
  var Z = te.header ? te.header : null, H = te.frames ? te.frames : null;
  if (Z) {
    Z.loop_counter = Z.loop_count, I = [Z.canvas_height], D = [Z.canvas_width];
    for (var J = 0; J < H.length && H[J].blend != 0; J++) ;
  }
  var re = H[0], be = $.WebPDecodeRGBA(G, re.src_off, re.src_size, D, I);
  re.rgba = be, re.imgwidth = D[0], re.imgheight = I[0];
  for (var pe = 0; pe < D[0] * I[0] * 4; pe++) k[pe] = be[pe];
  return this.width = D, this.height = I, this.data = k, this;
}
(function(r) {
  var e, t, i, n, s, c, o, d, m, y = function(fe) {
    return fe = fe || {}, this.isStrokeTransparent = fe.isStrokeTransparent || !1, this.strokeOpacity = fe.strokeOpacity || 1, this.strokeStyle = fe.strokeStyle || "#000000", this.fillStyle = fe.fillStyle || "#000000", this.isFillTransparent = fe.isFillTransparent || !1, this.fillOpacity = fe.fillOpacity || 1, this.font = fe.font || "10px sans-serif", this.textBaseline = fe.textBaseline || "alphabetic", this.textAlign = fe.textAlign || "left", this.lineWidth = fe.lineWidth || 1, this.lineJoin = fe.lineJoin || "miter", this.lineCap = fe.lineCap || "butt", this.path = fe.path || [], this.transform = fe.transform !== void 0 ? fe.transform.clone() : new d(), this.globalCompositeOperation = fe.globalCompositeOperation || "normal", this.globalAlpha = fe.globalAlpha || 1, this.clip_path = fe.clip_path || [], this.currentPoint = fe.currentPoint || new c(), this.miterLimit = fe.miterLimit || 10, this.lastPoint = fe.lastPoint || new c(), this.lineDashOffset = fe.lineDashOffset || 0, this.lineDash = fe.lineDash || [], this.margin = fe.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = fe.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof fe.ignoreClearRect != "boolean" || fe.ignoreClearRect, this;
  };
  r.events.push(["initialized", function() {
    this.context2d = new T(this), e = this.internal.f2, t = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, n = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, c = this.internal.Point, o = this.internal.Rectangle, d = this.internal.Matrix, m = new y();
  }]);
  var T = function(fe) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var De = fe;
    Object.defineProperty(this, "pdf", { get: function() {
      return De;
    } });
    var je = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return je;
    }, set: function(Ct) {
      je = !!Ct;
    } });
    var Ke = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Ke;
    }, set: function(Ct) {
      Ke = !!Ct;
    } });
    var rt = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return rt;
    }, set: function(Ct) {
      isNaN(Ct) || (rt = Ct);
    } });
    var at = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return at;
    }, set: function(Ct) {
      isNaN(Ct) || (at = Ct);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return m.margin;
    }, set: function(Ct) {
      var Oe;
      typeof Ct == "number" ? Oe = [Ct, Ct, Ct, Ct] : ((Oe = new Array(4))[0] = Ct[0], Oe[1] = Ct.length >= 2 ? Ct[1] : Oe[0], Oe[2] = Ct.length >= 3 ? Ct[2] : Oe[0], Oe[3] = Ct.length >= 4 ? Ct[3] : Oe[1]), m.margin = Oe;
    } });
    var Et = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return Et;
    }, set: function(Ct) {
      Et = Ct;
    } });
    var Tt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Tt;
    }, set: function(Ct) {
      Tt = Ct;
    } });
    var Vt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return Vt;
    }, set: function(Ct) {
      Vt = Ct;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return m;
    }, set: function(Ct) {
      Ct instanceof y && (m = Ct);
    } }), Object.defineProperty(this, "path", { get: function() {
      return m.path;
    }, set: function(Ct) {
      m.path = Ct;
    } });
    var tr = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return tr;
    }, set: function(Ct) {
      tr = Ct;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(Ct) {
      var Oe;
      Oe = P(Ct), this.ctx.fillStyle = Oe.style, this.ctx.isFillTransparent = Oe.a === 0, this.ctx.fillOpacity = Oe.a, this.pdf.setFillColor(Oe.r, Oe.g, Oe.b, { a: Oe.a }), this.pdf.setTextColor(Oe.r, Oe.g, Oe.b, { a: Oe.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(Ct) {
      var Oe = P(Ct);
      this.ctx.strokeStyle = Oe.style, this.ctx.isStrokeTransparent = Oe.a === 0, this.ctx.strokeOpacity = Oe.a, Oe.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Oe.a, this.pdf.setDrawColor(Oe.r, Oe.g, Oe.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(Ct) {
      ["butt", "round", "square"].indexOf(Ct) !== -1 && (this.ctx.lineCap = Ct, this.pdf.setLineCap(Ct));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(Ct) {
      isNaN(Ct) || (this.ctx.lineWidth = Ct, this.pdf.setLineWidth(Ct));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(Ct) {
      ["bevel", "round", "miter"].indexOf(Ct) !== -1 && (this.ctx.lineJoin = Ct, this.pdf.setLineJoin(Ct));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(Ct) {
      isNaN(Ct) || (this.ctx.miterLimit = Ct, this.pdf.setMiterLimit(Ct));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(Ct) {
      this.ctx.textBaseline = Ct;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(Ct) {
      ["right", "end", "center", "left", "start"].indexOf(Ct) !== -1 && (this.ctx.textAlign = Ct);
    } });
    var ur = null, dr = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return dr;
    }, set: function(Ct) {
      ur = null, dr = Ct;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(Ct) {
      var Oe;
      if (this.ctx.font = Ct, (Oe = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Ct)) !== null) {
        var ii = Oe[1];
        Oe[2];
        var Zr = Oe[3], Rr = Oe[4];
        Oe[5];
        var Jt = Oe[6], Sr = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(Rr)[2];
        Rr = Math.floor(Sr === "px" ? parseFloat(Rr) * this.pdf.internal.scaleFactor : Sr === "em" ? parseFloat(Rr) * this.pdf.getFontSize() : parseFloat(Rr) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(Rr);
        var hr = function(Ue) {
          var K, ne, de = [], Te = Ue.trim();
          if (Te === "") return PC;
          if (Te in xC) return [xC[Te]];
          for (; Te !== ""; ) {
            switch (ne = null, K = (Te = AC(Te)).charAt(0)) {
              case '"':
              case "'":
                ne = Bee(Te.substring(1), K);
                break;
              default:
                ne = kee(Te);
            }
            if (ne === null || (de.push(ne[0]), (Te = AC(ne[1])) !== "" && Te.charAt(0) !== ",")) return PC;
            Te = Te.replace(/^,/, "");
          }
          return de;
        }(Jt);
        if (this.fontFaces) {
          var qr = function(Ue, K) {
            if (ur === null) {
              var ne = function(de) {
                var Te = [];
                return Object.keys(de).forEach(function(Pe) {
                  de[Pe].forEach(function(qe) {
                    var Je = null;
                    switch (qe) {
                      case "bold":
                        Je = { family: Pe, weight: "bold" };
                        break;
                      case "italic":
                        Je = { family: Pe, style: "italic" };
                        break;
                      case "bolditalic":
                        Je = { family: Pe, weight: "bold", style: "italic" };
                        break;
                      case "":
                      case "normal":
                        Je = { family: Pe };
                    }
                    Je !== null && (Je.ref = { name: Pe, style: qe }, Te.push(Je));
                  });
                }), Te;
              }(Ue.getFontList());
              ur = function(de) {
                for (var Te = {}, Pe = 0; Pe < de.length; ++Pe) {
                  var qe = N1(de[Pe]), Je = qe.family, He = qe.stretch, nt = qe.style, Bt = qe.weight;
                  Te[Je] = Te[Je] || {}, Te[Je][He] = Te[Je][He] || {}, Te[Je][He][nt] = Te[Je][He][nt] || {}, Te[Je][He][nt][Bt] = qe;
                }
                return Te;
              }(ne.concat(K));
            }
            return ur;
          }(this.pdf, this.fontFaces), xr = hr.map(function(Ue) {
            return { family: Ue, stretch: "normal", weight: Zr, style: ii };
          }), bi = function(Ue, K, ne) {
            for (var de = (ne = ne || {}).defaultFontFamily || "times", Te = Object.assign({}, Lee, ne.genericFontFamilies || {}), Pe = null, qe = null, Je = 0; Je < K.length; ++Je) if (Te[(Pe = N1(K[Je])).family] && (Pe.family = Te[Pe.family]), Ue.hasOwnProperty(Pe.family)) {
              qe = Ue[Pe.family];
              break;
            }
            if (!(qe = qe || Ue[de])) throw new Error("Could not find a font-family for the rule '" + wC(Pe) + "' and default family '" + de + "'.");
            if (qe = function(He, nt) {
              if (nt[He]) return nt[He];
              var Bt = c2[He], It = Bt <= c2.normal ? -1 : 1, rr = vC(nt, qR, Bt, It);
              if (!rr) throw new Error("Could not find a matching font-stretch value for " + He);
              return rr;
            }(Pe.stretch, qe), qe = function(He, nt) {
              if (nt[He]) return nt[He];
              for (var Bt = HR[He], It = 0; It < Bt.length; ++It) if (nt[Bt[It]]) return nt[Bt[It]];
              throw new Error("Could not find a matching font-style for " + He);
            }(Pe.style, qe), !(qe = function(He, nt) {
              if (nt[He]) return nt[He];
              if (He === 400 && nt[500]) return nt[500];
              if (He === 500 && nt[400]) return nt[400];
              var Bt = Ree[He], It = vC(nt, WR, Bt, He < 400 ? -1 : 1);
              if (!It) throw new Error("Could not find a matching font-weight for value " + He);
              return It;
            }(Pe.weight, qe))) throw new Error("Failed to resolve a font for the rule '" + wC(Pe) + "'.");
            return qe;
          }(qr, xr);
          this.pdf.setFont(bi.ref.name, bi.ref.style);
        } else {
          var Yr = "";
          (Zr === "bold" || parseInt(Zr, 10) >= 700 || ii === "bold") && (Yr = "bold"), ii === "italic" && (Yr += "italic"), Yr.length === 0 && (Yr = "normal");
          for (var Fr = "", Ri = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Kr = 0; Kr < hr.length; Kr++) {
            if (this.pdf.internal.getFont(hr[Kr], Yr, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Fr = hr[Kr];
              break;
            }
            if (Yr === "bolditalic" && this.pdf.internal.getFont(hr[Kr], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Fr = hr[Kr], Yr = "bold";
            else if (this.pdf.internal.getFont(hr[Kr], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Fr = hr[Kr], Yr = "normal";
              break;
            }
          }
          if (Fr === "") {
            for (var wr = 0; wr < hr.length; wr++) if (Ri[hr[wr]]) {
              Fr = Ri[hr[wr]];
              break;
            }
          }
          Fr = Fr === "" ? "Times" : Fr, this.pdf.setFont(Fr, Yr);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(Ct) {
      this.ctx.globalCompositeOperation = Ct;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(Ct) {
      this.ctx.globalAlpha = Ct;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(Ct) {
      this.ctx.lineDashOffset = Ct, Dt.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(Ct) {
      this.ctx.lineDash = Ct, Dt.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(Ct) {
      this.ctx.ignoreClearRect = !!Ct;
    } });
  };
  T.prototype.setLineDash = function(fe) {
    this.lineDash = fe;
  }, T.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, T.prototype.fill = function() {
    H.call(this, "fill", !1);
  }, T.prototype.stroke = function() {
    H.call(this, "stroke", !1);
  }, T.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, T.prototype.moveTo = function(fe, De) {
    if (isNaN(fe) || isNaN(De)) throw An.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var je = this.ctx.transform.applyToPoint(new c(fe, De));
    this.path.push({ type: "mt", x: je.x, y: je.y }), this.ctx.lastPoint = new c(fe, De);
  }, T.prototype.closePath = function() {
    var fe = new c(0, 0), De = 0;
    for (De = this.path.length - 1; De !== -1; De--) if (this.path[De].type === "begin" && un(this.path[De + 1]) === "object" && typeof this.path[De + 1].x == "number") {
      fe = new c(this.path[De + 1].x, this.path[De + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c(fe.x, fe.y);
  }, T.prototype.lineTo = function(fe, De) {
    if (isNaN(fe) || isNaN(De)) throw An.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var je = this.ctx.transform.applyToPoint(new c(fe, De));
    this.path.push({ type: "lt", x: je.x, y: je.y }), this.ctx.lastPoint = new c(je.x, je.y);
  }, T.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), H.call(this, null, !0);
  }, T.prototype.quadraticCurveTo = function(fe, De, je, Ke) {
    if (isNaN(je) || isNaN(Ke) || isNaN(fe) || isNaN(De)) throw An.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var rt = this.ctx.transform.applyToPoint(new c(je, Ke)), at = this.ctx.transform.applyToPoint(new c(fe, De));
    this.path.push({ type: "qct", x1: at.x, y1: at.y, x: rt.x, y: rt.y }), this.ctx.lastPoint = new c(rt.x, rt.y);
  }, T.prototype.bezierCurveTo = function(fe, De, je, Ke, rt, at) {
    if (isNaN(rt) || isNaN(at) || isNaN(fe) || isNaN(De) || isNaN(je) || isNaN(Ke)) throw An.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var Et = this.ctx.transform.applyToPoint(new c(rt, at)), Tt = this.ctx.transform.applyToPoint(new c(fe, De)), Vt = this.ctx.transform.applyToPoint(new c(je, Ke));
    this.path.push({ type: "bct", x1: Tt.x, y1: Tt.y, x2: Vt.x, y2: Vt.y, x: Et.x, y: Et.y }), this.ctx.lastPoint = new c(Et.x, Et.y);
  }, T.prototype.arc = function(fe, De, je, Ke, rt, at) {
    if (isNaN(fe) || isNaN(De) || isNaN(je) || isNaN(Ke) || isNaN(rt)) throw An.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (at = !!at, !this.ctx.transform.isIdentity) {
      var Et = this.ctx.transform.applyToPoint(new c(fe, De));
      fe = Et.x, De = Et.y;
      var Tt = this.ctx.transform.applyToPoint(new c(0, je)), Vt = this.ctx.transform.applyToPoint(new c(0, 0));
      je = Math.sqrt(Math.pow(Tt.x - Vt.x, 2) + Math.pow(Tt.y - Vt.y, 2));
    }
    Math.abs(rt - Ke) >= 2 * Math.PI && (Ke = 0, rt = 2 * Math.PI), this.path.push({ type: "arc", x: fe, y: De, radius: je, startAngle: Ke, endAngle: rt, counterclockwise: at });
  }, T.prototype.arcTo = function(fe, De, je, Ke, rt) {
    throw new Error("arcTo not implemented.");
  }, T.prototype.rect = function(fe, De, je, Ke) {
    if (isNaN(fe) || isNaN(De) || isNaN(je) || isNaN(Ke)) throw An.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(fe, De), this.lineTo(fe + je, De), this.lineTo(fe + je, De + Ke), this.lineTo(fe, De + Ke), this.lineTo(fe, De), this.lineTo(fe + je, De), this.lineTo(fe, De);
  }, T.prototype.fillRect = function(fe, De, je, Ke) {
    if (isNaN(fe) || isNaN(De) || isNaN(je) || isNaN(Ke)) throw An.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!I.call(this)) {
      var rt = {};
      this.lineCap !== "butt" && (rt.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (rt.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(fe, De, je, Ke), this.fill(), rt.hasOwnProperty("lineCap") && (this.lineCap = rt.lineCap), rt.hasOwnProperty("lineJoin") && (this.lineJoin = rt.lineJoin);
    }
  }, T.prototype.strokeRect = function(fe, De, je, Ke) {
    if (isNaN(fe) || isNaN(De) || isNaN(je) || isNaN(Ke)) throw An.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    D.call(this) || (this.beginPath(), this.rect(fe, De, je, Ke), this.stroke());
  }, T.prototype.clearRect = function(fe, De, je, Ke) {
    if (isNaN(fe) || isNaN(De) || isNaN(je) || isNaN(Ke)) throw An.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(fe, De, je, Ke));
  }, T.prototype.save = function(fe) {
    fe = typeof fe != "boolean" || fe;
    for (var De = this.pdf.internal.getCurrentPageInfo().pageNumber, je = 0; je < this.pdf.internal.getNumberOfPages(); je++) this.pdf.setPage(je + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(De), fe) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Ke = new y(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Ke;
    }
  }, T.prototype.restore = function(fe) {
    fe = typeof fe != "boolean" || fe;
    for (var De = this.pdf.internal.getCurrentPageInfo().pageNumber, je = 0; je < this.pdf.internal.getNumberOfPages(); je++) this.pdf.setPage(je + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(De), fe && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, T.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var P = function(fe) {
    var De, je, Ke, rt;
    if (fe.isCanvasGradient === !0 && (fe = fe.getColor()), !fe) return { r: 0, g: 0, b: 0, a: 0, style: fe };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(fe)) De = 0, je = 0, Ke = 0, rt = 0;
    else {
      var at = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(fe);
      if (at !== null) De = parseInt(at[1]), je = parseInt(at[2]), Ke = parseInt(at[3]), rt = 1;
      else if ((at = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(fe)) !== null) De = parseInt(at[1]), je = parseInt(at[2]), Ke = parseInt(at[3]), rt = parseFloat(at[4]);
      else {
        if (rt = 1, typeof fe == "string" && fe.charAt(0) !== "#") {
          var Et = new FR(fe);
          fe = Et.ok ? Et.toHex() : "#000000";
        }
        fe.length === 4 ? (De = fe.substring(1, 2), De += De, je = fe.substring(2, 3), je += je, Ke = fe.substring(3, 4), Ke += Ke) : (De = fe.substring(1, 3), je = fe.substring(3, 5), Ke = fe.substring(5, 7)), De = parseInt(De, 16), je = parseInt(je, 16), Ke = parseInt(Ke, 16);
      }
    }
    return { r: De, g: je, b: Ke, a: rt, style: fe };
  }, I = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, D = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  T.prototype.fillText = function(fe, De, je, Ke) {
    if (isNaN(De) || isNaN(je) || typeof fe != "string") throw An.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Ke = isNaN(Ke) ? void 0 : Ke, !I.call(this)) {
      var rt = mt(this.ctx.transform.rotation), at = this.ctx.transform.scaleX;
      _e.call(this, { text: fe, x: De, y: je, scale: at, angle: rt, align: this.textAlign, maxWidth: Ke });
    }
  }, T.prototype.strokeText = function(fe, De, je, Ke) {
    if (isNaN(De) || isNaN(je) || typeof fe != "string") throw An.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!D.call(this)) {
      Ke = isNaN(Ke) ? void 0 : Ke;
      var rt = mt(this.ctx.transform.rotation), at = this.ctx.transform.scaleX;
      _e.call(this, { text: fe, x: De, y: je, scale: at, renderingMode: "stroke", angle: rt, align: this.textAlign, maxWidth: Ke });
    }
  }, T.prototype.measureText = function(fe) {
    if (typeof fe != "string") throw An.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var De = this.pdf, je = this.pdf.internal.scaleFactor, Ke = De.internal.getFontSize(), rt = De.getStringUnitWidth(fe) * Ke / De.internal.scaleFactor;
    return new function(at) {
      var Et = (at = at || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Et;
      } }), this;
    }({ width: rt *= Math.round(96 * je / 72 * 1e4) / 1e4 });
  }, T.prototype.scale = function(fe, De) {
    if (isNaN(fe) || isNaN(De)) throw An.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var je = new d(fe, 0, 0, De, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(je);
  }, T.prototype.rotate = function(fe) {
    if (isNaN(fe)) throw An.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var De = new d(Math.cos(fe), Math.sin(fe), -Math.sin(fe), Math.cos(fe), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(De);
  }, T.prototype.translate = function(fe, De) {
    if (isNaN(fe) || isNaN(De)) throw An.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var je = new d(1, 0, 0, 1, fe, De);
    this.ctx.transform = this.ctx.transform.multiply(je);
  }, T.prototype.transform = function(fe, De, je, Ke, rt, at) {
    if (isNaN(fe) || isNaN(De) || isNaN(je) || isNaN(Ke) || isNaN(rt) || isNaN(at)) throw An.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var Et = new d(fe, De, je, Ke, rt, at);
    this.ctx.transform = this.ctx.transform.multiply(Et);
  }, T.prototype.setTransform = function(fe, De, je, Ke, rt, at) {
    fe = isNaN(fe) ? 1 : fe, De = isNaN(De) ? 0 : De, je = isNaN(je) ? 0 : je, Ke = isNaN(Ke) ? 1 : Ke, rt = isNaN(rt) ? 0 : rt, at = isNaN(at) ? 0 : at, this.ctx.transform = new d(fe, De, je, Ke, rt, at);
  };
  var k = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  T.prototype.drawImage = function(fe, De, je, Ke, rt, at, Et, Tt, Vt) {
    var tr = this.pdf.getImageProperties(fe), ur = 1, dr = 1, Ct = 1, Oe = 1;
    Ke !== void 0 && Tt !== void 0 && (Ct = Tt / Ke, Oe = Vt / rt, ur = tr.width / Ke * Tt / Ke, dr = tr.height / rt * Vt / rt), at === void 0 && (at = De, Et = je, De = 0, je = 0), Ke !== void 0 && Tt === void 0 && (Tt = Ke, Vt = rt), Ke === void 0 && Tt === void 0 && (Tt = tr.width, Vt = tr.height);
    for (var ii, Zr = this.ctx.transform.decompose(), Rr = mt(Zr.rotate.shx), Jt = new d(), Sr = (Jt = (Jt = (Jt = Jt.multiply(Zr.translate)).multiply(Zr.skew)).multiply(Zr.scale)).applyToRectangle(new o(at - De * Ct, Et - je * Oe, Ke * ur, rt * dr)), hr = $.call(this, Sr), qr = [], xr = 0; xr < hr.length; xr += 1) qr.indexOf(hr[xr]) === -1 && qr.push(hr[xr]);
    if (Z(qr), this.autoPaging) for (var bi = qr[0], Yr = qr[qr.length - 1], Fr = bi; Fr < Yr + 1; Fr++) {
      this.pdf.setPage(Fr);
      var Ri = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Kr = Fr === 1 ? this.posY + this.margin[0] : this.margin[0], wr = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Ue = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], K = Fr === 1 ? 0 : wr + (Fr - 2) * Ue;
      if (this.ctx.clip_path.length !== 0) {
        var ne = this.path;
        ii = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = te(ii, this.posX + this.margin[3], -K + Kr + this.ctx.prevPageLastElemOffset), J.call(this, "fill", !0), this.path = ne;
      }
      var de = JSON.parse(JSON.stringify(Sr));
      de = te([de], this.posX + this.margin[3], -K + Kr + this.ctx.prevPageLastElemOffset)[0];
      var Te = (Fr > bi || Fr < Yr) && k.call(this);
      Te && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ri, Ue, null).clip().discardPath()), this.pdf.addImage(fe, "JPEG", de.x, de.y, de.w, de.h, null, null, Rr), Te && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(fe, "JPEG", Sr.x, Sr.y, Sr.w, Sr.h, null, null, Rr);
  };
  var $ = function(fe, De, je) {
    var Ke = [];
    De = De || this.pdf.internal.pageSize.width, je = je || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var rt = this.posY + this.ctx.prevPageLastElemOffset;
    switch (fe.type) {
      default:
      case "mt":
      case "lt":
        Ke.push(Math.floor((fe.y + rt) / je) + 1);
        break;
      case "arc":
        Ke.push(Math.floor((fe.y + rt - fe.radius) / je) + 1), Ke.push(Math.floor((fe.y + rt + fe.radius) / je) + 1);
        break;
      case "qct":
        var at = wt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, fe.x1, fe.y1, fe.x, fe.y);
        Ke.push(Math.floor((at.y + rt) / je) + 1), Ke.push(Math.floor((at.y + at.h + rt) / je) + 1);
        break;
      case "bct":
        var Et = Yt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, fe.x1, fe.y1, fe.x2, fe.y2, fe.x, fe.y);
        Ke.push(Math.floor((Et.y + rt) / je) + 1), Ke.push(Math.floor((Et.y + Et.h + rt) / je) + 1);
        break;
      case "rect":
        Ke.push(Math.floor((fe.y + rt) / je) + 1), Ke.push(Math.floor((fe.y + fe.h + rt) / je) + 1);
    }
    for (var Tt = 0; Tt < Ke.length; Tt += 1) for (; this.pdf.internal.getNumberOfPages() < Ke[Tt]; ) G.call(this);
    return Ke;
  }, G = function() {
    var fe = this.fillStyle, De = this.strokeStyle, je = this.font, Ke = this.lineCap, rt = this.lineWidth, at = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = fe, this.strokeStyle = De, this.font = je, this.lineCap = Ke, this.lineWidth = rt, this.lineJoin = at;
  }, te = function(fe, De, je) {
    for (var Ke = 0; Ke < fe.length; Ke++) switch (fe[Ke].type) {
      case "bct":
        fe[Ke].x2 += De, fe[Ke].y2 += je;
      case "qct":
        fe[Ke].x1 += De, fe[Ke].y1 += je;
      default:
        fe[Ke].x += De, fe[Ke].y += je;
    }
    return fe;
  }, Z = function(fe) {
    return fe.sort(function(De, je) {
      return De - je;
    });
  }, H = function(fe, De) {
    for (var je, Ke, rt = this.fillStyle, at = this.strokeStyle, Et = this.lineCap, Tt = this.lineWidth, Vt = Math.abs(Tt * this.ctx.transform.scaleX), tr = this.lineJoin, ur = JSON.parse(JSON.stringify(this.path)), dr = JSON.parse(JSON.stringify(this.path)), Ct = [], Oe = 0; Oe < dr.length; Oe++) if (dr[Oe].x !== void 0) for (var ii = $.call(this, dr[Oe]), Zr = 0; Zr < ii.length; Zr += 1) Ct.indexOf(ii[Zr]) === -1 && Ct.push(ii[Zr]);
    for (var Rr = 0; Rr < Ct.length; Rr++) for (; this.pdf.internal.getNumberOfPages() < Ct[Rr]; ) G.call(this);
    if (Z(Ct), this.autoPaging) for (var Jt = Ct[0], Sr = Ct[Ct.length - 1], hr = Jt; hr < Sr + 1; hr++) {
      this.pdf.setPage(hr), this.fillStyle = rt, this.strokeStyle = at, this.lineCap = Et, this.lineWidth = Vt, this.lineJoin = tr;
      var qr = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], xr = hr === 1 ? this.posY + this.margin[0] : this.margin[0], bi = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Yr = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Fr = hr === 1 ? 0 : bi + (hr - 2) * Yr;
      if (this.ctx.clip_path.length !== 0) {
        var Ri = this.path;
        je = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = te(je, this.posX + this.margin[3], -Fr + xr + this.ctx.prevPageLastElemOffset), J.call(this, fe, !0), this.path = Ri;
      }
      if (Ke = JSON.parse(JSON.stringify(ur)), this.path = te(Ke, this.posX + this.margin[3], -Fr + xr + this.ctx.prevPageLastElemOffset), De === !1 || hr === 0) {
        var Kr = (hr > Jt || hr < Sr) && k.call(this);
        Kr && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], qr, Yr, null).clip().discardPath()), J.call(this, fe, De), Kr && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Tt;
    }
    else this.lineWidth = Vt, J.call(this, fe, De), this.lineWidth = Tt;
    this.path = ur;
  }, J = function(fe, De) {
    if ((fe !== "stroke" || De || !D.call(this)) && (fe === "stroke" || De || !I.call(this))) {
      for (var je, Ke, rt = [], at = this.path, Et = 0; Et < at.length; Et++) {
        var Tt = at[Et];
        switch (Tt.type) {
          case "begin":
            rt.push({ begin: !0 });
            break;
          case "close":
            rt.push({ close: !0 });
            break;
          case "mt":
            rt.push({ start: Tt, deltas: [], abs: [] });
            break;
          case "lt":
            var Vt = rt.length;
            if (at[Et - 1] && !isNaN(at[Et - 1].x) && (je = [Tt.x - at[Et - 1].x, Tt.y - at[Et - 1].y], Vt > 0)) {
              for (; Vt >= 0; Vt--) if (rt[Vt - 1].close !== !0 && rt[Vt - 1].begin !== !0) {
                rt[Vt - 1].deltas.push(je), rt[Vt - 1].abs.push(Tt);
                break;
              }
            }
            break;
          case "bct":
            je = [Tt.x1 - at[Et - 1].x, Tt.y1 - at[Et - 1].y, Tt.x2 - at[Et - 1].x, Tt.y2 - at[Et - 1].y, Tt.x - at[Et - 1].x, Tt.y - at[Et - 1].y], rt[rt.length - 1].deltas.push(je);
            break;
          case "qct":
            var tr = at[Et - 1].x + 2 / 3 * (Tt.x1 - at[Et - 1].x), ur = at[Et - 1].y + 2 / 3 * (Tt.y1 - at[Et - 1].y), dr = Tt.x + 2 / 3 * (Tt.x1 - Tt.x), Ct = Tt.y + 2 / 3 * (Tt.y1 - Tt.y), Oe = Tt.x, ii = Tt.y;
            je = [tr - at[Et - 1].x, ur - at[Et - 1].y, dr - at[Et - 1].x, Ct - at[Et - 1].y, Oe - at[Et - 1].x, ii - at[Et - 1].y], rt[rt.length - 1].deltas.push(je);
            break;
          case "arc":
            rt.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(rt[rt.length - 1].abs) && rt[rt.length - 1].abs.push(Tt);
        }
      }
      Ke = De ? null : fe === "stroke" ? "stroke" : "fill";
      for (var Zr = !1, Rr = 0; Rr < rt.length; Rr++) if (rt[Rr].arc) for (var Jt = rt[Rr].abs, Sr = 0; Sr < Jt.length; Sr++) {
        var hr = Jt[Sr];
        hr.type === "arc" ? pe.call(this, hr.x, hr.y, hr.radius, hr.startAngle, hr.endAngle, hr.counterclockwise, void 0, De, !Zr) : Ve.call(this, hr.x, hr.y), Zr = !0;
      }
      else if (rt[Rr].close === !0) this.pdf.internal.out("h"), Zr = !1;
      else if (rt[Rr].begin !== !0) {
        var qr = rt[Rr].start.x, xr = rt[Rr].start.y;
        Be.call(this, rt[Rr].deltas, qr, xr), Zr = !0;
      }
      Ke && oe.call(this, Ke), De && Ee.call(this);
    }
  }, re = function(fe) {
    var De = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, je = De * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return fe - je;
      case "top":
        return fe + De - je;
      case "hanging":
        return fe + De - 2 * je;
      case "middle":
        return fe + De / 2 - je;
      default:
        return fe;
    }
  }, be = function(fe) {
    return fe + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  T.prototype.createLinearGradient = function() {
    var fe = function() {
    };
    return fe.colorStops = [], fe.addColorStop = function(De, je) {
      this.colorStops.push([De, je]);
    }, fe.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, fe.isCanvasGradient = !0, fe;
  }, T.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, T.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var pe = function(fe, De, je, Ke, rt, at, Et, Tt, Vt) {
    for (var tr = St.call(this, je, Ke, rt, at), ur = 0; ur < tr.length; ur++) {
      var dr = tr[ur];
      ur === 0 && (Vt ? le.call(this, dr.x1 + fe, dr.y1 + De) : Ve.call(this, dr.x1 + fe, dr.y1 + De)), gt.call(this, fe, De, dr.x2, dr.y2, dr.x3, dr.y3, dr.x4, dr.y4);
    }
    Tt ? Ee.call(this) : oe.call(this, Et);
  }, oe = function(fe) {
    switch (fe) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, Ee = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, le = function(fe, De) {
    this.pdf.internal.out(t(fe) + " " + i(De) + " m");
  }, _e = function(fe) {
    var De;
    switch (fe.align) {
      case "right":
      case "end":
        De = "right";
        break;
      case "center":
        De = "center";
        break;
      default:
        De = "left";
    }
    var je = this.pdf.getTextDimensions(fe.text), Ke = re.call(this, fe.y), rt = be.call(this, Ke) - je.h, at = this.ctx.transform.applyToPoint(new c(fe.x, Ke)), Et = this.ctx.transform.decompose(), Tt = new d();
    Tt = (Tt = (Tt = Tt.multiply(Et.translate)).multiply(Et.skew)).multiply(Et.scale);
    for (var Vt, tr, ur, dr = this.ctx.transform.applyToRectangle(new o(fe.x, Ke, je.w, je.h)), Ct = Tt.applyToRectangle(new o(fe.x, rt, je.w, je.h)), Oe = $.call(this, Ct), ii = [], Zr = 0; Zr < Oe.length; Zr += 1) ii.indexOf(Oe[Zr]) === -1 && ii.push(Oe[Zr]);
    if (Z(ii), this.autoPaging) for (var Rr = ii[0], Jt = ii[ii.length - 1], Sr = Rr; Sr < Jt + 1; Sr++) {
      this.pdf.setPage(Sr);
      var hr = Sr === 1 ? this.posY + this.margin[0] : this.margin[0], qr = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], xr = this.pdf.internal.pageSize.height - this.margin[2], bi = xr - this.margin[0], Yr = this.pdf.internal.pageSize.width - this.margin[1], Fr = Yr - this.margin[3], Ri = Sr === 1 ? 0 : qr + (Sr - 2) * bi;
      if (this.ctx.clip_path.length !== 0) {
        var Kr = this.path;
        Vt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = te(Vt, this.posX + this.margin[3], -1 * Ri + hr), J.call(this, "fill", !0), this.path = Kr;
      }
      var wr = te([JSON.parse(JSON.stringify(Ct))], this.posX + this.margin[3], -Ri + hr + this.ctx.prevPageLastElemOffset)[0];
      fe.scale >= 0.01 && (tr = this.pdf.internal.getFontSize(), this.pdf.setFontSize(tr * fe.scale), ur = this.lineWidth, this.lineWidth = ur * fe.scale);
      var Ue = this.autoPaging !== "text";
      if (Ue || wr.y + wr.h <= xr) {
        if (Ue || wr.y >= hr && wr.x <= Yr) {
          var K = Ue ? fe.text : this.pdf.splitTextToSize(fe.text, fe.maxWidth || Yr - wr.x)[0], ne = te([JSON.parse(JSON.stringify(dr))], this.posX + this.margin[3], -Ri + hr + this.ctx.prevPageLastElemOffset)[0], de = Ue && (Sr > Rr || Sr < Jt) && k.call(this);
          de && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Fr, bi, null).clip().discardPath()), this.pdf.text(K, ne.x, ne.y, { angle: fe.angle, align: De, renderingMode: fe.renderingMode }), de && this.pdf.restoreGraphicsState();
        }
      } else wr.y < xr && (this.ctx.prevPageLastElemOffset += xr - wr.y);
      fe.scale >= 0.01 && (this.pdf.setFontSize(tr), this.lineWidth = ur);
    }
    else fe.scale >= 0.01 && (tr = this.pdf.internal.getFontSize(), this.pdf.setFontSize(tr * fe.scale), ur = this.lineWidth, this.lineWidth = ur * fe.scale), this.pdf.text(fe.text, at.x + this.posX, at.y + this.posY, { angle: fe.angle, align: De, renderingMode: fe.renderingMode, maxWidth: fe.maxWidth }), fe.scale >= 0.01 && (this.pdf.setFontSize(tr), this.lineWidth = ur);
  }, Ve = function(fe, De, je, Ke) {
    je = je || 0, Ke = Ke || 0, this.pdf.internal.out(t(fe + je) + " " + i(De + Ke) + " l");
  }, Be = function(fe, De, je) {
    return this.pdf.lines(fe, De, je, null, null);
  }, gt = function(fe, De, je, Ke, rt, at, Et, Tt) {
    this.pdf.internal.out([e(n(je + fe)), e(s(Ke + De)), e(n(rt + fe)), e(s(at + De)), e(n(Et + fe)), e(s(Tt + De)), "c"].join(" "));
  }, St = function(fe, De, je, Ke) {
    for (var rt = 2 * Math.PI, at = Math.PI / 2; De > je; ) De -= rt;
    var Et = Math.abs(je - De);
    Et < rt && Ke && (Et = rt - Et);
    for (var Tt = [], Vt = Ke ? -1 : 1, tr = De; Et > 1e-5; ) {
      var ur = tr + Vt * Math.min(Et, at);
      Tt.push(Mt.call(this, fe, tr, ur)), Et -= Math.abs(ur - tr), tr = ur;
    }
    return Tt;
  }, Mt = function(fe, De, je) {
    var Ke = (je - De) / 2, rt = fe * Math.cos(Ke), at = fe * Math.sin(Ke), Et = rt, Tt = -at, Vt = Et * Et + Tt * Tt, tr = Vt + Et * rt + Tt * at, ur = 4 / 3 * (Math.sqrt(2 * Vt * tr) - tr) / (Et * at - Tt * rt), dr = Et - ur * Tt, Ct = Tt + ur * Et, Oe = dr, ii = -Ct, Zr = Ke + De, Rr = Math.cos(Zr), Jt = Math.sin(Zr);
    return { x1: fe * Math.cos(De), y1: fe * Math.sin(De), x2: dr * Rr - Ct * Jt, y2: dr * Jt + Ct * Rr, x3: Oe * Rr - ii * Jt, y3: Oe * Jt + ii * Rr, x4: fe * Math.cos(je), y4: fe * Math.sin(je) };
  }, mt = function(fe) {
    return 180 * fe / Math.PI;
  }, wt = function(fe, De, je, Ke, rt, at) {
    var Et = fe + 0.5 * (je - fe), Tt = De + 0.5 * (Ke - De), Vt = rt + 0.5 * (je - rt), tr = at + 0.5 * (Ke - at), ur = Math.min(fe, rt, Et, Vt), dr = Math.max(fe, rt, Et, Vt), Ct = Math.min(De, at, Tt, tr), Oe = Math.max(De, at, Tt, tr);
    return new o(ur, Ct, dr - ur, Oe - Ct);
  }, Yt = function(fe, De, je, Ke, rt, at, Et, Tt) {
    var Vt, tr, ur, dr, Ct, Oe, ii, Zr, Rr, Jt, Sr, hr, qr, xr, bi = je - fe, Yr = Ke - De, Fr = rt - je, Ri = at - Ke, Kr = Et - rt, wr = Tt - at;
    for (tr = 0; tr < 41; tr++) Rr = (ii = (ur = fe + (Vt = tr / 40) * bi) + Vt * ((Ct = je + Vt * Fr) - ur)) + Vt * (Ct + Vt * (rt + Vt * Kr - Ct) - ii), Jt = (Zr = (dr = De + Vt * Yr) + Vt * ((Oe = Ke + Vt * Ri) - dr)) + Vt * (Oe + Vt * (at + Vt * wr - Oe) - Zr), tr == 0 ? (Sr = Rr, hr = Jt, qr = Rr, xr = Jt) : (Sr = Math.min(Sr, Rr), hr = Math.min(hr, Jt), qr = Math.max(qr, Rr), xr = Math.max(xr, Jt));
    return new o(Math.round(Sr), Math.round(hr), Math.round(qr - Sr), Math.round(xr - hr));
  }, Dt = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var fe, De, je = (fe = this.ctx.lineDash, De = this.ctx.lineDashOffset, JSON.stringify({ lineDash: fe, lineDashOffset: De }));
      this.prevLineDash !== je && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = je);
    }
  };
})(Ur.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(c) {
    var o, d, m, y, T, P, I, D, k, $;
    for (d = [], m = 0, y = (c += o = "\0\0\0\0".slice(c.length % 4 || 4)).length; y > m; m += 4) (T = (c.charCodeAt(m) << 24) + (c.charCodeAt(m + 1) << 16) + (c.charCodeAt(m + 2) << 8) + c.charCodeAt(m + 3)) !== 0 ? (P = (T = ((T = ((T = ((T = (T - ($ = T % 85)) / 85) - (k = T % 85)) / 85) - (D = T % 85)) / 85) - (I = T % 85)) / 85) % 85, d.push(P + 33, I + 33, D + 33, k + 33, $ + 33)) : d.push(122);
    return function(G, te) {
      for (var Z = te; Z > 0; Z--) G.pop();
    }(d, o.length), String.fromCharCode.apply(String, d) + "~>";
  }, t = function(c) {
    var o, d, m, y, T, P = String, I = "length", D = 255, k = "charCodeAt", $ = "slice", G = "replace";
    for (c[$](-2), c = c[$](0, -2)[G](/\s/g, "")[G]("z", "!!!!!"), m = [], y = 0, T = (c += o = "uuuuu"[$](c[I] % 5 || 5))[I]; T > y; y += 5) d = 52200625 * (c[k](y) - 33) + 614125 * (c[k](y + 1) - 33) + 7225 * (c[k](y + 2) - 33) + 85 * (c[k](y + 3) - 33) + (c[k](y + 4) - 33), m.push(D & d >> 24, D & d >> 16, D & d >> 8, D & d);
    return function(te, Z) {
      for (var H = Z; H > 0; H--) te.pop();
    }(m, o[I]), P.fromCharCode.apply(P, m);
  }, i = function(c) {
    return c.split("").map(function(o) {
      return ("0" + o.charCodeAt().toString(16)).slice(-2);
    }).join("") + ">";
  }, n = function(c) {
    var o = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((c = c.replace(/\s/g, "")).indexOf(">") !== -1 && (c = c.substr(0, c.indexOf(">"))), c.length % 2 && (c += "0"), o.test(c) === !1) return "";
    for (var d = "", m = 0; m < c.length; m += 2) d += String.fromCharCode("0x" + (c[m] + c[m + 1]));
    return d;
  }, s = function(c) {
    for (var o = new Uint8Array(c.length), d = c.length; d--; ) o[d] = c.charCodeAt(d);
    return (o = r2(o)).reduce(function(m, y) {
      return m + String.fromCharCode(y);
    }, "");
  };
  r.processDataByFilters = function(c, o) {
    var d = 0, m = c || "", y = [];
    for (typeof (o = o || []) == "string" && (o = [o]), d = 0; d < o.length; d += 1) switch (o[d]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        m = t(m), y.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        m = e(m), y.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        m = n(m), y.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        m = i(m), y.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        m = s(m), y.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + o[d] + '" is not implemented');
    }
    return { data: m, reverseChain: y.reverse().join(" ") };
  };
}(Ur.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.loadFile = function(e, t, i) {
    return function(n, s, c) {
      s = s !== !1, c = typeof c == "function" ? c : function() {
      };
      var o = void 0;
      try {
        o = function(d, m, y) {
          var T = new XMLHttpRequest(), P = 0, I = function(D) {
            var k = D.length, $ = [], G = String.fromCharCode;
            for (P = 0; P < k; P += 1) $.push(G(255 & D.charCodeAt(P)));
            return $.join("");
          };
          if (T.open("GET", d, !m), T.overrideMimeType("text/plain; charset=x-user-defined"), m === !1 && (T.onload = function() {
            T.status === 200 ? y(I(this.responseText)) : y(void 0);
          }), T.send(null), m && T.status === 200) return I(T.responseText);
        }(n, s, c);
      } catch {
      }
      return o;
    }(e, t, i);
  }, r.loadImageFile = r.loadFile;
}(Ur.API), function(r) {
  function e() {
    return (ai.html2canvas ? Promise.resolve(ai.html2canvas) : import("./html2canvas.esm-Dmi1NfiH-AQaq32X6.mjs")).catch(function(o) {
      return Promise.reject(new Error("Could not load html2canvas: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  function t() {
    return (ai.DOMPurify ? Promise.resolve(ai.DOMPurify) : import("./purify.es-DHbHSKL1-2rarU4M1.mjs")).catch(function(o) {
      return Promise.reject(new Error("Could not load dompurify: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  var i = function(o) {
    var d = un(o);
    return d === "undefined" ? "undefined" : d === "string" || o instanceof String ? "string" : d === "number" || o instanceof Number ? "number" : d === "function" || o instanceof Function ? "function" : o && o.constructor === Array ? "array" : o && o.nodeType === 1 ? "element" : d === "object" ? "object" : "unknown";
  }, n = function(o, d) {
    var m = document.createElement(o);
    for (var y in d.className && (m.className = d.className), d.innerHTML && d.dompurify && (m.innerHTML = d.dompurify.sanitize(d.innerHTML)), d.style) m.style[y] = d.style[y];
    return m;
  }, s = function o(d, m) {
    for (var y = d.nodeType === 3 ? document.createTextNode(d.nodeValue) : d.cloneNode(!1), T = d.firstChild; T; T = T.nextSibling) m !== !0 && T.nodeType === 1 && T.nodeName === "SCRIPT" || y.appendChild(o(T, m));
    return d.nodeType === 1 && (d.nodeName === "CANVAS" ? (y.width = d.width, y.height = d.height, y.getContext("2d").drawImage(d, 0, 0)) : d.nodeName !== "TEXTAREA" && d.nodeName !== "SELECT" || (y.value = d.value), y.addEventListener("load", function() {
      y.scrollTop = d.scrollTop, y.scrollLeft = d.scrollLeft;
    }, !0)), y;
  }, c = function o(d) {
    var m = Object.assign(o.convert(Promise.resolve()), JSON.parse(JSON.stringify(o.template))), y = o.convert(Promise.resolve(), m);
    return (y = y.setProgress(1, o, 1, [o])).set(d);
  };
  (c.prototype = Object.create(Promise.prototype)).constructor = c, c.convert = function(o, d) {
    return o.__proto__ = d || c.prototype, o;
  }, c.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, c.prototype.from = function(o, d) {
    return this.then(function() {
      switch (d = d || function(m) {
        switch (i(m)) {
          case "string":
            return "string";
          case "element":
            return m.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(o), d) {
        case "string":
          return this.then(t).then(function(m) {
            return this.set({ src: n("div", { innerHTML: o, dompurify: m }) });
          });
        case "element":
          return this.set({ src: o });
        case "canvas":
          return this.set({ canvas: o });
        case "img":
          return this.set({ img: o });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, c.prototype.to = function(o) {
    switch (o) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, c.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var o = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, d = s(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      d.tagName === "BODY" && (o.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = n("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = n("div", { className: "html2pdf__container", style: o }), this.prop.container.appendChild(d), this.prop.container.firstChild.appendChild(n("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, c.prototype.toCanvas = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(e).then(function(d) {
      var m = Object.assign({}, this.opt.html2canvas);
      return delete m.onrendered, d(this.prop.container, m);
    }).then(function(d) {
      (this.opt.html2canvas.onrendered || function() {
      })(d), this.prop.canvas = d, document.body.removeChild(this.prop.overlay);
    });
  }, c.prototype.toContext2d = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(e).then(function(d) {
      var m = this.opt.jsPDF, y = this.opt.fontFaces, T = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, P = Object.assign({ async: !0, allowTaint: !0, scale: T, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete P.onrendered, m.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, m.context2d.posX = this.opt.x, m.context2d.posY = this.opt.y, m.context2d.margin = this.opt.margin, m.context2d.fontFaces = y, y) for (var I = 0; I < y.length; ++I) {
        var D = y[I], k = D.src.find(function($) {
          return $.format === "truetype";
        });
        k && m.addFont(k.url, D.ref.name, D.ref.style);
      }
      return P.windowHeight = P.windowHeight || 0, P.windowHeight = P.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : P.windowHeight, m.context2d.save(!0), d(this.prop.container, P);
    }).then(function(d) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(d), this.prop.canvas = d, document.body.removeChild(this.prop.overlay);
    });
  }, c.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var o = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = o;
    });
  }, c.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, c.prototype.output = function(o, d, m) {
    return (m = m || "pdf").toLowerCase() === "img" || m.toLowerCase() === "image" ? this.outputImg(o, d) : this.outputPdf(o, d);
  }, c.prototype.outputPdf = function(o, d) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(o, d);
    });
  }, c.prototype.outputImg = function(o) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (o) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + o + '" is not supported.';
      }
    });
  }, c.prototype.save = function(o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(o ? { filename: o } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, c.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, c.prototype.set = function(o) {
    if (i(o) !== "object") return this;
    var d = Object.keys(o || {}).map(function(m) {
      if (m in c.template.prop) return function() {
        this.prop[m] = o[m];
      };
      switch (m) {
        case "margin":
          return this.setMargin.bind(this, o.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = o.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, o.pageSize);
        default:
          return function() {
            this.opt[m] = o[m];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(d);
    });
  }, c.prototype.get = function(o, d) {
    return this.then(function() {
      var m = o in c.template.prop ? this.prop[o] : this.opt[o];
      return d ? d(m) : m;
    });
  }, c.prototype.setMargin = function(o) {
    return this.then(function() {
      switch (i(o)) {
        case "number":
          o = [o, o, o, o];
        case "array":
          if (o.length === 2 && (o = [o[0], o[1], o[0], o[1]]), o.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = o;
    }).then(this.setPageSize);
  }, c.prototype.setPageSize = function(o) {
    function d(m, y) {
      return Math.floor(m * y / 72 * 96);
    }
    return this.then(function() {
      (o = o || Ur.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (o.inner = { width: o.width - this.opt.margin[1] - this.opt.margin[3], height: o.height - this.opt.margin[0] - this.opt.margin[2] }, o.inner.px = { width: d(o.inner.width, o.k), height: d(o.inner.height, o.k) }, o.inner.ratio = o.inner.height / o.inner.width), this.prop.pageSize = o;
    });
  }, c.prototype.setProgress = function(o, d, m, y) {
    return o != null && (this.progress.val = o), d != null && (this.progress.state = d), m != null && (this.progress.n = m), y != null && (this.progress.stack = y), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, c.prototype.updateProgress = function(o, d, m, y) {
    return this.setProgress(o ? this.progress.val + o : null, d || null, m ? this.progress.n + m : null, y ? this.progress.stack.concat(y) : null);
  }, c.prototype.then = function(o, d) {
    var m = this;
    return this.thenCore(o, d, function(y, T) {
      return m.updateProgress(null, null, 1, [y]), Promise.prototype.then.call(this, function(P) {
        return m.updateProgress(null, y), P;
      }).then(y, T).then(function(P) {
        return m.updateProgress(1), P;
      });
    });
  }, c.prototype.thenCore = function(o, d, m) {
    m = m || Promise.prototype.then;
    var y = this;
    o && (o = o.bind(y)), d && (d = d.bind(y));
    var T = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? y : c.convert(Object.assign({}, y), Promise.prototype), P = m.call(T, o, d);
    return c.convert(P, y.__proto__);
  }, c.prototype.thenExternal = function(o, d) {
    return Promise.prototype.then.call(this, o, d);
  }, c.prototype.thenList = function(o) {
    var d = this;
    return o.forEach(function(m) {
      d = d.thenCore(m);
    }), d;
  }, c.prototype.catch = function(o) {
    o && (o = o.bind(this));
    var d = Promise.prototype.catch.call(this, o);
    return c.convert(d, this);
  }, c.prototype.catchExternal = function(o) {
    return Promise.prototype.catch.call(this, o);
  }, c.prototype.error = function(o) {
    return this.then(function() {
      throw new Error(o);
    });
  }, c.prototype.using = c.prototype.set, c.prototype.saveAs = c.prototype.save, c.prototype.export = c.prototype.output, c.prototype.run = c.prototype.then, Ur.getPageSize = function(o, d, m) {
    if (un(o) === "object") {
      var y = o;
      o = y.orientation, d = y.unit || d, m = y.format || m;
    }
    d = d || "mm", m = m || "a4", o = ("" + (o || "P")).toLowerCase();
    var T, P = ("" + m).toLowerCase(), I = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (d) {
      case "pt":
        T = 1;
        break;
      case "mm":
        T = 72 / 25.4;
        break;
      case "cm":
        T = 72 / 2.54;
        break;
      case "in":
        T = 72;
        break;
      case "px":
        T = 0.75;
        break;
      case "pc":
      case "em":
        T = 12;
        break;
      case "ex":
        T = 6;
        break;
      default:
        throw "Invalid unit: " + d;
    }
    var D, k = 0, $ = 0;
    if (I.hasOwnProperty(P)) k = I[P][1] / T, $ = I[P][0] / T;
    else try {
      k = m[1], $ = m[0];
    } catch {
      throw new Error("Invalid format: " + m);
    }
    if (o === "p" || o === "portrait") o = "p", $ > k && (D = $, $ = k, k = D);
    else {
      if (o !== "l" && o !== "landscape") throw "Invalid orientation: " + o;
      o = "l", k > $ && (D = $, $ = k, k = D);
    }
    return { width: $, height: k, unit: d, k: T, orientation: o };
  }, r.html = function(o, d) {
    (d = d || {}).callback = d.callback || function() {
    }, d.html2canvas = d.html2canvas || {}, d.html2canvas.canvas = d.html2canvas.canvas || this.canvas, d.jsPDF = d.jsPDF || this, d.fontFaces = d.fontFaces ? d.fontFaces.map(N1) : null;
    var m = new c(d);
    return d.worker ? m : m.from(o).doCallback();
  };
}(Ur.API), Ur.API.addJS = function(r) {
  return SC = r, this.internal.events.subscribe("postPutResources", function() {
    R_ = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (R_ + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), TC = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + SC + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    R_ !== void 0 && TC !== void 0 && this.internal.out("/Names <</JavaScript " + R_ + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e;
  r.events.push(["postPutResources", function() {
    var t = this, i = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var n = t.outline.render().split(/\r\n/), s = 0; s < n.length; s++) {
      var c = n[s], o = i.exec(c);
      if (o != null) {
        var d = o[1];
        t.internal.newObjectDeferredBegin(d, !1);
      }
      t.internal.write(c);
    }
    if (this.outline.createNamedDestinations) {
      var m = this.internal.pages.length, y = [];
      for (s = 0; s < m; s++) {
        var T = t.internal.newObject();
        y.push(T);
        var P = t.internal.getPageInfo(s + 1);
        t.internal.write("<< /D[" + P.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var I = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), s = 0; s < y.length; s++) t.internal.write("(page_" + (s + 1) + ")" + y[s] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + I + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), r.events.push(["putCatalog", function() {
    var t = this;
    t.outline.root.children.length > 0 && (t.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t.internal.write("/Names " + e + " 0 R"));
  }]), r.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(i, n, s) {
      var c = { title: n, options: s, children: [] };
      return i == null && (i = this.root), i.children.push(c), c;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(i) {
      i.id = t.internal.newObjectDeferred();
      for (var n = 0; n < i.children.length; n++) this.genIds_r(i.children[n]);
    }, t.outline.renderRoot = function(i) {
      this.objStart(i), this.line("/Type /Outlines"), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, i)), this.objEnd();
    }, t.outline.renderItems = function(i) {
      for (var n = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < i.children.length; s++) {
        var c = i.children[s];
        this.objStart(c), this.line("/Title " + this.makeString(c.title)), this.line("/Parent " + this.makeRef(i)), s > 0 && this.line("/Prev " + this.makeRef(i.children[s - 1])), s < i.children.length - 1 && this.line("/Next " + this.makeRef(i.children[s + 1])), c.children.length > 0 && (this.line("/First " + this.makeRef(c.children[0])), this.line("/Last " + this.makeRef(c.children[c.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, c);
        if (o > 0 && this.line("/Count " + o), c.options && c.options.pageNumber) {
          var d = t.internal.getPageInfo(c.options.pageNumber);
          this.line("/Dest [" + d.objId + " 0 R /XYZ 0 " + n(0) + " 0]");
        }
        this.objEnd();
      }
      for (var m = 0; m < i.children.length; m++) this.renderItems(i.children[m]);
    }, t.outline.line = function(i) {
      this.ctx.val += i + `\r
`;
    }, t.outline.makeRef = function(i) {
      return i.id + " 0 R";
    }, t.outline.makeString = function(i) {
      return "(" + t.internal.pdfEscape(i) + ")";
    }, t.outline.objStart = function(i) {
      this.ctx.val += `\r
` + i.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(i, n) {
      for (var s = 0; s < n.children.length; s++) i.count++, this.count_r(i, n.children[s]);
      return i.count;
    };
  }]);
}(Ur.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  r.processJPEG = function(t, i, n, s, c, o) {
    var d, m = this.decode.DCT_DECODE, y = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = c || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, d = function(T) {
        for (var P, I = 256 * T.charCodeAt(4) + T.charCodeAt(5), D = T.length, k = { width: 0, height: 0, numcomponents: 1 }, $ = 4; $ < D; $ += 2) {
          if ($ += I, e.indexOf(T.charCodeAt($ + 1)) !== -1) {
            P = 256 * T.charCodeAt($ + 5) + T.charCodeAt($ + 6), k = { width: 256 * T.charCodeAt($ + 7) + T.charCodeAt($ + 8), height: P, numcomponents: T.charCodeAt($ + 9) };
            break;
          }
          I = 256 * T.charCodeAt($ + 2) + T.charCodeAt($ + 3);
        }
        return k;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t), d.numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      y = { data: t, width: d.width, height: d.height, colorSpace: o, bitsPerComponent: 8, filter: m, index: i, alias: n };
    }
    return y;
  };
}(Ur.API), Ur.API.processPNG = function(r, e, t, i) {
  if (this.__addimage__.isArrayBuffer(r) && (r = new Uint8Array(r)), this.__addimage__.isArrayBufferView(r)) {
    var n, s = _ee(r, { checkCrc: !0 }), c = s.width, o = s.height, d = s.channels, m = s.palette, y = s.depth;
    n = m && d === 1 ? function(be) {
      for (var pe = be.width, oe = be.height, Ee = be.data, le = be.palette, _e = be.depth, Ve = !1, Be = [], gt = [], St = void 0, Mt = !1, mt = 0, wt = 0; wt < le.length; wt++) {
        var Yt = PE(le[wt], 4), Dt = Yt[0], fe = Yt[1], De = Yt[2], je = Yt[3];
        Be.push(Dt, fe, De), je != null && (je === 0 ? (mt++, gt.length < 1 && gt.push(wt)) : je < 255 && (Mt = !0));
      }
      if (Mt || mt > 1) {
        Ve = !0, gt = void 0;
        var Ke = pe * oe;
        St = new Uint8Array(Ke);
        for (var rt = new DataView(Ee.buffer), at = 0; at < Ke; at++) {
          var Et = F1(rt, at, _e), Tt = PE(le[Et], 4)[3];
          St[at] = Tt;
        }
      }
      return { colorSpace: "Indexed", colorsPerPixel: 1, colorBytes: Ee, alphaBytes: St, needSMask: Ve, palette: Be, mask: gt };
    }(s) : d === 2 || d === 4 ? function(be) {
      for (var pe = be.data, oe = be.width, Ee = be.height, le = be.channels, _e = be.depth, Ve = le === 2 ? "DeviceGray" : "DeviceRGB", Be = le - 1, gt = oe * Ee, St = Be, Mt = gt * St, mt = 1 * gt, wt = Math.ceil(Mt * _e / 8), Yt = Math.ceil(mt * _e / 8), Dt = new Uint8Array(wt), fe = new Uint8Array(Yt), De = new DataView(pe.buffer), je = new DataView(Dt.buffer), Ke = new DataView(fe.buffer), rt = !1, at = 0; at < gt; at++) {
        for (var Et = at * le, Tt = 0; Tt < St; Tt++) OC(je, F1(De, Et + Tt, _e), at * St + Tt, _e);
        var Vt = F1(De, Et + St, _e);
        Vt < (1 << _e) - 1 && (rt = !0), OC(Ke, Vt, 1 * at, _e);
      }
      return { colorSpace: Ve, colorsPerPixel: Be, colorBytes: Dt, alphaBytes: fe, needSMask: rt };
    }(s) : function(be) {
      var pe = be.data, oe = be.channels === 1 ? "DeviceGray" : "DeviceRGB";
      return { colorSpace: oe, colorsPerPixel: oe === "DeviceGray" ? 1 : 3, colorBytes: pe instanceof Uint8Array ? pe : new Uint8Array(pe.buffer), needSMask: !1 };
    }(s);
    var T, P, I, D = n, k = D.colorSpace, $ = D.colorsPerPixel, G = D.colorBytes, te = D.alphaBytes, Z = D.needSMask, H = D.palette, J = D.mask, re = null;
    return i !== Ur.API.image_compression.NONE && typeof r2 == "function" ? (re = function(be) {
      var pe;
      switch (be) {
        case Ur.API.image_compression.FAST:
          pe = 11;
          break;
        case Ur.API.image_compression.MEDIUM:
          pe = 13;
          break;
        case Ur.API.image_compression.SLOW:
          pe = 14;
          break;
        default:
          pe = 12;
      }
      return pe;
    }(i), T = this.decode.FLATE_DECODE, P = "/Predictor ".concat(re, " "), r = MC(G, c * $, $, i), Z && (I = MC(te, c, 1, i))) : (T = void 0, P = "", r = G, Z && (I = te)), P += "/Colors ".concat($, " /BitsPerComponent ").concat(y, " /Columns ").concat(c), (this.__addimage__.isArrayBuffer(r) || this.__addimage__.isArrayBufferView(r)) && (r = this.__addimage__.arrayBufferToBinaryString(r)), (I && this.__addimage__.isArrayBuffer(I) || this.__addimage__.isArrayBufferView(I)) && (I = this.__addimage__.arrayBufferToBinaryString(I)), { alias: t, data: r, index: e, filter: T, decodeParameters: P, transparency: J, palette: H, sMask: I, predictor: re, width: c, height: o, bitsPerComponent: y, colorSpace: k };
  }
}, function(r) {
  r.processGIF89A = function(e, t, i, n) {
    var s = new Fee(e), c = s.width, o = s.height, d = [];
    s.decodeAndBlitFrameRGBA(0, d);
    var m = { data: d, width: c, height: o }, y = new U1(100).encode(m, 100);
    return r.processJPEG.call(this, y, t, i, n);
  }, r.processGIF87A = r.processGIF89A;
}(Ur.API), fc.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var r = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(r);
    for (var e = 0; e < r; e++) {
      var t = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: n, green: i, blue: t, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, fc.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var r = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[r]();
  } catch (t) {
    An.log("bit decode error:" + t);
  }
}, fc.prototype.bit1 = function() {
  var r, e = Math.ceil(this.width / 8), t = e % 4;
  for (r = this.height - 1; r >= 0; r--) {
    for (var i = this.bottom_up ? r : this.height - 1 - r, n = 0; n < e; n++) for (var s = this.datav.getUint8(this.pos++, !0), c = i * this.width * 4 + 8 * n * 4, o = 0; o < 8 && 8 * n + o < this.width; o++) {
      var d = this.palette[s >> 7 - o & 1];
      this.data[c + 4 * o] = d.blue, this.data[c + 4 * o + 1] = d.green, this.data[c + 4 * o + 2] = d.red, this.data[c + 4 * o + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, fc.prototype.bit4 = function() {
  for (var r = Math.ceil(this.width / 2), e = r % 4, t = this.height - 1; t >= 0; t--) {
    for (var i = this.bottom_up ? t : this.height - 1 - t, n = 0; n < r; n++) {
      var s = this.datav.getUint8(this.pos++, !0), c = i * this.width * 4 + 2 * n * 4, o = s >> 4, d = 15 & s, m = this.palette[o];
      if (this.data[c] = m.blue, this.data[c + 1] = m.green, this.data[c + 2] = m.red, this.data[c + 3] = 255, 2 * n + 1 >= this.width) break;
      m = this.palette[d], this.data[c + 4] = m.blue, this.data[c + 4 + 1] = m.green, this.data[c + 4 + 2] = m.red, this.data[c + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, fc.prototype.bit8 = function() {
  for (var r = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, i = 0; i < this.width; i++) {
      var n = this.datav.getUint8(this.pos++, !0), s = t * this.width * 4 + 4 * i;
      if (n < this.palette.length) {
        var c = this.palette[n];
        this.data[s] = c.red, this.data[s + 1] = c.green, this.data[s + 2] = c.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    r !== 0 && (this.pos += 4 - r);
  }
}, fc.prototype.bit15 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var i = this.bottom_up ? t : this.height - 1 - t, n = 0; n < this.width; n++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var c = (s & e) / e * 255 | 0, o = (s >> 5 & e) / e * 255 | 0, d = (s >> 10 & e) / e * 255 | 0, m = s >> 15 ? 255 : 0, y = i * this.width * 4 + 4 * n;
      this.data[y] = d, this.data[y + 1] = o, this.data[y + 2] = c, this.data[y + 3] = m;
    }
    this.pos += r;
  }
}, fc.prototype.bit16 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), i = this.height - 1; i >= 0; i--) {
    for (var n = this.bottom_up ? i : this.height - 1 - i, s = 0; s < this.width; s++) {
      var c = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (c & e) / e * 255 | 0, d = (c >> 5 & t) / t * 255 | 0, m = (c >> 11) / e * 255 | 0, y = n * this.width * 4 + 4 * s;
      this.data[y] = m, this.data[y + 1] = d, this.data[y + 2] = o, this.data[y + 3] = 255;
    }
    this.pos += r;
  }
}, fc.prototype.bit24 = function() {
  for (var r = this.height - 1; r >= 0; r--) {
    for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
      var i = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), c = e * this.width * 4 + 4 * t;
      this.data[c] = s, this.data[c + 1] = n, this.data[c + 2] = i, this.data[c + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, fc.prototype.bit32 = function() {
  for (var r = this.height - 1; r >= 0; r--) for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
    var i = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), c = this.datav.getUint8(this.pos++, !0), o = e * this.width * 4 + 4 * t;
    this.data[o] = s, this.data[o + 1] = n, this.data[o + 2] = i, this.data[o + 3] = c;
  }
}, fc.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.processBMP = function(e, t, i, n) {
    var s = new fc(e, !1), c = s.width, o = s.height, d = { data: s.getData(), width: c, height: o }, m = new U1(100).encode(d, 100);
    return r.processJPEG.call(this, m, t, i, n);
  };
}(Ur.API), NC.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.processWEBP = function(e, t, i, n) {
    var s = new NC(e), c = s.width, o = s.height, d = { data: s.getData(), width: c, height: o }, m = new U1(100).encode(d, 100);
    return r.processJPEG.call(this, m, t, i, n);
  };
}(Ur.API), Ur.API.processRGBA = function(r, e, t) {
  for (var i = r.data, n = i.length, s = new Uint8Array(n / 4 * 3), c = new Uint8Array(n / 4), o = 0, d = 0, m = 0; m < n; m += 4) {
    var y = i[m], T = i[m + 1], P = i[m + 2], I = i[m + 3];
    s[o++] = y, s[o++] = T, s[o++] = P, c[d++] = I;
  }
  var D = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(c), data: D, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: r.width, height: r.height };
}, Ur.API.setLanguage = function(r) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[r] !== void 0 && (this.internal.languageSettings.languageCode = r, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Xd = Ur.API, L_ = Xd.getCharWidthsArray = function(r, e) {
  var t, i, n = (e = e || {}).font || this.internal.getFont(), s = e.fontSize || this.internal.getFontSize(), c = e.charSpace || this.internal.getCharSpace(), o = e.widths ? e.widths : n.metadata.Unicode.widths, d = o.fof ? o.fof : 1, m = e.kerning ? e.kerning : n.metadata.Unicode.kerning, y = m.fof ? m.fof : 1, T = e.doKerning !== !1, P = 0, I = r.length, D = 0, k = o[0] || d, $ = [];
  for (t = 0; t < I; t++) i = r.charCodeAt(t), typeof n.metadata.widthOfString == "function" ? $.push((n.metadata.widthOfGlyph(n.metadata.characterToGlyph(i)) + c * (1e3 / s) || 0) / 1e3) : (P = T && un(m[i]) === "object" && !isNaN(parseInt(m[i][D], 10)) ? m[i][D] / y : 0, $.push((o[i] || k) / d + P)), D = i;
  return $;
}, EC = Xd.getStringUnitWidth = function(r, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), i = e.font || this.internal.getFont(), n = e.charSpace || this.internal.getCharSpace();
  return Xd.processArabic && (r = Xd.processArabic(r)), typeof i.metadata.widthOfString == "function" ? i.metadata.widthOfString(r, t, n) / t : L_.apply(this, arguments).reduce(function(s, c) {
    return s + c;
  }, 0);
}, CC = function(r, e, t, i) {
  for (var n = [], s = 0, c = r.length, o = 0; s !== c && o + e[s] < t; ) o += e[s], s++;
  n.push(r.slice(0, s));
  var d = s;
  for (o = 0; s !== c; ) o + e[s] > i && (n.push(r.slice(d, s)), o = 0, d = s), o += e[s], s++;
  return d !== s && n.push(r.slice(d, s)), n;
}, IC = function(r, e, t) {
  t || (t = {});
  var i, n, s, c, o, d, m, y = [], T = [y], P = t.textIndent || 0, I = 0, D = 0, k = r.split(" "), $ = L_.apply(this, [" ", t])[0];
  if (d = t.lineIndent === -1 ? k[0].length + 2 : t.lineIndent || 0) {
    var G = Array(d).join(" "), te = [];
    k.map(function(H) {
      (H = H.split(/\s*\n/)).length > 1 ? te = te.concat(H.map(function(J, re) {
        return (re && J.length ? `
` : "") + J;
      })) : te.push(H[0]);
    }), k = te, d = EC.apply(this, [G, t]);
  }
  for (s = 0, c = k.length; s < c; s++) {
    var Z = 0;
    if (i = k[s], d && i[0] == `
` && (i = i.substr(1), Z = 1), P + I + (D = (n = L_.apply(this, [i, t])).reduce(function(H, J) {
      return H + J;
    }, 0)) > e || Z) {
      if (D > e) {
        for (o = CC.apply(this, [i, n, e - (P + I), e]), y.push(o.shift()), y = [o.pop()]; o.length; ) T.push([o.shift()]);
        D = n.slice(i.length - (y[0] ? y[0].length : 0)).reduce(function(H, J) {
          return H + J;
        }, 0);
      } else y = [i];
      T.push(y), P = D + d, I = $;
    } else y.push(i), P += I + D, I = $;
  }
  return m = d ? function(H, J) {
    return (J ? G : "") + H.join(" ");
  } : function(H) {
    return H.join(" ");
  }, T.map(m);
}, Xd.splitTextToSize = function(r, e, t) {
  var i, n = (t = t || {}).fontSize || this.internal.getFontSize(), s = (function(y) {
    if (y.widths && y.kerning) return { widths: y.widths, kerning: y.kerning };
    var T = this.internal.getFont(y.fontName, y.fontStyle), P = "Unicode";
    return T.metadata[P] ? { widths: T.metadata[P].widths || { 0: 1 }, kerning: T.metadata[P].kerning || {} } : { font: T.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, t);
  i = Array.isArray(r) ? r : String(r).split(/\r?\n/);
  var c = 1 * this.internal.scaleFactor * e / n;
  s.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / n : 0, s.lineIndent = t.lineIndent;
  var o, d, m = [];
  for (o = 0, d = i.length; o < d; o++) m = m.concat(IC.apply(this, [i[o], c, s]));
  return m;
}, function(r) {
  r.__fontmetrics__ = r.__fontmetrics__ || {};
  for (var e = "0123456789abcdef", t = "klmnopqrstuvwxyz", i = {}, n = {}, s = 0; s < 16; s++) i[t[s]] = e[s], n[e[s]] = t[s];
  var c = function(P) {
    return "0x" + parseInt(P, 10).toString(16);
  }, o = r.__fontmetrics__.compress = function(P) {
    var I, D, k, $, G = ["{"];
    for (var te in P) {
      if (I = P[te], isNaN(parseInt(te, 10)) ? D = "'" + te + "'" : (te = parseInt(te, 10), D = (D = c(te).slice(2)).slice(0, -1) + n[D.slice(-1)]), typeof I == "number") I < 0 ? (k = c(I).slice(3), $ = "-") : (k = c(I).slice(2), $ = ""), k = $ + k.slice(0, -1) + n[k.slice(-1)];
      else {
        if (un(I) !== "object") throw new Error("Don't know what to do with value type " + un(I) + ".");
        k = o(I);
      }
      G.push(D + k);
    }
    return G.push("}"), G.join("");
  }, d = r.__fontmetrics__.uncompress = function(P) {
    if (typeof P != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var I, D, k, $, G = {}, te = 1, Z = G, H = [], J = "", re = "", be = P.length - 1, pe = 1; pe < be; pe += 1) ($ = P[pe]) == "'" ? I ? (k = I.join(""), I = void 0) : I = [] : I ? I.push($) : $ == "{" ? (H.push([Z, k]), Z = {}, k = void 0) : $ == "}" ? ((D = H.pop())[0][D[1]] = Z, k = void 0, Z = D[0]) : $ == "-" ? te = -1 : k === void 0 ? i.hasOwnProperty($) ? (J += i[$], k = parseInt(J, 16) * te, te = 1, J = "") : J += $ : i.hasOwnProperty($) ? (re += i[$], Z[k] = parseInt(re, 16) * te, te = 1, k = void 0, re = "") : re += $;
    return G;
  }, m = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: d("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, y = { Unicode: { Courier: m, "Courier-Bold": m, "Courier-BoldOblique": m, "Courier-Oblique": m, Helvetica: m, "Helvetica-Bold": m, "Helvetica-BoldOblique": m, "Helvetica-Oblique": m, "Times-Roman": m, "Times-Bold": m, "Times-BoldItalic": m, "Times-Italic": m } }, T = { Unicode: { "Courier-Oblique": d("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": d("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": d("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: d("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": d("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": d("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: d("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: d("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": d("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: d("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": d("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": d("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": d("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": d("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  r.events.push(["addFont", function(P) {
    var I = P.font, D = T.Unicode[I.postScriptName];
    D && (I.metadata.Unicode = {}, I.metadata.Unicode.widths = D.widths, I.metadata.Unicode.kerning = D.kerning);
    var k = y.Unicode[I.postScriptName];
    k && (I.metadata.Unicode.encoding = k, I.encoding = k.codePages[0]);
  }]);
}(Ur.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(t) {
    for (var i = t.length, n = new Uint8Array(i), s = 0; s < i; s++) n[s] = t.charCodeAt(s);
    return n;
  };
  r.API.events.push(["addFont", function(t) {
    var i = void 0, n = t.font, s = t.instance;
    if (!n.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + n.postScriptName + "').");
      if (typeof (i = s.existsFileInVFS(n.postScriptName) === !1 ? s.loadFile(n.postScriptName) : s.getFileFromVFS(n.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + n.postScriptName + "').");
      (function(c, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? e(o) : e(ty(o)), c.metadata = r.API.TTFFont.open(o), c.metadata.Unicode = c.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, c.metadata.glyIdsUsed = [0];
      })(n, i);
    }
  }]);
}(Ur), Ur.API.addSvgAsImage = function(r, e, t, i, n, s, c, o) {
  if (isNaN(e) || isNaN(t)) throw An.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
  if (isNaN(i) || isNaN(n)) throw An.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
  var d = document.createElement("canvas");
  d.width = i, d.height = n;
  var m = d.getContext("2d");
  m.fillStyle = "#fff", m.fillRect(0, 0, d.width, d.height);
  var y = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, T = this;
  return (ai.canvg ? Promise.resolve(ai.canvg) : import("./index.es-CDV9zB2B-CB-dpJjG.mjs")).catch(function(P) {
    return Promise.reject(new Error("Could not load canvg: " + P));
  }).then(function(P) {
    return P.default ? P.default : P;
  }).then(function(P) {
    return P.fromString(m, r, y);
  }, function() {
    return Promise.reject(new Error("Could not load canvg."));
  }).then(function(P) {
    return P.render(y);
  }).then(function() {
    T.addImage(d.toDataURL("image/jpeg", 1), e, t, i, n, c, o);
  });
}, Ur.API.putTotalPages = function(r) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(r, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(r, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var i = 1; i <= this.internal.getNumberOfPages(); i++) for (var n = 0; n < this.internal.pages[i].length; n++) this.internal.pages[i][n] = this.internal.pages[i][n].replace(e, t);
  return this;
}, Ur.API.viewerPreferences = function(r, e) {
  var t;
  r = r || {}, e = e || !1;
  var i, n, s, c = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(c), d = [], m = 0, y = 0, T = 0;
  function P(D, k) {
    var $, G = !1;
    for ($ = 0; $ < D.length; $ += 1) D[$] === k && (G = !0);
    return G;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(c)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, r === "reset" || e === !0) {
    var I = o.length;
    for (T = 0; T < I; T += 1) t[o[T]].value = t[o[T]].defaultValue, t[o[T]].explicitSet = !1;
  }
  if (un(r) === "object") {
    for (n in r) if (s = r[n], P(o, n) && s !== void 0) {
      if (t[n].type === "boolean" && typeof s == "boolean") t[n].value = s;
      else if (t[n].type === "name" && P(t[n].valueSet, s)) t[n].value = s;
      else if (t[n].type === "integer" && Number.isInteger(s)) t[n].value = s;
      else if (t[n].type === "array") {
        for (m = 0; m < s.length; m += 1) if (i = !0, s[m].length === 1 && typeof s[m][0] == "number") d.push(String(s[m] - 1));
        else if (s[m].length > 1) {
          for (y = 0; y < s[m].length; y += 1) typeof s[m][y] != "number" && (i = !1);
          i === !0 && d.push([s[m][0] - 1, s[m][1] - 1].join(" "));
        }
        t[n].value = "[" + d.join(" ") + "]";
      } else t[n].value = t[n].defaultValue;
      t[n].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var D, k = [];
    for (D in t) t[D].explicitSet === !0 && (t[D].type === "name" ? k.push("/" + D + " /" + t[D].value) : k.push("/" + D + " " + t[D].value));
    k.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + k.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(r) {
  var e = function() {
    var i = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', n = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(i)), c = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), d = unescape(encodeURIComponent("</x:xmpmeta>")), m = s.length + c.length + o.length + n.length + d.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + m + " >>"), this.internal.write("stream"), this.internal.write(n + s + c + o + d), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  r.addMetadata = function(i, n) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: i, namespaceuri: n || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(Ur.API), function(r) {
  var e = r.API, t = e.pdfEscape16 = function(s, c) {
    for (var o, d = c.metadata.Unicode.widths, m = ["", "0", "00", "000", "0000"], y = [""], T = 0, P = s.length; T < P; ++T) {
      if (o = c.metadata.characterToGlyph(s.charCodeAt(T)), c.metadata.glyIdsUsed.push(o), c.metadata.toUnicode[o] = s.charCodeAt(T), d.indexOf(o) == -1 && (d.push(o), d.push([parseInt(c.metadata.widthOfGlyph(o), 10)])), o == "0") return y.join("");
      o = o.toString(16), y.push(m[4 - o.length], o);
    }
    return y.join("");
  }, i = function(s) {
    var c, o, d, m, y, T, P;
    for (y = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, d = [], T = 0, P = (o = Object.keys(s).sort(function(I, D) {
      return I - D;
    })).length; T < P; T++) c = o[T], d.length >= 100 && (y += `
` + d.length + ` beginbfchar
` + d.join(`
`) + `
endbfchar`, d = []), s[c] !== void 0 && s[c] !== null && typeof s[c].toString == "function" && (m = ("0000" + s[c].toString(16)).slice(-4), c = ("0000" + (+c).toString(16)).slice(-4), d.push("<" + c + "><" + m + ">"));
    return d.length && (y += `
` + d.length + ` beginbfchar
` + d.join(`
`) + `
endbfchar
`), y + `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(s) {
    (function(c) {
      var o = c.font, d = c.out, m = c.newObject, y = c.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "Identity-H") {
        for (var T = o.metadata.Unicode.widths, P = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), I = "", D = 0; D < P.length; D++) I += String.fromCharCode(P[D]);
        var k = m();
        y({ data: I, addLength1: !0, objectId: k }), d("endobj");
        var $ = m();
        y({ data: i(o.metadata.toUnicode), addLength1: !0, objectId: $ }), d("endobj");
        var G = m();
        d("<<"), d("/Type /FontDescriptor"), d("/FontName /" + Qd(o.fontName)), d("/FontFile2 " + k + " 0 R"), d("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), d("/Flags " + o.metadata.flags), d("/StemV " + o.metadata.stemV), d("/ItalicAngle " + o.metadata.italicAngle), d("/Ascent " + o.metadata.ascender), d("/Descent " + o.metadata.decender), d("/CapHeight " + o.metadata.capHeight), d(">>"), d("endobj");
        var te = m();
        d("<<"), d("/Type /Font"), d("/BaseFont /" + Qd(o.fontName)), d("/FontDescriptor " + G + " 0 R"), d("/W " + r.API.PDFObject.convert(T)), d("/CIDToGIDMap /Identity"), d("/DW 1000"), d("/Subtype /CIDFontType2"), d("/CIDSystemInfo"), d("<<"), d("/Supplement 0"), d("/Registry (Adobe)"), d("/Ordering (" + o.encoding + ")"), d(">>"), d(">>"), d("endobj"), o.objectNumber = m(), d("<<"), d("/Type /Font"), d("/Subtype /Type0"), d("/ToUnicode " + $ + " 0 R"), d("/BaseFont /" + Qd(o.fontName)), d("/Encoding /" + o.encoding), d("/DescendantFonts [" + te + " 0 R]"), d(">>"), d("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]), e.events.push(["putFont", function(s) {
    (function(c) {
      var o = c.font, d = c.out, m = c.newObject, y = c.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var T = o.metadata.rawData, P = "", I = 0; I < T.length; I++) P += String.fromCharCode(T[I]);
        var D = m();
        y({ data: P, addLength1: !0, objectId: D }), d("endobj");
        var k = m();
        y({ data: i(o.metadata.toUnicode), addLength1: !0, objectId: k }), d("endobj");
        var $ = m();
        d("<<"), d("/Descent " + o.metadata.decender), d("/CapHeight " + o.metadata.capHeight), d("/StemV " + o.metadata.stemV), d("/Type /FontDescriptor"), d("/FontFile2 " + D + " 0 R"), d("/Flags 96"), d("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), d("/FontName /" + Qd(o.fontName)), d("/ItalicAngle " + o.metadata.italicAngle), d("/Ascent " + o.metadata.ascender), d(">>"), d("endobj"), o.objectNumber = m();
        for (var G = 0; G < o.metadata.hmtx.widths.length; G++) o.metadata.hmtx.widths[G] = parseInt(o.metadata.hmtx.widths[G] * (1e3 / o.metadata.head.unitsPerEm));
        d("<</Subtype/TrueType/Type/Font/ToUnicode " + k + " 0 R/BaseFont/" + Qd(o.fontName) + "/FontDescriptor " + $ + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + r.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), d("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var n = function(s) {
    var c, o = s.text || "", d = s.x, m = s.y, y = s.options || {}, T = s.mutex || {}, P = T.pdfEscape, I = T.activeFontKey, D = T.fonts, k = I, $ = "", G = 0, te = "", Z = D[k].encoding;
    if (D[k].encoding !== "Identity-H") return { text: o, x: d, y: m, options: y, mutex: T };
    for (te = o, k = I, Array.isArray(o) && (te = o[0]), G = 0; G < te.length; G += 1) D[k].metadata.hasOwnProperty("cmap") && (c = D[k].metadata.cmap.unicode.codeMap[te[G].charCodeAt(0)]), c || te[G].charCodeAt(0) < 256 && D[k].metadata.hasOwnProperty("Unicode") ? $ += te[G] : $ += "";
    var H = "";
    return parseInt(k.slice(1)) < 14 || Z === "WinAnsiEncoding" ? H = P($, k).split("").map(function(J) {
      return J.charCodeAt(0).toString(16);
    }).join("") : Z === "Identity-H" && (H = t($, D[k])), T.isHex = !0, { text: H, x: d, y: m, options: y, mutex: T };
  };
  e.events.push(["postProcessText", function(s) {
    var c = s.text || "", o = [], d = { text: c, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(c)) {
      var m = 0;
      for (m = 0; m < c.length; m += 1) Array.isArray(c[m]) && c[m].length === 3 ? o.push([n(Object.assign({}, d, { text: c[m][0] })).text, c[m][1], c[m][2]]) : o.push(n(Object.assign({}, d, { text: c[m] })).text);
      s.text = o;
    } else s.text = n(Object.assign({}, d, { text: c })).text;
  }]);
}(Ur), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  r.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, r.addFileToVFS = function(t, i) {
    return e.call(this), this.internal.vFS[t] = i, this;
  }, r.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(Ur.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(r) {
  r.__bidiEngine__ = r.prototype.__bidiEngine__ = function(i) {
    var n, s, c, o, d, m, y, T = e, P = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], I = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], D = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, k = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, $ = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], G = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), te = !1, Z = 0;
    this.__bidiEngine__ = {};
    var H = function(le) {
      var _e = le.charCodeAt(), Ve = _e >> 8, Be = k[Ve];
      return Be !== void 0 ? T[256 * Be + (255 & _e)] : Ve === 252 || Ve === 253 ? "AL" : G.test(Ve) ? "L" : Ve === 8 ? "R" : "N";
    }, J = function(le) {
      for (var _e, Ve = 0; Ve < le.length; Ve++) {
        if ((_e = H(le.charAt(Ve))) === "L") return !1;
        if (_e === "R") return !0;
      }
      return !1;
    }, re = function(le, _e, Ve, Be) {
      var gt, St, Mt, mt, wt = _e[Be];
      switch (wt) {
        case "L":
        case "R":
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          te = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          te && (wt = "AN");
          break;
        case "AL":
          te = !0, wt = "R";
          break;
        case "WS":
        case "BN":
          wt = "N";
          break;
        case "CS":
          Be < 1 || Be + 1 >= _e.length || (gt = Ve[Be - 1]) !== "EN" && gt !== "AN" || (St = _e[Be + 1]) !== "EN" && St !== "AN" ? wt = "N" : te && (St = "AN"), wt = St === gt ? St : "N";
          break;
        case "ES":
          wt = (gt = Be > 0 ? Ve[Be - 1] : "B") === "EN" && Be + 1 < _e.length && _e[Be + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Be > 0 && Ve[Be - 1] === "EN") {
            wt = "EN";
            break;
          }
          if (te) {
            wt = "N";
            break;
          }
          for (Mt = Be + 1, mt = _e.length; Mt < mt && _e[Mt] === "ET"; ) Mt++;
          wt = Mt < mt && _e[Mt] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (c && !o) {
            for (mt = _e.length, Mt = Be + 1; Mt < mt && _e[Mt] === "NSM"; ) Mt++;
            if (Mt < mt) {
              var Yt = le[Be], Dt = Yt >= 1425 && Yt <= 2303 || Yt === 64286;
              if (gt = _e[Mt], Dt && (gt === "R" || gt === "AL")) {
                wt = "R";
                break;
              }
            }
          }
          wt = Be < 1 || (gt = _e[Be - 1]) === "B" ? "N" : Ve[Be - 1];
          break;
        case "B":
          te = !1, n = !0, wt = Z;
          break;
        case "S":
          s = !0, wt = "N";
      }
      return wt;
    }, be = function(le, _e, Ve) {
      var Be = le.split("");
      return Ve && pe(Be, Ve, { hiLevel: Z }), Be.reverse(), _e && _e.reverse(), Be.join("");
    }, pe = function(le, _e, Ve) {
      var Be, gt, St, Mt, mt, wt = -1, Yt = le.length, Dt = 0, fe = [], De = Z ? I : P, je = [];
      for (te = !1, n = !1, s = !1, gt = 0; gt < Yt; gt++) je[gt] = H(le[gt]);
      for (St = 0; St < Yt; St++) {
        if (mt = Dt, fe[St] = re(le, je, fe, St), Be = 240 & (Dt = De[mt][D[fe[St]]]), Dt &= 15, _e[St] = Mt = De[Dt][5], Be > 0) if (Be === 16) {
          for (gt = wt; gt < St; gt++) _e[gt] = 1;
          wt = -1;
        } else wt = -1;
        if (De[Dt][6]) wt === -1 && (wt = St);
        else if (wt > -1) {
          for (gt = wt; gt < St; gt++) _e[gt] = Mt;
          wt = -1;
        }
        je[St] === "B" && (_e[St] = 0), Ve.hiLevel |= Mt;
      }
      s && function(Ke, rt, at) {
        for (var Et = 0; Et < at; Et++) if (Ke[Et] === "S") {
          rt[Et] = Z;
          for (var Tt = Et - 1; Tt >= 0 && Ke[Tt] === "WS"; Tt--) rt[Tt] = Z;
        }
      }(je, _e, Yt);
    }, oe = function(le, _e, Ve, Be, gt) {
      if (!(gt.hiLevel < le)) {
        if (le === 1 && Z === 1 && !n) return _e.reverse(), void (Ve && Ve.reverse());
        for (var St, Mt, mt, wt, Yt = _e.length, Dt = 0; Dt < Yt; ) {
          if (Be[Dt] >= le) {
            for (mt = Dt + 1; mt < Yt && Be[mt] >= le; ) mt++;
            for (wt = Dt, Mt = mt - 1; wt < Mt; wt++, Mt--) St = _e[wt], _e[wt] = _e[Mt], _e[Mt] = St, Ve && (St = Ve[wt], Ve[wt] = Ve[Mt], Ve[Mt] = St);
            Dt = mt;
          }
          Dt++;
        }
      }
    }, Ee = function(le, _e, Ve) {
      var Be = le.split(""), gt = { hiLevel: Z };
      return Ve || (Ve = []), pe(Be, Ve, gt), function(St, Mt, mt) {
        if (mt.hiLevel !== 0 && y) for (var wt, Yt = 0; Yt < St.length; Yt++) Mt[Yt] === 1 && (wt = $.indexOf(St[Yt])) >= 0 && (St[Yt] = $[wt + 1]);
      }(Be, Ve, gt), oe(2, Be, _e, Ve, gt), oe(1, Be, _e, Ve, gt), Be.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(le, _e, Ve) {
      if (function(gt, St) {
        if (St) for (var Mt = 0; Mt < gt.length; Mt++) St[Mt] = Mt;
        o === void 0 && (o = J(gt)), m === void 0 && (m = J(gt));
      }(le, _e), c || !d || m)
        if (c && d && o ^ m) Z = o ? 1 : 0, le = be(le, _e, Ve);
        else if (!c && d && m) Z = o ? 1 : 0, le = Ee(le, _e, Ve), le = be(le, _e);
        else if (!c || o || d || m) {
          if (c && !d && o ^ m) le = be(le, _e), o ? (Z = 0, le = Ee(le, _e, Ve)) : (Z = 1, le = Ee(le, _e, Ve), le = be(le, _e));
          else if (c && o && !d && m) Z = 1, le = Ee(le, _e, Ve), le = be(le, _e);
          else if (!c && !d && o ^ m) {
            var Be = y;
            o ? (Z = 1, le = Ee(le, _e, Ve), Z = 0, y = !1, le = Ee(le, _e, Ve), y = Be) : (Z = 0, le = Ee(le, _e, Ve), le = be(le, _e), Z = 1, y = !1, le = Ee(le, _e, Ve), y = Be, le = be(le, _e));
          }
        } else Z = 0, le = Ee(le, _e, Ve);
      else Z = o ? 1 : 0, le = Ee(le, _e, Ve);
      return le;
    }, this.__bidiEngine__.setOptions = function(le) {
      le && (c = le.isInputVisual, d = le.isOutputVisual, o = le.isInputRtl, m = le.isOutputRtl, y = le.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(i), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new r.__bidiEngine__({ isInputVisual: !0 });
  r.API.events.push(["postProcessText", function(i) {
    var n = i.text;
    i.x, i.y;
    var s = i.options || {};
    i.mutex, s.lang;
    var c = [];
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, t.setOptions(s), Object.prototype.toString.call(n) === "[object Array]") {
      var o = 0;
      for (c = [], o = 0; o < n.length; o += 1) Object.prototype.toString.call(n[o]) === "[object Array]" ? c.push([t.doBidiReorder(n[o][0]), n[o][1], n[o][2]]) : c.push([t.doBidiReorder(n[o])]);
      i.text = c;
    } else i.text = t.doBidiReorder(n);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(Ur), Ur.API.TTFFont = function() {
  function r(e) {
    var t;
    if (this.rawData = e, t = this.contents = new Jh(e), this.contents.pos = 4, t.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new Qee(this), this.registerTTF();
  }
  return r.open = function(e) {
    return new r(e);
  }, r.prototype.parse = function() {
    return this.directory = new Uee(this.contents), this.head = new jee(this), this.name = new qee(this), this.cmap = new ZR(this), this.toUnicode = {}, this.hhea = new Vee(this), this.maxp = new Wee(this), this.hmtx = new Xee(this), this.post = new $ee(this), this.os2 = new Gee(this), this.loca = new Kee(this), this.glyf = new Zee(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, r.prototype.registerTTF = function() {
    var e, t, i, n, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var c, o, d, m;
      for (m = [], c = 0, o = (d = this.bbox).length; c < o; c++) e = d[c], m.push(Math.round(e * this.scaleFactor));
      return m;
    }).call(this), this.stemV = 0, this.post.exists ? (i = 255 & (n = this.post.italic_angle), 32768 & (t = n >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + i)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, r.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, r.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, r.prototype.widthOfString = function(e, t, i) {
    var n, s, c, o;
    for (c = 0, s = 0, o = (e = "" + e).length; 0 <= o ? s < o : s > o; s = 0 <= o ? ++s : --s) n = e.charCodeAt(s), c += this.widthOfGlyph(this.characterToGlyph(n)) + i * (1e3 / t) || 0;
    return c * (t / 1e3);
  }, r.prototype.lineHeight = function(e, t) {
    var i;
    return t == null && (t = !1), i = t ? this.lineGap : 0, (this.ascender + i - this.decender) / 1e3 * e;
  }, r;
}();
var Rc, Jh = function() {
  function r(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return r.prototype.readByte = function() {
    return this.data[this.pos++];
  }, r.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, r.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, r.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, r.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, r.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, r.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, r.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, r.prototype.readString = function(e) {
    var t, i;
    for (i = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t) i[t] = String.fromCharCode(this.readByte());
    return i.join("");
  }, r.prototype.writeString = function(e) {
    var t, i, n;
    for (n = [], t = 0, i = e.length; 0 <= i ? t < i : t > i; t = 0 <= i ? ++t : --t) n.push(this.writeByte(e.charCodeAt(t)));
    return n;
  }, r.prototype.readShort = function() {
    return this.readInt16();
  }, r.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, r.prototype.readLongLong = function() {
    var e, t, i, n, s, c, o, d;
    return e = this.readByte(), t = this.readByte(), i = this.readByte(), n = this.readByte(), s = this.readByte(), c = this.readByte(), o = this.readByte(), d = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ i) + 4294967296 * (255 ^ n) + 16777216 * (255 ^ s) + 65536 * (255 ^ c) + 256 * (255 ^ o) + (255 ^ d) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * i + 4294967296 * n + 16777216 * s + 65536 * c + 256 * o + d;
  }, r.prototype.writeLongLong = function(e) {
    var t, i;
    return t = Math.floor(e / 4294967296), i = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(i >> 24 & 255), this.writeByte(i >> 16 & 255), this.writeByte(i >> 8 & 255), this.writeByte(255 & i);
  }, r.prototype.readInt = function() {
    return this.readInt32();
  }, r.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, r.prototype.read = function(e) {
    var t, i;
    for (t = [], i = 0; 0 <= e ? i < e : i > e; i = 0 <= e ? ++i : --i) t.push(this.readByte());
    return t;
  }, r.prototype.write = function(e) {
    var t, i, n, s;
    for (s = [], i = 0, n = e.length; i < n; i++) t = e[i], s.push(this.writeByte(t));
    return s;
  }, r;
}(), Uee = function() {
  var r;
  function e(t) {
    var i, n, s;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, n = 0, s = this.tableCount; 0 <= s ? n < s : n > s; n = 0 <= s ? ++n : --n) i = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[i.tag] = i;
  }
  return e.prototype.encode = function(t) {
    var i, n, s, c, o, d, m, y, T, P, I, D, k;
    for (k in I = Object.keys(t).length, d = Math.log(2), T = 16 * Math.floor(Math.log(I) / d), c = Math.floor(T / d), y = 16 * I - T, (n = new Jh()).writeInt(this.scalarType), n.writeShort(I), n.writeShort(T), n.writeShort(c), n.writeShort(y), s = 16 * I, m = n.pos + s, o = null, D = [], t) for (P = t[k], n.writeString(k), n.writeInt(r(P)), n.writeInt(m), n.writeInt(P.length), D = D.concat(P), k === "head" && (o = m), m += P.length; m % 4; ) D.push(0), m++;
    return n.write(D), i = 2981146554 - r(n.data), n.pos = o + 8, n.writeUInt32(i), n.data;
  }, r = function(t) {
    var i, n, s, c;
    for (t = YR.call(t); t.length % 4; ) t.push(0);
    for (s = new Jh(t), n = 0, i = 0, c = t.length; i < c; i = i += 4) n += s.readUInt32();
    return 4294967295 & n;
  }, e;
}(), zee = {}.hasOwnProperty, Au = function(r, e) {
  for (var t in e) zee.call(e, t) && (r[t] = e[t]);
  function i() {
    this.constructor = r;
  }
  return i.prototype = e.prototype, r.prototype = new i(), r.__super__ = e.prototype, r;
};
Rc = function() {
  function r(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return r.prototype.parse = function() {
  }, r.prototype.encode = function() {
  }, r.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, r;
}();
var jee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "head", r.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.revision = e.readInt(), this.checkSumAdjustment = e.readInt(), this.magicNumber = e.readInt(), this.flags = e.readShort(), this.unitsPerEm = e.readShort(), this.created = e.readLongLong(), this.modified = e.readLongLong(), this.xMin = e.readShort(), this.yMin = e.readShort(), this.xMax = e.readShort(), this.yMax = e.readShort(), this.macStyle = e.readShort(), this.lowestRecPPEM = e.readShort(), this.fontDirectionHint = e.readShort(), this.indexToLocFormat = e.readShort(), this.glyphDataFormat = e.readShort();
  }, r.prototype.encode = function(e) {
    var t;
    return (t = new Jh()).writeInt(this.version), t.writeInt(this.revision), t.writeInt(this.checkSumAdjustment), t.writeInt(this.magicNumber), t.writeShort(this.flags), t.writeShort(this.unitsPerEm), t.writeLongLong(this.created), t.writeLongLong(this.modified), t.writeShort(this.xMin), t.writeShort(this.yMin), t.writeShort(this.xMax), t.writeShort(this.yMax), t.writeShort(this.macStyle), t.writeShort(this.lowestRecPPEM), t.writeShort(this.fontDirectionHint), t.writeShort(e), t.writeShort(this.glyphDataFormat), t.data;
  }, r;
}(), FC = function() {
  function r(e, t) {
    var i, n, s, c, o, d, m, y, T, P, I, D, k, $, G, te, Z;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), T = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (d = 0; d < 256; ++d) this.codeMap[d] = e.readByte();
        break;
      case 4:
        for (I = e.readUInt16(), P = I / 2, e.pos += 6, s = function() {
          var H, J;
          for (J = [], d = H = 0; 0 <= P ? H < P : H > P; d = 0 <= P ? ++H : --H) J.push(e.readUInt16());
          return J;
        }(), e.pos += 2, k = function() {
          var H, J;
          for (J = [], d = H = 0; 0 <= P ? H < P : H > P; d = 0 <= P ? ++H : --H) J.push(e.readUInt16());
          return J;
        }(), m = function() {
          var H, J;
          for (J = [], d = H = 0; 0 <= P ? H < P : H > P; d = 0 <= P ? ++H : --H) J.push(e.readUInt16());
          return J;
        }(), y = function() {
          var H, J;
          for (J = [], d = H = 0; 0 <= P ? H < P : H > P; d = 0 <= P ? ++H : --H) J.push(e.readUInt16());
          return J;
        }(), n = (this.length - e.pos + this.offset) / 2, o = function() {
          var H, J;
          for (J = [], d = H = 0; 0 <= n ? H < n : H > n; d = 0 <= n ? ++H : --H) J.push(e.readUInt16());
          return J;
        }(), d = G = 0, Z = s.length; G < Z; d = ++G) for ($ = s[d], i = te = D = k[d]; D <= $ ? te <= $ : te >= $; i = D <= $ ? ++te : --te) y[d] === 0 ? c = i + m[d] : (c = o[y[d] / 2 + (i - D) - (P - d)] || 0) !== 0 && (c += m[d]), this.codeMap[i] = 65535 & c;
    }
    e.pos = T;
  }
  return r.encode = function(e, t) {
    var i, n, s, c, o, d, m, y, T, P, I, D, k, $, G, te, Z, H, J, re, be, pe, oe, Ee, le, _e, Ve, Be, gt, St, Mt, mt, wt, Yt, Dt, fe, De, je, Ke, rt, at, Et, Tt, Vt, tr, ur;
    switch (Be = new Jh(), c = Object.keys(e).sort(function(dr, Ct) {
      return dr - Ct;
    }), t) {
      case "macroman":
        for (k = 0, $ = function() {
          var dr = [];
          for (D = 0; D < 256; ++D) dr.push(0);
          return dr;
        }(), te = { 0: 0 }, s = {}, gt = 0, wt = c.length; gt < wt; gt++) te[Tt = e[n = c[gt]]] == null && (te[Tt] = ++k), s[n] = { old: e[n], new: te[e[n]] }, $[n] = te[e[n]];
        return Be.writeUInt16(1), Be.writeUInt16(0), Be.writeUInt32(12), Be.writeUInt16(0), Be.writeUInt16(262), Be.writeUInt16(0), Be.write($), { charMap: s, subtable: Be.data, maxGlyphID: k + 1 };
      case "unicode":
        for (_e = [], T = [], Z = 0, te = {}, i = {}, G = m = null, St = 0, Yt = c.length; St < Yt; St++) te[J = e[n = c[St]]] == null && (te[J] = ++Z), i[n] = { old: J, new: te[J] }, o = te[J] - n, G != null && o === m || (G && T.push(G), _e.push(n), m = o), G = n;
        for (G && T.push(G), T.push(65535), _e.push(65535), Ee = 2 * (oe = _e.length), pe = 2 * Math.pow(Math.log(oe) / Math.LN2, 2), P = Math.log(pe / 2) / Math.LN2, be = 2 * oe - pe, d = [], re = [], I = [], D = Mt = 0, Dt = _e.length; Mt < Dt; D = ++Mt) {
          if (le = _e[D], y = T[D], le === 65535) {
            d.push(0), re.push(0);
            break;
          }
          if (le - (Ve = i[le].new) >= 32768) for (d.push(0), re.push(2 * (I.length + oe - D)), n = mt = le; le <= y ? mt <= y : mt >= y; n = le <= y ? ++mt : --mt) I.push(i[n].new);
          else d.push(Ve - le), re.push(0);
        }
        for (Be.writeUInt16(3), Be.writeUInt16(1), Be.writeUInt32(12), Be.writeUInt16(4), Be.writeUInt16(16 + 8 * oe + 2 * I.length), Be.writeUInt16(0), Be.writeUInt16(Ee), Be.writeUInt16(pe), Be.writeUInt16(P), Be.writeUInt16(be), at = 0, fe = T.length; at < fe; at++) n = T[at], Be.writeUInt16(n);
        for (Be.writeUInt16(0), Et = 0, De = _e.length; Et < De; Et++) n = _e[Et], Be.writeUInt16(n);
        for (Vt = 0, je = d.length; Vt < je; Vt++) o = d[Vt], Be.writeUInt16(o);
        for (tr = 0, Ke = re.length; tr < Ke; tr++) H = re[tr], Be.writeUInt16(H);
        for (ur = 0, rt = I.length; ur < rt; ur++) k = I[ur], Be.writeUInt16(k);
        return { charMap: i, subtable: Be.data, maxGlyphID: Z + 1 };
    }
  }, r;
}(), ZR = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "cmap", r.prototype.parse = function(e) {
    var t, i, n;
    for (e.pos = this.offset, this.version = e.readUInt16(), n = e.readUInt16(), this.tables = [], this.unicode = null, i = 0; 0 <= n ? i < n : i > n; i = 0 <= n ? ++i : --i) t = new FC(e, this.offset), this.tables.push(t), t.isUnicode && this.unicode == null && (this.unicode = t);
    return !0;
  }, r.encode = function(e, t) {
    var i, n;
    return t == null && (t = "macroman"), i = FC.encode(e, t), (n = new Jh()).writeUInt16(0), n.writeUInt16(1), i.table = n.data.concat(i.subtable), i;
  }, r;
}(), Vee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "hhea", r.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.ascender = e.readShort(), this.decender = e.readShort(), this.lineGap = e.readShort(), this.advanceWidthMax = e.readShort(), this.minLeftSideBearing = e.readShort(), this.minRightSideBearing = e.readShort(), this.xMaxExtent = e.readShort(), this.caretSlopeRise = e.readShort(), this.caretSlopeRun = e.readShort(), this.caretOffset = e.readShort(), e.pos += 8, this.metricDataFormat = e.readShort(), this.numberOfMetrics = e.readUInt16();
  }, r;
}(), Gee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "OS/2", r.prototype.parse = function(e) {
    if (e.pos = this.offset, this.version = e.readUInt16(), this.averageCharWidth = e.readShort(), this.weightClass = e.readUInt16(), this.widthClass = e.readUInt16(), this.type = e.readShort(), this.ySubscriptXSize = e.readShort(), this.ySubscriptYSize = e.readShort(), this.ySubscriptXOffset = e.readShort(), this.ySubscriptYOffset = e.readShort(), this.ySuperscriptXSize = e.readShort(), this.ySuperscriptYSize = e.readShort(), this.ySuperscriptXOffset = e.readShort(), this.ySuperscriptYOffset = e.readShort(), this.yStrikeoutSize = e.readShort(), this.yStrikeoutPosition = e.readShort(), this.familyClass = e.readShort(), this.panose = function() {
      var t, i;
      for (i = [], t = 0; t < 10; ++t) i.push(e.readByte());
      return i;
    }(), this.charRange = function() {
      var t, i;
      for (i = [], t = 0; t < 4; ++t) i.push(e.readInt());
      return i;
    }(), this.vendorID = e.readString(4), this.selection = e.readShort(), this.firstCharIndex = e.readShort(), this.lastCharIndex = e.readShort(), this.version > 0 && (this.ascent = e.readShort(), this.descent = e.readShort(), this.lineGap = e.readShort(), this.winAscent = e.readShort(), this.winDescent = e.readShort(), this.codePageRange = function() {
      var t, i;
      for (i = [], t = 0; t < 2; t = ++t) i.push(e.readInt());
      return i;
    }(), this.version > 1)) return this.xHeight = e.readShort(), this.capHeight = e.readShort(), this.defaultChar = e.readShort(), this.breakChar = e.readShort(), this.maxContext = e.readShort();
  }, r;
}(), $ee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "post", r.prototype.parse = function(e) {
    var t, i, n;
    switch (e.pos = this.offset, this.format = e.readInt(), this.italicAngle = e.readInt(), this.underlinePosition = e.readShort(), this.underlineThickness = e.readShort(), this.isFixedPitch = e.readInt(), this.minMemType42 = e.readInt(), this.maxMemType42 = e.readInt(), this.minMemType1 = e.readInt(), this.maxMemType1 = e.readInt(), this.format) {
      case 65536:
      case 196608:
        break;
      case 131072:
        var s;
        for (i = e.readUInt16(), this.glyphNameIndex = [], s = 0; 0 <= i ? s < i : s > i; s = 0 <= i ? ++s : --s) this.glyphNameIndex.push(e.readUInt16());
        for (this.names = [], n = []; e.pos < this.offset + this.length; ) t = e.readByte(), n.push(this.names.push(e.readString(t)));
        return n;
      case 151552:
        return i = e.readUInt16(), this.offsets = e.read(i);
      case 262144:
        return this.map = (function() {
          var c, o, d;
          for (d = [], s = c = 0, o = this.file.maxp.numGlyphs; 0 <= o ? c < o : c > o; s = 0 <= o ? ++c : --c) d.push(e.readUInt32());
          return d;
        }).call(this);
    }
  }, r;
}(), Hee = function(r, e) {
  this.raw = r, this.length = r.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, qee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "name", r.prototype.parse = function(e) {
    var t, i, n, s, c, o, d, m, y, T, P;
    for (e.pos = this.offset, e.readShort(), t = e.readShort(), o = e.readShort(), i = [], s = 0; 0 <= t ? s < t : s > t; s = 0 <= t ? ++s : --s) i.push({ platformID: e.readShort(), encodingID: e.readShort(), languageID: e.readShort(), nameID: e.readShort(), length: e.readShort(), offset: this.offset + o + e.readShort() });
    for (d = {}, s = y = 0, T = i.length; y < T; s = ++y) n = i[s], e.pos = n.offset, m = e.readString(n.length), c = new Hee(m, n), d[P = n.nameID] == null && (d[P] = []), d[n.nameID].push(c);
    this.strings = d, this.copyright = d[0], this.fontFamily = d[1], this.fontSubfamily = d[2], this.uniqueSubfamily = d[3], this.fontName = d[4], this.version = d[5];
    try {
      this.postscriptName = d[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = d[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = d[7], this.manufacturer = d[8], this.designer = d[9], this.description = d[10], this.vendorUrl = d[11], this.designerUrl = d[12], this.license = d[13], this.licenseUrl = d[14], this.preferredFamily = d[15], this.preferredSubfamily = d[17], this.compatibleFull = d[18], this.sampleText = d[19];
  }, r;
}(), Wee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "maxp", r.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.numGlyphs = e.readUInt16(), this.maxPoints = e.readUInt16(), this.maxContours = e.readUInt16(), this.maxCompositePoints = e.readUInt16(), this.maxComponentContours = e.readUInt16(), this.maxZones = e.readUInt16(), this.maxTwilightPoints = e.readUInt16(), this.maxStorage = e.readUInt16(), this.maxFunctionDefs = e.readUInt16(), this.maxInstructionDefs = e.readUInt16(), this.maxStackElements = e.readUInt16(), this.maxSizeOfInstructions = e.readUInt16(), this.maxComponentElements = e.readUInt16(), this.maxComponentDepth = e.readUInt16();
  }, r;
}(), Xee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "hmtx", r.prototype.parse = function(e) {
    var t, i, n, s, c, o, d;
    for (e.pos = this.offset, this.metrics = [], t = 0, o = this.file.hhea.numberOfMetrics; 0 <= o ? t < o : t > o; t = 0 <= o ? ++t : --t) this.metrics.push({ advance: e.readUInt16(), lsb: e.readInt16() });
    for (n = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var m, y;
      for (y = [], t = m = 0; 0 <= n ? m < n : m > n; t = 0 <= n ? ++m : --m) y.push(e.readInt16());
      return y;
    }(), this.widths = (function() {
      var m, y, T, P;
      for (P = [], m = 0, y = (T = this.metrics).length; m < y; m++) s = T[m], P.push(s.advance);
      return P;
    }).call(this), i = this.widths[this.widths.length - 1], d = [], t = c = 0; 0 <= n ? c < n : c > n; t = 0 <= n ? ++c : --c) d.push(this.widths.push(i));
    return d;
  }, r.prototype.forGlyph = function(e) {
    return e in this.metrics ? this.metrics[e] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[e - this.metrics.length] };
  }, r;
}(), YR = [].slice, Zee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "glyf", r.prototype.parse = function() {
    return this.cache = {};
  }, r.prototype.glyphFor = function(e) {
    var t, i, n, s, c, o, d, m, y, T;
    return e in this.cache ? this.cache[e] : (s = this.file.loca, t = this.file.contents, i = s.indexOf(e), (n = s.lengthOf(e)) === 0 ? this.cache[e] = null : (t.pos = this.offset + i, c = (o = new Jh(t.read(n))).readShort(), m = o.readShort(), T = o.readShort(), d = o.readShort(), y = o.readShort(), this.cache[e] = c === -1 ? new Jee(o, m, T, d, y) : new Yee(o, c, m, T, d, y), this.cache[e]));
  }, r.prototype.encode = function(e, t, i) {
    var n, s, c, o, d;
    for (c = [], s = [], o = 0, d = t.length; o < d; o++) n = e[t[o]], s.push(c.length), n && (c = c.concat(n.encode(i)));
    return s.push(c.length), { table: c, offsets: s };
  }, r;
}(), Yee = function() {
  function r(e, t, i, n, s, c) {
    this.raw = e, this.numberOfContours = t, this.xMin = i, this.yMin = n, this.xMax = s, this.yMax = c, this.compound = !1;
  }
  return r.prototype.encode = function() {
    return this.raw.data;
  }, r;
}(), Jee = function() {
  function r(e, t, i, n, s) {
    var c, o;
    for (this.raw = e, this.xMin = t, this.yMin = i, this.xMax = n, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], c = this.raw; o = c.readShort(), this.glyphOffsets.push(c.pos), this.glyphIDs.push(c.readUInt16()), 32 & o; ) c.pos += 1 & o ? 4 : 2, 128 & o ? c.pos += 8 : 64 & o ? c.pos += 4 : 8 & o && (c.pos += 2);
  }
  return r.prototype.encode = function() {
    var e, t, i;
    for (t = new Jh(YR.call(this.raw.data)), e = 0, i = this.glyphIDs.length; e < i; ++e) t.pos = this.glyphOffsets[e];
    return t.data;
  }, r;
}(), Kee = function() {
  function r() {
    return r.__super__.constructor.apply(this, arguments);
  }
  return Au(r, Rc), r.prototype.tag = "loca", r.prototype.parse = function(e) {
    var t, i;
    return e.pos = this.offset, t = this.file.head.indexToLocFormat, this.offsets = t === 0 ? (function() {
      var n, s;
      for (s = [], i = 0, n = this.length; i < n; i += 2) s.push(2 * e.readUInt16());
      return s;
    }).call(this) : (function() {
      var n, s;
      for (s = [], i = 0, n = this.length; i < n; i += 4) s.push(e.readUInt32());
      return s;
    }).call(this);
  }, r.prototype.indexOf = function(e) {
    return this.offsets[e];
  }, r.prototype.lengthOf = function(e) {
    return this.offsets[e + 1] - this.offsets[e];
  }, r.prototype.encode = function(e, t) {
    for (var i = new Uint32Array(this.offsets.length), n = 0, s = 0, c = 0; c < i.length; ++c) if (i[c] = n, s < t.length && t[s] == c) {
      ++s, i[c] = n;
      var o = this.offsets[c], d = this.offsets[c + 1] - o;
      d > 0 && (n += d);
    }
    for (var m = new Array(4 * i.length), y = 0; y < i.length; ++y) m[4 * y + 3] = 255 & i[y], m[4 * y + 2] = (65280 & i[y]) >> 8, m[4 * y + 1] = (16711680 & i[y]) >> 16, m[4 * y] = (4278190080 & i[y]) >> 24;
    return m;
  }, r;
}(), Qee = function() {
  function r(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return r.prototype.generateCmap = function() {
    var e, t, i, n, s;
    for (t in n = this.font.cmap.tables[0].codeMap, e = {}, s = this.subset) i = s[t], e[t] = n[i];
    return e;
  }, r.prototype.glyphsFor = function(e) {
    var t, i, n, s, c, o, d;
    for (n = {}, c = 0, o = e.length; c < o; c++) n[s = e[c]] = this.font.glyf.glyphFor(s);
    for (s in t = [], n) (i = n[s]) != null && i.compound && t.push.apply(t, i.glyphIDs);
    if (t.length > 0) for (s in d = this.glyphsFor(t)) i = d[s], n[s] = i;
    return n;
  }, r.prototype.encode = function(e, t) {
    var i, n, s, c, o, d, m, y, T, P, I, D, k, $, G;
    for (n in i = ZR.encode(this.generateCmap(), "unicode"), c = this.glyphsFor(e), I = { 0: 0 }, G = i.charMap) I[(d = G[n]).old] = d.new;
    for (D in P = i.maxGlyphID, c) D in I || (I[D] = P++);
    return y = function(te) {
      var Z, H;
      for (Z in H = {}, te) H[te[Z]] = Z;
      return H;
    }(I), T = Object.keys(y).sort(function(te, Z) {
      return te - Z;
    }), k = function() {
      var te, Z, H;
      for (H = [], te = 0, Z = T.length; te < Z; te++) o = T[te], H.push(y[o]);
      return H;
    }(), s = this.font.glyf.encode(c, k, I), m = this.font.loca.encode(s.offsets, k), $ = { cmap: this.font.cmap.raw(), glyf: s.table, loca: m, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && ($["OS/2"] = this.font.os2.raw()), this.font.directory.encode($);
  }, r;
}();
Ur.API.PDFObject = function() {
  var r;
  function e() {
  }
  return r = function(t, i) {
    return (Array(i + 1).join("0") + t).slice(-i);
  }, e.convert = function(t) {
    var i, n, s, c;
    if (Array.isArray(t)) return "[" + function() {
      var o, d, m;
      for (m = [], o = 0, d = t.length; o < d; o++) i = t[o], m.push(e.convert(i));
      return m;
    }().join(" ") + "]";
    if (typeof t == "string") return "/" + t;
    if (t?.isString) return "(" + t + ")";
    if (t instanceof Date) return "(D:" + r(t.getUTCFullYear(), 4) + r(t.getUTCMonth(), 2) + r(t.getUTCDate(), 2) + r(t.getUTCHours(), 2) + r(t.getUTCMinutes(), 2) + r(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (n in s = ["<<"], t) c = t[n], s.push("/" + n + " " + e.convert(c));
      return s.push(">>"), s.join(`
`);
    }
    return "" + t;
  }, e;
}();
const rw = { "circle-radius": 8, "circle-color": "red", "circle-stroke-width": 1, "circle-stroke-color": "black" }, $y = { style: { textSize: 16, textHaloColor: "#FFFFFF", textHaloWidth: 0.8, textColor: "#000000", fallbackTextFont: ["Open Sans Regular"] }, visibility: "visible", position: "bottom-right" }, Hy = { image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>', imageName: "gl-export-north-icon", imageSizeFraction: 0.05, visibility: "visible", position: "top-right" };
class ete {
  map;
  width;
  height;
  dpi;
  format;
  unit;
  fileName;
  markerClassName;
  markerCirclePaint;
  attributionClassName;
  attributionOptions;
  northIconOptions;
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e, t = Uf.A4, i = 300, n = ih.PNG, s = Mp.mm, c = "map", o = "maplibregl-marker", d = rw, m = "maplibregl-ctrl-attrib-inner", y = $y, T = Hy) {
    this.map = e, this.width = t[0], this.height = t[1], this.dpi = i, this.format = n, this.unit = s, this.fileName = c, this.markerClassName = o, this.markerCirclePaint = d, this.attributionClassName = m, this.attributionOptions = y, this.northIconOptions = T;
  }
  renderMapPost(e) {
    return e;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(e) {
    const t = this.getMarkers();
    for (let i = 0; i < t.length; i++) {
      const n = t.item(i);
      if (!n) continue;
      const s = n.getAttribute("style");
      if (!s) continue;
      const c = /translate\(([^,]+)px,\s*([^,]+)px\)/, o = s.match(c);
      if (!o) continue;
      const d = parseInt(o[1]), m = parseInt(o[2]), y = this.map.unproject([d, m]), T = `point${i}`;
      e.addSource(T, { type: "geojson", data: { type: "Point", coordinates: [y.lng, y.lat] } }), e.addLayer({ id: T, source: T, type: "circle", paint: this.markerCirclePaint });
    }
    return e;
  }
  /**
  * Generate and download Map image
  */
  generate() {
    const e = this;
    this.addLoader(), this.showLoader();
    const t = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", { get() {
      return e.dpi / 96;
    } });
    const i = document.createElement("div");
    i.className = "hidden-map", document.body.appendChild(i);
    const n = document.createElement("div");
    n.style.width = this.toPixels(this.width), n.style.height = this.toPixels(this.height), i.appendChild(n);
    const s = this.map.getStyle();
    if (s && s.sources) {
      const o = s.sources;
      Object.keys(o).forEach((d) => {
        const m = o[d];
        Object.keys(m).forEach((y) => {
          m[y] || delete m[y];
        });
      });
    }
    let c = this.getRenderedMap(n, s);
    c.on("load", () => {
      this.addNorthIconToMap(c).then(() => {
        c.once("idle", () => {
          this.addAttributions(c) ? c.once("idle", () => {
            c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, i, t) : (c = this.renderMarkers(c), c.once("idle", () => {
              this.exportImage(c, i, t);
            }));
          }) : (c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, i, t) : (c = this.renderMarkers(c), c.once("idle", () => {
            this.exportImage(c, i, t);
          })));
        });
      });
    });
  }
  stripHtml(e) {
    const t = document.createElement("div");
    return t.innerHTML = e, t.textContent || t.innerText || "";
  }
  /**
  * Get icon width against exported map size by using fraction rate
  * @param renderMap Map object
  * @param fraction adjust icon size by using this fraction rate. Default is 8%
  * @returns Icon width calculated
  */
  getIconWidth(e, t) {
    const i = e.getContainer(), n = parseInt(i.style.width.replace("px", ""));
    return parseInt(`${n * t}`);
  }
  /**
  * Get element position's pixel values based on selected position setting
  * @param renderMap Map object
  * @param position Position of element inserted
  * @param offset Offset value to adjust position
  * @returns Pixels [width, height]
  */
  getElementPosition(e, t, i = 0) {
    const n = e.getContainer();
    let s = 0, c = 0;
    switch (t) {
      case "top-left":
        s = 0 + i, c = 0 + i;
        break;
      case "top-right":
        s = parseInt(n.style.width.replace("px", "")) - i, c = 0 + i;
        break;
      case "bottom-left":
        s = 0 + i, c = parseInt(n.style.height.replace("px", "")) - i;
        break;
      case "bottom-right":
        s = parseInt(n.style.width.replace("px", "")) - i, c = parseInt(n.style.height.replace("px", "")) - i;
        break;
    }
    return [s, c];
  }
  /**
  * Add North Icon SVG to map object
  * @param renderMap Map object
  * @returns void
  */
  addNorthIconImage(e) {
    const t = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((i) => {
      const n = new Image(t, t);
      n.onload = () => {
        this.northIconOptions.imageName && e.addImage(this.northIconOptions.imageName, n), i();
      };
      function s(c) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(c);
      }
      this.northIconOptions.image && (n.src = s(this.northIconOptions.image));
    });
  }
  /**
  * Add North Icon Symbol layer to renderMap object
  * @param renderMap Map object
  * @returns
  */
  addNorthIconToMap(e) {
    let t = this.northIconOptions.visibility ?? "visible";
    return e.getZoom() < 2 && this.width > this.height && (t = "none"), new Promise((i) => {
      this.addNorthIconImage(e).then(() => {
        const n = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08) * 0.8, s = this.getElementPosition(e, this.northIconOptions.position ?? "top-right", n), c = e.unproject(s), o = this.northIconOptions.imageName ?? "gl-export-north-icon";
        e.addSource(o, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [c.lng, c.lat] }, properties: {} } }), e.addLayer({ id: o, source: o, type: "symbol", layout: { "icon-image": o, "icon-size": 1, "icon-rotate": e.getBearing() * -1, "icon-allow-overlap": !0, "icon-ignore-placement": !0, visibility: t }, paint: {} }), i();
      });
    });
  }
  addAttributions(e) {
    if (!this.map.getStyle().glyphs) return !1;
    const t = e.getContainer(), i = this.attributionOptions.position ?? "bottom-right", n = this.getElementPosition(e, i, 5), s = n[0], c = e.unproject(n), o = t.getElementsByClassName(this.attributionClassName), d = [];
    if (o?.length > 0) {
      const k = o.item(0);
      if (k) for (let $ = 0; $ < k.children.length; $++) {
        const G = k.children.item($);
        G && d.push(this.stripHtml(G.outerHTML));
      }
    } else {
      const k = this.map.getStyle().sources;
      Object.keys(k).forEach(($) => {
        const G = k[$];
        if ("attribution" in G) {
          const te = G.attribution;
          d.push(this.stripHtml(te));
        }
      });
    }
    if (d.length === 0) return !1;
    const m = d.join(" | "), y = "attribution";
    e.addSource(y, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [c.lng, c.lat] }, properties: { attribution: m } } });
    const T = this.map.getStyle().layers.filter((k) => k.type === "symbol" && k.layout && "text-font" in k.layout), P = T.length > 0 && T[0].layout ? T[0].layout["text-font"] : this.attributionOptions.style?.fallbackTextFont;
    let I = this.attributionOptions.visibility ?? "visible";
    e.getZoom() < 2 && this.width > this.height && (I = "none");
    const D = this.attributionOptions.style;
    return e.addLayer({ id: y, source: y, type: "symbol", layout: { "text-field": ["get", "attribution"], "text-font": P, "text-max-width": parseInt(`${s / D.textSize}`), "text-anchor": i, "text-justify": ["top-right", "bottom-right"].includes(i) ? "right" : "left", "text-size": D.textSize, "text-allow-overlap": !0, visibility: I }, paint: { "text-halo-color": D.textHaloColor, "text-halo-width": D.textHaloWidth, "text-color": D.textColor } }), !0;
  }
  exportImage(e, t, i) {
    const n = e.getCanvas(), s = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case ih.PNG:
        this.toPNG(n, s);
        break;
      case ih.JPEG:
        this.toJPEG(n, s);
        break;
      case ih.PDF:
        this.toPDF(e, s);
        break;
      case ih.SVG:
        this.toSVG(n, s);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    e.remove(), t.parentNode?.removeChild(t), Object.defineProperty(window, "devicePixelRatio", { get() {
      return i;
    } }), t.remove(), this.hideLoader();
  }
  /**
  * Convert canvas to PNG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toPNG(e, t) {
    const i = document.createElement("a");
    i.href = e.toDataURL(), i.download = t, i.click(), i.remove();
  }
  /**
  * Convert canvas to JPEG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toJPEG(e, t) {
    const i = e.toDataURL("image/jpeg", 0.85), n = document.createElement("a");
    n.href = i, n.download = t, n.click(), n.remove();
  }
  /**
  * Convert Map object to PDF
  * @param map Map object
  * @param fileName file name
  */
  toPDF(e, t) {
    const i = e.getCanvas(), n = new Ur({ orientation: this.width > this.height ? "l" : "p", unit: this.unit, compress: !0, format: [this.width, this.height] });
    n.addImage(i.toDataURL("image/png"), "png", 0, 0, this.width, this.height, void 0, "FAST");
    const { lng: s, lat: c } = e.getCenter();
    n.setProperties({ title: e.getStyle().name, subject: `center: [${s}, ${c}], zoom: ${e.getZoom()}`, creator: "Mapbox GL Export Plugin", author: "(c)Mapbox, (c)OpenStreetMap" }), n.save(t);
  }
  /**
  * Convert canvas to SVG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toSVG(e, t) {
    const i = e.toDataURL("image/png"), n = Number(this.toPixels(this.width, this.dpi).replace("px", "")), s = Number(this.toPixels(this.height, this.dpi).replace("px", "")), c = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${n}" 
      height="${s}" 
      viewBox="0 0 ${n} ${s}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${i}" width="${n}" height="${s}"></image>
    </svg>`, o = document.createElement("a");
    o.href = `data:application/xml,${encodeURIComponent(c)}`, o.download = t, o.click(), o.remove();
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e, t = 96) {
    return this.unit === Mp.mm && (t /= 25.4), `${t * e}px`;
  }
  /**
  * Add loader in the parent element of maplibre map.
  */
  addLoader() {
    const e = this.map.getCanvas().parentElement?.parentElement;
    if (!e || e.getElementsByClassName("map-export-loader").length > 0) return;
    const t = document.createElement("span");
    t.classList.add("map-export-loader"), t.classList.add("loader-default"), e.appendChild(t);
  }
  /**
  * Show loader
  */
  showLoader() {
    const e = this.map.getCanvas().parentElement?.parentElement;
    if (!e) return;
    const t = e.getElementsByClassName("map-export-loader");
    t && t.length > 0 && t.item(0)?.classList.add("is-active");
  }
  /**
  * Hide loader
  */
  hideLoader() {
    const e = this.map.getCanvas().parentElement?.parentElement;
    if (!e) return;
    const t = e.getElementsByClassName("map-export-loader");
    t && t.length > 0 && t.item(0)?.classList.remove("is-active");
  }
}
class tte extends ete {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e, t = Uf.A4, i = 300, n = ih.PNG, s = Mp.mm, c = "map", o = rw, d = $y, m = Hy) {
    super(e, t, i, n, s, c, "maplibregl-marker", o, "maplibregl-ctrl-attrib-inner", d, m);
  }
  getRenderedMap(e, t) {
    const i = new g5.Map({
      container: e,
      style: t,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      canvasContextAttributes: { preserveDrawingBuffer: !0 },
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transform request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (i.setMaxPitch(85), i.setPitch(this.map.getPitch()));
    const n = (this.map.style.imageManager || {}).images || [];
    return Object.keys(n).forEach((s) => {
      n[s].data && i.addImage(s, n[s].data);
    }), i;
  }
  renderMapPost(e) {
    const t = this.map.getTerrain();
    return t && e.setTerrain({ source: t.source, exaggeration: t.exaggeration }), e;
  }
}
class rte {
  controlContainer;
  exportContainer;
  crosshair;
  printableArea;
  map;
  exportButton;
  options = { PageSize: Uf.A4, PageOrientation: Pg.Landscape, Format: ih.PDF, DPI: Qv[300], Crosshair: !1, PrintableArea: !1, Local: "en", AllowedSizes: Object.keys(Uf), Filename: "map", markerCirclePaint: rw, attributionOptions: $y, northIconOptions: Hy };
  MAPLIB_CSS_PREFIX = "maplibregl";
  constructor(e) {
    e && (e.attributionOptions = Object.assign($y, e.attributionOptions), e.northIconOptions = Object.assign(Hy, e.northIconOptions), this.options = Object.assign(this.options, e)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const e = this.options.Local ?? "en";
    return hK(e);
  }
  onAdd(e) {
    this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const t = document.createElement("TABLE");
    t.className = "print-table";
    const i = {};
    this.options.AllowedSizes?.forEach((m) => {
      Uf[m] && (i[m] = Uf[m]);
    });
    const n = this.createSelection(i, this.getTranslation().PageSize, "page-size", this.options.PageSize, (m, y) => JSON.stringify(m[y]));
    t.appendChild(n);
    const s = this.createSelection(Pg, this.getTranslation().PageOrientation, "page-orientation", this.options.PageOrientation, (m, y) => m[y]);
    t.appendChild(s);
    const c = this.createSelection(ih, this.getTranslation().Format, "format-type", this.options.Format, (m, y) => m[y]);
    t.appendChild(c);
    const o = this.createSelection(Qv, this.getTranslation().DPI, "dpi-type", this.options.DPI, (m, y) => m[y]);
    t.appendChild(o), this.exportContainer.appendChild(t);
    const d = document.createElement("button");
    return d.type = "button", d.textContent = this.getTranslation().Generate, d.classList.add("generate-button"), d.addEventListener("click", () => {
      const m = document.getElementById("mapbox-gl-export-page-size"), y = document.getElementById("mapbox-gl-export-page-orientation"), T = document.getElementById("mapbox-gl-export-format-type"), P = document.getElementById("mapbox-gl-export-dpi-type"), I = y.value;
      let D = JSON.parse(m.value);
      I === Pg.Portrait && (D = D.reverse()), this.generateMap(e, D, Number(P.value), T.value, Mp.mm, this.options.Filename);
    }), this.exportContainer.appendChild(d), this.controlContainer;
  }
  generateMap(e, t, i, n, s, c) {
    new tte(e, t, i, n, s, c, this.options.markerCirclePaint, this.options.attributionOptions, this.options.northIconOptions).generate();
  }
  createSelection(e, t, i, n, s) {
    const c = document.createElement("label");
    c.textContent = t;
    const o = document.createElement("select");
    o.setAttribute("id", `mapbox-gl-export-${i}`), o.style.width = "100%", Object.keys(e).forEach((T) => {
      const P = document.createElement("option");
      P.setAttribute("value", s(e, T)), P.appendChild(document.createTextNode(T)), P.setAttribute("name", i), n === e[T] && (P.selected = !0), o.appendChild(P);
    }), o.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const d = document.createElement("TR"), m = document.createElement("TD"), y = document.createElement("TD");
    return m.appendChild(c), y.appendChild(o), d.appendChild(m), d.appendChild(y), d;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(e) {
    this.controlContainer && !this.controlContainer.contains(e.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(e) {
    this.options.Crosshair === !0 && (e === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new ZJ(this.map), this.crosshair.create()));
  }
  togglePrintableArea(e) {
    this.options.PrintableArea === !0 && (e === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new YJ(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0) return;
    const e = document.getElementById("mapbox-gl-export-page-size"), t = document.getElementById("mapbox-gl-export-page-orientation").value;
    let i = JSON.parse(e.value);
    t === Pg.Portrait && (i = i.reverse()), this.printableArea.updateArea(i[0], i[1]);
  }
}
function z1(r, e, t, i) {
  function n(s) {
    return s instanceof t ? s : new t(function(c) {
      c(s);
    });
  }
  return new (t || (t = Promise))(function(s, c) {
    function o(y) {
      try {
        m(i.next(y));
      } catch (T) {
        c(T);
      }
    }
    function d(y) {
      try {
        m(i.throw(y));
      } catch (T) {
        c(T);
      }
    }
    function m(y) {
      y.done ? s(y.value) : n(y.value).then(o, d);
    }
    m((i = i.apply(r, e || [])).next());
  });
}
var B_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function f0(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var j1, UC;
function JR() {
  if (UC) return j1;
  UC = 1, j1 = e;
  var r = Object.prototype.hasOwnProperty;
  function e() {
    for (var t = {}, i = 0; i < arguments.length; i++) {
      var n = arguments[i];
      for (var s in n)
        r.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }
  return j1;
}
var V1 = {
  exports: {}
}, zC;
function ite() {
  return zC || (zC = 1, function(r, e) {
    (function() {
      var t = {};
      r.exports = t, t.simpleFilter = function(i, n) {
        return n.filter(function(s) {
          return t.test(i, s);
        });
      }, t.test = function(i, n) {
        return t.match(i, n) !== null;
      }, t.match = function(i, n, s) {
        s = s || {};
        var c = 0, o = [], d = n.length, m = 0, y = 0, T = s.pre || "", P = s.post || "", I = s.caseSensitive && n || n.toLowerCase(), D;
        i = s.caseSensitive && i || i.toLowerCase();
        for (var k = 0; k < d; k++)
          D = n[k], I[k] === i[c] ? (D = T + D + P, c += 1, y += 1 + y) : y = 0, m += y, o[o.length] = D;
        return c === i.length ? (m = I === i ? 1 / 0 : m, {
          rendered: o.join(""),
          score: m
        }) : null;
      }, t.filter = function(i, n, s) {
        return !n || n.length === 0 ? [] : typeof i != "string" ? n : (s = s || {}, n.reduce(function(c, o, d, m) {
          var y = o;
          s.extract && (y = s.extract(o));
          var T = t.match(i, y, s);
          return T != null && (c[c.length] = {
            string: T.rendered,
            score: T.score,
            index: d,
            original: o
          }), c;
        }, []).sort(function(c, o) {
          var d = o.score - c.score;
          return d || c.index - o.index;
        }));
      };
    })();
  }(V1)), V1.exports;
}
var G1, jC;
function nte() {
  if (jC) return G1;
  jC = 1;
  var r = function(e) {
    return this.component = e, this.items = [], this.active = e.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, e.el.parentNode.insertBefore(this.wrapper, e.el.nextSibling), this;
  };
  return r.prototype.show = function() {
    this.element.style.display = "block";
  }, r.prototype.hide = function() {
    this.element.style.display = "none";
  }, r.prototype.add = function(e) {
    this.items.push(e);
  }, r.prototype.clear = function() {
    this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
  }, r.prototype.isEmpty = function() {
    return !this.items.length;
  }, r.prototype.isVisible = function() {
    return this.element.style.display === "block";
  }, r.prototype.draw = function() {
    if (this.element.innerHTML = "", this.items.length === 0) {
      this.hide();
      return;
    }
    for (var e = 0; e < this.items.length; e++)
      this.drawItem(this.items[e], this.active === e);
    this.show();
  }, r.prototype.drawItem = function(e, t) {
    var i = document.createElement("li"), n = document.createElement("a");
    t && (i.className += " active"), n.innerHTML = e.string, i.appendChild(n), this.element.appendChild(i), i.addEventListener("mousedown", (function() {
      this.selectingListItem = !0;
    }).bind(this)), i.addEventListener("mouseup", (function() {
      this.handleMouseUp.call(this, e);
    }).bind(this));
  }, r.prototype.handleMouseUp = function(e) {
    this.selectingListItem = !1, this.component.value(e.original), this.clear(), this.draw();
  }, r.prototype.move = function(e) {
    this.active = e, this.draw();
  }, r.prototype.previous = function() {
    this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
  }, r.prototype.next = function() {
    this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
  }, r.prototype.drawError = function(e) {
    var t = document.createElement("li");
    t.innerHTML = e, this.element.appendChild(t), this.show();
  }, G1 = r, G1;
}
var $1, VC;
function ste() {
  if (VC) return $1;
  VC = 1;
  var r = JR(), e = ite(), t = nte(), i = function(n, s, c) {
    return c = c || {}, this.options = r({
      minLength: 2,
      limit: 5,
      filter: !0,
      hideOnBlur: !0,
      noInitialSelection: !0
    }, c), this.el = n, this.data = s || [], this.list = new t(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(o) {
      this.handleKeyUp(o.keyCode, o);
    }).bind(this), !1), this.el.addEventListener("keydown", (function(o) {
      this.handleKeyDown(o);
    }).bind(this)), this.el.addEventListener("focus", (function() {
      this.handleFocus();
    }).bind(this)), this.el.addEventListener("blur", (function() {
      this.handleBlur();
    }).bind(this)), this.el.addEventListener("paste", (function(o) {
      this.handlePaste(o);
    }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
  };
  return i.prototype.handleKeyUp = function(n, s) {
    if (!(n === 40 || n === 38 || n === 27 || n === 9)) {
      if (n === 13) {
        this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), s.stopPropagation());
        return;
      }
      this.handleInputChange(this.el.value);
    }
  }, i.prototype.handleKeyDown = function(n) {
    switch (n.keyCode) {
      case 13:
        this.list.active >= 0 && (this.list.selectingListItem = !0);
        break;
      case 9:
        this.list.isEmpty() || (this.list.isVisible() && n.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
        break;
      case 27:
        this.list.isEmpty() || this.list.hide();
        break;
      case 38:
        this.list.previous();
        break;
      case 40:
        this.list.next();
        break;
    }
  }, i.prototype.handleBlur = function() {
    !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
  }, i.prototype.handlePaste = function(n) {
    if (n.clipboardData)
      this.handleInputChange(n.clipboardData.getData("Text"));
    else {
      var s = this;
      setTimeout(function() {
        s.handleInputChange(n.target.value);
      }, 100);
    }
  }, i.prototype.handleInputChange = function(n) {
    if (this.query = this.normalize(n), this.list.clear(), this.query.length < this.options.minLength) {
      this.list.draw();
      return;
    }
    this.getCandidates((function(s) {
      for (var c = 0; c < s.length && (this.list.add(s[c]), c !== this.options.limit - 1); c++)
        ;
      this.list.draw();
    }).bind(this));
  }, i.prototype.handleFocus = function() {
    this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
  }, i.prototype.update = function(n) {
    this.data = n, this.handleKeyUp();
  }, i.prototype.clear = function() {
    this.data = [], this.list.clear();
  }, i.prototype.normalize = function(n) {
    return n = n.toLowerCase(), n;
  }, i.prototype.match = function(n, s) {
    return n.indexOf(s) > -1;
  }, i.prototype.value = function(n) {
    if (this.selected = n, this.el.value = this.getItemValue(n || {
      place_name: this.query
    }), document.createEvent) {
      var s = document.createEvent("HTMLEvents");
      s.initEvent("change", !0, !1), this.el.dispatchEvent(s);
    } else
      this.el.fireEvent("onchange");
  }, i.prototype.getCandidates = function(n) {
    var s = {
      pre: "<strong>",
      post: "</strong>",
      extract: (function(o) {
        return this.getItemValue(o);
      }).bind(this)
    }, c;
    this.options.filter ? (c = e.filter(this.query, this.data, s), c = c.map((function(o) {
      return {
        original: o.original,
        string: this.render(o.original, o.string)
      };
    }).bind(this))) : c = this.data.map((function(o) {
      var d = this.render(o);
      return {
        original: o,
        string: d
      };
    }).bind(this)), n(c);
  }, i.prototype.getItemValue = function(n) {
    return n;
  }, i.prototype.render = function(n, s) {
    if (s)
      return s;
    for (var c = n.original ? this.getItemValue(n.original) : this.getItemValue(n), o = this.normalize(c), d = o.lastIndexOf(this.query); d > -1; ) {
      var m = d + this.query.length;
      c = c.slice(0, d) + "<strong>" + c.slice(d, m) + "</strong>" + c.slice(m), d = o.slice(0, d).lastIndexOf(this.query);
    }
    return c;
  }, i.prototype.renderError = function(n) {
    this.list.drawError(n);
  }, $1 = i, $1;
}
var H1, GC;
function ote() {
  if (GC) return H1;
  GC = 1;
  var r = ste();
  return H1 = r, typeof window < "u" && (window.Suggestions = r), H1;
}
var ate = ote(), lte = /* @__PURE__ */ f0(ate), oy = {
  exports: {}
}, cte = oy.exports, $C;
function ute() {
  return $C || ($C = 1, function(r) {
    (function(e, t, i) {
      r.exports ? r.exports = i() : e[t] = i();
    })(cte, "subtag", function() {
      var e = "", t = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
      function i(d) {
        return d.match(t) || [];
      }
      function n(d) {
        return i(d).filter(function(m, y) {
          return m && y;
        });
      }
      function s(d) {
        return d = i(d), {
          language: d[1] || e,
          extlang: d[2] || e,
          script: d[3] || e,
          region: d[4] || e
        };
      }
      function c(d, m, y) {
        Object.defineProperty(d, m, {
          value: y,
          enumerable: !0
        });
      }
      function o(d, m, y) {
        function T(P) {
          return i(P)[d] || e;
        }
        c(T, "pattern", m), c(s, y, T);
      }
      return o(1, /^[a-zA-Z]{2,3}$/, "language"), o(2, /^[a-zA-Z]{3}$/, "extlang"), o(3, /^[a-zA-Z]{4}$/, "script"), o(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), c(s, "split", n), s;
    });
  }(oy)), oy.exports;
}
var hte = ute(), fte = /* @__PURE__ */ f0(hte), q1, HC;
function dte() {
  if (HC) return q1;
  HC = 1;
  var r = "Expected a function", e = NaN, t = "[object Symbol]", i = /^\s+|\s+$/g, n = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, c = /^0o[0-7]+$/i, o = parseInt, d = typeof B_ == "object" && B_ && B_.Object === Object && B_, m = typeof self == "object" && self && self.Object === Object && self, y = d || m || Function("return this")(), T = Object.prototype, P = T.toString, I = Math.max, D = Math.min, k = function() {
    return y.Date.now();
  };
  function $(J, re, be) {
    var pe, oe, Ee, le, _e, Ve, Be = 0, gt = !1, St = !1, Mt = !0;
    if (typeof J != "function")
      throw new TypeError(r);
    re = H(re) || 0, G(be) && (gt = !!be.leading, St = "maxWait" in be, Ee = St ? I(H(be.maxWait) || 0, re) : Ee, Mt = "trailing" in be ? !!be.trailing : Mt);
    function mt(at) {
      var Et = pe, Tt = oe;
      return pe = oe = void 0, Be = at, le = J.apply(Tt, Et), le;
    }
    function wt(at) {
      return Be = at, _e = setTimeout(fe, re), gt ? mt(at) : le;
    }
    function Yt(at) {
      var Et = at - Ve, Tt = at - Be, Vt = re - Et;
      return St ? D(Vt, Ee - Tt) : Vt;
    }
    function Dt(at) {
      var Et = at - Ve, Tt = at - Be;
      return Ve === void 0 || Et >= re || Et < 0 || St && Tt >= Ee;
    }
    function fe() {
      var at = k();
      if (Dt(at))
        return De(at);
      _e = setTimeout(fe, Yt(at));
    }
    function De(at) {
      return _e = void 0, Mt && pe ? mt(at) : (pe = oe = void 0, le);
    }
    function je() {
      _e !== void 0 && clearTimeout(_e), Be = 0, pe = Ve = oe = _e = void 0;
    }
    function Ke() {
      return _e === void 0 ? le : De(k());
    }
    function rt() {
      var at = k(), Et = Dt(at);
      if (pe = arguments, oe = this, Ve = at, Et) {
        if (_e === void 0)
          return wt(Ve);
        if (St)
          return _e = setTimeout(fe, re), mt(Ve);
      }
      return _e === void 0 && (_e = setTimeout(fe, re)), le;
    }
    return rt.cancel = je, rt.flush = Ke, rt;
  }
  function G(J) {
    var re = typeof J;
    return !!J && (re == "object" || re == "function");
  }
  function te(J) {
    return !!J && typeof J == "object";
  }
  function Z(J) {
    return typeof J == "symbol" || te(J) && P.call(J) == t;
  }
  function H(J) {
    if (typeof J == "number")
      return J;
    if (Z(J))
      return e;
    if (G(J)) {
      var re = typeof J.valueOf == "function" ? J.valueOf() : J;
      J = G(re) ? re + "" : re;
    }
    if (typeof J != "string")
      return J === 0 ? J : +J;
    J = J.replace(i, "");
    var be = s.test(J);
    return be || c.test(J) ? o(J.slice(2), be ? 2 : 8) : n.test(J) ? e : +J;
  }
  return q1 = $, q1;
}
var pte = dte(), gte = /* @__PURE__ */ f0(pte), mte = JR(), dc = /* @__PURE__ */ f0(mte), k_ = {
  exports: {}
}, qC;
function _te() {
  if (qC) return k_.exports;
  qC = 1;
  var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(J, re, be) {
    return Function.prototype.apply.call(J, re, be);
  }, t;
  r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(J) {
    return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J));
  } : t = function(J) {
    return Object.getOwnPropertyNames(J);
  };
  function i(H) {
    console && console.warn && console.warn(H);
  }
  var n = Number.isNaN || function(J) {
    return J !== J;
  };
  function s() {
    s.init.call(this);
  }
  k_.exports = s, k_.exports.once = G, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var c = 10;
  function o(H) {
    if (typeof H != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof H);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return c;
    },
    set: function(H) {
      if (typeof H != "number" || H < 0 || n(H))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + H + ".");
      c = H;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(J) {
    if (typeof J != "number" || J < 0 || n(J))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + J + ".");
    return this._maxListeners = J, this;
  };
  function d(H) {
    return H._maxListeners === void 0 ? s.defaultMaxListeners : H._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return d(this);
  }, s.prototype.emit = function(J) {
    for (var re = [], be = 1; be < arguments.length; be++) re.push(arguments[be]);
    var pe = J === "error", oe = this._events;
    if (oe !== void 0) pe = pe && oe.error === void 0;
    else if (!pe) return !1;
    if (pe) {
      var Ee;
      if (re.length > 0 && (Ee = re[0]), Ee instanceof Error)
        throw Ee;
      var le = new Error("Unhandled error." + (Ee ? " (" + Ee.message + ")" : ""));
      throw le.context = Ee, le;
    }
    var _e = oe[J];
    if (_e === void 0) return !1;
    if (typeof _e == "function")
      e(_e, this, re);
    else
      for (var Ve = _e.length, Be = D(_e, Ve), be = 0; be < Ve; ++be) e(Be[be], this, re);
    return !0;
  };
  function m(H, J, re, be) {
    var pe, oe, Ee;
    if (o(re), oe = H._events, oe === void 0 ? (oe = H._events = /* @__PURE__ */ Object.create(null), H._eventsCount = 0) : (oe.newListener !== void 0 && (H.emit("newListener", J, re.listener ? re.listener : re), oe = H._events), Ee = oe[J]), Ee === void 0)
      Ee = oe[J] = re, ++H._eventsCount;
    else if (typeof Ee == "function" ? Ee = oe[J] = be ? [re, Ee] : [Ee, re] : be ? Ee.unshift(re) : Ee.push(re), pe = d(H), pe > 0 && Ee.length > pe && !Ee.warned) {
      Ee.warned = !0;
      var le = new Error("Possible EventEmitter memory leak detected. " + Ee.length + " " + String(J) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      le.name = "MaxListenersExceededWarning", le.emitter = H, le.type = J, le.count = Ee.length, i(le);
    }
    return H;
  }
  s.prototype.addListener = function(J, re) {
    return m(this, J, re, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(J, re) {
    return m(this, J, re, !0);
  };
  function y() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function T(H, J, re) {
    var be = {
      fired: !1,
      wrapFn: void 0,
      target: H,
      type: J,
      listener: re
    }, pe = y.bind(be);
    return pe.listener = re, be.wrapFn = pe, pe;
  }
  s.prototype.once = function(J, re) {
    return o(re), this.on(J, T(this, J, re)), this;
  }, s.prototype.prependOnceListener = function(J, re) {
    return o(re), this.prependListener(J, T(this, J, re)), this;
  }, s.prototype.removeListener = function(J, re) {
    var be, pe, oe, Ee, le;
    if (o(re), pe = this._events, pe === void 0) return this;
    if (be = pe[J], be === void 0) return this;
    if (be === re || be.listener === re)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete pe[J], pe.removeListener && this.emit("removeListener", J, be.listener || re));
    else if (typeof be != "function") {
      for (oe = -1, Ee = be.length - 1; Ee >= 0; Ee--)
        if (be[Ee] === re || be[Ee].listener === re) {
          le = be[Ee].listener, oe = Ee;
          break;
        }
      if (oe < 0) return this;
      oe === 0 ? be.shift() : k(be, oe), be.length === 1 && (pe[J] = be[0]), pe.removeListener !== void 0 && this.emit("removeListener", J, le || re);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(J) {
    var re, be, pe;
    if (be = this._events, be === void 0) return this;
    if (be.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : be[J] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete be[J]), this;
    if (arguments.length === 0) {
      var oe = Object.keys(be), Ee;
      for (pe = 0; pe < oe.length; ++pe)
        Ee = oe[pe], Ee !== "removeListener" && this.removeAllListeners(Ee);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (re = be[J], typeof re == "function")
      this.removeListener(J, re);
    else if (re !== void 0)
      for (pe = re.length - 1; pe >= 0; pe--)
        this.removeListener(J, re[pe]);
    return this;
  };
  function P(H, J, re) {
    var be = H._events;
    if (be === void 0) return [];
    var pe = be[J];
    return pe === void 0 ? [] : typeof pe == "function" ? re ? [pe.listener || pe] : [pe] : re ? $(pe) : D(pe, pe.length);
  }
  s.prototype.listeners = function(J) {
    return P(this, J, !0);
  }, s.prototype.rawListeners = function(J) {
    return P(this, J, !1);
  }, s.listenerCount = function(H, J) {
    return typeof H.listenerCount == "function" ? H.listenerCount(J) : I.call(H, J);
  }, s.prototype.listenerCount = I;
  function I(H) {
    var J = this._events;
    if (J !== void 0) {
      var re = J[H];
      if (typeof re == "function")
        return 1;
      if (re !== void 0)
        return re.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function D(H, J) {
    for (var re = new Array(J), be = 0; be < J; ++be) re[be] = H[be];
    return re;
  }
  function k(H, J) {
    for (; J + 1 < H.length; J++) H[J] = H[J + 1];
    H.pop();
  }
  function $(H) {
    for (var J = new Array(H.length), re = 0; re < J.length; ++re)
      J[re] = H[re].listener || H[re];
    return J;
  }
  function G(H, J) {
    return new Promise(function(re, be) {
      function pe(Ee) {
        H.removeListener(J, oe), be(Ee);
      }
      function oe() {
        typeof H.removeListener == "function" && H.removeListener("error", pe), re([].slice.call(arguments));
      }
      Z(H, J, oe, {
        once: !0
      }), J !== "error" && te(H, pe, {
        once: !0
      });
    });
  }
  function te(H, J, re) {
    typeof H.on == "function" && Z(H, "error", J, re);
  }
  function Z(H, J, re, be) {
    if (typeof H.on == "function")
      be.once ? H.once(J, re) : H.on(J, re);
    else if (typeof H.addEventListener == "function")
      H.addEventListener(J, function pe(oe) {
        be.once && H.removeEventListener(J, pe), re(oe);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof H);
  }
  return k_.exports;
}
var yte = _te();
const WC = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, bte = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "לחפש",
  //hebrew
  ja: "サーチ",
  //japanese
  lv: "Meklēt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "Претрага",
  //serbian
  zh: "搜索",
  //chinese-simplified
  cs: "Vyhledávání",
  //czech
  hu: "Keresés",
  //hungarian
  ka: "ძიება",
  // georgian
  nb: "Søke",
  //norwegian
  sk: "Vyhľadávanie",
  //slovak
  th: "ค้นหา",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "수색",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "جستجو",
  //persian(aka farsi)
  ru: "Поиск",
  //russian,
  es: "Buscar"
  //spanish
}, vte = {
  en: "No results found",
  de: "Keine Ergebnisse gefunden",
  es: "No hay resultados",
  fr: "Aucun résultat trouvé"
}, xte = {
  en: "There was an error reaching the server",
  de: "Verbindung fehlgeschlagen",
  es: "Error al conectarse al servidor",
  fr: "Une erreur est survenue lors de la connexion au serveur"
};
var vg = {
  placeholder: bte,
  errorNoResults: vte,
  errorConnectionFailed: xte
};
const wte = /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/;
class Ate {
  constructor(e, t) {
    this.options = {
      zoom: 16,
      flyTo: !0,
      trackProximity: !0,
      showResultsWhileTyping: !1,
      minLength: 2,
      reverseGeocode: !1,
      limit: 5,
      enableEventLogging: !0,
      marker: !0,
      popup: !1,
      maplibregl: void 0,
      collapsed: !1,
      clearAndBlurOnEsc: !1,
      clearOnBlur: !1,
      proximityMinZoom: 9,
      getItemValue: (i) => i.text !== void 0 ? i.text : i.place_name,
      render: function(i) {
        if (!i.geometry) {
          const s = i.text, c = s.toLowerCase().indexOf(this.query.toLowerCase()), o = this.query.length, d = s.substring(0, c), m = s.substring(c, c + o), y = s.substring(c + o);
          return '<div class="maplibregl-ctrl-geocoder--suggestion"><svg class="maplibregl-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="maplibregl-ctrl-geocoder--suggestion-info"><div class="maplibregl-ctrl-geocoder--suggestion-title">' + d + '<span class="maplibregl-ctrl-geocoder--suggestion-match">' + m + "</span>" + y + "</div></div></div>";
        }
        const n = i.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--result"><svg class="maplibregl-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="maplibregl-ctrl-geocoder--result-title">' + n[0] + '</div><div class="maplibregl-ctrl-geocoder--result-address">' + n.splice(1, n.length).join(",") + "</div></div></div>";
      },
      popupRender: (i) => {
        const n = i.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--suggestion popup-suggestion"><div class="maplibregl-ctrl-geocoder--suggestion-title popup-suggestion-title">' + n[0] + '</div><div class="maplibregl-ctrl-geocoder--suggestion-address popup-suggestion-address">' + n.splice(1, n.length).join(",") + "</div></div>";
      },
      showResultMarkers: !0,
      debounceSearch: 200
    }, this._eventEmitter = new yte.EventEmitter(), this.options = dc({}, this.options, t), this.fresh = !0, this.lastSelected = null, this.geocoderApi = e;
  }
  /**
   * Add the geocoder to a container. The container can be either a `Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`Map`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   * @example
   * ```js
   * const GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * const geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param container - A reference to the container to which to add the geocoder
   */
  addTo(e) {
    function t(i, n) {
      if (!document.body.contains(n))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      const s = i.onAdd();
      n.appendChild(s);
    }
    if (e instanceof HTMLElement)
      t(this, e);
    else if (typeof e == "string") {
      const i = document.querySelectorAll(e);
      if (i.length === 0)
        throw new Error("Element " + e + "not found.");
      if (i.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      t(this, i[0]);
    } else if ("addControl" in e)
      e.addControl(this);
    else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  }
  onAdd(e) {
    if (e && typeof e != "string" && (this._map = e), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    const t = this.container = document.createElement("div");
    t.className = "maplibregl-ctrl-geocoder maplibregl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    const i = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "search", this._inputEl.className = "maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", gte(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    const n = document.createElement("div");
    n.classList.add("maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("type", "button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "maplibregl-ctrl-geocoder--button";
    const s = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(s), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), n.appendChild(this._clearEl), n.appendChild(this._loadingEl), t.appendChild(i), t.appendChild(this._inputEl), t.appendChild(n), this._typeahead = new lte(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.container.addEventListener("click", () => {
      this._typeahead.update(this._typeahead.data);
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), t;
  }
  createIcon(e, t) {
    const i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (i.setAttribute("class", "maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + e), i.setAttribute("viewBox", "0 0 18 18"), i.setAttribute("xml:space", "preserve"), i.setAttribute("width", "18"), i.setAttribute("height", "18"), "innerHTML" in i)
      i.innerHTML = t;
    else {
      const n = document.createElement("div");
      n.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
      const s = n.firstChild, c = s.firstChild;
      i.appendChild(c);
    }
    return i;
  }
  onRemove() {
    return this.container.remove(), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  }
  _onPaste(e) {
    const t = (e.clipboardData || window.clipboardData).getData("text");
    t.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(t);
  }
  _onKeyDown(e) {
    if (e.keyCode === 27 && this.options.clearAndBlurOnEsc)
      return this._clear(e), this._inputEl.blur();
    const s = this._inputEl.value;
    if (!s)
      return this.fresh = !0, e.keyCode !== 9 && this.clear(e), this._clearEl.style.display = "none";
    if (!(e.metaKey || [9, 27, 37, 39, 38, 40].indexOf(e.keyCode) !== -1)) {
      if (e.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(s);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(s, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      s.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(s);
    }
  }
  _showButton() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  }
  _hideButton() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  }
  _onBlur(e) {
    this.options.clearOnBlur && this._clearOnBlur(e), this.options.collapsed && this._collapse();
  }
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange() {
    const e = this._typeahead.selected;
    if (e && !e.geometry)
      e.placeId ? this._geocode(e.placeId, !0, !0) : this._geocode(e.text, !0);
    else if (e && JSON.stringify(e) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        let t;
        if (this._removeResultMarkers(), e.properties && WC[e.properties.short_code])
          t = dc({}, this.options.flyTo), this._map && this._map.fitBounds(WC[e.properties.short_code].bbox, t);
        else if (e.bbox) {
          const i = e.bbox;
          t = dc({}, this.options.flyTo), this._map && this._map.fitBounds([[i[0], i[1]], [i[2], i[3]]], t);
        } else {
          const i = {
            zoom: this.options.zoom
          };
          t = dc({}, i, this.options.flyTo), e.center ? t.center = e.center : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (t.center = e.geometry.coordinates), this._map && this._map.flyTo(t);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(e), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(e), this._typeahead.selected = null, this._eventEmitter.emit("result", {
        result: e
      });
    }
  }
  _getConfigForRequest() {
    return ["bbox", "limit", "proximity", "countries", "types", "language", "reverseMode"].reduce((i, n) => (this.options[n] && (["countries", "types", "language"].indexOf(n) > -1 ? i[n] = this.options[n].split(/[\s,]+/) : i[n] = this.options[n], n === "proximity" && this.options[n] && typeof this.options[n].longitude == "number" && typeof this.options[n].latitude == "number" && (i[n] = [this.options[n].longitude, this.options[n].latitude])), i), {});
  }
  _geocode(e) {
    return z1(this, arguments, void 0, function* (t, i = !1, n = !1) {
      this._loadingEl.style.display = "block", this._eventEmitter.emit("loading", {
        query: t
      });
      const s = this._getConfigForRequest(), c = this._createGeocodeRequest(s, t, i, n), o = this.options.localGeocoder ? this.options.localGeocoder(t) || [] : [];
      try {
        const d = yield c;
        yield this._handleGeocodeResponse(d, s, t, i, o);
      } catch (d) {
        this._handleGeocodeErrorResponse(d, o);
      }
      return c;
    });
  }
  _createGeocodeRequest(e, t, i, n) {
    return this.options.localGeocoderOnly ? Promise.resolve({}) : this.options.reverseGeocode && wte.test(t) ? this._createReverseGeocodeRequest(t, e) : (e.query = t, this.geocoderApi.getSuggestions ? i ? this.geocoderApi.searchByPlaceId && n ? this.geocoderApi.searchByPlaceId(e) : this.geocoderApi.forwardGeocode(e) : this.geocoderApi.getSuggestions(e) : this.geocoderApi.forwardGeocode(e));
  }
  _createReverseGeocodeRequest(e, t) {
    const i = e.split(/[\s(,)?]+/).map((n) => parseFloat(n)).reverse();
    return t.query = i, t.limit = 1, "proximity" in t && delete t.proximity, this.geocoderApi.reverseGeocode(t);
  }
  _handleGeocodeResponse(e, t, i, n, s) {
    return z1(this, void 0, void 0, function* () {
      this._loadingEl.style.display = "none";
      let c = {};
      e ? c = e : c = {
        type: "FeatureCollection",
        features: []
      }, c.config = t, this.fresh && (this.fresh = !1), c.features = c.features ? s.concat(c.features) : s;
      const o = this.options.externalGeocoder ? this.options.externalGeocoder(i, c.features, t) || Promise.resolve([]) : Promise.resolve([]);
      try {
        const m = yield o;
        c.features = c.features ? m.concat(c.features) : m;
      } catch {
      }
      this.options.filter && c.features.length && (c.features = c.features.filter(this.options.filter));
      let d = [];
      "suggestions" in c ? d = c.suggestions : "place" in c ? d = [c.place] : d = c.features, d.length ? (this._clearEl.style.display = "block", this._typeahead.update(d), (!this.options.showResultsWhileTyping || n) && this.options.showResultMarkers && (c.features.length > 0 || "place" in c) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", c)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", c));
    });
  }
  _handleGeocodeErrorResponse(e, t) {
    this._loadingEl.style.display = "none", t.length && this.options.localGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(t)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", {
      features: t
    }), this._eventEmitter.emit("error", {
      error: e
    });
  }
  /**
   * Shared logic for clearing input
   * @param ev - the event that triggered the clear, if available
   */
  _clear(e) {
    e && e.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  }
  /**
   * Clear and then focus the input.
   * @param ev - the event that triggered the clear, if available
   *
   */
  clear(e) {
    this._clear(e), this._inputEl.focus();
  }
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param ev - the blur event
   */
  _clearOnBlur(e) {
    e.relatedTarget && this._clear(e);
  }
  _onQueryResult(e) {
    if (!("features" in e) || !e.features.length) return;
    const t = e.features[0];
    this._typeahead.selected = t, this._inputEl.value = t.place_name, this._onChange();
  }
  _updateProximity() {
    if (this._map)
      if (this._map.getZoom() > this.options.proximityMinZoom) {
        const e = this._map.getCenter().wrap();
        this.setProximity({
          longitude: e.lng,
          latitude: e.lat
        });
      } else
        this.setProximity(null);
  }
  _collapse() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("maplibregl-ctrl-geocoder--collapsed");
  }
  _unCollapse() {
    this.container.classList.remove("maplibregl-ctrl-geocoder--collapsed");
  }
  /**
   * Set & query the input
   * @param searchInput - location name or other search input
   */
  query(e) {
    return z1(this, void 0, void 0, function* () {
      const t = yield this._geocode(e);
      this._onQueryResult(t);
    });
  }
  _renderError() {
    const e = `<div class='maplibre-gl-geocoder--error'>${this._localize("errorConnectionFailed")}</div>`;
    this._renderMessage(e);
  }
  _renderNoResults() {
    const e = `<div class='maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>
        ${this._localize("errorNoResults")}</div>`;
    this._renderMessage(e);
  }
  _renderMessage(e) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(e);
  }
  /**
   * Get a localised string for a given key
   *
   * If language is provided in options, attempt to return localized string (defaults to English)
   * @param key - key in the localization object
   * @returns localized string
   */
  _localize(e) {
    const t = fte.language(this.options.language.split(",")[0]);
    return this.options.language && vg?.[e][t] ? vg[e][t] : vg[e].en;
  }
  /**
   * Fits the map to the current bounds for the searched results
   */
  _fitBoundsForMarkers() {
    if (this._typeahead.data.length < 1) return;
    const e = this._typeahead.data.filter((t) => typeof t != "string").slice(0, this.options.limit);
    if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
      const i = dc({}, {
        padding: 100
      }, this.options.flyTo), n = new this._maplibregl.LngLatBounds();
      for (const s of e)
        n.extend(s.geometry.coordinates);
      this._map.fitBounds(n, i);
    }
    return e.length > 0 && this._maplibregl && this._handleResultMarkers(e), this;
  }
  /**
   * Set input
   * @param searchInput - location name or other search input
   */
  setInput(e) {
    return this._inputEl.value = e, this._typeahead.selected = null, this._typeahead.clear(), e.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(e), this;
  }
  /**
   * Set proximity
   * @param proximity - The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   */
  setProximity(e) {
    return this.options.proximity = e, this;
  }
  /**
   * Get proximity
   * @returns The geocoder proximity
   */
  getProximity() {
    return this.options.proximity;
  }
  /**
   * Set the render function used in the results dropdown
   * @param fn - The function to use as a render function. This function accepts a single {@link CarmenGeojsonFeature} object as input and returns a string.
   */
  setRenderFunction(e) {
    return e && typeof e == "function" && (this._typeahead.render = e), this;
  }
  /**
   * Get the function used to render the results dropdown
   *
   * @returns the render function
   */
  getRenderFunction() {
    return this._typeahead.render;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param language - Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   */
  setLanguage(e) {
    return this.options.language = e || this.options.language || navigator.language, this;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns The language(s) used by the plugin, if any
   */
  getLanguage() {
    return this.options.language;
  }
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns the map zoom
   */
  getZoom() {
    return this.options.zoom;
  }
  /**
   * Set the zoom level
   * @param zoom - The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns this
   */
  setZoom(e) {
    return this.options.zoom = e, this;
  }
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns The `flyTo` option
   */
  getFlyTo() {
    return this.options.flyTo;
  }
  /**
   * Set the flyTo options
   * @param flyTo - If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo(e) {
    return this.options.flyTo = e, this;
  }
  /**
   * Get the value of the placeholder string
   * @returns The input element's placeholder value
   */
  getPlaceholder() {
    return this.options.placeholder;
  }
  /**
   * Set the value of the input element's placeholder
   * @param placeholder - the text to use as the input element's placeholder
   */
  setPlaceholder(e) {
    return this.placeholder = e || this.options.placeholder || this._localize("placeholder"), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  }
  /**
   * Get the bounding box used by the plugin
   * @returns the bounding box, if any
   */
  getBbox() {
    return this.options.bbox;
  }
  /**
   * Set the bounding box to limit search results to
   * @param bbox - a bounding box given as an array in the format [minX, minY, maxX, maxY].
   */
  setBbox(e) {
    return this.options.bbox = e, this;
  }
  /**
   * Get a list of the countries to limit search results to
   * @returns a comma separated list of countries to limit to, if any
   */
  getCountries() {
    return this.options.countries;
  }
  /**
   * Set the countries to limit search results to
   * @param countries - a comma separated list of countries to limit to
   */
  setCountries(e) {
    return this.options.countries = e, this;
  }
  /**
   * Get a list of the types to limit search results to
   * @returns a comma separated list of types to limit to
   */
  getTypes() {
    return this.options.types;
  }
  /**
   * Set the types to limit search results to
   * @param types - a comma separated list of types to limit to
   */
  setTypes(e) {
    return this.options.types = e, this;
  }
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns The minimum length in characters before a search is triggered
   */
  getMinLength() {
    return this.options.minLength;
  }
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param minLength - the minimum length in characters
   */
  setMinLength(e) {
    return this.options.minLength = e, this._typeahead && (this._typeahead.options.minLength = e), this;
  }
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns The limit value for the number of results to display used by the plugin
   */
  getLimit() {
    return this.options.limit;
  }
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param limit - the number of search results to return
   */
  setLimit(e) {
    return this.options.limit = e, this._typeahead && (this._typeahead.options.limit = e), this;
  }
  /**
   * Get the filter function used by the plugin
   * @returns the filter function
   */
  getFilter() {
    return this.options.filter;
  }
  /**
   * Set the filter function used by the plugin.
   * @param filter - A function which accepts a {@link CarmenGeojsonFeature} to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   */
  setFilter(e) {
    return this.options.filter = e, this;
  }
  /**
   * Set the geocoding api used by the plugin.
   */
  setGeocoderApi(e) {
    return this.geocoderApi = e, this;
  }
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns the geocoding API
   */
  getGeocoderApi() {
    return this.geocoderApi;
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param selected - the selected geojson feature
   */
  _handleMarker(e) {
    if (!this._map)
      return;
    this._removeMarker();
    const i = dc({}, {
      color: "#4668F2"
    }, this.options.marker);
    this.mapMarker = new this._maplibregl.Marker(i);
    let n;
    if (this.options.popup) {
      const c = dc({}, {}, this.options.popup);
      n = new this._maplibregl.Popup(c).setHTML(this.options.popupRender(e));
    }
    return e.center ? (this.mapMarker.setLngLat(e.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(n)) : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (this.mapMarker.setLngLat(e.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(n)), this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeMarker() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param results - the top results to display on the map
   */
  _handleResultMarkers(e) {
    if (!this._map)
      return;
    this._removeResultMarkers();
    let i = dc({}, {
      color: "#4668F2"
    }, this.options.showResultMarkers);
    for (const n of e) {
      let s;
      if (this.options.showResultMarkers) {
        this.options.showResultMarkers && this.options.showResultMarkers.element && (s = this.options.showResultMarkers.element.cloneNode(!0), i = dc(i, {
          element: s
        }));
        const c = new this._maplibregl.Marker(dc({}, i, {
          element: s
        }));
        let o;
        if (this.options.popup) {
          const m = dc({}, {}, this.options.popup);
          o = new this._maplibregl.Popup(m).setHTML(this.options.popupRender(n));
        }
        n.center ? (c.setLngLat(n.center).addTo(this._map), this.options.popup && c.setPopup(o)) : n.geometry && n.geometry.type && n.geometry.type === "Point" && n.geometry.coordinates && (c.setLngLat(n.geometry.coordinates).addTo(this._map), this.options.popup && c.setPopup(o)), this.resultMarkers.push(c);
      }
    }
    return this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeResultMarkers() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(e) {
      e.remove();
    }), this.resultMarkers = []);
  }
  /**
   * Subscribe to events that happen within the plugin.
   * @param type - name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param fn - function that's called when the event is emitted.
   */
  on(e, t) {
    return this._eventEmitter.on(e, t), this;
  }
  /**
   * Subscribe to events that happen within the plugin only once.
   * @param type - Event name.
   * Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @returns a Promise that resolves when the event is emitted.
   */
  once(e) {
    return new Promise((t) => {
      this._eventEmitter.once(e, t);
    });
  }
  /**
   * Remove an event
   * @param type - Event name.
   * @param fn - Function that should unsubscribe to the event emitted.
   */
  off(e, t) {
    return this._eventEmitter.removeListener(e, t), this;
  }
}
const Tte = /* @__PURE__ */ JSON.parse('{"limitsUrl":"https://tilemaps.icgc.cat/vt/limits-tilejsonV3.json","geocoder":{"peliasUrl1":"https://eines.icgc.cat/geocodificador/autocompletar?text=","peliasUrl2":"&layers=topo1%2Ctopo2%2Caddress&size=5"},"mapOptions":{"container":"map","center":{"0":1.537786,"1":41.837539},"zoom":7.5,"bearing":0,"pitch":0,"hash":false,"style":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json.json","maxZoom":18,"maxPitch":85},"logoIcgcOptions":{"logoUrlColor":"https://eines.icgc.cat/recursos/logos/icgc_logo_color.png","logoUrlWhite":"https://eines.icgc.cat/recursos/logos/icgc_logo_blanc.svg","logoLink":"https://www.icgc.cat","logoTitle":"Institut Cartogràfic i Geològic de Catalunya","logoWidth":100,"logoOpacity":0.6},"logoGencatOptions":{"logoUrlColor":"https://eines.icgc.cat/recursos/logos/gencat_logo_color.png","logoUrlWhite":"https://eines.icgc.cat/recursos/logos/gencat_logo_blanc.png","logoLink":"https://web.gencat.cat/","logoTitle":"Generalitat de Catalunya","logoWidth":100,"logoOpacity":0.6},"map3dOptions":{"spaceErrorFactor":2,"exaggeration":1,"zfactor":48,"minZoomRange":15.5,"maxZoomRange":22,"urlTilesetCities":"https://geoserveis.icgc.cat/servei/catalunya/ciutats/3dtiles/v1/tilesetV1.0.json","layerIdOrder":"place-isolated","sourceLayerFilterId":"place","minZoomFilter":14,"layerId3d":"edificisMapboxLayer","terrainSource":"ICGC5M","style3dName":"orto3d","imageIcon":"https://eines.icgc.cat/recursos//images/stick.png"},"baseStyles":[{"key":"TOPO","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_estandard.png"},{"key":"ORTO","url":"https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"},{"key":"ORTO3D","url":"https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"},{"key":"ORTOHYBRID","url":"https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_hibrida.png"},{"key":"ADMIN","url":"https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_delimitacio_limits_administratius.png"},{"key":"DARK","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_fosc.png"},{"key":"LIGHT","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_gris.png"},{"key":"GEOLOGY","url":"https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_geologic_informacio.png"},{"key":"RASTER","substyles":{"TOPO":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo.jpg"},"ADMIN":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_administratiu.jpg"},"LIGHT":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo_gris.jpg"},"STANDARD":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_estandard_0.jpg"},"Simplified":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_simplificat.jpg"},"ORTO":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto.jpg"},"ORTOGREY":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_gris.jpg"},"ORTOHYBRID":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_hibida.jpg"}}}],"urlTerrainICGC":[{"name":"ICGC5M","url":"https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png"},{"name":"WORLD30M","url":"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png","encoding":"terrarium"}],"ortoLayersICGC":[{"name":"ortofotoColorProvisional","key":"ortofoto_color_provisional","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional"},{"name":"ortofotoColor2023","key":"ortofoto_color_2023","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023"},{"name":"ortofotoColor2022","key":"ortofoto_color_2022","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022"},{"name":"ortofotoColor2021","key":"ortofoto_color_2021","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021"},{"name":"ortofotoColor2020","key":"ortofoto_color_2020","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020"},{"name":"ortofotoColor2019","key":"ortofoto_color_2019","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019"},{"name":"ortofotoColor2018","key":"ortofoto_color_2018","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018"},{"name":"ortofotoColor2017","key":"ortofoto_color_2017","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017"},{"name":"ortofotoColor2016","key":"ortofoto_color_2016","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016"},{"name":"ortofotoColor2015","key":"ortofoto_color_2015","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015"},{"name":"ortofotoColor2014","key":"ortofoto_color_2014","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014"},{"name":"ortofotoColor2013","key":"ortofoto_color_2013","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013"},{"name":"ortofotoColor2012","key":"ortofoto_color_2012","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012"},{"name":"ortofotoColor2011","key":"ortofoto_color_2011","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011"},{"name":"ortofotoColor2010","key":"ortofoto_color_2010","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010"},{"name":"ortofotoColor2009","key":"ortofoto_color_2009","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009"},{"name":"ortofotoColor2008","key":"ortofoto_color_2008","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008"},{"name":"ortofotoColor20062007","key":"ortofoto_color_2006-2007","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007"},{"name":"ortofotoColor20042005","key":"ortofoto_color_2004-2005","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005"},{"name":"ortofotoColor20002003","key":"ortofoto_color_2000-2003","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003"},{"name":"ortofotoBlancINegre1998","key":"ortofoto_blanc_i_negre_1998","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998"},{"name":"ortofotoBlancINegre19941997","key":"ortofoto_blanc_i_negre_1994-1997","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997"},{"name":"ortofotoColor1993","key":"ortofoto_color_1993","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993"},{"name":"ortofotoBlancINegre19831992","key":"ortofoto_blanc_i_negre_1983-1992","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992"},{"name":"ortofotoBlancINegre19701977","key":"ortofoto_blanc_i_negre_1970-1977","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977"},{"name":"ortofotoBlancINegre1956","key":"ortofoto_blanc_i_negre_1956","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956"},{"name":"ortofotoBlancINegre1945","key":"ortofoto_blanc_i_negre_1945","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945"},{"name":"ortofotoColorSerieAnual","key":"ortofoto_color_serie_anual","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual"},{"name":"ortofotoInfraroigProvisional","key":"ortofoto_infraroig_provisional","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional"},{"name":"ortofotoInfraroig2023","key":"ortofoto_infraroig_2023","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023"},{"name":"ortofotoInfraroig2022","key":"ortofoto_infraroig_2022","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022"},{"name":"ortofotoInfraroig2021","key":"ortofoto_infraroig_2021","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021"},{"name":"ortofotoInfraroig2020","key":"ortofoto_infraroig_2020","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020"},{"name":"ortofotoInfraroig2019","key":"ortofoto_infraroig_2019","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019"},{"name":"ortofotoInfraroig2018","key":"ortofoto_infraroig_2018","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018"},{"name":"ortofotoInfraroig2017","key":"ortofoto_infraroig_2017","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017"},{"name":"ortofotoInfraroig2016","key":"ortofoto_infraroig_2016","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016"},{"name":"ortofotoInfraroig2015","key":"ortofoto_infraroig_2015","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015"},{"name":"ortofotoInfraroig2014","key":"ortofoto_infraroig_2014","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014"},{"name":"ortofotoInfraroig2013","key":"ortofoto_infraroig_2013","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013"},{"name":"ortofotoInfraroig2012","key":"ortofoto_infraroig_2012","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012"},{"name":"ortofotoInfraroig2011","key":"ortofoto_infraroig_2011","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011"},{"name":"ortofotoInfraroig2010","key":"ortofoto_infraroig_2010","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010"},{"name":"ortofotoInfraroig2009","key":"ortofoto_infraroig_2009","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009"},{"name":"ortofotoInfraroig2008","key":"ortofoto_infraroig_2008","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008"},{"name":"ortofotoInfraroig20062007","key":"ortofoto_infraroig_2006-2007","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007"},{"name":"ortofotoInfraroig19961997","key":"ortofoto_infraroig_1996-1997","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997"},{"name":"ortofotoInfraroigSerieAnual","key":"ortofoto_infraroig_serie_anual","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"}],"vectorLayersICGC":[{"name":"agrupacionsCensals2015","key":"agrupacions_censals_2015"},{"name":"agrupacionsCensals2016","key":"agrupacions_censals_2016"},{"name":"agrupacionsCensals2017","key":"agrupacions_censals_2017"},{"name":"agrupacionsCensals2018","key":"agrupacions_censals_2018"},{"name":"agrupacionsCensals2019","key":"agrupacions_censals_2019"},{"name":"agrupacionsCensals2020","key":"agrupacions_censals_2020"},{"name":"agrupacionsCensals2021","key":"agrupacions_censals_2021"},{"name":"agrupacionsCensalsVigent","key":"agrupacions_censals_vigent"},{"name":"agrupacionsCensalsVigentText","key":"agrupacions_censals_vigent_text"},{"name":"areesBasiquesPolicials2019","key":"arees_basiques_policials_2019"},{"name":"areesBasiquesPolicials2020","key":"arees_basiques_policials_2020"},{"name":"areesBasiquesPolicials2022","key":"arees_basiques_policials_2022"},{"name":"areesBasiquesPolicialsVigent","key":"arees_basiques_policials_vigent"},{"name":"areesBasiquesPolicialsVigentText","key":"arees_basiques_policials_vigent_text"},{"name":"areesBasiquesSalutVigent","key":"arees_basiques_salut_vigent"},{"name":"areesBasiquesServeisSocialsVigent","key":"arees_basiques_serveis_socials_vigent"},{"name":"areesBasiquesServeisSocialsVigentText","key":"arees_basiques_serveis_socials_vigent_text"},{"name":"areesGestioAssistencialVigent","key":"arees_gestio_assistencial_vigent"},{"name":"areesHidrogeologiquesAquifersVigent","key":"arees_hidrogeologiques_aquifers_vigent"},{"name":"catalunyaVigent","key":"catalunya_vigent"},{"name":"catalunyaVigentText","key":"catalunya_vigent_text"},{"name":"comarques2022","key":"comarques_2022"},{"name":"comarquesVigent","key":"comarques_vigent"},{"name":"comarquesVigentText","key":"comarques_vigent_text"},{"name":"districtesCensals2015","key":"districtes_censals_2015"},{"name":"districtesCensals2016","key":"districtes_censals_2016"},{"name":"districtesCensals2017","key":"districtes_censals_2017"},{"name":"districtesCensals2018","key":"districtes_censals_2018"},{"name":"districtesCensals2019","key":"districtes_censals_2019"},{"name":"districtesCensals2020","key":"districtes_censals_2020"},{"name":"districtesCensals2021","key":"districtes_censals_2021"},{"name":"districtesCensals2022","key":"districtes_censals_2022"},{"name":"districtesCensals2023","key":"districtes_censals_2023"},{"name":"districtesCensalsVigent","key":"districtes_censals_vigent"},{"name":"districtesCensalsVigentText","key":"districtes_censals_vigent_text"},{"name":"incendisForestalsVigent","key":"incendis_forestals_vigent"},{"name":"incendisForestalsVigentText","key":"incendis_forestals_vigent_text"},{"name":"municipis2022","key":"municipis_2022"},{"name":"municipis2022Text","key":"municipis_2022_text"},{"name":"municipisVigent","key":"municipis_vigent"},{"name":"municipisVigentText","key":"municipis_vigent_text"},{"name":"partitsJudicialsVigent","key":"partits_judicials_vigent"},{"name":"partitsJudicialsVigentText","key":"partits_judicials_vigent_text"},{"name":"plaTerritorial2015","key":"pla_territorial_2015"},{"name":"plaTerritorialVigent","key":"pla_territorial_vigent"},{"name":"plaTerritorialVigentText","key":"pla_territorial_vigent_text"},{"name":"provinciesVigent","key":"provincies_vigent"},{"name":"provinciesVigentText","key":"provincies_vigent_text"},{"name":"regionsPolicialsVigent","key":"regions_policials_vigent"},{"name":"regionsPolicialsVigentText","key":"regions_policials_vigent_text"},{"name":"regionsSanitariesVigent","key":"regions_sanitaries_vigent"},{"name":"regionsSanitariesVigentText","key":"regions_sanitaries_vigent_text"},{"name":"seccionsCensals2015","key":"seccions_censals_2015"},{"name":"seccionsCensals2016","key":"seccions_censals_2016"},{"name":"seccionsCensals2017","key":"seccions_censals_2017"},{"name":"seccionsCensals2018","key":"seccions_censals_2018"},{"name":"seccionsCensals2019","key":"seccions_censals_2019"},{"name":"seccionsCensals2020","key":"seccions_censals_2020"},{"name":"seccionsCensals2021","key":"seccions_censals_2021"},{"name":"seccionsCensals2022","key":"seccions_censals_2022"},{"name":"seccionsCensals2023","key":"seccions_censals_2023"},{"name":"seccionsCensalsVigent","key":"seccions_censals_vigent"},{"name":"seccionsCensalsVigentText","key":"seccions_censals_vigent_text"},{"name":"sectorsSanitarisVigent","key":"sectors_sanitaris_vigent"},{"name":"vegueriesVigent","key":"vegueries_vigent"},{"name":"vegueriesVigentText","key":"vegueries_vigent_text"}],"vectorLayers":[{"key":"cobertes2018","url":"https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json","legend":"https://eines.icgc.cat/recursos//images/llegendaCobertesSol2018.jpg"}],"wmsLayers":[{"key":"espaisInteresGeologic","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"gravimetriaBouguer500000","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"cobertesSol2018","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"administratiu","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png"},{"key":"simplificat","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png"},{"key":"cims","layer":"","url":"https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455"},{"key":"cobertesSol","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"}],"fgbLayers":[{"name":"agrupacionsCensalsVigent","key":"agrupacions_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb"},{"name":"agrupacionsCensalsVigentText","key":"agrupacions_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb"},{"name":"areesBasiquesPolicialsVigent","key":"arees_basiques_policials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb"},{"name":"areesBasiquesPolicialsVigentText","key":"arees_basiques_policials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb"},{"name":"areesBasiquesSalutVigent","key":"arees_basiques_salut_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb"},{"name":"areesBasiquesServeisSocialsVigent","key":"arees_basiques_serveis_socials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb"},{"name":"areesBasiquesServeisSocialsVigentText","key":"arees_basiques_serveis_socials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb"},{"name":"areesGestioAssistencialVigent","key":"arees_gestio_assistencial_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb"},{"name":"areesHidrogeologiquesAquifersVigent","key":"arees_hidrogeologiques_aquifers_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb"},{"name":"catalunyaVigent","key":"catalunya_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb"},{"name":"catalunyaVigentText","key":"catalunya_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb"},{"name":"comarquesVigent","key":"comarques_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb"},{"name":"comarquesVigentText","key":"comarques_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb"},{"name":"districtesCensalsVigent","key":"districtes_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb"},{"name":"districtesCensalsVigentText","key":"districtes_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb"},{"name":"incendisForestalsVigent","key":"incendis_forestals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb"},{"name":"incendisForestalsVigentText","key":"incendis_forestals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb"},{"name":"municipisVigent","key":"municipis_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb"},{"name":"municipisVigentText","key":"municipis_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb"},{"name":"partitsJudicialsVigent","key":"partits_judicials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb"},{"name":"partitsJudicialsVigentText","key":"partits_judicials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb"},{"name":"plaTerritorialVigent","key":"pla_territorial_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb"},{"name":"plaTerritorialVigentText","key":"pla_territorial_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb"},{"name":"provinciesVigent","key":"provincies_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb"},{"name":"provinciesVigentText","key":"provincies_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb"},{"name":"regionsPolicialsVigent","key":"regions_policials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb"},{"name":"regionsPolicialsVigentText","key":"regions_policials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb"},{"name":"regionsSanitariesVigent","key":"regions_sanitaries_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb"},{"name":"regionsSanitariesVigentText","key":"regions_sanitaries_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb"},{"name":"seccionsCensalsVigent","key":"seccions_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb"},{"name":"seccionsCensalsVigentText","key":"seccions_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb"},{"name":"sectorsSanitarisVigent","key":"sectors_sanitaris_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb"},{"name":"vegueriesVigent","key":"vegueries_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb"},{"name":"vegueriesVigentText","key":"vegueries_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"}]}'), Ste = { TOPO: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json", ORTO: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json", ORTO3D: "https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json", ORTOHYBRID: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json", ADMIN: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json", DARK: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json", LIGHT: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json", GEOLOGY: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json", RASTER: { TOPO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png", ADMIN: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png", LIGHT: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png", STANDARD: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png", SIMPLIFIED: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png", ORTO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png", ORTOGREY: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png", ORTOHYBRID: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png" } }, Ete = { ICGC5M: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png", WORLD30M: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png" }, Cte = /* @__PURE__ */ JSON.parse('{"Orto":{"ortofotoColorProvisional":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional","ortofotoColor2023":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023","ortofotoColor2022":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022","ortofotoColor2021":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021","ortofotoColor2020":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020","ortofotoColor2019":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019","ortofotoColor2018":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018","ortofotoColor2017":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017","ortofotoColor2016":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016","ortofotoColor2015":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015","ortofotoColor2014":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014","ortofotoColor2013":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013","ortofotoColor2012":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012","ortofotoColor2011":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011","ortofotoColor2010":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010","ortofotoColor2009":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009","ortofotoColor2008":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008","ortofotoColor20062007":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007","ortofotoColor20042005":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005","ortofotoColor20002003":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003","ortofotoBlancINegre1998":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998","ortofotoBlancINegre19941997":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997","ortofotoColor1993":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993","ortofotoBlancINegre19831992":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992","ortofotoBlancINegre19701977":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977","ortofotoBlancINegre1956":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956","ortofotoBlancINegre1945":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945","ortofotoColorSerieAnual":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual","ortofotoInfraroigProvisional":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional","ortofotoInfraroig2023":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023","ortofotoInfraroig2022":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022","ortofotoInfraroig2021":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021","ortofotoInfraroig2020":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020","ortofotoInfraroig2019":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019","ortofotoInfraroig2018":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018","ortofotoInfraroig2017":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017","ortofotoInfraroig2016":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016","ortofotoInfraroig2015":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015","ortofotoInfraroig2014":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014","ortofotoInfraroig2013":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013","ortofotoInfraroig2012":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012","ortofotoInfraroig2011":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011","ortofotoInfraroig2010":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010","ortofotoInfraroig2009":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009","ortofotoInfraroig2008":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008","ortofotoInfraroig20062007":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007","ortofotoInfraroig19961997":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997","ortofotoInfraroigSerieAnual":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"},"VectorAdmin":{"agrupacionsCensals2015":"agrupacions_censals_2015","agrupacionsCensals2016":"agrupacions_censals_2016","agrupacionsCensals2017":"agrupacions_censals_2017","agrupacionsCensals2018":"agrupacions_censals_2018","agrupacionsCensals2019":"agrupacions_censals_2019","agrupacionsCensals2020":"agrupacions_censals_2020","agrupacionsCensals2021":"agrupacions_censals_2021","agrupacionsCensalsVigent":"agrupacions_censals_vigent","agrupacionsCensalsVigentText":"agrupacions_censals_vigent_text","areesBasiquesPolicials2019":"arees_basiques_policials_2019","areesBasiquesPolicials2020":"arees_basiques_policials_2020","areesBasiquesPolicials2022":"arees_basiques_policials_2022","areesBasiquesPolicialsVigent":"arees_basiques_policials_vigent","areesBasiquesPolicialsVigentText":"arees_basiques_policials_vigent_text","areesBasiquesSalutVigent":"arees_basiques_salut_vigent","areesBasiquesServeisSocialsVigent":"arees_basiques_serveis_socials_vigent","areesBasiquesServeisSocialsVigentText":"arees_basiques_serveis_socials_vigent_text","areesGestioAssistencialVigent":"arees_gestio_assistencial_vigent","areesHidrogeologiquesAquifersVigent":"arees_hidrogeologiques_aquifers_vigent","catalunyaVigent":"catalunya_vigent","catalunyaVigentText":"catalunya_vigent_text","comarques2022":"comarques_2022","comarquesVigent":"comarques_vigent","comarquesVigentText":"comarques_vigent_text","districtesCensals2015":"districtes_censals_2015","districtesCensals2016":"districtes_censals_2016","districtesCensals2017":"districtes_censals_2017","districtesCensals2018":"districtes_censals_2018","districtesCensals2019":"districtes_censals_2019","districtesCensals2020":"districtes_censals_2020","districtesCensals2021":"districtes_censals_2021","districtesCensals2022":"districtes_censals_2022","districtesCensals2023":"districtes_censals_2023","districtesCensalsVigent":"districtes_censals_vigent","districtesCensalsVigentText":"districtes_censals_vigent_text","incendisForestalsVigent":"incendis_forestals_vigent","incendisForestalsVigentText":"incendis_forestals_vigent_text","municipis2022":"municipis_2022","municipis2022Text":"municipis_2022_text","municipisVigent":"municipis_vigent","municipisVigentText":"municipis_vigent_text","partitsJudicialsVigent":"partits_judicials_vigent","partitsJudicialsVigentText":"partits_judicials_vigent_text","plaTerritorial2015":"pla_territorial_2015","plaTerritorialVigent":"pla_territorial_vigent","plaTerritorialVigentText":"pla_territorial_vigent_text","provinciesVigent":"provincies_vigent","provinciesVigentText":"provincies_vigent_text","regionsPolicialsVigent":"regions_policials_vigent","regionsPolicialsVigentText":"regions_policials_vigent_text","regionsSanitariesVigent":"regions_sanitaries_vigent","regionsSanitariesVigentText":"regions_sanitaries_vigent_text","seccionsCensals2015":"seccions_censals_2015","seccionsCensals2016":"seccions_censals_2016","seccionsCensals2017":"seccions_censals_2017","seccionsCensals2018":"seccions_censals_2018","seccionsCensals2019":"seccions_censals_2019","seccionsCensals2020":"seccions_censals_2020","seccionsCensals2021":"seccions_censals_2021","seccionsCensals2022":"seccions_censals_2022","seccionsCensals2023":"seccions_censals_2023","seccionsCensalsVigent":"seccions_censals_vigent","seccionsCensalsVigentText":"seccions_censals_vigent_text","sectorsSanitarisVigent":"sectors_sanitaris_vigent","vegueriesVigent":"vegueries_vigent","vegueriesVigentText":"vegueries_vigent_text"},"FGBAdmin":{"agrupacionsCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb","agrupacionsCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb","areesBasiquesPolicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb","areesBasiquesPolicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb","areesBasiquesSalutVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb","areesBasiquesServeisSocialsVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb","areesBasiquesServeisSocialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb","areesGestioAssistencialVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb","areesHidrogeologiquesAquifersVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb","catalunyaVigent":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb","catalunyaVigentText":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb","comarquesVigent":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb","comarquesVigentText":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb","districtesCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb","districtesCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb","incendisForestalsVigent":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb","incendisForestalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb","municipisVigent":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb","municipisVigentText":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb","partitsJudicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb","partitsJudicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb","plaTerritorialVigent":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb","plaTerritorialVigentText":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb","provinciesVigent":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb","provinciesVigentText":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb","regionsPolicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb","regionsPolicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb","regionsSanitariesVigent":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb","regionsSanitariesVigentText":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb","seccionsCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb","seccionsCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb","sectorsSanitarisVigent":"https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb","vegueriesVigent":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb","vegueriesVigentText":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"},"Vector":{"cobertes2018":"https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json"},"WMS":{"espaisInteresGeologic":"https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","gravimetriaBouguer500000":"https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","cobertesSol2018":"https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","administratiu":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png","simplificat":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png","cims":"https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455","cobertesSol":"http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"}}'), zf = {
  defaultOptions: Tte,
  Styles: Ste,
  Terrains: Ete,
  Layers: Cte
};
class Ite {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    let t = zf.defaultOptions;
    return this._map = e, this._img1 = document.createElement("img"), this._img1.className = "maplibregl-ctrl", this._img1.src = this.options.color ? t.logoIcgcOptions.logoUrlColor : t.logoIcgcOptions.logoUrlWhite, this._img1.width = t.logoIcgcOptions.logoWidth, this._img1.title = t.logoIcgcOptions.logoTitle, this._img1.style.opacity = t.logoIcgcOptions.logoOpacity, this.link1 = document.createElement("a"), this.link1.href = t.logoIcgcOptions.logoLink, this.link1.target = "_blank", this.link1.appendChild(this._img1), this._container1 = document.createElement("div"), this._container1.className = "maplibregl-ctrl", this._container1.style.width = `${t.logoIcgcOptions.logoWidth}px`, this._container1.appendChild(this.link1), this._img2 = document.createElement("img"), this._img2.className = "maplibregl-ctrl", this._img2.src = this.options.color ? t.logoGencatOptions.logoUrlColor : t.logoGencatOptions.logoUrlWhite, this._img2.width = t.logoGencatOptions.logoWidth, this._img2.title = t.logoGencatOptions.logoTitle, this._img2.style.opacity = t.logoGencatOptions.logoOpacity, this.link2 = document.createElement("a"), this.link2.href = t.logoGencatOptions.logoLink, this.link2.target = "_blank", this.link2.appendChild(this._img2), this._container2 = document.createElement("div"), this._container2.className = "maplibregl-ctrl", this._container2.style.width = `${t.logoGencatOptions.logoWidth}px`, this._container2.appendChild(this.link2), this._mainContainer = document.createElement("div"), this._mainContainer.className = "divLogos", this._mainContainer.style = "display: flex", this._mainContainer.appendChild(this._container1), this._mainContainer.appendChild(this._container2), this._mainContainer;
  }
}
class Pte {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    this._map = e, this._img1 = document.createElement("img"), this._img1.src = this.options.url, this._img1.width = 150, this._img1.title = 300, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), this.legendContainer = document.createElement("div"), this.legendContainer.classList.add("maplibregl-legend-list"), this.legendButton = document.createElement("button"), this.legendButton.classList.add("maplibregl-ctrl-icon"), this.legendButton.classList.add("maplibregl-legend-switcher"), this.legendButton.addEventListener("click", () => {
      this.legendButton.style.display = "none", this.legendContainer.style.display = "block";
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.legendButton), this.controlContainer.appendChild(this.legendContainer), this.closeButton = document.createElement("button"), this.closeButton.textContent = "x", this.closeButton.classList.add("maplibregl-legend-close-button"), this.closeButton.addEventListener("click", () => {
      this.legendButton.style.display = "block", this.legendContainer.style.display = "none";
    }), this.legendContainer.appendChild(this.closeButton);
    const t = document.createElement("label");
    return t.classList.add("maplibregl-legend-title-label"), t.textContent = this.options.idLayer || "Llegenda", this.legendContainer.appendChild(t), this.legendContainer.appendChild(document.createElement("br")), this.legendContainer.appendChild(this._img1), this.controlContainer;
  }
}
var W1, XC;
function Mte() {
  if (XC) return W1;
  XC = 1;
  var r = t.prototype, e = "WGS 84";
  function t(n) {
    n !== void 0 && (e = n), this.setEllipsoid(e);
  }
  r.convertLatLngToUtm = function(n, s, c) {
    var o;
    if (this.status)
      return "No ecclipsoid data associated with unknown datum: " + e;
    if (!Number.isInteger(c))
      return "Precision is not integer number.";
    n = parseFloat(n), s = parseFloat(s);
    var d = s, m = this.toRadians(n), y = this.toRadians(d);
    d >= 8 && d <= 13 && n > 54.5 && n < 58 || n >= 56 && n < 64 && d >= 3 && d < 12 ? o = 32 : (o = (d + 180) / 6 + 1, n >= 72 && n < 84 && (d >= 0 && d < 9 ? o = 31 : d >= 9 && d < 21 ? o = 33 : d >= 21 && d < 33 ? o = 35 : d >= 33 && d < 42 && (o = 37))), o = parseInt(o);
    var T = (o - 1) * 6 - 180 + 3, P = this.toRadians(T), I = this.getUtmLetterDesignator(n), D = this.eccSquared / (1 - this.eccSquared), k = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(m) * Math.sin(m)), $ = Math.tan(m) * Math.tan(m), G = D * Math.cos(m) * Math.cos(m), te = Math.cos(m) * (y - P), Z = this.a * ((1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256) * m - (3 * this.eccSquared / 8 + 3 * this.eccSquared * this.eccSquared / 32 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(2 * m) + (15 * this.eccSquared * this.eccSquared / 256 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(4 * m) - 35 * this.eccSquared * this.eccSquared * this.eccSquared / 3072 * Math.sin(6 * m)), H = parseFloat(0.9996 * k * (te + (1 - $ + G) * te * te * te / 6 + (5 - 18 * $ + $ * $ + 72 * G - 58 * D) * te * te * te * te * te / 120) + 5e5), J = parseFloat(0.9996 * (Z + k * Math.tan(m) * (te * te / 2 + (5 - $ + 9 * G + 4 * G * G) * te * te * te * te / 24 + (61 - 58 * $ + $ * $ + 600 * G - 330 * D) * te * te * te * te * te * te / 720)));
    return n < 0 && (J += 1e7), J = i(J, c), H = i(H, c), {
      Easting: H,
      Northing: J,
      ZoneNumber: parseInt(o),
      ZoneLetter: I
    };
  }, r.convertUtmToLatLng = function(n, s, c, o) {
    var d = (1 - Math.sqrt(1 - this.eccSquared)) / (1 + Math.sqrt(1 - this.eccSquared)), m = n - 5e5, y = s, T = c, P = o;
    if (n === void 0)
      return "Please pass the UTMEasting!";
    if (s === void 0)
      return "Please pass the UTMNorthing!";
    if (c === void 0)
      return "Please pass the UTMZoneNumber!";
    if (o === void 0)
      return "Please pass the UTMZoneLetter!";
    ["N", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"].indexOf(P) !== -1 || (y -= 1e7);
    var I = (T - 1) * 6 - 180 + 3, D = this.eccSquared / (1 - this.eccSquared), k = y / 0.9996, $ = k / (this.a * (1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256)), G = $ + (3 * d / 2 - 27 * d * d * d / 32) * Math.sin(2 * $) + (21 * d * d / 16 - 55 * d * d * d * d / 32) * Math.sin(4 * $) + 151 * d * d * d / 96 * Math.sin(6 * $);
    this.toDegrees(G);
    var te = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(G) * Math.sin(G)), Z = Math.tan(G) * Math.tan(G), H = D * Math.cos(G) * Math.cos(G), J = this.a * (1 - this.eccSquared) / Math.pow(1 - this.eccSquared * Math.sin(G) * Math.sin(G), 1.5), re = m / (te * 0.9996), be = G - te * Math.tan(G) / J * (re * re / 2 - (5 + 3 * Z + 10 * H - 4 * H * H - 9 * D) * re * re * re * re / 24 + (61 + 90 * Z + 298 * H + 45 * Z * Z - 252 * D - 3 * H * H) * re * re * re * re * re * re / 720);
    be = this.toDegrees(be);
    var pe = (re - (1 + 2 * Z + H) * re * re * re / 6 + (5 - 2 * H + 28 * Z - 3 * H * H + 8 * D + 24 * Z * Z) * re * re * re * re * re / 120) / Math.cos(G);
    return pe = I + this.toDegrees(pe), {
      lat: be,
      lng: pe
    };
  }, r.getUtmLetterDesignator = function(n) {
    return n = parseFloat(n), 84 >= n && n >= 72 ? "X" : 72 > n && n >= 64 ? "W" : 64 > n && n >= 56 ? "V" : 56 > n && n >= 48 ? "U" : 48 > n && n >= 40 ? "T" : 40 > n && n >= 32 ? "S" : 32 > n && n >= 24 ? "R" : 24 > n && n >= 16 ? "Q" : 16 > n && n >= 8 ? "P" : 8 > n && n >= 0 ? "N" : 0 > n && n >= -8 ? "M" : -8 > n && n >= -16 ? "L" : -16 > n && n >= -24 ? "K" : -24 > n && n >= -32 ? "J" : -32 > n && n >= -40 ? "H" : -40 > n && n >= -48 ? "G" : -48 > n && n >= -56 ? "F" : -56 > n && n >= -64 ? "E" : -64 > n && n >= -72 ? "D" : -72 > n && n >= -80 ? "C" : "Z";
  }, r.setEllipsoid = function(n) {
    switch (n) {
      case "Airy":
        this.a = 6377563, this.eccSquared = 667054e-8;
        break;
      case "Australian National":
        this.a = 6378160, this.eccSquared = 6694542e-9;
        break;
      case "Bessel 1841":
        this.a = 6377397, this.eccSquared = 6674372e-9;
        break;
      case "Bessel 1841 Nambia":
        this.a = 6377484, this.eccSquared = 6674372e-9;
        break;
      case "Clarke 1866":
        this.a = 6378206, this.eccSquared = 6768658e-9;
        break;
      case "Clarke 1880":
        this.a = 6378249, this.eccSquared = 6803511e-9;
        break;
      case "Everest":
        this.a = 6377276, this.eccSquared = 6637847e-9;
        break;
      case "Fischer 1960 Mercury":
        this.a = 6378166, this.eccSquared = 6693422e-9;
        break;
      case "Fischer 1968":
        this.a = 6378150, this.eccSquared = 6693422e-9;
        break;
      case "GRS 1967":
        this.a = 6378160, this.eccSquared = 6694605e-9;
        break;
      case "GRS 1980":
        this.a = 6378137, this.eccSquared = 669438e-8;
        break;
      case "Helmert 1906":
        this.a = 6378200, this.eccSquared = 6693422e-9;
        break;
      case "Hough":
        this.a = 6378270, this.eccSquared = 672267e-8;
        break;
      case "International":
        this.a = 6378388, this.eccSquared = 672267e-8;
        break;
      case "Krassovsky":
        this.a = 6378245, this.eccSquared = 6693422e-9;
        break;
      case "Modified Airy":
        this.a = 6377340, this.eccSquared = 667054e-8;
        break;
      case "Modified Everest":
        this.a = 6377304, this.eccSquared = 6637847e-9;
        break;
      case "Modified Fischer 1960":
        this.a = 6378155, this.eccSquared = 6693422e-9;
        break;
      case "South American 1969":
        this.a = 6378160, this.eccSquared = 6694542e-9;
        break;
      case "WGS 60":
        this.a = 6378165, this.eccSquared = 6693422e-9;
        break;
      case "WGS 66":
        this.a = 6378145, this.eccSquared = 6694542e-9;
        break;
      case "WGS 72":
        this.a = 6378135, this.eccSquared = 6694318e-9;
        break;
      case "ED50":
        this.a = 6378388, this.eccSquared = 672267e-8;
        break;
      // International Ellipsoid
      case "WGS 84":
      case "EUREF89":
      // Max deviation from WGS 84 is 40 cm/km see http://ocq.dk/euref89 (in danish)
      case "ETRS89":
        this.a = 6378137, this.eccSquared = 669438e-8;
        break;
      default:
        this.status = !0;
    }
  }, r.toDegrees = function(n) {
    return n / Math.PI * 180;
  }, r.toRadians = function(n) {
    return n * Math.PI / 180;
  };
  function i(n, s) {
    var c = Math.pow(10, s);
    return Math.round(n * c) / c;
  }
  return W1 = t, W1;
}
var Rte = Mte();
const Lte = /* @__PURE__ */ p2(Rte);
class Bte {
  constructor(e) {
    this.options = e || {}, this.options.utm = this.options.hasOwnProperty("utm") ? this.options.utm : !0, this.options.lonlat = this.options.hasOwnProperty("lonlat") ? this.options.lonlat : !0;
  }
  onAdd(e) {
    const t = new Lte();
    return this._map = e, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl coordControl", this._container.style.width = `${this.options.width || "225px"}`, this._map.on("mousemove", (i) => {
      const n = i.lngLat.lat, s = i.lngLat.lng;
      let c = "", o = "";
      const d = t.convertLatLngToUtm(n, s, 2), m = n > 0 ? "N" : "S";
      this.options.utm && (c = `ETRS89 UTM ${d.ZoneNumber}${m} X:<b> ${d.Easting}</b> Y:<b> ${d.Northing}</b> <br>`), this.options.lonlat && (o = `WGS 84 Lon:<b> ${s.toFixed(5)}</b>  Lat:<b> ${n.toFixed(5)}</b>`);
      const y = `${c}${o}`;
      this._container.innerHTML = y;
    }), this._container;
  }
  _lookUTM31(e, t) {
    var i = 0, n = 0, s = 6, c = 84;
    return e >= i && e <= s && t >= n && t <= c;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function KR(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const {
  toString: kte
} = Object.prototype, {
  getPrototypeOf: iw
} = Object, {
  iterator: d0,
  toStringTag: QR
} = Symbol, p0 = /* @__PURE__ */ ((r) => (e) => {
  const t = kte.call(e);
  return r[t] || (r[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Lc = (r) => (r = r.toLowerCase(), (e) => p0(e) === r), g0 = (r) => (e) => typeof e === r, {
  isArray: Vp
} = Array, Rp = g0("undefined");
function vm(r) {
  return r !== null && !Rp(r) && r.constructor !== null && !Rp(r.constructor) && Pa(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const e4 = Lc("ArrayBuffer");
function Ote(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && e4(r.buffer), e;
}
const Dte = g0("string"), Pa = g0("function"), t4 = g0("number"), xm = (r) => r !== null && typeof r == "object", Nte = (r) => r === !0 || r === !1, ay = (r) => {
  if (p0(r) !== "object")
    return !1;
  const e = iw(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(QR in r) && !(d0 in r);
}, Fte = (r) => {
  if (!xm(r) || vm(r))
    return !1;
  try {
    return Object.keys(r).length === 0 && Object.getPrototypeOf(r) === Object.prototype;
  } catch {
    return !1;
  }
}, Ute = Lc("Date"), zte = Lc("File"), jte = Lc("Blob"), Vte = Lc("FileList"), Gte = (r) => xm(r) && Pa(r.pipe), $te = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || Pa(r.append) && ((e = p0(r)) === "formdata" || // detect form-data instance
  e === "object" && Pa(r.toString) && r.toString() === "[object FormData]"));
}, Hte = Lc("URLSearchParams"), [qte, Wte, Xte, Zte] = ["ReadableStream", "Request", "Response", "Headers"].map(Lc), Yte = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function wm(r, e, {
  allOwnKeys: t = !1
} = {}) {
  if (r === null || typeof r > "u")
    return;
  let i, n;
  if (typeof r != "object" && (r = [r]), Vp(r))
    for (i = 0, n = r.length; i < n; i++)
      e.call(null, r[i], i, r);
  else {
    if (vm(r))
      return;
    const s = t ? Object.getOwnPropertyNames(r) : Object.keys(r), c = s.length;
    let o;
    for (i = 0; i < c; i++)
      o = s[i], e.call(null, r[o], o, r);
  }
}
function r4(r, e) {
  if (vm(r))
    return null;
  e = e.toLowerCase();
  const t = Object.keys(r);
  let i = t.length, n;
  for (; i-- > 0; )
    if (n = t[i], e === n.toLowerCase())
      return n;
  return null;
}
const jf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, i4 = (r) => !Rp(r) && r !== jf;
function u2() {
  const {
    caseless: r,
    skipUndefined: e
  } = i4(this) && this || {}, t = {}, i = (n, s) => {
    const c = r && r4(t, s) || s;
    ay(t[c]) && ay(n) ? t[c] = u2(t[c], n) : ay(n) ? t[c] = u2({}, n) : Vp(n) ? t[c] = n.slice() : (!e || !Rp(n)) && (t[c] = n);
  };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && wm(arguments[n], i);
  return t;
}
const Jte = (r, e, t, {
  allOwnKeys: i
} = {}) => (wm(e, (n, s) => {
  t && Pa(n) ? r[s] = KR(n, t) : r[s] = n;
}, {
  allOwnKeys: i
}), r), Kte = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), Qte = (r, e, t, i) => {
  r.prototype = Object.create(e.prototype, i), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), t && Object.assign(r.prototype, t);
}, ere = (r, e, t, i) => {
  let n, s, c;
  const o = {};
  if (e = e || {}, r == null) return e;
  do {
    for (n = Object.getOwnPropertyNames(r), s = n.length; s-- > 0; )
      c = n[s], (!i || i(c, r, e)) && !o[c] && (e[c] = r[c], o[c] = !0);
    r = t !== !1 && iw(r);
  } while (r && (!t || t(r, e)) && r !== Object.prototype);
  return e;
}, tre = (r, e, t) => {
  r = String(r), (t === void 0 || t > r.length) && (t = r.length), t -= e.length;
  const i = r.indexOf(e, t);
  return i !== -1 && i === t;
}, rre = (r) => {
  if (!r) return null;
  if (Vp(r)) return r;
  let e = r.length;
  if (!t4(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = r[e];
  return t;
}, ire = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && iw(Uint8Array)), nre = (r, e) => {
  const i = (r && r[d0]).call(r);
  let n;
  for (; (n = i.next()) && !n.done; ) {
    const s = n.value;
    e.call(r, s[0], s[1]);
  }
}, sre = (r, e) => {
  let t;
  const i = [];
  for (; (t = r.exec(e)) !== null; )
    i.push(t);
  return i;
}, ore = Lc("HTMLFormElement"), are = (r) => r.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, i, n) {
  return i.toUpperCase() + n;
}), ZC = (({
  hasOwnProperty: r
}) => (e, t) => r.call(e, t))(Object.prototype), lre = Lc("RegExp"), n4 = (r, e) => {
  const t = Object.getOwnPropertyDescriptors(r), i = {};
  wm(t, (n, s) => {
    let c;
    (c = e(n, s, r)) !== !1 && (i[s] = c || n);
  }), Object.defineProperties(r, i);
}, cre = (r) => {
  n4(r, (e, t) => {
    if (Pa(r) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const i = r[t];
    if (Pa(i)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, ure = (r, e) => {
  const t = {}, i = (n) => {
    n.forEach((s) => {
      t[s] = !0;
    });
  };
  return Vp(r) ? i(r) : i(String(r).split(e)), t;
}, hre = () => {
}, fre = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function dre(r) {
  return !!(r && Pa(r.append) && r[QR] === "FormData" && r[d0]);
}
const pre = (r) => {
  const e = new Array(10), t = (i, n) => {
    if (xm(i)) {
      if (e.indexOf(i) >= 0)
        return;
      if (vm(i))
        return i;
      if (!("toJSON" in i)) {
        e[n] = i;
        const s = Vp(i) ? [] : {};
        return wm(i, (c, o) => {
          const d = t(c, n + 1);
          !Rp(d) && (s[o] = d);
        }), e[n] = void 0, s;
      }
    }
    return i;
  };
  return t(r, 0);
}, gre = Lc("AsyncFunction"), mre = (r) => r && (xm(r) || Pa(r)) && Pa(r.then) && Pa(r.catch), s4 = ((r, e) => r ? setImmediate : e ? ((t, i) => (jf.addEventListener("message", ({
  source: n,
  data: s
}) => {
  n === jf && s === t && i.length && i.shift()();
}, !1), (n) => {
  i.push(n), jf.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(typeof setImmediate == "function", Pa(jf.postMessage)), _re = typeof queueMicrotask < "u" ? queueMicrotask.bind(jf) : typeof process < "u" && process.nextTick || s4, yre = (r) => r != null && Pa(r[d0]), Rt = {
  isArray: Vp,
  isArrayBuffer: e4,
  isBuffer: vm,
  isFormData: $te,
  isArrayBufferView: Ote,
  isString: Dte,
  isNumber: t4,
  isBoolean: Nte,
  isObject: xm,
  isPlainObject: ay,
  isEmptyObject: Fte,
  isReadableStream: qte,
  isRequest: Wte,
  isResponse: Xte,
  isHeaders: Zte,
  isUndefined: Rp,
  isDate: Ute,
  isFile: zte,
  isBlob: jte,
  isRegExp: lre,
  isFunction: Pa,
  isStream: Gte,
  isURLSearchParams: Hte,
  isTypedArray: ire,
  isFileList: Vte,
  forEach: wm,
  merge: u2,
  extend: Jte,
  trim: Yte,
  stripBOM: Kte,
  inherits: Qte,
  toFlatObject: ere,
  kindOf: p0,
  kindOfTest: Lc,
  endsWith: tre,
  toArray: rre,
  forEachEntry: nre,
  matchAll: sre,
  isHTMLForm: ore,
  hasOwnProperty: ZC,
  hasOwnProp: ZC,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: n4,
  freezeMethods: cre,
  toObjectSet: ure,
  toCamelCase: are,
  noop: hre,
  toFiniteNumber: fre,
  findKey: r4,
  global: jf,
  isContextDefined: i4,
  isSpecCompliantForm: dre,
  toJSONObject: pre,
  isAsyncFn: gre,
  isThenable: mre,
  setImmediate: s4,
  asap: _re,
  isIterable: yre
};
function mi(r, e, t, i, n) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), i && (this.request = i), n && (this.response = n, this.status = n.status ? n.status : null);
}
Rt.inherits(mi, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Rt.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const o4 = mi.prototype, a4 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  a4[r] = {
    value: r
  };
});
Object.defineProperties(mi, a4);
Object.defineProperty(o4, "isAxiosError", {
  value: !0
});
mi.from = (r, e, t, i, n, s) => {
  const c = Object.create(o4);
  Rt.toFlatObject(r, c, function(y) {
    return y !== Error.prototype;
  }, (m) => m !== "isAxiosError");
  const o = r && r.message ? r.message : "Error", d = e == null && r ? r.code : e;
  return mi.call(c, o, d, t, i, n), r && c.cause == null && Object.defineProperty(c, "cause", {
    value: r,
    configurable: !0
  }), c.name = r && r.name || "Error", s && Object.assign(c, s), c;
};
const bre = null;
function h2(r) {
  return Rt.isPlainObject(r) || Rt.isArray(r);
}
function l4(r) {
  return Rt.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function YC(r, e, t) {
  return r ? r.concat(e).map(function(n, s) {
    return n = l4(n), !t && s ? "[" + n + "]" : n;
  }).join(t ? "." : "") : e;
}
function vre(r) {
  return Rt.isArray(r) && !r.some(h2);
}
const xre = Rt.toFlatObject(Rt, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function m0(r, e, t) {
  if (!Rt.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = Rt.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(k, $) {
    return !Rt.isUndefined($[k]);
  });
  const i = t.metaTokens, n = t.visitor || y, s = t.dots, c = t.indexes, d = (t.Blob || typeof Blob < "u" && Blob) && Rt.isSpecCompliantForm(e);
  if (!Rt.isFunction(n))
    throw new TypeError("visitor must be a function");
  function m(D) {
    if (D === null) return "";
    if (Rt.isDate(D))
      return D.toISOString();
    if (Rt.isBoolean(D))
      return D.toString();
    if (!d && Rt.isBlob(D))
      throw new mi("Blob is not supported. Use a Buffer instead.");
    return Rt.isArrayBuffer(D) || Rt.isTypedArray(D) ? d && typeof Blob == "function" ? new Blob([D]) : Buffer.from(D) : D;
  }
  function y(D, k, $) {
    let G = D;
    if (D && !$ && typeof D == "object") {
      if (Rt.endsWith(k, "{}"))
        k = i ? k : k.slice(0, -2), D = JSON.stringify(D);
      else if (Rt.isArray(D) && vre(D) || (Rt.isFileList(D) || Rt.endsWith(k, "[]")) && (G = Rt.toArray(D)))
        return k = l4(k), G.forEach(function(Z, H) {
          !(Rt.isUndefined(Z) || Z === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            c === !0 ? YC([k], H, s) : c === null ? k : k + "[]",
            m(Z)
          );
        }), !1;
    }
    return h2(D) ? !0 : (e.append(YC($, k, s), m(D)), !1);
  }
  const T = [], P = Object.assign(xre, {
    defaultVisitor: y,
    convertValue: m,
    isVisitable: h2
  });
  function I(D, k) {
    if (!Rt.isUndefined(D)) {
      if (T.indexOf(D) !== -1)
        throw Error("Circular reference detected in " + k.join("."));
      T.push(D), Rt.forEach(D, function(G, te) {
        (!(Rt.isUndefined(G) || G === null) && n.call(e, G, Rt.isString(te) ? te.trim() : te, k, P)) === !0 && I(G, k ? k.concat(te) : [te]);
      }), T.pop();
    }
  }
  if (!Rt.isObject(r))
    throw new TypeError("data must be an object");
  return I(r), e;
}
function JC(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(i) {
    return e[i];
  });
}
function nw(r, e) {
  this._pairs = [], r && m0(r, this, e);
}
const c4 = nw.prototype;
c4.append = function(e, t) {
  this._pairs.push([e, t]);
};
c4.toString = function(e) {
  const t = e ? function(i) {
    return e.call(this, i, JC);
  } : JC;
  return this._pairs.map(function(n) {
    return t(n[0]) + "=" + t(n[1]);
  }, "").join("&");
};
function wre(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function u4(r, e, t) {
  if (!e)
    return r;
  const i = t && t.encode || wre;
  Rt.isFunction(t) && (t = {
    serialize: t
  });
  const n = t && t.serialize;
  let s;
  if (n ? s = n(e, t) : s = Rt.isURLSearchParams(e) ? e.toString() : new nw(e, t).toString(i), s) {
    const c = r.indexOf("#");
    c !== -1 && (r = r.slice(0, c)), r += (r.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return r;
}
class KC {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, i) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Rt.forEach(this.handlers, function(i) {
      i !== null && e(i);
    });
  }
}
const h4 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Are = typeof URLSearchParams < "u" ? URLSearchParams : nw, Tre = typeof FormData < "u" ? FormData : null, Sre = typeof Blob < "u" ? Blob : null, Ere = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Are,
    FormData: Tre,
    Blob: Sre
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, sw = typeof window < "u" && typeof document < "u", f2 = typeof navigator == "object" && navigator || void 0, Cre = sw && (!f2 || ["ReactNative", "NativeScript", "NS"].indexOf(f2.product) < 0), Ire = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Pre = sw && window.location.href || "http://localhost", Mre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: sw,
  hasStandardBrowserEnv: Cre,
  hasStandardBrowserWebWorkerEnv: Ire,
  navigator: f2,
  origin: Pre
}, Symbol.toStringTag, { value: "Module" })), $o = {
  ...Mre,
  ...Ere
};
function Rre(r, e) {
  return m0(r, new $o.classes.URLSearchParams(), {
    visitor: function(t, i, n, s) {
      return $o.isNode && Rt.isBuffer(t) ? (this.append(i, t.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    },
    ...e
  });
}
function Lre(r) {
  return Rt.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function Bre(r) {
  const e = {}, t = Object.keys(r);
  let i;
  const n = t.length;
  let s;
  for (i = 0; i < n; i++)
    s = t[i], e[s] = r[s];
  return e;
}
function f4(r) {
  function e(t, i, n, s) {
    let c = t[s++];
    if (c === "__proto__") return !0;
    const o = Number.isFinite(+c), d = s >= t.length;
    return c = !c && Rt.isArray(n) ? n.length : c, d ? (Rt.hasOwnProp(n, c) ? n[c] = [n[c], i] : n[c] = i, !o) : ((!n[c] || !Rt.isObject(n[c])) && (n[c] = []), e(t, i, n[c], s) && Rt.isArray(n[c]) && (n[c] = Bre(n[c])), !o);
  }
  if (Rt.isFormData(r) && Rt.isFunction(r.entries)) {
    const t = {};
    return Rt.forEachEntry(r, (i, n) => {
      e(Lre(i), n, t, 0);
    }), t;
  }
  return null;
}
function kre(r, e, t) {
  if (Rt.isString(r))
    try {
      return (e || JSON.parse)(r), Rt.trim(r);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (t || JSON.stringify)(r);
}
const Am = {
  transitional: h4,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const i = t.getContentType() || "", n = i.indexOf("application/json") > -1, s = Rt.isObject(e);
    if (s && Rt.isHTMLForm(e) && (e = new FormData(e)), Rt.isFormData(e))
      return n ? JSON.stringify(f4(e)) : e;
    if (Rt.isArrayBuffer(e) || Rt.isBuffer(e) || Rt.isStream(e) || Rt.isFile(e) || Rt.isBlob(e) || Rt.isReadableStream(e))
      return e;
    if (Rt.isArrayBufferView(e))
      return e.buffer;
    if (Rt.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (s) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return Rre(e, this.formSerializer).toString();
      if ((o = Rt.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
        const d = this.env && this.env.FormData;
        return m0(o ? {
          "files[]": e
        } : e, d && new d(), this.formSerializer);
      }
    }
    return s || n ? (t.setContentType("application/json", !1), kre(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || Am.transitional, i = t && t.forcedJSONParsing, n = this.responseType === "json";
    if (Rt.isResponse(e) || Rt.isReadableStream(e))
      return e;
    if (e && Rt.isString(e) && (i && !this.responseType || n)) {
      const c = !(t && t.silentJSONParsing) && n;
      try {
        return JSON.parse(e, this.parseReviver);
      } catch (o) {
        if (c)
          throw o.name === "SyntaxError" ? mi.from(o, mi.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: $o.classes.FormData,
    Blob: $o.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Rt.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  Am.headers[r] = {};
});
const Ore = Rt.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), Dre = (r) => {
  const e = {};
  let t, i, n;
  return r && r.split(`
`).forEach(function(c) {
    n = c.indexOf(":"), t = c.substring(0, n).trim().toLowerCase(), i = c.substring(n + 1).trim(), !(!t || e[t] && Ore[t]) && (t === "set-cookie" ? e[t] ? e[t].push(i) : e[t] = [i] : e[t] = e[t] ? e[t] + ", " + i : i);
  }), e;
}, QC = Symbol("internals");
function xg(r) {
  return r && String(r).trim().toLowerCase();
}
function ly(r) {
  return r === !1 || r == null ? r : Rt.isArray(r) ? r.map(ly) : String(r);
}
function Nre(r) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = t.exec(r); )
    e[i[1]] = i[2];
  return e;
}
const Fre = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function X1(r, e, t, i, n) {
  if (Rt.isFunction(i))
    return i.call(this, e, t);
  if (n && (e = t), !!Rt.isString(e)) {
    if (Rt.isString(i))
      return e.indexOf(i) !== -1;
    if (Rt.isRegExp(i))
      return i.test(e);
  }
}
function Ure(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function zre(r, e) {
  const t = Rt.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(r, i + t, {
      value: function(n, s, c) {
        return this[i].call(this, e, n, s, c);
      },
      configurable: !0
    });
  });
}
let Ma = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const n = this;
    function s(o, d, m) {
      const y = xg(d);
      if (!y)
        throw new Error("header name must be a non-empty string");
      const T = Rt.findKey(n, y);
      (!T || n[T] === void 0 || m === !0 || m === void 0 && n[T] !== !1) && (n[T || d] = ly(o));
    }
    const c = (o, d) => Rt.forEach(o, (m, y) => s(m, y, d));
    if (Rt.isPlainObject(e) || e instanceof this.constructor)
      c(e, t);
    else if (Rt.isString(e) && (e = e.trim()) && !Fre(e))
      c(Dre(e), t);
    else if (Rt.isObject(e) && Rt.isIterable(e)) {
      let o = {}, d, m;
      for (const y of e) {
        if (!Rt.isArray(y))
          throw TypeError("Object iterator must return a key-value pair");
        o[m = y[0]] = (d = o[m]) ? Rt.isArray(d) ? [...d, y[1]] : [d, y[1]] : y[1];
      }
      c(o, t);
    } else
      e != null && s(t, e, i);
    return this;
  }
  get(e, t) {
    if (e = xg(e), e) {
      const i = Rt.findKey(this, e);
      if (i) {
        const n = this[i];
        if (!t)
          return n;
        if (t === !0)
          return Nre(n);
        if (Rt.isFunction(t))
          return t.call(this, n, i);
        if (Rt.isRegExp(t))
          return t.exec(n);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = xg(e), e) {
      const i = Rt.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || X1(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let n = !1;
    function s(c) {
      if (c = xg(c), c) {
        const o = Rt.findKey(i, c);
        o && (!t || X1(i, i[o], o, t)) && (delete i[o], n = !0);
      }
    }
    return Rt.isArray(e) ? e.forEach(s) : s(e), n;
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length, n = !1;
    for (; i--; ) {
      const s = t[i];
      (!e || X1(this, this[s], s, e, !0)) && (delete this[s], n = !0);
    }
    return n;
  }
  normalize(e) {
    const t = this, i = {};
    return Rt.forEach(this, (n, s) => {
      const c = Rt.findKey(i, s);
      if (c) {
        t[c] = ly(n), delete t[s];
        return;
      }
      const o = e ? Ure(s) : String(s).trim();
      o !== s && delete t[s], t[o] = ly(n), i[o] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return Rt.forEach(this, (i, n) => {
      i != null && i !== !1 && (t[n] = e && Rt.isArray(i) ? i.join(", ") : i);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const i = new this(e);
    return t.forEach((n) => i.set(n)), i;
  }
  static accessor(e) {
    const i = (this[QC] = this[QC] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function s(c) {
      const o = xg(c);
      i[o] || (zre(n, c), i[o] = !0);
    }
    return Rt.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
Ma.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Rt.reduceDescriptors(Ma.prototype, ({
  value: r
}, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => r,
    set(i) {
      this[t] = i;
    }
  };
});
Rt.freezeMethods(Ma);
function Z1(r, e) {
  const t = this || Am, i = e || t, n = Ma.from(i.headers);
  let s = i.data;
  return Rt.forEach(r, function(o) {
    s = o.call(t, s, n.normalize(), e ? e.status : void 0);
  }), n.normalize(), s;
}
function d4(r) {
  return !!(r && r.__CANCEL__);
}
function Gp(r, e, t) {
  mi.call(this, r ?? "canceled", mi.ERR_CANCELED, e, t), this.name = "CanceledError";
}
Rt.inherits(Gp, mi, {
  __CANCEL__: !0
});
function p4(r, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status) ? r(t) : e(new mi("Request failed with status code " + t.status, [mi.ERR_BAD_REQUEST, mi.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t));
}
function jre(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function Vre(r, e) {
  r = r || 10;
  const t = new Array(r), i = new Array(r);
  let n = 0, s = 0, c;
  return e = e !== void 0 ? e : 1e3, function(d) {
    const m = Date.now(), y = i[s];
    c || (c = m), t[n] = d, i[n] = m;
    let T = s, P = 0;
    for (; T !== n; )
      P += t[T++], T = T % r;
    if (n = (n + 1) % r, n === s && (s = (s + 1) % r), m - c < e)
      return;
    const I = y && m - y;
    return I ? Math.round(P * 1e3 / I) : void 0;
  };
}
function Gre(r, e) {
  let t = 0, i = 1e3 / e, n, s;
  const c = (m, y = Date.now()) => {
    t = y, n = null, s && (clearTimeout(s), s = null), r(...m);
  };
  return [(...m) => {
    const y = Date.now(), T = y - t;
    T >= i ? c(m, y) : (n = m, s || (s = setTimeout(() => {
      s = null, c(n);
    }, i - T)));
  }, () => n && c(n)];
}
const qy = (r, e, t = 3) => {
  let i = 0;
  const n = Vre(50, 250);
  return Gre((s) => {
    const c = s.loaded, o = s.lengthComputable ? s.total : void 0, d = c - i, m = n(d), y = c <= o;
    i = c;
    const T = {
      loaded: c,
      total: o,
      progress: o ? c / o : void 0,
      bytes: d,
      rate: m || void 0,
      estimated: m && o && y ? (o - c) / m : void 0,
      event: s,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    r(T);
  }, t);
}, e5 = (r, e) => {
  const t = r != null;
  return [(i) => e[0]({
    lengthComputable: t,
    total: r,
    loaded: i
  }), e[1]];
}, t5 = (r) => (...e) => Rt.asap(() => r(...e)), $re = $o.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (t) => (t = new URL(t, $o.origin), r.protocol === t.protocol && r.host === t.host && (e || r.port === t.port)))(new URL($o.origin), $o.navigator && /(msie|trident)/i.test($o.navigator.userAgent)) : () => !0, Hre = $o.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, t, i, n, s, c) {
      if (typeof document > "u") return;
      const o = [`${r}=${encodeURIComponent(e)}`];
      Rt.isNumber(t) && o.push(`expires=${new Date(t).toUTCString()}`), Rt.isString(i) && o.push(`path=${i}`), Rt.isString(n) && o.push(`domain=${n}`), s === !0 && o.push("secure"), Rt.isString(c) && o.push(`SameSite=${c}`), document.cookie = o.join("; ");
    },
    read(r) {
      if (typeof document > "u") return null;
      const e = document.cookie.match(new RegExp("(?:^|; )" + r + "=([^;]*)"));
      return e ? decodeURIComponent(e[1]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function qre(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function Wre(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function g4(r, e, t) {
  let i = !qre(e);
  return r && (i || t == !1) ? Wre(r, e) : e;
}
const r5 = (r) => r instanceof Ma ? {
  ...r
} : r;
function od(r, e) {
  e = e || {};
  const t = {};
  function i(m, y, T, P) {
    return Rt.isPlainObject(m) && Rt.isPlainObject(y) ? Rt.merge.call({
      caseless: P
    }, m, y) : Rt.isPlainObject(y) ? Rt.merge({}, y) : Rt.isArray(y) ? y.slice() : y;
  }
  function n(m, y, T, P) {
    if (Rt.isUndefined(y)) {
      if (!Rt.isUndefined(m))
        return i(void 0, m, T, P);
    } else return i(m, y, T, P);
  }
  function s(m, y) {
    if (!Rt.isUndefined(y))
      return i(void 0, y);
  }
  function c(m, y) {
    if (Rt.isUndefined(y)) {
      if (!Rt.isUndefined(m))
        return i(void 0, m);
    } else return i(void 0, y);
  }
  function o(m, y, T) {
    if (T in e)
      return i(m, y);
    if (T in r)
      return i(void 0, m);
  }
  const d = {
    url: s,
    method: s,
    data: s,
    baseURL: c,
    transformRequest: c,
    transformResponse: c,
    paramsSerializer: c,
    timeout: c,
    timeoutMessage: c,
    withCredentials: c,
    withXSRFToken: c,
    adapter: c,
    responseType: c,
    xsrfCookieName: c,
    xsrfHeaderName: c,
    onUploadProgress: c,
    onDownloadProgress: c,
    decompress: c,
    maxContentLength: c,
    maxBodyLength: c,
    beforeRedirect: c,
    transport: c,
    httpAgent: c,
    httpsAgent: c,
    cancelToken: c,
    socketPath: c,
    responseEncoding: c,
    validateStatus: o,
    headers: (m, y, T) => n(r5(m), r5(y), T, !0)
  };
  return Rt.forEach(Object.keys({
    ...r,
    ...e
  }), function(y) {
    const T = d[y] || n, P = T(r[y], e[y], y);
    Rt.isUndefined(P) && T !== o || (t[y] = P);
  }), t;
}
const m4 = (r) => {
  const e = od({}, r);
  let {
    data: t,
    withXSRFToken: i,
    xsrfHeaderName: n,
    xsrfCookieName: s,
    headers: c,
    auth: o
  } = e;
  if (e.headers = c = Ma.from(c), e.url = u4(g4(e.baseURL, e.url, e.allowAbsoluteUrls), r.params, r.paramsSerializer), o && c.set("Authorization", "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))), Rt.isFormData(t)) {
    if ($o.hasStandardBrowserEnv || $o.hasStandardBrowserWebWorkerEnv)
      c.setContentType(void 0);
    else if (Rt.isFunction(t.getHeaders)) {
      const d = t.getHeaders(), m = ["content-type", "content-length"];
      Object.entries(d).forEach(([y, T]) => {
        m.includes(y.toLowerCase()) && c.set(y, T);
      });
    }
  }
  if ($o.hasStandardBrowserEnv && (i && Rt.isFunction(i) && (i = i(e)), i || i !== !1 && $re(e.url))) {
    const d = n && s && Hre.read(s);
    d && c.set(n, d);
  }
  return e;
}, Xre = typeof XMLHttpRequest < "u", Zre = Xre && function(r) {
  return new Promise(function(t, i) {
    const n = m4(r);
    let s = n.data;
    const c = Ma.from(n.headers).normalize();
    let {
      responseType: o,
      onUploadProgress: d,
      onDownloadProgress: m
    } = n, y, T, P, I, D;
    function k() {
      I && I(), D && D(), n.cancelToken && n.cancelToken.unsubscribe(y), n.signal && n.signal.removeEventListener("abort", y);
    }
    let $ = new XMLHttpRequest();
    $.open(n.method.toUpperCase(), n.url, !0), $.timeout = n.timeout;
    function G() {
      if (!$)
        return;
      const Z = Ma.from("getAllResponseHeaders" in $ && $.getAllResponseHeaders()), J = {
        data: !o || o === "text" || o === "json" ? $.responseText : $.response,
        status: $.status,
        statusText: $.statusText,
        headers: Z,
        config: r,
        request: $
      };
      p4(function(be) {
        t(be), k();
      }, function(be) {
        i(be), k();
      }, J), $ = null;
    }
    "onloadend" in $ ? $.onloadend = G : $.onreadystatechange = function() {
      !$ || $.readyState !== 4 || $.status === 0 && !($.responseURL && $.responseURL.indexOf("file:") === 0) || setTimeout(G);
    }, $.onabort = function() {
      $ && (i(new mi("Request aborted", mi.ECONNABORTED, r, $)), $ = null);
    }, $.onerror = function(H) {
      const J = H && H.message ? H.message : "Network Error", re = new mi(J, mi.ERR_NETWORK, r, $);
      re.event = H || null, i(re), $ = null;
    }, $.ontimeout = function() {
      let H = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const J = n.transitional || h4;
      n.timeoutErrorMessage && (H = n.timeoutErrorMessage), i(new mi(H, J.clarifyTimeoutError ? mi.ETIMEDOUT : mi.ECONNABORTED, r, $)), $ = null;
    }, s === void 0 && c.setContentType(null), "setRequestHeader" in $ && Rt.forEach(c.toJSON(), function(H, J) {
      $.setRequestHeader(J, H);
    }), Rt.isUndefined(n.withCredentials) || ($.withCredentials = !!n.withCredentials), o && o !== "json" && ($.responseType = n.responseType), m && ([P, D] = qy(m, !0), $.addEventListener("progress", P)), d && $.upload && ([T, I] = qy(d), $.upload.addEventListener("progress", T), $.upload.addEventListener("loadend", I)), (n.cancelToken || n.signal) && (y = (Z) => {
      $ && (i(!Z || Z.type ? new Gp(null, r, $) : Z), $.abort(), $ = null);
    }, n.cancelToken && n.cancelToken.subscribe(y), n.signal && (n.signal.aborted ? y() : n.signal.addEventListener("abort", y)));
    const te = jre(n.url);
    if (te && $o.protocols.indexOf(te) === -1) {
      i(new mi("Unsupported protocol " + te + ":", mi.ERR_BAD_REQUEST, r));
      return;
    }
    $.send(s || null);
  });
}, Yre = (r, e) => {
  const {
    length: t
  } = r = r ? r.filter(Boolean) : [];
  if (e || t) {
    let i = new AbortController(), n;
    const s = function(m) {
      if (!n) {
        n = !0, o();
        const y = m instanceof Error ? m : this.reason;
        i.abort(y instanceof mi ? y : new Gp(y instanceof Error ? y.message : y));
      }
    };
    let c = e && setTimeout(() => {
      c = null, s(new mi(`timeout ${e} of ms exceeded`, mi.ETIMEDOUT));
    }, e);
    const o = () => {
      r && (c && clearTimeout(c), c = null, r.forEach((m) => {
        m.unsubscribe ? m.unsubscribe(s) : m.removeEventListener("abort", s);
      }), r = null);
    };
    r.forEach((m) => m.addEventListener("abort", s));
    const {
      signal: d
    } = i;
    return d.unsubscribe = () => Rt.asap(o), d;
  }
}, Jre = function* (r, e) {
  let t = r.byteLength;
  if (t < e) {
    yield r;
    return;
  }
  let i = 0, n;
  for (; i < t; )
    n = i + e, yield r.slice(i, n), i = n;
}, Kre = async function* (r, e) {
  for await (const t of Qre(r))
    yield* Jre(t, e);
}, Qre = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const {
        done: t,
        value: i
      } = await e.read();
      if (t)
        break;
      yield i;
    }
  } finally {
    await e.cancel();
  }
}, i5 = (r, e, t, i) => {
  const n = Kre(r, e);
  let s = 0, c, o = (d) => {
    c || (c = !0, i && i(d));
  };
  return new ReadableStream({
    async pull(d) {
      try {
        const {
          done: m,
          value: y
        } = await n.next();
        if (m) {
          o(), d.close();
          return;
        }
        let T = y.byteLength;
        if (t) {
          let P = s += T;
          t(P);
        }
        d.enqueue(new Uint8Array(y));
      } catch (m) {
        throw o(m), m;
      }
    },
    cancel(d) {
      return o(d), n.return();
    }
  }, {
    highWaterMark: 2
  });
}, n5 = 64 * 1024, {
  isFunction: O_
} = Rt, eie = (({
  Request: r,
  Response: e
}) => ({
  Request: r,
  Response: e
}))(Rt.global), {
  ReadableStream: s5,
  TextEncoder: o5
} = Rt.global, a5 = (r, ...e) => {
  try {
    return !!r(...e);
  } catch {
    return !1;
  }
}, tie = (r) => {
  r = Rt.merge.call({
    skipUndefined: !0
  }, eie, r);
  const {
    fetch: e,
    Request: t,
    Response: i
  } = r, n = e ? O_(e) : typeof fetch == "function", s = O_(t), c = O_(i);
  if (!n)
    return !1;
  const o = n && O_(s5), d = n && (typeof o5 == "function" ? /* @__PURE__ */ ((D) => (k) => D.encode(k))(new o5()) : async (D) => new Uint8Array(await new t(D).arrayBuffer())), m = s && o && a5(() => {
    let D = !1;
    const k = new t($o.origin, {
      body: new s5(),
      method: "POST",
      get duplex() {
        return D = !0, "half";
      }
    }).headers.has("Content-Type");
    return D && !k;
  }), y = c && o && a5(() => Rt.isReadableStream(new i("").body)), T = {
    stream: y && ((D) => D.body)
  };
  n && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((D) => {
    !T[D] && (T[D] = (k, $) => {
      let G = k && k[D];
      if (G)
        return G.call(k);
      throw new mi(`Response type '${D}' is not supported`, mi.ERR_NOT_SUPPORT, $);
    });
  });
  const P = async (D) => {
    if (D == null)
      return 0;
    if (Rt.isBlob(D))
      return D.size;
    if (Rt.isSpecCompliantForm(D))
      return (await new t($o.origin, {
        method: "POST",
        body: D
      }).arrayBuffer()).byteLength;
    if (Rt.isArrayBufferView(D) || Rt.isArrayBuffer(D))
      return D.byteLength;
    if (Rt.isURLSearchParams(D) && (D = D + ""), Rt.isString(D))
      return (await d(D)).byteLength;
  }, I = async (D, k) => {
    const $ = Rt.toFiniteNumber(D.getContentLength());
    return $ ?? P(k);
  };
  return async (D) => {
    let {
      url: k,
      method: $,
      data: G,
      signal: te,
      cancelToken: Z,
      timeout: H,
      onDownloadProgress: J,
      onUploadProgress: re,
      responseType: be,
      headers: pe,
      withCredentials: oe = "same-origin",
      fetchOptions: Ee
    } = m4(D), le = e || fetch;
    be = be ? (be + "").toLowerCase() : "text";
    let _e = Yre([te, Z && Z.toAbortSignal()], H), Ve = null;
    const Be = _e && _e.unsubscribe && (() => {
      _e.unsubscribe();
    });
    let gt;
    try {
      if (re && m && $ !== "get" && $ !== "head" && (gt = await I(pe, G)) !== 0) {
        let Dt = new t(k, {
          method: "POST",
          body: G,
          duplex: "half"
        }), fe;
        if (Rt.isFormData(G) && (fe = Dt.headers.get("content-type")) && pe.setContentType(fe), Dt.body) {
          const [De, je] = e5(gt, qy(t5(re)));
          G = i5(Dt.body, n5, De, je);
        }
      }
      Rt.isString(oe) || (oe = oe ? "include" : "omit");
      const St = s && "credentials" in t.prototype, Mt = {
        ...Ee,
        signal: _e,
        method: $.toUpperCase(),
        headers: pe.normalize().toJSON(),
        body: G,
        duplex: "half",
        credentials: St ? oe : void 0
      };
      Ve = s && new t(k, Mt);
      let mt = await (s ? le(Ve, Ee) : le(k, Mt));
      const wt = y && (be === "stream" || be === "response");
      if (y && (J || wt && Be)) {
        const Dt = {};
        ["status", "statusText", "headers"].forEach((Ke) => {
          Dt[Ke] = mt[Ke];
        });
        const fe = Rt.toFiniteNumber(mt.headers.get("content-length")), [De, je] = J && e5(fe, qy(t5(J), !0)) || [];
        mt = new i(i5(mt.body, n5, De, () => {
          je && je(), Be && Be();
        }), Dt);
      }
      be = be || "text";
      let Yt = await T[Rt.findKey(T, be) || "text"](mt, D);
      return !wt && Be && Be(), await new Promise((Dt, fe) => {
        p4(Dt, fe, {
          data: Yt,
          headers: Ma.from(mt.headers),
          status: mt.status,
          statusText: mt.statusText,
          config: D,
          request: Ve
        });
      });
    } catch (St) {
      throw Be && Be(), St && St.name === "TypeError" && /Load failed|fetch/i.test(St.message) ? Object.assign(new mi("Network Error", mi.ERR_NETWORK, D, Ve), {
        cause: St.cause || St
      }) : mi.from(St, St && St.code, D, Ve);
    }
  };
}, rie = /* @__PURE__ */ new Map(), _4 = (r) => {
  let e = r && r.env || {};
  const {
    fetch: t,
    Request: i,
    Response: n
  } = e, s = [i, n, t];
  let c = s.length, o = c, d, m, y = rie;
  for (; o--; )
    d = s[o], m = y.get(d), m === void 0 && y.set(d, m = o ? /* @__PURE__ */ new Map() : tie(e)), y = m;
  return m;
};
_4();
const ow = {
  http: bre,
  xhr: Zre,
  fetch: {
    get: _4
  }
};
Rt.forEach(ow, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", {
        value: e
      });
    } catch {
    }
    Object.defineProperty(r, "adapterName", {
      value: e
    });
  }
});
const l5 = (r) => `- ${r}`, iie = (r) => Rt.isFunction(r) || r === null || r === !1;
function nie(r, e) {
  r = Rt.isArray(r) ? r : [r];
  const {
    length: t
  } = r;
  let i, n;
  const s = {};
  for (let c = 0; c < t; c++) {
    i = r[c];
    let o;
    if (n = i, !iie(i) && (n = ow[(o = String(i)).toLowerCase()], n === void 0))
      throw new mi(`Unknown adapter '${o}'`);
    if (n && (Rt.isFunction(n) || (n = n.get(e))))
      break;
    s[o || "#" + c] = n;
  }
  if (!n) {
    const c = Object.entries(s).map(([d, m]) => `adapter ${d} ` + (m === !1 ? "is not supported by the environment" : "is not available in the build"));
    let o = t ? c.length > 1 ? `since :
` + c.map(l5).join(`
`) : " " + l5(c[0]) : "as no adapter specified";
    throw new mi("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT");
  }
  return n;
}
const y4 = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter: nie,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: ow
};
function Y1(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new Gp(null, r);
}
function c5(r) {
  return Y1(r), r.headers = Ma.from(r.headers), r.data = Z1.call(r, r.transformRequest), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), y4.getAdapter(r.adapter || Am.adapter, r)(r).then(function(i) {
    return Y1(r), i.data = Z1.call(r, r.transformResponse, i), i.headers = Ma.from(i.headers), i;
  }, function(i) {
    return d4(i) || (Y1(r), i && i.response && (i.response.data = Z1.call(r, r.transformResponse, i.response), i.response.headers = Ma.from(i.response.headers))), Promise.reject(i);
  });
}
const b4 = "1.13.1", _0 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  _0[r] = function(i) {
    return typeof i === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const u5 = {};
_0.transitional = function(e, t, i) {
  function n(s, c) {
    return "[Axios v" + b4 + "] Transitional option '" + s + "'" + c + (i ? ". " + i : "");
  }
  return (s, c, o) => {
    if (e === !1)
      throw new mi(n(c, " has been removed" + (t ? " in " + t : "")), mi.ERR_DEPRECATED);
    return t && !u5[c] && (u5[c] = !0, console.warn(n(c, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(s, c, o) : !0;
  };
};
_0.spelling = function(e) {
  return (t, i) => (console.warn(`${i} is likely a misspelling of ${e}`), !0);
};
function sie(r, e, t) {
  if (typeof r != "object")
    throw new mi("options must be an object", mi.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(r);
  let n = i.length;
  for (; n-- > 0; ) {
    const s = i[n], c = e[s];
    if (c) {
      const o = r[s], d = o === void 0 || c(o, s, r);
      if (d !== !0)
        throw new mi("option " + s + " must be " + d, mi.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new mi("Unknown option " + s, mi.ERR_BAD_OPTION);
  }
}
const cy = {
  assertOptions: sie,
  validators: _0
}, hu = cy.validators;
let Xf = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new KC(),
      response: new KC()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (i) {
      if (i instanceof Error) {
        let n = {};
        Error.captureStackTrace ? Error.captureStackTrace(n) : n = new Error();
        const s = n.stack ? n.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? s && !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + s) : i.stack = s;
        } catch {
        }
      }
      throw i;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = od(this.defaults, t);
    const {
      transitional: i,
      paramsSerializer: n,
      headers: s
    } = t;
    i !== void 0 && cy.assertOptions(i, {
      silentJSONParsing: hu.transitional(hu.boolean),
      forcedJSONParsing: hu.transitional(hu.boolean),
      clarifyTimeoutError: hu.transitional(hu.boolean)
    }, !1), n != null && (Rt.isFunction(n) ? t.paramsSerializer = {
      serialize: n
    } : cy.assertOptions(n, {
      encode: hu.function,
      serialize: hu.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), cy.assertOptions(t, {
      baseUrl: hu.spelling("baseURL"),
      withXsrfToken: hu.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let c = s && Rt.merge(s.common, s[t.method]);
    s && Rt.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (D) => {
      delete s[D];
    }), t.headers = Ma.concat(c, s);
    const o = [];
    let d = !0;
    this.interceptors.request.forEach(function(k) {
      typeof k.runWhen == "function" && k.runWhen(t) === !1 || (d = d && k.synchronous, o.unshift(k.fulfilled, k.rejected));
    });
    const m = [];
    this.interceptors.response.forEach(function(k) {
      m.push(k.fulfilled, k.rejected);
    });
    let y, T = 0, P;
    if (!d) {
      const D = [c5.bind(this), void 0];
      for (D.unshift(...o), D.push(...m), P = D.length, y = Promise.resolve(t); T < P; )
        y = y.then(D[T++], D[T++]);
      return y;
    }
    P = o.length;
    let I = t;
    for (; T < P; ) {
      const D = o[T++], k = o[T++];
      try {
        I = D(I);
      } catch ($) {
        k.call(this, $);
        break;
      }
    }
    try {
      y = c5.call(this, I);
    } catch (D) {
      return Promise.reject(D);
    }
    for (T = 0, P = m.length; T < P; )
      y = y.then(m[T++], m[T++]);
    return y;
  }
  getUri(e) {
    e = od(this.defaults, e);
    const t = g4(e.baseURL, e.url, e.allowAbsoluteUrls);
    return u4(t, e.params, e.paramsSerializer);
  }
};
Rt.forEach(["delete", "get", "head", "options"], function(e) {
  Xf.prototype[e] = function(t, i) {
    return this.request(od(i || {}, {
      method: e,
      url: t,
      data: (i || {}).data
    }));
  };
});
Rt.forEach(["post", "put", "patch"], function(e) {
  function t(i) {
    return function(s, c, o) {
      return this.request(od(o || {}, {
        method: e,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: c
      }));
    };
  }
  Xf.prototype[e] = t(), Xf.prototype[e + "Form"] = t(!0);
});
let oie = class v4 {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(s) {
      t = s;
    });
    const i = this;
    this.promise.then((n) => {
      if (!i._listeners) return;
      let s = i._listeners.length;
      for (; s-- > 0; )
        i._listeners[s](n);
      i._listeners = null;
    }), this.promise.then = (n) => {
      let s;
      const c = new Promise((o) => {
        i.subscribe(o), s = o;
      }).then(n);
      return c.cancel = function() {
        i.unsubscribe(s);
      }, c;
    }, e(function(s, c, o) {
      i.reason || (i.reason = new Gp(s, c, o), t(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (i) => {
      e.abort(i);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new v4(function(n) {
        e = n;
      }),
      cancel: e
    };
  }
};
function aie(r) {
  return function(t) {
    return r.apply(null, t);
  };
}
function lie(r) {
  return Rt.isObject(r) && r.isAxiosError === !0;
}
const d2 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(d2).forEach(([r, e]) => {
  d2[e] = r;
});
function x4(r) {
  const e = new Xf(r), t = KR(Xf.prototype.request, e);
  return Rt.extend(t, Xf.prototype, e, {
    allOwnKeys: !0
  }), Rt.extend(t, e, null, {
    allOwnKeys: !0
  }), t.create = function(n) {
    return x4(od(r, n));
  }, t;
}
const ws = x4(Am);
ws.Axios = Xf;
ws.CanceledError = Gp;
ws.CancelToken = oie;
ws.isCancel = d4;
ws.VERSION = b4;
ws.toFormData = m0;
ws.AxiosError = mi;
ws.Cancel = ws.CanceledError;
ws.all = function(e) {
  return Promise.all(e);
};
ws.spread = aie;
ws.isAxiosError = lie;
ws.mergeConfig = od;
ws.AxiosHeaders = Ma;
ws.formToJSON = (r) => f4(Rt.isHTMLForm(r) ? new FormData(r) : r);
ws.getAdapter = y4.getAdapter;
ws.HttpStatusCode = d2;
ws.default = ws;
const {
  Axios: Rie,
  AxiosError: Lie,
  CanceledError: Bie,
  isCancel: kie,
  CancelToken: Oie,
  VERSION: Die,
  all: Nie,
  Cancel: Fie,
  isAxiosError: Uie,
  spread: zie,
  toFormData: jie,
  AxiosHeaders: Vie,
  HttpStatusCode: Gie,
  formToJSON: $ie,
  getAdapter: Hie,
  mergeConfig: qie
} = ws, cie = "https://eines.icgc.cat/recursos/mapicgc-gl-js/mapicgc-config.json", uie = 5e3;
class hie {
  static async getConfigICGC() {
    try {
      const e = await ws.get(cie, {
        timeout: uie
      });
      return e.data ? e.data : (console.log("Resposta sense dades:", e), zf);
    } catch (e) {
      return e.response ? (console.error("Error de resposta:", e.response.data), console.error("Codi d'estat:", e.response.status)) : e.request ? console.error("No s'ha rebut resposta del servidor:", e.request) : console.error("Error:", e.message), zf;
    }
  }
}
const fie = {
  "fill-opacity": ["interpolate", ["exponential", 0.5], ["zoom"], 13.5, 1, 18, 0.4],
  "fill-outline-color": "rgba(0,0, 0, 0)",
  "fill-color": ["interpolate", ["cubic-bezier", 0.5, 1, 1, 1], ["get", "nivell_2"], 0, "#ffffff", 111, "#ffff00", 112, "#ccff33", 113, "#af5b15", 114, "#808000", 115, "#cdcd00", 116, "#ffffcc", 221, "#33cc33", 222, "#66ff33", 223, "#689018", 224, "#967d5f", 225, "#19e61e", 226, "#b4ff9b", 227, "#aaa500", 228, "#c3c3a0", 229, "#00ff9b", 230, "#ff9632", 231, "#282828", 232, "#79797a", 233, "#f5df78", 234, "#3296ff", 341, "#ff007d", 342, "#ff53cd", 343, "#ffa4e2", 344, "#ffc8e2", 345, "#ffb4b4", 346, "#0f3700", 347, "#730055", 348, "#6200c4", 349, "#4a9595", 350, "#ff00f0", 351, "#adaaca", 352, "#ffe6e6", 353, "#67629a", 354, "#4a466e", 355, "#2f2d46", 461, "#6f6fff", 462, "#0000dc", 463, "#000064", 464, "#185f94", 465, "#12466d", 466, "#000080"]
}, die = {
  cobertesSol: fie
}, pie = "lines", D_ = "labels";
let pc, Cf, Zd, as, rn, Wie = class {
  /**
   * Constructor for the Map class.
   * @param {Object} options - Options to initialize the map.
   */
  constructor(e) {
    hie.getConfigICGC().then((t) => {
      Cf = {
        ...t.Styles
      }, as = {
        ...t.Layers
      }, Zd = {
        ...t.Terrains
      }, rn = {
        ...t.defaultOptions
      }, this.initTheMap(e);
    }).catch((t) => {
      console.info("Configuracio per defecte", t), Cf = {
        ...zf.Styles
      }, as = {
        ...zf.Layers
      }, Zd = {
        ...zf.Terrains
      }, rn = {
        ...zf.defaultOptions
      }, this.initTheMap(e);
    });
  }
  initTheMap(e) {
    if (!e)
      e = rn.mapOptions;
    else
      for (const n in rn.mapOptions) {
        let s = [rn.mapOptions.center[0], rn.mapOptions.center[1]];
        rn.mapOptions.center = s, e.hasOwnProperty(n) || (e[n] = rn.mapOptions[n]);
      }
    e.maxPitch = 85, e.maplibreLogo = !1, e.attributionControl = !1;
    const t = e.style === "RELIEF" || typeof e.style == "object" && e.style.hasOwnProperty("colorRelief"), i = typeof e.style == "string" && e.style.includes("https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/");
    if (t) {
      const n = typeof e.style == "object" ? e.style : {}, s = n.source || {
        type: "raster-dem",
        tiles: [Zd.ICGC5M],
        tileSize: 512,
        maxzoom: 20
      }, c = n.colorRelief || ["interpolate", ["linear"], ["elevation"], -50, "rgb(30, 70, 130)", 0, "rgb(120, 180, 210)", 5, "rgb(170, 220, 170)", 100, "rgb(180, 210, 140)", 300, "rgb(220, 220, 130)", 500, "rgb(245, 220, 110)", 800, "rgb(250, 200, 100)", 1100, "rgb(245, 170, 90)", 1400, "rgb(230, 140, 80)", 1700, "rgb(210, 130, 90)", 2e3, "rgb(190, 130, 110)", 2400, "rgb(180, 150, 130)", 2800, "rgb(200, 190, 180)", 3200, "rgb(235, 235, 235)", 3600, "rgb(255, 255, 255)"];
      this.map = new Zs.Map({
        container: e.container,
        center: e.center,
        zoom: e.zoom,
        pitch: e.pitch || 0,
        bearing: e.bearing || 0,
        hash: e.hash || !1,
        maxZoom: e.maxZoom || 18,
        maxPitch: e.maxPitch || 85,
        renderWorldCopies: !1,
        style: {
          version: 8,
          sources: {
            terrainSource: s
          },
          layers: [{
            id: "color-relief",
            type: "color-relief",
            source: "terrainSource",
            paint: {
              "color-relief-color": c
            }
          }]
        }
      });
    } else i ? (this.map = new Zs.Map({
      container: e.container,
      center: e.center,
      zoom: e.zoom,
      pitch: e.pitch || 0,
      hash: e.hash || !1,
      style: {
        version: 8,
        sources: {},
        layers: []
      }
    }), this.map.on("load", () => {
      this.map.addSource("raster-source", {
        type: "raster",
        tiles: [e.style],
        tileSize: 256
      }), this.map.addLayer({
        id: "raster-layer",
        type: "raster",
        source: "raster-source"
      });
    })) : this.map = new Zs.Map(e);
    this.map.on("load", () => {
      if (!i && !t) {
        const n = this.map.getStyle().name, s = e.style;
        this.map.addControl(new Ite({
          color: s.indexOf("orto") === -1,
          defaultOptions: rn
        }), "bottom-left"), this._dealOrto3dStyle(n);
      }
    });
  }
  /**
   * Add geocoder with customizable options.
   * @function addGeocoderICGC
   * @param {Object} [options={}] - Optional configuration options for the geocoder. Defaults to an empty object.
   * @param {string} [position='top-right'] - Position to add the geocoder control on the map. Defaults to 'top-right'.
   * @returns {Object} - The merged configuration options for the geocoder, including the position.
   *
   */
  addGeocoderICGC(e = {}, t = "top-right") {
    try {
      e = {
        ...{
          collapsed: !0,
          marker: !0,
          zoom: 16,
          popup: !0,
          showResultMarkers: !0,
          maplibregl: Zs,
          showResultsWhileTyping: !0,
          minLength: 2
        },
        ...e
      };
      const n = {
        forwardGeocode: async (c) => {
          const o = [];
          try {
            const d = rn.geocoder.peliasUrl1 + encodeURIComponent(c.query) + rn.geocoder.peliasUrl2, y = await (await fetch(d)).json();
            for (const T of y.features) {
              const P = T.geometry.coordinates, I = {
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: P
                },
                place_name: T.properties.etiqueta,
                properties: T.properties,
                text: T.properties.etiqueta,
                place_type: ["place"],
                center: P
              };
              o.push(I);
            }
          } catch (d) {
            console.error(`Failed to forwardGeocode with error: ${d}`);
          }
          return {
            features: o
          };
        }
      };
      this.map.addControl(new Ate(n, e), t);
      let s = document.getElementsByClassName("maplibregl-ctrl-geocoder--input");
      s[0].attributes[2].nodeValue = "Cerca...", s[0].addEventListener("input", function(c) {
        c.target.value.length > 3;
      });
    } catch (i) {
      console.error(`Error adding ICGC geocoder: ${i.message}`);
    }
  }
  //geocoder ends
  async loadImage(e) {
    try {
      return this.map.loadImage(e);
    } catch (t) {
      console.error(`Error getting loadImage: ${t.message}`);
    }
  }
  /**
   * Retrieves the available base styles from default options.
   * @function getConfigStyles
   * @returns {Array} - Array containing the names of available base styles.
   */
  getConfigStyles() {
    try {
      let e = [];
      for (const t of Cf)
        e.push(t.name);
      return e;
    } catch (e) {
      console.error(`Error retrieving base styles: ${e.message}`);
    }
  }
  /**
   * Retrieves the available WMS image layers from default options.
   * @function getConfigWMSLayers
   * @returns {Array} - Array containing the keys of available WMS image layers.
   */
  getConfigWMSLayers() {
    try {
      let e = [];
      for (const t in as.WMS)
        as.WMS.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving WMS layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available orto image layers from default options.
   * @function getConfigOrtoLayers
   * @returns {Array} - Array containing the keys of available image layers.
   */
  getConfigOrtoLayers() {
    try {
      let e = [];
      for (const t in as.Orto)
        as.Orto.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving orto image layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorLayers
   * @returns {Array} - Array containing the keys of available vector layers.
   */
  getConfigVectorLayers() {
    try {
      let e = [];
      for (const t in as.Vector)
        as.Vector.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vector layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorAdminLayers
   * @returns {Array} - Array containing the keys of available vectorAdmin layers.
   */
  getConfigVectorAdminLayers() {
    try {
      let e = [];
      for (const t in as.VectorAdmin)
        as.VectorAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vectorAdmin layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available fgb layers from default options.
   * @function getConfigFGBAdminLayers
   * @returns {Array} - Array containing the keys of available fgbadmin layers.
   */
  getConfigFGBAdminLayers() {
    try {
      let e = [];
      for (const t in as.FGBAdmin)
        as.FGBAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving FGBAdmin layers: ${e.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The id for the layer.
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchData(e, t, i) {
    try {
      (!i || i === void 0) && (i = {
        type: "line",
        layout: {
          visibility: "visible"
        },
        paint: {
          "line-color": "grey",
          "line-width": 2
        },
        layerPosition: "top"
        // select: 'top', 'lines' or 'labels'
      });
      let n = i.layerPosition;
      if (e.includes(".fgb"))
        this.addFGBLayerICGC(e, t, i);
      else {
        const c = await (await fetch(e)).json();
        let o = t, d = this._dealOrderLayer(n), m = c.features[0].geometry.type;
        m.includes("ine") && (i !== void 0 ? this.map.addLayer({
          id: o,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout || {},
          paint: i.paint || {}
        }, d) : this.map.addLayer({
          id: o,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "line-color": "black",
            "line-width": 2,
            "line-opacity": 1
          }
        }, d)), m.includes("olygon") && (i !== void 0 ? this.map.addLayer({
          id: o,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout,
          paint: i.paint
        }, d) : this.map.addLayer({
          id: o,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "fill-color": "blue",
            "fill-opacity": 0.6
          }
        }, d)), m.includes("oint") && (i !== void 0 ? this.map.addLayer({
          id: o,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout,
          paint: i.paint
        }, d) : this.map.addLayer({
          id: o,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "circle-color": "red",
            "circle-opacity": 0.85
          }
        }, d));
      }
    } catch (n) {
      console.error(`Error fetching data: ${n.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type and adds to the Menu as a checkbox item.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The geometry name (e.g., 'buildings').
   * @param {string} filterField - Import all features as unique or group based on a field ('all', 'field').
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchDataAndMenu(e, t, i, n) {
    try {
      let s;
      n !== null ? s = n.layerPosition : s = D_;
      let c, o = document.getElementById("map");
      if (document.getElementById("menu-group") ? c = document.getElementById("menu-group") : (c = document.createElement("nav"), c.id = "menu-group", c.classList.add = "filter-group", o.appendChild(c)), c !== null) {
        let d = "visible", m = this._dealOrderLayer(s), y;
        if (e.includes(".fgb")) {
          let P = this._getKeyByUrlFGB(e);
          P === null && (P = "userFGB");
          const I = await fetch(e), D = {
            type: "FeatureCollection",
            features: []
          };
          for await (const $ of XA(I.body)) D.features.push($);
          y = D;
          let k = t;
          if (this.map.addSource(k, {
            type: "geojson",
            data: D
          }), e.includes("text"))
            n !== void 0 ? this.map.addLayer({
              id: t,
              type: "symbol",
              source: k,
              layout: n.layout,
              paint: n.paint
            }, m) : this.map.addLayer({
              id: t,
              type: "symbol",
              source: k,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: d,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, m);
          else {
            let $ = t + "Text";
            this.map.addLayer({
              id: $,
              type: "symbol",
              source: k,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: d,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, m);
          }
        } else
          y = await (await fetch(e)).json();
        if (i !== "all") {
          const P = document.createElement("div");
          P.id = "titleDivMenu", P.textContent = t, c.appendChild(P);
          const I = document.createElement("div");
          I.id = "titleDivMenuSub", I.textContent = `📂 ${i}`, c.appendChild(I);
        }
        let T;
        if (n.type ? T = n.type : T = y.features[0].geometry.type, i === "all")
          T.includes("ine") && (n !== void 0 ? this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: y
            },
            layout: n.layout,
            paint: n.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: y
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "line-color": "black",
              "line-width": 2,
              "line-opacity": 1
            }
          }, m)), T.includes("olygon") && (n !== void 0 ? this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: y
            },
            layout: n.layout,
            paint: n.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: y
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "fill-color": "#0000FF",
              "fill-opacity": 0
            }
          }, m)), T.includes("oint") && (n !== void 0 ? this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: y
            },
            layout: n.layout,
            paint: n.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: y
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "circle-color": "red",
              "circle-opacity": 0.85
            }
          }, m)), T.includes("ymbol") && (n !== void 0 ? this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: y
            },
            layout: n.layout,
            paint: n.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: y
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "text-halo-blur": 0.5,
              "text-color": "rgba(90, 7, 7, 1)",
              "text-halo-width": 2,
              "text-halo-color": "rgba(255, 255, 255,0.8)"
            }
          }, m)), this.addMenuItem(t);
        else {
          let P = i;
          const I = {};
          y.features.forEach((D) => {
            const k = D.properties[P], $ = k + "-userFieldFilter-" + t;
            k !== null && (I[$] || (T.includes("ine") && (n !== void 0 ? this.map.addLayer({
              id: $,
              type: "line",
              source: {
                type: "geojson",
                data: y
              },
              layout: n.layout,
              paint: n.paint,
              filter: ["==", `${P}`, k]
            }, m) : this.map.addLayer({
              id: $,
              type: "line",
              source: {
                type: "geojson",
                data: y
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${P}`, k],
              paint: {
                "line-color": "black",
                "line-width": 2,
                "line-opacity": 1
              }
            }, m)), T.includes("olygon") && (n !== void 0 ? this.map.addLayer({
              id: $,
              type: "fill",
              source: {
                type: "geojson",
                data: y
              },
              filter: ["==", `${P}`, k],
              layout: n.layout,
              paint: n.paint
            }, m) : this.map.addLayer({
              id: $,
              type: "fill",
              source: {
                type: "geojson",
                data: y
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${P}`, k],
              paint: {
                "fill-color": "blue",
                "fill-opacity": 0.6
              }
            }, m)), T.includes("oint") && (n !== void 0 ? this.map.addLayer({
              id: $,
              type: "circle",
              source: {
                type: "geojson",
                data: y
              },
              filter: ["==", `${P}`, k],
              layout: n.layout,
              paint: n.paint
            }, m) : this.map.addLayer({
              id: $,
              type: "circle",
              source: {
                type: "geojson",
                data: y
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${P}`, k],
              paint: {
                "circle-color": "red",
                "circle-opacity": 0.85
              }
            }, m)), I[$] = !0, this.addMenuItem($)));
          });
        }
      }
    } catch (s) {
      console.error(`Error fetching data: ${s.message}`);
    }
  }
  /**
   * Adds an event listener to the map.
   * @function on
   * @param {string} type - The type of the event.
   * @param {Function} func - The callback function to be executed when the event occurs.
   */
  on(e, t) {
    setTimeout(() => {
      try {
        return this.map.on(e, t);
      } catch (i) {
        console.error(`Error adding event ON listener: ${i.message}`);
      }
    }, 100);
  }
  /**
   * Sets the style of the map.
   * @function setStyle
   * @param {string} style - Name of the map style.
   * @param {Object} [options] - Options for setting the style.
   */
  setStyle(e, t) {
    try {
      t !== void 0 ? this.map.setStyle(e, t) : this.map.setStyle(e), this.map.on("styledata", () => {
        if (window.document.querySelector(".maplibregl-compact-show")) {
          var i = window.document.querySelector(".maplibregl-compact-show");
          i.classList.remove("maplibregl-compact-show");
        }
        this._dealOrto3dStyle(this.map.getStyle().name);
      });
    } catch (i) {
      console.error(`Error setting style: ${i.message}`);
    }
  }
  /**
   * Adds a control to the map with the specified position.
   * @function addControl
   * @param {Object} control - The control to add.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(e, t);
    } catch (i) {
      console.error(`Error adding control: ${i.message}`);
    }
  }
  /**
   * Sets the sky properties of the map.
   * @function setSky
   * @param {Object} options - Options to set the sky properties.
   * @param {string} [options.skyType='gradient'] - Type of sky to set (e.g., 'gradient', 'atmosphere').
   * @param {string} [options.color='lightblue'] - Color of the sky.
   * @param {Number} [options.horizonBlend=0.03] - Blend horizon value.
   * @param {Number} [options.starIntensity=0.5] - Intensity of stars in the sky.
   * @param {Number} [options.sunIntensity=0.1] - Intensity of the sun in the sky.
   * @param {Array<Number>} [options.sunPosition=[0, 0]] - Position of the sun in the sky.
   */
  setSky(e) {
    try {
      e === void 0 && (this.map.style.stylesheet.id.includes("orto") ? e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("mapa_estandard_general") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("icgc_mapa_vissir") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("fosc") ? e = {
        "sky-color": "#232423",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#969996",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#383838"
      } : e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      }), this.map.setSky(e);
    } catch (t) {
      console.error(`Error setting sky properties: ${t.message}`);
    }
  }
  /**
   * Adds a mouse coordinate control to the map.
   * @function addMouseCoordControl
   * @param {Number} options.width - Width control i.
   * @param {Boolean} options.utm - Boolean to show coordinates in UTM.
   * @param {Boolean} options.lonlat - Boolean to show coordinates in Lon Lat.
   * @param {string} [position='bottom-left'] - Position to add the control on the map.
   */
  addMouseCoordControl(e, t = "bottom-left") {
    try {
      this.map.addControl(new Bte(e), t);
    } catch (i) {
      console.error(`Error adding mouse coordinate control: ${i.message}`);
    }
  }
  /**
   * Adds a geolocate control to the map.
   * @function addGeolocateControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addGeolocateControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new Zs.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: !0
        },
        trackUserLocation: !0
      }), t) : this.map.addControl(new Zs.GeolocateControl(e), t);
    } catch (i) {
      console.error(`Error adding geolocate control: ${i.message}`);
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullscreenControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullscreenControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new Zs.FullscreenControl({
        container: HTMLElement
      }), t) : this.map.addControl(new Zs.FullscreenControl(e), t);
    } catch (i) {
      console.error(`Error adding fullscreen control: ${i.message}`);
    }
  }
  /**
   * Adds a layer to the map.
   * @function addLayer
   * @param {Object} layer - Options for the layer to add.
   * @param {string} layerIdOrder - Optional layer Id draw position.
   */
  addLayer(e, t) {
    try {
      this.map.addLayer(e, t);
    } catch (i) {
      console.error(`Error adding layer: ${i.message}`);
    }
  }
  //add maplibre methods
  /**
   * Adds an image to the map.
   * @function addImage
   * @param {string} id - The ID of the image.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The image object to add.
   * @param {Partial<StyleImageMetadata>} options - Optional metadata for the image.
   * @returns {this}
   */
  addImage(e, t, i) {
    try {
      this.map.addImage(e, t, i);
    } catch (n) {
      console.error(`Error adding image: ${n.message}`);
    }
    return this;
  }
  /**
   * Adds a source to the map.
   * @function addSource
   * @param {string} id - The ID of the source.
   * @param {SourceSpecification} source - The source object to add.
   * @returns {this}
   */
  addSource(e, t) {
    try {
      this.map.addSource(e, t);
    } catch (i) {
      console.error(`Error adding source: ${i.message}`);
    }
    return this;
  }
  /**
   * Adds a sprite to the map.
   * @function addSprite
   * @param {string} id - The ID of the sprite.
   * @param {string} url - The URL to load the sprite from.
   * @param {StyleSetterOptions} options - Options object.
   * @returns {this}
   */
  addSprite(e, t, i) {
    try {
      this.map.addSprite(e, t, i);
    } catch (n) {
      console.error(`Error adding sprite: ${n.message}`);
    }
    return this;
  }
  /**
   * Checks if all tiles in the viewport are loaded.
   * @function areTilesLoaded
   * @returns {boolean}
   */
  areTilesLoaded() {
    return this.map.areTilesLoaded();
  }
  /**
   * Calculates the camera position for given bounds.
   * @function cameraForBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {CameraForBoundsOptions} options - Options object.
   * @returns {CenterZoomBearing | undefined}
   */
  cameraForBounds(e, t) {
    return this.map.cameraForBounds(e, t);
  }
  /**
   * Eases the camera to a new position.
   * @function easeTo
   * @param {object} options - Options describing the animation.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  easeTo(e, t) {
    return this.map.easeTo(e, t), this;
  }
  /**
   * Fits the map to the given geographical bounds.
   * @function fitBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitBounds(e, t, i) {
    return this.map.fitBounds(e, t, i), this;
  }
  /**
   * Fits the map to the given screen coordinates.
   * @function fitScreenCoordinates
   * @param {PointLike} p0 - First point on screen, in pixel coordinates.
   * @param {PointLike} p1 - Second point on screen, in pixel coordinates.
   * @param {number} bearing - Desired map bearing at end of animation, in degrees.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitScreenCoordinates(e, t, i, n, s) {
    return this.map.fitScreenCoordinates(e, t, i, n, s), this;
  }
  /**
   * Flies the camera to a new position.
   * @function flyTo
   * @param {FlyToOptions} options - Options describing the flight.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  flyTo(e, t) {
    return this.map.flyTo(e, t), this;
  }
  /**
   * Gets the current bearing of the map.
   * @function getBearing
   * @returns {number}
   */
  getBearing() {
    return this.map.getBearing();
  }
  /**
   * Gets the current geographical bounds of the map.
   * @function getBounds
   * @returns {LngLatBounds}
   */
  getBounds() {
    return this.map.getBounds();
  }
  /**
   * Gets the elevation for the point where the camera is looking.
   * @function getCameraTargetElevation
   * @returns {number}
   */
  getCameraTargetElevation() {
    return this.map.getCameraTargetElevation();
  }
  /**
   * Gets the map's <canvas> element.
   * @function getCanvas
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.map.getCanvas();
  }
  /**
   * Gets the HTML element containing the map's <canvas> element.
   * @function getCanvasContainer
   * @returns {HTMLElement}
   */
  getCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  /**
   * Returns the map's geographical centerpoint.
   * @function getCenter
   * @returns {LngLat} The map's geographical centerpoint.
   */
  getCenter() {
    return this.map.getCenter();
  }
  /**
   * Returns the map's containing HTML element.
   * @function getContainer
   * @returns {HTMLElement} The map's container.
   */
  getContainer() {
    return this.map.getContainer();
  }
  /**
   * Gets the state of a feature.
   * @function getFeatureState
   * @param {FeatureIdentifier} feature - Feature identifier.
   * @returns {any} The state of the feature.
   */
  getFeatureState(e) {
    return this.map.getFeatureState(e);
  }
  /**
   * Returns the filter applied to the specified style layer.
   * @function getFilter
   * @param {string} layerId - The ID of the style layer.
   * @returns {void | FilterSpecification} The layer's filter.
   */
  getFilter(e) {
    return this.map.getFilter(e);
  }
  /**
   * Returns the value of the style's glyphs URL.
   * @function getGlyphs
   * @returns {string} The glyphs Style's glyphs URL.
   */
  getGlyphs() {
    return this.map.getGlyphs();
  }
  /**
   * Returns an image currently available in the map.
   * @function getImage
   * @param {string} id - The ID of the image.
   * @returns {StyleImage} An image in the map with the specified ID.
   */
  getImage(e) {
    return this.map.getImage(e);
  }
  /**
   * Returns the layer with the specified ID in the map's style.
   * @function getLayer
   * @param {string} id - The ID of the layer to get.
   * @returns {StyleLayer} The layer with the specified ID.
   */
  getLayer(e) {
    return this.map.getLayer(e);
  }
  /**
   * Return the ids of all layers currently in the style, including custom layers, in order.
   * @function getLayersOrder
   * @returns {string[]} Ids of layers, in order.
   */
  getLayersOrder() {
    return this.map.getLayersOrder();
  }
  /**
   * Returns the value of a layout property in the specified style layer.
   * @function getLayoutProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of the layout property.
   * @returns {any} The value of the specified layout property.
   */
  getLayoutProperty(e, t) {
    return this.map.getLayoutProperty(e, t);
  }
  /**
   * Returns the value of the light object.
   * @function getLight
   * @returns {LightSpecification} Light properties of the style.
   */
  getLight() {
    return this.map.getLight();
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to.
   * @function getMaxBounds
   * @returns {LngLatBounds} The map's maximum geographical bounds.
   */
  getMaxBounds() {
    return this.map.getMaxBounds();
  }
  /**
   * Returns the map's maximum allowable pitch.
   * @function getMaxPitch
   * @returns {number} The maxPitch.
   */
  getMaxPitch() {
    return this.map.getMaxPitch();
  }
  /**
   * Returns the map's maximum allowable zoom level.
   * @function getMaxZoom
   * @returns {number} The maxZoom.
   */
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  /**
   * Returns the map's minimum allowable pitch.
   * @function getMinPitch
   * @returns {number} The minPitch.
   */
  getMinPitch() {
    return this.map.getMinPitch();
  }
  /**
   * Returns the map's minimum allowable zoom level.
   * @function getMinZoom
   * @returns {number} The minZoom.
   */
  getMinZoom() {
    return this.map.getMinZoom();
  }
  /**
   * Returns the current padding applied around the map viewport.
   * @function getPadding
   * @returns {PaddingOptions} The current padding around the map viewport.
   */
  getPadding() {
    return this.map.getPadding();
  }
  /**
   * Returns the value of a paint property in the specified style layer.
   * @function getPaintProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of a paint property.
   * @returns {unknown} The value of the specified paint property.
   */
  getPaintProperty(e, t) {
    return this.map.getPaintProperty(e, t);
  }
  /**
   * Returns the map's current pitch (tilt).
   * @function getPitch
   * @returns {number} The map's current pitch, measured in degrees away from the plane of the screen.
   */
  getPitch() {
    return this.map.getPitch();
  }
  /**
   * Returns the map's pixel ratio.
   * @function getPixelRatio
   * @returns {number} The pixel ratio.
   */
  getPixelRatio() {
    return this.map.getPixelRatio();
  }
  /**
   * Returns the state of renderWorldCopies.
   * @function getRenderWorldCopies
   * @returns {boolean} The renderWorldCopies.
   */
  getRenderWorldCopies() {
    return this.map.getRenderWorldCopies();
  }
  /**
   * Returns the source with the specified ID in the map's style.
   * @function getSource
   * @param {string} id - The ID of the source to get.
   * @returns {Source} The style source with the specified ID.
   */
  getSource(e) {
    return this.map.getSource(e);
  }
  /**
   * Returns the as-is value of the style's sprite.
   * @function getSprite
   * @returns {object[]} Style's sprite list of id-url pairs.
   */
  getSprite() {
    return this.map.getSprite();
  }
  /**
   * Returns the map's MapLibre style object.
   * @function getStyle
   * @returns {StyleSpecification} The map's style JSON object.
   */
  getStyle() {
    return this.map.getStyle();
  }
  /**
   * Get the terrain-options if terrain is loaded.
   * @function getTerrain
   * @returns {TerrainSpecification} The TerrainSpecification passed to setTerrain.
   */
  getTerrain() {
    return this.map.getTerrain();
  }
  //  Function getZoom()
  /**
   * Returns the map's current zoom level.
   * @function getZoom
   * @returns {number} The map's current zoom level.
   */
  getZoom() {
    return this.map.getZoom();
  }
  //  Function hasControl()
  /**
   * Checks if a control exists on the map.
   * @function hasControl
   * @param {IControl} control - The IControl to check.
   * @returns {boolean} true if map contains control.
   */
  hasControl(e) {
    return this.map.hasControl(e);
  }
  //  Function hasImage()
  /**
   * Check whether or not an image with a specific ID exists in the style.
   * @function hasImage
   * @param {string} id - The ID of the image.
   * @returns {boolean} A Boolean indicating whether the image exists.
   */
  hasImage(e) {
    return this.map.hasImage(e);
  }
  //  Function isMoving()
  /**
   * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
   * @function isMoving
   * @returns {boolean} true if the map is moving.
   */
  isMoving() {
    return this.map.isMoving();
  }
  //  Function isRotating()
  /**
   * Returns true if the map is rotating due to a camera animation or user gesture.
   * @function isRotating
   * @returns {boolean} true if the map is rotating.
   */
  isRotating() {
    return this.map.isRotating();
  }
  //  Function isSourceLoaded()
  /**
   * Returns a Boolean indicating whether the source is loaded.
   * @function isSourceLoaded
   * @param {string} id - The ID of the source to be checked.
   * @returns {boolean} A Boolean indicating whether the source is loaded.
   */
  isSourceLoaded(e) {
    return this.map.isSourceLoaded(e);
  }
  //  Function isStyleLoaded()
  /**
   * Returns a Boolean indicating whether the map's style is fully loaded.
   * @function isStyleLoaded
   * @returns {boolean | void} A Boolean indicating whether the style is fully loaded.
   */
  isStyleLoaded() {
    return this.map.isStyleLoaded();
  }
  //  Function isZooming()
  /**
   * Returns true if the map is zooming due to a camera animation or user gesture.
   * @function isZooming
   * @returns {boolean} true if the map is zooming.
   */
  isZooming() {
    return this.map.isZooming();
  }
  //  Function jumpTo()
  /**
   * Changes any combination of center, zoom, bearing, and pitch, without an animated transition.
   * @function jumpTo
   * @param {JumpToOptions} options - Options object
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  jumpTo(e, t) {
    return this.map.jumpTo(e, t);
  }
  //  Function listImages()
  /**
   * Returns an Array of strings containing the IDs of all images currently available in the map.
   * @function listImages
   * @returns {string[]} An Array of strings containing the names of all sprites/images currently available in the map.
   */
  listImages() {
    return this.map.listImages();
  }
  //  Function listens()
  /**
   * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
   * @function listens
   * @param {string} type - The event type.
   * @returns {boolean} true if there is at least one registered listener for specified event type, false otherwise.
   */
  listens(e) {
    return this.map.listens(e);
  }
  //  Function loadImage()
  /**
   * Load an image from an external URL to be used with Map#addImage.
   * @function loadImage
   * @param {string} url - The URL of the image file. Image file must be in png, webp, or jpg format.
   * @returns {Promise<GetResourceResponse<ImageBitmap | HTMLImageElement>>} A promise that is resolved when the image is loaded.
   */
  loadImage(e) {
    return this.map.loadImage(e);
  }
  //  Function loaded()
  /**
   * Returns a Boolean indicating whether the map is fully loaded.
   * @function loaded
   * @returns {boolean} A Boolean indicating whether the map is fully loaded.
   */
  loaded() {
    return this.map.loaded();
  }
  //  Function new LngLatBounds()
  /**
   * Constructs a new LngLatBounds object representing a geographical bounding box.
   * @class LngLatBounds
   * @constructor
   * @param {LngLatLike} [sw] - The southwest corner of the bounding box. Can be specified as an array of 4 numbers in the order of west, south, east, north, or an array of 2 LngLatLike representing [sw,ne].
   * @param {LngLatLike} [ne] - The northeast corner of the bounding box.
   */
  LngLatBounds(e, t) {
    return new Zs.LngLatBounds(e, t);
  }
  //  Function addProtocol()
  /**
   * Adds a custom load resource function that will be called when using a URL that starts with a custom URL schema.
   * @function addProtocol
   * @param {string} customProtocol - The protocol to hook, for example 'custom'.
   * @param {AddProtocolAction} loadFn - The function to use when trying to fetch a resource specified by the customProtocol.
   * @returns {void}
   */
  addProtocol(e, t) {
    return this.map.addProtocol(e, t);
  }
  //  Function moveLayer()
  /**
   * Moves a layer to a different z-position.
   * @function moveLayer
   * @param {string} id - The ID of the layer to move.
   * @param {string} [beforeId] - The ID of an existing layer to insert the new layer before.
   * @returns {this}
   */
  moveLayer(e, t) {
    return this.map.moveLayer(e, t);
  }
  //  Function panBy()
  /**
   * Pans the map by the specified offset.
   * @function panBy
   * @param {PointLike} offset - x and y coordinates by which to pan the map.
   * @param {AnimationOptions} [options] - Options object.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panBy(e, t, i) {
    return this.map.panBy(e, t, i);
  }
  //  Function panTo()
  /**
   * Pans the map to the specified location with an animated transition.
   * @function panTo
   * @param {LngLatLike} lnglat - The location to pan the map to.
   * @param {AnimationOptions} [options] - Options describing the destination and animation of the transition.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panTo(e, t, i) {
    return this.map.panTo(e, t, i);
  }
  //  Function project()
  /**
   * Returns a Point representing pixel coordinates, relative to the map's container, that correspond to the specified geographical location.
   * @function project
   * @param {LngLatLike} lnglat - The geographical location to project.
   * @returns {Point} The Point corresponding to lnglat, relative to the map's container.
   */
  project(e) {
    return this.map.project(e);
  }
  //  Function queryRenderedFeatures()
  /**
   * Queries rendered features within a specified geometry or bounding box.
   * @function queryRenderedFeatures
   * @param {GeometryLike | Array | Object} [geometryOrOptions] - The geometry or options for the query.
   * @param {Object} [options] - Options for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features that intersect the query geometry.
   */
  queryRenderedFeatures(e, t) {
    return this.map.queryRenderedFeatures(e, t);
  }
  //  Function querySourceFeatures()
  /**
   * Queries source features within a specified source.
   * @function querySourceFeatures
   * @param {string} sourceId - The ID of the source to query.
   * @param {Object} parameters - Parameters for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features in the source that satisfy the query parameters.
   */
  querySourceFeatures(e, t) {
    return this.map.querySourceFeatures(e, t);
  }
  //  Function queryTerrainElevation()
  /**
   * Queries the terrain elevation at a specified geographical location.
   * @function queryTerrainElevation
   * @param {LngLatLike} lngLatLike - The geographical location to query.
   * @returns {number} The elevation (in meters) at the specified location.
   */
  queryTerrainElevation(e) {
    return this.map.queryTerrainElevation(e);
  }
  //  Function redraw()
  /**
   * Redraws the map.
   * @function redraw
   * @returns {this}
   */
  redraw() {
    return this.map.redraw();
  }
  //  Function remove()
  /**
   * Removes the map from the DOM.
   * @function remove
   * @returns {this}
   */
  remove() {
    return this.map.remove();
  }
  //  Function removeControl()
  /**
   * Removes a control from the map.
   * @function removeControl
   * @param {Object} control - The control to remove.
   * @returns {this}
   */
  removeControl(e) {
    return this.map.removeControl(e);
  }
  //  Function removeFeatureState()
  /**
   * Removes the state of a feature.
   * @function removeFeatureState
   * @param {Object} target - The target feature.
   * @param {string} [key] - The key of the state to remove.
   * @returns {this}
   */
  removeFeatureState(e, t) {
    return this.map.removeFeatureState(e, t);
  }
  //  Function removeImage()
  /**
   * Removes an image from the style's sprite.
   * @function removeImage
   * @param {string} id - The ID of the image to remove.
   * @returns {this}
   */
  removeImage(e) {
    return this.map.removeImage(e);
  }
  /**
   * Removes a layer from the map.
   * @function removeLayer
   * @param {string} idLayer - Identifier of the layer to remove.
   */
  removeLayer(e) {
    try {
      this.map.removeLayer(e);
    } catch (t) {
      console.error(`Error removing layer: ${t.message}`);
    }
  }
  /**
   * Removes a source from the map.
   * @function removeSource
   * @param {string} idLayer - Identifier of the source to remove.
   */
  removeSource(e) {
    try {
      this.map.removeSource(e);
    } catch (t) {
      console.error(`Error removing source: ${t.message}`);
    }
  }
  //  Function removeSprite()
  /**
   * Removes a sprite from the style.
   * @function removeSprite
   * @param {string} id - The ID of the sprite to remove.
   * @returns {this}
   */
  removeSprite(e) {
    return this.map.removeSprite(e);
  }
  //  Function resetNorth()
  /**
   * Resets the map orientation so that north is up.
   * @function resetNorth
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorth(e, t) {
    return this.map.resetNorth(e, t);
  }
  //  Function resetNorthPitch()
  /**
   * Resets the map orientation so that north is up and pitch is set to 0°.
   * @function resetNorthPitch
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorthPitch(e, t) {
    return this.map.resetNorthPitch(e, t);
  }
  //  Function resize()
  /**
   * Resizes the map to fit its container.
   * @function resize
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resize(e) {
    return this.map.resize(e);
  }
  //  Function rotateTo()
  /**
   * Rotates the map to the specified bearing with an animated transition.
   * @function rotateTo
   * @param {number} bearing - The desired bearing (in degrees) to rotate the map to.
   * @param {Object} [options] - Options for the rotation.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  rotateTo(e, t, i) {
    return this.map.rotateTo(e, t, i);
  }
  //  Function setBearing()
  /**
   * Sets the map's bearing with an optional animated transition.
   * @function setBearing
   * @param {number} bearing - The desired bearing (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setBearing(e, t) {
    return this.map.setBearing(e, t);
  }
  //  Function setCenter()
  /**
   * Sets the map's center coordinates with an optional animated transition.
   * @function setCenter
   * @param {LngLatLike} center - The desired center coordinates to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setCenter(e, t) {
    return this.map.setCenter(e, t);
  }
  //  Function setEventedParent()
  /**
   * Sets the parent of the map's event emitter.
   * @function setEventedParent
   * @param {any} [parent] - The parent object to set for the event emitter.
   * @param {any} [data] - Additional data to pass to the parent.
   * @returns {this}
   */
  setEventedParent(e, t) {
    return this.map.setEventedParent(e, t);
  }
  //  Function setFeatureState()
  /**
   * Sets the state of a feature.
   * @function setFeatureState
   * @param {Object} feature - The feature to set the state for.
   * @param {Object} state - The state object to set for the feature.
   * @returns {this}
   */
  setFeatureState(e, t) {
    return this.map.setFeatureState(e, t);
  }
  //  Function setFilter()
  /**
   * Sets the filter for a specified layer.
   * @function setFilter
   * @param {string} layerId - The ID of the layer to set the filter for.
   * @param {Array} [filter] - The filter array to apply to the layer.
   * @param {Object} [options] - Options for the filter.
   * @returns {this}
   */
  setFilter(e, t, i) {
    return this.map.setFilter(e, t, i);
  }
  //  Function setGlyphs()
  /**
   * Sets the glyphs for the map's style.
   * @function setGlyphs
   * @param {string} glyphsUrl - The URL to the glyphs.
   * @param {Object} [options] - Options for setting the glyphs.
   * @returns {this}
   */
  setGlyphs(e, t) {
    return this.map.setGlyphs(e, t);
  }
  //  Function setLayerZoomRange()
  /**
   * Sets the zoom range for a specified layer.
   * @function setLayerZoomRange
   * @param {string} layerId - The ID of the layer to set the zoom range for.
   * @param {number} minzoom - The minimum zoom level for the layer.
   * @param {number} maxzoom - The maximum zoom level for the layer.
   * @returns {this}
   */
  setLayerZoomRange(e, t, i) {
    return this.map.setLayerZoomRange(e, t, i);
  }
  //  Function setLayoutProperty()
  /**
   * Sets a layout property for a specified layer.
   * @function setLayoutProperty
   * @param {string} layerId - The ID of the layer to set the layout property for.
   * @param {string} name - The name of the layout property to set.
   * @param {any} value - The value to set for the layout property.
   * @param {Object} [options] - Options for setting the layout property.
   * @returns {this}
   */
  setLayoutProperty(e, t, i, n) {
    return this.map.setLayoutProperty(e, t, i, n);
  }
  //  Function setLight()
  /**
   * Sets the light for the map's style.
   * @function setLight
   * @param {Object} light - The light object to set for the map.
   * @param {Object} [options] - Options for setting the light.
   * @returns {this}
   */
  setLight(e, t) {
    return this.map.setLight(e, t);
  }
  //  Function setMaxBounds()
  /**
   * Sets the maximum bounds for the map.
   * @function setMaxBounds
   * @param {Array} bounds - The maximum bounds for the map.
   * @returns {this}
   */
  setMaxBounds(e) {
    return this.map.setMaxBounds(e);
  }
  //  Function setMaxPitch()
  /**
   * Sets the maximum pitch for the map.
   * @function setMaxPitch
   * @param {number} maxPitch - The maximum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMaxPitch(e) {
    return this.map.setMaxPitch(e);
  }
  //  Function setMaxZoom()
  /**
   * Sets the maximum zoom level for the map.
   * @function setMaxZoom
   * @param {number} maxZoom - The maximum zoom level for the map.
   * @returns {this}
   */
  setMaxZoom(e) {
    return this.map.setMaxZoom(e);
  }
  //  Function setMinPitch()
  /**
   * Sets the minimum pitch for the map.
   * @function setMinPitch
   * @param {number} minPitch - The minimum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMinPitch(e) {
    return this.map.setMinPitch(e);
  }
  //  Function setMinZoom()
  /**
   * Sets the minimum zoom level for the map.
   * @function setMinZoom
   * @param {number} minZoom - The minimum zoom level for the map.
   * @returns {this}
   */
  setMinZoom(e) {
    return this.map.setMinZoom(e);
  }
  //  Function setPadding()
  /**
   * Sets padding for the map's container.
   * @function setPadding
   * @param {Object} padding - The padding object to set for the map's container.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPadding(e, t) {
    return this.map.setPadding(e, t);
  }
  //  Function setPaintProperty()
  /**
   * Sets a paint property for a specified layer.
   * @function setPaintProperty
   * @param {string} layerId - The ID of the layer to set the paint property for.
   * @param {string} name - The name of the paint property to set.
   * @param {any} value - The value to set for the paint property.
   * @param {Object} [options] - Options for setting the paint property.
   * @returns {this}
   */
  setPaintProperty(e, t, i, n) {
    return this.map.setPaintProperty(e, t, i, n);
  }
  //  Function setPitch()
  /**
   * Sets the map's pitch angle with an optional animated transition.
   * @function setPitch
   * @param {number} pitch - The desired pitch angle (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPitch(e, t) {
    return this.map.setPitch(e, t);
  }
  //  Function setPixelRatio()
  /**
   * Sets the pixel ratio for the map.
   * @function setPixelRatio
   * @param {number} pixelRatio - The desired pixel ratio for the map.
   * @returns {this}
   */
  setPixelRatio(e) {
    return this.map.setPixelRatio(e);
  }
  //  Function setRenderWorldCopies()
  /**
   * Sets whether the map should render world copies when the center longitude is greater than or less than ±180 degrees.
   * @function setRenderWorldCopies
   * @param {boolean} renderWorldCopies - A boolean indicating whether to render world copies.
   * @returns {this}
   */
  setRenderWorldCopies(e) {
    return this.map.setRenderWorldCopies(e);
  }
  //  Function setSprite()
  /**
   * Sets the sprite for the map's style.
   * @function setSprite
   * @param {string} spriteUrl - The URL to the sprite.
   * @param {Object} [options] - Options for setting the sprite.
   * @returns {this}
   */
  setSprite(e, t) {
    return this.map.setSprite(e, t);
  }
  //  Function setTerrain()
  /**
   * Loads a 3D terrain mesh based on a "raster-dem" source.
   * @function setTerrain
   * @param {TerrainSpecification} options - Options object specifying the terrain source.
   * @returns {this}
   */
  setTerrain(e) {
    return this.map.setTerrain(e);
  }
  //  Function setTransformRequest()
  /**
   * Updates the requestManager's transform request with a new function.
   * @function setTransformRequest
   * @param {RequestTransformFunction} transformRequest - The callback function to update the transform request.
   * @returns {this}
   */
  setTransformRequest(e) {
    return this.map.setTransformRequest(e);
  }
  //  Function setZoom()
  /**
   * Sets the map's zoom level.
   * @function setZoom
   * @param {number} zoom - The zoom level to set (0-20).
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setZoom(e, t) {
    return this.map.setZoom(e, t);
  }
  //  Function snapToNorth()
  /**
   * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it.
   * @function snapToNorth
   * @param {Object} [options] - Options for snapping to north.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  snapToNorth(e, t) {
    return this.map.snapToNorth(e, t);
  }
  //  Function stop()
  /**
   * Stops any animated transition underway.
   * @function stop
   * @returns {this}
   */
  stop() {
    return this.map.stop();
  }
  //  Function triggerRepaint()
  /**
   * Triggers the rendering of a single frame.
   * @function triggerRepaint
   * @returns {void}
   */
  triggerRepaint() {
    return this.map.triggerRepaint();
  }
  //  Function unproject()
  /**
   * Returns geographical coordinates corresponding to the specified pixel coordinates.
   * @function unproject
   * @param {PointLike} point - The pixel coordinates to unproject.
   * @returns {LngLat} The geographical coordinates corresponding to the specified pixel coordinates.
   */
  unproject(e) {
    return this.map.unproject(e);
  }
  //  Function updateImage()
  /**
   * Updates an existing image in the style's sprite.
   * @function updateImage
   * @param {string} id - The ID of the image to update.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The new image data.
   * @returns {this}
   */
  updateImage(e, t) {
    return this.map.updateImage(e, t);
  }
  //  Function zoomIn()
  /**
   * Increases the map's zoom level by 1.
   * @function zoomIn
   * @param {Object} [options] - Options for zooming in.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomIn(e, t) {
    return this.map.zoomIn(e, t);
  }
  //  Function zoomOut()
  /**
   * Decreases the map's zoom level by 1.
   * @function zoomOut
   * @param {Object} [options] - Options for zooming out.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomOut(e, t) {
    return this.map.zoomOut(e, t);
  }
  //  Function zoomTo()
  /**
   * Zooms the map to the specified zoom level with an animated transition.
   * @function zoomTo
   * @param {number} zoom - The zoom level to transition to.
   * @param {Object} [options] - Options for zooming to.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomTo(e, t, i) {
    return this.map.zoomTo(e, t, i);
  }
  // end maplibre methods
  /**
   * Adds a GeoJSON layer to the map.
   * @function addLayerGeoJSON
   * @param {Object} layer - Options for the GeoJSON layer to add.
   * @param {string} layer.id - Unique identifier for the layer.
   * @param {Object} layer.data - GeoJSON data for the layer.
   * @param {string} layer.type - Map layer type (e.g., 'symbol', 'circle', 'fill').   *
   * @param {Object} layer.layout - Layer layout configuration.
   * @param {Object} layer.paint - Layer paint configuration.
   * @param {string} layerPosition - Position of the layer: 'top', below 'labels' or below 'lines'.
   */
  addLayerGeoJSON(e, t) {
    try {
      let i = this._dealOrderLayer(t);
      this.map.addSource(`${e.id}`, {
        type: "geojson",
        data: e.data
      }), this.map.addLayer({
        id: `${e.id}-layerIcgcMap`,
        type: e.type,
        source: `${e.id}`,
        layout: e.layout,
        paint: e.paint
      }, i);
    } catch (i) {
      console.error(`Error adding GeoJSON layer: ${i.message}`);
    }
  }
  /**
   * Adds a WMS layer to the map.
   * @function addLayerWMS
   
   * @param {string[]} tiles - Tiles for the raster layer.
   * @param {string} idLayer - Unique identifier for the layer.
   * @param {Object} options - Options of the layer: layout, paint and layerPosition.
   */
  addLayerWMS(e, t, i) {
    try {
      let n = this._dealOrderLayer(i.layerPosition);
      i ? (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, n), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        layout: i.layout,
        paint: i.paint
      }, n)) : (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, n), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        paint: {}
      }, n));
    } catch (n) {
      console.error(`Error adding WMS layer: ${n.message}`);
    }
  }
  /**
   * Adds a logo to the map.
   * @function addLogo
   * @param {Object} options - Options for the logo to add.
   * @param {string} options.id - Unique identifier for the logo.
   * @param {string} options.url - URL of the logo image.
   * @param {string} options.href - URL to navigate to when the logo is clicked.
   * @param {string} options.height - Height of the logo.
   */
  addLogo(e) {
    try {
      let t = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "logos", t.appendChild(i);
      const n = document.createElement("img");
      n.src = e.url, n.style.height = e.height;
      const s = document.getElementById("logos"), c = document.createElement("a");
      c.id = e.id, c.href = e.href, c.target = "_blank", c.style.position = "relative", c.style.bottom = "1px", c.appendChild(n), s.appendChild(c);
    } catch (t) {
      console.error(`Error adding logo: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemapsICGC
   * @param {Object[]} basesArray - Array of base layer objects.
   */
  addBasemapsICGC(e) {
    try {
      const t = (c) => {
        this.map.setStyle(c);
      };
      let i = document.getElementById("map"), n;
      n = document.createElement("div"), n.id = "basemap-group", n.classList.add = "filter-group", i.appendChild(n);
      const s = document.getElementById("basemap-group");
      for (const c of e)
        for (const o of Object.keys(rn.baseStyles)) {
          const d = rn.baseStyles[o];
          if (c === d.url) {
            const m = document.createElement("div");
            m.className = "basemap-item", m.title = d.key, m.style.backgroundImage = `url('${d.image}')`, s.appendChild(m), m.addEventListener("click", () => t(d.url));
          }
        }
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemaps
   * @param {Object[]} baseLayers - Array of base layer objects.
   * @param {string} baseLayers.label - Label for the base layer.
   * @param {string} baseLayers.image - URL of the image representing the base layer.
   * @param {string} baseLayers.url - URL of the base layer style.
   */
  addBasemaps(e) {
    try {
      const t = (c) => {
        map.setStyle(c.url);
      };
      let i = document.getElementById("map"), n;
      n = document.createElement("div"), n.id = "basemap-group", n.classList.add = "basemap-group", i.appendChild(n);
      const s = document.getElementById("basemap-group");
      e.forEach((c) => {
        const o = document.createElement("div");
        o.className = "basemap-item", o.title = c.label, o.style.backgroundImage = `url('${c.image}')`, s.appendChild(o), o.addEventListener("click", () => t(c));
      });
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds feature query function to a layer.
   * @function addFeatureQuery
   * @param {string} idLayer - name of the layer
   * @param {objetc} queryFields - optional indications for the popup
   * @param {objetc} popupStyle - optional indications for the popup style
   */
  addFeatureQuery(e, t, i) {
    try {
      let n;
      this.map.on("mouseenter", e, () => {
        this.map.getCanvas().style.cursor = "pointer";
      }), this.map.on("mouseleave", e, () => {
        this.map.getCanvas().style.cursor = "";
      }), this.map.on("click", (s) => {
        let c = this.map.queryRenderedFeatures(s.point);
        if (c && c[0].source.includes(e)) {
          let o = [s.lngLat.lng, s.lngLat.lat];
          if (t !== void 0 && t.length > 0 && t !== "all") {
            if (t !== null) {
              let d = "";
              t.forEach((m) => {
                let y = c[0].properties[m];
                d = d + `<h4>${y}</h4>`;
              }), n = d, this.addPopup(o, n, i);
            }
          } else {
            let d = "";
            for (const m in c[0].properties)
              d += "<b>" + m + "</b>:" + c[0].properties[m] + "<br>";
            n = d, this.addPopup(o, n, i);
          }
        }
      });
    } catch (n) {
      console.error(`Error adding feature query: ${n.message}`);
    }
  }
  /**
   * Adds a scale control to the map.
   *  * @function addScaleControl
   * @param {Object} options - Options for configuring the scale control.
   * @param {string} position - The position on the map to place the scale control (e.g., 'top-left', 'bottom-right').
   */
  addScaleControl(e, t) {
    try {
      var i = new Zs.ScaleControl(e);
      this.map.addControl(i, t);
    } catch (n) {
      console.error(`Error adding scale: ${n.message}`);
    }
  }
  /**
   * Adds an export control to the map with the provided options and position.
   * @function addExportControl
   * @param {Object|string} options - Options for the export control or position if provided as a string.
   * @param {string} [position] - Position to place the export control (e.g., 'top-right').
   */
  addExportControl(e, t) {
    try {
      typeof e == "string" && (t = e, e = void 0), e === void 0 && (e = {
        PageSize: Uf.A4,
        PageOrientation: Pg.Landscape,
        Format: ih.PNG,
        DPI: Qv[300],
        Crosshair: !0,
        PrintableArea: !0,
        Local: "ca"
      }, t = "top-right"), this.map.addControl(new rte(e), t);
    } catch (i) {
      console.error(`Error adding export control: ${i.message}`);
    }
  }
  /**
   * Adds a marker to the map.
   * @function addMarker
   * @param {Object} options - Options for the marker to add.
   * @param {string} options.text - Text content for the marker popup.
   * @param {Object} options.options - Marker options.
   * @param {LngLatLike} options.coord - Coordinates for placing the marker.
   * @param {Object} options.textOffset - Text offset for the marker popup.
   * @returns {Object} - Instance of the added marker.
   */
  addMarker(e) {
    try {
      let t, i;
      return e.text === void 0 ? t = new Zs.Marker(e.options).setLngLat(e.coord).addTo(this.map) : (i = new Zs.Popup({
        offset: e.textOffset
      }).setHTML(e.text), t = new Zs.Marker(e.options).setLngLat(e.coord).setPopup(i).addTo(this.map)), t;
    } catch (t) {
      return console.error(`Error adding marker: ${t.message}`), null;
    }
  }
  /**
   * Adds a popup to the map.
   * @function addPopup
   * @param {Object} options - Options for the popup to add.
   * @param {LngLatLike} coord - Coordinates for placing the popup.
   * @param {string} text - HTML content for the popup.
   * @param {string} popupStyle - css content for the popup style.
   * @returns {Object} - Instance of the added popup.
   */
  addPopup(e, t, i) {
    try {
      return i.image === void 0 ? new Zs.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${i.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
 ${t}
          </div>
          <div class="popupBottomDown">
          </div>
          </div>
        </div>
      `).addTo(this.map) : new Zs.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${i.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
          ${t}
          </div>
          <div class="popupBottomDown">
             <img style="  padding: 8px;  width: 50%;" src=${i.image} />
          </div>
          </div>
        </div>
      `).addTo(this.map);
    } catch (n) {
      return console.error(`Error adding popup: ${n.message}`), null;
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullScreen
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullScreen(e) {
    try {
      e === void 0 && (e = "top-right"), this.map.addControl(new Zs.FullscreenControl(), e);
    } catch (t) {
      console.error(`Error adding fullscreen control: ${t.message}`);
    }
  }
  /**
   * Adds a menu item with a checkbox for controlling the visibility of a layer on the map.
   * @function addMenuItem
   * @param {string} name - The name of the layer corresponding to the menu item.
   */
  addMenuItem(e) {
    try {
      let t;
      if (e.includes("-userFieldFilter-") ? t = e.split("-userFieldFilter-")[0] : t = e, e.length > 0) {
        const i = document.getElementById("menu-group"), n = document.createElement("input");
        n.type = "checkbox", n.id = e, n.checked = !0, i.appendChild(n);
        const s = document.createElement("label");
        s.setAttribute("for", e), s.textContent = t, i.appendChild(s), n.addEventListener("change", (c) => {
          this.map.setLayoutProperty(e, "visibility", c.target.checked ? "visible" : "none");
        });
      }
    } catch (t) {
      console.error(`Error adding menu item: ${t.message}`);
    }
  }
  /**
   * Adds a layer tree to the map.
   * @function addLayerTree
   * @param {Object} options - Options for the layer tree to add.
   * @param {Object} options.features - Features for the layer tree.
   * @param {string} options.id - Unique identifier for the layer tree.
   * @param {string} options.type - Type of layer tree ('geojson', 'raster', etc.).
   */
  addLayerTree(e) {
    try {
      let t = e.features, i = document.getElementById("map"), n = document.createElement("nav");
      n.id = "filter-group", i.appendChild(n);
      const s = document.getElementById("filter-group");
      this.map.addSource(`${e.id}`, {
        type: e.type,
        data: t
      }), t.features.forEach((c) => {
        const o = c.properties.icon, d = `poi-${o}`;
        if (!this.map.getLayer(d)) {
          this.map.addLayer({
            id: d,
            type: "circle",
            source: `${e.id}`,
            paint: {
              "circle-radius": 6,
              "circle-color": "#B42222"
            },
            filter: ["==", "icon", o]
          }, this._firstSymbolLayer());
          const m = document.createElement("input");
          m.type = "checkbox", m.id = d, m.checked = !0, s.appendChild(m);
          const y = document.createElement("label");
          y.setAttribute("for", d), y.textContent = o, s.appendChild(y), m.addEventListener("change", (T) => {
            this.map.setLayoutProperty(d, "visibility", T.target.checked ? "visible" : "none");
          });
        }
      });
    } catch (t) {
      console.error(`Error adding layer tree: ${t.message}`);
    }
  }
  /**
   * Creates a navigation control with the provided options.
   * @function createNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   * @returns {Object} - Instance of the created navigation control.
   */
  createNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new Zs.NavigationControl(e), t);
    } catch (i) {
      return console.error(`Error creating navigation control: ${i.message}`), null;
    }
  }
  /**
   * Adds a navigation control to the map with the provided options.
   * @function addNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new Zs.NavigationControl(e), t);
    } catch (i) {
      console.error(`Error adding navigation control: ${i.message}`);
    }
  }
  /**
   * Adds an attribution control to the map with the provided options.
   * @function addAttributionControl
   * @param {Object} options - Options for the attribution control.
   * @param {string} [position='bottom-right'] - Position to add the control on the map.
   */
  addAttributionControl(e, t) {
    try {
      this.map.addControl(new Zs.AttributionControl(e), t);
    } catch (i) {
      console.error(`Error adding attribution control: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC image layer to the map based on the specified name and year.
   * @function addImageLayerICGC
   * @param {string} url - The url of the  layer.
   * @param {string} idLayer - The user id for the  layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   */
  addImageLayerICGC(e, t, i) {
    try {
      let n = null, s, c;
      i ? (c = i, s = i.layerPosition) : c = {
        type: "raster",
        layout: {
          visibility: "visible"
        },
        paint: {
          "raster-opacity": 1
        },
        layerPosition: D_
      }, n = this._findImageType(e, as.Orto, as.VectorAdmin, as.WMS, as.Vector), n || console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
      let o = {
        id: t,
        tiles: e
      };
      this.addLayerWMS(e, t, c);
    } catch (n) {
      console.error(`Error adding ICGC image layer: ${n.message}`);
    }
  }
  /**
   * Adds an ICGC vector layer to the map based on the specified name and year.
   * @function addVectorLayerICGC
   * @param {string} url - The url of the vector layer.
   * @param {string} idLayer - The user id for the vector layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   *
   */
  async addVectorLayerICGC(e, t, i) {
    try {
      let {
        type: n = "line",
        layerPosition: s = D_,
        layoutOptions: c = {
          visibility: "visible"
        },
        paintOption: o
      } = i || {}, d = this._dealOrderLayer(s);
      if (!e) {
        console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
        return;
      }
      if (e.includes("https")) {
        let m = this._getKeyByUrlVector(e);
        this.map.addSource(m, {
          type: "vector",
          url: e
        });
        let y = {
          id: m,
          type: "fill",
          source: m,
          "source-layer": "cobertes",
          maxzoom: 18,
          layout: i.layout,
          paint: die.cobertesSol
        };
        if (m === "cobertes2018" && this.map.addLayer(y, d), c.visibility === "visible") {
          let T = this._getLegendByName(m);
          this.addLegend(T, m);
        }
      } else {
        let m = t;
        this.map.addSource(m, {
          type: "vector",
          url: rn.limitsUrl
        });
        let y = {
          id: t,
          type: n,
          source: m,
          "source-layer": e,
          layout: i.layout,
          paint: i.paint || {}
        };
        n === "fill" || n === "polygon" ? y.paint = o || {
          "fill-color": "#0000FF",
          "fill-opacity": 0
        } : n === "line" && (y.paint = o || {
          "line-color": "#4832a8",
          "line-opacity": 1,
          "line-width": 1
        }), this.map.addLayer(y, d);
      }
    } catch (n) {
      console.error(`Error adding ICGC vector layer: ${n.message}`);
    }
  }
  /**
   * Adds an ICGC FGB layer to the map based on the specified name and year.
   * @function addFGBLayerICGC
   * @param {string} url - The url of the FGB layer.
   * @param {string} idLayer - Id for the layer.
   * @param {object} options - Paint option for the layer
   *
   */
  async addFGBLayerICGC(e, t, i) {
    try {
      i || (i.layout = {
        visibility: !0
      }, i.paint = {
        "line-color": "#4832a8",
        "line-opacity": 1,
        "line-width": 1
      }, i.type = "lines", i.layerPosition = "labels");
      let n = this._dealOrderLayer(i.layerPosition);
      const s = await fetch(e), c = {
        type: "FeatureCollection",
        features: []
      };
      for await (const d of XA(s.body)) c.features.push(d);
      let o = t;
      this.map.addSource(o, {
        type: "geojson",
        data: c
      }), e.includes("text") ? this.map.addLayer({
        id: t,
        type: "symbol",
        source: o,
        layout: {
          "text-letter-spacing": 0.1,
          "text-size": {
            base: 1.2,
            stops: [[8, 0], [12, 14], [15, 15]]
          },
          "text-font": ["FiraSans-Regular"],
          "text-field": ["get", "NOM_AC"],
          "text-transform": "none",
          "text-max-width": 25,
          visibility: i.layout.visibility,
          "text-justify": "right",
          "text-anchor": "top",
          "text-allow-overlap": !1,
          "symbol-spacing": 2,
          "text-line-height": 1
        },
        paint: {
          "text-halo-blur": 0.5,
          "text-color": "rgba(90, 7, 7, 1)",
          "text-halo-width": 2,
          "text-halo-color": "rgba(255, 255, 255,0.8)"
        }
      }, n) : this.map.addLayer({
        id: t,
        type: i.type,
        source: o,
        layout: i.layout,
        paint: i.paint
      }, n);
    } catch (n) {
      console.error(`Error adding ICGC FGB layer: ${n.message}`);
    }
  }
  /**
   * Adds 3D terrain to the map using hillshade.
   * @function addTerrainICGC
   * @param {string} url - dataset url of the terrain
   * @param {string} controlPosition - Position to add the control on the map.
   */
  addTerrainICGC(e, t) {
    try {
      let i;
      for (const s in Zd)
        if (Zd.hasOwnProperty(s)) {
          const c = Zd[s];
          c === e && (i = c);
        }
      let n = i;
      this.getSource("terrainICGC") !== void 0 && (this.getStyle().layers.forEach((c) => {
        c.source === "terrainICGC" && this.removeLayer(c.id);
      }), this.removeSource("terrainICGC")), this.getSource("terrainICGC") === void 0 && (e.includes("terrarium") ? this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [n],
        tileSize: 512,
        encoding: "terrarium",
        maxzoom: 16
      }) : this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [n],
        tileSize: 256,
        maxzoom: 14,
        minzoom: 7
      })), this.map.setTerrain({
        source: "terrainICGC",
        exaggeration: 1.5
      }), t == null || this.map.addControl(new WB({
        pitch: 90,
        bearing: null,
        minpitchzoom: null
      }), t);
    } catch (i) {
      console.error(`Error adding 3D terrain: ${i.message}`);
    }
  }
  /**
   * Add image legend.
   * @function addLegend
   * @param {string} url - image legend url.
   * @param {string} idLayer - layer's name.
   */
  addLegend(e, t) {
    try {
      this.map.addControl(new Pte({
        url: e,
        idLayer: t
      }));
    } catch (i) {
      console.error(`Error adding legend: ${i.message}`);
    }
  }
  //Internal methods
  /**
   * Finds the type of image based on the provided URL and specified vectors.
   * @function _findImageType
   * @param {string} url - The URL of the image to find the type for.
   * @param {Object} var1 - The first vector object containing key-value pairs.
   * @param {Object} var2 - The second vector object containing key-value pairs.
   * @param {Object} var3 - The third vector object containing key-value pairs.
   * @param {Object} var4 - The fourth vector object containing key-value pairs.
   * @returns {string|null} - The type of image if found, otherwise null.
   */
  _findImageType(e, t, i, n, s) {
    const c = [t, i, n, s];
    for (const o of c)
      for (const [d, m] of Object.entries(o))
        if (m === e)
          return d;
    return null;
  }
  /**
   * Gets the key by URL from the FGBAdmin layers.
   * @function _getKeyByUrlFGB
   * @param {string} url - The URL to find the key for in the FGBAdmin layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlFGB(e) {
    for (const t in as.FGBAdmin)
      if (as.FGBAdmin.hasOwnProperty(t) && as.FGBAdmin[t] === e)
        return t;
    return null;
  }
  /**
   * Gets the legend by name from the default vector layers.
   * @function _getLegendByName
   * @param {string} name - The name of the vector layer to get the legend for.
   * @returns {string|null} - The legend if found, otherwise null.
   */
  _getLegendByName(e) {
    for (const t in rn.vectorLayers) {
      const i = rn.vectorLayers[t];
      if (i.key === e)
        return i.legend;
    }
    return null;
  }
  /**
   * Gets the key by URL from the Vector layers.
   * @function _getKeyByUrlVector
   * @param {string} url - The URL to find the key for in the Vector layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlVector(e) {
    for (const t in as.Vector)
      if (as.Vector.hasOwnProperty(t) && as.Vector[t] === e)
        return t;
    return null;
  }
  /**
   * Raises text 3D style on the map.
   * @function _raiseText3DStyle
   * @async
   * @returns {Promise<void>} - A promise that resolves after updating the text 3D style on the map.
   */
  async _raiseText3DStyle() {
    try {
      const e = await this.map.loadImage(rn.map3dOptions.imageIcon);
      this.map.hasImage("stick") || this.map.addImage("stick", e.data), this.map.getStyle().layers.forEach((t) => {
        if (t["source-layer"] === rn.map3dOptions.sourceLayerFilterId && t.minzoom >= rn.map3dOptions.minZoomFilter && e) {
          const i = t.id;
          this.map.setLayoutProperty(i, "icon-image", "stick"), this.map.setLayoutProperty(i, "text-offset", [0, -9]), this.map.setLayoutProperty(i, "symbol-placement", "point"), this.map.setLayoutProperty(i, "symbol-avoid-edges", !1), this.map.setLayoutProperty(i, "text-allow-overlap", !0), this.map.setLayoutProperty(i, "text-ignore-placement", !1), this.map.setLayoutProperty(i, "text-pitch-alignment", "auto"), this.map.setLayoutProperty(i, "text-rotation-alignment", "auto"), this.map.setLayoutProperty(i, "text-justify", "center"), this.map.setLayoutProperty(i, "text-anchor", "bottom"), this.map.setLayoutProperty(i, "icon-anchor", "bottom"), this.map.setPaintProperty(i, "text-color", "#ffffff"), this.map.setPaintProperty(i, "text-halo-color", "#000000"), this.map.setPaintProperty(i, "text-halo-width", 2);
        }
      });
    } catch (e) {
      return console.error(`Error dealing orto 3D: ${e.message}`), null;
    }
  }
  /**
   * Deals with map styles based on the name.
   * @function _dealStyleMaps
   * @param {string} name - The name of the map style.
   * @returns {Object|string|null} - The map style object if found, or the input name if not found, or null if an error occurs.
   */
  _dealStyleMaps(e) {
    try {
      if (e && e.indexOf("icgc.cat") != -1) {
        for (const t in Cf)
          if (Cf.hasOwnProperty(t)) {
            const i = Cf[t];
            if (t === e)
              return i;
          }
        return Cf[0];
      } else
        return e;
    } catch (t) {
      return console.error(`Error dealing with map styles: ${t.message}`), null;
    }
  }
  /**
   * Deals with the 3D ortho style based on the name.
   * @function _dealOrto3dStyle
   * @param {string} name - The name of the orto3D style.
   * @returns {void|null} - Returns null if an error occurs.
   */
  _dealOrto3dStyle(e) {
    try {
      if (e == "orto3d") {
        this.map.setMaxZoom(18.8), this.map.easeTo({
          pitch: 45
        });
        const t = new fP({
          intensity: 4
        }), i = new hx({
          ambientLight: t
        });
        this.map.setTerrain({
          source: rn.map3dOptions.terrainSource,
          exaggeration: rn.map3dOptions.exaggeration
        }), pc = new vG({
          interleaved: !0,
          layers: [this._createCitiesMapboxLayer(!1)],
          // Inicialment invisible
          effects: [i],
          onAfterRender: () => {
            try {
              const s = this.map.getZoom() >= rn.map3dOptions.minZoomRange;
              pc.setProps({
                layers: [this._createCitiesMapboxLayer(s)]
              });
            } catch {
              console.log("No render 3D Mesh");
            }
          }
        }), this.map.hasControl(pc) || (this.map.addControl(pc), this._raiseText3DStyle()), this.map.setSky({
          "sky-color": "#86bbd5",
          "sky-horizon-blend": 0.3,
          "horizon-color": "#ffffff33",
          "horizon-fog-blend": 0.1,
          "fog-ground-blend": 0.75,
          "fog-color": "#c5d6d6"
        }), this.map.on("zoomend", () => {
          !this.map.getStyle().name == "orto3d" && this.map.hasControl(pc) && (this.map.removeControl(pc), pc.setProps({
            layers: []
          }), this.map.setTerrain(null));
        });
      } else
        pc?.setProps({
          layers: []
        }), this.map.hasControl(pc) && (this.map.removeControl(pc), pc.setProps({
          layers: []
        }), this.map.setTerrain(null));
    } catch (t) {
      return console.error(`Error dealing orto 3D: ${t.message}`), null;
    }
  }
  /**
   * Deals with the order of the layer.
   * @function _dealOrderLayer
   * @param {string} order - The order of the layer.
   * @returns {string} - The id of the first symbol layer if the order is 'symbol', the id of the first line layer if the order is 'line', otherwise an empty string.
   */
  _dealOrderLayer(e) {
    return e === D_ ? this._firstSymbolLayer() : e === pie ? this._firstLineLayer() : "";
  }
  /**
   * Retrieves the id of the first symbol layer.
   * @function _firstSymbolLayer
   * @returns {string|undefined} - The id of the first symbol layer if found, otherwise undefined.
   */
  _firstSymbolLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let i = 0; i < e.length; i++)
        if (e[i].type === "symbol" && e[i].id.indexOf("contour") === -1 && e[i].id.indexOf("water") === -1) {
          t = e[i].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Retrieves the id of the first line layer.
   * @function _firstLineLayer
   * @returns {string|undefined} - The id of the first line layer if found, otherwise undefined.
   */
  _firstLineLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let i = 0; i < e.length; i++)
        if (e[i].type === "line") {
          t = e[i].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Creates a Mapbox layer for displaying cities in 3D.
   * @function _createCitiesMapboxLayer
   * @returns {MapboxLayer|null} - The Mapbox layer for displaying cities in 3D if created successfully, otherwise null.
   */
  _createCitiesMapboxLayer(e = !1) {
    try {
      return new Yx({
        id: rn.map3dOptions.layerId3d,
        data: rn.map3dOptions.urlTilesetCities,
        loader: Zx,
        beforeId: rn.map3dOptions.layerIdOrder,
        visible: e,
        loadOptions: {
          tileset: {
            viewDistanceScale: 1,
            memoryAdjustedScreenSpaceError: rn.map3dOptions.spaceErrorFactor,
            updateTransforms: !0,
            adjustScreenSpaceError: rn.map3dOptions.spaceErrorFactor
            // Aplicació inicial
          }
        },
        onTilesetLoad: (t) => {
          t.adjustScreenSpaceError = rn.map3dOptions.spaceErrorFactor, t.memoryAdjustedScreenSpaceError = rn.map3dOptions.spaceErrorFactor;
        },
        onTileLoad: (t) => {
          t.content.cartographicOrigin.z -= rn.map3dOptions.zfactor;
        },
        operation: "terrain+draw",
        pickable: !1
      });
    } catch (t) {
      return console.error(`Error adding MapboxOverlay: ${t.message}`), null;
    }
  }
};
var J1 = { exports: {} }, K1, h5;
function gie() {
  if (h5) return K1;
  h5 = 1;
  function r(t, i) {
    var n = t.getCenter(), s = t.getZoom(), c = t.getBearing(), o = t.getPitch();
    i.forEach(function(d) {
      d.jumpTo({
        center: n,
        zoom: s,
        bearing: c,
        pitch: o
      });
    });
  }
  function e() {
    var t, i = arguments.length;
    if (i === 1)
      t = arguments[0];
    else {
      t = [];
      for (var n = 0; n < i; n++)
        t.push(arguments[n]);
    }
    var s = [];
    t.forEach(function(m, y) {
      s[y] = d.bind(null, m, t.filter(function(T, P) {
        return P !== y;
      }));
    });
    function c() {
      t.forEach(function(m, y) {
        m.on("move", s[y]);
      });
    }
    function o() {
      t.forEach(function(m, y) {
        m.off("move", s[y]);
      });
    }
    function d(m, y) {
      o(), r(m, y), c();
    }
    return c(), function() {
      o(), s = [], t = [];
    };
  }
  return K1 = e, K1;
}
var N_ = { exports: {} }, f5;
function mie() {
  if (f5) return N_.exports;
  f5 = 1;
  var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(J, re, be) {
    return Function.prototype.apply.call(J, re, be);
  }, t;
  r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(J) {
    return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J));
  } : t = function(J) {
    return Object.getOwnPropertyNames(J);
  };
  function i(H) {
    console && console.warn && console.warn(H);
  }
  var n = Number.isNaN || function(J) {
    return J !== J;
  };
  function s() {
    s.init.call(this);
  }
  N_.exports = s, N_.exports.once = G, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var c = 10;
  function o(H) {
    if (typeof H != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof H);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return c;
    },
    set: function(H) {
      if (typeof H != "number" || H < 0 || n(H))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + H + ".");
      c = H;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(J) {
    if (typeof J != "number" || J < 0 || n(J))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + J + ".");
    return this._maxListeners = J, this;
  };
  function d(H) {
    return H._maxListeners === void 0 ? s.defaultMaxListeners : H._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return d(this);
  }, s.prototype.emit = function(J) {
    for (var re = [], be = 1; be < arguments.length; be++) re.push(arguments[be]);
    var pe = J === "error", oe = this._events;
    if (oe !== void 0) pe = pe && oe.error === void 0;
    else if (!pe) return !1;
    if (pe) {
      var Ee;
      if (re.length > 0 && (Ee = re[0]), Ee instanceof Error)
        throw Ee;
      var le = new Error("Unhandled error." + (Ee ? " (" + Ee.message + ")" : ""));
      throw le.context = Ee, le;
    }
    var _e = oe[J];
    if (_e === void 0) return !1;
    if (typeof _e == "function")
      e(_e, this, re);
    else
      for (var Ve = _e.length, Be = D(_e, Ve), be = 0; be < Ve; ++be) e(Be[be], this, re);
    return !0;
  };
  function m(H, J, re, be) {
    var pe, oe, Ee;
    if (o(re), oe = H._events, oe === void 0 ? (oe = H._events = /* @__PURE__ */ Object.create(null), H._eventsCount = 0) : (oe.newListener !== void 0 && (H.emit("newListener", J, re.listener ? re.listener : re), oe = H._events), Ee = oe[J]), Ee === void 0)
      Ee = oe[J] = re, ++H._eventsCount;
    else if (typeof Ee == "function" ? Ee = oe[J] = be ? [re, Ee] : [Ee, re] : be ? Ee.unshift(re) : Ee.push(re), pe = d(H), pe > 0 && Ee.length > pe && !Ee.warned) {
      Ee.warned = !0;
      var le = new Error("Possible EventEmitter memory leak detected. " + Ee.length + " " + String(J) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      le.name = "MaxListenersExceededWarning", le.emitter = H, le.type = J, le.count = Ee.length, i(le);
    }
    return H;
  }
  s.prototype.addListener = function(J, re) {
    return m(this, J, re, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(J, re) {
    return m(this, J, re, !0);
  };
  function y() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function T(H, J, re) {
    var be = {
      fired: !1,
      wrapFn: void 0,
      target: H,
      type: J,
      listener: re
    }, pe = y.bind(be);
    return pe.listener = re, be.wrapFn = pe, pe;
  }
  s.prototype.once = function(J, re) {
    return o(re), this.on(J, T(this, J, re)), this;
  }, s.prototype.prependOnceListener = function(J, re) {
    return o(re), this.prependListener(J, T(this, J, re)), this;
  }, s.prototype.removeListener = function(J, re) {
    var be, pe, oe, Ee, le;
    if (o(re), pe = this._events, pe === void 0) return this;
    if (be = pe[J], be === void 0) return this;
    if (be === re || be.listener === re)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete pe[J], pe.removeListener && this.emit("removeListener", J, be.listener || re));
    else if (typeof be != "function") {
      for (oe = -1, Ee = be.length - 1; Ee >= 0; Ee--)
        if (be[Ee] === re || be[Ee].listener === re) {
          le = be[Ee].listener, oe = Ee;
          break;
        }
      if (oe < 0) return this;
      oe === 0 ? be.shift() : k(be, oe), be.length === 1 && (pe[J] = be[0]), pe.removeListener !== void 0 && this.emit("removeListener", J, le || re);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(J) {
    var re, be, pe;
    if (be = this._events, be === void 0) return this;
    if (be.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : be[J] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete be[J]), this;
    if (arguments.length === 0) {
      var oe = Object.keys(be), Ee;
      for (pe = 0; pe < oe.length; ++pe)
        Ee = oe[pe], Ee !== "removeListener" && this.removeAllListeners(Ee);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (re = be[J], typeof re == "function")
      this.removeListener(J, re);
    else if (re !== void 0)
      for (pe = re.length - 1; pe >= 0; pe--)
        this.removeListener(J, re[pe]);
    return this;
  };
  function P(H, J, re) {
    var be = H._events;
    if (be === void 0) return [];
    var pe = be[J];
    return pe === void 0 ? [] : typeof pe == "function" ? re ? [pe.listener || pe] : [pe] : re ? $(pe) : D(pe, pe.length);
  }
  s.prototype.listeners = function(J) {
    return P(this, J, !0);
  }, s.prototype.rawListeners = function(J) {
    return P(this, J, !1);
  }, s.listenerCount = function(H, J) {
    return typeof H.listenerCount == "function" ? H.listenerCount(J) : I.call(H, J);
  }, s.prototype.listenerCount = I;
  function I(H) {
    var J = this._events;
    if (J !== void 0) {
      var re = J[H];
      if (typeof re == "function")
        return 1;
      if (re !== void 0)
        return re.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function D(H, J) {
    for (var re = new Array(J), be = 0; be < J; ++be) re[be] = H[be];
    return re;
  }
  function k(H, J) {
    for (; J + 1 < H.length; J++) H[J] = H[J + 1];
    H.pop();
  }
  function $(H) {
    for (var J = new Array(H.length), re = 0; re < J.length; ++re)
      J[re] = H[re].listener || H[re];
    return J;
  }
  function G(H, J) {
    return new Promise(function(re, be) {
      function pe(Ee) {
        H.removeListener(J, oe), be(Ee);
      }
      function oe() {
        typeof H.removeListener == "function" && H.removeListener("error", pe), re([].slice.call(arguments));
      }
      Z(H, J, oe, {
        once: !0
      }), J !== "error" && te(H, pe, {
        once: !0
      });
    });
  }
  function te(H, J, re) {
    typeof H.on == "function" && Z(H, "error", J, re);
  }
  function Z(H, J, re, be) {
    if (typeof H.on == "function")
      be.once ? H.once(J, re) : H.on(J, re);
    else if (typeof H.addEventListener == "function")
      H.addEventListener(J, function pe(oe) {
        be.once && H.removeEventListener(J, pe), re(oe);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof H);
  }
  return N_.exports;
}
var d5;
function _ie() {
  return d5 || (d5 = 1, function(r) {
    var e = gie(), t = mie().EventEmitter;
    function i(n, s, c, o) {
      if (this.options = o || {}, this._mapA = n, this._mapB = s, this._horizontal = this.options.orientation === "horizontal", this._onDown = this._onDown.bind(this), this._onMove = this._onMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._ev = new t(), this._swiper = document.createElement("div"), this._swiper.className = this._horizontal ? "compare-swiper-horizontal" : "compare-swiper-vertical", this._controlContainer = document.createElement("div"), this._controlContainer.className = this._horizontal ? "maplibregl-compare maplibregl-compare-horizontal" : "maplibregl-compare", this._controlContainer.className = this._controlContainer.className, this._controlContainer.appendChild(this._swiper), typeof c == "string" && document.body.querySelectorAll) {
        var d = document.body.querySelectorAll(c)[0];
        if (!d)
          throw new Error("Cannot find element with specified container selector.");
        d.appendChild(this._controlContainer);
      } else if (c instanceof Element && c.appendChild)
        c.appendChild(this._controlContainer);
      else
        throw new Error("Invalid container specified. Must be CSS selector or HTML element.");
      this._bounds = s.getContainer().getBoundingClientRect();
      var m = (this._horizontal ? this._bounds.height : this._bounds.width) / 2;
      this._setPosition(m), this._clearSync = e(n, s), this._onResize = (function() {
        this._bounds = s.getContainer().getBoundingClientRect(), this.currentPosition && this._setPosition(this.currentPosition);
      }).bind(this), s.on("resize", this._onResize), this.options && this.options.mousemove && (n.getContainer().addEventListener("mousemove", this._onMove), s.getContainer().addEventListener("mousemove", this._onMove)), this._swiper.addEventListener("mousedown", this._onDown), this._swiper.addEventListener("touchstart", this._onDown);
    }
    i.prototype = {
      _setPointerEvents: function(n) {
        this._controlContainer.style.pointerEvents = n, this._swiper.style.pointerEvents = n;
      },
      _onDown: function(n) {
        n.touches ? (document.addEventListener("touchmove", this._onMove), document.addEventListener("touchend", this._onTouchEnd)) : (document.addEventListener("mousemove", this._onMove), document.addEventListener("mouseup", this._onMouseUp));
      },
      _setPosition: function(n) {
        n = Math.min(n, this._horizontal ? this._bounds.height : this._bounds.width);
        var s = this._horizontal ? "translate(0, " + n + "px)" : "translate(" + n + "px, 0)";
        this._controlContainer.style.transform = s, this._controlContainer.style.WebkitTransform = s;
        var c = this._horizontal ? "rect(0, 999em, " + n + "px, 0)" : "rect(0, " + n + "px, " + this._bounds.height + "px, 0)", o = this._horizontal ? "rect(" + n + "px, 999em, " + this._bounds.height + "px,0)" : "rect(0, 999em, " + this._bounds.height + "px," + n + "px)";
        this._mapA.getContainer().style.clip = c, this._mapB.getContainer().style.clip = o, this.currentPosition = n;
      },
      _onMove: function(n) {
        this.options && this.options.mousemove && this._setPointerEvents(n.touches ? "auto" : "none"), this._horizontal ? this._setPosition(this._getY(n)) : this._setPosition(this._getX(n));
      },
      _onMouseUp: function() {
        document.removeEventListener("mousemove", this._onMove), document.removeEventListener("mouseup", this._onMouseUp), this.fire("slideend", {
          currentPosition: this.currentPosition
        });
      },
      _onTouchEnd: function() {
        document.removeEventListener("touchmove", this._onMove), document.removeEventListener("touchend", this._onTouchEnd), this.fire("slideend", {
          currentPosition: this.currentPosition
        });
      },
      _getX: function(n) {
        n = n.touches ? n.touches[0] : n;
        var s = n.clientX - this._bounds.left;
        return s < 0 && (s = 0), s > this._bounds.width && (s = this._bounds.width), s;
      },
      _getY: function(n) {
        n = n.touches ? n.touches[0] : n;
        var s = n.clientY - this._bounds.top;
        return s < 0 && (s = 0), s > this._bounds.height && (s = this._bounds.height), s;
      },
      /**
       * Set the position of the slider.
       *
       * @param {number} x Slider position in pixels from left/top.
       */
      setSlider: function(n) {
        this._setPosition(n);
      },
      /**
       * Adds a listener for events of a specified type.
       *
       * @param {string} type The event type to listen for; one of `slideend`.
       * @param {Function} listener The function to be called when the event is fired.
       * @returns {Compare} `this`
       */
      on: function(n, s) {
        return this._ev.on(n, s), this;
      },
      /**
       * Fire an event of a specified type.
       *
       * @param {string} type The event type to fire; one of `slideend`.
       * @param {Object} data Data passed to the event listener.
       * @returns {Compare} `this`
       */
      fire: function(n, s) {
        return this._ev.emit(n, s), this;
      },
      /**
       * Removes an event listener previously added with `Compare#on`.
       *
       * @param {string} type The event type previously used to install the listener.
       * @param {Function} listener The function previously installed as a listener.
       * @returns {Compare} `this`
       */
      off: function(n, s) {
        return this._ev.removeListener(n, s), this;
      },
      remove: function() {
        this._clearSync(), this._mapB.off("resize", this._onResize);
        var n = this._mapA.getContainer();
        n && (n.style.clip = null, n.removeEventListener("mousemove", this._onMove));
        var s = this._mapB.getContainer();
        s && (s.style.clip = null, s.removeEventListener("mousemove", this._onMove)), this._swiper.removeEventListener("mousedown", this._onDown), this._swiper.removeEventListener("touchstart", this._onDown), this._controlContainer.remove();
      }
    }, window.maplibregl ? maplibregl.Compare = i : r.exports = i;
  }(J1)), J1.exports;
}
var yie = _ie();
const bie = /* @__PURE__ */ p2(yie);
class Zie {
  /**
   * Constructor for the map comparison class.
   * @class MapComparison
   * @param {Object} map1 - The first map object to compare.
   * @param {Object} map2 - The second map object to compare.
   * @param {string} container - The HTML container element ID for displaying the comparison.
   * @param {Object} options - Additional options for map comparison (if needed).
   */
  constructor(e, t, i, n) {
    const s = this;
    setTimeout(function() {
      s.mapCompare = new bie(e.map, t.map, i, {});
    }, 1e3);
  }
}
export {
  Zie as C,
  Wie as M,
  hie as a,
  un as w
};
