function uI(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o && Object.defineProperty(n, i, o.get ? o : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var Pd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ip(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var w5 = { exports: {} };
(function(n, e) {
  (function(t, r) {
    n.exports = r();
  })(Pd, function() {
    var t = {}, r = {};
    function i(c, l, _) {
      if (r[c] = _, c === "index") {
        var b = "var sharedModule = {}; (" + r.shared + ")(sharedModule); (" + r.worker + ")(sharedModule);", w = {};
        return r.shared(w), r.index(t, w), typeof window < "u" && t.setWorkerUrl(window.URL.createObjectURL(new Blob([b], { type: "text/javascript" }))), t;
      }
    }
    i("shared", ["exports"], function(c) {
      function l(u, a, d, p) {
        return new (d || (d = Promise))(function(v, x) {
          function E(F) {
            try {
              R(p.next(F));
            } catch (j) {
              x(j);
            }
          }
          function L(F) {
            try {
              R(p.throw(F));
            } catch (j) {
              x(j);
            }
          }
          function R(F) {
            var j;
            F.done ? v(F.value) : (j = F.value, j instanceof d ? j : new d(function(q) {
              q(j);
            })).then(E, L);
          }
          R((p = p.apply(u, a || [])).next());
        });
      }
      function _(u) {
        return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var b = w;
      function w(u, a) {
        this.x = u, this.y = a;
      }
      w.prototype = { clone: function() {
        return new w(this.x, this.y);
      }, add: function(u) {
        return this.clone()._add(u);
      }, sub: function(u) {
        return this.clone()._sub(u);
      }, multByPoint: function(u) {
        return this.clone()._multByPoint(u);
      }, divByPoint: function(u) {
        return this.clone()._divByPoint(u);
      }, mult: function(u) {
        return this.clone()._mult(u);
      }, div: function(u) {
        return this.clone()._div(u);
      }, rotate: function(u) {
        return this.clone()._rotate(u);
      }, rotateAround: function(u, a) {
        return this.clone()._rotateAround(u, a);
      }, matMult: function(u) {
        return this.clone()._matMult(u);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(u) {
        return this.x === u.x && this.y === u.y;
      }, dist: function(u) {
        return Math.sqrt(this.distSqr(u));
      }, distSqr: function(u) {
        var a = u.x - this.x, d = u.y - this.y;
        return a * a + d * d;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(u) {
        return Math.atan2(this.y - u.y, this.x - u.x);
      }, angleWith: function(u) {
        return this.angleWithSep(u.x, u.y);
      }, angleWithSep: function(u, a) {
        return Math.atan2(this.x * a - this.y * u, this.x * u + this.y * a);
      }, _matMult: function(u) {
        var a = u[2] * this.x + u[3] * this.y;
        return this.x = u[0] * this.x + u[1] * this.y, this.y = a, this;
      }, _add: function(u) {
        return this.x += u.x, this.y += u.y, this;
      }, _sub: function(u) {
        return this.x -= u.x, this.y -= u.y, this;
      }, _mult: function(u) {
        return this.x *= u, this.y *= u, this;
      }, _div: function(u) {
        return this.x /= u, this.y /= u, this;
      }, _multByPoint: function(u) {
        return this.x *= u.x, this.y *= u.y, this;
      }, _divByPoint: function(u) {
        return this.x /= u.x, this.y /= u.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var u = this.y;
        return this.y = this.x, this.x = -u, this;
      }, _rotate: function(u) {
        var a = Math.cos(u), d = Math.sin(u), p = d * this.x + a * this.y;
        return this.x = a * this.x - d * this.y, this.y = p, this;
      }, _rotateAround: function(u, a) {
        var d = Math.cos(u), p = Math.sin(u), v = a.y + p * (this.x - a.x) + d * (this.y - a.y);
        return this.x = a.x + d * (this.x - a.x) - p * (this.y - a.y), this.y = v, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, w.convert = function(u) {
        return u instanceof w ? u : Array.isArray(u) ? new w(u[0], u[1]) : u;
      };
      var T = _(b), I = P;
      function P(u, a, d, p) {
        this.cx = 3 * u, this.bx = 3 * (d - u) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * a, this.by = 3 * (p - a) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = u, this.p1y = a, this.p2x = d, this.p2y = p;
      }
      P.prototype = { sampleCurveX: function(u) {
        return ((this.ax * u + this.bx) * u + this.cx) * u;
      }, sampleCurveY: function(u) {
        return ((this.ay * u + this.by) * u + this.cy) * u;
      }, sampleCurveDerivativeX: function(u) {
        return (3 * this.ax * u + 2 * this.bx) * u + this.cx;
      }, solveCurveX: function(u, a) {
        if (a === void 0 && (a = 1e-6), u < 0) return 0;
        if (u > 1) return 1;
        for (var d = u, p = 0; p < 8; p++) {
          var v = this.sampleCurveX(d) - u;
          if (Math.abs(v) < a) return d;
          var x = this.sampleCurveDerivativeX(d);
          if (Math.abs(x) < 1e-6) break;
          d -= v / x;
        }
        var E = 0, L = 1;
        for (d = u, p = 0; p < 20 && (v = this.sampleCurveX(d), !(Math.abs(v - u) < a)); p++) u > v ? E = d : L = d, d = 0.5 * (L - E) + E;
        return d;
      }, solve: function(u, a) {
        return this.sampleCurveY(this.solveCurveX(u, a));
      } };
      var k = _(I);
      let U, G;
      function H() {
        return U == null && (U = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), U;
      }
      function $() {
        if (G == null && (G = !1, H())) {
          const a = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (a) {
            for (let p = 0; p < 5 * 5; p++) {
              const v = 4 * p;
              a.fillStyle = `rgb(${v},${v + 1},${v + 2})`, a.fillRect(p % 5, Math.floor(p / 5), 1, 1);
            }
            const d = a.getImageData(0, 0, 5, 5).data;
            for (let p = 0; p < 5 * 5 * 4; p++) if (p % 4 != 3 && d[p] !== p) {
              G = !0;
              break;
            }
          }
        }
        return G || !1;
      }
      function ie(u, a, d, p) {
        const v = new k(u, a, d, p);
        return (x) => v.solve(x);
      }
      const ge = ie(0.25, 0.1, 0.25, 1);
      function Se(u, a, d) {
        return Math.min(d, Math.max(a, u));
      }
      function Re(u, a, d) {
        const p = d - a, v = ((u - a) % p + p) % p + a;
        return v === a ? d : v;
      }
      function Le(u) {
        for (var a = arguments.length, d = new Array(a > 1 ? a - 1 : 0), p = 1; p < a; p++)
          d[p - 1] = arguments[p];
        for (const v of d) for (const x in v) u[x] = v[x];
        return u;
      }
      let _e = 1;
      function Ge(u, a, d) {
        const p = {};
        for (const v in u) p[v] = a.call(this, u[v], v, u);
        return p;
      }
      function ke(u, a, d) {
        const p = {};
        for (const v in u) a.call(this, u[v], v, u) && (p[v] = u[v]);
        return p;
      }
      function oe(u) {
        return Array.isArray(u) ? u.map(oe) : typeof u == "object" && u ? Ge(u, oe) : u;
      }
      const pe = {};
      function Te(u) {
        pe[u] || (typeof console < "u" && console.warn(u), pe[u] = !0);
      }
      function xe(u, a, d) {
        return (d.y - u.y) * (a.x - u.x) > (a.y - u.y) * (d.x - u.x);
      }
      function et(u) {
        return typeof WorkerGlobalScope < "u" && u !== void 0 && u instanceof WorkerGlobalScope;
      }
      let rt = null;
      function st(u) {
        return typeof ImageBitmap < "u" && u instanceof ImageBitmap;
      }
      const Je = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function ct(u, a, d, p, v) {
        return l(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const x = new VideoFrame(u, { timestamp: 0 });
          try {
            const E = x == null ? void 0 : x.format;
            if (!E || !E.startsWith("BGR") && !E.startsWith("RGB")) throw new Error(`Unrecognized format ${E}`);
            const L = E.startsWith("BGR"), R = new Uint8ClampedArray(p * v * 4);
            if (yield x.copyTo(R, function(F, j, q, Y, ee) {
              const se = 4 * Math.max(-j, 0), de = (Math.max(0, q) - q) * Y * 4 + se, we = 4 * Y, Me = Math.max(0, j), $e = Math.max(0, q);
              return { rect: { x: Me, y: $e, width: Math.min(F.width, j + Y) - Me, height: Math.min(F.height, q + ee) - $e }, layout: [{ offset: de, stride: we }] };
            }(u, a, d, p, v)), L) for (let F = 0; F < R.length; F += 4) {
              const j = R[F];
              R[F] = R[F + 2], R[F + 2] = j;
            }
            return R;
          } finally {
            x.close();
          }
        });
      }
      let ot, Mt;
      const re = "AbortError";
      function Ae() {
        return new Error(re);
      }
      const Ce = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Ue(u) {
        return Ce.REGISTERED_PROTOCOLS[u.substring(0, u.indexOf("://"))];
      }
      const qe = "global-dispatcher";
      class He extends Error {
        constructor(a, d, p, v) {
          super(`AJAXError: ${d} (${a}): ${p}`), this.status = a, this.statusText = d, this.url = p, this.body = v;
        }
      }
      const Ye = () => et(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Ze = function(u, a) {
        if (/:\/\//.test(u.url) && !/^https?:|^file:/.test(u.url)) {
          const p = Ue(u.url);
          if (p) return p(u, a);
          if (et(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: u, targetMapId: qe }, a);
        }
        if (!(/^file:/.test(d = u.url) || /^file:/.test(Ye()) && !/^\w+:/.test(d))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(p, v) {
            return l(this, void 0, void 0, function* () {
              const x = new Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, cache: p.cache, referrer: Ye(), signal: v.signal });
              p.type !== "json" || x.headers.has("Accept") || x.headers.set("Accept", "application/json");
              const E = yield fetch(x);
              if (!E.ok) {
                const F = yield E.blob();
                throw new He(E.status, E.statusText, p.url, F);
              }
              let L;
              L = p.type === "arrayBuffer" || p.type === "image" ? E.arrayBuffer() : p.type === "json" ? E.json() : E.text();
              const R = yield L;
              if (v.signal.aborted) throw Ae();
              return { data: R, cacheControl: E.headers.get("Cache-Control"), expires: E.headers.get("Expires") };
            });
          }(u, a);
          if (et(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: u, mustQueue: !0, targetMapId: qe }, a);
        }
        var d;
        return function(p, v) {
          return new Promise((x, E) => {
            var L;
            const R = new XMLHttpRequest();
            R.open(p.method || "GET", p.url, !0), p.type !== "arrayBuffer" && p.type !== "image" || (R.responseType = "arraybuffer");
            for (const F in p.headers) R.setRequestHeader(F, p.headers[F]);
            p.type === "json" && (R.responseType = "text", !((L = p.headers) === null || L === void 0) && L.Accept || R.setRequestHeader("Accept", "application/json")), R.withCredentials = p.credentials === "include", R.onerror = () => {
              E(new Error(R.statusText));
            }, R.onload = () => {
              if (!v.signal.aborted) if ((R.status >= 200 && R.status < 300 || R.status === 0) && R.response !== null) {
                let F = R.response;
                if (p.type === "json") try {
                  F = JSON.parse(R.response);
                } catch (j) {
                  return void E(j);
                }
                x({ data: F, cacheControl: R.getResponseHeader("Cache-Control"), expires: R.getResponseHeader("Expires") });
              } else {
                const F = new Blob([R.response], { type: R.getResponseHeader("Content-Type") });
                E(new He(R.status, R.statusText, p.url, F));
              }
            }, v.signal.addEventListener("abort", () => {
              R.abort(), E(Ae());
            }), R.send(p.body);
          });
        }(u, a);
      };
      function St(u) {
        if (!u || u.indexOf("://") <= 0 || u.indexOf("data:image/") === 0 || u.indexOf("blob:") === 0) return !0;
        const a = new URL(u), d = window.location;
        return a.protocol === d.protocol && a.host === d.host;
      }
      function Lt(u, a, d) {
        d[u] && d[u].indexOf(a) !== -1 || (d[u] = d[u] || [], d[u].push(a));
      }
      function Dt(u, a, d) {
        if (d && d[u]) {
          const p = d[u].indexOf(a);
          p !== -1 && d[u].splice(p, 1);
        }
      }
      class Nt {
        constructor(a) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          Le(this, d), this.type = a;
        }
      }
      class an extends Nt {
        constructor(a) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super("error", Le({ error: a }, d));
        }
      }
      class at {
        on(a, d) {
          return this._listeners = this._listeners || {}, Lt(a, d, this._listeners), this;
        }
        off(a, d) {
          return Dt(a, d, this._listeners), Dt(a, d, this._oneTimeListeners), this;
        }
        once(a, d) {
          return d ? (this._oneTimeListeners = this._oneTimeListeners || {}, Lt(a, d, this._oneTimeListeners), this) : new Promise((p) => this.once(a, p));
        }
        fire(a, d) {
          typeof a == "string" && (a = new Nt(a, d || {}));
          const p = a.type;
          if (this.listens(p)) {
            a.target = this;
            const v = this._listeners && this._listeners[p] ? this._listeners[p].slice() : [];
            for (const L of v) L.call(this, a);
            const x = this._oneTimeListeners && this._oneTimeListeners[p] ? this._oneTimeListeners[p].slice() : [];
            for (const L of x) Dt(p, L, this._oneTimeListeners), L.call(this, a);
            const E = this._eventedParent;
            E && (Le(a, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), E.fire(a));
          } else a instanceof an && console.error(a.error);
          return this;
        }
        listens(a) {
          return this._listeners && this._listeners[a] && this._listeners[a].length > 0 || this._oneTimeListeners && this._oneTimeListeners[a] && this._oneTimeListeners[a].length > 0 || this._eventedParent && this._eventedParent.listens(a);
        }
        setEventedParent(a, d) {
          return this._eventedParent = a, this._eventedParentData = d, this;
        }
      }
      var ne = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const pn = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Qt(u, a) {
        const d = {};
        for (const p in u) p !== "ref" && (d[p] = u[p]);
        return pn.forEach((p) => {
          p in a && (d[p] = a[p]);
        }), d;
      }
      function dt(u, a) {
        if (Array.isArray(u)) {
          if (!Array.isArray(a) || u.length !== a.length) return !1;
          for (let d = 0; d < u.length; d++) if (!dt(u[d], a[d])) return !1;
          return !0;
        }
        if (typeof u == "object" && u !== null && a !== null) {
          if (typeof a != "object" || Object.keys(u).length !== Object.keys(a).length) return !1;
          for (const d in u) if (!dt(u[d], a[d])) return !1;
          return !0;
        }
        return u === a;
      }
      function Et(u, a) {
        u.push(a);
      }
      function Bt(u, a, d) {
        Et(d, { command: "addSource", args: [u, a[u]] });
      }
      function Ft(u, a, d) {
        Et(a, { command: "removeSource", args: [u] }), d[u] = !0;
      }
      function nn(u, a, d, p) {
        Ft(u, d, p), Bt(u, a, d);
      }
      function Sn(u, a, d) {
        let p;
        for (p in u[d]) if (Object.prototype.hasOwnProperty.call(u[d], p) && p !== "data" && !dt(u[d][p], a[d][p])) return !1;
        for (p in a[d]) if (Object.prototype.hasOwnProperty.call(a[d], p) && p !== "data" && !dt(u[d][p], a[d][p])) return !1;
        return !0;
      }
      function vn(u, a, d, p, v, x) {
        u = u || {}, a = a || {};
        for (const E in u) Object.prototype.hasOwnProperty.call(u, E) && (dt(u[E], a[E]) || d.push({ command: x, args: [p, E, a[E], v] }));
        for (const E in a) Object.prototype.hasOwnProperty.call(a, E) && !Object.prototype.hasOwnProperty.call(u, E) && (dt(u[E], a[E]) || d.push({ command: x, args: [p, E, a[E], v] }));
      }
      function On(u) {
        return u.id;
      }
      function Un(u, a) {
        return u[a.id] = a, u;
      }
      class gt {
        constructor(a, d, p, v) {
          this.message = (a ? `${a}: ` : "") + p, v && (this.identifier = v), d != null && d.__line__ && (this.line = d.__line__);
        }
      }
      function un(u) {
        for (var a = arguments.length, d = new Array(a > 1 ? a - 1 : 0), p = 1; p < a; p++)
          d[p - 1] = arguments[p];
        for (const v of d) for (const x in v) u[x] = v[x];
        return u;
      }
      class xn extends Error {
        constructor(a, d) {
          super(d), this.message = d, this.key = a;
        }
      }
      class Ot {
        constructor(a) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          this.parent = a, this.bindings = {};
          for (const [p, v] of d) this.bindings[p] = v;
        }
        concat(a) {
          return new Ot(this, a);
        }
        get(a) {
          if (this.bindings[a]) return this.bindings[a];
          if (this.parent) return this.parent.get(a);
          throw new Error(`${a} not found in scope.`);
        }
        has(a) {
          return !!this.bindings[a] || !!this.parent && this.parent.has(a);
        }
      }
      const _r = { kind: "null" }, mt = { kind: "number" }, bn = { kind: "string" }, jt = { kind: "boolean" }, qn = { kind: "color" }, Jr = { kind: "object" }, zt = { kind: "value" }, yi = { kind: "collator" }, rr = { kind: "formatted" }, ti = { kind: "padding" }, ni = { kind: "resolvedImage" }, be = { kind: "variableAnchorOffsetCollection" };
      function J(u, a) {
        return { kind: "array", itemType: u, N: a };
      }
      function K(u) {
        if (u.kind === "array") {
          const a = K(u.itemType);
          return typeof u.N == "number" ? `array<${a}, ${u.N}>` : u.itemType.kind === "value" ? "array" : `array<${a}>`;
        }
        return u.kind;
      }
      const ce = [_r, mt, bn, jt, qn, rr, Jr, J(zt), ti, ni, be];
      function ye(u, a) {
        if (a.kind === "error") return null;
        if (u.kind === "array") {
          if (a.kind === "array" && (a.N === 0 && a.itemType.kind === "value" || !ye(u.itemType, a.itemType)) && (typeof u.N != "number" || u.N === a.N)) return null;
        } else {
          if (u.kind === a.kind) return null;
          if (u.kind === "value") {
            for (const d of ce) if (!ye(d, a)) return null;
          }
        }
        return `Expected ${K(u)} but found ${K(a)} instead.`;
      }
      function Fe(u, a) {
        return a.some((d) => d.kind === u.kind);
      }
      function je(u, a) {
        return a.some((d) => d === "null" ? u === null : d === "array" ? Array.isArray(u) : d === "object" ? u && !Array.isArray(u) && typeof u == "object" : d === typeof u);
      }
      function Oe(u, a) {
        return u.kind === "array" && a.kind === "array" ? u.itemType.kind === a.itemType.kind && typeof u.N == "number" : u.kind === a.kind;
      }
      const Ie = 0.96422, tt = 0.82521, ut = 4 / 29, We = 6 / 29, vt = 3 * We * We, Xt = We * We * We, Kt = Math.PI / 180, Mn = 180 / Math.PI;
      function en(u) {
        return (u %= 360) < 0 && (u += 360), u;
      }
      function In(u) {
        let [a, d, p, v] = u, x, E;
        const L = ir((0.2225045 * (a = wn(a)) + 0.7168786 * (d = wn(d)) + 0.0606169 * (p = wn(p))) / 1);
        a === d && d === p ? x = E = L : (x = ir((0.4360747 * a + 0.3850649 * d + 0.1430804 * p) / Ie), E = ir((0.0139322 * a + 0.0971045 * d + 0.7141733 * p) / tt));
        const R = 116 * L - 16;
        return [R < 0 ? 0 : R, 500 * (x - L), 200 * (L - E), v];
      }
      function wn(u) {
        return u <= 0.04045 ? u / 12.92 : Math.pow((u + 0.055) / 1.055, 2.4);
      }
      function ir(u) {
        return u > Xt ? Math.pow(u, 1 / 3) : u / vt + ut;
      }
      function Wn(u) {
        let [a, d, p, v] = u, x = (a + 16) / 116, E = isNaN(d) ? x : x + d / 500, L = isNaN(p) ? x : x - p / 200;
        return x = 1 * Fn(x), E = Ie * Fn(E), L = tt * Fn(L), [hn(3.1338561 * E - 1.6168667 * x - 0.4906146 * L), hn(-0.9787684 * E + 1.9161415 * x + 0.033454 * L), hn(0.0719453 * E - 0.2289914 * x + 1.4052427 * L), v];
      }
      function hn(u) {
        return (u = u <= 304e-5 ? 12.92 * u : 1.055 * Math.pow(u, 1 / 2.4) - 0.055) < 0 ? 0 : u > 1 ? 1 : u;
      }
      function Fn(u) {
        return u > We ? u * u * u : vt * (u - ut);
      }
      function er(u) {
        return parseInt(u.padEnd(2, u), 16) / 255;
      }
      function fr(u, a) {
        return Sr(a ? u / 100 : u, 0, 1);
      }
      function Sr(u, a, d) {
        return Math.min(Math.max(a, u), d);
      }
      function Yr(u) {
        return !u.some(Number.isNaN);
      }
      const so = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class Jn {
        constructor(a, d, p) {
          let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
          this.r = a, this.g = d, this.b = p, this.a = v, x || (this.r *= v, this.g *= v, this.b *= v, v || this.overwriteGetter("rgb", [a, d, p, v]));
        }
        static parse(a) {
          if (a instanceof Jn) return a;
          if (typeof a != "string") return;
          const d = function(p) {
            if ((p = p.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const v = so[p];
            if (v) {
              const [E, L, R] = v;
              return [E / 255, L / 255, R / 255, 1];
            }
            if (p.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(p)) {
              const E = p.length < 6 ? 1 : 2;
              let L = 1;
              return [er(p.slice(L, L += E)), er(p.slice(L, L += E)), er(p.slice(L, L += E)), er(p.slice(L, L + E) || "ff")];
            }
            if (p.startsWith("rgb")) {
              const E = p.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (E) {
                const [L, R, F, j, q, Y, ee, se, de, we, Me, $e] = E, Ne = [j || " ", ee || " ", we].join("");
                if (Ne === "  " || Ne === "  /" || Ne === ",," || Ne === ",,,") {
                  const Ve = [F, Y, de].join(""), it = Ve === "%%%" ? 100 : Ve === "" ? 255 : 0;
                  if (it) {
                    const At = [Sr(+R / it, 0, 1), Sr(+q / it, 0, 1), Sr(+se / it, 0, 1), Me ? fr(+Me, $e) : 1];
                    if (Yr(At)) return At;
                  }
                }
                return;
              }
            }
            const x = p.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (x) {
              const [E, L, R, F, j, q, Y, ee, se] = x, de = [R || " ", j || " ", Y].join("");
              if (de === "  " || de === "  /" || de === ",," || de === ",,,") {
                const we = [+L, Sr(+F, 0, 100), Sr(+q, 0, 100), ee ? fr(+ee, se) : 1];
                if (Yr(we)) return function(Me) {
                  let [$e, Ne, Ve, it] = Me;
                  function At(Gt) {
                    const mn = (Gt + $e / 30) % 12, Ut = Ne * Math.min(Ve, 1 - Ve);
                    return Ve - Ut * Math.max(-1, Math.min(mn - 3, 9 - mn, 1));
                  }
                  return $e = en($e), Ne /= 100, Ve /= 100, [At(0), At(8), At(4), it];
                }(we);
              }
            }
          }(a);
          return d ? new Jn(...d, !1) : void 0;
        }
        get rgb() {
          const { r: a, g: d, b: p, a: v } = this, x = v || 1 / 0;
          return this.overwriteGetter("rgb", [a / x, d / x, p / x, v]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(a) {
            const [d, p, v, x] = In(a), E = Math.sqrt(p * p + v * v);
            return [Math.round(1e4 * E) ? en(Math.atan2(v, p) * Mn) : NaN, E, d, x];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", In(this.rgb));
        }
        overwriteGetter(a, d) {
          return Object.defineProperty(this, a, { value: d }), d;
        }
        toString() {
          const [a, d, p, v] = this.rgb;
          return `rgba(${[a, d, p].map((x) => Math.round(255 * x)).join(",")},${v})`;
        }
      }
      Jn.black = new Jn(0, 0, 0, 1), Jn.white = new Jn(1, 1, 1, 1), Jn.transparent = new Jn(0, 0, 0, 0), Jn.red = new Jn(1, 0, 0, 1);
      class bi {
        constructor(a, d, p) {
          this.sensitivity = a ? d ? "variant" : "case" : d ? "accent" : "base", this.locale = p, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(a, d) {
          return this.collator.compare(a, d);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Xi {
        constructor(a, d, p, v, x) {
          this.text = a, this.image = d, this.scale = p, this.fontStack = v, this.textColor = x;
        }
      }
      class Pr {
        constructor(a) {
          this.sections = a;
        }
        static fromString(a) {
          return new Pr([new Xi(a, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((a) => a.text.length !== 0 || a.image && a.image.name.length !== 0);
        }
        static factory(a) {
          return a instanceof Pr ? a : Pr.fromString(a);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((a) => a.text).join("");
        }
      }
      class Lr {
        constructor(a) {
          this.values = a.slice();
        }
        static parse(a) {
          if (a instanceof Lr) return a;
          if (typeof a == "number") return new Lr([a, a, a, a]);
          if (Array.isArray(a) && !(a.length < 1 || a.length > 4)) {
            for (const d of a) if (typeof d != "number") return;
            switch (a.length) {
              case 1:
                a = [a[0], a[0], a[0], a[0]];
                break;
              case 2:
                a = [a[0], a[1], a[0], a[1]];
                break;
              case 3:
                a = [a[0], a[1], a[2], a[1]];
            }
            return new Lr(a);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const oo = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class Mr {
        constructor(a) {
          this.values = a.slice();
        }
        static parse(a) {
          if (a instanceof Mr) return a;
          if (Array.isArray(a) && !(a.length < 1) && a.length % 2 == 0) {
            for (let d = 0; d < a.length; d += 2) {
              const p = a[d], v = a[d + 1];
              if (typeof p != "string" || !oo.has(p) || !Array.isArray(v) || v.length !== 2 || typeof v[0] != "number" || typeof v[1] != "number") return;
            }
            return new Mr(a);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class Er {
        constructor(a) {
          this.name = a.name, this.available = a.available;
        }
        toString() {
          return this.name;
        }
        static fromString(a) {
          return a ? new Er({ name: a, available: !1 }) : null;
        }
      }
      function ao(u, a, d, p) {
        return typeof u == "number" && u >= 0 && u <= 255 && typeof a == "number" && a >= 0 && a <= 255 && typeof d == "number" && d >= 0 && d <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : `Invalid rgba value [${[u, a, d, p].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof p == "number" ? [u, a, d, p] : [u, a, d]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function $i(u) {
        if (u === null || typeof u == "string" || typeof u == "boolean" || typeof u == "number" || u instanceof Jn || u instanceof bi || u instanceof Pr || u instanceof Lr || u instanceof Mr || u instanceof Er) return !0;
        if (Array.isArray(u)) {
          for (const a of u) if (!$i(a)) return !1;
          return !0;
        }
        if (typeof u == "object") {
          for (const a in u) if (!$i(u[a])) return !1;
          return !0;
        }
        return !1;
      }
      function yr(u) {
        if (u === null) return _r;
        if (typeof u == "string") return bn;
        if (typeof u == "boolean") return jt;
        if (typeof u == "number") return mt;
        if (u instanceof Jn) return qn;
        if (u instanceof bi) return yi;
        if (u instanceof Pr) return rr;
        if (u instanceof Lr) return ti;
        if (u instanceof Mr) return be;
        if (u instanceof Er) return ni;
        if (Array.isArray(u)) {
          const a = u.length;
          let d;
          for (const p of u) {
            const v = yr(p);
            if (d) {
              if (d === v) continue;
              d = zt;
              break;
            }
            d = v;
          }
          return J(d || zt, a);
        }
        return Jr;
      }
      function Yn(u) {
        const a = typeof u;
        return u === null ? "" : a === "string" || a === "number" || a === "boolean" ? String(u) : u instanceof Jn || u instanceof Pr || u instanceof Lr || u instanceof Mr || u instanceof Er ? u.toString() : JSON.stringify(u);
      }
      class fi {
        constructor(a, d) {
          this.type = a, this.value = d;
        }
        static parse(a, d) {
          if (a.length !== 2) return d.error(`'literal' expression requires exactly one argument, but found ${a.length - 1} instead.`);
          if (!$i(a[1])) return d.error("invalid value");
          const p = a[1];
          let v = yr(p);
          const x = d.expectedType;
          return v.kind !== "array" || v.N !== 0 || !x || x.kind !== "array" || typeof x.N == "number" && x.N !== 0 || (v = x), new fi(v, p);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class pr {
        constructor(a) {
          this.name = "ExpressionEvaluationError", this.message = a;
        }
        toJSON() {
          return this.message;
        }
      }
      const lo = { string: bn, number: mt, boolean: jt, object: Jr };
      class pi {
        constructor(a, d) {
          this.type = a, this.args = d;
        }
        static parse(a, d) {
          if (a.length < 2) return d.error("Expected at least one argument.");
          let p, v = 1;
          const x = a[0];
          if (x === "array") {
            let L, R;
            if (a.length > 2) {
              const F = a[1];
              if (typeof F != "string" || !(F in lo) || F === "object") return d.error('The item type argument of "array" must be one of string, number, boolean', 1);
              L = lo[F], v++;
            } else L = zt;
            if (a.length > 3) {
              if (a[2] !== null && (typeof a[2] != "number" || a[2] < 0 || a[2] !== Math.floor(a[2]))) return d.error('The length argument to "array" must be a positive integer literal', 2);
              R = a[2], v++;
            }
            p = J(L, R);
          } else {
            if (!lo[x]) throw new Error(`Types doesn't contain name = ${x}`);
            p = lo[x];
          }
          const E = [];
          for (; v < a.length; v++) {
            const L = d.parse(a[v], v, zt);
            if (!L) return null;
            E.push(L);
          }
          return new pi(p, E);
        }
        evaluate(a) {
          for (let d = 0; d < this.args.length; d++) {
            const p = this.args[d].evaluate(a);
            if (!ye(this.type, yr(p))) return p;
            if (d === this.args.length - 1) throw new pr(`Expected value to be of type ${K(this.type)}, but found ${K(yr(p))} instead.`);
          }
          throw new Error();
        }
        eachChild(a) {
          this.args.forEach(a);
        }
        outputDefined() {
          return this.args.every((a) => a.outputDefined());
        }
      }
      const Zo = { "to-boolean": jt, "to-color": qn, "to-number": mt, "to-string": bn };
      class Tr {
        constructor(a, d) {
          this.type = a, this.args = d;
        }
        static parse(a, d) {
          if (a.length < 2) return d.error("Expected at least one argument.");
          const p = a[0];
          if (!Zo[p]) throw new Error(`Can't parse ${p} as it is not part of the known types`);
          if ((p === "to-boolean" || p === "to-string") && a.length !== 2) return d.error("Expected one argument.");
          const v = Zo[p], x = [];
          for (let E = 1; E < a.length; E++) {
            const L = d.parse(a[E], E, zt);
            if (!L) return null;
            x.push(L);
          }
          return new Tr(v, x);
        }
        evaluate(a) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(a);
            case "color": {
              let d, p;
              for (const v of this.args) {
                if (d = v.evaluate(a), p = null, d instanceof Jn) return d;
                if (typeof d == "string") {
                  const x = a.parseColor(d);
                  if (x) return x;
                } else if (Array.isArray(d) && (p = d.length < 3 || d.length > 4 ? `Invalid rbga value ${JSON.stringify(d)}: expected an array containing either three or four numeric values.` : ao(d[0], d[1], d[2], d[3]), !p)) return new Jn(d[0] / 255, d[1] / 255, d[2] / 255, d[3]);
              }
              throw new pr(p || `Could not parse color from value '${typeof d == "string" ? d : JSON.stringify(d)}'`);
            }
            case "padding": {
              let d;
              for (const p of this.args) {
                d = p.evaluate(a);
                const v = Lr.parse(d);
                if (v) return v;
              }
              throw new pr(`Could not parse padding from value '${typeof d == "string" ? d : JSON.stringify(d)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let d;
              for (const p of this.args) {
                d = p.evaluate(a);
                const v = Mr.parse(d);
                if (v) return v;
              }
              throw new pr(`Could not parse variableAnchorOffsetCollection from value '${typeof d == "string" ? d : JSON.stringify(d)}'`);
            }
            case "number": {
              let d = null;
              for (const p of this.args) {
                if (d = p.evaluate(a), d === null) return 0;
                const v = Number(d);
                if (!isNaN(v)) return v;
              }
              throw new pr(`Could not convert ${JSON.stringify(d)} to number.`);
            }
            case "formatted":
              return Pr.fromString(Yn(this.args[0].evaluate(a)));
            case "resolvedImage":
              return Er.fromString(Yn(this.args[0].evaluate(a)));
            default:
              return Yn(this.args[0].evaluate(a));
          }
        }
        eachChild(a) {
          this.args.forEach(a);
        }
        outputDefined() {
          return this.args.every((a) => a.outputDefined());
        }
      }
      const Zi = ["Unknown", "Point", "LineString", "Polygon"];
      class gi {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Zi[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(a) {
          let d = this._parseColorCache[a];
          return d || (d = this._parseColorCache[a] = Jn.parse(a)), d;
        }
      }
      class as {
        constructor(a, d) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], v = arguments.length > 3 ? arguments[3] : void 0, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Ot(), E = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
          this.registry = a, this.path = p, this.key = p.map((L) => `[${L}]`).join(""), this.scope = x, this.errors = E, this.expectedType = v, this._isConstant = d;
        }
        parse(a, d, p, v) {
          let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return d ? this.concat(d, p, v)._parse(a, x) : this._parse(a, x);
        }
        _parse(a, d) {
          function p(v, x, E) {
            return E === "assert" ? new pi(x, [v]) : E === "coerce" ? new Tr(x, [v]) : v;
          }
          if (a !== null && typeof a != "string" && typeof a != "boolean" && typeof a != "number" || (a = ["literal", a]), Array.isArray(a)) {
            if (a.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const v = a[0];
            if (typeof v != "string") return this.error(`Expression name must be a string, but found ${typeof v} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const x = this.registry[v];
            if (x) {
              let E = x.parse(a, this);
              if (!E) return null;
              if (this.expectedType) {
                const L = this.expectedType, R = E.type;
                if (L.kind !== "string" && L.kind !== "number" && L.kind !== "boolean" && L.kind !== "object" && L.kind !== "array" || R.kind !== "value")
                  if (L.kind !== "color" && L.kind !== "formatted" && L.kind !== "resolvedImage" || R.kind !== "value" && R.kind !== "string")
                    if (L.kind !== "padding" || R.kind !== "value" && R.kind !== "number" && R.kind !== "array")
                      if (L.kind !== "variableAnchorOffsetCollection" || R.kind !== "value" && R.kind !== "array") {
                        if (this.checkSubtype(L, R)) return null;
                      } else E = p(E, L, d.typeAnnotation || "coerce");
                    else E = p(E, L, d.typeAnnotation || "coerce");
                  else E = p(E, L, d.typeAnnotation || "coerce");
                else E = p(E, L, d.typeAnnotation || "assert");
              }
              if (!(E instanceof fi) && E.type.kind !== "resolvedImage" && this._isConstant(E)) {
                const L = new gi();
                try {
                  E = new fi(E.type, E.evaluate(L));
                } catch (R) {
                  return this.error(R.message), null;
                }
              }
              return E;
            }
            return this.error(`Unknown expression "${v}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(a === void 0 ? "'undefined' value invalid. Use null instead." : typeof a == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof a} instead.`);
        }
        concat(a, d, p) {
          const v = typeof a == "number" ? this.path.concat(a) : this.path, x = p ? this.scope.concat(p) : this.scope;
          return new as(this.registry, this._isConstant, v, d || null, x, this.errors);
        }
        error(a) {
          for (var d = arguments.length, p = new Array(d > 1 ? d - 1 : 0), v = 1; v < d; v++)
            p[v - 1] = arguments[v];
          const x = `${this.key}${p.map((E) => `[${E}]`).join("")}`;
          this.errors.push(new xn(x, a));
        }
        checkSubtype(a, d) {
          const p = ye(a, d);
          return p && this.error(p), p;
        }
      }
      class Ji {
        constructor(a, d) {
          this.type = d.type, this.bindings = [].concat(a), this.result = d;
        }
        evaluate(a) {
          return this.result.evaluate(a);
        }
        eachChild(a) {
          for (const d of this.bindings) a(d[1]);
          a(this.result);
        }
        static parse(a, d) {
          if (a.length < 4) return d.error(`Expected at least 3 arguments, but found ${a.length - 1} instead.`);
          const p = [];
          for (let x = 1; x < a.length - 1; x += 2) {
            const E = a[x];
            if (typeof E != "string") return d.error(`Expected string, but found ${typeof E} instead.`, x);
            if (/[^a-zA-Z0-9_]/.test(E)) return d.error("Variable names must contain only alphanumeric characters or '_'.", x);
            const L = d.parse(a[x + 1], x + 1);
            if (!L) return null;
            p.push([E, L]);
          }
          const v = d.parse(a[a.length - 1], a.length - 1, d.expectedType, p);
          return v ? new Ji(p, v) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Xn {
        constructor(a, d) {
          this.type = d.type, this.name = a, this.boundExpression = d;
        }
        static parse(a, d) {
          if (a.length !== 2 || typeof a[1] != "string") return d.error("'var' expression requires exactly one string literal argument.");
          const p = a[1];
          return d.scope.has(p) ? new Xn(p, d.scope.get(p)) : d.error(`Unknown variable "${p}". Make sure "${p}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(a) {
          return this.boundExpression.evaluate(a);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class Sa {
        constructor(a, d, p) {
          this.type = a, this.index = d, this.input = p;
        }
        static parse(a, d) {
          if (a.length !== 3) return d.error(`Expected 2 arguments, but found ${a.length - 1} instead.`);
          const p = d.parse(a[1], 1, mt), v = d.parse(a[2], 2, J(d.expectedType || zt));
          return p && v ? new Sa(v.type.itemType, p, v) : null;
        }
        evaluate(a) {
          const d = this.index.evaluate(a), p = this.input.evaluate(a);
          if (d < 0) throw new pr(`Array index out of bounds: ${d} < 0.`);
          if (d >= p.length) throw new pr(`Array index out of bounds: ${d} > ${p.length - 1}.`);
          if (d !== Math.floor(d)) throw new pr(`Array index must be an integer, but found ${d} instead.`);
          return p[d];
        }
        eachChild(a) {
          a(this.index), a(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ya {
        constructor(a, d) {
          this.type = jt, this.needle = a, this.haystack = d;
        }
        static parse(a, d) {
          if (a.length !== 3) return d.error(`Expected 2 arguments, but found ${a.length - 1} instead.`);
          const p = d.parse(a[1], 1, zt), v = d.parse(a[2], 2, zt);
          return p && v ? Fe(p.type, [jt, bn, mt, _r, zt]) ? new Ya(p, v) : d.error(`Expected first argument to be of type boolean, string, number or null, but found ${K(p.type)} instead`) : null;
        }
        evaluate(a) {
          const d = this.needle.evaluate(a), p = this.haystack.evaluate(a);
          if (!p) return !1;
          if (!je(d, ["boolean", "string", "number", "null"])) throw new pr(`Expected first argument to be of type boolean, string, number or null, but found ${K(yr(d))} instead.`);
          if (!je(p, ["string", "array"])) throw new pr(`Expected second argument to be of type array or string, but found ${K(yr(p))} instead.`);
          return p.indexOf(d) >= 0;
        }
        eachChild(a) {
          a(this.needle), a(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class ae {
        constructor(a, d, p) {
          this.type = mt, this.needle = a, this.haystack = d, this.fromIndex = p;
        }
        static parse(a, d) {
          if (a.length <= 2 || a.length >= 5) return d.error(`Expected 3 or 4 arguments, but found ${a.length - 1} instead.`);
          const p = d.parse(a[1], 1, zt), v = d.parse(a[2], 2, zt);
          if (!p || !v) return null;
          if (!Fe(p.type, [jt, bn, mt, _r, zt])) return d.error(`Expected first argument to be of type boolean, string, number or null, but found ${K(p.type)} instead`);
          if (a.length === 4) {
            const x = d.parse(a[3], 3, mt);
            return x ? new ae(p, v, x) : null;
          }
          return new ae(p, v);
        }
        evaluate(a) {
          const d = this.needle.evaluate(a), p = this.haystack.evaluate(a);
          if (!je(d, ["boolean", "string", "number", "null"])) throw new pr(`Expected first argument to be of type boolean, string, number or null, but found ${K(yr(d))} instead.`);
          let v;
          if (this.fromIndex && (v = this.fromIndex.evaluate(a)), je(p, ["string"])) {
            const x = p.indexOf(d, v);
            return x === -1 ? -1 : [...p.slice(0, x)].length;
          }
          if (je(p, ["array"])) return p.indexOf(d, v);
          throw new pr(`Expected second argument to be of type array or string, but found ${K(yr(p))} instead.`);
        }
        eachChild(a) {
          a(this.needle), a(this.haystack), this.fromIndex && a(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class me {
        constructor(a, d, p, v, x, E) {
          this.inputType = a, this.type = d, this.input = p, this.cases = v, this.outputs = x, this.otherwise = E;
        }
        static parse(a, d) {
          if (a.length < 5) return d.error(`Expected at least 4 arguments, but found only ${a.length - 1}.`);
          if (a.length % 2 != 1) return d.error("Expected an even number of arguments.");
          let p, v;
          d.expectedType && d.expectedType.kind !== "value" && (v = d.expectedType);
          const x = {}, E = [];
          for (let F = 2; F < a.length - 1; F += 2) {
            let j = a[F];
            const q = a[F + 1];
            Array.isArray(j) || (j = [j]);
            const Y = d.concat(F);
            if (j.length === 0) return Y.error("Expected at least one branch label.");
            for (const se of j) {
              if (typeof se != "number" && typeof se != "string") return Y.error("Branch labels must be numbers or strings.");
              if (typeof se == "number" && Math.abs(se) > Number.MAX_SAFE_INTEGER) return Y.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof se == "number" && Math.floor(se) !== se) return Y.error("Numeric branch labels must be integer values.");
              if (p) {
                if (Y.checkSubtype(p, yr(se))) return null;
              } else p = yr(se);
              if (x[String(se)] !== void 0) return Y.error("Branch labels must be unique.");
              x[String(se)] = E.length;
            }
            const ee = d.parse(q, F, v);
            if (!ee) return null;
            v = v || ee.type, E.push(ee);
          }
          const L = d.parse(a[1], 1, zt);
          if (!L) return null;
          const R = d.parse(a[a.length - 1], a.length - 1, v);
          return R ? L.type.kind !== "value" && d.concat(1).checkSubtype(p, L.type) ? null : new me(p, v, L, x, E, R) : null;
        }
        evaluate(a) {
          const d = this.input.evaluate(a);
          return (yr(d) === this.inputType && this.outputs[this.cases[d]] || this.otherwise).evaluate(a);
        }
        eachChild(a) {
          a(this.input), this.outputs.forEach(a), a(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((a) => a.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class De {
        constructor(a, d, p) {
          this.type = a, this.branches = d, this.otherwise = p;
        }
        static parse(a, d) {
          if (a.length < 4) return d.error(`Expected at least 3 arguments, but found only ${a.length - 1}.`);
          if (a.length % 2 != 0) return d.error("Expected an odd number of arguments.");
          let p;
          d.expectedType && d.expectedType.kind !== "value" && (p = d.expectedType);
          const v = [];
          for (let E = 1; E < a.length - 1; E += 2) {
            const L = d.parse(a[E], E, jt);
            if (!L) return null;
            const R = d.parse(a[E + 1], E + 1, p);
            if (!R) return null;
            v.push([L, R]), p = p || R.type;
          }
          const x = d.parse(a[a.length - 1], a.length - 1, p);
          if (!x) return null;
          if (!p) throw new Error("Can't infer output type");
          return new De(p, v, x);
        }
        evaluate(a) {
          for (const [d, p] of this.branches) if (d.evaluate(a)) return p.evaluate(a);
          return this.otherwise.evaluate(a);
        }
        eachChild(a) {
          for (const [d, p] of this.branches) a(d), a(p);
          a(this.otherwise);
        }
        outputDefined() {
          return this.branches.every((a) => {
            let [d, p] = a;
            return p.outputDefined();
          }) && this.otherwise.outputDefined();
        }
      }
      class nt {
        constructor(a, d, p, v) {
          this.type = a, this.input = d, this.beginIndex = p, this.endIndex = v;
        }
        static parse(a, d) {
          if (a.length <= 2 || a.length >= 5) return d.error(`Expected 3 or 4 arguments, but found ${a.length - 1} instead.`);
          const p = d.parse(a[1], 1, zt), v = d.parse(a[2], 2, mt);
          if (!p || !v) return null;
          if (!Fe(p.type, [J(zt), bn, zt])) return d.error(`Expected first argument to be of type array or string, but found ${K(p.type)} instead`);
          if (a.length === 4) {
            const x = d.parse(a[3], 3, mt);
            return x ? new nt(p.type, p, v, x) : null;
          }
          return new nt(p.type, p, v);
        }
        evaluate(a) {
          const d = this.input.evaluate(a), p = this.beginIndex.evaluate(a);
          let v;
          if (this.endIndex && (v = this.endIndex.evaluate(a)), je(d, ["string"])) return [...d].slice(p, v).join("");
          if (je(d, ["array"])) return d.slice(p, v);
          throw new pr(`Expected first argument to be of type array or string, but found ${K(yr(d))} instead.`);
        }
        eachChild(a) {
          a(this.input), a(this.beginIndex), this.endIndex && a(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function Tt(u, a) {
        const d = u.length - 1;
        let p, v, x = 0, E = d, L = 0;
        for (; x <= E; ) if (L = Math.floor((x + E) / 2), p = u[L], v = u[L + 1], p <= a) {
          if (L === d || a < v) return L;
          x = L + 1;
        } else {
          if (!(p > a)) throw new pr("Input is not a number.");
          E = L - 1;
        }
        return 0;
      }
      class Vt {
        constructor(a, d, p) {
          this.type = a, this.input = d, this.labels = [], this.outputs = [];
          for (const [v, x] of p) this.labels.push(v), this.outputs.push(x);
        }
        static parse(a, d) {
          if (a.length - 1 < 4) return d.error(`Expected at least 4 arguments, but found only ${a.length - 1}.`);
          if ((a.length - 1) % 2 != 0) return d.error("Expected an even number of arguments.");
          const p = d.parse(a[1], 1, mt);
          if (!p) return null;
          const v = [];
          let x = null;
          d.expectedType && d.expectedType.kind !== "value" && (x = d.expectedType);
          for (let E = 1; E < a.length; E += 2) {
            const L = E === 1 ? -1 / 0 : a[E], R = a[E + 1], F = E, j = E + 1;
            if (typeof L != "number") return d.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', F);
            if (v.length && v[v.length - 1][0] >= L) return d.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', F);
            const q = d.parse(R, j, x);
            if (!q) return null;
            x = x || q.type, v.push([L, q]);
          }
          return new Vt(x, p, v);
        }
        evaluate(a) {
          const d = this.labels, p = this.outputs;
          if (d.length === 1) return p[0].evaluate(a);
          const v = this.input.evaluate(a);
          if (v <= d[0]) return p[0].evaluate(a);
          const x = d.length;
          return v >= d[x - 1] ? p[x - 1].evaluate(a) : p[Tt(d, v)].evaluate(a);
        }
        eachChild(a) {
          a(this.input);
          for (const d of this.outputs) a(d);
        }
        outputDefined() {
          return this.outputs.every((a) => a.outputDefined());
        }
      }
      function Pn(u) {
        return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
      }
      var Br = Rr;
      function Rr(u, a, d, p) {
        this.cx = 3 * u, this.bx = 3 * (d - u) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * a, this.by = 3 * (p - a) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = u, this.p1y = a, this.p2x = d, this.p2y = p;
      }
      Rr.prototype = { sampleCurveX: function(u) {
        return ((this.ax * u + this.bx) * u + this.cx) * u;
      }, sampleCurveY: function(u) {
        return ((this.ay * u + this.by) * u + this.cy) * u;
      }, sampleCurveDerivativeX: function(u) {
        return (3 * this.ax * u + 2 * this.bx) * u + this.cx;
      }, solveCurveX: function(u, a) {
        if (a === void 0 && (a = 1e-6), u < 0) return 0;
        if (u > 1) return 1;
        for (var d = u, p = 0; p < 8; p++) {
          var v = this.sampleCurveX(d) - u;
          if (Math.abs(v) < a) return d;
          var x = this.sampleCurveDerivativeX(d);
          if (Math.abs(x) < 1e-6) break;
          d -= v / x;
        }
        var E = 0, L = 1;
        for (d = u, p = 0; p < 20 && (v = this.sampleCurveX(d), !(Math.abs(v - u) < a)); p++) u > v ? E = d : L = d, d = 0.5 * (L - E) + E;
        return d;
      }, solve: function(u, a) {
        return this.sampleCurveY(this.solveCurveX(u, a));
      } };
      var ui = Pn(Br);
      function nr(u, a, d) {
        return u + d * (a - u);
      }
      function Ka(u, a, d) {
        return u.map((p, v) => nr(p, a[v], d));
      }
      const Ii = { number: nr, color: function(u, a, d) {
        switch (arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rgb") {
          case "rgb": {
            const [v, x, E, L] = Ka(u.rgb, a.rgb, d);
            return new Jn(v, x, E, L, !1);
          }
          case "hcl": {
            const [v, x, E, L] = u.hcl, [R, F, j, q] = a.hcl;
            let Y, ee;
            if (isNaN(v) || isNaN(R)) isNaN(v) ? isNaN(R) ? Y = NaN : (Y = R, E !== 1 && E !== 0 || (ee = F)) : (Y = v, j !== 1 && j !== 0 || (ee = x));
            else {
              let $e = R - v;
              R > v && $e > 180 ? $e -= 360 : R < v && v - R > 180 && ($e += 360), Y = v + d * $e;
            }
            const [se, de, we, Me] = function($e) {
              let [Ne, Ve, it, At] = $e;
              return Ne = isNaN(Ne) ? 0 : Ne * Kt, Wn([it, Math.cos(Ne) * Ve, Math.sin(Ne) * Ve, At]);
            }([Y, ee ?? nr(x, F, d), nr(E, j, d), nr(L, q, d)]);
            return new Jn(se, de, we, Me, !1);
          }
          case "lab": {
            const [v, x, E, L] = Wn(Ka(u.lab, a.lab, d));
            return new Jn(v, x, E, L, !1);
          }
        }
      }, array: Ka, padding: function(u, a, d) {
        return new Lr(Ka(u.values, a.values, d));
      }, variableAnchorOffsetCollection: function(u, a, d) {
        const p = u.values, v = a.values;
        if (p.length !== v.length) throw new pr(`Cannot interpolate values of different length. from: ${u.toString()}, to: ${a.toString()}`);
        const x = [];
        for (let E = 0; E < p.length; E += 2) {
          if (p[E] !== v[E]) throw new pr(`Cannot interpolate values containing mismatched anchors. from[${E}]: ${p[E]}, to[${E}]: ${v[E]}`);
          x.push(p[E]);
          const [L, R] = p[E + 1], [F, j] = v[E + 1];
          x.push([nr(L, F, d), nr(R, j, d)]);
        }
        return new Mr(x);
      } };
      class dn {
        constructor(a, d, p, v, x) {
          this.type = a, this.operator = d, this.interpolation = p, this.input = v, this.labels = [], this.outputs = [];
          for (const [E, L] of x) this.labels.push(E), this.outputs.push(L);
        }
        static interpolationFactor(a, d, p, v) {
          let x = 0;
          if (a.name === "exponential") x = Ll(d, a.base, p, v);
          else if (a.name === "linear") x = Ll(d, 1, p, v);
          else if (a.name === "cubic-bezier") {
            const E = a.controlPoints;
            x = new ui(E[0], E[1], E[2], E[3]).solve(Ll(d, 1, p, v));
          }
          return x;
        }
        static parse(a, d) {
          let [p, v, x, ...E] = a;
          if (!Array.isArray(v) || v.length === 0) return d.error("Expected an interpolation type expression.", 1);
          if (v[0] === "linear") v = { name: "linear" };
          else if (v[0] === "exponential") {
            const F = v[1];
            if (typeof F != "number") return d.error("Exponential interpolation requires a numeric base.", 1, 1);
            v = { name: "exponential", base: F };
          } else {
            if (v[0] !== "cubic-bezier") return d.error(`Unknown interpolation type ${String(v[0])}`, 1, 0);
            {
              const F = v.slice(1);
              if (F.length !== 4 || F.some((j) => typeof j != "number" || j < 0 || j > 1)) return d.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              v = { name: "cubic-bezier", controlPoints: F };
            }
          }
          if (a.length - 1 < 4) return d.error(`Expected at least 4 arguments, but found only ${a.length - 1}.`);
          if ((a.length - 1) % 2 != 0) return d.error("Expected an even number of arguments.");
          if (x = d.parse(x, 2, mt), !x) return null;
          const L = [];
          let R = null;
          p === "interpolate-hcl" || p === "interpolate-lab" ? R = qn : d.expectedType && d.expectedType.kind !== "value" && (R = d.expectedType);
          for (let F = 0; F < E.length; F += 2) {
            const j = E[F], q = E[F + 1], Y = F + 3, ee = F + 4;
            if (typeof j != "number") return d.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', Y);
            if (L.length && L[L.length - 1][0] >= j) return d.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', Y);
            const se = d.parse(q, ee, R);
            if (!se) return null;
            R = R || se.type, L.push([j, se]);
          }
          return Oe(R, mt) || Oe(R, qn) || Oe(R, ti) || Oe(R, be) || Oe(R, J(mt)) ? new dn(R, p, v, x, L) : d.error(`Type ${K(R)} is not interpolatable.`);
        }
        evaluate(a) {
          const d = this.labels, p = this.outputs;
          if (d.length === 1) return p[0].evaluate(a);
          const v = this.input.evaluate(a);
          if (v <= d[0]) return p[0].evaluate(a);
          const x = d.length;
          if (v >= d[x - 1]) return p[x - 1].evaluate(a);
          const E = Tt(d, v), L = dn.interpolationFactor(this.interpolation, v, d[E], d[E + 1]), R = p[E].evaluate(a), F = p[E + 1].evaluate(a);
          switch (this.operator) {
            case "interpolate":
              return Ii[this.type.kind](R, F, L);
            case "interpolate-hcl":
              return Ii.color(R, F, L, "hcl");
            case "interpolate-lab":
              return Ii.color(R, F, L, "lab");
          }
        }
        eachChild(a) {
          a(this.input);
          for (const d of this.outputs) a(d);
        }
        outputDefined() {
          return this.outputs.every((a) => a.outputDefined());
        }
      }
      function Ll(u, a, d, p) {
        const v = p - d, x = u - d;
        return v === 0 ? 0 : a === 1 ? x / v : (Math.pow(a, x) - 1) / (Math.pow(a, v) - 1);
      }
      class Ml {
        constructor(a, d) {
          this.type = a, this.args = d;
        }
        static parse(a, d) {
          if (a.length < 2) return d.error("Expectected at least one argument.");
          let p = null;
          const v = d.expectedType;
          v && v.kind !== "value" && (p = v);
          const x = [];
          for (const L of a.slice(1)) {
            const R = d.parse(L, 1 + x.length, p, void 0, { typeAnnotation: "omit" });
            if (!R) return null;
            p = p || R.type, x.push(R);
          }
          if (!p) throw new Error("No output type");
          const E = v && x.some((L) => ye(v, L.type));
          return new Ml(E ? zt : p, x);
        }
        evaluate(a) {
          let d, p = null, v = 0;
          for (const x of this.args) if (v++, p = x.evaluate(a), p && p instanceof Er && !p.available && (d || (d = p.name), p = null, v === this.args.length && (p = d)), p !== null) break;
          return p;
        }
        eachChild(a) {
          this.args.forEach(a);
        }
        outputDefined() {
          return this.args.every((a) => a.outputDefined());
        }
      }
      function xs(u, a) {
        return u === "==" || u === "!=" ? a.kind === "boolean" || a.kind === "string" || a.kind === "number" || a.kind === "null" || a.kind === "value" : a.kind === "string" || a.kind === "number" || a.kind === "value";
      }
      function Sc(u, a, d, p) {
        return p.compare(a, d) === 0;
      }
      function Jo(u, a, d) {
        const p = u !== "==" && u !== "!=";
        return class A5 {
          constructor(x, E, L) {
            this.type = jt, this.lhs = x, this.rhs = E, this.collator = L, this.hasUntypedArgument = x.type.kind === "value" || E.type.kind === "value";
          }
          static parse(x, E) {
            if (x.length !== 3 && x.length !== 4) return E.error("Expected two or three arguments.");
            const L = x[0];
            let R = E.parse(x[1], 1, zt);
            if (!R) return null;
            if (!xs(L, R.type)) return E.concat(1).error(`"${L}" comparisons are not supported for type '${K(R.type)}'.`);
            let F = E.parse(x[2], 2, zt);
            if (!F) return null;
            if (!xs(L, F.type)) return E.concat(2).error(`"${L}" comparisons are not supported for type '${K(F.type)}'.`);
            if (R.type.kind !== F.type.kind && R.type.kind !== "value" && F.type.kind !== "value") return E.error(`Cannot compare types '${K(R.type)}' and '${K(F.type)}'.`);
            p && (R.type.kind === "value" && F.type.kind !== "value" ? R = new pi(F.type, [R]) : R.type.kind !== "value" && F.type.kind === "value" && (F = new pi(R.type, [F])));
            let j = null;
            if (x.length === 4) {
              if (R.type.kind !== "string" && F.type.kind !== "string" && R.type.kind !== "value" && F.type.kind !== "value") return E.error("Cannot use collator to compare non-string types.");
              if (j = E.parse(x[3], 3, yi), !j) return null;
            }
            return new A5(R, F, j);
          }
          evaluate(x) {
            const E = this.lhs.evaluate(x), L = this.rhs.evaluate(x);
            if (p && this.hasUntypedArgument) {
              const R = yr(E), F = yr(L);
              if (R.kind !== F.kind || R.kind !== "string" && R.kind !== "number") throw new pr(`Expected arguments for "${u}" to be (string, string) or (number, number), but found (${R.kind}, ${F.kind}) instead.`);
            }
            if (this.collator && !p && this.hasUntypedArgument) {
              const R = yr(E), F = yr(L);
              if (R.kind !== "string" || F.kind !== "string") return a(x, E, L);
            }
            return this.collator ? d(x, E, L, this.collator.evaluate(x)) : a(x, E, L);
          }
          eachChild(x) {
            x(this.lhs), x(this.rhs), this.collator && x(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const Bl = Jo("==", function(u, a, d) {
        return a === d;
      }, Sc), Rl = Jo("!=", function(u, a, d) {
        return a !== d;
      }, function(u, a, d, p) {
        return !Sc(0, a, d, p);
      }), uu = Jo("<", function(u, a, d) {
        return a < d;
      }, function(u, a, d, p) {
        return p.compare(a, d) < 0;
      }), Zu = Jo(">", function(u, a, d) {
        return a > d;
      }, function(u, a, d, p) {
        return p.compare(a, d) > 0;
      }), Ju = Jo("<=", function(u, a, d) {
        return a <= d;
      }, function(u, a, d, p) {
        return p.compare(a, d) <= 0;
      }), Ol = Jo(">=", function(u, a, d) {
        return a >= d;
      }, function(u, a, d, p) {
        return p.compare(a, d) >= 0;
      });
      class co {
        constructor(a, d, p) {
          this.type = yi, this.locale = p, this.caseSensitive = a, this.diacriticSensitive = d;
        }
        static parse(a, d) {
          if (a.length !== 2) return d.error("Expected one argument.");
          const p = a[1];
          if (typeof p != "object" || Array.isArray(p)) return d.error("Collator options argument must be an object.");
          const v = d.parse(p["case-sensitive"] !== void 0 && p["case-sensitive"], 1, jt);
          if (!v) return null;
          const x = d.parse(p["diacritic-sensitive"] !== void 0 && p["diacritic-sensitive"], 1, jt);
          if (!x) return null;
          let E = null;
          return p.locale && (E = d.parse(p.locale, 1, bn), !E) ? null : new co(v, x, E);
        }
        evaluate(a) {
          return new bi(this.caseSensitive.evaluate(a), this.diacriticSensitive.evaluate(a), this.locale ? this.locale.evaluate(a) : null);
        }
        eachChild(a) {
          a(this.caseSensitive), a(this.diacriticSensitive), this.locale && a(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class To {
        constructor(a, d, p, v, x) {
          this.type = bn, this.number = a, this.locale = d, this.currency = p, this.minFractionDigits = v, this.maxFractionDigits = x;
        }
        static parse(a, d) {
          if (a.length !== 3) return d.error("Expected two arguments.");
          const p = d.parse(a[1], 1, mt);
          if (!p) return null;
          const v = a[2];
          if (typeof v != "object" || Array.isArray(v)) return d.error("NumberFormat options argument must be an object.");
          let x = null;
          if (v.locale && (x = d.parse(v.locale, 1, bn), !x)) return null;
          let E = null;
          if (v.currency && (E = d.parse(v.currency, 1, bn), !E)) return null;
          let L = null;
          if (v["min-fraction-digits"] && (L = d.parse(v["min-fraction-digits"], 1, mt), !L)) return null;
          let R = null;
          return v["max-fraction-digits"] && (R = d.parse(v["max-fraction-digits"], 1, mt), !R) ? null : new To(p, x, E, L, R);
        }
        evaluate(a) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(a) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(a) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(a) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(a) : void 0 }).format(this.number.evaluate(a));
        }
        eachChild(a) {
          a(this.number), this.locale && a(this.locale), this.currency && a(this.currency), this.minFractionDigits && a(this.minFractionDigits), this.maxFractionDigits && a(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class Dl {
        constructor(a) {
          this.type = rr, this.sections = a;
        }
        static parse(a, d) {
          if (a.length < 2) return d.error("Expected at least one argument.");
          const p = a[1];
          if (!Array.isArray(p) && typeof p == "object") return d.error("First argument must be an image or text section.");
          const v = [];
          let x = !1;
          for (let E = 1; E <= a.length - 1; ++E) {
            const L = a[E];
            if (x && typeof L == "object" && !Array.isArray(L)) {
              x = !1;
              let R = null;
              if (L["font-scale"] && (R = d.parse(L["font-scale"], 1, mt), !R)) return null;
              let F = null;
              if (L["text-font"] && (F = d.parse(L["text-font"], 1, J(bn)), !F)) return null;
              let j = null;
              if (L["text-color"] && (j = d.parse(L["text-color"], 1, qn), !j)) return null;
              const q = v[v.length - 1];
              q.scale = R, q.font = F, q.textColor = j;
            } else {
              const R = d.parse(a[E], 1, zt);
              if (!R) return null;
              const F = R.type.kind;
              if (F !== "string" && F !== "value" && F !== "null" && F !== "resolvedImage") return d.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              x = !0, v.push({ content: R, scale: null, font: null, textColor: null });
            }
          }
          return new Dl(v);
        }
        evaluate(a) {
          return new Pr(this.sections.map((d) => {
            const p = d.content.evaluate(a);
            return yr(p) === ni ? new Xi("", p, null, null, null) : new Xi(Yn(p), null, d.scale ? d.scale.evaluate(a) : null, d.font ? d.font.evaluate(a).join(",") : null, d.textColor ? d.textColor.evaluate(a) : null);
          }));
        }
        eachChild(a) {
          for (const d of this.sections) a(d.content), d.scale && a(d.scale), d.font && a(d.font), d.textColor && a(d.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Yo {
        constructor(a) {
          this.type = ni, this.input = a;
        }
        static parse(a, d) {
          if (a.length !== 2) return d.error("Expected two arguments.");
          const p = d.parse(a[1], 1, bn);
          return p ? new Yo(p) : d.error("No image name provided.");
        }
        evaluate(a) {
          const d = this.input.evaluate(a), p = Er.fromString(d);
          return p && a.availableImages && (p.available = a.availableImages.indexOf(d) > -1), p;
        }
        eachChild(a) {
          a(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Qa {
        constructor(a) {
          this.type = mt, this.input = a;
        }
        static parse(a, d) {
          if (a.length !== 2) return d.error(`Expected 1 argument, but found ${a.length - 1} instead.`);
          const p = d.parse(a[1], 1);
          return p ? p.type.kind !== "array" && p.type.kind !== "string" && p.type.kind !== "value" ? d.error(`Expected argument of type string or array, but found ${K(p.type)} instead.`) : new Qa(p) : null;
        }
        evaluate(a) {
          const d = this.input.evaluate(a);
          if (typeof d == "string") return [...d].length;
          if (Array.isArray(d)) return d.length;
          throw new pr(`Expected value to be of type string or array, but found ${K(yr(d))} instead.`);
        }
        eachChild(a) {
          a(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const Yi = 8192;
      function hu(u, a) {
        const d = (180 + u[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + u[1] * Math.PI / 360))) / 360, v = Math.pow(2, a.z);
        return [Math.round(d * v * Yi), Math.round(p * v * Yi)];
      }
      function Fl(u, a) {
        const d = Math.pow(2, a.z);
        return [(v = (u[0] / Yi + a.x) / d, 360 * v - 180), (p = (u[1] / Yi + a.y) / d, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * p) * Math.PI / 180)) - 90)];
        var p, v;
      }
      function Co(u, a) {
        u[0] = Math.min(u[0], a[0]), u[1] = Math.min(u[1], a[1]), u[2] = Math.max(u[2], a[0]), u[3] = Math.max(u[3], a[1]);
      }
      function uo(u, a) {
        return !(u[0] <= a[0] || u[2] >= a[2] || u[1] <= a[1] || u[3] >= a[3]);
      }
      function jn(u, a, d) {
        const p = u[0] - a[0], v = u[1] - a[1], x = u[0] - d[0], E = u[1] - d[1];
        return p * E - x * v == 0 && p * x <= 0 && v * E <= 0;
      }
      function ho(u, a, d, p) {
        return (v = [p[0] - d[0], p[1] - d[1]])[0] * (x = [a[0] - u[0], a[1] - u[1]])[1] - v[1] * x[0] != 0 && !(!du(u, a, d, p) || !du(d, p, u, a));
        var v, x;
      }
      function Yu(u, a, d) {
        for (const p of d) for (let v = 0; v < p.length - 1; ++v) if (ho(u, a, p[v], p[v + 1])) return !0;
        return !1;
      }
      function ws(u, a) {
        let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, p = !1;
        for (const L of a) for (let R = 0; R < L.length - 1; R++) {
          if (jn(u, L[R], L[R + 1])) return d;
          (x = L[R])[1] > (v = u)[1] != (E = L[R + 1])[1] > v[1] && v[0] < (E[0] - x[0]) * (v[1] - x[1]) / (E[1] - x[1]) + x[0] && (p = !p);
        }
        var v, x, E;
        return p;
      }
      function fo(u, a) {
        for (const d of a) if (ws(u, d)) return !0;
        return !1;
      }
      function kl(u, a) {
        for (const d of u) if (!ws(d, a)) return !1;
        for (let d = 0; d < u.length - 1; ++d) if (Yu(u[d], u[d + 1], a)) return !1;
        return !0;
      }
      function el(u, a) {
        for (const d of a) if (kl(u, d)) return !0;
        return !1;
      }
      function du(u, a, d, p) {
        const v = p[0] - d[0], x = p[1] - d[1], E = (u[0] - d[0]) * x - v * (u[1] - d[1]), L = (a[0] - d[0]) * x - v * (a[1] - d[1]);
        return E > 0 && L < 0 || E < 0 && L > 0;
      }
      function Ea(u, a, d) {
        const p = [];
        for (let v = 0; v < u.length; v++) {
          const x = [];
          for (let E = 0; E < u[v].length; E++) {
            const L = hu(u[v][E], d);
            Co(a, L), x.push(L);
          }
          p.push(x);
        }
        return p;
      }
      function fu(u, a, d) {
        const p = [];
        for (let v = 0; v < u.length; v++) {
          const x = Ea(u[v], a, d);
          p.push(x);
        }
        return p;
      }
      function Nl(u, a, d, p) {
        if (u[0] < d[0] || u[0] > d[2]) {
          const v = 0.5 * p;
          let x = u[0] - d[0] > v ? -p : d[0] - u[0] > v ? p : 0;
          x === 0 && (x = u[0] - d[2] > v ? -p : d[2] - u[0] > v ? p : 0), u[0] += x;
        }
        Co(a, u);
      }
      function zl(u, a, d, p) {
        const v = Math.pow(2, p.z) * Yi, x = [p.x * Yi, p.y * Yi], E = [];
        for (const L of u) for (const R of L) {
          const F = [R.x + x[0], R.y + x[1]];
          Nl(F, a, d, v), E.push(F);
        }
        return E;
      }
      function Ec(u, a, d, p) {
        const v = Math.pow(2, p.z) * Yi, x = [p.x * Yi, p.y * Yi], E = [];
        for (const R of u) {
          const F = [];
          for (const j of R) {
            const q = [j.x + x[0], j.y + x[1]];
            Co(a, q), F.push(q);
          }
          E.push(F);
        }
        if (a[2] - a[0] <= v / 2) {
          (L = a)[0] = L[1] = 1 / 0, L[2] = L[3] = -1 / 0;
          for (const R of E) for (const F of R) Nl(F, a, d, v);
        }
        var L;
        return E;
      }
      class Os {
        constructor(a, d) {
          this.type = jt, this.geojson = a, this.geometries = d;
        }
        static parse(a, d) {
          if (a.length !== 2) return d.error(`'within' expression requires exactly one argument, but found ${a.length - 1} instead.`);
          if ($i(a[1])) {
            const p = a[1];
            if (p.type === "FeatureCollection") {
              const v = [];
              for (const x of p.features) {
                const { type: E, coordinates: L } = x.geometry;
                E === "Polygon" && v.push(L), E === "MultiPolygon" && v.push(...L);
              }
              if (v.length) return new Os(p, { type: "MultiPolygon", coordinates: v });
            } else if (p.type === "Feature") {
              const v = p.geometry.type;
              if (v === "Polygon" || v === "MultiPolygon") return new Os(p, p.geometry);
            } else if (p.type === "Polygon" || p.type === "MultiPolygon") return new Os(p, p);
          }
          return d.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(a) {
          if (a.geometry() != null && a.canonicalID() != null) {
            if (a.geometryType() === "Point") return function(d, p) {
              const v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], E = d.canonicalID();
              if (p.type === "Polygon") {
                const L = Ea(p.coordinates, x, E), R = zl(d.geometry(), v, x, E);
                if (!uo(v, x)) return !1;
                for (const F of R) if (!ws(F, L)) return !1;
              }
              if (p.type === "MultiPolygon") {
                const L = fu(p.coordinates, x, E), R = zl(d.geometry(), v, x, E);
                if (!uo(v, x)) return !1;
                for (const F of R) if (!fo(F, L)) return !1;
              }
              return !0;
            }(a, this.geometries);
            if (a.geometryType() === "LineString") return function(d, p) {
              const v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], E = d.canonicalID();
              if (p.type === "Polygon") {
                const L = Ea(p.coordinates, x, E), R = Ec(d.geometry(), v, x, E);
                if (!uo(v, x)) return !1;
                for (const F of R) if (!kl(F, L)) return !1;
              }
              if (p.type === "MultiPolygon") {
                const L = fu(p.coordinates, x, E), R = Ec(d.geometry(), v, x, E);
                if (!uo(v, x)) return !1;
                for (const F of R) if (!el(F, L)) return !1;
              }
              return !0;
            }(a, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let Ul = class {
        constructor() {
          let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (d, p) => d < p ? -1 : d > p ? 1 : 0;
          if (this.data = u, this.length = this.data.length, this.compare = a, this.length > 0) for (let d = (this.length >> 1) - 1; d >= 0; d--) this._down(d);
        }
        push(u) {
          this.data.push(u), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const u = this.data[0], a = this.data.pop();
          return --this.length > 0 && (this.data[0] = a, this._down(0)), u;
        }
        peek() {
          return this.data[0];
        }
        _up(u) {
          const { data: a, compare: d } = this, p = a[u];
          for (; u > 0; ) {
            const v = u - 1 >> 1, x = a[v];
            if (d(p, x) >= 0) break;
            a[u] = x, u = v;
          }
          a[u] = p;
        }
        _down(u) {
          const { data: a, compare: d } = this, p = this.length >> 1, v = a[u];
          for (; u < p; ) {
            let x = 1 + (u << 1);
            const E = x + 1;
            if (E < this.length && d(a[E], a[x]) < 0 && (x = E), d(a[x], v) >= 0) break;
            a[u] = a[x], u = x;
          }
          a[u] = v;
        }
      };
      function Tc(u, a, d, p, v) {
        Cc(u, a, d, p || u.length - 1, v || jl);
      }
      function Cc(u, a, d, p, v) {
        for (; p > d; ) {
          if (p - d > 600) {
            var x = p - d + 1, E = a - d + 1, L = Math.log(x), R = 0.5 * Math.exp(2 * L / 3), F = 0.5 * Math.sqrt(L * R * (x - R) / x) * (E - x / 2 < 0 ? -1 : 1);
            Cc(u, a, Math.max(d, Math.floor(a - E * R / x + F)), Math.min(p, Math.floor(a + (x - E) * R / x + F)), v);
          }
          var j = u[a], q = d, Y = p;
          for (tl(u, d, a), v(u[p], j) > 0 && tl(u, d, p); q < Y; ) {
            for (tl(u, q, Y), q++, Y--; v(u[q], j) < 0; ) q++;
            for (; v(u[Y], j) > 0; ) Y--;
          }
          v(u[d], j) === 0 ? tl(u, d, Y) : tl(u, ++Y, p), Y <= a && (d = Y + 1), a <= Y && (p = Y - 1);
        }
      }
      function tl(u, a, d) {
        var p = u[a];
        u[a] = u[d], u[d] = p;
      }
      function jl(u, a) {
        return u < a ? -1 : u > a ? 1 : 0;
      }
      function Io(u, a) {
        if (u.length <= 1) return [u];
        const d = [];
        let p, v;
        for (const x of u) {
          const E = Ta(x);
          E !== 0 && (x.area = Math.abs(E), v === void 0 && (v = E < 0), v === E < 0 ? (p && d.push(p), p = [x]) : p.push(x));
        }
        if (p && d.push(p), a > 1) for (let x = 0; x < d.length; x++) d[x].length <= a || (Tc(d[x], a, 1, d[x].length - 1, Ic), d[x] = d[x].slice(0, a));
        return d;
      }
      function Ic(u, a) {
        return a.area - u.area;
      }
      function Ta(u) {
        let a = 0;
        for (let d, p, v = 0, x = u.length, E = x - 1; v < x; E = v++) d = u[v], p = u[E], a += (p.x - d.x) * (d.y + p.y);
        return a;
      }
      const Gl = 1 / 298.257223563, O = Gl * (2 - Gl), te = Math.PI / 180;
      class Ee {
        constructor(a) {
          const d = 6378.137 * te * 1e3, p = Math.cos(a * te), v = 1 / (1 - O * (1 - p * p)), x = Math.sqrt(v);
          this.kx = d * x * p, this.ky = d * x * v * (1 - O);
        }
        distance(a, d) {
          const p = this.wrap(a[0] - d[0]) * this.kx, v = (a[1] - d[1]) * this.ky;
          return Math.sqrt(p * p + v * v);
        }
        pointOnLine(a, d) {
          let p, v, x, E, L = 1 / 0;
          for (let R = 0; R < a.length - 1; R++) {
            let F = a[R][0], j = a[R][1], q = this.wrap(a[R + 1][0] - F) * this.kx, Y = (a[R + 1][1] - j) * this.ky, ee = 0;
            q === 0 && Y === 0 || (ee = (this.wrap(d[0] - F) * this.kx * q + (d[1] - j) * this.ky * Y) / (q * q + Y * Y), ee > 1 ? (F = a[R + 1][0], j = a[R + 1][1]) : ee > 0 && (F += q / this.kx * ee, j += Y / this.ky * ee)), q = this.wrap(d[0] - F) * this.kx, Y = (d[1] - j) * this.ky;
            const se = q * q + Y * Y;
            se < L && (L = se, p = F, v = j, x = R, E = ee);
          }
          return { point: [p, v], index: x, t: Math.max(0, Math.min(1, E)) };
        }
        wrap(a) {
          for (; a < -180; ) a += 360;
          for (; a > 180; ) a -= 360;
          return a;
        }
      }
      function ze(u, a) {
        return a[0] - u[0];
      }
      function Xe(u) {
        return u[1] - u[0] + 1;
      }
      function lt(u, a) {
        return u[1] >= u[0] && u[1] < a;
      }
      function Pt(u, a) {
        if (u[0] > u[1]) return [null, null];
        const d = Xe(u);
        if (a) {
          if (d === 2) return [u, null];
          const v = Math.floor(d / 2);
          return [[u[0], u[0] + v], [u[0] + v, u[1]]];
        }
        if (d === 1) return [u, null];
        const p = Math.floor(d / 2) - 1;
        return [[u[0], u[0] + p], [u[0] + p + 1, u[1]]];
      }
      function Wt(u, a) {
        if (!lt(a, u.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const d = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let p = a[0]; p <= a[1]; ++p) Co(d, u[p]);
        return d;
      }
      function _n(u) {
        const a = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const d of u) for (const p of d) Co(a, p);
        return a;
      }
      function Ln(u) {
        return u[0] !== -1 / 0 && u[1] !== -1 / 0 && u[2] !== 1 / 0 && u[3] !== 1 / 0;
      }
      function kn(u, a, d) {
        if (!Ln(u) || !Ln(a)) return NaN;
        let p = 0, v = 0;
        return u[2] < a[0] && (p = a[0] - u[2]), u[0] > a[2] && (p = u[0] - a[2]), u[1] > a[3] && (v = u[1] - a[3]), u[3] < a[1] && (v = a[1] - u[3]), d.distance([0, 0], [p, v]);
      }
      function Gn(u, a, d) {
        const p = d.pointOnLine(a, u);
        return d.distance(u, p.point);
      }
      function Or(u, a, d, p, v) {
        const x = Math.min(Gn(u, [d, p], v), Gn(a, [d, p], v)), E = Math.min(Gn(d, [u, a], v), Gn(p, [u, a], v));
        return Math.min(x, E);
      }
      function ri(u, a, d, p, v) {
        if (!lt(a, u.length) || !lt(p, d.length)) return 1 / 0;
        let x = 1 / 0;
        for (let E = a[0]; E < a[1]; ++E) {
          const L = u[E], R = u[E + 1];
          for (let F = p[0]; F < p[1]; ++F) {
            const j = d[F], q = d[F + 1];
            if (ho(L, R, j, q)) return 0;
            x = Math.min(x, Or(L, R, j, q, v));
          }
        }
        return x;
      }
      function Nn(u, a, d, p, v) {
        if (!lt(a, u.length) || !lt(p, d.length)) return NaN;
        let x = 1 / 0;
        for (let E = a[0]; E <= a[1]; ++E) for (let L = p[0]; L <= p[1]; ++L) if (x = Math.min(x, v.distance(u[E], d[L])), x === 0) return x;
        return x;
      }
      function Di(u, a, d) {
        if (ws(u, a, !0)) return 0;
        let p = 1 / 0;
        for (const v of a) {
          const x = v[0], E = v[v.length - 1];
          if (x !== E && (p = Math.min(p, Gn(u, [E, x], d)), p === 0)) return p;
          const L = d.pointOnLine(v, u);
          if (p = Math.min(p, d.distance(u, L.point)), p === 0) return p;
        }
        return p;
      }
      function fn(u, a, d, p) {
        if (!lt(a, u.length)) return NaN;
        for (let x = a[0]; x <= a[1]; ++x) if (ws(u[x], d, !0)) return 0;
        let v = 1 / 0;
        for (let x = a[0]; x < a[1]; ++x) {
          const E = u[x], L = u[x + 1];
          for (const R of d) for (let F = 0, j = R.length, q = j - 1; F < j; q = F++) {
            const Y = R[q], ee = R[F];
            if (ho(E, L, Y, ee)) return 0;
            v = Math.min(v, Or(E, L, Y, ee, p));
          }
        }
        return v;
      }
      function ls(u, a) {
        for (const d of u) for (const p of d) if (ws(p, a, !0)) return !0;
        return !1;
      }
      function $n(u, a, d) {
        let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / 0;
        const v = _n(u), x = _n(a);
        if (p !== 1 / 0 && kn(v, x, d) >= p) return p;
        if (uo(v, x)) {
          if (ls(u, a)) return 0;
        } else if (ls(a, u)) return 0;
        let E = 1 / 0;
        for (const L of u) for (let R = 0, F = L.length, j = F - 1; R < F; j = R++) {
          const q = L[j], Y = L[R];
          for (const ee of a) for (let se = 0, de = ee.length, we = de - 1; se < de; we = se++) {
            const Me = ee[we], $e = ee[se];
            if (ho(q, Y, Me, $e)) return 0;
            E = Math.min(E, Or(q, Y, Me, $e, d));
          }
        }
        return E;
      }
      function Kn(u, a, d, p, v, x) {
        if (!x) return;
        const E = kn(Wt(p, x), v, d);
        E < a && u.push([E, x, [0, 0]]);
      }
      function Po(u, a, d, p, v, x, E) {
        if (!x || !E) return;
        const L = kn(Wt(p, x), Wt(v, E), d);
        L < a && u.push([L, x, E]);
      }
      function Ko(u, a, d, p) {
        let v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1 / 0, x = Math.min(p.distance(u[0], d[0][0]), v);
        if (x === 0) return x;
        const E = new Ul([[0, [0, u.length - 1], [0, 0]]], ze), L = _n(d);
        for (; E.length > 0; ) {
          const R = E.pop();
          if (R[0] >= x) continue;
          const F = R[1], j = a ? 50 : 100;
          if (Xe(F) <= j) {
            if (!lt(F, u.length)) return NaN;
            if (a) {
              const q = fn(u, F, d, p);
              if (isNaN(q) || q === 0) return q;
              x = Math.min(x, q);
            } else for (let q = F[0]; q <= F[1]; ++q) {
              const Y = Di(u[q], d, p);
              if (x = Math.min(x, Y), x === 0) return 0;
            }
          } else {
            const q = Pt(F, a);
            Kn(E, x, p, u, L, q[0]), Kn(E, x, p, u, L, q[1]);
          }
        }
        return x;
      }
      function Qo(u, a, d, p, v) {
        let x = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0, E = Math.min(x, v.distance(u[0], d[0]));
        if (E === 0) return E;
        const L = new Ul([[0, [0, u.length - 1], [0, d.length - 1]]], ze);
        for (; L.length > 0; ) {
          const R = L.pop();
          if (R[0] >= E) continue;
          const F = R[1], j = R[2], q = a ? 50 : 100, Y = p ? 50 : 100;
          if (Xe(F) <= q && Xe(j) <= Y) {
            if (!lt(F, u.length) && lt(j, d.length)) return NaN;
            let ee;
            if (a && p) ee = ri(u, F, d, j, v), E = Math.min(E, ee);
            else if (a && !p) {
              const se = u.slice(F[0], F[1] + 1);
              for (let de = j[0]; de <= j[1]; ++de) if (ee = Gn(d[de], se, v), E = Math.min(E, ee), E === 0) return E;
            } else if (!a && p) {
              const se = d.slice(j[0], j[1] + 1);
              for (let de = F[0]; de <= F[1]; ++de) if (ee = Gn(u[de], se, v), E = Math.min(E, ee), E === 0) return E;
            } else ee = Nn(u, F, d, j, v), E = Math.min(E, ee);
          } else {
            const ee = Pt(F, a), se = Pt(j, p);
            Po(L, E, v, u, d, ee[0], se[0]), Po(L, E, v, u, d, ee[0], se[1]), Po(L, E, v, u, d, ee[1], se[0]), Po(L, E, v, u, d, ee[1], se[1]);
          }
        }
        return E;
      }
      function Ca(u) {
        return u.type === "MultiPolygon" ? u.coordinates.map((a) => ({ type: "Polygon", coordinates: a })) : u.type === "MultiLineString" ? u.coordinates.map((a) => ({ type: "LineString", coordinates: a })) : u.type === "MultiPoint" ? u.coordinates.map((a) => ({ type: "Point", coordinates: a })) : [u];
      }
      class po {
        constructor(a, d) {
          this.type = mt, this.geojson = a, this.geometries = d;
        }
        static parse(a, d) {
          if (a.length !== 2) return d.error(`'distance' expression requires exactly one argument, but found ${a.length - 1} instead.`);
          if ($i(a[1])) {
            const p = a[1];
            if (p.type === "FeatureCollection") return new po(p, p.features.map((v) => Ca(v.geometry)).flat());
            if (p.type === "Feature") return new po(p, Ca(p.geometry));
            if ("type" in p && "coordinates" in p) return new po(p, Ca(p));
          }
          return d.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(a) {
          if (a.geometry() != null && a.canonicalID() != null) {
            if (a.geometryType() === "Point") return function(d, p) {
              const v = d.geometry(), x = v.flat().map((R) => Fl([R.x, R.y], d.canonical));
              if (v.length === 0) return NaN;
              const E = new Ee(x[0][1]);
              let L = 1 / 0;
              for (const R of p) {
                switch (R.type) {
                  case "Point":
                    L = Math.min(L, Qo(x, !1, [R.coordinates], !1, E, L));
                    break;
                  case "LineString":
                    L = Math.min(L, Qo(x, !1, R.coordinates, !0, E, L));
                    break;
                  case "Polygon":
                    L = Math.min(L, Ko(x, !1, R.coordinates, E, L));
                }
                if (L === 0) return L;
              }
              return L;
            }(a, this.geometries);
            if (a.geometryType() === "LineString") return function(d, p) {
              const v = d.geometry(), x = v.flat().map((R) => Fl([R.x, R.y], d.canonical));
              if (v.length === 0) return NaN;
              const E = new Ee(x[0][1]);
              let L = 1 / 0;
              for (const R of p) {
                switch (R.type) {
                  case "Point":
                    L = Math.min(L, Qo(x, !0, [R.coordinates], !1, E, L));
                    break;
                  case "LineString":
                    L = Math.min(L, Qo(x, !0, R.coordinates, !0, E, L));
                    break;
                  case "Polygon":
                    L = Math.min(L, Ko(x, !0, R.coordinates, E, L));
                }
                if (L === 0) return L;
              }
              return L;
            }(a, this.geometries);
            if (a.geometryType() === "Polygon") return function(d, p) {
              const v = d.geometry();
              if (v.length === 0 || v[0].length === 0) return NaN;
              const x = Io(v, 0).map((R) => R.map((F) => F.map((j) => Fl([j.x, j.y], d.canonical)))), E = new Ee(x[0][0][0][1]);
              let L = 1 / 0;
              for (const R of p) for (const F of x) {
                switch (R.type) {
                  case "Point":
                    L = Math.min(L, Ko([R.coordinates], !1, F, E, L));
                    break;
                  case "LineString":
                    L = Math.min(L, Ko(R.coordinates, !0, F, E, L));
                    break;
                  case "Polygon":
                    L = Math.min(L, $n(F, R.coordinates, E, L));
                }
                if (L === 0) return L;
              }
              return L;
            }(a, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const Lo = { "==": Bl, "!=": Rl, ">": Zu, "<": uu, ">=": Ol, "<=": Ju, array: pi, at: Sa, boolean: pi, case: De, coalesce: Ml, collator: co, format: Dl, image: Yo, in: Ya, "index-of": ae, interpolate: dn, "interpolate-hcl": dn, "interpolate-lab": dn, length: Qa, let: Ji, literal: fi, match: me, number: pi, "number-format": To, object: pi, slice: nt, step: Vt, string: pi, "to-boolean": Tr, "to-color": Tr, "to-number": Tr, "to-string": Tr, var: Xn, within: Os, distance: po };
      class Pi {
        constructor(a, d, p, v) {
          this.name = a, this.type = d, this._evaluate = p, this.args = v;
        }
        evaluate(a) {
          return this._evaluate(a, this.args);
        }
        eachChild(a) {
          this.args.forEach(a);
        }
        outputDefined() {
          return !1;
        }
        static parse(a, d) {
          const p = a[0], v = Pi.definitions[p];
          if (!v) return d.error(`Unknown expression "${p}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const x = Array.isArray(v) ? v[0] : v.type, E = Array.isArray(v) ? [[v[1], v[2]]] : v.overloads, L = E.filter((F) => {
            let [j] = F;
            return !Array.isArray(j) || j.length === a.length - 1;
          });
          let R = null;
          for (const [F, j] of L) {
            R = new as(d.registry, ea, d.path, null, d.scope);
            const q = [];
            let Y = !1;
            for (let ee = 1; ee < a.length; ee++) {
              const se = a[ee], de = Array.isArray(F) ? F[ee - 1] : F.type, we = R.parse(se, 1 + q.length, de);
              if (!we) {
                Y = !0;
                break;
              }
              q.push(we);
            }
            if (!Y) if (Array.isArray(F) && F.length !== q.length) R.error(`Expected ${F.length} arguments, but found ${q.length} instead.`);
            else {
              for (let ee = 0; ee < q.length; ee++) {
                const se = Array.isArray(F) ? F[ee] : F.type, de = q[ee];
                R.concat(ee + 1).checkSubtype(se, de.type);
              }
              if (R.errors.length === 0) return new Pi(p, x, j, q);
            }
          }
          if (L.length === 1) d.errors.push(...R.errors);
          else {
            const F = (L.length ? L : E).map((q) => {
              let [Y] = q;
              return ee = Y, Array.isArray(ee) ? `(${ee.map(K).join(", ")})` : `(${K(ee.type)}...)`;
              var ee;
            }).join(" | "), j = [];
            for (let q = 1; q < a.length; q++) {
              const Y = d.parse(a[q], 1 + j.length);
              if (!Y) return null;
              j.push(K(Y.type));
            }
            d.error(`Expected arguments of type ${F}, but found (${j.join(", ")}) instead.`);
          }
          return null;
        }
        static register(a, d) {
          Pi.definitions = d;
          for (const p in d) a[p] = Pi;
        }
      }
      function Fi(u, a) {
        let [d, p, v, x] = a;
        d = d.evaluate(u), p = p.evaluate(u), v = v.evaluate(u);
        const E = x ? x.evaluate(u) : 1, L = ao(d, p, v, E);
        if (L) throw new pr(L);
        return new Jn(d / 255, p / 255, v / 255, E, !1);
      }
      function Ia(u, a) {
        return u in a;
      }
      function Pa(u, a) {
        const d = a[u];
        return d === void 0 ? null : d;
      }
      function Ds(u) {
        return { type: u };
      }
      function ea(u) {
        if (u instanceof Xn) return ea(u.boundExpression);
        if (u instanceof Pi && u.name === "error" || u instanceof co || u instanceof Os || u instanceof po) return !1;
        const a = u instanceof Tr || u instanceof pi;
        let d = !0;
        return u.eachChild((p) => {
          d = a ? d && ea(p) : d && p instanceof fi;
        }), !!d && vi(u) && ta(u, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function vi(u) {
        if (u instanceof Pi && (u.name === "get" && u.args.length === 1 || u.name === "feature-state" || u.name === "has" && u.args.length === 1 || u.name === "properties" || u.name === "geometry-type" || u.name === "id" || /^filter-/.test(u.name)) || u instanceof Os || u instanceof po) return !1;
        let a = !0;
        return u.eachChild((d) => {
          a && !vi(d) && (a = !1);
        }), a;
      }
      function La(u) {
        if (u instanceof Pi && u.name === "feature-state") return !1;
        let a = !0;
        return u.eachChild((d) => {
          a && !La(d) && (a = !1);
        }), a;
      }
      function ta(u, a) {
        if (u instanceof Pi && a.indexOf(u.name) >= 0) return !1;
        let d = !0;
        return u.eachChild((p) => {
          d && !ta(p, a) && (d = !1);
        }), d;
      }
      function nl(u) {
        return { result: "success", value: u };
      }
      function ki(u) {
        return { result: "error", value: u };
      }
      function Mo(u) {
        return u["property-type"] === "data-driven" || u["property-type"] === "cross-faded-data-driven";
      }
      function pu(u) {
        return !!u.expression && u.expression.parameters.indexOf("zoom") > -1;
      }
      function Pc(u) {
        return !!u.expression && u.expression.interpolated;
      }
      function zn(u) {
        return u instanceof Number ? "number" : u instanceof String ? "string" : u instanceof Boolean ? "boolean" : Array.isArray(u) ? "array" : u === null ? "null" : typeof u;
      }
      function Ki(u) {
        return typeof u == "object" && u !== null && !Array.isArray(u);
      }
      function go(u) {
        return u;
      }
      function na(u, a) {
        const d = a.type === "color", p = u.stops && typeof u.stops[0][0] == "object", v = p || !(p || u.property !== void 0), x = u.type || (Pc(a) ? "exponential" : "interval");
        if (d || a.type === "padding") {
          const j = d ? Jn.parse : Lr.parse;
          (u = un({}, u)).stops && (u.stops = u.stops.map((q) => [q[0], j(q[1])])), u.default = j(u.default ? u.default : a.default);
        }
        if (u.colorSpace && (E = u.colorSpace) !== "rgb" && E !== "hcl" && E !== "lab") throw new Error(`Unknown color space: "${u.colorSpace}"`);
        var E;
        let L, R, F;
        if (x === "exponential") L = Fs;
        else if (x === "interval") L = ra;
        else if (x === "categorical") {
          L = Bo, R = /* @__PURE__ */ Object.create(null);
          for (const j of u.stops) R[j[0]] = j[1];
          F = typeof u.stops[0][0];
        } else {
          if (x !== "identity") throw new Error(`Unknown function type "${x}"`);
          L = rl;
        }
        if (p) {
          const j = {}, q = [];
          for (let se = 0; se < u.stops.length; se++) {
            const de = u.stops[se], we = de[0].zoom;
            j[we] === void 0 && (j[we] = { zoom: we, type: u.type, property: u.property, default: u.default, stops: [] }, q.push(we)), j[we].stops.push([de[0].value, de[1]]);
          }
          const Y = [];
          for (const se of q) Y.push([j[se].zoom, na(j[se], a)]);
          const ee = { name: "linear" };
          return { kind: "composite", interpolationType: ee, interpolationFactor: dn.interpolationFactor.bind(void 0, ee), zoomStops: Y.map((se) => se[0]), evaluate: (se, de) => {
            let { zoom: we } = se;
            return Fs({ stops: Y, base: u.base }, a, we).evaluate(we, de);
          } };
        }
        if (v) {
          const j = x === "exponential" ? { name: "exponential", base: u.base !== void 0 ? u.base : 1 } : null;
          return { kind: "camera", interpolationType: j, interpolationFactor: dn.interpolationFactor.bind(void 0, j), zoomStops: u.stops.map((q) => q[0]), evaluate: (q) => {
            let { zoom: Y } = q;
            return L(u, a, Y, R, F);
          } };
        }
        return { kind: "source", evaluate(j, q) {
          const Y = q && q.properties ? q.properties[u.property] : void 0;
          return Y === void 0 ? Qi(u.default, a.default) : L(u, a, Y, R, F);
        } };
      }
      function Qi(u, a, d) {
        return u !== void 0 ? u : a !== void 0 ? a : d !== void 0 ? d : void 0;
      }
      function Bo(u, a, d, p, v) {
        return Qi(typeof d === v ? p[d] : void 0, u.default, a.default);
      }
      function ra(u, a, d) {
        if (zn(d) !== "number") return Qi(u.default, a.default);
        const p = u.stops.length;
        if (p === 1 || d <= u.stops[0][0]) return u.stops[0][1];
        if (d >= u.stops[p - 1][0]) return u.stops[p - 1][1];
        const v = Tt(u.stops.map((x) => x[0]), d);
        return u.stops[v][1];
      }
      function Fs(u, a, d) {
        const p = u.base !== void 0 ? u.base : 1;
        if (zn(d) !== "number") return Qi(u.default, a.default);
        const v = u.stops.length;
        if (v === 1 || d <= u.stops[0][0]) return u.stops[0][1];
        if (d >= u.stops[v - 1][0]) return u.stops[v - 1][1];
        const x = Tt(u.stops.map((j) => j[0]), d), E = function(j, q, Y, ee) {
          const se = ee - Y, de = j - Y;
          return se === 0 ? 0 : q === 1 ? de / se : (Math.pow(q, de) - 1) / (Math.pow(q, se) - 1);
        }(d, p, u.stops[x][0], u.stops[x + 1][0]), L = u.stops[x][1], R = u.stops[x + 1][1], F = Ii[a.type] || go;
        return typeof L.evaluate == "function" ? { evaluate() {
          for (var j = arguments.length, q = new Array(j), Y = 0; Y < j; Y++)
            q[Y] = arguments[Y];
          const ee = L.evaluate.apply(void 0, q), se = R.evaluate.apply(void 0, q);
          if (ee !== void 0 && se !== void 0) return F(ee, se, E, u.colorSpace);
        } } : F(L, R, E, u.colorSpace);
      }
      function rl(u, a, d) {
        switch (a.type) {
          case "color":
            d = Jn.parse(d);
            break;
          case "formatted":
            d = Pr.fromString(d.toString());
            break;
          case "resolvedImage":
            d = Er.fromString(d.toString());
            break;
          case "padding":
            d = Lr.parse(d);
            break;
          default:
            zn(d) === a.type || a.type === "enum" && a.values[d] || (d = void 0);
        }
        return Qi(d, u.default, a.default);
      }
      Pi.register(Lo, { error: [{ kind: "error" }, [bn], (u, a) => {
        let [d] = a;
        throw new pr(d.evaluate(u));
      }], typeof: [bn, [zt], (u, a) => {
        let [d] = a;
        return K(yr(d.evaluate(u)));
      }], "to-rgba": [J(mt, 4), [qn], (u, a) => {
        let [d] = a;
        const [p, v, x, E] = d.evaluate(u).rgb;
        return [255 * p, 255 * v, 255 * x, E];
      }], rgb: [qn, [mt, mt, mt], Fi], rgba: [qn, [mt, mt, mt, mt], Fi], has: { type: jt, overloads: [[[bn], (u, a) => {
        let [d] = a;
        return Ia(d.evaluate(u), u.properties());
      }], [[bn, Jr], (u, a) => {
        let [d, p] = a;
        return Ia(d.evaluate(u), p.evaluate(u));
      }]] }, get: { type: zt, overloads: [[[bn], (u, a) => {
        let [d] = a;
        return Pa(d.evaluate(u), u.properties());
      }], [[bn, Jr], (u, a) => {
        let [d, p] = a;
        return Pa(d.evaluate(u), p.evaluate(u));
      }]] }, "feature-state": [zt, [bn], (u, a) => {
        let [d] = a;
        return Pa(d.evaluate(u), u.featureState || {});
      }], properties: [Jr, [], (u) => u.properties()], "geometry-type": [bn, [], (u) => u.geometryType()], id: [zt, [], (u) => u.id()], zoom: [mt, [], (u) => u.globals.zoom], "heatmap-density": [mt, [], (u) => u.globals.heatmapDensity || 0], "line-progress": [mt, [], (u) => u.globals.lineProgress || 0], accumulated: [zt, [], (u) => u.globals.accumulated === void 0 ? null : u.globals.accumulated], "+": [mt, Ds(mt), (u, a) => {
        let d = 0;
        for (const p of a) d += p.evaluate(u);
        return d;
      }], "*": [mt, Ds(mt), (u, a) => {
        let d = 1;
        for (const p of a) d *= p.evaluate(u);
        return d;
      }], "-": { type: mt, overloads: [[[mt, mt], (u, a) => {
        let [d, p] = a;
        return d.evaluate(u) - p.evaluate(u);
      }], [[mt], (u, a) => {
        let [d] = a;
        return -d.evaluate(u);
      }]] }, "/": [mt, [mt, mt], (u, a) => {
        let [d, p] = a;
        return d.evaluate(u) / p.evaluate(u);
      }], "%": [mt, [mt, mt], (u, a) => {
        let [d, p] = a;
        return d.evaluate(u) % p.evaluate(u);
      }], ln2: [mt, [], () => Math.LN2], pi: [mt, [], () => Math.PI], e: [mt, [], () => Math.E], "^": [mt, [mt, mt], (u, a) => {
        let [d, p] = a;
        return Math.pow(d.evaluate(u), p.evaluate(u));
      }], sqrt: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.sqrt(d.evaluate(u));
      }], log10: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.log(d.evaluate(u)) / Math.LN10;
      }], ln: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.log(d.evaluate(u));
      }], log2: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.log(d.evaluate(u)) / Math.LN2;
      }], sin: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.sin(d.evaluate(u));
      }], cos: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.cos(d.evaluate(u));
      }], tan: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.tan(d.evaluate(u));
      }], asin: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.asin(d.evaluate(u));
      }], acos: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.acos(d.evaluate(u));
      }], atan: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.atan(d.evaluate(u));
      }], min: [mt, Ds(mt), (u, a) => Math.min(...a.map((d) => d.evaluate(u)))], max: [mt, Ds(mt), (u, a) => Math.max(...a.map((d) => d.evaluate(u)))], abs: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.abs(d.evaluate(u));
      }], round: [mt, [mt], (u, a) => {
        let [d] = a;
        const p = d.evaluate(u);
        return p < 0 ? -Math.round(-p) : Math.round(p);
      }], floor: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.floor(d.evaluate(u));
      }], ceil: [mt, [mt], (u, a) => {
        let [d] = a;
        return Math.ceil(d.evaluate(u));
      }], "filter-==": [jt, [bn, zt], (u, a) => {
        let [d, p] = a;
        return u.properties()[d.value] === p.value;
      }], "filter-id-==": [jt, [zt], (u, a) => {
        let [d] = a;
        return u.id() === d.value;
      }], "filter-type-==": [jt, [bn], (u, a) => {
        let [d] = a;
        return u.geometryType() === d.value;
      }], "filter-<": [jt, [bn, zt], (u, a) => {
        let [d, p] = a;
        const v = u.properties()[d.value], x = p.value;
        return typeof v == typeof x && v < x;
      }], "filter-id-<": [jt, [zt], (u, a) => {
        let [d] = a;
        const p = u.id(), v = d.value;
        return typeof p == typeof v && p < v;
      }], "filter->": [jt, [bn, zt], (u, a) => {
        let [d, p] = a;
        const v = u.properties()[d.value], x = p.value;
        return typeof v == typeof x && v > x;
      }], "filter-id->": [jt, [zt], (u, a) => {
        let [d] = a;
        const p = u.id(), v = d.value;
        return typeof p == typeof v && p > v;
      }], "filter-<=": [jt, [bn, zt], (u, a) => {
        let [d, p] = a;
        const v = u.properties()[d.value], x = p.value;
        return typeof v == typeof x && v <= x;
      }], "filter-id-<=": [jt, [zt], (u, a) => {
        let [d] = a;
        const p = u.id(), v = d.value;
        return typeof p == typeof v && p <= v;
      }], "filter->=": [jt, [bn, zt], (u, a) => {
        let [d, p] = a;
        const v = u.properties()[d.value], x = p.value;
        return typeof v == typeof x && v >= x;
      }], "filter-id->=": [jt, [zt], (u, a) => {
        let [d] = a;
        const p = u.id(), v = d.value;
        return typeof p == typeof v && p >= v;
      }], "filter-has": [jt, [zt], (u, a) => {
        let [d] = a;
        return d.value in u.properties();
      }], "filter-has-id": [jt, [], (u) => u.id() !== null && u.id() !== void 0], "filter-type-in": [jt, [J(bn)], (u, a) => {
        let [d] = a;
        return d.value.indexOf(u.geometryType()) >= 0;
      }], "filter-id-in": [jt, [J(zt)], (u, a) => {
        let [d] = a;
        return d.value.indexOf(u.id()) >= 0;
      }], "filter-in-small": [jt, [bn, J(zt)], (u, a) => {
        let [d, p] = a;
        return p.value.indexOf(u.properties()[d.value]) >= 0;
      }], "filter-in-large": [jt, [bn, J(zt)], (u, a) => {
        let [d, p] = a;
        return function(v, x, E, L) {
          for (; E <= L; ) {
            const R = E + L >> 1;
            if (x[R] === v) return !0;
            x[R] > v ? L = R - 1 : E = R + 1;
          }
          return !1;
        }(u.properties()[d.value], p.value, 0, p.value.length - 1);
      }], all: { type: jt, overloads: [[[jt, jt], (u, a) => {
        let [d, p] = a;
        return d.evaluate(u) && p.evaluate(u);
      }], [Ds(jt), (u, a) => {
        for (const d of a) if (!d.evaluate(u)) return !1;
        return !0;
      }]] }, any: { type: jt, overloads: [[[jt, jt], (u, a) => {
        let [d, p] = a;
        return d.evaluate(u) || p.evaluate(u);
      }], [Ds(jt), (u, a) => {
        for (const d of a) if (d.evaluate(u)) return !0;
        return !1;
      }]] }, "!": [jt, [jt], (u, a) => {
        let [d] = a;
        return !d.evaluate(u);
      }], "is-supported-script": [jt, [bn], (u, a) => {
        let [d] = a;
        const p = u.globals && u.globals.isSupportedScript;
        return !p || p(d.evaluate(u));
      }], upcase: [bn, [bn], (u, a) => {
        let [d] = a;
        return d.evaluate(u).toUpperCase();
      }], downcase: [bn, [bn], (u, a) => {
        let [d] = a;
        return d.evaluate(u).toLowerCase();
      }], concat: [bn, Ds(zt), (u, a) => a.map((d) => Yn(d.evaluate(u))).join("")], "resolved-locale": [bn, [yi], (u, a) => {
        let [d] = a;
        return d.evaluate(u).resolvedLocale();
      }] });
      class Ma {
        constructor(a, d) {
          var p;
          this.expression = a, this._warningHistory = {}, this._evaluator = new gi(), this._defaultValue = d ? (p = d).type === "color" && Ki(p.default) ? new Jn(0, 0, 0, 0) : p.type === "color" ? Jn.parse(p.default) || null : p.type === "padding" ? Lr.parse(p.default) || null : p.type === "variableAnchorOffsetCollection" ? Mr.parse(p.default) || null : p.default === void 0 ? null : p.default : null, this._enumValues = d && d.type === "enum" ? d.values : null;
        }
        evaluateWithoutErrorHandling(a, d, p, v, x, E) {
          return this._evaluator.globals = a, this._evaluator.feature = d, this._evaluator.featureState = p, this._evaluator.canonical = v, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = E, this.expression.evaluate(this._evaluator);
        }
        evaluate(a, d, p, v, x, E) {
          this._evaluator.globals = a, this._evaluator.feature = d || null, this._evaluator.featureState = p || null, this._evaluator.canonical = v, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = E || null;
          try {
            const L = this.expression.evaluate(this._evaluator);
            if (L == null || typeof L == "number" && L != L) return this._defaultValue;
            if (this._enumValues && !(L in this._enumValues)) throw new pr(`Expected value to be one of ${Object.keys(this._enumValues).map((R) => JSON.stringify(R)).join(", ")}, but found ${JSON.stringify(L)} instead.`);
            return L;
          } catch (L) {
            return this._warningHistory[L.message] || (this._warningHistory[L.message] = !0, typeof console < "u" && console.warn(L.message)), this._defaultValue;
          }
        }
      }
      function mo(u) {
        return Array.isArray(u) && u.length > 0 && typeof u[0] == "string" && u[0] in Lo;
      }
      function Ni(u, a) {
        const d = new as(Lo, ea, [], a ? function(v) {
          const x = { color: qn, string: bn, number: mt, enum: bn, boolean: jt, formatted: rr, padding: ti, resolvedImage: ni, variableAnchorOffsetCollection: be };
          return v.type === "array" ? J(x[v.value] || zt, v.length) : x[v.type];
        }(a) : void 0), p = d.parse(u, void 0, void 0, void 0, a && a.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return p ? nl(new Ma(p, a)) : ki(d.errors);
      }
      class cs {
        constructor(a, d) {
          this.kind = a, this._styleExpression = d, this.isStateDependent = a !== "constant" && !La(d.expression);
        }
        evaluateWithoutErrorHandling(a, d, p, v, x, E) {
          return this._styleExpression.evaluateWithoutErrorHandling(a, d, p, v, x, E);
        }
        evaluate(a, d, p, v, x, E) {
          return this._styleExpression.evaluate(a, d, p, v, x, E);
        }
      }
      class ks {
        constructor(a, d, p, v) {
          this.kind = a, this.zoomStops = p, this._styleExpression = d, this.isStateDependent = a !== "camera" && !La(d.expression), this.interpolationType = v;
        }
        evaluateWithoutErrorHandling(a, d, p, v, x, E) {
          return this._styleExpression.evaluateWithoutErrorHandling(a, d, p, v, x, E);
        }
        evaluate(a, d, p, v, x, E) {
          return this._styleExpression.evaluate(a, d, p, v, x, E);
        }
        interpolationFactor(a, d, p) {
          return this.interpolationType ? dn.interpolationFactor(this.interpolationType, a, d, p) : 0;
        }
      }
      function Ba(u, a) {
        const d = Ni(u, a);
        if (d.result === "error") return d;
        const p = d.value.expression, v = vi(p);
        if (!v && !Mo(a)) return ki([new xn("", "data expressions not supported")]);
        const x = ta(p, ["zoom"]);
        if (!x && !pu(a)) return ki([new xn("", "zoom expressions not supported")]);
        const E = zs(p);
        return E || x ? E instanceof xn ? ki([E]) : E instanceof dn && !Pc(a) ? ki([new xn("", '"interpolate" expressions cannot be used with this property')]) : nl(E ? new ks(v ? "camera" : "composite", d.value, E.labels, E instanceof dn ? E.interpolation : void 0) : new cs(v ? "constant" : "source", d.value)) : ki([new xn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Ns {
        constructor(a, d) {
          this._parameters = a, this._specification = d, un(this, na(this._parameters, this._specification));
        }
        static deserialize(a) {
          return new Ns(a._parameters, a._specification);
        }
        static serialize(a) {
          return { _parameters: a._parameters, _specification: a._specification };
        }
      }
      function zs(u) {
        let a = null;
        if (u instanceof Ji) a = zs(u.result);
        else if (u instanceof Ml) {
          for (const d of u.args) if (a = zs(d), a) break;
        } else (u instanceof Vt || u instanceof dn) && u.input instanceof Pi && u.input.name === "zoom" && (a = u);
        return a instanceof xn || u.eachChild((d) => {
          const p = zs(d);
          p instanceof xn ? a = p : !a && p ? a = new xn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : a && p && a !== p && (a = new xn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), a;
      }
      function Ra(u) {
        if (u === !0 || u === !1) return !0;
        if (!Array.isArray(u) || u.length === 0) return !1;
        switch (u[0]) {
          case "has":
            return u.length >= 2 && u[1] !== "$id" && u[1] !== "$type";
          case "in":
            return u.length >= 3 && (typeof u[1] != "string" || Array.isArray(u[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return u.length !== 3 || Array.isArray(u[1]) || Array.isArray(u[2]);
          case "any":
          case "all":
            for (const a of u.slice(1)) if (!Ra(a) && typeof a != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const es = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function _o(u) {
        if (u == null) return { filter: () => !0, needGeometry: !1 };
        Ra(u) || (u = jr(u));
        const a = Ni(u, es);
        if (a.result === "error") throw new Error(a.value.map((d) => `${d.key}: ${d.message}`).join(", "));
        return { filter: (d, p, v) => a.value.evaluate(d, p, {}, v), needGeometry: br(u) };
      }
      function Cr(u, a) {
        return u < a ? -1 : u > a ? 1 : 0;
      }
      function br(u) {
        if (!Array.isArray(u)) return !1;
        if (u[0] === "within" || u[0] === "distance") return !0;
        for (let a = 1; a < u.length; a++) if (br(u[a])) return !0;
        return !1;
      }
      function jr(u) {
        if (!u) return !0;
        const a = u[0];
        return u.length <= 1 ? a !== "any" : a === "==" ? ii(u[1], u[2], "==") : a === "!=" ? si(ii(u[1], u[2], "==")) : a === "<" || a === ">" || a === "<=" || a === ">=" ? ii(u[1], u[2], a) : a === "any" ? (d = u.slice(1), ["any"].concat(d.map(jr))) : a === "all" ? ["all"].concat(u.slice(1).map(jr)) : a === "none" ? ["all"].concat(u.slice(1).map(jr).map(si)) : a === "in" ? As(u[1], u.slice(2)) : a === "!in" ? si(As(u[1], u.slice(2))) : a === "has" ? Us(u[1]) : a !== "!has" || si(Us(u[1]));
        var d;
      }
      function ii(u, a, d) {
        switch (u) {
          case "$type":
            return [`filter-type-${d}`, a];
          case "$id":
            return [`filter-id-${d}`, a];
          default:
            return [`filter-${d}`, u, a];
        }
      }
      function As(u, a) {
        if (a.length === 0) return !1;
        switch (u) {
          case "$type":
            return ["filter-type-in", ["literal", a]];
          case "$id":
            return ["filter-id-in", ["literal", a]];
          default:
            return a.length > 200 && !a.some((d) => typeof d != typeof a[0]) ? ["filter-in-large", u, ["literal", a.sort(Cr)]] : ["filter-in-small", u, ["literal", a]];
        }
      }
      function Us(u) {
        switch (u) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", u];
        }
      }
      function si(u) {
        return ["!", u];
      }
      function Ro(u) {
        const a = typeof u;
        if (a === "number" || a === "boolean" || a === "string" || u == null) return JSON.stringify(u);
        if (Array.isArray(u)) {
          let v = "[";
          for (const x of u) v += `${Ro(x)},`;
          return `${v}]`;
        }
        const d = Object.keys(u).sort();
        let p = "{";
        for (let v = 0; v < d.length; v++) p += `${JSON.stringify(d[v])}:${Ro(u[d[v]])},`;
        return `${p}}`;
      }
      function Ku(u) {
        let a = "";
        for (const d of pn) a += `/${Ro(u[d])}`;
        return a;
      }
      function Qu(u) {
        const a = u.value;
        return a ? [new gt(u.key, a, "constants have been deprecated as of v8")] : [];
      }
      function Wr(u) {
        return u instanceof Number || u instanceof String || u instanceof Boolean ? u.valueOf() : u;
      }
      function js(u) {
        if (Array.isArray(u)) return u.map(js);
        if (u instanceof Object && !(u instanceof Number || u instanceof String || u instanceof Boolean)) {
          const a = {};
          for (const d in u) a[d] = js(u[d]);
          return a;
        }
        return Wr(u);
      }
      function us(u) {
        const a = u.key, d = u.value, p = u.valueSpec || {}, v = u.objectElementValidators || {}, x = u.style, E = u.styleSpec, L = u.validateSpec;
        let R = [];
        const F = zn(d);
        if (F !== "object") return [new gt(a, d, `object expected, ${F} found`)];
        for (const j in d) {
          const q = j.split(".")[0], Y = p[q] || p["*"];
          let ee;
          if (v[q]) ee = v[q];
          else if (p[q]) ee = L;
          else if (v["*"]) ee = v["*"];
          else {
            if (!p["*"]) {
              R.push(new gt(a, d[j], `unknown property "${j}"`));
              continue;
            }
            ee = L;
          }
          R = R.concat(ee({ key: (a && `${a}.`) + j, value: d[j], valueSpec: Y, style: x, styleSpec: E, object: d, objectKey: j, validateSpec: L }, d));
        }
        for (const j in p) v[j] || p[j].required && p[j].default === void 0 && d[j] === void 0 && R.push(new gt(a, d, `missing required property "${j}"`));
        return R;
      }
      function Vl(u) {
        const a = u.value, d = u.valueSpec, p = u.style, v = u.styleSpec, x = u.key, E = u.arrayElementValidator || u.validateSpec;
        if (zn(a) !== "array") return [new gt(x, a, `array expected, ${zn(a)} found`)];
        if (d.length && a.length !== d.length) return [new gt(x, a, `array length ${d.length} expected, length ${a.length} found`)];
        if (d["min-length"] && a.length < d["min-length"]) return [new gt(x, a, `array length at least ${d["min-length"]} expected, length ${a.length} found`)];
        let L = { type: d.value, values: d.values };
        v.$version < 7 && (L.function = d.function), zn(d.value) === "object" && (L = d.value);
        let R = [];
        for (let F = 0; F < a.length; F++) R = R.concat(E({ array: a, arrayIndex: F, value: a[F], valueSpec: L, validateSpec: u.validateSpec, style: p, styleSpec: v, key: `${x}[${F}]` }));
        return R;
      }
      function Lc(u) {
        const a = u.key, d = u.value, p = u.valueSpec;
        let v = zn(d);
        return v === "number" && d != d && (v = "NaN"), v !== "number" ? [new gt(a, d, `number expected, ${v} found`)] : "minimum" in p && d < p.minimum ? [new gt(a, d, `${d} is less than the minimum value ${p.minimum}`)] : "maximum" in p && d > p.maximum ? [new gt(a, d, `${d} is greater than the maximum value ${p.maximum}`)] : [];
      }
      function il(u) {
        const a = u.valueSpec, d = Wr(u.value.type);
        let p, v, x, E = {};
        const L = d !== "categorical" && u.value.property === void 0, R = !L, F = zn(u.value.stops) === "array" && zn(u.value.stops[0]) === "array" && zn(u.value.stops[0][0]) === "object", j = us({ key: u.key, value: u.value, valueSpec: u.styleSpec.function, validateSpec: u.validateSpec, style: u.style, styleSpec: u.styleSpec, objectElementValidators: { stops: function(ee) {
          if (d === "identity") return [new gt(ee.key, ee.value, 'identity function may not have a "stops" property')];
          let se = [];
          const de = ee.value;
          return se = se.concat(Vl({ key: ee.key, value: de, valueSpec: ee.valueSpec, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, arrayElementValidator: q })), zn(de) === "array" && de.length === 0 && se.push(new gt(ee.key, de, "array must have at least one stop")), se;
        }, default: function(ee) {
          return ee.validateSpec({ key: ee.key, value: ee.value, valueSpec: a, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec });
        } } });
        return d === "identity" && L && j.push(new gt(u.key, u.value, 'missing required property "property"')), d === "identity" || u.value.stops || j.push(new gt(u.key, u.value, 'missing required property "stops"')), d === "exponential" && u.valueSpec.expression && !Pc(u.valueSpec) && j.push(new gt(u.key, u.value, "exponential functions not supported")), u.styleSpec.$version >= 8 && (R && !Mo(u.valueSpec) ? j.push(new gt(u.key, u.value, "property functions not supported")) : L && !pu(u.valueSpec) && j.push(new gt(u.key, u.value, "zoom functions not supported"))), d !== "categorical" && !F || u.value.property !== void 0 || j.push(new gt(u.key, u.value, '"property" property is required')), j;
        function q(ee) {
          let se = [];
          const de = ee.value, we = ee.key;
          if (zn(de) !== "array") return [new gt(we, de, `array expected, ${zn(de)} found`)];
          if (de.length !== 2) return [new gt(we, de, `array length 2 expected, length ${de.length} found`)];
          if (F) {
            if (zn(de[0]) !== "object") return [new gt(we, de, `object expected, ${zn(de[0])} found`)];
            if (de[0].zoom === void 0) return [new gt(we, de, "object stop key must have zoom")];
            if (de[0].value === void 0) return [new gt(we, de, "object stop key must have value")];
            if (x && x > Wr(de[0].zoom)) return [new gt(we, de[0].zoom, "stop zoom values must appear in ascending order")];
            Wr(de[0].zoom) !== x && (x = Wr(de[0].zoom), v = void 0, E = {}), se = se.concat(us({ key: `${we}[0]`, value: de[0], valueSpec: { zoom: {} }, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, objectElementValidators: { zoom: Lc, value: Y } }));
          } else se = se.concat(Y({ key: `${we}[0]`, value: de[0], valueSpec: {}, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }, de));
          return mo(js(de[1])) ? se.concat([new gt(`${we}[1]`, de[1], "expressions are not allowed in function stops.")]) : se.concat(ee.validateSpec({ key: `${we}[1]`, value: de[1], valueSpec: a, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }));
        }
        function Y(ee, se) {
          const de = zn(ee.value), we = Wr(ee.value), Me = ee.value !== null ? ee.value : se;
          if (p) {
            if (de !== p) return [new gt(ee.key, Me, `${de} stop domain type must match previous stop domain type ${p}`)];
          } else p = de;
          if (de !== "number" && de !== "string" && de !== "boolean") return [new gt(ee.key, Me, "stop domain value must be a number, string, or boolean")];
          if (de !== "number" && d !== "categorical") {
            let $e = `number expected, ${de} found`;
            return Mo(a) && d === void 0 && ($e += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new gt(ee.key, Me, $e)];
          }
          return d !== "categorical" || de !== "number" || isFinite(we) && Math.floor(we) === we ? d !== "categorical" && de === "number" && v !== void 0 && we < v ? [new gt(ee.key, Me, "stop domain values must appear in ascending order")] : (v = we, d === "categorical" && we in E ? [new gt(ee.key, Me, "stop domain values must be unique")] : (E[we] = !0, [])) : [new gt(ee.key, Me, `integer expected, found ${we}`)];
        }
      }
      function xi(u) {
        const a = (u.expressionContext === "property" ? Ba : Ni)(js(u.value), u.valueSpec);
        if (a.result === "error") return a.value.map((p) => new gt(`${u.key}${p.key}`, u.value, p.message));
        const d = a.value.expression || a.value._styleExpression.expression;
        if (u.expressionContext === "property" && u.propertyKey === "text-font" && !d.outputDefined()) return [new gt(u.key, u.value, `Invalid data expression for "${u.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (u.expressionContext === "property" && u.propertyType === "layout" && !La(d)) return [new gt(u.key, u.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (u.expressionContext === "filter" && !La(d)) return [new gt(u.key, u.value, '"feature-state" data expressions are not supported with filters.')];
        if (u.expressionContext && u.expressionContext.indexOf("cluster") === 0) {
          if (!ta(d, ["zoom", "feature-state"])) return [new gt(u.key, u.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (u.expressionContext === "cluster-initial" && !vi(d)) return [new gt(u.key, u.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function hi(u) {
        const a = u.key, d = u.value, p = u.valueSpec, v = [];
        return Array.isArray(p.values) ? p.values.indexOf(Wr(d)) === -1 && v.push(new gt(a, d, `expected one of [${p.values.join(", ")}], ${JSON.stringify(d)} found`)) : Object.keys(p.values).indexOf(Wr(d)) === -1 && v.push(new gt(a, d, `expected one of [${Object.keys(p.values).join(", ")}], ${JSON.stringify(d)} found`)), v;
      }
      function ql(u) {
        return Ra(js(u.value)) ? xi(un({}, u, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : sl(u);
      }
      function sl(u) {
        const a = u.value, d = u.key;
        if (zn(a) !== "array") return [new gt(d, a, `array expected, ${zn(a)} found`)];
        const p = u.styleSpec;
        let v, x = [];
        if (a.length < 1) return [new gt(d, a, "filter array must have at least 1 element")];
        switch (x = x.concat(hi({ key: `${d}[0]`, value: a[0], valueSpec: p.filter_operator, style: u.style, styleSpec: u.styleSpec })), Wr(a[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            a.length >= 2 && Wr(a[1]) === "$type" && x.push(new gt(d, a, `"$type" cannot be use with operator "${a[0]}"`));
          case "==":
          case "!=":
            a.length !== 3 && x.push(new gt(d, a, `filter array for operator "${a[0]}" must have 3 elements`));
          case "in":
          case "!in":
            a.length >= 2 && (v = zn(a[1]), v !== "string" && x.push(new gt(`${d}[1]`, a[1], `string expected, ${v} found`)));
            for (let E = 2; E < a.length; E++) v = zn(a[E]), Wr(a[1]) === "$type" ? x = x.concat(hi({ key: `${d}[${E}]`, value: a[E], valueSpec: p.geometry_type, style: u.style, styleSpec: u.styleSpec })) : v !== "string" && v !== "number" && v !== "boolean" && x.push(new gt(`${d}[${E}]`, a[E], `string, number, or boolean expected, ${v} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let E = 1; E < a.length; E++) x = x.concat(sl({ key: `${d}[${E}]`, value: a[E], style: u.style, styleSpec: u.styleSpec }));
            break;
          case "has":
          case "!has":
            v = zn(a[1]), a.length !== 2 ? x.push(new gt(d, a, `filter array for "${a[0]}" operator must have 2 elements`)) : v !== "string" && x.push(new gt(`${d}[1]`, a[1], `string expected, ${v} found`));
        }
        return x;
      }
      function gu(u, a) {
        const d = u.key, p = u.validateSpec, v = u.style, x = u.styleSpec, E = u.value, L = u.objectKey, R = x[`${a}_${u.layerType}`];
        if (!R) return [];
        const F = L.match(/^(.*)-transition$/);
        if (a === "paint" && F && R[F[1]] && R[F[1]].transition) return p({ key: d, value: E, valueSpec: x.transition, style: v, styleSpec: x });
        const j = u.valueSpec || R[L];
        if (!j) return [new gt(d, E, `unknown property "${L}"`)];
        let q;
        if (zn(E) === "string" && Mo(j) && !j.tokens && (q = /^{([^}]+)}$/.exec(E))) return [new gt(d, E, `"${L}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(q[1])} }\`.`)];
        const Y = [];
        return u.layerType === "symbol" && (L === "text-field" && v && !v.glyphs && Y.push(new gt(d, E, 'use of "text-field" requires a style "glyphs" property')), L === "text-font" && Ki(js(E)) && Wr(E.type) === "identity" && Y.push(new gt(d, E, '"text-font" does not support identity functions'))), Y.concat(p({ key: u.key, value: E, valueSpec: j, style: v, styleSpec: x, expressionContext: "property", propertyType: a, propertyKey: L }));
      }
      function ol(u) {
        return gu(u, "paint");
      }
      function Hl(u) {
        return gu(u, "layout");
      }
      function Mc(u) {
        let a = [];
        const d = u.value, p = u.key, v = u.style, x = u.styleSpec;
        d.type || d.ref || a.push(new gt(p, d, 'either "type" or "ref" is required'));
        let E = Wr(d.type);
        const L = Wr(d.ref);
        if (d.id) {
          const R = Wr(d.id);
          for (let F = 0; F < u.arrayIndex; F++) {
            const j = v.layers[F];
            Wr(j.id) === R && a.push(new gt(p, d.id, `duplicate layer id "${d.id}", previously used at line ${j.id.__line__}`));
          }
        }
        if ("ref" in d) {
          let R;
          ["type", "source", "source-layer", "filter", "layout"].forEach((F) => {
            F in d && a.push(new gt(p, d[F], `"${F}" is prohibited for ref layers`));
          }), v.layers.forEach((F) => {
            Wr(F.id) === L && (R = F);
          }), R ? R.ref ? a.push(new gt(p, d.ref, "ref cannot reference another ref layer")) : E = Wr(R.type) : a.push(new gt(p, d.ref, `ref layer "${L}" not found`));
        } else if (E !== "background") if (d.source) {
          const R = v.sources && v.sources[d.source], F = R && Wr(R.type);
          R ? F === "vector" && E === "raster" ? a.push(new gt(p, d.source, `layer "${d.id}" requires a raster source`)) : F !== "raster-dem" && E === "hillshade" ? a.push(new gt(p, d.source, `layer "${d.id}" requires a raster-dem source`)) : F === "raster" && E !== "raster" ? a.push(new gt(p, d.source, `layer "${d.id}" requires a vector source`)) : F !== "vector" || d["source-layer"] ? F === "raster-dem" && E !== "hillshade" ? a.push(new gt(p, d.source, "raster-dem source can only be used with layer type 'hillshade'.")) : E !== "line" || !d.paint || !d.paint["line-gradient"] || F === "geojson" && R.lineMetrics || a.push(new gt(p, d, `layer "${d.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : a.push(new gt(p, d, `layer "${d.id}" must specify a "source-layer"`)) : a.push(new gt(p, d.source, `source "${d.source}" not found`));
        } else a.push(new gt(p, d, 'missing required property "source"'));
        return a = a.concat(us({ key: p, value: d, valueSpec: x.layer, style: u.style, styleSpec: u.styleSpec, validateSpec: u.validateSpec, objectElementValidators: { "*": () => [], type: () => u.validateSpec({ key: `${p}.type`, value: d.type, valueSpec: x.layer.type, style: u.style, styleSpec: u.styleSpec, validateSpec: u.validateSpec, object: d, objectKey: "type" }), filter: ql, layout: (R) => us({ layer: d, key: R.key, value: R.value, style: R.style, styleSpec: R.styleSpec, validateSpec: R.validateSpec, objectElementValidators: { "*": (F) => Hl(un({ layerType: E }, F)) } }), paint: (R) => us({ layer: d, key: R.key, value: R.value, style: R.style, styleSpec: R.styleSpec, validateSpec: R.validateSpec, objectElementValidators: { "*": (F) => ol(un({ layerType: E }, F)) } }) } })), a;
      }
      function Oa(u) {
        const a = u.value, d = u.key, p = zn(a);
        return p !== "string" ? [new gt(d, a, `string expected, ${p} found`)] : [];
      }
      const Wl = { promoteId: function(u) {
        let { key: a, value: d } = u;
        if (zn(d) === "string") return Oa({ key: a, value: d });
        {
          const p = [];
          for (const v in d) p.push(...Oa({ key: `${a}.${v}`, value: d[v] }));
          return p;
        }
      } };
      function al(u) {
        const a = u.value, d = u.key, p = u.styleSpec, v = u.style, x = u.validateSpec;
        if (!a.type) return [new gt(d, a, '"type" is required')];
        const E = Wr(a.type);
        let L;
        switch (E) {
          case "vector":
          case "raster":
            return L = us({ key: d, value: a, valueSpec: p[`source_${E.replace("-", "_")}`], style: u.style, styleSpec: p, objectElementValidators: Wl, validateSpec: x }), L;
          case "raster-dem":
            return L = function(R) {
              var F;
              const j = (F = R.sourceName) !== null && F !== void 0 ? F : "", q = R.value, Y = R.styleSpec, ee = Y.source_raster_dem, se = R.style;
              let de = [];
              const we = zn(q);
              if (q === void 0) return de;
              if (we !== "object") return de.push(new gt("source_raster_dem", q, `object expected, ${we} found`)), de;
              const Me = Wr(q.encoding) === "custom", $e = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Ne = R.value.encoding ? `"${R.value.encoding}"` : "Default";
              for (const Ve in q) !Me && $e.includes(Ve) ? de.push(new gt(Ve, q[Ve], `In "${j}": "${Ve}" is only valid when "encoding" is set to "custom". ${Ne} encoding found`)) : ee[Ve] ? de = de.concat(R.validateSpec({ key: Ve, value: q[Ve], valueSpec: ee[Ve], validateSpec: R.validateSpec, style: se, styleSpec: Y })) : de.push(new gt(Ve, q[Ve], `unknown property "${Ve}"`));
              return de;
            }({ sourceName: d, value: a, style: u.style, styleSpec: p, validateSpec: x }), L;
          case "geojson":
            if (L = us({ key: d, value: a, valueSpec: p.source_geojson, style: v, styleSpec: p, validateSpec: x, objectElementValidators: Wl }), a.cluster) for (const R in a.clusterProperties) {
              const [F, j] = a.clusterProperties[R], q = typeof F == "string" ? [F, ["accumulated"], ["get", R]] : F;
              L.push(...xi({ key: `${d}.${R}.map`, value: j, validateSpec: x, expressionContext: "cluster-map" })), L.push(...xi({ key: `${d}.${R}.reduce`, value: q, validateSpec: x, expressionContext: "cluster-reduce" }));
            }
            return L;
          case "video":
            return us({ key: d, value: a, valueSpec: p.source_video, style: v, validateSpec: x, styleSpec: p });
          case "image":
            return us({ key: d, value: a, valueSpec: p.source_image, style: v, validateSpec: x, styleSpec: p });
          case "canvas":
            return [new gt(d, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return hi({ key: `${d}.type`, value: a.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: v, validateSpec: x, styleSpec: p });
        }
      }
      function Xl(u) {
        const a = u.value, d = u.styleSpec, p = d.light, v = u.style;
        let x = [];
        const E = zn(a);
        if (a === void 0) return x;
        if (E !== "object") return x = x.concat([new gt("light", a, `object expected, ${E} found`)]), x;
        for (const L in a) {
          const R = L.match(/^(.*)-transition$/);
          x = x.concat(R && p[R[1]] && p[R[1]].transition ? u.validateSpec({ key: L, value: a[L], valueSpec: d.transition, validateSpec: u.validateSpec, style: v, styleSpec: d }) : p[L] ? u.validateSpec({ key: L, value: a[L], valueSpec: p[L], validateSpec: u.validateSpec, style: v, styleSpec: d }) : [new gt(L, a[L], `unknown property "${L}"`)]);
        }
        return x;
      }
      function Bc(u) {
        const a = u.value, d = u.styleSpec, p = d.sky, v = u.style, x = zn(a);
        if (a === void 0) return [];
        if (x !== "object") return [new gt("sky", a, `object expected, ${x} found`)];
        let E = [];
        for (const L in a) E = E.concat(p[L] ? u.validateSpec({ key: L, value: a[L], valueSpec: p[L], style: v, styleSpec: d }) : [new gt(L, a[L], `unknown property "${L}"`)]);
        return E;
      }
      function eh(u) {
        const a = u.value, d = u.styleSpec, p = d.terrain, v = u.style;
        let x = [];
        const E = zn(a);
        if (a === void 0) return x;
        if (E !== "object") return x = x.concat([new gt("terrain", a, `object expected, ${E} found`)]), x;
        for (const L in a) x = x.concat(p[L] ? u.validateSpec({ key: L, value: a[L], valueSpec: p[L], validateSpec: u.validateSpec, style: v, styleSpec: d }) : [new gt(L, a[L], `unknown property "${L}"`)]);
        return x;
      }
      function th(u) {
        let a = [];
        const d = u.value, p = u.key;
        if (Array.isArray(d)) {
          const v = [], x = [];
          for (const E in d) d[E].id && v.includes(d[E].id) && a.push(new gt(p, d, `all the sprites' ids must be unique, but ${d[E].id} is duplicated`)), v.push(d[E].id), d[E].url && x.includes(d[E].url) && a.push(new gt(p, d, `all the sprites' URLs must be unique, but ${d[E].url} is duplicated`)), x.push(d[E].url), a = a.concat(us({ key: `${p}[${E}]`, value: d[E], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: u.validateSpec }));
          return a;
        }
        return Oa({ key: p, value: d });
      }
      const Rc = { "*": () => [], array: Vl, boolean: function(u) {
        const a = u.value, d = u.key, p = zn(a);
        return p !== "boolean" ? [new gt(d, a, `boolean expected, ${p} found`)] : [];
      }, number: Lc, color: function(u) {
        const a = u.key, d = u.value, p = zn(d);
        return p !== "string" ? [new gt(a, d, `color expected, ${p} found`)] : Jn.parse(String(d)) ? [] : [new gt(a, d, `color expected, "${d}" found`)];
      }, constants: Qu, enum: hi, filter: ql, function: il, layer: Mc, object: us, source: al, light: Xl, sky: Bc, terrain: eh, projection: function(u) {
        const a = u.value, d = u.styleSpec, p = d.projection, v = u.style, x = zn(a);
        if (a === void 0) return [];
        if (x !== "object") return [new gt("projection", a, `object expected, ${x} found`)];
        let E = [];
        for (const L in a) E = E.concat(p[L] ? u.validateSpec({ key: L, value: a[L], valueSpec: p[L], style: v, styleSpec: d }) : [new gt(L, a[L], `unknown property "${L}"`)]);
        return E;
      }, string: Oa, formatted: function(u) {
        return Oa(u).length === 0 ? [] : xi(u);
      }, resolvedImage: function(u) {
        return Oa(u).length === 0 ? [] : xi(u);
      }, padding: function(u) {
        const a = u.key, d = u.value;
        if (zn(d) === "array") {
          if (d.length < 1 || d.length > 4) return [new gt(a, d, `padding requires 1 to 4 values; ${d.length} values found`)];
          const p = { type: "number" };
          let v = [];
          for (let x = 0; x < d.length; x++) v = v.concat(u.validateSpec({ key: `${a}[${x}]`, value: d[x], validateSpec: u.validateSpec, valueSpec: p }));
          return v;
        }
        return Lc({ key: a, value: d, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(u) {
        const a = u.key, d = u.value, p = zn(d), v = u.styleSpec;
        if (p !== "array" || d.length < 1 || d.length % 2 != 0) return [new gt(a, d, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let x = [];
        for (let E = 0; E < d.length; E += 2) x = x.concat(hi({ key: `${a}[${E}]`, value: d[E], valueSpec: v.layout_symbol["text-anchor"] })), x = x.concat(Vl({ key: `${a}[${E + 1}]`, value: d[E + 1], valueSpec: { length: 2, value: "number" }, validateSpec: u.validateSpec, style: u.style, styleSpec: v }));
        return x;
      }, sprite: th };
      function $l(u) {
        const a = u.value, d = u.valueSpec, p = u.styleSpec;
        return u.validateSpec = $l, d.expression && Ki(Wr(a)) ? il(u) : d.expression && mo(js(a)) ? xi(u) : d.type && Rc[d.type] ? Rc[d.type](u) : us(un({}, u, { valueSpec: d.type ? p[d.type] : d }));
      }
      function Wh(u) {
        const a = u.value, d = u.key, p = Oa(u);
        return p.length || (a.indexOf("{fontstack}") === -1 && p.push(new gt(d, a, '"glyphs" url must include a "{fontstack}" token')), a.indexOf("{range}") === -1 && p.push(new gt(d, a, '"glyphs" url must include a "{range}" token'))), p;
      }
      function Gs(u) {
        let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ne, d = [];
        return d = d.concat($l({ key: "", value: u, valueSpec: a.$root, styleSpec: a, style: u, validateSpec: $l, objectElementValidators: { glyphs: Wh, "*": () => [] } })), u.constants && (d = d.concat(Qu({ key: "constants", value: u.constants, style: u, styleSpec: a, validateSpec: $l }))), nh(d);
      }
      function Oo(u) {
        return function(a) {
          return u({ ...a, validateSpec: $l });
        };
      }
      function nh(u) {
        return [].concat(u).sort((a, d) => a.line - d.line);
      }
      function Ss(u) {
        return function() {
          for (var a = arguments.length, d = new Array(a), p = 0; p < a; p++)
            d[p] = arguments[p];
          return nh(u.apply(this, d));
        };
      }
      Gs.source = Ss(Oo(al)), Gs.sprite = Ss(Oo(th)), Gs.glyphs = Ss(Oo(Wh)), Gs.light = Ss(Oo(Xl)), Gs.sky = Ss(Oo(Bc)), Gs.terrain = Ss(Oo(eh)), Gs.layer = Ss(Oo(Mc)), Gs.filter = Ss(Oo(ql)), Gs.paintProperty = Ss(Oo(ol)), Gs.layoutProperty = Ss(Oo(Hl));
      const ia = Gs, Oc = ia.light, uf = ia.sky, Xh = ia.paintProperty, rh = ia.layoutProperty;
      function ih(u, a) {
        let d = !1;
        if (a && a.length) for (const p of a) u.fire(new an(new Error(p.message))), d = !0;
        return d;
      }
      class Zl {
        constructor(a, d, p) {
          const v = this.cells = [];
          if (a instanceof ArrayBuffer) {
            this.arrayBuffer = a;
            const E = new Int32Array(this.arrayBuffer);
            a = E[0], this.d = (d = E[1]) + 2 * (p = E[2]);
            for (let R = 0; R < this.d * this.d; R++) {
              const F = E[3 + R], j = E[3 + R + 1];
              v.push(F === j ? null : E.subarray(F, j));
            }
            const L = E[3 + v.length + 1];
            this.keys = E.subarray(E[3 + v.length], L), this.bboxes = E.subarray(L), this.insert = this._insertReadonly;
          } else {
            this.d = d + 2 * p;
            for (let E = 0; E < this.d * this.d; E++) v.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = d, this.extent = a, this.padding = p, this.scale = d / a, this.uid = 0;
          const x = p / d * a;
          this.min = -x, this.max = a + x;
        }
        insert(a, d, p, v, x) {
          this._forEachCell(d, p, v, x, this._insertCell, this.uid++, void 0, void 0), this.keys.push(a), this.bboxes.push(d), this.bboxes.push(p), this.bboxes.push(v), this.bboxes.push(x);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(a, d, p, v, x, E) {
          this.cells[x].push(E);
        }
        query(a, d, p, v, x) {
          const E = this.min, L = this.max;
          if (a <= E && d <= E && L <= p && L <= v && !x) return Array.prototype.slice.call(this.keys);
          {
            const R = [];
            return this._forEachCell(a, d, p, v, this._queryCell, R, {}, x), R;
          }
        }
        _queryCell(a, d, p, v, x, E, L, R) {
          const F = this.cells[x];
          if (F !== null) {
            const j = this.keys, q = this.bboxes;
            for (let Y = 0; Y < F.length; Y++) {
              const ee = F[Y];
              if (L[ee] === void 0) {
                const se = 4 * ee;
                (R ? R(q[se + 0], q[se + 1], q[se + 2], q[se + 3]) : a <= q[se + 2] && d <= q[se + 3] && p >= q[se + 0] && v >= q[se + 1]) ? (L[ee] = !0, E.push(j[ee])) : L[ee] = !1;
              }
            }
          }
        }
        _forEachCell(a, d, p, v, x, E, L, R) {
          const F = this._convertToCellCoord(a), j = this._convertToCellCoord(d), q = this._convertToCellCoord(p), Y = this._convertToCellCoord(v);
          for (let ee = F; ee <= q; ee++) for (let se = j; se <= Y; se++) {
            const de = this.d * se + ee;
            if ((!R || R(this._convertFromCellCoord(ee), this._convertFromCellCoord(se), this._convertFromCellCoord(ee + 1), this._convertFromCellCoord(se + 1))) && x.call(this, a, d, p, v, de, E, L, R)) return;
          }
        }
        _convertFromCellCoord(a) {
          return (a - this.padding) / this.scale;
        }
        _convertToCellCoord(a) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(a * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const a = this.cells, d = 3 + this.cells.length + 1 + 1;
          let p = 0;
          for (let E = 0; E < this.cells.length; E++) p += this.cells[E].length;
          const v = new Int32Array(d + p + this.keys.length + this.bboxes.length);
          v[0] = this.extent, v[1] = this.n, v[2] = this.padding;
          let x = d;
          for (let E = 0; E < a.length; E++) {
            const L = a[E];
            v[3 + E] = x, v.set(L, x), x += L.length;
          }
          return v[3 + a.length] = x, v.set(this.keys, x), x += this.keys.length, v[3 + a.length + 1] = x, v.set(this.bboxes, x), x += this.bboxes.length, v.buffer;
        }
        static serialize(a, d) {
          const p = a.toArrayBuffer();
          return d && d.push(p), { buffer: p };
        }
        static deserialize(a) {
          return new Zl(a.buffer);
        }
      }
      const Vs = {};
      function qt(u, a) {
        let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (Vs[u]) throw new Error(`${u} is already registered.`);
        Object.defineProperty(a, "_classRegistryKey", { value: u, writeable: !1 }), Vs[u] = { klass: a, omit: d.omit || [], shallow: d.shallow || [] };
      }
      qt("Object", Object), qt("TransferableGridIndex", Zl), qt("Color", Jn), qt("Error", Error), qt("AJAXError", He), qt("ResolvedImage", Er), qt("StylePropertyFunction", Ns), qt("StyleExpression", Ma, { omit: ["_evaluator"] }), qt("ZoomDependentExpression", ks), qt("ZoomConstantExpression", cs), qt("CompoundExpression", Pi, { omit: ["_evaluate"] });
      for (const u in Lo) Lo[u]._classRegistryKey || qt(`Expression_${u}`, Lo[u]);
      function yo(u) {
        return u && typeof ArrayBuffer < "u" && (u instanceof ArrayBuffer || u.constructor && u.constructor.name === "ArrayBuffer");
      }
      function Es(u) {
        return u.$name || u.constructor._classRegistryKey;
      }
      function Do(u) {
        return !function(a) {
          if (a === null || typeof a != "object") return !1;
          const d = Es(a);
          return !(!d || d === "Object");
        }(u) && (u == null || typeof u == "boolean" || typeof u == "number" || typeof u == "string" || u instanceof Boolean || u instanceof Number || u instanceof String || u instanceof Date || u instanceof RegExp || u instanceof Blob || u instanceof Error || yo(u) || st(u) || ArrayBuffer.isView(u) || u instanceof ImageData);
      }
      function Jl(u, a) {
        if (Do(u)) return (yo(u) || st(u)) && a && a.push(u), ArrayBuffer.isView(u) && a && a.push(u.buffer), u instanceof ImageData && a && a.push(u.data.buffer), u;
        if (Array.isArray(u)) {
          const x = [];
          for (const E of u) x.push(Jl(E, a));
          return x;
        }
        if (typeof u != "object") throw new Error("can't serialize object of type " + typeof u);
        const d = Es(u);
        if (!d) throw new Error(`can't serialize object of unregistered class ${u.constructor.name}`);
        if (!Vs[d]) throw new Error(`${d} is not registered.`);
        const { klass: p } = Vs[d], v = p.serialize ? p.serialize(u, a) : {};
        if (p.serialize) {
          if (a && v === a[a.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const x in u) {
            if (!u.hasOwnProperty(x) || Vs[d].omit.indexOf(x) >= 0) continue;
            const E = u[x];
            v[x] = Vs[d].shallow.indexOf(x) >= 0 ? E : Jl(E, a);
          }
          u instanceof Error && (v.message = u.message);
        }
        if (v.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return d !== "Object" && (v.$name = d), v;
      }
      function ll(u) {
        if (Do(u)) return u;
        if (Array.isArray(u)) return u.map(ll);
        if (typeof u != "object") throw new Error("can't deserialize object of type " + typeof u);
        const a = Es(u) || "Object";
        if (!Vs[a]) throw new Error(`can't deserialize unregistered class ${a}`);
        const { klass: d } = Vs[a];
        if (!d) throw new Error(`can't deserialize unregistered class ${a}`);
        if (d.deserialize) return d.deserialize(u);
        const p = Object.create(d.prototype);
        for (const v of Object.keys(u)) {
          if (v === "$name") continue;
          const x = u[v];
          p[v] = Vs[a].shallow.indexOf(v) >= 0 ? x : ll(x);
        }
        return p;
      }
      class Fo {
        constructor() {
          this.first = !0;
        }
        update(a, d) {
          const p = Math.floor(a);
          return this.first ? (this.first = !1, this.lastIntegerZoom = p, this.lastIntegerZoomTime = 0, this.lastZoom = a, this.lastFloorZoom = p, !0) : (this.lastFloorZoom > p ? (this.lastIntegerZoom = p + 1, this.lastIntegerZoomTime = d) : this.lastFloorZoom < p && (this.lastIntegerZoom = p, this.lastIntegerZoomTime = d), a !== this.lastZoom && (this.lastZoom = a, this.lastFloorZoom = p, !0));
        }
      }
      const Cn = { "Latin-1 Supplement": (u) => u >= 128 && u <= 255, "Hangul Jamo": (u) => u >= 4352 && u <= 4607, Khmer: (u) => u >= 6016 && u <= 6143, "General Punctuation": (u) => u >= 8192 && u <= 8303, "Letterlike Symbols": (u) => u >= 8448 && u <= 8527, "Number Forms": (u) => u >= 8528 && u <= 8591, "Miscellaneous Technical": (u) => u >= 8960 && u <= 9215, "Control Pictures": (u) => u >= 9216 && u <= 9279, "Optical Character Recognition": (u) => u >= 9280 && u <= 9311, "Enclosed Alphanumerics": (u) => u >= 9312 && u <= 9471, "Geometric Shapes": (u) => u >= 9632 && u <= 9727, "Miscellaneous Symbols": (u) => u >= 9728 && u <= 9983, "Miscellaneous Symbols and Arrows": (u) => u >= 11008 && u <= 11263, "Ideographic Description Characters": (u) => u >= 12272 && u <= 12287, "CJK Symbols and Punctuation": (u) => u >= 12288 && u <= 12351, Katakana: (u) => u >= 12448 && u <= 12543, Kanbun: (u) => u >= 12688 && u <= 12703, "CJK Strokes": (u) => u >= 12736 && u <= 12783, "Enclosed CJK Letters and Months": (u) => u >= 12800 && u <= 13055, "CJK Compatibility": (u) => u >= 13056 && u <= 13311, "Yijing Hexagram Symbols": (u) => u >= 19904 && u <= 19967, "Private Use Area": (u) => u >= 57344 && u <= 63743, "Vertical Forms": (u) => u >= 65040 && u <= 65055, "CJK Compatibility Forms": (u) => u >= 65072 && u <= 65103, "Small Form Variants": (u) => u >= 65104 && u <= 65135, "Halfwidth and Fullwidth Forms": (u) => u >= 65280 && u <= 65519 };
      function sh(u) {
        for (const a of u) if (ah(a.charCodeAt(0))) return !0;
        return !1;
      }
      function hf(u) {
        for (const a of u) if (!cl(a.charCodeAt(0))) return !1;
        return !0;
      }
      function mu(u) {
        const a = u.map((d) => {
          try {
            return new RegExp(`\\p{sc=${d}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((d) => d);
        return new RegExp(a.join("|"), "u");
      }
      const $h = mu(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function cl(u) {
        return !$h.test(String.fromCodePoint(u));
      }
      const oh = mu(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function ah(u) {
        return !(u !== 746 && u !== 747 && (u < 4352 || !(Cn["CJK Compatibility Forms"](u) && !(u >= 65097 && u <= 65103) || Cn["CJK Compatibility"](u) || Cn["CJK Strokes"](u) || !(!Cn["CJK Symbols and Punctuation"](u) || u >= 12296 && u <= 12305 || u >= 12308 && u <= 12319 || u === 12336) || Cn["Enclosed CJK Letters and Months"](u) || Cn["Ideographic Description Characters"](u) || Cn.Kanbun(u) || Cn.Katakana(u) && u !== 12540 || !(!Cn["Halfwidth and Fullwidth Forms"](u) || u === 65288 || u === 65289 || u === 65293 || u >= 65306 && u <= 65310 || u === 65339 || u === 65341 || u === 65343 || u >= 65371 && u <= 65503 || u === 65507 || u >= 65512 && u <= 65519) || !(!Cn["Small Form Variants"](u) || u >= 65112 && u <= 65118 || u >= 65123 && u <= 65126) || Cn["Vertical Forms"](u) || Cn["Yijing Hexagram Symbols"](u) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(u)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(u)) || oh.test(String.fromCodePoint(u)))));
      }
      function Dc(u) {
        return !(ah(u) || function(a) {
          return !!(Cn["Latin-1 Supplement"](a) && (a === 167 || a === 169 || a === 174 || a === 177 || a === 188 || a === 189 || a === 190 || a === 215 || a === 247) || Cn["General Punctuation"](a) && (a === 8214 || a === 8224 || a === 8225 || a === 8240 || a === 8241 || a === 8251 || a === 8252 || a === 8258 || a === 8263 || a === 8264 || a === 8265 || a === 8273) || Cn["Letterlike Symbols"](a) || Cn["Number Forms"](a) || Cn["Miscellaneous Technical"](a) && (a >= 8960 && a <= 8967 || a >= 8972 && a <= 8991 || a >= 8996 && a <= 9e3 || a === 9003 || a >= 9085 && a <= 9114 || a >= 9150 && a <= 9165 || a === 9167 || a >= 9169 && a <= 9179 || a >= 9186 && a <= 9215) || Cn["Control Pictures"](a) && a !== 9251 || Cn["Optical Character Recognition"](a) || Cn["Enclosed Alphanumerics"](a) || Cn["Geometric Shapes"](a) || Cn["Miscellaneous Symbols"](a) && !(a >= 9754 && a <= 9759) || Cn["Miscellaneous Symbols and Arrows"](a) && (a >= 11026 && a <= 11055 || a >= 11088 && a <= 11097 || a >= 11192 && a <= 11243) || Cn["CJK Symbols and Punctuation"](a) || Cn.Katakana(a) || Cn["Private Use Area"](a) || Cn["CJK Compatibility Forms"](a) || Cn["Small Form Variants"](a) || Cn["Halfwidth and Fullwidth Forms"](a) || a === 8734 || a === 8756 || a === 8757 || a >= 9984 && a <= 10087 || a >= 10102 && a <= 10131 || a === 65532 || a === 65533);
        }(u));
      }
      const _u = mu(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function ul(u) {
        return _u.test(String.fromCodePoint(u));
      }
      function lh(u, a) {
        return !(!a && ul(u) || u >= 2304 && u <= 3583 || u >= 3840 && u <= 4255 || Cn.Khmer(u));
      }
      function Zh(u) {
        for (const a of u) if (ul(a.charCodeAt(0))) return !0;
        return !1;
      }
      const Ts = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(u) {
          this.pluginStatus = u.pluginStatus, this.pluginURL = u.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(u) {
          this.applyArabicShaping = u.applyArabicShaping, this.processBidirectionalText = u.processBidirectionalText, this.processStyledBidirectionalText = u.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class vr {
        constructor(a, d) {
          this.zoom = a, d ? (this.now = d.now, this.fadeDuration = d.fadeDuration, this.zoomHistory = d.zoomHistory, this.transition = d.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Fo(), this.transition = {});
        }
        isSupportedScript(a) {
          return function(d, p) {
            for (const v of d) if (!lh(v.charCodeAt(0), p)) return !1;
            return !0;
          }(a, Ts.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const a = this.zoom, d = a - Math.floor(a), p = this.crossFadingFactor();
          return a > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: d + (1 - d) * p } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - p) * d };
        }
      }
      class Yl {
        constructor(a, d) {
          this.property = a, this.value = d, this.expression = function(p, v) {
            if (Ki(p)) return new Ns(p, v);
            if (mo(p)) {
              const x = Ba(p, v);
              if (x.result === "error") throw new Error(x.value.map((E) => `${E.key}: ${E.message}`).join(", "));
              return x.value;
            }
            {
              let x = p;
              return v.type === "color" && typeof p == "string" ? x = Jn.parse(p) : v.type !== "padding" || typeof p != "number" && !Array.isArray(p) ? v.type === "variableAnchorOffsetCollection" && Array.isArray(p) && (x = Mr.parse(p)) : x = Lr.parse(p), { kind: "constant", evaluate: () => x };
            }
          }(d === void 0 ? a.specification.default : d, a.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(a, d, p) {
          return this.property.possiblyEvaluate(this, a, d, p);
        }
      }
      class yu {
        constructor(a) {
          this.property = a, this.value = new Yl(a, void 0);
        }
        transitioned(a, d) {
          return new Jh(this.property, this.value, d, Le({}, a.transition, this.transition), a.now);
        }
        untransitioned() {
          return new Jh(this.property, this.value, null, {}, 0);
        }
      }
      class bu {
        constructor(a) {
          this._properties = a, this._values = Object.create(a.defaultTransitionablePropertyValues);
        }
        getValue(a) {
          return oe(this._values[a].value.value);
        }
        setValue(a, d) {
          Object.prototype.hasOwnProperty.call(this._values, a) || (this._values[a] = new yu(this._values[a].property)), this._values[a].value = new Yl(this._values[a].property, d === null ? void 0 : oe(d));
        }
        getTransition(a) {
          return oe(this._values[a].transition);
        }
        setTransition(a, d) {
          Object.prototype.hasOwnProperty.call(this._values, a) || (this._values[a] = new yu(this._values[a].property)), this._values[a].transition = oe(d) || void 0;
        }
        serialize() {
          const a = {};
          for (const d of Object.keys(this._values)) {
            const p = this.getValue(d);
            p !== void 0 && (a[d] = p);
            const v = this.getTransition(d);
            v !== void 0 && (a[`${d}-transition`] = v);
          }
          return a;
        }
        transitioned(a, d) {
          const p = new Fc(this._properties);
          for (const v of Object.keys(this._values)) p._values[v] = this._values[v].transitioned(a, d._values[v]);
          return p;
        }
        untransitioned() {
          const a = new Fc(this._properties);
          for (const d of Object.keys(this._values)) a._values[d] = this._values[d].untransitioned();
          return a;
        }
      }
      class Jh {
        constructor(a, d, p, v, x) {
          this.property = a, this.value = d, this.begin = x + v.delay || 0, this.end = this.begin + v.duration || 0, a.specification.transition && (v.delay || v.duration) && (this.prior = p);
        }
        possiblyEvaluate(a, d, p) {
          const v = a.now || 0, x = this.value.possiblyEvaluate(a, d, p), E = this.prior;
          if (E) {
            if (v > this.end) return this.prior = null, x;
            if (this.value.isDataDriven()) return this.prior = null, x;
            if (v < this.begin) return E.possiblyEvaluate(a, d, p);
            {
              const L = (v - this.begin) / (this.end - this.begin);
              return this.property.interpolate(E.possiblyEvaluate(a, d, p), x, function(R) {
                if (R <= 0) return 0;
                if (R >= 1) return 1;
                const F = R * R, j = F * R;
                return 4 * (R < 0.5 ? j : 3 * (R - F) + j - 0.75);
              }(L));
            }
          }
          return x;
        }
      }
      class Fc {
        constructor(a) {
          this._properties = a, this._values = Object.create(a.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(a, d, p) {
          const v = new Da(this._properties);
          for (const x of Object.keys(this._values)) v._values[x] = this._values[x].possiblyEvaluate(a, d, p);
          return v;
        }
        hasTransition() {
          for (const a of Object.keys(this._values)) if (this._values[a].prior) return !0;
          return !1;
        }
      }
      class kc {
        constructor(a) {
          this._properties = a, this._values = Object.create(a.defaultPropertyValues);
        }
        hasValue(a) {
          return this._values[a].value !== void 0;
        }
        getValue(a) {
          return oe(this._values[a].value);
        }
        setValue(a, d) {
          this._values[a] = new Yl(this._values[a].property, d === null ? void 0 : oe(d));
        }
        serialize() {
          const a = {};
          for (const d of Object.keys(this._values)) {
            const p = this.getValue(d);
            p !== void 0 && (a[d] = p);
          }
          return a;
        }
        possiblyEvaluate(a, d, p) {
          const v = new Da(this._properties);
          for (const x of Object.keys(this._values)) v._values[x] = this._values[x].possiblyEvaluate(a, d, p);
          return v;
        }
      }
      class bo {
        constructor(a, d, p) {
          this.property = a, this.value = d, this.parameters = p;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(a) {
          return this.value.kind === "constant" ? this.value.value : a;
        }
        evaluate(a, d, p, v) {
          return this.property.evaluate(this.value, this.parameters, a, d, p, v);
        }
      }
      class Da {
        constructor(a) {
          this._properties = a, this._values = Object.create(a.defaultPossiblyEvaluatedValues);
        }
        get(a) {
          return this._values[a];
        }
      }
      class Yt {
        constructor(a) {
          this.specification = a;
        }
        possiblyEvaluate(a, d) {
          if (a.isDataDriven()) throw new Error("Value should not be data driven");
          return a.expression.evaluate(d);
        }
        interpolate(a, d, p) {
          const v = Ii[this.specification.type];
          return v ? v(a, d, p) : a;
        }
      }
      class gn {
        constructor(a, d) {
          this.specification = a, this.overrides = d;
        }
        possiblyEvaluate(a, d, p, v) {
          return new bo(this, a.expression.kind === "constant" || a.expression.kind === "camera" ? { kind: "constant", value: a.expression.evaluate(d, null, {}, p, v) } : a.expression, d);
        }
        interpolate(a, d, p) {
          if (a.value.kind !== "constant" || d.value.kind !== "constant") return a;
          if (a.value.value === void 0 || d.value.value === void 0) return new bo(this, { kind: "constant", value: void 0 }, a.parameters);
          const v = Ii[this.specification.type];
          if (v) {
            const x = v(a.value.value, d.value.value, p);
            return new bo(this, { kind: "constant", value: x }, a.parameters);
          }
          return a;
        }
        evaluate(a, d, p, v, x, E) {
          return a.kind === "constant" ? a.value : a.evaluate(d, p, v, x, E);
        }
      }
      class Nc extends gn {
        possiblyEvaluate(a, d, p, v) {
          if (a.value === void 0) return new bo(this, { kind: "constant", value: void 0 }, d);
          if (a.expression.kind === "constant") {
            const x = a.expression.evaluate(d, null, {}, p, v), E = a.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, L = this._calculate(E, E, E, d);
            return new bo(this, { kind: "constant", value: L }, d);
          }
          if (a.expression.kind === "camera") {
            const x = this._calculate(a.expression.evaluate({ zoom: d.zoom - 1 }), a.expression.evaluate({ zoom: d.zoom }), a.expression.evaluate({ zoom: d.zoom + 1 }), d);
            return new bo(this, { kind: "constant", value: x }, d);
          }
          return new bo(this, a.expression, d);
        }
        evaluate(a, d, p, v, x, E) {
          if (a.kind === "source") {
            const L = a.evaluate(d, p, v, x, E);
            return this._calculate(L, L, L, d);
          }
          return a.kind === "composite" ? this._calculate(a.evaluate({ zoom: Math.floor(d.zoom) - 1 }, p, v), a.evaluate({ zoom: Math.floor(d.zoom) }, p, v), a.evaluate({ zoom: Math.floor(d.zoom) + 1 }, p, v), d) : a.value;
        }
        _calculate(a, d, p, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: a, to: d } : { from: p, to: d };
        }
        interpolate(a) {
          return a;
        }
      }
      class A {
        constructor(a) {
          this.specification = a;
        }
        possiblyEvaluate(a, d, p, v) {
          if (a.value !== void 0) {
            if (a.expression.kind === "constant") {
              const x = a.expression.evaluate(d, null, {}, p, v);
              return this._calculate(x, x, x, d);
            }
            return this._calculate(a.expression.evaluate(new vr(Math.floor(d.zoom - 1), d)), a.expression.evaluate(new vr(Math.floor(d.zoom), d)), a.expression.evaluate(new vr(Math.floor(d.zoom + 1), d)), d);
          }
        }
        _calculate(a, d, p, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: a, to: d } : { from: p, to: d };
        }
        interpolate(a) {
          return a;
        }
      }
      class M {
        constructor(a) {
          this.specification = a;
        }
        possiblyEvaluate(a, d, p, v) {
          return !!a.expression.evaluate(d, null, {}, p, v);
        }
        interpolate() {
          return !1;
        }
      }
      class g {
        constructor(a) {
          this.properties = a, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const d in a) {
            const p = a[d];
            p.specification.overridable && this.overridableProperties.push(d);
            const v = this.defaultPropertyValues[d] = new Yl(p, void 0), x = this.defaultTransitionablePropertyValues[d] = new yu(p);
            this.defaultTransitioningPropertyValues[d] = x.untransitioned(), this.defaultPossiblyEvaluatedValues[d] = v.possiblyEvaluate({});
          }
        }
      }
      qt("DataDrivenProperty", gn), qt("DataConstantProperty", Yt), qt("CrossFadedDataDrivenProperty", Nc), qt("CrossFadedProperty", A), qt("ColorRampProperty", M);
      const s = "-transition";
      class h extends at {
        constructor(a, d) {
          if (super(), this.id = a.id, this.type = a.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, a.type !== "custom" && (this.metadata = a.metadata, this.minzoom = a.minzoom, this.maxzoom = a.maxzoom, a.type !== "background" && (this.source = a.source, this.sourceLayer = a["source-layer"], this.filter = a.filter), d.layout && (this._unevaluatedLayout = new kc(d.layout)), d.paint)) {
            this._transitionablePaint = new bu(d.paint);
            for (const p in a.paint) this.setPaintProperty(p, a.paint[p], { validate: !1 });
            for (const p in a.layout) this.setLayoutProperty(p, a.layout[p], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Da(d.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(a) {
          return a === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(a);
        }
        setLayoutProperty(a, d) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          d != null && this._validate(rh, `layers.${this.id}.layout.${a}`, a, d, p) || (a !== "visibility" ? this._unevaluatedLayout.setValue(a, d) : this.visibility = d);
        }
        getPaintProperty(a) {
          return a.endsWith(s) ? this._transitionablePaint.getTransition(a.slice(0, -11)) : this._transitionablePaint.getValue(a);
        }
        setPaintProperty(a, d) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (d != null && this._validate(Xh, `layers.${this.id}.paint.${a}`, a, d, p)) return !1;
          if (a.endsWith(s)) return this._transitionablePaint.setTransition(a.slice(0, -11), d || void 0), !1;
          {
            const v = this._transitionablePaint._values[a], x = v.property.specification["property-type"] === "cross-faded-data-driven", E = v.value.isDataDriven(), L = v.value;
            this._transitionablePaint.setValue(a, d), this._handleSpecialPaintPropertyUpdate(a);
            const R = this._transitionablePaint._values[a].value;
            return R.isDataDriven() || E || x || this._handleOverridablePaintPropertyUpdate(a, L, R);
          }
        }
        _handleSpecialPaintPropertyUpdate(a) {
        }
        _handleOverridablePaintPropertyUpdate(a, d, p) {
          return !1;
        }
        isHidden(a) {
          return !!(this.minzoom && a < this.minzoom) || !!(this.maxzoom && a >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(a) {
          this._transitioningPaint = this._transitionablePaint.transitioned(a, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(a, d) {
          a.getCrossfadeParameters && (this._crossfadeParameters = a.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(a, void 0, d)), this.paint = this._transitioningPaint.possiblyEvaluate(a, void 0, d);
        }
        serialize() {
          const a = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (a.layout = a.layout || {}, a.layout.visibility = this.visibility), ke(a, (d, p) => !(d === void 0 || p === "layout" && !Object.keys(d).length || p === "paint" && !Object.keys(d).length));
        }
        _validate(a, d, p, v) {
          let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return (!x || x.validate !== !1) && ih(this, a.call(ia, { key: d, layerType: this.type, objectKey: p, value: v, styleSpec: ne, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const a in this.paint._values) {
            const d = this.paint.get(a);
            if (d instanceof bo && Mo(d.property.specification) && (d.value.kind === "source" || d.value.kind === "composite") && d.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const f = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class m {
        constructor(a, d) {
          this._structArray = a, this._pos1 = d * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class y {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(a, d) {
          return a._trim(), d && (a.isTransferred = !0, d.push(a.arrayBuffer)), { length: a.length, arrayBuffer: a.arrayBuffer };
        }
        static deserialize(a) {
          const d = Object.create(this.prototype);
          return d.arrayBuffer = a.arrayBuffer, d.length = a.length, d.capacity = a.arrayBuffer.byteLength / d.bytesPerElement, d._refreshViews(), d;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(a) {
          this.reserve(a), this.length = a;
        }
        reserve(a) {
          if (a > this.capacity) {
            this.capacity = Math.max(a, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const d = this.uint8;
            this._refreshViews(), d && this.uint8.set(d);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function S(u) {
        let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, d = 0, p = 0;
        return { members: u.map((v) => {
          const x = f[v.type].BYTES_PER_ELEMENT, E = d = C(d, Math.max(a, x)), L = v.components || 1;
          return p = Math.max(p, x), d += x * L, { name: v.name, type: v.type, components: L, offset: E };
        }), size: C(d, Math.max(p, a)), alignment: a };
      }
      function C(u, a) {
        return Math.ceil(u / a) * a;
      }
      class B extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d) {
          const p = this.length;
          return this.resize(p + 1), this.emplace(p, a, d);
        }
        emplace(a, d, p) {
          const v = 2 * a;
          return this.int16[v + 0] = d, this.int16[v + 1] = p, a;
        }
      }
      B.prototype.bytesPerElement = 4, qt("StructArrayLayout2i4", B);
      class D extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, a, d, p);
        }
        emplace(a, d, p, v) {
          const x = 3 * a;
          return this.int16[x + 0] = d, this.int16[x + 1] = p, this.int16[x + 2] = v, a;
        }
      }
      D.prototype.bytesPerElement = 6, qt("StructArrayLayout3i6", D);
      class z extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, a, d, p, v);
        }
        emplace(a, d, p, v, x) {
          const E = 4 * a;
          return this.int16[E + 0] = d, this.int16[E + 1] = p, this.int16[E + 2] = v, this.int16[E + 3] = x, a;
        }
      }
      z.prototype.bytesPerElement = 8, qt("StructArrayLayout4i8", z);
      class N extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E) {
          const L = this.length;
          return this.resize(L + 1), this.emplace(L, a, d, p, v, x, E);
        }
        emplace(a, d, p, v, x, E, L) {
          const R = 6 * a;
          return this.int16[R + 0] = d, this.int16[R + 1] = p, this.int16[R + 2] = v, this.int16[R + 3] = x, this.int16[R + 4] = E, this.int16[R + 5] = L, a;
        }
      }
      N.prototype.bytesPerElement = 12, qt("StructArrayLayout2i4i12", N);
      class X extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E) {
          const L = this.length;
          return this.resize(L + 1), this.emplace(L, a, d, p, v, x, E);
        }
        emplace(a, d, p, v, x, E, L) {
          const R = 4 * a, F = 8 * a;
          return this.int16[R + 0] = d, this.int16[R + 1] = p, this.uint8[F + 4] = v, this.uint8[F + 5] = x, this.uint8[F + 6] = E, this.uint8[F + 7] = L, a;
        }
      }
      X.prototype.bytesPerElement = 8, qt("StructArrayLayout2i4ub8", X);
      class Z extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(a, d) {
          const p = this.length;
          return this.resize(p + 1), this.emplace(p, a, d);
        }
        emplace(a, d, p) {
          const v = 2 * a;
          return this.float32[v + 0] = d, this.float32[v + 1] = p, a;
        }
      }
      Z.prototype.bytesPerElement = 8, qt("StructArrayLayout2f8", Z);
      class W extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E, L, R, F, j) {
          const q = this.length;
          return this.resize(q + 1), this.emplace(q, a, d, p, v, x, E, L, R, F, j);
        }
        emplace(a, d, p, v, x, E, L, R, F, j, q) {
          const Y = 10 * a;
          return this.uint16[Y + 0] = d, this.uint16[Y + 1] = p, this.uint16[Y + 2] = v, this.uint16[Y + 3] = x, this.uint16[Y + 4] = E, this.uint16[Y + 5] = L, this.uint16[Y + 6] = R, this.uint16[Y + 7] = F, this.uint16[Y + 8] = j, this.uint16[Y + 9] = q, a;
        }
      }
      W.prototype.bytesPerElement = 20, qt("StructArrayLayout10ui20", W);
      class Q extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E, L, R, F, j, q, Y) {
          const ee = this.length;
          return this.resize(ee + 1), this.emplace(ee, a, d, p, v, x, E, L, R, F, j, q, Y);
        }
        emplace(a, d, p, v, x, E, L, R, F, j, q, Y, ee) {
          const se = 12 * a;
          return this.int16[se + 0] = d, this.int16[se + 1] = p, this.int16[se + 2] = v, this.int16[se + 3] = x, this.uint16[se + 4] = E, this.uint16[se + 5] = L, this.uint16[se + 6] = R, this.uint16[se + 7] = F, this.int16[se + 8] = j, this.int16[se + 9] = q, this.int16[se + 10] = Y, this.int16[se + 11] = ee, a;
        }
      }
      Q.prototype.bytesPerElement = 24, qt("StructArrayLayout4i4ui4i24", Q);
      class le extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, a, d, p);
        }
        emplace(a, d, p, v) {
          const x = 3 * a;
          return this.float32[x + 0] = d, this.float32[x + 1] = p, this.float32[x + 2] = v, a;
        }
      }
      le.prototype.bytesPerElement = 12, qt("StructArrayLayout3f12", le);
      class ue extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(a) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, a);
        }
        emplace(a, d) {
          return this.uint32[1 * a + 0] = d, a;
        }
      }
      ue.prototype.bytesPerElement = 4, qt("StructArrayLayout1ul4", ue);
      class fe extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E, L, R, F) {
          const j = this.length;
          return this.resize(j + 1), this.emplace(j, a, d, p, v, x, E, L, R, F);
        }
        emplace(a, d, p, v, x, E, L, R, F, j) {
          const q = 10 * a, Y = 5 * a;
          return this.int16[q + 0] = d, this.int16[q + 1] = p, this.int16[q + 2] = v, this.int16[q + 3] = x, this.int16[q + 4] = E, this.int16[q + 5] = L, this.uint32[Y + 3] = R, this.uint16[q + 8] = F, this.uint16[q + 9] = j, a;
        }
      }
      fe.prototype.bytesPerElement = 20, qt("StructArrayLayout6i1ul2ui20", fe);
      class he extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E) {
          const L = this.length;
          return this.resize(L + 1), this.emplace(L, a, d, p, v, x, E);
        }
        emplace(a, d, p, v, x, E, L) {
          const R = 6 * a;
          return this.int16[R + 0] = d, this.int16[R + 1] = p, this.int16[R + 2] = v, this.int16[R + 3] = x, this.int16[R + 4] = E, this.int16[R + 5] = L, a;
        }
      }
      he.prototype.bytesPerElement = 12, qt("StructArrayLayout2i2i2i12", he);
      class ve extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, a, d, p, v, x);
        }
        emplace(a, d, p, v, x, E) {
          const L = 4 * a, R = 8 * a;
          return this.float32[L + 0] = d, this.float32[L + 1] = p, this.float32[L + 2] = v, this.int16[R + 6] = x, this.int16[R + 7] = E, a;
        }
      }
      ve.prototype.bytesPerElement = 16, qt("StructArrayLayout2f1f2i16", ve);
      class Be extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E) {
          const L = this.length;
          return this.resize(L + 1), this.emplace(L, a, d, p, v, x, E);
        }
        emplace(a, d, p, v, x, E, L) {
          const R = 16 * a, F = 4 * a, j = 8 * a;
          return this.uint8[R + 0] = d, this.uint8[R + 1] = p, this.float32[F + 1] = v, this.float32[F + 2] = x, this.int16[j + 6] = E, this.int16[j + 7] = L, a;
        }
      }
      Be.prototype.bytesPerElement = 16, qt("StructArrayLayout2ub2f2i16", Be);
      class Pe extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, a, d, p);
        }
        emplace(a, d, p, v) {
          const x = 3 * a;
          return this.uint16[x + 0] = d, this.uint16[x + 1] = p, this.uint16[x + 2] = v, a;
        }
      }
      Pe.prototype.bytesPerElement = 6, qt("StructArrayLayout3ui6", Pe);
      class Qe extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E, L, R, F, j, q, Y, ee, se, de, we, Me) {
          const $e = this.length;
          return this.resize($e + 1), this.emplace($e, a, d, p, v, x, E, L, R, F, j, q, Y, ee, se, de, we, Me);
        }
        emplace(a, d, p, v, x, E, L, R, F, j, q, Y, ee, se, de, we, Me, $e) {
          const Ne = 24 * a, Ve = 12 * a, it = 48 * a;
          return this.int16[Ne + 0] = d, this.int16[Ne + 1] = p, this.uint16[Ne + 2] = v, this.uint16[Ne + 3] = x, this.uint32[Ve + 2] = E, this.uint32[Ve + 3] = L, this.uint32[Ve + 4] = R, this.uint16[Ne + 10] = F, this.uint16[Ne + 11] = j, this.uint16[Ne + 12] = q, this.float32[Ve + 7] = Y, this.float32[Ve + 8] = ee, this.uint8[it + 36] = se, this.uint8[it + 37] = de, this.uint8[it + 38] = we, this.uint32[Ve + 10] = Me, this.int16[Ne + 22] = $e, a;
        }
      }
      Qe.prototype.bytesPerElement = 48, qt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Qe);
      class ft extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v, x, E, L, R, F, j, q, Y, ee, se, de, we, Me, $e, Ne, Ve, it, At, Gt, mn, Ut, kt, sn, $t) {
          const Ht = this.length;
          return this.resize(Ht + 1), this.emplace(Ht, a, d, p, v, x, E, L, R, F, j, q, Y, ee, se, de, we, Me, $e, Ne, Ve, it, At, Gt, mn, Ut, kt, sn, $t);
        }
        emplace(a, d, p, v, x, E, L, R, F, j, q, Y, ee, se, de, we, Me, $e, Ne, Ve, it, At, Gt, mn, Ut, kt, sn, $t, Ht) {
          const pt = 32 * a, on = 16 * a;
          return this.int16[pt + 0] = d, this.int16[pt + 1] = p, this.int16[pt + 2] = v, this.int16[pt + 3] = x, this.int16[pt + 4] = E, this.int16[pt + 5] = L, this.int16[pt + 6] = R, this.int16[pt + 7] = F, this.uint16[pt + 8] = j, this.uint16[pt + 9] = q, this.uint16[pt + 10] = Y, this.uint16[pt + 11] = ee, this.uint16[pt + 12] = se, this.uint16[pt + 13] = de, this.uint16[pt + 14] = we, this.uint16[pt + 15] = Me, this.uint16[pt + 16] = $e, this.uint16[pt + 17] = Ne, this.uint16[pt + 18] = Ve, this.uint16[pt + 19] = it, this.uint16[pt + 20] = At, this.uint16[pt + 21] = Gt, this.uint16[pt + 22] = mn, this.uint32[on + 12] = Ut, this.float32[on + 13] = kt, this.float32[on + 14] = sn, this.uint16[pt + 30] = $t, this.uint16[pt + 31] = Ht, a;
        }
      }
      ft.prototype.bytesPerElement = 64, qt("StructArrayLayout8i15ui1ul2f2ui64", ft);
      class _t extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(a) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, a);
        }
        emplace(a, d) {
          return this.float32[1 * a + 0] = d, a;
        }
      }
      _t.prototype.bytesPerElement = 4, qt("StructArrayLayout1f4", _t);
      class xt extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, a, d, p);
        }
        emplace(a, d, p, v) {
          const x = 3 * a;
          return this.uint16[6 * a + 0] = d, this.float32[x + 1] = p, this.float32[x + 2] = v, a;
        }
      }
      xt.prototype.bytesPerElement = 12, qt("StructArrayLayout1ui2f12", xt);
      class bt extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, a, d, p);
        }
        emplace(a, d, p, v) {
          const x = 4 * a;
          return this.uint32[2 * a + 0] = d, this.uint16[x + 2] = p, this.uint16[x + 3] = v, a;
        }
      }
      bt.prototype.bytesPerElement = 8, qt("StructArrayLayout1ul2ui8", bt);
      class yt extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(a, d) {
          const p = this.length;
          return this.resize(p + 1), this.emplace(p, a, d);
        }
        emplace(a, d, p) {
          const v = 2 * a;
          return this.uint16[v + 0] = d, this.uint16[v + 1] = p, a;
        }
      }
      yt.prototype.bytesPerElement = 4, qt("StructArrayLayout2ui4", yt);
      class wt extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(a) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, a);
        }
        emplace(a, d) {
          return this.uint16[1 * a + 0] = d, a;
        }
      }
      wt.prototype.bytesPerElement = 2, qt("StructArrayLayout1ui2", wt);
      class Jt extends y {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(a, d, p, v) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, a, d, p, v);
        }
        emplace(a, d, p, v, x) {
          const E = 4 * a;
          return this.float32[E + 0] = d, this.float32[E + 1] = p, this.float32[E + 2] = v, this.float32[E + 3] = x, a;
        }
      }
      Jt.prototype.bytesPerElement = 16, qt("StructArrayLayout4f16", Jt);
      class Ct extends m {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new T(this.anchorPointX, this.anchorPointY);
        }
      }
      Ct.prototype.size = 20;
      class It extends fe {
        get(a) {
          return new Ct(this, a);
        }
      }
      qt("CollisionBoxArray", It);
      class rn extends m {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(a) {
          this._structArray.uint8[this._pos1 + 37] = a;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(a) {
          this._structArray.uint8[this._pos1 + 38] = a;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(a) {
          this._structArray.uint32[this._pos4 + 10] = a;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      rn.prototype.size = 48;
      class An extends Qe {
        get(a) {
          return new rn(this, a);
        }
      }
      qt("PlacedSymbolArray", An);
      class yn extends m {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(a) {
          this._structArray.uint32[this._pos4 + 12] = a;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      yn.prototype.size = 64;
      class En extends ft {
        get(a) {
          return new yn(this, a);
        }
      }
      qt("SymbolInstanceArray", En);
      class Dn extends _t {
        getoffsetX(a) {
          return this.float32[1 * a + 0];
        }
      }
      qt("GlyphOffsetArray", Dn);
      class sr extends D {
        getx(a) {
          return this.int16[3 * a + 0];
        }
        gety(a) {
          return this.int16[3 * a + 1];
        }
        gettileUnitDistanceFromAnchor(a) {
          return this.int16[3 * a + 2];
        }
      }
      qt("SymbolLineVertexArray", sr);
      class Dr extends m {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Dr.prototype.size = 12;
      class Qn extends xt {
        get(a) {
          return new Dr(this, a);
        }
      }
      qt("TextAnchorOffsetArray", Qn);
      class Xr extends m {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      Xr.prototype.size = 8;
      class or extends bt {
        get(a) {
          return new Xr(this, a);
        }
      }
      qt("FeatureIndexArray", or);
      class Gr extends B {
      }
      class oi extends B {
      }
      class ts extends B {
      }
      class Cs extends N {
      }
      class Fr extends X {
      }
      class Fa extends Z {
      }
      class Is extends W {
      }
      class zc extends Q {
      }
      class Kl extends le {
      }
      class zi extends ue {
      }
      class ns extends he {
      }
      class wi extends Be {
      }
      class Ui extends Pe {
      }
      class Kr extends yt {
      }
      const Li = S([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ji } = Li;
      class Hn {
        constructor() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.segments = a;
        }
        prepareSegment(a, d, p, v) {
          let x = this.segments[this.segments.length - 1];
          return a > Hn.MAX_VERTEX_ARRAY_LENGTH && Te(`Max vertices per segment is ${Hn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${a}`), (!x || x.vertexLength + a > Hn.MAX_VERTEX_ARRAY_LENGTH || x.sortKey !== v) && (x = { vertexOffset: d.length, primitiveOffset: p.length, vertexLength: 0, primitiveLength: 0 }, v !== void 0 && (x.sortKey = v), this.segments.push(x)), x;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const a of this.segments) for (const d in a.vaos) a.vaos[d].destroy();
        }
        static simpleSegment(a, d, p, v) {
          return new Hn([{ vertexOffset: a, primitiveOffset: d, vertexLength: p, primitiveLength: v, vaos: {}, sortKey: 0 }]);
        }
      }
      function ko(u, a) {
        return 256 * (u = Se(Math.floor(u), 0, 255)) + Se(Math.floor(a), 0, 255);
      }
      Hn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, qt("SegmentVector", Hn);
      const ka = S([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var sa = { exports: {} }, Ql = { exports: {} };
      Ql.exports = function(u, a) {
        var d, p, v, x, E, L, R, F;
        for (p = u.length - (d = 3 & u.length), v = a, E = 3432918353, L = 461845907, F = 0; F < p; ) R = 255 & u.charCodeAt(F) | (255 & u.charCodeAt(++F)) << 8 | (255 & u.charCodeAt(++F)) << 16 | (255 & u.charCodeAt(++F)) << 24, ++F, v = 27492 + (65535 & (x = 5 * (65535 & (v = (v ^= R = (65535 & (R = (R = (65535 & R) * E + (((R >>> 16) * E & 65535) << 16) & 4294967295) << 15 | R >>> 17)) * L + (((R >>> 16) * L & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16);
        switch (R = 0, d) {
          case 3:
            R ^= (255 & u.charCodeAt(F + 2)) << 16;
          case 2:
            R ^= (255 & u.charCodeAt(F + 1)) << 8;
          case 1:
            v ^= R = (65535 & (R = (R = (65535 & (R ^= 255 & u.charCodeAt(F))) * E + (((R >>> 16) * E & 65535) << 16) & 4294967295) << 15 | R >>> 17)) * L + (((R >>> 16) * L & 65535) << 16) & 4294967295;
        }
        return v ^= u.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
      };
      var df = Ql.exports, Yh = { exports: {} };
      Yh.exports = function(u, a) {
        for (var d, p = u.length, v = a ^ p, x = 0; p >= 4; ) d = 1540483477 * (65535 & (d = 255 & u.charCodeAt(x) | (255 & u.charCodeAt(++x)) << 8 | (255 & u.charCodeAt(++x)) << 16 | (255 & u.charCodeAt(++x)) << 24)) + ((1540483477 * (d >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (d = 1540483477 * (65535 & (d ^= d >>> 24)) + ((1540483477 * (d >>> 16) & 65535) << 16)), p -= 4, ++x;
        switch (p) {
          case 3:
            v ^= (255 & u.charCodeAt(x + 2)) << 16;
          case 2:
            v ^= (255 & u.charCodeAt(x + 1)) << 8;
          case 1:
            v = 1540483477 * (65535 & (v ^= 255 & u.charCodeAt(x))) + ((1540483477 * (v >>> 16) & 65535) << 16);
        }
        return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
      };
      var No = df, oa = Yh.exports;
      sa.exports = No, sa.exports.murmur3 = No, sa.exports.murmur2 = oa;
      var vu = _(sa.exports);
      class Uc {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(a, d, p, v) {
          this.ids.push(xu(a)), this.positions.push(d, p, v);
        }
        getPositions(a) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const d = xu(a);
          let p = 0, v = this.ids.length - 1;
          for (; p < v; ) {
            const E = p + v >> 1;
            this.ids[E] >= d ? v = E : p = E + 1;
          }
          const x = [];
          for (; this.ids[p] === d; ) x.push({ index: this.positions[3 * p], start: this.positions[3 * p + 1], end: this.positions[3 * p + 2] }), p++;
          return x;
        }
        static serialize(a, d) {
          const p = new Float64Array(a.ids), v = new Uint32Array(a.positions);
          return jc(p, v, 0, p.length - 1), d && d.push(p.buffer, v.buffer), { ids: p, positions: v };
        }
        static deserialize(a) {
          const d = new Uc();
          return d.ids = a.ids, d.positions = a.positions, d.indexed = !0, d;
        }
      }
      function xu(u) {
        const a = +u;
        return !isNaN(a) && a <= Number.MAX_SAFE_INTEGER ? a : vu(String(u));
      }
      function jc(u, a, d, p) {
        for (; d < p; ) {
          const v = u[d + p >> 1];
          let x = d - 1, E = p + 1;
          for (; ; ) {
            do
              x++;
            while (u[x] < v);
            do
              E--;
            while (u[E] > v);
            if (x >= E) break;
            aa(u, x, E), aa(a, 3 * x, 3 * E), aa(a, 3 * x + 1, 3 * E + 1), aa(a, 3 * x + 2, 3 * E + 2);
          }
          E - d < p - E ? (jc(u, a, d, E), d = E + 1) : (jc(u, a, E + 1, p), p = E);
        }
      }
      function aa(u, a, d) {
        const p = u[a];
        u[a] = u[d], u[d] = p;
      }
      qt("FeaturePositionMap", Uc);
      class ec {
        constructor(a, d) {
          this.gl = a.gl, this.location = d;
        }
      }
      class ch extends ec {
        constructor(a, d) {
          super(a, d), this.current = 0;
        }
        set(a) {
          this.current !== a && (this.current = a, this.gl.uniform1f(this.location, a));
        }
      }
      class uh extends ec {
        constructor(a, d) {
          super(a, d), this.current = [0, 0, 0, 0];
        }
        set(a) {
          a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] && a[3] === this.current[3] || (this.current = a, this.gl.uniform4f(this.location, a[0], a[1], a[2], a[3]));
        }
      }
      class Kh extends ec {
        constructor(a, d) {
          super(a, d), this.current = Jn.transparent;
        }
        set(a) {
          a.r === this.current.r && a.g === this.current.g && a.b === this.current.b && a.a === this.current.a || (this.current = a, this.gl.uniform4f(this.location, a.r, a.g, a.b, a.a));
        }
      }
      const hh = new Float32Array(16);
      function Qh(u) {
        return [ko(255 * u.r, 255 * u.g), ko(255 * u.b, 255 * u.a)];
      }
      class dh {
        constructor(a, d, p) {
          this.value = a, this.uniformNames = d.map((v) => `u_${v}`), this.type = p;
        }
        setUniform(a, d, p) {
          a.set(p.constantOr(this.value));
        }
        getBinding(a, d, p) {
          return this.type === "color" ? new Kh(a, d) : new ch(a, d);
        }
      }
      class hl {
        constructor(a, d) {
          this.uniformNames = d.map((p) => `u_${p}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(a, d) {
          this.pixelRatioFrom = d.pixelRatio, this.pixelRatioTo = a.pixelRatio, this.patternFrom = d.tlbr, this.patternTo = a.tlbr;
        }
        setUniform(a, d, p, v) {
          const x = v === "u_pattern_to" ? this.patternTo : v === "u_pattern_from" ? this.patternFrom : v === "u_pixel_ratio_to" ? this.pixelRatioTo : v === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          x && a.set(x);
        }
        getBinding(a, d, p) {
          return p.substr(0, 9) === "u_pattern" ? new uh(a, d) : new ch(a, d);
        }
      }
      class Na {
        constructor(a, d, p, v) {
          this.expression = a, this.type = p, this.maxValue = 0, this.paintVertexAttributes = d.map((x) => ({ name: `a_${x}`, type: "Float32", components: p === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new v();
        }
        populatePaintArray(a, d, p, v, x) {
          const E = this.paintVertexArray.length, L = this.expression.evaluate(new vr(0), d, {}, v, [], x);
          this.paintVertexArray.resize(a), this._setPaintValue(E, a, L);
        }
        updatePaintArray(a, d, p, v) {
          const x = this.expression.evaluate({ zoom: 0 }, p, v);
          this._setPaintValue(a, d, x);
        }
        _setPaintValue(a, d, p) {
          if (this.type === "color") {
            const v = Qh(p);
            for (let x = a; x < d; x++) this.paintVertexArray.emplace(x, v[0], v[1]);
          } else {
            for (let v = a; v < d; v++) this.paintVertexArray.emplace(v, p);
            this.maxValue = Math.max(this.maxValue, Math.abs(p));
          }
        }
        upload(a) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = a.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class vo {
        constructor(a, d, p, v, x, E) {
          this.expression = a, this.uniformNames = d.map((L) => `u_${L}_t`), this.type = p, this.useIntegerZoom = v, this.zoom = x, this.maxValue = 0, this.paintVertexAttributes = d.map((L) => ({ name: `a_${L}`, type: "Float32", components: p === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new E();
        }
        populatePaintArray(a, d, p, v, x) {
          const E = this.expression.evaluate(new vr(this.zoom), d, {}, v, [], x), L = this.expression.evaluate(new vr(this.zoom + 1), d, {}, v, [], x), R = this.paintVertexArray.length;
          this.paintVertexArray.resize(a), this._setPaintValue(R, a, E, L);
        }
        updatePaintArray(a, d, p, v) {
          const x = this.expression.evaluate({ zoom: this.zoom }, p, v), E = this.expression.evaluate({ zoom: this.zoom + 1 }, p, v);
          this._setPaintValue(a, d, x, E);
        }
        _setPaintValue(a, d, p, v) {
          if (this.type === "color") {
            const x = Qh(p), E = Qh(v);
            for (let L = a; L < d; L++) this.paintVertexArray.emplace(L, x[0], x[1], E[0], E[1]);
          } else {
            for (let x = a; x < d; x++) this.paintVertexArray.emplace(x, p, v);
            this.maxValue = Math.max(this.maxValue, Math.abs(p), Math.abs(v));
          }
        }
        upload(a) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = a.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(a, d) {
          const p = this.useIntegerZoom ? Math.floor(d.zoom) : d.zoom, v = Se(this.expression.interpolationFactor(p, this.zoom, this.zoom + 1), 0, 1);
          a.set(v);
        }
        getBinding(a, d, p) {
          return new ch(a, d);
        }
      }
      class Ps {
        constructor(a, d, p, v, x, E) {
          this.expression = a, this.type = d, this.useIntegerZoom = p, this.zoom = v, this.layerId = E, this.zoomInPaintVertexArray = new x(), this.zoomOutPaintVertexArray = new x();
        }
        populatePaintArray(a, d, p) {
          const v = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(a), this.zoomOutPaintVertexArray.resize(a), this._setPaintValues(v, a, d.patterns && d.patterns[this.layerId], p);
        }
        updatePaintArray(a, d, p, v, x) {
          this._setPaintValues(a, d, p.patterns && p.patterns[this.layerId], x);
        }
        _setPaintValues(a, d, p, v) {
          if (!v || !p) return;
          const { min: x, mid: E, max: L } = p, R = v[x], F = v[E], j = v[L];
          if (R && F && j) for (let q = a; q < d; q++) this.zoomInPaintVertexArray.emplace(q, F.tl[0], F.tl[1], F.br[0], F.br[1], R.tl[0], R.tl[1], R.br[0], R.br[1], F.pixelRatio, R.pixelRatio), this.zoomOutPaintVertexArray.emplace(q, F.tl[0], F.tl[1], F.br[0], F.br[1], j.tl[0], j.tl[1], j.br[0], j.br[1], F.pixelRatio, j.pixelRatio);
        }
        upload(a) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = a.createVertexBuffer(this.zoomInPaintVertexArray, ka.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = a.createVertexBuffer(this.zoomOutPaintVertexArray, ka.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class ff {
        constructor(a, d, p) {
          this.binders = {}, this._buffers = [];
          const v = [];
          for (const x in a.paint._values) {
            if (!p(x)) continue;
            const E = a.paint.get(x);
            if (!(E instanceof bo && Mo(E.property.specification))) continue;
            const L = r0(x, a.type), R = E.value, F = E.property.specification.type, j = E.property.useIntegerZoom, q = E.property.specification["property-type"], Y = q === "cross-faded" || q === "cross-faded-data-driven";
            if (R.kind === "constant") this.binders[x] = Y ? new hl(R.value, L) : new dh(R.value, L, F), v.push(`/u_${x}`);
            else if (R.kind === "source" || Y) {
              const ee = pf(x, F, "source");
              this.binders[x] = Y ? new Ps(R, F, j, d, ee, a.id) : new Na(R, L, F, ee), v.push(`/a_${x}`);
            } else {
              const ee = pf(x, F, "composite");
              this.binders[x] = new vo(R, L, F, j, d, ee), v.push(`/z_${x}`);
            }
          }
          this.cacheKey = v.sort().join("");
        }
        getMaxValue(a) {
          const d = this.binders[a];
          return d instanceof Na || d instanceof vo ? d.maxValue : 0;
        }
        populatePaintArrays(a, d, p, v, x) {
          for (const E in this.binders) {
            const L = this.binders[E];
            (L instanceof Na || L instanceof vo || L instanceof Ps) && L.populatePaintArray(a, d, p, v, x);
          }
        }
        setConstantPatternPositions(a, d) {
          for (const p in this.binders) {
            const v = this.binders[p];
            v instanceof hl && v.setConstantPatternPositions(a, d);
          }
        }
        updatePaintArrays(a, d, p, v, x) {
          let E = !1;
          for (const L in a) {
            const R = d.getPositions(L);
            for (const F of R) {
              const j = p.feature(F.index);
              for (const q in this.binders) {
                const Y = this.binders[q];
                if ((Y instanceof Na || Y instanceof vo || Y instanceof Ps) && Y.expression.isStateDependent === !0) {
                  const ee = v.paint.get(q);
                  Y.expression = ee.value, Y.updatePaintArray(F.start, F.end, j, a[L], x), E = !0;
                }
              }
            }
          }
          return E;
        }
        defines() {
          const a = [];
          for (const d in this.binders) {
            const p = this.binders[d];
            (p instanceof dh || p instanceof hl) && a.push(...p.uniformNames.map((v) => `#define HAS_UNIFORM_${v}`));
          }
          return a;
        }
        getBinderAttributes() {
          const a = [];
          for (const d in this.binders) {
            const p = this.binders[d];
            if (p instanceof Na || p instanceof vo) for (let v = 0; v < p.paintVertexAttributes.length; v++) a.push(p.paintVertexAttributes[v].name);
            else if (p instanceof Ps) for (let v = 0; v < ka.members.length; v++) a.push(ka.members[v].name);
          }
          return a;
        }
        getBinderUniforms() {
          const a = [];
          for (const d in this.binders) {
            const p = this.binders[d];
            if (p instanceof dh || p instanceof hl || p instanceof vo) for (const v of p.uniformNames) a.push(v);
          }
          return a;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(a, d) {
          const p = [];
          for (const v in this.binders) {
            const x = this.binders[v];
            if (x instanceof dh || x instanceof hl || x instanceof vo) {
              for (const E of x.uniformNames) if (d[E]) {
                const L = x.getBinding(a, d[E], E);
                p.push({ name: E, property: v, binding: L });
              }
            }
          }
          return p;
        }
        setUniforms(a, d, p, v) {
          for (const { name: x, property: E, binding: L } of d) this.binders[E].setUniform(L, v, p.get(E), x);
        }
        updatePaintBuffers(a) {
          this._buffers = [];
          for (const d in this.binders) {
            const p = this.binders[d];
            if (a && p instanceof Ps) {
              const v = a.fromScale === 2 ? p.zoomInPaintVertexBuffer : p.zoomOutPaintVertexBuffer;
              v && this._buffers.push(v);
            } else (p instanceof Na || p instanceof vo) && p.paintVertexBuffer && this._buffers.push(p.paintVertexBuffer);
          }
        }
        upload(a) {
          for (const d in this.binders) {
            const p = this.binders[d];
            (p instanceof Na || p instanceof vo || p instanceof Ps) && p.upload(a);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const a in this.binders) {
            const d = this.binders[a];
            (d instanceof Na || d instanceof vo || d instanceof Ps) && d.destroy();
          }
        }
      }
      class tc {
        constructor(a, d) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => !0;
          this.programConfigurations = {};
          for (const v of a) this.programConfigurations[v.id] = new ff(v, d, p);
          this.needsUpload = !1, this._featureMap = new Uc(), this._bufferOffset = 0;
        }
        populatePaintArrays(a, d, p, v, x, E) {
          for (const L in this.programConfigurations) this.programConfigurations[L].populatePaintArrays(a, d, v, x, E);
          d.id !== void 0 && this._featureMap.add(d.id, p, this._bufferOffset, a), this._bufferOffset = a, this.needsUpload = !0;
        }
        updatePaintArrays(a, d, p, v) {
          for (const x of p) this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(a, this._featureMap, d, x, v) || this.needsUpload;
        }
        get(a) {
          return this.programConfigurations[a];
        }
        upload(a) {
          if (this.needsUpload) {
            for (const d in this.programConfigurations) this.programConfigurations[d].upload(a);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const a in this.programConfigurations) this.programConfigurations[a].destroy();
        }
      }
      function r0(u, a) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[u] || [u.replace(`${a}-`, "").replace(/-/g, "_")];
      }
      function pf(u, a, d) {
        const p = { color: { source: Z, composite: Jt }, number: { source: _t, composite: Z } }, v = function(x) {
          return { "line-pattern": { source: Is, composite: Is }, "fill-pattern": { source: Is, composite: Is }, "fill-extrusion-pattern": { source: Is, composite: Is } }[x];
        }(u);
        return v && v[d] || p[a][d];
      }
      qt("ConstantBinder", dh), qt("CrossFadedConstantBinder", hl), qt("SourceExpressionBinder", Na), qt("CrossFadedCompositeBinder", Ps), qt("CompositeExpressionBinder", vo), qt("ProgramConfiguration", ff, { omit: ["_buffers"] }), qt("ProgramConfigurationSet", tc);
      const kr = 8192, gf = Math.pow(2, 14) - 1, mf = -gf - 1;
      function Gc(u) {
        const a = kr / u.extent, d = u.loadGeometry();
        for (let p = 0; p < d.length; p++) {
          const v = d[p];
          for (let x = 0; x < v.length; x++) {
            const E = v[x], L = Math.round(E.x * a), R = Math.round(E.y * a);
            E.x = Se(L, mf, gf), E.y = Se(R, mf, gf), (L < E.x || L > E.x + 1 || R < E.y || R > E.y + 1) && Te("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return d;
      }
      function nc(u, a) {
        return { type: u.type, id: u.id, properties: u.properties, geometry: a ? Gc(u) : [] };
      }
      function ed(u, a, d, p, v) {
        u.emplaceBack(2 * a + (p + 1) / 2, 2 * d + (v + 1) / 2);
      }
      class Vc {
        constructor(a) {
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((d) => d.id), this.index = a.index, this.hasPattern = !1, this.layoutVertexArray = new oi(), this.indexArray = new Ui(), this.segments = new Hn(), this.programConfigurations = new tc(a.layers, a.zoom), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(a, d, p) {
          const v = this.layers[0], x = [];
          let E = null, L = !1;
          v.type === "circle" && (E = v.layout.get("circle-sort-key"), L = !E.isConstant());
          for (const { feature: R, id: F, index: j, sourceLayerIndex: q } of a) {
            const Y = this.layers[0]._featureFilter.needGeometry, ee = nc(R, Y);
            if (!this.layers[0]._featureFilter.filter(new vr(this.zoom), ee, p)) continue;
            const se = L ? E.evaluate(ee, {}, p) : void 0, de = { id: F, properties: R.properties, type: R.type, sourceLayerIndex: q, index: j, geometry: Y ? ee.geometry : Gc(R), patterns: {}, sortKey: se };
            x.push(de);
          }
          L && x.sort((R, F) => R.sortKey - F.sortKey);
          for (const R of x) {
            const { geometry: F, index: j, sourceLayerIndex: q } = R, Y = a[j].feature;
            this.addFeature(R, F, j, p), d.featureIndex.insert(Y, F, j, q, this.index);
          }
        }
        update(a, d, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, d, this.stateDependentLayers, p);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(a) {
          this.uploaded || (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, ji), this.indexBuffer = a.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(a), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(a, d, p, v) {
          for (const x of d) for (const E of x) {
            const L = E.x, R = E.y;
            if (L < 0 || L >= kr || R < 0 || R >= kr) continue;
            const F = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, a.sortKey), j = F.vertexLength;
            ed(this.layoutVertexArray, L, R, -1, -1), ed(this.layoutVertexArray, L, R, 1, -1), ed(this.layoutVertexArray, L, R, 1, 1), ed(this.layoutVertexArray, L, R, -1, 1), this.indexArray.emplaceBack(j, j + 1, j + 2), this.indexArray.emplaceBack(j, j + 3, j + 2), F.vertexLength += 4, F.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, {}, v);
        }
      }
      function td(u, a) {
        for (let d = 0; d < u.length; d++) if (ic(a, u[d])) return !0;
        for (let d = 0; d < a.length; d++) if (ic(u, a[d])) return !0;
        return !!Ua(u, a);
      }
      function nd(u, a, d) {
        return !!ic(u, a) || !!fh(a, u, d);
      }
      function za(u, a) {
        if (u.length === 1) return Xp(a, u[0]);
        for (let d = 0; d < a.length; d++) {
          const p = a[d];
          for (let v = 0; v < p.length; v++) if (ic(u, p[v])) return !0;
        }
        for (let d = 0; d < u.length; d++) if (Xp(a, u[d])) return !0;
        for (let d = 0; d < a.length; d++) if (Ua(u, a[d])) return !0;
        return !1;
      }
      function rc(u, a, d) {
        if (u.length > 1) {
          if (Ua(u, a)) return !0;
          for (let p = 0; p < a.length; p++) if (fh(a[p], u, d)) return !0;
        }
        for (let p = 0; p < u.length; p++) if (fh(u[p], a, d)) return !0;
        return !1;
      }
      function Ua(u, a) {
        if (u.length === 0 || a.length === 0) return !1;
        for (let d = 0; d < u.length - 1; d++) {
          const p = u[d], v = u[d + 1];
          for (let x = 0; x < a.length - 1; x++) if (rd(p, v, a[x], a[x + 1])) return !0;
        }
        return !1;
      }
      function rd(u, a, d, p) {
        return xe(u, d, p) !== xe(a, d, p) && xe(u, a, d) !== xe(u, a, p);
      }
      function fh(u, a, d) {
        const p = d * d;
        if (a.length === 1) return u.distSqr(a[0]) < p;
        for (let v = 1; v < a.length; v++) if (_f(u, a[v - 1], a[v]) < p) return !0;
        return !1;
      }
      function _f(u, a, d) {
        const p = a.distSqr(d);
        if (p === 0) return u.distSqr(a);
        const v = ((u.x - a.x) * (d.x - a.x) + (u.y - a.y) * (d.y - a.y)) / p;
        return u.distSqr(v < 0 ? a : v > 1 ? d : d.sub(a)._mult(v)._add(a));
      }
      function Xp(u, a) {
        let d, p, v, x = !1;
        for (let E = 0; E < u.length; E++) {
          d = u[E];
          for (let L = 0, R = d.length - 1; L < d.length; R = L++) p = d[L], v = d[R], p.y > a.y != v.y > a.y && a.x < (v.x - p.x) * (a.y - p.y) / (v.y - p.y) + p.x && (x = !x);
        }
        return x;
      }
      function ic(u, a) {
        let d = !1;
        for (let p = 0, v = u.length - 1; p < u.length; v = p++) {
          const x = u[p], E = u[v];
          x.y > a.y != E.y > a.y && a.x < (E.x - x.x) * (a.y - x.y) / (E.y - x.y) + x.x && (d = !d);
        }
        return d;
      }
      function yf(u, a, d) {
        const p = d[0], v = d[2];
        if (u.x < p.x && a.x < p.x || u.x > v.x && a.x > v.x || u.y < p.y && a.y < p.y || u.y > v.y && a.y > v.y) return !1;
        const x = xe(u, a, d[0]);
        return x !== xe(u, a, d[1]) || x !== xe(u, a, d[2]) || x !== xe(u, a, d[3]);
      }
      function bf(u, a, d) {
        const p = a.paint.get(u).value;
        return p.kind === "constant" ? p.value : d.programConfigurations.get(a.id).getMaxValue(u);
      }
      function $p(u) {
        return Math.sqrt(u[0] * u[0] + u[1] * u[1]);
      }
      function Zp(u, a, d, p, v) {
        if (!a[0] && !a[1]) return u;
        const x = T.convert(a)._mult(v);
        d === "viewport" && x._rotate(-p);
        const E = [];
        for (let L = 0; L < u.length; L++) E.push(u[L].sub(x));
        return E;
      }
      let jb, Gb;
      qt("CircleBucket", Vc, { omit: ["layers"] });
      var S3 = { get paint() {
        return Gb = Gb || new g({ "circle-radius": new gn(ne.paint_circle["circle-radius"]), "circle-color": new gn(ne.paint_circle["circle-color"]), "circle-blur": new gn(ne.paint_circle["circle-blur"]), "circle-opacity": new gn(ne.paint_circle["circle-opacity"]), "circle-translate": new Yt(ne.paint_circle["circle-translate"]), "circle-translate-anchor": new Yt(ne.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Yt(ne.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Yt(ne.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new gn(ne.paint_circle["circle-stroke-width"]), "circle-stroke-color": new gn(ne.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new gn(ne.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return jb = jb || new g({ "circle-sort-key": new gn(ne.layout_circle["circle-sort-key"]) });
      } }, qs = 1e-6, id = typeof Float32Array < "u" ? Float32Array : Array;
      function i0(u) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function Vb(u, a, d) {
        var p = a[0], v = a[1], x = a[2], E = a[3], L = a[4], R = a[5], F = a[6], j = a[7], q = a[8], Y = a[9], ee = a[10], se = a[11], de = a[12], we = a[13], Me = a[14], $e = a[15], Ne = d[0], Ve = d[1], it = d[2], At = d[3];
        return u[0] = Ne * p + Ve * L + it * q + At * de, u[1] = Ne * v + Ve * R + it * Y + At * we, u[2] = Ne * x + Ve * F + it * ee + At * Me, u[3] = Ne * E + Ve * j + it * se + At * $e, u[4] = (Ne = d[4]) * p + (Ve = d[5]) * L + (it = d[6]) * q + (At = d[7]) * de, u[5] = Ne * v + Ve * R + it * Y + At * we, u[6] = Ne * x + Ve * F + it * ee + At * Me, u[7] = Ne * E + Ve * j + it * se + At * $e, u[8] = (Ne = d[8]) * p + (Ve = d[9]) * L + (it = d[10]) * q + (At = d[11]) * de, u[9] = Ne * v + Ve * R + it * Y + At * we, u[10] = Ne * x + Ve * F + it * ee + At * Me, u[11] = Ne * E + Ve * j + it * se + At * $e, u[12] = (Ne = d[12]) * p + (Ve = d[13]) * L + (it = d[14]) * q + (At = d[15]) * de, u[13] = Ne * v + Ve * R + it * Y + At * we, u[14] = Ne * x + Ve * F + it * ee + At * Me, u[15] = Ne * E + Ve * j + it * se + At * $e, u;
      }
      Math.hypot || (Math.hypot = function() {
        for (var u = 0, a = arguments.length; a--; ) u += arguments[a] * arguments[a];
        return Math.sqrt(u);
      });
      var vf, E3 = Vb;
      function Jp(u, a, d) {
        var p = a[0], v = a[1], x = a[2], E = a[3];
        return u[0] = d[0] * p + d[4] * v + d[8] * x + d[12] * E, u[1] = d[1] * p + d[5] * v + d[9] * x + d[13] * E, u[2] = d[2] * p + d[6] * v + d[10] * x + d[14] * E, u[3] = d[3] * p + d[7] * v + d[11] * x + d[15] * E, u;
      }
      vf = new id(4), id != Float32Array && (vf[0] = 0, vf[1] = 0, vf[2] = 0, vf[3] = 0);
      class T3 extends h {
        constructor(a) {
          super(a, S3);
        }
        createBucket(a) {
          return new Vc(a);
        }
        queryRadius(a) {
          const d = a;
          return bf("circle-radius", this, d) + bf("circle-stroke-width", this, d) + $p(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(a, d, p, v, x, E, L, R) {
          const F = Zp(a, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), E.angle, L), j = this.paint.get("circle-radius").evaluate(d, p) + this.paint.get("circle-stroke-width").evaluate(d, p), q = this.paint.get("circle-pitch-alignment") === "map", Y = q ? F : function(se, de) {
            return se.map((we) => qb(we, de));
          }(F, R), ee = q ? j * L : j;
          for (const se of v) for (const de of se) {
            const we = q ? de : qb(de, R);
            let Me = ee;
            const $e = Jp([], [de.x, de.y, 0, 1], R);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Me *= $e[3] / E.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Me *= E.cameraToCenterDistance / $e[3]), nd(Y, we, Me)) return !0;
          }
          return !1;
        }
      }
      function qb(u, a) {
        const d = Jp([], [u.x, u.y, 0, 1], a);
        return new T(d[0] / d[3], d[1] / d[3]);
      }
      class Hb extends Vc {
      }
      let Wb;
      qt("HeatmapBucket", Hb, { omit: ["layers"] });
      var C3 = { get paint() {
        return Wb = Wb || new g({ "heatmap-radius": new gn(ne.paint_heatmap["heatmap-radius"]), "heatmap-weight": new gn(ne.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Yt(ne.paint_heatmap["heatmap-intensity"]), "heatmap-color": new M(ne.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Yt(ne.paint_heatmap["heatmap-opacity"]) });
      } };
      function s0(u, a, d, p) {
        let { width: v, height: x } = a;
        if (p) {
          if (p instanceof Uint8ClampedArray) p = new Uint8Array(p.buffer);
          else if (p.length !== v * x * d) throw new RangeError(`mismatched image size. expected: ${p.length} but got: ${v * x * d}`);
        } else p = new Uint8Array(v * x * d);
        return u.width = v, u.height = x, u.data = p, u;
      }
      function Xb(u, a, d) {
        let { width: p, height: v } = a;
        if (p === u.width && v === u.height) return;
        const x = s0({}, { width: p, height: v }, d);
        o0(u, x, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(u.width, p), height: Math.min(u.height, v) }, d), u.width = p, u.height = v, u.data = x.data;
      }
      function o0(u, a, d, p, v, x) {
        if (v.width === 0 || v.height === 0) return a;
        if (v.width > u.width || v.height > u.height || d.x > u.width - v.width || d.y > u.height - v.height) throw new RangeError("out of range source coordinates for image copy");
        if (v.width > a.width || v.height > a.height || p.x > a.width - v.width || p.y > a.height - v.height) throw new RangeError("out of range destination coordinates for image copy");
        const E = u.data, L = a.data;
        if (E === L) throw new Error("srcData equals dstData, so image is already copied");
        for (let R = 0; R < v.height; R++) {
          const F = ((d.y + R) * u.width + d.x) * x, j = ((p.y + R) * a.width + p.x) * x;
          for (let q = 0; q < v.width * x; q++) L[j + q] = E[F + q];
        }
        return a;
      }
      class xf {
        constructor(a, d) {
          s0(this, a, 1, d);
        }
        resize(a) {
          Xb(this, a, 1);
        }
        clone() {
          return new xf({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(a, d, p, v, x) {
          o0(a, d, p, v, x, 1);
        }
      }
      class la {
        constructor(a, d) {
          s0(this, a, 4, d);
        }
        resize(a) {
          Xb(this, a, 4);
        }
        replace(a, d) {
          d ? this.data.set(a) : this.data = a instanceof Uint8ClampedArray ? new Uint8Array(a.buffer) : a;
        }
        clone() {
          return new la({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(a, d, p, v, x) {
          o0(a, d, p, v, x, 4);
        }
      }
      function $b(u) {
        const a = {}, d = u.resolution || 256, p = u.clips ? u.clips.length : 1, v = u.image || new la({ width: d, height: p });
        if (Math.log(d) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${d}`);
        const x = (E, L, R) => {
          a[u.evaluationKey] = R;
          const F = u.expression.evaluate(a);
          v.data[E + L + 0] = Math.floor(255 * F.r / F.a), v.data[E + L + 1] = Math.floor(255 * F.g / F.a), v.data[E + L + 2] = Math.floor(255 * F.b / F.a), v.data[E + L + 3] = Math.floor(255 * F.a);
        };
        if (u.clips) for (let E = 0, L = 0; E < p; ++E, L += 4 * d) for (let R = 0, F = 0; R < d; R++, F += 4) {
          const j = R / (d - 1), { start: q, end: Y } = u.clips[E];
          x(L, F, q * (1 - j) + Y * j);
        }
        else for (let E = 0, L = 0; E < d; E++, L += 4) x(0, L, E / (d - 1));
        return v;
      }
      qt("AlphaImage", xf), qt("RGBAImage", la);
      const a0 = "big-fb";
      class I3 extends h {
        createBucket(a) {
          return new Hb(a);
        }
        constructor(a) {
          super(a, C3), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(a) {
          a === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = $b({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(a0) && this.heatmapFbos.delete(a0);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let Zb;
      var P3 = { get paint() {
        return Zb = Zb || new g({ "hillshade-illumination-direction": new Yt(ne.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Yt(ne.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Yt(ne.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Yt(ne.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Yt(ne.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Yt(ne.paint_hillshade["hillshade-accent-color"]) });
      } };
      class L3 extends h {
        constructor(a) {
          super(a, P3);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const M3 = S([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: B3 } = M3;
      function Jb(u, a) {
        let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;
        const p = a && a.length, v = p ? a[0] * d : u.length;
        let x = Yb(u, 0, v, d, !0);
        const E = [];
        if (!x || x.next === x.prev) return E;
        let L, R, F;
        if (p && (x = function(j, q, Y, ee) {
          const se = [];
          for (let de = 0, we = q.length; de < we; de++) {
            const Me = Yb(j, q[de] * ee, de < we - 1 ? q[de + 1] * ee : j.length, ee, !1);
            Me === Me.next && (Me.steiner = !0), se.push(U3(Me));
          }
          se.sort(k3);
          for (let de = 0; de < se.length; de++) Y = N3(se[de], Y);
          return Y;
        }(u, a, x, d)), u.length > 80 * d) {
          L = 1 / 0, R = 1 / 0;
          let j = -1 / 0, q = -1 / 0;
          for (let Y = d; Y < v; Y += d) {
            const ee = u[Y], se = u[Y + 1];
            ee < L && (L = ee), se < R && (R = se), ee > j && (j = ee), se > q && (q = se);
          }
          F = Math.max(j - L, q - R), F = F !== 0 ? 32767 / F : 0;
        }
        return wf(x, E, d, L, R, F, 0), E;
      }
      function Yb(u, a, d, p, v) {
        let x;
        if (v === function(E, L, R, F) {
          let j = 0;
          for (let q = L, Y = R - F; q < R; q += F) j += (E[Y] - E[q]) * (E[q + 1] + E[Y + 1]), Y = q;
          return j;
        }(u, a, d, p) > 0) for (let E = a; E < d; E += p) x = ev(E / p | 0, u[E], u[E + 1], x);
        else for (let E = d - p; E >= a; E -= p) x = ev(E / p | 0, u[E], u[E + 1], x);
        return x && Yp(x, x.next) && (Sf(x), x = x.next), x;
      }
      function ph(u, a) {
        if (!u) return u;
        a || (a = u);
        let d, p = u;
        do
          if (d = !1, p.steiner || !Yp(p, p.next) && mi(p.prev, p, p.next) !== 0) p = p.next;
          else {
            if (Sf(p), p = a = p.prev, p === p.next) break;
            d = !0;
          }
        while (d || p !== a);
        return a;
      }
      function wf(u, a, d, p, v, x, E) {
        if (!u) return;
        !E && x && function(R, F, j, q) {
          let Y = R;
          do
            Y.z === 0 && (Y.z = l0(Y.x, Y.y, F, j, q)), Y.prevZ = Y.prev, Y.nextZ = Y.next, Y = Y.next;
          while (Y !== R);
          Y.prevZ.nextZ = null, Y.prevZ = null, function(ee) {
            let se, de = 1;
            do {
              let we, Me = ee;
              ee = null;
              let $e = null;
              for (se = 0; Me; ) {
                se++;
                let Ne = Me, Ve = 0;
                for (let At = 0; At < de && (Ve++, Ne = Ne.nextZ, Ne); At++) ;
                let it = de;
                for (; Ve > 0 || it > 0 && Ne; ) Ve !== 0 && (it === 0 || !Ne || Me.z <= Ne.z) ? (we = Me, Me = Me.nextZ, Ve--) : (we = Ne, Ne = Ne.nextZ, it--), $e ? $e.nextZ = we : ee = we, we.prevZ = $e, $e = we;
                Me = Ne;
              }
              $e.nextZ = null, de *= 2;
            } while (se > 1);
          }(Y);
        }(u, p, v, x);
        let L = u;
        for (; u.prev !== u.next; ) {
          const R = u.prev, F = u.next;
          if (x ? O3(u, p, v, x) : R3(u)) a.push(R.i, u.i, F.i), Sf(u), u = F.next, L = F.next;
          else if ((u = F) === L) {
            E ? E === 1 ? wf(u = D3(ph(u), a), a, d, p, v, x, 2) : E === 2 && F3(u, a, d, p, v, x) : wf(ph(u), a, d, p, v, x, 1);
            break;
          }
        }
      }
      function R3(u) {
        const a = u.prev, d = u, p = u.next;
        if (mi(a, d, p) >= 0) return !1;
        const v = a.x, x = d.x, E = p.x, L = a.y, R = d.y, F = p.y, j = v < x ? v < E ? v : E : x < E ? x : E, q = L < R ? L < F ? L : F : R < F ? R : F, Y = v > x ? v > E ? v : E : x > E ? x : E, ee = L > R ? L > F ? L : F : R > F ? R : F;
        let se = p.next;
        for (; se !== a; ) {
          if (se.x >= j && se.x <= Y && se.y >= q && se.y <= ee && sd(v, L, x, R, E, F, se.x, se.y) && mi(se.prev, se, se.next) >= 0) return !1;
          se = se.next;
        }
        return !0;
      }
      function O3(u, a, d, p) {
        const v = u.prev, x = u, E = u.next;
        if (mi(v, x, E) >= 0) return !1;
        const L = v.x, R = x.x, F = E.x, j = v.y, q = x.y, Y = E.y, ee = L < R ? L < F ? L : F : R < F ? R : F, se = j < q ? j < Y ? j : Y : q < Y ? q : Y, de = L > R ? L > F ? L : F : R > F ? R : F, we = j > q ? j > Y ? j : Y : q > Y ? q : Y, Me = l0(ee, se, a, d, p), $e = l0(de, we, a, d, p);
        let Ne = u.prevZ, Ve = u.nextZ;
        for (; Ne && Ne.z >= Me && Ve && Ve.z <= $e; ) {
          if (Ne.x >= ee && Ne.x <= de && Ne.y >= se && Ne.y <= we && Ne !== v && Ne !== E && sd(L, j, R, q, F, Y, Ne.x, Ne.y) && mi(Ne.prev, Ne, Ne.next) >= 0 || (Ne = Ne.prevZ, Ve.x >= ee && Ve.x <= de && Ve.y >= se && Ve.y <= we && Ve !== v && Ve !== E && sd(L, j, R, q, F, Y, Ve.x, Ve.y) && mi(Ve.prev, Ve, Ve.next) >= 0)) return !1;
          Ve = Ve.nextZ;
        }
        for (; Ne && Ne.z >= Me; ) {
          if (Ne.x >= ee && Ne.x <= de && Ne.y >= se && Ne.y <= we && Ne !== v && Ne !== E && sd(L, j, R, q, F, Y, Ne.x, Ne.y) && mi(Ne.prev, Ne, Ne.next) >= 0) return !1;
          Ne = Ne.prevZ;
        }
        for (; Ve && Ve.z <= $e; ) {
          if (Ve.x >= ee && Ve.x <= de && Ve.y >= se && Ve.y <= we && Ve !== v && Ve !== E && sd(L, j, R, q, F, Y, Ve.x, Ve.y) && mi(Ve.prev, Ve, Ve.next) >= 0) return !1;
          Ve = Ve.nextZ;
        }
        return !0;
      }
      function D3(u, a) {
        let d = u;
        do {
          const p = d.prev, v = d.next.next;
          !Yp(p, v) && Kb(p, d, d.next, v) && Af(p, v) && Af(v, p) && (a.push(p.i, d.i, v.i), Sf(d), Sf(d.next), d = u = v), d = d.next;
        } while (d !== u);
        return ph(d);
      }
      function F3(u, a, d, p, v, x) {
        let E = u;
        do {
          let L = E.next.next;
          for (; L !== E.prev; ) {
            if (E.i !== L.i && j3(E, L)) {
              let R = Qb(E, L);
              return E = ph(E, E.next), R = ph(R, R.next), wf(E, a, d, p, v, x, 0), void wf(R, a, d, p, v, x, 0);
            }
            L = L.next;
          }
          E = E.next;
        } while (E !== u);
      }
      function k3(u, a) {
        return u.x - a.x;
      }
      function N3(u, a) {
        const d = function(v, x) {
          let E = x;
          const L = v.x, R = v.y;
          let F, j = -1 / 0;
          do {
            if (R <= E.y && R >= E.next.y && E.next.y !== E.y) {
              const de = E.x + (R - E.y) * (E.next.x - E.x) / (E.next.y - E.y);
              if (de <= L && de > j && (j = de, F = E.x < E.next.x ? E : E.next, de === L)) return F;
            }
            E = E.next;
          } while (E !== x);
          if (!F) return null;
          const q = F, Y = F.x, ee = F.y;
          let se = 1 / 0;
          E = F;
          do {
            if (L >= E.x && E.x >= Y && L !== E.x && sd(R < ee ? L : j, R, Y, ee, R < ee ? j : L, R, E.x, E.y)) {
              const de = Math.abs(R - E.y) / (L - E.x);
              Af(E, v) && (de < se || de === se && (E.x > F.x || E.x === F.x && z3(F, E))) && (F = E, se = de);
            }
            E = E.next;
          } while (E !== q);
          return F;
        }(u, a);
        if (!d) return a;
        const p = Qb(d, u);
        return ph(p, p.next), ph(d, d.next);
      }
      function z3(u, a) {
        return mi(u.prev, u, a.prev) < 0 && mi(a.next, u, u.next) < 0;
      }
      function l0(u, a, d, p, v) {
        return (u = 1431655765 & ((u = 858993459 & ((u = 252645135 & ((u = 16711935 & ((u = (u - d) * v | 0) | u << 8)) | u << 4)) | u << 2)) | u << 1)) | (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = (a - p) * v | 0) | a << 8)) | a << 4)) | a << 2)) | a << 1)) << 1;
      }
      function U3(u) {
        let a = u, d = u;
        do
          (a.x < d.x || a.x === d.x && a.y < d.y) && (d = a), a = a.next;
        while (a !== u);
        return d;
      }
      function sd(u, a, d, p, v, x, E, L) {
        return (v - E) * (a - L) >= (u - E) * (x - L) && (u - E) * (p - L) >= (d - E) * (a - L) && (d - E) * (x - L) >= (v - E) * (p - L);
      }
      function j3(u, a) {
        return u.next.i !== a.i && u.prev.i !== a.i && !function(d, p) {
          let v = d;
          do {
            if (v.i !== d.i && v.next.i !== d.i && v.i !== p.i && v.next.i !== p.i && Kb(v, v.next, d, p)) return !0;
            v = v.next;
          } while (v !== d);
          return !1;
        }(u, a) && (Af(u, a) && Af(a, u) && function(d, p) {
          let v = d, x = !1;
          const E = (d.x + p.x) / 2, L = (d.y + p.y) / 2;
          do
            v.y > L != v.next.y > L && v.next.y !== v.y && E < (v.next.x - v.x) * (L - v.y) / (v.next.y - v.y) + v.x && (x = !x), v = v.next;
          while (v !== d);
          return x;
        }(u, a) && (mi(u.prev, u, a.prev) || mi(u, a.prev, a)) || Yp(u, a) && mi(u.prev, u, u.next) > 0 && mi(a.prev, a, a.next) > 0);
      }
      function mi(u, a, d) {
        return (a.y - u.y) * (d.x - a.x) - (a.x - u.x) * (d.y - a.y);
      }
      function Yp(u, a) {
        return u.x === a.x && u.y === a.y;
      }
      function Kb(u, a, d, p) {
        const v = Qp(mi(u, a, d)), x = Qp(mi(u, a, p)), E = Qp(mi(d, p, u)), L = Qp(mi(d, p, a));
        return v !== x && E !== L || !(v !== 0 || !Kp(u, d, a)) || !(x !== 0 || !Kp(u, p, a)) || !(E !== 0 || !Kp(d, u, p)) || !(L !== 0 || !Kp(d, a, p));
      }
      function Kp(u, a, d) {
        return a.x <= Math.max(u.x, d.x) && a.x >= Math.min(u.x, d.x) && a.y <= Math.max(u.y, d.y) && a.y >= Math.min(u.y, d.y);
      }
      function Qp(u) {
        return u > 0 ? 1 : u < 0 ? -1 : 0;
      }
      function Af(u, a) {
        return mi(u.prev, u, u.next) < 0 ? mi(u, a, u.next) >= 0 && mi(u, u.prev, a) >= 0 : mi(u, a, u.prev) < 0 || mi(u, u.next, a) < 0;
      }
      function Qb(u, a) {
        const d = c0(u.i, u.x, u.y), p = c0(a.i, a.x, a.y), v = u.next, x = a.prev;
        return u.next = a, a.prev = u, d.next = v, v.prev = d, p.next = d, d.prev = p, x.next = p, p.prev = x, p;
      }
      function ev(u, a, d, p) {
        const v = c0(u, a, d);
        return p ? (v.next = p.next, v.prev = p, p.next.prev = v, p.next = v) : (v.prev = v, v.next = v), v;
      }
      function Sf(u) {
        u.next.prev = u.prev, u.prev.next = u.next, u.prevZ && (u.prevZ.nextZ = u.nextZ), u.nextZ && (u.nextZ.prevZ = u.prevZ);
      }
      function c0(u, a, d) {
        return { i: u, x: a, y: d, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function u0(u, a, d) {
        const p = d.patternDependencies;
        let v = !1;
        for (const x of a) {
          const E = x.paint.get(`${u}-pattern`);
          E.isConstant() || (v = !0);
          const L = E.constantOr(null);
          L && (v = !0, p[L.to] = !0, p[L.from] = !0);
        }
        return v;
      }
      function h0(u, a, d, p, v) {
        const x = v.patternDependencies;
        for (const E of a) {
          const L = E.paint.get(`${u}-pattern`).value;
          if (L.kind !== "constant") {
            let R = L.evaluate({ zoom: p - 1 }, d, {}, v.availableImages), F = L.evaluate({ zoom: p }, d, {}, v.availableImages), j = L.evaluate({ zoom: p + 1 }, d, {}, v.availableImages);
            R = R && R.name ? R.name : R, F = F && F.name ? F.name : F, j = j && j.name ? j.name : j, x[R] = !0, x[F] = !0, x[j] = !0, d.patterns[E.id] = { min: R, mid: F, max: j };
          }
        }
        return d;
      }
      class d0 {
        constructor(a) {
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((d) => d.id), this.index = a.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new ts(), this.indexArray = new Ui(), this.indexArray2 = new Kr(), this.programConfigurations = new tc(a.layers, a.zoom), this.segments = new Hn(), this.segments2 = new Hn(), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(a, d, p) {
          this.hasPattern = u0("fill", this.layers, d);
          const v = this.layers[0].layout.get("fill-sort-key"), x = !v.isConstant(), E = [];
          for (const { feature: L, id: R, index: F, sourceLayerIndex: j } of a) {
            const q = this.layers[0]._featureFilter.needGeometry, Y = nc(L, q);
            if (!this.layers[0]._featureFilter.filter(new vr(this.zoom), Y, p)) continue;
            const ee = x ? v.evaluate(Y, {}, p, d.availableImages) : void 0, se = { id: R, properties: L.properties, type: L.type, sourceLayerIndex: j, index: F, geometry: q ? Y.geometry : Gc(L), patterns: {}, sortKey: ee };
            E.push(se);
          }
          x && E.sort((L, R) => L.sortKey - R.sortKey);
          for (const L of E) {
            const { geometry: R, index: F, sourceLayerIndex: j } = L;
            if (this.hasPattern) {
              const q = h0("fill", this.layers, L, this.zoom, d);
              this.patternFeatures.push(q);
            } else this.addFeature(L, R, F, p, {});
            d.featureIndex.insert(a[F].feature, R, F, j, this.index);
          }
        }
        update(a, d, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, d, this.stateDependentLayers, p);
        }
        addFeatures(a, d, p) {
          for (const v of this.patternFeatures) this.addFeature(v, v.geometry, v.index, d, p);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(a) {
          this.uploaded || (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, B3), this.indexBuffer = a.createIndexBuffer(this.indexArray), this.indexBuffer2 = a.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(a), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(a, d, p, v, x) {
          for (const E of Io(d, 500)) {
            let L = 0;
            for (const ee of E) L += ee.length;
            const R = this.segments.prepareSegment(L, this.layoutVertexArray, this.indexArray), F = R.vertexLength, j = [], q = [];
            for (const ee of E) {
              if (ee.length === 0) continue;
              ee !== E[0] && q.push(j.length / 2);
              const se = this.segments2.prepareSegment(ee.length, this.layoutVertexArray, this.indexArray2), de = se.vertexLength;
              this.layoutVertexArray.emplaceBack(ee[0].x, ee[0].y), this.indexArray2.emplaceBack(de + ee.length - 1, de), j.push(ee[0].x), j.push(ee[0].y);
              for (let we = 1; we < ee.length; we++) this.layoutVertexArray.emplaceBack(ee[we].x, ee[we].y), this.indexArray2.emplaceBack(de + we - 1, de + we), j.push(ee[we].x), j.push(ee[we].y);
              se.vertexLength += ee.length, se.primitiveLength += ee.length;
            }
            const Y = Jb(j, q);
            for (let ee = 0; ee < Y.length; ee += 3) this.indexArray.emplaceBack(F + Y[ee], F + Y[ee + 1], F + Y[ee + 2]);
            R.vertexLength += L, R.primitiveLength += Y.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, x, v);
        }
      }
      let tv, nv;
      qt("FillBucket", d0, { omit: ["layers", "patternFeatures"] });
      var G3 = { get paint() {
        return nv = nv || new g({ "fill-antialias": new Yt(ne.paint_fill["fill-antialias"]), "fill-opacity": new gn(ne.paint_fill["fill-opacity"]), "fill-color": new gn(ne.paint_fill["fill-color"]), "fill-outline-color": new gn(ne.paint_fill["fill-outline-color"]), "fill-translate": new Yt(ne.paint_fill["fill-translate"]), "fill-translate-anchor": new Yt(ne.paint_fill["fill-translate-anchor"]), "fill-pattern": new Nc(ne.paint_fill["fill-pattern"]) });
      }, get layout() {
        return tv = tv || new g({ "fill-sort-key": new gn(ne.layout_fill["fill-sort-key"]) });
      } };
      class V3 extends h {
        constructor(a) {
          super(a, G3);
        }
        recalculate(a, d) {
          super.recalculate(a, d);
          const p = this.paint._values["fill-outline-color"];
          p.value.kind === "constant" && p.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(a) {
          return new d0(a);
        }
        queryRadius() {
          return $p(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(a, d, p, v, x, E, L) {
          return za(Zp(a, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), E.angle, L), v);
        }
        isTileClipped() {
          return !0;
        }
      }
      const q3 = S([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), H3 = S([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: W3 } = q3;
      var wu = {}, X3 = b, rv = od;
      function od(u, a, d, p, v) {
        this.properties = {}, this.extent = d, this.type = 0, this._pbf = u, this._geometry = -1, this._keys = p, this._values = v, u.readFields($3, this, a);
      }
      function $3(u, a, d) {
        u == 1 ? a.id = d.readVarint() : u == 2 ? function(p, v) {
          for (var x = p.readVarint() + p.pos; p.pos < x; ) {
            var E = v._keys[p.readVarint()], L = v._values[p.readVarint()];
            v.properties[E] = L;
          }
        }(d, a) : u == 3 ? a.type = d.readVarint() : u == 4 && (a._geometry = d.pos);
      }
      function Z3(u) {
        for (var a, d, p = 0, v = 0, x = u.length, E = x - 1; v < x; E = v++) p += ((d = u[E]).x - (a = u[v]).x) * (a.y + d.y);
        return p;
      }
      od.types = ["Unknown", "Point", "LineString", "Polygon"], od.prototype.loadGeometry = function() {
        var u = this._pbf;
        u.pos = this._geometry;
        for (var a, d = u.readVarint() + u.pos, p = 1, v = 0, x = 0, E = 0, L = []; u.pos < d; ) {
          if (v <= 0) {
            var R = u.readVarint();
            p = 7 & R, v = R >> 3;
          }
          if (v--, p === 1 || p === 2) x += u.readSVarint(), E += u.readSVarint(), p === 1 && (a && L.push(a), a = []), a.push(new X3(x, E));
          else {
            if (p !== 7) throw new Error("unknown command " + p);
            a && a.push(a[0].clone());
          }
        }
        return a && L.push(a), L;
      }, od.prototype.bbox = function() {
        var u = this._pbf;
        u.pos = this._geometry;
        for (var a = u.readVarint() + u.pos, d = 1, p = 0, v = 0, x = 0, E = 1 / 0, L = -1 / 0, R = 1 / 0, F = -1 / 0; u.pos < a; ) {
          if (p <= 0) {
            var j = u.readVarint();
            d = 7 & j, p = j >> 3;
          }
          if (p--, d === 1 || d === 2) (v += u.readSVarint()) < E && (E = v), v > L && (L = v), (x += u.readSVarint()) < R && (R = x), x > F && (F = x);
          else if (d !== 7) throw new Error("unknown command " + d);
        }
        return [E, R, L, F];
      }, od.prototype.toGeoJSON = function(u, a, d) {
        var p, v, x = this.extent * Math.pow(2, d), E = this.extent * u, L = this.extent * a, R = this.loadGeometry(), F = od.types[this.type];
        function j(ee) {
          for (var se = 0; se < ee.length; se++) {
            var de = ee[se];
            ee[se] = [360 * (de.x + E) / x - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (de.y + L) / x) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var q = [];
            for (p = 0; p < R.length; p++) q[p] = R[p][0];
            j(R = q);
            break;
          case 2:
            for (p = 0; p < R.length; p++) j(R[p]);
            break;
          case 3:
            for (R = function(ee) {
              var se = ee.length;
              if (se <= 1) return [ee];
              for (var de, we, Me = [], $e = 0; $e < se; $e++) {
                var Ne = Z3(ee[$e]);
                Ne !== 0 && (we === void 0 && (we = Ne < 0), we === Ne < 0 ? (de && Me.push(de), de = [ee[$e]]) : de.push(ee[$e]));
              }
              return de && Me.push(de), Me;
            }(R), p = 0; p < R.length; p++) for (v = 0; v < R[p].length; v++) j(R[p][v]);
        }
        R.length === 1 ? R = R[0] : F = "Multi" + F;
        var Y = { type: "Feature", geometry: { type: F, coordinates: R }, properties: this.properties };
        return "id" in this && (Y.id = this.id), Y;
      };
      var J3 = rv, iv = sv;
      function sv(u, a) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = u, this._keys = [], this._values = [], this._features = [], u.readFields(Y3, this, a), this.length = this._features.length;
      }
      function Y3(u, a, d) {
        u === 15 ? a.version = d.readVarint() : u === 1 ? a.name = d.readString() : u === 5 ? a.extent = d.readVarint() : u === 2 ? a._features.push(d.pos) : u === 3 ? a._keys.push(d.readString()) : u === 4 && a._values.push(function(p) {
          for (var v = null, x = p.readVarint() + p.pos; p.pos < x; ) {
            var E = p.readVarint() >> 3;
            v = E === 1 ? p.readString() : E === 2 ? p.readFloat() : E === 3 ? p.readDouble() : E === 4 ? p.readVarint64() : E === 5 ? p.readVarint() : E === 6 ? p.readSVarint() : E === 7 ? p.readBoolean() : null;
          }
          return v;
        }(d));
      }
      sv.prototype.feature = function(u) {
        if (u < 0 || u >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[u];
        var a = this._pbf.readVarint() + this._pbf.pos;
        return new J3(this._pbf, a, this.extent, this._keys, this._values);
      };
      var K3 = iv;
      function Q3(u, a, d) {
        if (u === 3) {
          var p = new K3(d, d.readVarint() + d.pos);
          p.length && (a[p.name] = p);
        }
      }
      wu.VectorTile = function(u, a) {
        this.layers = u.readFields(Q3, {}, a);
      }, wu.VectorTileFeature = rv, wu.VectorTileLayer = iv;
      const eC = wu.VectorTileFeature.types, f0 = Math.pow(2, 13);
      function Ef(u, a, d, p, v, x, E, L) {
        u.emplaceBack(a, d, 2 * Math.floor(p * f0) + E, v * f0 * 2, x * f0 * 2, Math.round(L));
      }
      class p0 {
        constructor(a) {
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((d) => d.id), this.index = a.index, this.hasPattern = !1, this.layoutVertexArray = new Cs(), this.centroidVertexArray = new Gr(), this.indexArray = new Ui(), this.programConfigurations = new tc(a.layers, a.zoom), this.segments = new Hn(), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(a, d, p) {
          this.features = [], this.hasPattern = u0("fill-extrusion", this.layers, d);
          for (const { feature: v, id: x, index: E, sourceLayerIndex: L } of a) {
            const R = this.layers[0]._featureFilter.needGeometry, F = nc(v, R);
            if (!this.layers[0]._featureFilter.filter(new vr(this.zoom), F, p)) continue;
            const j = { id: x, sourceLayerIndex: L, index: E, geometry: R ? F.geometry : Gc(v), properties: v.properties, type: v.type, patterns: {} };
            this.hasPattern ? this.features.push(h0("fill-extrusion", this.layers, j, this.zoom, d)) : this.addFeature(j, j.geometry, E, p, {}), d.featureIndex.insert(v, j.geometry, E, L, this.index, !0);
          }
        }
        addFeatures(a, d, p) {
          for (const v of this.features) {
            const { geometry: x } = v;
            this.addFeature(v, x, v.index, d, p);
          }
        }
        update(a, d, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, d, this.stateDependentLayers, p);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(a) {
          this.uploaded || (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, W3), this.centroidVertexBuffer = a.createVertexBuffer(this.centroidVertexArray, H3.members, !0), this.indexBuffer = a.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(a), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(a, d, p, v, x) {
          for (const E of Io(d, 500)) {
            const L = { x: 0, y: 0, vertexCount: 0 };
            let R = 0;
            for (const se of E) R += se.length;
            let F = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const se of E) {
              if (se.length === 0 || nC(se)) continue;
              let de = 0;
              for (let we = 0; we < se.length; we++) {
                const Me = se[we];
                if (we >= 1) {
                  const $e = se[we - 1];
                  if (!tC(Me, $e)) {
                    F.vertexLength + 4 > Hn.MAX_VERTEX_ARRAY_LENGTH && (F = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const Ne = Me.sub($e)._perp()._unit(), Ve = $e.dist(Me);
                    de + Ve > 32768 && (de = 0), Ef(this.layoutVertexArray, Me.x, Me.y, Ne.x, Ne.y, 0, 0, de), Ef(this.layoutVertexArray, Me.x, Me.y, Ne.x, Ne.y, 0, 1, de), L.x += 2 * Me.x, L.y += 2 * Me.y, L.vertexCount += 2, de += Ve, Ef(this.layoutVertexArray, $e.x, $e.y, Ne.x, Ne.y, 0, 0, de), Ef(this.layoutVertexArray, $e.x, $e.y, Ne.x, Ne.y, 0, 1, de), L.x += 2 * $e.x, L.y += 2 * $e.y, L.vertexCount += 2;
                    const it = F.vertexLength;
                    this.indexArray.emplaceBack(it, it + 2, it + 1), this.indexArray.emplaceBack(it + 1, it + 2, it + 3), F.vertexLength += 4, F.primitiveLength += 2;
                  }
                }
              }
            }
            if (F.vertexLength + R > Hn.MAX_VERTEX_ARRAY_LENGTH && (F = this.segments.prepareSegment(R, this.layoutVertexArray, this.indexArray)), eC[a.type] !== "Polygon") continue;
            const j = [], q = [], Y = F.vertexLength;
            for (const se of E) if (se.length !== 0) {
              se !== E[0] && q.push(j.length / 2);
              for (let de = 0; de < se.length; de++) {
                const we = se[de];
                Ef(this.layoutVertexArray, we.x, we.y, 0, 0, 1, 1, 0), L.x += we.x, L.y += we.y, L.vertexCount += 1, j.push(we.x), j.push(we.y);
              }
            }
            const ee = Jb(j, q);
            for (let se = 0; se < ee.length; se += 3) this.indexArray.emplaceBack(Y + ee[se], Y + ee[se + 2], Y + ee[se + 1]);
            F.primitiveLength += ee.length / 3, F.vertexLength += R;
            for (let se = 0; se < L.vertexCount; se++) {
              const de = Math.floor(L.x / L.vertexCount), we = Math.floor(L.y / L.vertexCount);
              this.centroidVertexArray.emplaceBack(de, we);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, x, v);
        }
      }
      function tC(u, a) {
        return u.x === a.x && (u.x < 0 || u.x > kr) || u.y === a.y && (u.y < 0 || u.y > kr);
      }
      function nC(u) {
        return u.every((a) => a.x < 0) || u.every((a) => a.x > kr) || u.every((a) => a.y < 0) || u.every((a) => a.y > kr);
      }
      let ov;
      qt("FillExtrusionBucket", p0, { omit: ["layers", "features"] });
      var rC = { get paint() {
        return ov = ov || new g({ "fill-extrusion-opacity": new Yt(ne["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new gn(ne["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Yt(ne["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Yt(ne["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Nc(ne["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new gn(ne["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new gn(ne["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Yt(ne["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class iC extends h {
        constructor(a) {
          super(a, rC);
        }
        createBucket(a) {
          return new p0(a);
        }
        queryRadius() {
          return $p(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(a, d, p, v, x, E, L, R) {
          const F = Zp(a, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), E.angle, L), j = this.paint.get("fill-extrusion-height").evaluate(d, p), q = this.paint.get("fill-extrusion-base").evaluate(d, p), Y = function(se, de, we, Me) {
            const $e = [];
            for (const Ne of se) {
              const Ve = [Ne.x, Ne.y, 0, 1];
              Jp(Ve, Ve, de), $e.push(new T(Ve[0] / Ve[3], Ve[1] / Ve[3]));
            }
            return $e;
          }(F, R), ee = function(se, de, we, Me) {
            const $e = [], Ne = [], Ve = Me[8] * de, it = Me[9] * de, At = Me[10] * de, Gt = Me[11] * de, mn = Me[8] * we, Ut = Me[9] * we, kt = Me[10] * we, sn = Me[11] * we;
            for (const $t of se) {
              const Ht = [], pt = [];
              for (const on of $t) {
                const tn = on.x, Tn = on.y, Ir = Me[0] * tn + Me[4] * Tn + Me[12], wr = Me[1] * tn + Me[5] * Tn + Me[13], Gi = Me[2] * tn + Me[6] * Tn + Me[14], ja = Me[3] * tn + Me[7] * Tn + Me[15], ds = Gi + At, Vi = ja + Gt, Hs = Ir + mn, Ws = wr + Ut, Xs = Gi + kt, di = ja + sn, qi = new T((Ir + Ve) / Vi, (wr + it) / Vi);
                qi.z = ds / Vi, Ht.push(qi);
                const Ls = new T(Hs / di, Ws / di);
                Ls.z = Xs / di, pt.push(Ls);
              }
              $e.push(Ht), Ne.push(pt);
            }
            return [$e, Ne];
          }(v, q, j, R);
          return function(se, de, we) {
            let Me = 1 / 0;
            za(we, de) && (Me = av(we, de[0]));
            for (let $e = 0; $e < de.length; $e++) {
              const Ne = de[$e], Ve = se[$e];
              for (let it = 0; it < Ne.length - 1; it++) {
                const At = Ne[it], Gt = [At, Ne[it + 1], Ve[it + 1], Ve[it], At];
                td(we, Gt) && (Me = Math.min(Me, av(we, Gt)));
              }
            }
            return Me !== 1 / 0 && Me;
          }(ee[0], ee[1], Y);
        }
      }
      function Tf(u, a) {
        return u.x * a.x + u.y * a.y;
      }
      function av(u, a) {
        if (u.length === 1) {
          let d = 0;
          const p = a[d++];
          let v;
          for (; !v || p.equals(v); ) if (v = a[d++], !v) return 1 / 0;
          for (; d < a.length; d++) {
            const x = a[d], E = u[0], L = v.sub(p), R = x.sub(p), F = E.sub(p), j = Tf(L, L), q = Tf(L, R), Y = Tf(R, R), ee = Tf(F, L), se = Tf(F, R), de = j * Y - q * q, we = (Y * ee - q * se) / de, Me = (j * se - q * ee) / de, $e = p.z * (1 - we - Me) + v.z * we + x.z * Me;
            if (isFinite($e)) return $e;
          }
          return 1 / 0;
        }
        {
          let d = 1 / 0;
          for (const p of a) d = Math.min(d, p.z);
          return d;
        }
      }
      const sC = S([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: oC } = sC, aC = S([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: lC } = aC, cC = wu.VectorTileFeature.types, uC = Math.cos(Math.PI / 180 * 37.5), lv = Math.pow(2, 14) / 0.5;
      class g0 {
        constructor(a) {
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((d) => d.id), this.index = a.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((d) => {
            this.gradients[d.id] = {};
          }), this.layoutVertexArray = new Fr(), this.layoutVertexArray2 = new Fa(), this.indexArray = new Ui(), this.programConfigurations = new tc(a.layers, a.zoom), this.segments = new Hn(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(a, d, p) {
          this.hasPattern = u0("line", this.layers, d);
          const v = this.layers[0].layout.get("line-sort-key"), x = !v.isConstant(), E = [];
          for (const { feature: L, id: R, index: F, sourceLayerIndex: j } of a) {
            const q = this.layers[0]._featureFilter.needGeometry, Y = nc(L, q);
            if (!this.layers[0]._featureFilter.filter(new vr(this.zoom), Y, p)) continue;
            const ee = x ? v.evaluate(Y, {}, p) : void 0, se = { id: R, properties: L.properties, type: L.type, sourceLayerIndex: j, index: F, geometry: q ? Y.geometry : Gc(L), patterns: {}, sortKey: ee };
            E.push(se);
          }
          x && E.sort((L, R) => L.sortKey - R.sortKey);
          for (const L of E) {
            const { geometry: R, index: F, sourceLayerIndex: j } = L;
            if (this.hasPattern) {
              const q = h0("line", this.layers, L, this.zoom, d);
              this.patternFeatures.push(q);
            } else this.addFeature(L, R, F, p, {});
            d.featureIndex.insert(a[F].feature, R, F, j, this.index);
          }
        }
        update(a, d, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, d, this.stateDependentLayers, p);
        }
        addFeatures(a, d, p) {
          for (const v of this.patternFeatures) this.addFeature(v, v.geometry, v.index, d, p);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(a) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = a.createVertexBuffer(this.layoutVertexArray2, lC)), this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, oC), this.indexBuffer = a.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(a), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(a) {
          if (a.properties && Object.prototype.hasOwnProperty.call(a.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(a.properties, "mapbox_clip_end")) return { start: +a.properties.mapbox_clip_start, end: +a.properties.mapbox_clip_end };
        }
        addFeature(a, d, p, v, x) {
          const E = this.layers[0].layout, L = E.get("line-join").evaluate(a, {}), R = E.get("line-cap"), F = E.get("line-miter-limit"), j = E.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(a);
          for (const q of d) this.addLine(q, a, L, R, F, j);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, x, v);
        }
        addLine(a, d, p, v, x, E) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let Me = 0; Me < a.length - 1; Me++) this.totalDistance += a[Me].dist(a[Me + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const L = cC[d.type] === "Polygon";
          let R = a.length;
          for (; R >= 2 && a[R - 1].equals(a[R - 2]); ) R--;
          let F = 0;
          for (; F < R - 1 && a[F].equals(a[F + 1]); ) F++;
          if (R < (L ? 3 : 2)) return;
          p === "bevel" && (x = 1.05);
          const j = this.overscaling <= 16 ? 15 * kr / (512 * this.overscaling) : 0, q = this.segments.prepareSegment(10 * R, this.layoutVertexArray, this.indexArray);
          let Y, ee, se, de, we;
          this.e1 = this.e2 = -1, L && (Y = a[R - 2], we = a[F].sub(Y)._unit()._perp());
          for (let Me = F; Me < R; Me++) {
            if (se = Me === R - 1 ? L ? a[F + 1] : void 0 : a[Me + 1], se && a[Me].equals(se)) continue;
            we && (de = we), Y && (ee = Y), Y = a[Me], we = se ? se.sub(Y)._unit()._perp() : de, de = de || we;
            let $e = de.add(we);
            $e.x === 0 && $e.y === 0 || $e._unit();
            const Ne = de.x * we.x + de.y * we.y, Ve = $e.x * we.x + $e.y * we.y, it = Ve !== 0 ? 1 / Ve : 1 / 0, At = 2 * Math.sqrt(2 - 2 * Ve), Gt = Ve < uC && ee && se, mn = de.x * we.y - de.y * we.x > 0;
            if (Gt && Me > F) {
              const sn = Y.dist(ee);
              if (sn > 2 * j) {
                const $t = Y.sub(Y.sub(ee)._mult(j / sn)._round());
                this.updateDistance(ee, $t), this.addCurrentVertex($t, de, 0, 0, q), ee = $t;
              }
            }
            const Ut = ee && se;
            let kt = Ut ? p : L ? "butt" : v;
            if (Ut && kt === "round" && (it < E ? kt = "miter" : it <= 2 && (kt = "fakeround")), kt === "miter" && it > x && (kt = "bevel"), kt === "bevel" && (it > 2 && (kt = "flipbevel"), it < x && (kt = "miter")), ee && this.updateDistance(ee, Y), kt === "miter") $e._mult(it), this.addCurrentVertex(Y, $e, 0, 0, q);
            else if (kt === "flipbevel") {
              if (it > 100) $e = we.mult(-1);
              else {
                const sn = it * de.add(we).mag() / de.sub(we).mag();
                $e._perp()._mult(sn * (mn ? -1 : 1));
              }
              this.addCurrentVertex(Y, $e, 0, 0, q), this.addCurrentVertex(Y, $e.mult(-1), 0, 0, q);
            } else if (kt === "bevel" || kt === "fakeround") {
              const sn = -Math.sqrt(it * it - 1), $t = mn ? sn : 0, Ht = mn ? 0 : sn;
              if (ee && this.addCurrentVertex(Y, de, $t, Ht, q), kt === "fakeround") {
                const pt = Math.round(180 * At / Math.PI / 20);
                for (let on = 1; on < pt; on++) {
                  let tn = on / pt;
                  if (tn !== 0.5) {
                    const Ir = tn - 0.5;
                    tn += tn * Ir * (tn - 1) * ((1.0904 + Ne * (Ne * (3.55645 - 1.43519 * Ne) - 3.2452)) * Ir * Ir + (0.848013 + Ne * (0.215638 * Ne - 1.06021)));
                  }
                  const Tn = we.sub(de)._mult(tn)._add(de)._unit()._mult(mn ? -1 : 1);
                  this.addHalfVertex(Y, Tn.x, Tn.y, !1, mn, 0, q);
                }
              }
              se && this.addCurrentVertex(Y, we, -$t, -Ht, q);
            } else if (kt === "butt") this.addCurrentVertex(Y, $e, 0, 0, q);
            else if (kt === "square") {
              const sn = ee ? 1 : -1;
              this.addCurrentVertex(Y, $e, sn, sn, q);
            } else kt === "round" && (ee && (this.addCurrentVertex(Y, de, 0, 0, q), this.addCurrentVertex(Y, de, 1, 1, q, !0)), se && (this.addCurrentVertex(Y, we, -1, -1, q, !0), this.addCurrentVertex(Y, we, 0, 0, q)));
            if (Gt && Me < R - 1) {
              const sn = Y.dist(se);
              if (sn > 2 * j) {
                const $t = Y.add(se.sub(Y)._mult(j / sn)._round());
                this.updateDistance(Y, $t), this.addCurrentVertex($t, we, 0, 0, q), Y = $t;
              }
            }
          }
        }
        addCurrentVertex(a, d, p, v, x) {
          let E = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
          const L = d.y * v - d.x, R = -d.y - d.x * v;
          this.addHalfVertex(a, d.x + d.y * p, d.y - d.x * p, E, !1, p, x), this.addHalfVertex(a, L, R, E, !0, -v, x), this.distance > lv / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(a, d, p, v, x, E));
        }
        addHalfVertex(a, d, p, v, x, E, L) {
          let { x: R, y: F } = a;
          const j = 0.5 * (this.lineClips ? this.scaledDistance * (lv - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((R << 1) + (v ? 1 : 0), (F << 1) + (x ? 1 : 0), Math.round(63 * d) + 128, Math.round(63 * p) + 128, 1 + (E === 0 ? 0 : E < 0 ? -1 : 1) | (63 & j) << 2, j >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const q = L.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, q), L.primitiveLength++), x ? this.e2 = q : this.e1 = q;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(a, d) {
          this.distance += a.dist(d), this.updateScaledDistance();
        }
      }
      let cv, uv;
      qt("LineBucket", g0, { omit: ["layers", "patternFeatures"] });
      var hv = { get paint() {
        return uv = uv || new g({ "line-opacity": new gn(ne.paint_line["line-opacity"]), "line-color": new gn(ne.paint_line["line-color"]), "line-translate": new Yt(ne.paint_line["line-translate"]), "line-translate-anchor": new Yt(ne.paint_line["line-translate-anchor"]), "line-width": new gn(ne.paint_line["line-width"]), "line-gap-width": new gn(ne.paint_line["line-gap-width"]), "line-offset": new gn(ne.paint_line["line-offset"]), "line-blur": new gn(ne.paint_line["line-blur"]), "line-dasharray": new A(ne.paint_line["line-dasharray"]), "line-pattern": new Nc(ne.paint_line["line-pattern"]), "line-gradient": new M(ne.paint_line["line-gradient"]) });
      }, get layout() {
        return cv = cv || new g({ "line-cap": new Yt(ne.layout_line["line-cap"]), "line-join": new gn(ne.layout_line["line-join"]), "line-miter-limit": new Yt(ne.layout_line["line-miter-limit"]), "line-round-limit": new Yt(ne.layout_line["line-round-limit"]), "line-sort-key": new gn(ne.layout_line["line-sort-key"]) });
      } };
      class hC extends gn {
        possiblyEvaluate(a, d) {
          return d = new vr(Math.floor(d.zoom), { now: d.now, fadeDuration: d.fadeDuration, zoomHistory: d.zoomHistory, transition: d.transition }), super.possiblyEvaluate(a, d);
        }
        evaluate(a, d, p, v) {
          return d = Le({}, d, { zoom: Math.floor(d.zoom) }), super.evaluate(a, d, p, v);
        }
      }
      let eg;
      class dC extends h {
        constructor(a) {
          super(a, hv), this.gradientVersion = 0, eg || (eg = new hC(hv.paint.properties["line-width"].specification), eg.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(a) {
          if (a === "line-gradient") {
            const d = this.gradientExpression();
            this.stepInterpolant = !!function(p) {
              return p._styleExpression !== void 0;
            }(d) && d._styleExpression.expression instanceof Vt, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(a, d) {
          super.recalculate(a, d), this.paint._values["line-floorwidth"] = eg.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, a);
        }
        createBucket(a) {
          return new g0(a);
        }
        queryRadius(a) {
          const d = a, p = dv(bf("line-width", this, d), bf("line-gap-width", this, d)), v = bf("line-offset", this, d);
          return p / 2 + Math.abs(v) + $p(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(a, d, p, v, x, E, L) {
          const R = Zp(a, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), E.angle, L), F = L / 2 * dv(this.paint.get("line-width").evaluate(d, p), this.paint.get("line-gap-width").evaluate(d, p)), j = this.paint.get("line-offset").evaluate(d, p);
          return j && (v = function(q, Y) {
            const ee = [];
            for (let se = 0; se < q.length; se++) {
              const de = q[se], we = [];
              for (let Me = 0; Me < de.length; Me++) {
                const $e = de[Me - 1], Ne = de[Me], Ve = de[Me + 1], it = Me === 0 ? new T(0, 0) : Ne.sub($e)._unit()._perp(), At = Me === de.length - 1 ? new T(0, 0) : Ve.sub(Ne)._unit()._perp(), Gt = it._add(At)._unit(), mn = Gt.x * At.x + Gt.y * At.y;
                mn !== 0 && Gt._mult(1 / mn), we.push(Gt._mult(Y)._add(Ne));
              }
              ee.push(we);
            }
            return ee;
          }(v, j * L)), function(q, Y, ee) {
            for (let se = 0; se < Y.length; se++) {
              const de = Y[se];
              if (q.length >= 3) {
                for (let we = 0; we < de.length; we++) if (ic(q, de[we])) return !0;
              }
              if (rc(q, de, ee)) return !0;
            }
            return !1;
          }(R, v, F);
        }
        isTileClipped() {
          return !0;
        }
      }
      function dv(u, a) {
        return a > 0 ? a + 2 * u : u;
      }
      const fC = S([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), pC = S([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      S([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const gC = S([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      S([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const fv = S([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), mC = S([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function _C(u, a, d) {
        return u.sections.forEach((p) => {
          p.text = function(v, x, E) {
            const L = x.layout.get("text-transform").evaluate(E, {});
            return L === "uppercase" ? v = v.toLocaleUpperCase() : L === "lowercase" && (v = v.toLocaleLowerCase()), Ts.applyArabicShaping && (v = Ts.applyArabicShaping(v)), v;
          }(p.text, a, d);
        }), u;
      }
      S([{ name: "triangle", components: 3, type: "Uint16" }]), S([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), S([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), S([{ type: "Float32", name: "offsetX" }]), S([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), S([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Cf = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
      var Mi = 24, pv = xr, gv = function(u, a, d, p, v) {
        var x, E, L = 8 * v - p - 1, R = (1 << L) - 1, F = R >> 1, j = -7, q = v - 1, Y = -1, ee = u[a + q];
        for (q += Y, x = ee & (1 << -j) - 1, ee >>= -j, j += L; j > 0; x = 256 * x + u[a + q], q += Y, j -= 8) ;
        for (E = x & (1 << -j) - 1, x >>= -j, j += p; j > 0; E = 256 * E + u[a + q], q += Y, j -= 8) ;
        if (x === 0) x = 1 - F;
        else {
          if (x === R) return E ? NaN : 1 / 0 * (ee ? -1 : 1);
          E += Math.pow(2, p), x -= F;
        }
        return (ee ? -1 : 1) * E * Math.pow(2, x - p);
      }, mv = function(u, a, d, p, v, x) {
        var E, L, R, F = 8 * x - v - 1, j = (1 << F) - 1, q = j >> 1, Y = v === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = 0, se = 1, de = a < 0 || a === 0 && 1 / a < 0 ? 1 : 0;
        for (a = Math.abs(a), isNaN(a) || a === 1 / 0 ? (L = isNaN(a) ? 1 : 0, E = j) : (E = Math.floor(Math.log(a) / Math.LN2), a * (R = Math.pow(2, -E)) < 1 && (E--, R *= 2), (a += E + q >= 1 ? Y / R : Y * Math.pow(2, 1 - q)) * R >= 2 && (E++, R /= 2), E + q >= j ? (L = 0, E = j) : E + q >= 1 ? (L = (a * R - 1) * Math.pow(2, v), E += q) : (L = a * Math.pow(2, q - 1) * Math.pow(2, v), E = 0)); v >= 8; u[d + ee] = 255 & L, ee += se, L /= 256, v -= 8) ;
        for (E = E << v | L, F += v; F > 0; u[d + ee] = 255 & E, ee += se, E /= 256, F -= 8) ;
        u[d + ee - se] |= 128 * de;
      };
      function xr(u) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(u) ? u : new Uint8Array(u || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      xr.Varint = 0, xr.Fixed64 = 1, xr.Bytes = 2, xr.Fixed32 = 5;
      var m0 = 4294967296, _v = 1 / m0, yv = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
      function qc(u) {
        return u.type === xr.Bytes ? u.readVarint() + u.pos : u.pos + 1;
      }
      function ad(u, a, d) {
        return d ? 4294967296 * a + (u >>> 0) : 4294967296 * (a >>> 0) + (u >>> 0);
      }
      function bv(u, a, d) {
        var p = a <= 16383 ? 1 : a <= 2097151 ? 2 : a <= 268435455 ? 3 : Math.floor(Math.log(a) / (7 * Math.LN2));
        d.realloc(p);
        for (var v = d.pos - 1; v >= u; v--) d.buf[v + p] = d.buf[v];
      }
      function yC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeVarint(u[d]);
      }
      function bC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeSVarint(u[d]);
      }
      function vC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeFloat(u[d]);
      }
      function xC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeDouble(u[d]);
      }
      function wC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeBoolean(u[d]);
      }
      function AC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeFixed32(u[d]);
      }
      function SC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeSFixed32(u[d]);
      }
      function EC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeFixed64(u[d]);
      }
      function TC(u, a) {
        for (var d = 0; d < u.length; d++) a.writeSFixed64(u[d]);
      }
      function tg(u, a) {
        return (u[a] | u[a + 1] << 8 | u[a + 2] << 16) + 16777216 * u[a + 3];
      }
      function ld(u, a, d) {
        u[d] = a, u[d + 1] = a >>> 8, u[d + 2] = a >>> 16, u[d + 3] = a >>> 24;
      }
      function vv(u, a) {
        return (u[a] | u[a + 1] << 8 | u[a + 2] << 16) + (u[a + 3] << 24);
      }
      xr.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(u, a, d) {
        for (d = d || this.length; this.pos < d; ) {
          var p = this.readVarint(), v = p >> 3, x = this.pos;
          this.type = 7 & p, u(v, a, this), this.pos === x && this.skip(p);
        }
        return a;
      }, readMessage: function(u, a) {
        return this.readFields(u, a, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var u = tg(this.buf, this.pos);
        return this.pos += 4, u;
      }, readSFixed32: function() {
        var u = vv(this.buf, this.pos);
        return this.pos += 4, u;
      }, readFixed64: function() {
        var u = tg(this.buf, this.pos) + tg(this.buf, this.pos + 4) * m0;
        return this.pos += 8, u;
      }, readSFixed64: function() {
        var u = tg(this.buf, this.pos) + vv(this.buf, this.pos + 4) * m0;
        return this.pos += 8, u;
      }, readFloat: function() {
        var u = gv(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, u;
      }, readDouble: function() {
        var u = gv(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, u;
      }, readVarint: function(u) {
        var a, d, p = this.buf;
        return a = 127 & (d = p[this.pos++]), d < 128 ? a : (a |= (127 & (d = p[this.pos++])) << 7, d < 128 ? a : (a |= (127 & (d = p[this.pos++])) << 14, d < 128 ? a : (a |= (127 & (d = p[this.pos++])) << 21, d < 128 ? a : function(v, x, E) {
          var L, R, F = E.buf;
          if (L = (112 & (R = F[E.pos++])) >> 4, R < 128 || (L |= (127 & (R = F[E.pos++])) << 3, R < 128) || (L |= (127 & (R = F[E.pos++])) << 10, R < 128) || (L |= (127 & (R = F[E.pos++])) << 17, R < 128) || (L |= (127 & (R = F[E.pos++])) << 24, R < 128) || (L |= (1 & (R = F[E.pos++])) << 31, R < 128)) return ad(v, L, x);
          throw new Error("Expected varint not more than 10 bytes");
        }(a |= (15 & (d = p[this.pos])) << 28, u, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var u = this.readVarint();
        return u % 2 == 1 ? (u + 1) / -2 : u / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var u = this.readVarint() + this.pos, a = this.pos;
        return this.pos = u, u - a >= 12 && yv ? function(d, p, v) {
          return yv.decode(d.subarray(p, v));
        }(this.buf, a, u) : function(d, p, v) {
          for (var x = "", E = p; E < v; ) {
            var L, R, F, j = d[E], q = null, Y = j > 239 ? 4 : j > 223 ? 3 : j > 191 ? 2 : 1;
            if (E + Y > v) break;
            Y === 1 ? j < 128 && (q = j) : Y === 2 ? (192 & (L = d[E + 1])) == 128 && (q = (31 & j) << 6 | 63 & L) <= 127 && (q = null) : Y === 3 ? (R = d[E + 2], (192 & (L = d[E + 1])) == 128 && (192 & R) == 128 && ((q = (15 & j) << 12 | (63 & L) << 6 | 63 & R) <= 2047 || q >= 55296 && q <= 57343) && (q = null)) : Y === 4 && (R = d[E + 2], F = d[E + 3], (192 & (L = d[E + 1])) == 128 && (192 & R) == 128 && (192 & F) == 128 && ((q = (15 & j) << 18 | (63 & L) << 12 | (63 & R) << 6 | 63 & F) <= 65535 || q >= 1114112) && (q = null)), q === null ? (q = 65533, Y = 1) : q > 65535 && (q -= 65536, x += String.fromCharCode(q >>> 10 & 1023 | 55296), q = 56320 | 1023 & q), x += String.fromCharCode(q), E += Y;
          }
          return x;
        }(this.buf, a, u);
      }, readBytes: function() {
        var u = this.readVarint() + this.pos, a = this.buf.subarray(this.pos, u);
        return this.pos = u, a;
      }, readPackedVarint: function(u, a) {
        if (this.type !== xr.Bytes) return u.push(this.readVarint(a));
        var d = qc(this);
        for (u = u || []; this.pos < d; ) u.push(this.readVarint(a));
        return u;
      }, readPackedSVarint: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readSVarint());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readSVarint());
        return u;
      }, readPackedBoolean: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readBoolean());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readBoolean());
        return u;
      }, readPackedFloat: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readFloat());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readFloat());
        return u;
      }, readPackedDouble: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readDouble());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readDouble());
        return u;
      }, readPackedFixed32: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readFixed32());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readFixed32());
        return u;
      }, readPackedSFixed32: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readSFixed32());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readSFixed32());
        return u;
      }, readPackedFixed64: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readFixed64());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readFixed64());
        return u;
      }, readPackedSFixed64: function(u) {
        if (this.type !== xr.Bytes) return u.push(this.readSFixed64());
        var a = qc(this);
        for (u = u || []; this.pos < a; ) u.push(this.readSFixed64());
        return u;
      }, skip: function(u) {
        var a = 7 & u;
        if (a === xr.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (a === xr.Bytes) this.pos = this.readVarint() + this.pos;
        else if (a === xr.Fixed32) this.pos += 4;
        else {
          if (a !== xr.Fixed64) throw new Error("Unimplemented type: " + a);
          this.pos += 8;
        }
      }, writeTag: function(u, a) {
        this.writeVarint(u << 3 | a);
      }, realloc: function(u) {
        for (var a = this.length || 16; a < this.pos + u; ) a *= 2;
        if (a !== this.length) {
          var d = new Uint8Array(a);
          d.set(this.buf), this.buf = d, this.length = a;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(u) {
        this.realloc(4), ld(this.buf, u, this.pos), this.pos += 4;
      }, writeSFixed32: function(u) {
        this.realloc(4), ld(this.buf, u, this.pos), this.pos += 4;
      }, writeFixed64: function(u) {
        this.realloc(8), ld(this.buf, -1 & u, this.pos), ld(this.buf, Math.floor(u * _v), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(u) {
        this.realloc(8), ld(this.buf, -1 & u, this.pos), ld(this.buf, Math.floor(u * _v), this.pos + 4), this.pos += 8;
      }, writeVarint: function(u) {
        (u = +u || 0) > 268435455 || u < 0 ? function(a, d) {
          var p, v;
          if (a >= 0 ? (p = a % 4294967296 | 0, v = a / 4294967296 | 0) : (v = ~(-a / 4294967296), 4294967295 ^ (p = ~(-a % 4294967296)) ? p = p + 1 | 0 : (p = 0, v = v + 1 | 0)), a >= 18446744073709552e3 || a < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          d.realloc(10), function(x, E, L) {
            L.buf[L.pos++] = 127 & x | 128, x >>>= 7, L.buf[L.pos++] = 127 & x | 128, x >>>= 7, L.buf[L.pos++] = 127 & x | 128, x >>>= 7, L.buf[L.pos++] = 127 & x | 128, L.buf[L.pos] = 127 & (x >>>= 7);
          }(p, 0, d), function(x, E) {
            var L = (7 & x) << 4;
            E.buf[E.pos++] |= L | ((x >>>= 3) ? 128 : 0), x && (E.buf[E.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (E.buf[E.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (E.buf[E.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (E.buf[E.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (E.buf[E.pos++] = 127 & x)))));
          }(v, d);
        }(u, this) : (this.realloc(4), this.buf[this.pos++] = 127 & u | (u > 127 ? 128 : 0), u <= 127 || (this.buf[this.pos++] = 127 & (u >>>= 7) | (u > 127 ? 128 : 0), u <= 127 || (this.buf[this.pos++] = 127 & (u >>>= 7) | (u > 127 ? 128 : 0), u <= 127 || (this.buf[this.pos++] = u >>> 7 & 127))));
      }, writeSVarint: function(u) {
        this.writeVarint(u < 0 ? 2 * -u - 1 : 2 * u);
      }, writeBoolean: function(u) {
        this.writeVarint(!!u);
      }, writeString: function(u) {
        u = String(u), this.realloc(4 * u.length), this.pos++;
        var a = this.pos;
        this.pos = function(p, v, x) {
          for (var E, L, R = 0; R < v.length; R++) {
            if ((E = v.charCodeAt(R)) > 55295 && E < 57344) {
              if (!L) {
                E > 56319 || R + 1 === v.length ? (p[x++] = 239, p[x++] = 191, p[x++] = 189) : L = E;
                continue;
              }
              if (E < 56320) {
                p[x++] = 239, p[x++] = 191, p[x++] = 189, L = E;
                continue;
              }
              E = L - 55296 << 10 | E - 56320 | 65536, L = null;
            } else L && (p[x++] = 239, p[x++] = 191, p[x++] = 189, L = null);
            E < 128 ? p[x++] = E : (E < 2048 ? p[x++] = E >> 6 | 192 : (E < 65536 ? p[x++] = E >> 12 | 224 : (p[x++] = E >> 18 | 240, p[x++] = E >> 12 & 63 | 128), p[x++] = E >> 6 & 63 | 128), p[x++] = 63 & E | 128);
          }
          return x;
        }(this.buf, u, this.pos);
        var d = this.pos - a;
        d >= 128 && bv(a, d, this), this.pos = a - 1, this.writeVarint(d), this.pos += d;
      }, writeFloat: function(u) {
        this.realloc(4), mv(this.buf, u, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(u) {
        this.realloc(8), mv(this.buf, u, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(u) {
        var a = u.length;
        this.writeVarint(a), this.realloc(a);
        for (var d = 0; d < a; d++) this.buf[this.pos++] = u[d];
      }, writeRawMessage: function(u, a) {
        this.pos++;
        var d = this.pos;
        u(a, this);
        var p = this.pos - d;
        p >= 128 && bv(d, p, this), this.pos = d - 1, this.writeVarint(p), this.pos += p;
      }, writeMessage: function(u, a, d) {
        this.writeTag(u, xr.Bytes), this.writeRawMessage(a, d);
      }, writePackedVarint: function(u, a) {
        a.length && this.writeMessage(u, yC, a);
      }, writePackedSVarint: function(u, a) {
        a.length && this.writeMessage(u, bC, a);
      }, writePackedBoolean: function(u, a) {
        a.length && this.writeMessage(u, wC, a);
      }, writePackedFloat: function(u, a) {
        a.length && this.writeMessage(u, vC, a);
      }, writePackedDouble: function(u, a) {
        a.length && this.writeMessage(u, xC, a);
      }, writePackedFixed32: function(u, a) {
        a.length && this.writeMessage(u, AC, a);
      }, writePackedSFixed32: function(u, a) {
        a.length && this.writeMessage(u, SC, a);
      }, writePackedFixed64: function(u, a) {
        a.length && this.writeMessage(u, EC, a);
      }, writePackedSFixed64: function(u, a) {
        a.length && this.writeMessage(u, TC, a);
      }, writeBytesField: function(u, a) {
        this.writeTag(u, xr.Bytes), this.writeBytes(a);
      }, writeFixed32Field: function(u, a) {
        this.writeTag(u, xr.Fixed32), this.writeFixed32(a);
      }, writeSFixed32Field: function(u, a) {
        this.writeTag(u, xr.Fixed32), this.writeSFixed32(a);
      }, writeFixed64Field: function(u, a) {
        this.writeTag(u, xr.Fixed64), this.writeFixed64(a);
      }, writeSFixed64Field: function(u, a) {
        this.writeTag(u, xr.Fixed64), this.writeSFixed64(a);
      }, writeVarintField: function(u, a) {
        this.writeTag(u, xr.Varint), this.writeVarint(a);
      }, writeSVarintField: function(u, a) {
        this.writeTag(u, xr.Varint), this.writeSVarint(a);
      }, writeStringField: function(u, a) {
        this.writeTag(u, xr.Bytes), this.writeString(a);
      }, writeFloatField: function(u, a) {
        this.writeTag(u, xr.Fixed32), this.writeFloat(a);
      }, writeDoubleField: function(u, a) {
        this.writeTag(u, xr.Fixed64), this.writeDouble(a);
      }, writeBooleanField: function(u, a) {
        this.writeVarintField(u, !!a);
      } };
      var _0 = _(pv);
      const y0 = 3;
      function CC(u, a, d) {
        u === 1 && d.readMessage(IC, a);
      }
      function IC(u, a, d) {
        if (u === 3) {
          const { id: p, bitmap: v, width: x, height: E, left: L, top: R, advance: F } = d.readMessage(PC, {});
          a.push({ id: p, bitmap: new xf({ width: x + 2 * y0, height: E + 2 * y0 }, v), metrics: { width: x, height: E, left: L, top: R, advance: F } });
        }
      }
      function PC(u, a, d) {
        u === 1 ? a.id = d.readVarint() : u === 2 ? a.bitmap = d.readBytes() : u === 3 ? a.width = d.readVarint() : u === 4 ? a.height = d.readVarint() : u === 5 ? a.left = d.readSVarint() : u === 6 ? a.top = d.readSVarint() : u === 7 && (a.advance = d.readVarint());
      }
      const xv = y0;
      function wv(u) {
        let a = 0, d = 0;
        for (const E of u) a += E.w * E.h, d = Math.max(d, E.w);
        u.sort((E, L) => L.h - E.h);
        const p = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(a / 0.95)), d), h: 1 / 0 }];
        let v = 0, x = 0;
        for (const E of u) for (let L = p.length - 1; L >= 0; L--) {
          const R = p[L];
          if (!(E.w > R.w || E.h > R.h)) {
            if (E.x = R.x, E.y = R.y, x = Math.max(x, E.y + E.h), v = Math.max(v, E.x + E.w), E.w === R.w && E.h === R.h) {
              const F = p.pop();
              L < p.length && (p[L] = F);
            } else E.h === R.h ? (R.x += E.w, R.w -= E.w) : E.w === R.w ? (R.y += E.h, R.h -= E.h) : (p.push({ x: R.x + E.w, y: R.y, w: R.w - E.w, h: E.h }), R.y += E.h, R.h -= E.h);
            break;
          }
        }
        return { w: v, h: x, fill: a / (v * x) || 0 };
      }
      const xo = 1;
      class b0 {
        constructor(a, d) {
          let { pixelRatio: p, version: v, stretchX: x, stretchY: E, content: L, textFitWidth: R, textFitHeight: F } = d;
          this.paddedRect = a, this.pixelRatio = p, this.stretchX = x, this.stretchY = E, this.content = L, this.version = v, this.textFitWidth = R, this.textFitHeight = F;
        }
        get tl() {
          return [this.paddedRect.x + xo, this.paddedRect.y + xo];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - xo, this.paddedRect.y + this.paddedRect.h - xo];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * xo) / this.pixelRatio, (this.paddedRect.h - 2 * xo) / this.pixelRatio];
        }
      }
      class Av {
        constructor(a, d) {
          const p = {}, v = {};
          this.haveRenderCallbacks = [];
          const x = [];
          this.addImages(a, p, x), this.addImages(d, v, x);
          const { w: E, h: L } = wv(x), R = new la({ width: E || 1, height: L || 1 });
          for (const F in a) {
            const j = a[F], q = p[F].paddedRect;
            la.copy(j.data, R, { x: 0, y: 0 }, { x: q.x + xo, y: q.y + xo }, j.data);
          }
          for (const F in d) {
            const j = d[F], q = v[F].paddedRect, Y = q.x + xo, ee = q.y + xo, se = j.data.width, de = j.data.height;
            la.copy(j.data, R, { x: 0, y: 0 }, { x: Y, y: ee }, j.data), la.copy(j.data, R, { x: 0, y: de - 1 }, { x: Y, y: ee - 1 }, { width: se, height: 1 }), la.copy(j.data, R, { x: 0, y: 0 }, { x: Y, y: ee + de }, { width: se, height: 1 }), la.copy(j.data, R, { x: se - 1, y: 0 }, { x: Y - 1, y: ee }, { width: 1, height: de }), la.copy(j.data, R, { x: 0, y: 0 }, { x: Y + se, y: ee }, { width: 1, height: de });
          }
          this.image = R, this.iconPositions = p, this.patternPositions = v;
        }
        addImages(a, d, p) {
          for (const v in a) {
            const x = a[v], E = { x: 0, y: 0, w: x.data.width + 2 * xo, h: x.data.height + 2 * xo };
            p.push(E), d[v] = new b0(E, x), x.hasRenderCallback && this.haveRenderCallbacks.push(v);
          }
        }
        patchUpdatedImages(a, d) {
          a.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const p in a.updatedImages) this.patchUpdatedImage(this.iconPositions[p], a.getImage(p), d), this.patchUpdatedImage(this.patternPositions[p], a.getImage(p), d);
        }
        patchUpdatedImage(a, d, p) {
          if (!a || !d || a.version === d.version) return;
          a.version = d.version;
          const [v, x] = a.tl;
          p.update(d.data, void 0, { x: v, y: x });
        }
      }
      var Au;
      qt("ImagePosition", b0), qt("ImageAtlas", Av), c.ah = void 0, (Au = c.ah || (c.ah = {}))[Au.none = 0] = "none", Au[Au.horizontal = 1] = "horizontal", Au[Au.vertical = 2] = "vertical", Au[Au.horizontalOnly = 3] = "horizontalOnly";
      const If = -17;
      class Pf {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(a, d) {
          const p = new Pf();
          return p.scale = a || 1, p.fontStack = d, p;
        }
        static forImage(a) {
          const d = new Pf();
          return d.imageName = a, d;
        }
      }
      class cd {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(a, d) {
          const p = new cd();
          for (let v = 0; v < a.sections.length; v++) {
            const x = a.sections[v];
            x.image ? p.addImageSection(x) : p.addTextSection(x, d);
          }
          return p;
        }
        length() {
          return this.text.length;
        }
        getSection(a) {
          return this.sections[this.sectionIndex[a]];
        }
        getSectionIndex(a) {
          return this.sectionIndex[a];
        }
        getCharCode(a) {
          return this.text.charCodeAt(a);
        }
        verticalizePunctuation() {
          this.text = function(a) {
            let d = "";
            for (let p = 0; p < a.length; p++) {
              const v = a.charCodeAt(p + 1) || null, x = a.charCodeAt(p - 1) || null;
              d += v && Dc(v) && !Cf[a[p + 1]] || x && Dc(x) && !Cf[a[p - 1]] || !Cf[a[p]] ? a[p] : Cf[a[p]];
            }
            return d;
          }(this.text);
        }
        trim() {
          let a = 0;
          for (let p = 0; p < this.text.length && rg[this.text.charCodeAt(p)]; p++) a++;
          let d = this.text.length;
          for (let p = this.text.length - 1; p >= 0 && p >= a && rg[this.text.charCodeAt(p)]; p--) d--;
          this.text = this.text.substring(a, d), this.sectionIndex = this.sectionIndex.slice(a, d);
        }
        substring(a, d) {
          const p = new cd();
          return p.text = this.text.substring(a, d), p.sectionIndex = this.sectionIndex.slice(a, d), p.sections = this.sections, p;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((a, d) => Math.max(a, this.sections[d].scale), 0);
        }
        addTextSection(a, d) {
          this.text += a.text, this.sections.push(Pf.forText(a.scale, a.fontStack || d));
          const p = this.sections.length - 1;
          for (let v = 0; v < a.text.length; ++v) this.sectionIndex.push(p);
        }
        addImageSection(a) {
          const d = a.image ? a.image.name : "";
          if (d.length === 0) return void Te("Can't add FormattedSection with an empty image.");
          const p = this.getNextImageSectionCharCode();
          p ? (this.text += String.fromCharCode(p), this.sections.push(Pf.forImage(d)), this.sectionIndex.push(this.sections.length - 1)) : Te("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function ng(u, a, d, p, v, x, E, L, R, F, j, q, Y, ee, se) {
        const de = cd.fromFeature(u, v);
        let we;
        q === c.ah.vertical && de.verticalizePunctuation();
        const { processBidirectionalText: Me, processStyledBidirectionalText: $e } = Ts;
        if (Me && de.sections.length === 1) {
          we = [];
          const it = Me(de.toString(), v0(de, F, x, a, p, ee));
          for (const At of it) {
            const Gt = new cd();
            Gt.text = At, Gt.sections = de.sections;
            for (let mn = 0; mn < At.length; mn++) Gt.sectionIndex.push(0);
            we.push(Gt);
          }
        } else if ($e) {
          we = [];
          const it = $e(de.text, de.sectionIndex, v0(de, F, x, a, p, ee));
          for (const At of it) {
            const Gt = new cd();
            Gt.text = At[0], Gt.sectionIndex = At[1], Gt.sections = de.sections, we.push(Gt);
          }
        } else we = function(it, At) {
          const Gt = [], mn = it.text;
          let Ut = 0;
          for (const kt of At) Gt.push(it.substring(Ut, kt)), Ut = kt;
          return Ut < mn.length && Gt.push(it.substring(Ut, mn.length)), Gt;
        }(de, v0(de, F, x, a, p, ee));
        const Ne = [], Ve = { positionedLines: Ne, text: de.toString(), top: j[1], bottom: j[1], left: j[0], right: j[0], writingMode: q, iconsInText: !1, verticalizable: !1 };
        return function(it, At, Gt, mn, Ut, kt, sn, $t, Ht, pt, on, tn) {
          let Tn = 0, Ir = If, wr = 0, Gi = 0;
          const ja = $t === "right" ? 1 : $t === "left" ? 0 : 0.5;
          let ds = 0;
          for (const di of Ut) {
            di.trim();
            const qi = di.getMaxScale(), Ls = (qi - 1) * Mi, fs = { positionedGlyphs: [], lineOffset: 0 };
            it.positionedLines[ds] = fs;
            const $s = fs.positionedGlyphs;
            let ps = 0;
            if (!di.length()) {
              Ir += kt, ++ds;
              continue;
            }
            for (let wo = 0; wo < di.length(); wo++) {
              const ar = di.getSection(wo), Nr = di.getSectionIndex(wo), Vr = di.getCharCode(wo);
              let zo = 0, ai = null, fd = null, oc = null, ac = Mi;
              const Ga = !(Ht === c.ah.horizontal || !on && !ah(Vr) || on && (rg[Vr] || (Vi = Vr, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(Vi)))));
              if (ar.imageName) {
                const ha = mn[ar.imageName];
                if (!ha) continue;
                oc = ar.imageName, it.iconsInText = it.iconsInText || !0, fd = ha.paddedRect;
                const rs = ha.displaySize;
                ar.scale = ar.scale * Mi / tn, ai = { width: rs[0], height: rs[1], left: xo, top: -xv, advance: Ga ? rs[1] : rs[0] }, zo = Ls + (Mi - rs[1] * ar.scale), ac = ai.advance;
                const Hc = Ga ? rs[0] * ar.scale - Mi * qi : rs[1] * ar.scale - Mi * qi;
                Hc > 0 && Hc > ps && (ps = Hc);
              } else {
                const ha = Gt[ar.fontStack], rs = ha && ha[Vr];
                if (rs && rs.rect) fd = rs.rect, ai = rs.metrics;
                else {
                  const Hc = At[ar.fontStack], Df = Hc && Hc[Vr];
                  if (!Df) continue;
                  ai = Df.metrics;
                }
                zo = (qi - ar.scale) * Mi;
              }
              Ga ? (it.verticalizable = !0, $s.push({ glyph: Vr, imageName: oc, x: Tn, y: Ir + zo, vertical: Ga, scale: ar.scale, fontStack: ar.fontStack, sectionIndex: Nr, metrics: ai, rect: fd }), Tn += ac * ar.scale + pt) : ($s.push({ glyph: Vr, imageName: oc, x: Tn, y: Ir + zo, vertical: Ga, scale: ar.scale, fontStack: ar.fontStack, sectionIndex: Nr, metrics: ai, rect: fd }), Tn += ai.advance * ar.scale + pt);
            }
            $s.length !== 0 && (wr = Math.max(Tn - pt, wr), RC($s, 0, $s.length - 1, ja, ps)), Tn = 0;
            const ua = kt * qi + ps;
            fs.lineOffset = Math.max(ps, Ls), Ir += ua, Gi = Math.max(ua, Gi), ++ds;
          }
          var Vi;
          const Hs = Ir - If, { horizontalAlign: Ws, verticalAlign: Xs } = x0(sn);
          (function(di, qi, Ls, fs, $s, ps, ua, wo, ar) {
            const Nr = (qi - Ls) * $s;
            let Vr = 0;
            Vr = ps !== ua ? -wo * fs - If : (-fs * ar + 0.5) * ua;
            for (const zo of di) for (const ai of zo.positionedGlyphs) ai.x += Nr, ai.y += Vr;
          })(it.positionedLines, ja, Ws, Xs, wr, Gi, kt, Hs, Ut.length), it.top += -Xs * Hs, it.bottom = it.top + Hs, it.left += -Ws * wr, it.right = it.left + wr;
        }(Ve, a, d, p, we, E, L, R, q, F, Y, se), !function(it) {
          for (const At of it) if (At.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(Ne) && Ve;
      }
      const rg = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, LC = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, MC = { 40: !0 };
      function Sv(u, a, d, p, v, x) {
        if (a.imageName) {
          const E = p[a.imageName];
          return E ? E.displaySize[0] * a.scale * Mi / x + v : 0;
        }
        {
          const E = d[a.fontStack], L = E && E[u];
          return L ? L.metrics.advance * a.scale + v : 0;
        }
      }
      function Ev(u, a, d, p) {
        const v = Math.pow(u - a, 2);
        return p ? u < a ? v / 2 : 2 * v : v + Math.abs(d) * d;
      }
      function BC(u, a, d) {
        let p = 0;
        return u === 10 && (p -= 1e4), d && (p += 150), u !== 40 && u !== 65288 || (p += 50), a !== 41 && a !== 65289 || (p += 50), p;
      }
      function Tv(u, a, d, p, v, x) {
        let E = null, L = Ev(a, d, v, x);
        for (const R of p) {
          const F = Ev(a - R.x, d, v, x) + R.badness;
          F <= L && (E = R, L = F);
        }
        return { index: u, x: a, priorBreak: E, badness: L };
      }
      function Cv(u) {
        return u ? Cv(u.priorBreak).concat(u.index) : [];
      }
      function v0(u, a, d, p, v, x) {
        if (!u) return [];
        const E = [], L = function(q, Y, ee, se, de, we) {
          let Me = 0;
          for (let $e = 0; $e < q.length(); $e++) {
            const Ne = q.getSection($e);
            Me += Sv(q.getCharCode($e), Ne, se, de, Y, we);
          }
          return Me / Math.max(1, Math.ceil(Me / ee));
        }(u, a, d, p, v, x), R = u.text.indexOf("​") >= 0;
        let F = 0;
        for (let q = 0; q < u.length(); q++) {
          const Y = u.getSection(q), ee = u.getCharCode(q);
          if (rg[ee] || (F += Sv(ee, Y, p, v, a, x)), q < u.length() - 1) {
            const se = !((j = ee) < 11904) && (!!Cn["CJK Compatibility Forms"](j) || !!Cn["CJK Compatibility"](j) || !!Cn["CJK Strokes"](j) || !!Cn["CJK Symbols and Punctuation"](j) || !!Cn["Enclosed CJK Letters and Months"](j) || !!Cn["Halfwidth and Fullwidth Forms"](j) || !!Cn["Ideographic Description Characters"](j) || !!Cn["Vertical Forms"](j) || oh.test(String.fromCodePoint(j)));
            (LC[ee] || se || Y.imageName || q !== u.length() - 2 && MC[u.getCharCode(q + 1)]) && E.push(Tv(q + 1, F, L, E, BC(ee, u.getCharCode(q + 1), se && R), !1));
          }
        }
        var j;
        return Cv(Tv(u.length(), F, L, E, 0, !0));
      }
      function x0(u) {
        let a = 0.5, d = 0.5;
        switch (u) {
          case "right":
          case "top-right":
          case "bottom-right":
            a = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            a = 0;
        }
        switch (u) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            d = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            d = 0;
        }
        return { horizontalAlign: a, verticalAlign: d };
      }
      function RC(u, a, d, p, v) {
        if (!p && !v) return;
        const x = u[d], E = (u[d].x + x.metrics.advance * x.scale) * p;
        for (let L = a; L <= d; L++) u[L].x -= E, u[L].y += v;
      }
      function OC(u, a, d) {
        const { horizontalAlign: p, verticalAlign: v } = x0(d), x = a[0] - u.displaySize[0] * p, E = a[1] - u.displaySize[1] * v;
        return { image: u, top: E, bottom: E + u.displaySize[1], left: x, right: x + u.displaySize[0] };
      }
      function Iv(u) {
        var a, d;
        let p = u.left, v = u.top, x = u.right - p, E = u.bottom - v;
        const L = (a = u.image.textFitWidth) !== null && a !== void 0 ? a : "stretchOrShrink", R = (d = u.image.textFitHeight) !== null && d !== void 0 ? d : "stretchOrShrink", F = (u.image.content[2] - u.image.content[0]) / (u.image.content[3] - u.image.content[1]);
        if (R === "proportional") {
          if (L === "stretchOnly" && x / E < F || L === "proportional") {
            const j = Math.ceil(E * F);
            p *= j / x, x = j;
          }
        } else if (L === "proportional" && R === "stretchOnly" && F !== 0 && x / E > F) {
          const j = Math.ceil(x / F);
          v *= j / E, E = j;
        }
        return { x1: p, y1: v, x2: p + x, y2: v + E };
      }
      function Pv(u, a, d, p, v, x) {
        const E = u.image;
        let L;
        if (E.content) {
          const we = E.content, Me = E.pixelRatio || 1;
          L = [we[0] / Me, we[1] / Me, E.displaySize[0] - we[2] / Me, E.displaySize[1] - we[3] / Me];
        }
        const R = a.left * x, F = a.right * x;
        let j, q, Y, ee;
        d === "width" || d === "both" ? (ee = v[0] + R - p[3], q = v[0] + F + p[1]) : (ee = v[0] + (R + F - E.displaySize[0]) / 2, q = ee + E.displaySize[0]);
        const se = a.top * x, de = a.bottom * x;
        return d === "height" || d === "both" ? (j = v[1] + se - p[0], Y = v[1] + de + p[2]) : (j = v[1] + (se + de - E.displaySize[1]) / 2, Y = j + E.displaySize[1]), { image: E, top: j, right: q, bottom: Y, left: ee, collisionPadding: L };
      }
      const Lf = 255, sc = 128, Su = Lf * sc;
      function Lv(u, a) {
        const { expression: d } = a;
        if (d.kind === "constant") return { kind: "constant", layoutSize: d.evaluate(new vr(u + 1)) };
        if (d.kind === "source") return { kind: "source" };
        {
          const { zoomStops: p, interpolationType: v } = d;
          let x = 0;
          for (; x < p.length && p[x] <= u; ) x++;
          x = Math.max(0, x - 1);
          let E = x;
          for (; E < p.length && p[E] < u + 1; ) E++;
          E = Math.min(p.length - 1, E);
          const L = p[x], R = p[E];
          return d.kind === "composite" ? { kind: "composite", minZoom: L, maxZoom: R, interpolationType: v } : { kind: "camera", minZoom: L, maxZoom: R, minSize: d.evaluate(new vr(L)), maxSize: d.evaluate(new vr(R)), interpolationType: v };
        }
      }
      function w0(u, a, d) {
        let p = "never";
        const v = u.get(a);
        return v ? p = v : u.get(d) && (p = "always"), p;
      }
      const DC = wu.VectorTileFeature.types, FC = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function ig(u, a, d, p, v, x, E, L, R, F, j, q, Y) {
        const ee = L ? Math.min(Su, Math.round(L[0])) : 0, se = L ? Math.min(Su, Math.round(L[1])) : 0;
        u.emplaceBack(a, d, Math.round(32 * p), Math.round(32 * v), x, E, (ee << 1) + (R ? 1 : 0), se, 16 * F, 16 * j, 256 * q, 256 * Y);
      }
      function A0(u, a, d) {
        u.emplaceBack(a.x, a.y, d), u.emplaceBack(a.x, a.y, d), u.emplaceBack(a.x, a.y, d), u.emplaceBack(a.x, a.y, d);
      }
      function kC(u) {
        for (const a of u.sections) if (Zh(a.text)) return !0;
        return !1;
      }
      class S0 {
        constructor(a) {
          this.layoutVertexArray = new zc(), this.indexArray = new Ui(), this.programConfigurations = a, this.segments = new Hn(), this.dynamicLayoutVertexArray = new Kl(), this.opacityVertexArray = new zi(), this.hasVisibleVertices = !1, this.placedSymbolArray = new An();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(a, d, p, v) {
          this.isEmpty() || (p && (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, fC.members), this.indexBuffer = a.createIndexBuffer(this.indexArray, d), this.dynamicLayoutVertexBuffer = a.createVertexBuffer(this.dynamicLayoutVertexArray, pC.members, !0), this.opacityVertexBuffer = a.createVertexBuffer(this.opacityVertexArray, FC, !0), this.opacityVertexBuffer.itemSize = 1), (p || v) && this.programConfigurations.upload(a));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      qt("SymbolBuffers", S0);
      class E0 {
        constructor(a, d, p) {
          this.layoutVertexArray = new a(), this.layoutAttributes = d, this.indexArray = new p(), this.segments = new Hn(), this.collisionVertexArray = new wi();
        }
        upload(a) {
          this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = a.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = a.createVertexBuffer(this.collisionVertexArray, gC.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      qt("CollisionBuffers", E0);
      class ud {
        constructor(a) {
          this.collisionBoxArray = a.collisionBoxArray, this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((E) => E.id), this.index = a.index, this.pixelRatio = a.pixelRatio, this.sourceLayerIndex = a.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = i0([]), this.placementViewportMatrix = i0([]);
          const d = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Lv(this.zoom, d["text-size"]), this.iconSizeData = Lv(this.zoom, d["icon-size"]);
          const p = this.layers[0].layout, v = p.get("symbol-sort-key"), x = p.get("symbol-z-order");
          this.canOverlap = w0(p, "text-overlap", "text-allow-overlap") !== "never" || w0(p, "icon-overlap", "icon-allow-overlap") !== "never" || p.get("text-ignore-placement") || p.get("icon-ignore-placement"), this.sortFeaturesByKey = x !== "viewport-y" && !v.isConstant(), this.sortFeaturesByY = (x === "viewport-y" || x === "auto" && !this.sortFeaturesByKey) && this.canOverlap, p.get("symbol-placement") === "point" && (this.writingModes = p.get("text-writing-mode").map((E) => c.ah[E])), this.stateDependentLayerIds = this.layers.filter((E) => E.isStateDependent()).map((E) => E.id), this.sourceID = a.sourceID;
        }
        createArrays() {
          this.text = new S0(new tc(this.layers, this.zoom, (a) => /^text/.test(a))), this.icon = new S0(new tc(this.layers, this.zoom, (a) => /^icon/.test(a))), this.glyphOffsetArray = new Dn(), this.lineVertexArray = new sr(), this.symbolInstances = new En(), this.textAnchorOffsets = new Qn();
        }
        calculateGlyphDependencies(a, d, p, v, x) {
          for (let E = 0; E < a.length; E++) if (d[a.charCodeAt(E)] = !0, (p || v) && x) {
            const L = Cf[a.charAt(E)];
            L && (d[L.charCodeAt(0)] = !0);
          }
        }
        populate(a, d, p) {
          const v = this.layers[0], x = v.layout, E = x.get("text-font"), L = x.get("text-field"), R = x.get("icon-image"), F = (L.value.kind !== "constant" || L.value.value instanceof Pr && !L.value.value.isEmpty() || L.value.value.toString().length > 0) && (E.value.kind !== "constant" || E.value.value.length > 0), j = R.value.kind !== "constant" || !!R.value.value || Object.keys(R.parameters).length > 0, q = x.get("symbol-sort-key");
          if (this.features = [], !F && !j) return;
          const Y = d.iconDependencies, ee = d.glyphDependencies, se = d.availableImages, de = new vr(this.zoom);
          for (const { feature: we, id: Me, index: $e, sourceLayerIndex: Ne } of a) {
            const Ve = v._featureFilter.needGeometry, it = nc(we, Ve);
            if (!v._featureFilter.filter(de, it, p)) continue;
            let At, Gt;
            if (Ve || (it.geometry = Gc(we)), F) {
              const Ut = v.getValueAndResolveTokens("text-field", it, p, se), kt = Pr.factory(Ut), sn = this.hasRTLText = this.hasRTLText || kC(kt);
              (!sn || Ts.getRTLTextPluginStatus() === "unavailable" || sn && Ts.isParsed()) && (At = _C(kt, v, it));
            }
            if (j) {
              const Ut = v.getValueAndResolveTokens("icon-image", it, p, se);
              Gt = Ut instanceof Er ? Ut : Er.fromString(Ut);
            }
            if (!At && !Gt) continue;
            const mn = this.sortFeaturesByKey ? q.evaluate(it, {}, p) : void 0;
            if (this.features.push({ id: Me, text: At, icon: Gt, index: $e, sourceLayerIndex: Ne, geometry: it.geometry, properties: we.properties, type: DC[we.type], sortKey: mn }), Gt && (Y[Gt.name] = !0), At) {
              const Ut = E.evaluate(it, {}, p).join(","), kt = x.get("text-rotation-alignment") !== "viewport" && x.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(c.ah.vertical) >= 0;
              for (const sn of At.sections) if (sn.image) Y[sn.image.name] = !0;
              else {
                const $t = sh(At.toString()), Ht = sn.fontStack || Ut, pt = ee[Ht] = ee[Ht] || {};
                this.calculateGlyphDependencies(sn.text, pt, kt, this.allowVerticalPlacement, $t);
              }
            }
          }
          x.get("symbol-placement") === "line" && (this.features = function(we) {
            const Me = {}, $e = {}, Ne = [];
            let Ve = 0;
            function it(Ut) {
              Ne.push(we[Ut]), Ve++;
            }
            function At(Ut, kt, sn) {
              const $t = $e[Ut];
              return delete $e[Ut], $e[kt] = $t, Ne[$t].geometry[0].pop(), Ne[$t].geometry[0] = Ne[$t].geometry[0].concat(sn[0]), $t;
            }
            function Gt(Ut, kt, sn) {
              const $t = Me[kt];
              return delete Me[kt], Me[Ut] = $t, Ne[$t].geometry[0].shift(), Ne[$t].geometry[0] = sn[0].concat(Ne[$t].geometry[0]), $t;
            }
            function mn(Ut, kt, sn) {
              const $t = sn ? kt[0][kt[0].length - 1] : kt[0][0];
              return `${Ut}:${$t.x}:${$t.y}`;
            }
            for (let Ut = 0; Ut < we.length; Ut++) {
              const kt = we[Ut], sn = kt.geometry, $t = kt.text ? kt.text.toString() : null;
              if (!$t) {
                it(Ut);
                continue;
              }
              const Ht = mn($t, sn), pt = mn($t, sn, !0);
              if (Ht in $e && pt in Me && $e[Ht] !== Me[pt]) {
                const on = Gt(Ht, pt, sn), tn = At(Ht, pt, Ne[on].geometry);
                delete Me[Ht], delete $e[pt], $e[mn($t, Ne[tn].geometry, !0)] = tn, Ne[on].geometry = null;
              } else Ht in $e ? At(Ht, pt, sn) : pt in Me ? Gt(Ht, pt, sn) : (it(Ut), Me[Ht] = Ve - 1, $e[pt] = Ve - 1);
            }
            return Ne.filter((Ut) => Ut.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((we, Me) => we.sortKey - Me.sortKey);
        }
        update(a, d, p) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(a, d, this.layers, p), this.icon.programConfigurations.updatePaintArrays(a, d, this.layers, p));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(a) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(a), this.iconCollisionBox.upload(a)), this.text.upload(a, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(a, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(a, d) {
          const p = this.lineVertexArray.length;
          if (a.segment !== void 0) {
            let v = a.dist(d[a.segment + 1]), x = a.dist(d[a.segment]);
            const E = {};
            for (let L = a.segment + 1; L < d.length; L++) E[L] = { x: d[L].x, y: d[L].y, tileUnitDistanceFromAnchor: v }, L < d.length - 1 && (v += d[L + 1].dist(d[L]));
            for (let L = a.segment || 0; L >= 0; L--) E[L] = { x: d[L].x, y: d[L].y, tileUnitDistanceFromAnchor: x }, L > 0 && (x += d[L - 1].dist(d[L]));
            for (let L = 0; L < d.length; L++) {
              const R = E[L];
              this.lineVertexArray.emplaceBack(R.x, R.y, R.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: p, lineLength: this.lineVertexArray.length - p };
        }
        addSymbols(a, d, p, v, x, E, L, R, F, j, q, Y) {
          const ee = a.indexArray, se = a.layoutVertexArray, de = a.segments.prepareSegment(4 * d.length, se, ee, this.canOverlap ? E.sortKey : void 0), we = this.glyphOffsetArray.length, Me = de.vertexLength, $e = this.allowVerticalPlacement && L === c.ah.vertical ? Math.PI / 2 : 0, Ne = E.text && E.text.sections;
          for (let Ve = 0; Ve < d.length; Ve++) {
            const { tl: it, tr: At, bl: Gt, br: mn, tex: Ut, pixelOffsetTL: kt, pixelOffsetBR: sn, minFontScaleX: $t, minFontScaleY: Ht, glyphOffset: pt, isSDF: on, sectionIndex: tn } = d[Ve], Tn = de.vertexLength, Ir = pt[1];
            ig(se, R.x, R.y, it.x, Ir + it.y, Ut.x, Ut.y, p, on, kt.x, kt.y, $t, Ht), ig(se, R.x, R.y, At.x, Ir + At.y, Ut.x + Ut.w, Ut.y, p, on, sn.x, kt.y, $t, Ht), ig(se, R.x, R.y, Gt.x, Ir + Gt.y, Ut.x, Ut.y + Ut.h, p, on, kt.x, sn.y, $t, Ht), ig(se, R.x, R.y, mn.x, Ir + mn.y, Ut.x + Ut.w, Ut.y + Ut.h, p, on, sn.x, sn.y, $t, Ht), A0(a.dynamicLayoutVertexArray, R, $e), ee.emplaceBack(Tn, Tn + 1, Tn + 2), ee.emplaceBack(Tn + 1, Tn + 2, Tn + 3), de.vertexLength += 4, de.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(pt[0]), Ve !== d.length - 1 && tn === d[Ve + 1].sectionIndex || a.programConfigurations.populatePaintArrays(se.length, E, E.index, {}, Y, Ne && Ne[tn]);
          }
          a.placedSymbolArray.emplaceBack(R.x, R.y, we, this.glyphOffsetArray.length - we, Me, F, j, R.segment, p ? p[0] : 0, p ? p[1] : 0, v[0], v[1], L, 0, !1, 0, q);
        }
        _addCollisionDebugVertex(a, d, p, v, x, E) {
          return d.emplaceBack(0, 0), a.emplaceBack(p.x, p.y, v, x, Math.round(E.x), Math.round(E.y));
        }
        addCollisionDebugVertices(a, d, p, v, x, E, L) {
          const R = x.segments.prepareSegment(4, x.layoutVertexArray, x.indexArray), F = R.vertexLength, j = x.layoutVertexArray, q = x.collisionVertexArray, Y = L.anchorX, ee = L.anchorY;
          this._addCollisionDebugVertex(j, q, E, Y, ee, new T(a, d)), this._addCollisionDebugVertex(j, q, E, Y, ee, new T(p, d)), this._addCollisionDebugVertex(j, q, E, Y, ee, new T(p, v)), this._addCollisionDebugVertex(j, q, E, Y, ee, new T(a, v)), R.vertexLength += 4;
          const se = x.indexArray;
          se.emplaceBack(F, F + 1), se.emplaceBack(F + 1, F + 2), se.emplaceBack(F + 2, F + 3), se.emplaceBack(F + 3, F), R.primitiveLength += 4;
        }
        addDebugCollisionBoxes(a, d, p, v) {
          for (let x = a; x < d; x++) {
            const E = this.collisionBoxArray.get(x);
            this.addCollisionDebugVertices(E.x1, E.y1, E.x2, E.y2, v ? this.textCollisionBox : this.iconCollisionBox, E.anchorPoint, p);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new E0(ns, fv.members, Kr), this.iconCollisionBox = new E0(ns, fv.members, Kr);
          for (let a = 0; a < this.symbolInstances.length; a++) {
            const d = this.symbolInstances.get(a);
            this.addDebugCollisionBoxes(d.textBoxStartIndex, d.textBoxEndIndex, d, !0), this.addDebugCollisionBoxes(d.verticalTextBoxStartIndex, d.verticalTextBoxEndIndex, d, !0), this.addDebugCollisionBoxes(d.iconBoxStartIndex, d.iconBoxEndIndex, d, !1), this.addDebugCollisionBoxes(d.verticalIconBoxStartIndex, d.verticalIconBoxEndIndex, d, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(a, d, p, v, x, E, L, R, F) {
          const j = {};
          for (let q = d; q < p; q++) {
            const Y = a.get(q);
            j.textBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, j.textFeatureIndex = Y.featureIndex;
            break;
          }
          for (let q = v; q < x; q++) {
            const Y = a.get(q);
            j.verticalTextBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, j.verticalTextFeatureIndex = Y.featureIndex;
            break;
          }
          for (let q = E; q < L; q++) {
            const Y = a.get(q);
            j.iconBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, j.iconFeatureIndex = Y.featureIndex;
            break;
          }
          for (let q = R; q < F; q++) {
            const Y = a.get(q);
            j.verticalIconBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, j.verticalIconFeatureIndex = Y.featureIndex;
            break;
          }
          return j;
        }
        deserializeCollisionBoxes(a) {
          this.collisionArrays = [];
          for (let d = 0; d < this.symbolInstances.length; d++) {
            const p = this.symbolInstances.get(d);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(a, p.textBoxStartIndex, p.textBoxEndIndex, p.verticalTextBoxStartIndex, p.verticalTextBoxEndIndex, p.iconBoxStartIndex, p.iconBoxEndIndex, p.verticalIconBoxStartIndex, p.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(a, d) {
          const p = a.placedSymbolArray.get(d), v = p.vertexStartIndex + 4 * p.numGlyphs;
          for (let x = p.vertexStartIndex; x < v; x += 4) a.indexArray.emplaceBack(x, x + 1, x + 2), a.indexArray.emplaceBack(x + 1, x + 2, x + 3);
        }
        getSortedSymbolIndexes(a) {
          if (this.sortedAngle === a && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const d = Math.sin(a), p = Math.cos(a), v = [], x = [], E = [];
          for (let L = 0; L < this.symbolInstances.length; ++L) {
            E.push(L);
            const R = this.symbolInstances.get(L);
            v.push(0 | Math.round(d * R.anchorX + p * R.anchorY)), x.push(R.featureIndex);
          }
          return E.sort((L, R) => v[L] - v[R] || x[R] - x[L]), E;
        }
        addToSortKeyRanges(a, d) {
          const p = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          p && p.sortKey === d ? p.symbolInstanceEnd = a + 1 : this.sortKeyRanges.push({ sortKey: d, symbolInstanceStart: a, symbolInstanceEnd: a + 1 });
        }
        sortFeatures(a) {
          if (this.sortFeaturesByY && this.sortedAngle !== a && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(a), this.sortedAngle = a, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const d of this.symbolInstanceIndexes) {
              const p = this.symbolInstances.get(d);
              this.featureSortOrder.push(p.featureIndex), [p.rightJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.leftJustifiedTextSymbolIndex].forEach((v, x, E) => {
                v >= 0 && E.indexOf(v) === x && this.addIndicesForPlacedSymbol(this.text, v);
              }), p.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, p.verticalPlacedTextSymbolIndex), p.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.placedIconSymbolIndex), p.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Mv, Bv;
      qt("SymbolBucket", ud, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ud.MAX_GLYPHS = 65535, ud.addDynamicAttributes = A0;
      var T0 = { get paint() {
        return Bv = Bv || new g({ "icon-opacity": new gn(ne.paint_symbol["icon-opacity"]), "icon-color": new gn(ne.paint_symbol["icon-color"]), "icon-halo-color": new gn(ne.paint_symbol["icon-halo-color"]), "icon-halo-width": new gn(ne.paint_symbol["icon-halo-width"]), "icon-halo-blur": new gn(ne.paint_symbol["icon-halo-blur"]), "icon-translate": new Yt(ne.paint_symbol["icon-translate"]), "icon-translate-anchor": new Yt(ne.paint_symbol["icon-translate-anchor"]), "text-opacity": new gn(ne.paint_symbol["text-opacity"]), "text-color": new gn(ne.paint_symbol["text-color"], { runtimeType: qn, getOverride: (u) => u.textColor, hasOverride: (u) => !!u.textColor }), "text-halo-color": new gn(ne.paint_symbol["text-halo-color"]), "text-halo-width": new gn(ne.paint_symbol["text-halo-width"]), "text-halo-blur": new gn(ne.paint_symbol["text-halo-blur"]), "text-translate": new Yt(ne.paint_symbol["text-translate"]), "text-translate-anchor": new Yt(ne.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return Mv = Mv || new g({ "symbol-placement": new Yt(ne.layout_symbol["symbol-placement"]), "symbol-spacing": new Yt(ne.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Yt(ne.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new gn(ne.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Yt(ne.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Yt(ne.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Yt(ne.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Yt(ne.layout_symbol["icon-ignore-placement"]), "icon-optional": new Yt(ne.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Yt(ne.layout_symbol["icon-rotation-alignment"]), "icon-size": new gn(ne.layout_symbol["icon-size"]), "icon-text-fit": new Yt(ne.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Yt(ne.layout_symbol["icon-text-fit-padding"]), "icon-image": new gn(ne.layout_symbol["icon-image"]), "icon-rotate": new gn(ne.layout_symbol["icon-rotate"]), "icon-padding": new gn(ne.layout_symbol["icon-padding"]), "icon-keep-upright": new Yt(ne.layout_symbol["icon-keep-upright"]), "icon-offset": new gn(ne.layout_symbol["icon-offset"]), "icon-anchor": new gn(ne.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Yt(ne.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Yt(ne.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Yt(ne.layout_symbol["text-rotation-alignment"]), "text-field": new gn(ne.layout_symbol["text-field"]), "text-font": new gn(ne.layout_symbol["text-font"]), "text-size": new gn(ne.layout_symbol["text-size"]), "text-max-width": new gn(ne.layout_symbol["text-max-width"]), "text-line-height": new Yt(ne.layout_symbol["text-line-height"]), "text-letter-spacing": new gn(ne.layout_symbol["text-letter-spacing"]), "text-justify": new gn(ne.layout_symbol["text-justify"]), "text-radial-offset": new gn(ne.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Yt(ne.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new gn(ne.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new gn(ne.layout_symbol["text-anchor"]), "text-max-angle": new Yt(ne.layout_symbol["text-max-angle"]), "text-writing-mode": new Yt(ne.layout_symbol["text-writing-mode"]), "text-rotate": new gn(ne.layout_symbol["text-rotate"]), "text-padding": new Yt(ne.layout_symbol["text-padding"]), "text-keep-upright": new Yt(ne.layout_symbol["text-keep-upright"]), "text-transform": new gn(ne.layout_symbol["text-transform"]), "text-offset": new gn(ne.layout_symbol["text-offset"]), "text-allow-overlap": new Yt(ne.layout_symbol["text-allow-overlap"]), "text-overlap": new Yt(ne.layout_symbol["text-overlap"]), "text-ignore-placement": new Yt(ne.layout_symbol["text-ignore-placement"]), "text-optional": new Yt(ne.layout_symbol["text-optional"]) });
      } };
      class Rv {
        constructor(a) {
          if (a.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = a.property.overrides ? a.property.overrides.runtimeType : _r, this.defaultValue = a;
        }
        evaluate(a) {
          if (a.formattedSection) {
            const d = this.defaultValue.property.overrides;
            if (d && d.hasOverride(a.formattedSection)) return d.getOverride(a.formattedSection);
          }
          return a.feature && a.featureState ? this.defaultValue.evaluate(a.feature, a.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(a) {
          this.defaultValue.isConstant() || a(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      qt("FormatSectionOverride", Rv, { omit: ["defaultValue"] });
      class sg extends h {
        constructor(a) {
          super(a, T0);
        }
        recalculate(a, d) {
          if (super.recalculate(a, d), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const p = this.layout.get("text-writing-mode");
            if (p) {
              const v = [];
              for (const x of p) v.indexOf(x) < 0 && v.push(x);
              this.layout._values["text-writing-mode"] = v;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(a, d, p, v) {
          const x = this.layout.get(a).evaluate(d, {}, p, v), E = this._unevaluatedLayout._values[a];
          return E.isDataDriven() || mo(E.value) || !x ? x : function(L, R) {
            return R.replace(/{([^{}]+)}/g, (F, j) => L && j in L ? String(L[j]) : "");
          }(d.properties, x);
        }
        createBucket(a) {
          return new ud(a);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const a of T0.paint.overridableProperties) {
            if (!sg.hasPaintOverride(this.layout, a)) continue;
            const d = this.paint.get(a), p = new Rv(d), v = new Ma(p, d.property.specification);
            let x = null;
            x = d.value.kind === "constant" || d.value.kind === "source" ? new cs("source", v) : new ks("composite", v, d.value.zoomStops), this.paint._values[a] = new bo(d.property, x, d.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(a, d, p) {
          return !(!this.layout || d.isDataDriven() || p.isDataDriven()) && sg.hasPaintOverride(this.layout, a);
        }
        static hasPaintOverride(a, d) {
          const p = a.get("text-field"), v = T0.paint.properties[d];
          let x = !1;
          const E = (L) => {
            for (const R of L) if (v.overrides && v.overrides.hasOverride(R)) return void (x = !0);
          };
          if (p.value.kind === "constant" && p.value.value instanceof Pr) E(p.value.value.sections);
          else if (p.value.kind === "source") {
            const L = (F) => {
              x || (F instanceof fi && yr(F.value) === rr ? E(F.value.sections) : F instanceof Dl ? E(F.sections) : F.eachChild(L));
            }, R = p.value;
            R._styleExpression && L(R._styleExpression.expression);
          }
          return x;
        }
      }
      let Ov;
      var NC = { get paint() {
        return Ov = Ov || new g({ "background-color": new Yt(ne.paint_background["background-color"]), "background-pattern": new A(ne.paint_background["background-pattern"]), "background-opacity": new Yt(ne.paint_background["background-opacity"]) });
      } };
      class zC extends h {
        constructor(a) {
          super(a, NC);
        }
      }
      let Dv;
      var UC = { get paint() {
        return Dv = Dv || new g({ "raster-opacity": new Yt(ne.paint_raster["raster-opacity"]), "raster-hue-rotate": new Yt(ne.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Yt(ne.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Yt(ne.paint_raster["raster-brightness-max"]), "raster-saturation": new Yt(ne.paint_raster["raster-saturation"]), "raster-contrast": new Yt(ne.paint_raster["raster-contrast"]), "raster-resampling": new Yt(ne.paint_raster["raster-resampling"]), "raster-fade-duration": new Yt(ne.paint_raster["raster-fade-duration"]) });
      } };
      class jC extends h {
        constructor(a) {
          super(a, UC);
        }
      }
      class GC extends h {
        constructor(a) {
          super(a, {}), this.onAdd = (d) => {
            this.implementation.onAdd && this.implementation.onAdd(d, d.painter.context.gl);
          }, this.onRemove = (d) => {
            this.implementation.onRemove && this.implementation.onRemove(d, d.painter.context.gl);
          }, this.implementation = a;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class VC {
        constructor(a) {
          this._methodToThrottle = a, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const C0 = 63710088e-1;
      class Eu {
        constructor(a, d) {
          if (isNaN(a) || isNaN(d)) throw new Error(`Invalid LngLat object: (${a}, ${d})`);
          if (this.lng = +a, this.lat = +d, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Eu(Re(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(a) {
          const d = Math.PI / 180, p = this.lat * d, v = a.lat * d, x = Math.sin(p) * Math.sin(v) + Math.cos(p) * Math.cos(v) * Math.cos((a.lng - this.lng) * d);
          return C0 * Math.acos(Math.min(x, 1));
        }
        static convert(a) {
          if (a instanceof Eu) return a;
          if (Array.isArray(a) && (a.length === 2 || a.length === 3)) return new Eu(Number(a[0]), Number(a[1]));
          if (!Array.isArray(a) && typeof a == "object" && a !== null) return new Eu(Number("lng" in a ? a.lng : a.lon), Number(a.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Fv = 2 * Math.PI * C0;
      function kv(u) {
        return Fv * Math.cos(u * Math.PI / 180);
      }
      function Nv(u) {
        return (180 + u) / 360;
      }
      function zv(u) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + u * Math.PI / 360))) / 360;
      }
      function Uv(u, a) {
        return u / kv(a);
      }
      function I0(u) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90;
      }
      class Mf {
        constructor(a, d) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          this.x = +a, this.y = +d, this.z = +p;
        }
        static fromLngLat(a) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          const p = Eu.convert(a);
          return new Mf(Nv(p.lng), zv(p.lat), Uv(d, p.lat));
        }
        toLngLat() {
          return new Eu(360 * this.x - 180, I0(this.y));
        }
        toAltitude() {
          return this.z * kv(I0(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Fv * (a = I0(this.y), 1 / Math.cos(a * Math.PI / 180));
          var a;
        }
      }
      function jv(u, a, d) {
        var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, d);
        return [u * p - 2 * Math.PI * 6378137 / 2, a * p - 2 * Math.PI * 6378137 / 2];
      }
      class P0 {
        constructor(a, d, p) {
          if (!function(v, x, E) {
            return !(v < 0 || v > 25 || E < 0 || E >= Math.pow(2, v) || x < 0 || x >= Math.pow(2, v));
          }(a, d, p)) throw new Error(`x=${d}, y=${p}, z=${a} outside of bounds. 0<=x<${Math.pow(2, a)}, 0<=y<${Math.pow(2, a)} 0<=z<=25 `);
          this.z = a, this.x = d, this.y = p, this.key = Bf(0, a, a, d, p);
        }
        equals(a) {
          return this.z === a.z && this.x === a.x && this.y === a.y;
        }
        url(a, d, p) {
          const v = (E = this.y, L = this.z, R = jv(256 * (x = this.x), 256 * (E = Math.pow(2, L) - E - 1), L), F = jv(256 * (x + 1), 256 * (E + 1), L), R[0] + "," + R[1] + "," + F[0] + "," + F[1]);
          var x, E, L, R, F;
          const j = function(q, Y, ee) {
            let se, de = "";
            for (let we = q; we > 0; we--) se = 1 << we - 1, de += (Y & se ? 1 : 0) + (ee & se ? 2 : 0);
            return de;
          }(this.z, this.x, this.y);
          return a[(this.x + this.y) % a.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(p === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, d > 1 ? "@2x" : "").replace(/{quadkey}/g, j).replace(/{bbox-epsg-3857}/g, v);
        }
        isChildOf(a) {
          const d = this.z - a.z;
          return d > 0 && a.x === this.x >> d && a.y === this.y >> d;
        }
        getTilePoint(a) {
          const d = Math.pow(2, this.z);
          return new T((a.x * d - this.x) * kr, (a.y * d - this.y) * kr);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Gv {
        constructor(a, d) {
          this.wrap = a, this.canonical = d, this.key = Bf(a, d.z, d.z, d.x, d.y);
        }
      }
      class ca {
        constructor(a, d, p, v, x) {
          if (a < p) throw new Error(`overscaledZ should be >= z; overscaledZ = ${a}; z = ${p}`);
          this.overscaledZ = a, this.wrap = d, this.canonical = new P0(p, +v, +x), this.key = Bf(d, a, p, v, x);
        }
        clone() {
          return new ca(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(a) {
          return this.overscaledZ === a.overscaledZ && this.wrap === a.wrap && this.canonical.equals(a.canonical);
        }
        scaledTo(a) {
          if (a > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${a}; overscaledZ = ${this.overscaledZ}`);
          const d = this.canonical.z - a;
          return a > this.canonical.z ? new ca(a, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ca(a, this.wrap, a, this.canonical.x >> d, this.canonical.y >> d);
        }
        calculateScaledKey(a, d) {
          if (a > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${a}; overscaledZ = ${this.overscaledZ}`);
          const p = this.canonical.z - a;
          return a > this.canonical.z ? Bf(this.wrap * +d, a, this.canonical.z, this.canonical.x, this.canonical.y) : Bf(this.wrap * +d, a, a, this.canonical.x >> p, this.canonical.y >> p);
        }
        isChildOf(a) {
          if (a.wrap !== this.wrap) return !1;
          const d = this.canonical.z - a.canonical.z;
          return a.overscaledZ === 0 || a.overscaledZ < this.overscaledZ && a.canonical.x === this.canonical.x >> d && a.canonical.y === this.canonical.y >> d;
        }
        children(a) {
          if (this.overscaledZ >= a) return [new ca(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const d = this.canonical.z + 1, p = 2 * this.canonical.x, v = 2 * this.canonical.y;
          return [new ca(d, this.wrap, d, p, v), new ca(d, this.wrap, d, p + 1, v), new ca(d, this.wrap, d, p, v + 1), new ca(d, this.wrap, d, p + 1, v + 1)];
        }
        isLessThan(a) {
          return this.wrap < a.wrap || !(this.wrap > a.wrap) && (this.overscaledZ < a.overscaledZ || !(this.overscaledZ > a.overscaledZ) && (this.canonical.x < a.canonical.x || !(this.canonical.x > a.canonical.x) && this.canonical.y < a.canonical.y));
        }
        wrapped() {
          return new ca(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(a) {
          return new ca(this.overscaledZ, a, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Gv(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(a) {
          return this.canonical.getTilePoint(new Mf(a.x - this.wrap, a.y));
        }
      }
      function Bf(u, a, d, p, v) {
        (u *= 2) < 0 && (u = -1 * u - 1);
        const x = 1 << d;
        return (x * x * u + x * v + p).toString(36) + d.toString(36) + a.toString(36);
      }
      qt("CanonicalTileID", P0), qt("OverscaledTileID", ca, { omit: ["posMatrix"] });
      class Vv {
        constructor(a, d, p) {
          let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, E = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1, L = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
          if (this.uid = a, d.height !== d.width) throw new RangeError("DEM tiles must be square");
          if (p && !["mapbox", "terrarium", "custom"].includes(p)) return void Te(`"${p}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = d.height;
          const R = this.dim = d.height - 2;
          switch (this.data = new Uint32Array(d.data.buffer), p) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = v, this.greenFactor = x, this.blueFactor = E, this.baseShift = L;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let F = 0; F < R; F++) this.data[this._idx(-1, F)] = this.data[this._idx(0, F)], this.data[this._idx(R, F)] = this.data[this._idx(R - 1, F)], this.data[this._idx(F, -1)] = this.data[this._idx(F, 0)], this.data[this._idx(F, R)] = this.data[this._idx(F, R - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(R, -1)] = this.data[this._idx(R - 1, 0)], this.data[this._idx(-1, R)] = this.data[this._idx(0, R - 1)], this.data[this._idx(R, R)] = this.data[this._idx(R - 1, R - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let F = 0; F < R; F++) for (let j = 0; j < R; j++) {
            const q = this.get(F, j);
            q > this.max && (this.max = q), q < this.min && (this.min = q);
          }
        }
        get(a, d) {
          const p = new Uint8Array(this.data.buffer), v = 4 * this._idx(a, d);
          return this.unpack(p[v], p[v + 1], p[v + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(a, d) {
          if (a < -1 || a >= this.dim + 1 || d < -1 || d >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (d + 1) * this.stride + (a + 1);
        }
        unpack(a, d, p) {
          return a * this.redFactor + d * this.greenFactor + p * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new la({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(a, d, p) {
          if (this.dim !== a.dim) throw new Error("dem dimension mismatch");
          let v = d * this.dim, x = d * this.dim + this.dim, E = p * this.dim, L = p * this.dim + this.dim;
          switch (d) {
            case -1:
              v = x - 1;
              break;
            case 1:
              x = v + 1;
          }
          switch (p) {
            case -1:
              E = L - 1;
              break;
            case 1:
              L = E + 1;
          }
          const R = -d * this.dim, F = -p * this.dim;
          for (let j = E; j < L; j++) for (let q = v; q < x; q++) this.data[this._idx(q, j)] = a.data[this._idx(q + R, j + F)];
        }
      }
      qt("DEMData", Vv);
      class qv {
        constructor(a) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let d = 0; d < a.length; d++) {
            const p = a[d];
            this._stringToNumber[p] = d, this._numberToString[d] = p;
          }
        }
        encode(a) {
          return this._stringToNumber[a];
        }
        decode(a) {
          if (a >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${a} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[a];
        }
      }
      class Hv {
        constructor(a, d, p, v, x) {
          this.type = "Feature", this._vectorTileFeature = a, a._z = d, a._x = p, a._y = v, this.properties = a.properties, this.id = x;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(a) {
          this._geometry = a;
        }
        toJSON() {
          const a = { geometry: this.geometry };
          for (const d in this) d !== "_geometry" && d !== "_vectorTileFeature" && (a[d] = this[d]);
          return a;
        }
      }
      class Wv {
        constructor(a, d) {
          this.tileID = a, this.x = a.canonical.x, this.y = a.canonical.y, this.z = a.canonical.z, this.grid = new Zl(kr, 16, 0), this.grid3D = new Zl(kr, 16, 0), this.featureIndexArray = new or(), this.promoteId = d;
        }
        insert(a, d, p, v, x, E) {
          const L = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(p, v, x);
          const R = E ? this.grid3D : this.grid;
          for (let F = 0; F < d.length; F++) {
            const j = d[F], q = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let Y = 0; Y < j.length; Y++) {
              const ee = j[Y];
              q[0] = Math.min(q[0], ee.x), q[1] = Math.min(q[1], ee.y), q[2] = Math.max(q[2], ee.x), q[3] = Math.max(q[3], ee.y);
            }
            q[0] < kr && q[1] < kr && q[2] >= 0 && q[3] >= 0 && R.insert(L, q[0], q[1], q[2], q[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new wu.VectorTile(new _0(this.rawTileData)).layers, this.sourceLayerCoder = new qv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(a, d, p, v) {
          this.loadVTLayers();
          const x = a.params || {}, E = kr / a.tileSize / a.scale, L = _o(x.filter), R = a.queryGeometry, F = a.queryPadding * E, j = $v(R), q = this.grid.query(j.minX - F, j.minY - F, j.maxX + F, j.maxY + F), Y = $v(a.cameraQueryGeometry), ee = this.grid3D.query(Y.minX - F, Y.minY - F, Y.maxX + F, Y.maxY + F, (we, Me, $e, Ne) => function(Ve, it, At, Gt, mn) {
            for (const kt of Ve) if (it <= kt.x && At <= kt.y && Gt >= kt.x && mn >= kt.y) return !0;
            const Ut = [new T(it, At), new T(it, mn), new T(Gt, mn), new T(Gt, At)];
            if (Ve.length > 2) {
              for (const kt of Ut) if (ic(Ve, kt)) return !0;
            }
            for (let kt = 0; kt < Ve.length - 1; kt++) if (yf(Ve[kt], Ve[kt + 1], Ut)) return !0;
            return !1;
          }(a.cameraQueryGeometry, we - F, Me - F, $e + F, Ne + F));
          for (const we of ee) q.push(we);
          q.sort(qC);
          const se = {};
          let de;
          for (let we = 0; we < q.length; we++) {
            const Me = q[we];
            if (Me === de) continue;
            de = Me;
            const $e = this.featureIndexArray.get(Me);
            let Ne = null;
            this.loadMatchingFeature(se, $e.bucketIndex, $e.sourceLayerIndex, $e.featureIndex, L, x.layers, x.availableImages, d, p, v, (Ve, it, At) => (Ne || (Ne = Gc(Ve)), it.queryIntersectsFeature(R, Ve, At, Ne, this.z, a.transform, E, a.pixelPosMatrix)));
          }
          return se;
        }
        loadMatchingFeature(a, d, p, v, x, E, L, R, F, j, q) {
          const Y = this.bucketLayerIDs[d];
          if (E && !function(we, Me) {
            for (let $e = 0; $e < we.length; $e++) if (Me.indexOf(we[$e]) >= 0) return !0;
            return !1;
          }(E, Y)) return;
          const ee = this.sourceLayerCoder.decode(p), se = this.vtLayers[ee].feature(v);
          if (x.needGeometry) {
            const we = nc(se, !0);
            if (!x.filter(new vr(this.tileID.overscaledZ), we, this.tileID.canonical)) return;
          } else if (!x.filter(new vr(this.tileID.overscaledZ), se)) return;
          const de = this.getId(se, ee);
          for (let we = 0; we < Y.length; we++) {
            const Me = Y[we];
            if (E && E.indexOf(Me) < 0) continue;
            const $e = R[Me];
            if (!$e) continue;
            let Ne = {};
            de && j && (Ne = j.getState($e.sourceLayer || "_geojsonTileLayer", de));
            const Ve = Le({}, F[Me]);
            Ve.paint = Xv(Ve.paint, $e.paint, se, Ne, L), Ve.layout = Xv(Ve.layout, $e.layout, se, Ne, L);
            const it = !q || q(se, $e, Ne);
            if (!it) continue;
            const At = new Hv(se, this.z, this.x, this.y, de);
            At.layer = Ve;
            let Gt = a[Me];
            Gt === void 0 && (Gt = a[Me] = []), Gt.push({ featureIndex: v, feature: At, intersectionZ: it });
          }
        }
        lookupSymbolFeatures(a, d, p, v, x, E, L, R) {
          const F = {};
          this.loadVTLayers();
          const j = _o(x);
          for (const q of a) this.loadMatchingFeature(F, p, v, q, j, E, L, R, d);
          return F;
        }
        hasLayer(a) {
          for (const d of this.bucketLayerIDs) for (const p of d) if (a === p) return !0;
          return !1;
        }
        getId(a, d) {
          let p = a.id;
          return this.promoteId && (p = a.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[d]], typeof p == "boolean" && (p = Number(p))), p;
        }
      }
      function Xv(u, a, d, p, v) {
        return Ge(u, (x, E) => {
          const L = a instanceof Da ? a.get(E) : null;
          return L && L.evaluate ? L.evaluate(d, p, v) : L;
        });
      }
      function $v(u) {
        let a = 1 / 0, d = 1 / 0, p = -1 / 0, v = -1 / 0;
        for (const x of u) a = Math.min(a, x.x), d = Math.min(d, x.y), p = Math.max(p, x.x), v = Math.max(v, x.y);
        return { minX: a, minY: d, maxX: p, maxY: v };
      }
      function qC(u, a) {
        return a - u;
      }
      function Zv(u, a, d, p, v) {
        const x = [];
        for (let E = 0; E < u.length; E++) {
          const L = u[E];
          let R;
          for (let F = 0; F < L.length - 1; F++) {
            let j = L[F], q = L[F + 1];
            j.x < a && q.x < a || (j.x < a ? j = new T(a, j.y + (a - j.x) / (q.x - j.x) * (q.y - j.y))._round() : q.x < a && (q = new T(a, j.y + (a - j.x) / (q.x - j.x) * (q.y - j.y))._round()), j.y < d && q.y < d || (j.y < d ? j = new T(j.x + (d - j.y) / (q.y - j.y) * (q.x - j.x), d)._round() : q.y < d && (q = new T(j.x + (d - j.y) / (q.y - j.y) * (q.x - j.x), d)._round()), j.x >= p && q.x >= p || (j.x >= p ? j = new T(p, j.y + (p - j.x) / (q.x - j.x) * (q.y - j.y))._round() : q.x >= p && (q = new T(p, j.y + (p - j.x) / (q.x - j.x) * (q.y - j.y))._round()), j.y >= v && q.y >= v || (j.y >= v ? j = new T(j.x + (v - j.y) / (q.y - j.y) * (q.x - j.x), v)._round() : q.y >= v && (q = new T(j.x + (v - j.y) / (q.y - j.y) * (q.x - j.x), v)._round()), R && j.equals(R[R.length - 1]) || (R = [j], x.push(R)), R.push(q)))));
          }
        }
        return x;
      }
      qt("FeatureIndex", Wv, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Tu extends T {
        constructor(a, d, p, v) {
          super(a, d), this.angle = p, v !== void 0 && (this.segment = v);
        }
        clone() {
          return new Tu(this.x, this.y, this.angle, this.segment);
        }
      }
      function Jv(u, a, d, p, v) {
        if (a.segment === void 0 || d === 0) return !0;
        let x = a, E = a.segment + 1, L = 0;
        for (; L > -d / 2; ) {
          if (E--, E < 0) return !1;
          L -= u[E].dist(x), x = u[E];
        }
        L += u[E].dist(u[E + 1]), E++;
        const R = [];
        let F = 0;
        for (; L < d / 2; ) {
          const j = u[E], q = u[E + 1];
          if (!q) return !1;
          let Y = u[E - 1].angleTo(j) - j.angleTo(q);
          for (Y = Math.abs((Y + 3 * Math.PI) % (2 * Math.PI) - Math.PI), R.push({ distance: L, angleDelta: Y }), F += Y; L - R[0].distance > p; ) F -= R.shift().angleDelta;
          if (F > v) return !1;
          E++, L += j.dist(q);
        }
        return !0;
      }
      function Yv(u) {
        let a = 0;
        for (let d = 0; d < u.length - 1; d++) a += u[d].dist(u[d + 1]);
        return a;
      }
      function Kv(u, a, d) {
        return u ? 0.6 * a * d : 0;
      }
      function Qv(u, a) {
        return Math.max(u ? u.right - u.left : 0, a ? a.right - a.left : 0);
      }
      function HC(u, a, d, p, v, x) {
        const E = Kv(d, v, x), L = Qv(d, p) * x;
        let R = 0;
        const F = Yv(u) / 2;
        for (let j = 0; j < u.length - 1; j++) {
          const q = u[j], Y = u[j + 1], ee = q.dist(Y);
          if (R + ee > F) {
            const se = (F - R) / ee, de = Ii.number(q.x, Y.x, se), we = Ii.number(q.y, Y.y, se), Me = new Tu(de, we, Y.angleTo(q), j);
            return Me._round(), !E || Jv(u, Me, L, E, a) ? Me : void 0;
          }
          R += ee;
        }
      }
      function WC(u, a, d, p, v, x, E, L, R) {
        const F = Kv(p, x, E), j = Qv(p, v), q = j * E, Y = u[0].x === 0 || u[0].x === R || u[0].y === 0 || u[0].y === R;
        return a - q < a / 4 && (a = q + a / 4), e2(u, Y ? a / 2 * L % a : (j / 2 + 2 * x) * E * L % a, a, F, d, q, Y, !1, R);
      }
      function e2(u, a, d, p, v, x, E, L, R) {
        const F = x / 2, j = Yv(u);
        let q = 0, Y = a - d, ee = [];
        for (let se = 0; se < u.length - 1; se++) {
          const de = u[se], we = u[se + 1], Me = de.dist(we), $e = we.angleTo(de);
          for (; Y + d < q + Me; ) {
            Y += d;
            const Ne = (Y - q) / Me, Ve = Ii.number(de.x, we.x, Ne), it = Ii.number(de.y, we.y, Ne);
            if (Ve >= 0 && Ve < R && it >= 0 && it < R && Y - F >= 0 && Y + F <= j) {
              const At = new Tu(Ve, it, $e, se);
              At._round(), p && !Jv(u, At, x, p, v) || ee.push(At);
            }
          }
          q += Me;
        }
        return L || ee.length || E || (ee = e2(u, q / 2, d, p, v, x, E, !0, R)), ee;
      }
      qt("Anchor", Tu);
      const hd = xo;
      function t2(u, a, d, p) {
        const v = [], x = u.image, E = x.pixelRatio, L = x.paddedRect.w - 2 * hd, R = x.paddedRect.h - 2 * hd;
        let F = { x1: u.left, y1: u.top, x2: u.right, y2: u.bottom };
        const j = x.stretchX || [[0, L]], q = x.stretchY || [[0, R]], Y = (pt, on) => pt + on[1] - on[0], ee = j.reduce(Y, 0), se = q.reduce(Y, 0), de = L - ee, we = R - se;
        let Me = 0, $e = ee, Ne = 0, Ve = se, it = 0, At = de, Gt = 0, mn = we;
        if (x.content && p) {
          const pt = x.content, on = pt[2] - pt[0], tn = pt[3] - pt[1];
          (x.textFitWidth || x.textFitHeight) && (F = Iv(u)), Me = og(j, 0, pt[0]), Ne = og(q, 0, pt[1]), $e = og(j, pt[0], pt[2]), Ve = og(q, pt[1], pt[3]), it = pt[0] - Me, Gt = pt[1] - Ne, At = on - $e, mn = tn - Ve;
        }
        const Ut = F.x1, kt = F.y1, sn = F.x2 - Ut, $t = F.y2 - kt, Ht = (pt, on, tn, Tn) => {
          const Ir = ag(pt.stretch - Me, $e, sn, Ut), wr = lg(pt.fixed - it, At, pt.stretch, ee), Gi = ag(on.stretch - Ne, Ve, $t, kt), ja = lg(on.fixed - Gt, mn, on.stretch, se), ds = ag(tn.stretch - Me, $e, sn, Ut), Vi = lg(tn.fixed - it, At, tn.stretch, ee), Hs = ag(Tn.stretch - Ne, Ve, $t, kt), Ws = lg(Tn.fixed - Gt, mn, Tn.stretch, se), Xs = new T(Ir, Gi), di = new T(ds, Gi), qi = new T(ds, Hs), Ls = new T(Ir, Hs), fs = new T(wr / E, ja / E), $s = new T(Vi / E, Ws / E), ps = a * Math.PI / 180;
          if (ps) {
            const ar = Math.sin(ps), Nr = Math.cos(ps), Vr = [Nr, -ar, ar, Nr];
            Xs._matMult(Vr), di._matMult(Vr), Ls._matMult(Vr), qi._matMult(Vr);
          }
          const ua = pt.stretch + pt.fixed, wo = on.stretch + on.fixed;
          return { tl: Xs, tr: di, bl: Ls, br: qi, tex: { x: x.paddedRect.x + hd + ua, y: x.paddedRect.y + hd + wo, w: tn.stretch + tn.fixed - ua, h: Tn.stretch + Tn.fixed - wo }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: fs, pixelOffsetBR: $s, minFontScaleX: At / E / sn, minFontScaleY: mn / E / $t, isSDF: d };
        };
        if (p && (x.stretchX || x.stretchY)) {
          const pt = n2(j, de, ee), on = n2(q, we, se);
          for (let tn = 0; tn < pt.length - 1; tn++) {
            const Tn = pt[tn], Ir = pt[tn + 1];
            for (let wr = 0; wr < on.length - 1; wr++) v.push(Ht(Tn, on[wr], Ir, on[wr + 1]));
          }
        } else v.push(Ht({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: L + 1 }, { fixed: 0, stretch: R + 1 }));
        return v;
      }
      function og(u, a, d) {
        let p = 0;
        for (const v of u) p += Math.max(a, Math.min(d, v[1])) - Math.max(a, Math.min(d, v[0]));
        return p;
      }
      function n2(u, a, d) {
        const p = [{ fixed: -hd, stretch: 0 }];
        for (const [v, x] of u) {
          const E = p[p.length - 1];
          p.push({ fixed: v - E.stretch, stretch: E.stretch }), p.push({ fixed: v - E.stretch, stretch: E.stretch + (x - v) });
        }
        return p.push({ fixed: a + hd, stretch: d }), p;
      }
      function ag(u, a, d, p) {
        return u / a * d + p;
      }
      function lg(u, a, d, p) {
        return u - a * d / p;
      }
      class cg {
        constructor(a, d, p, v, x, E, L, R, F, j) {
          var q;
          if (this.boxStartIndex = a.length, F) {
            let Y = E.top, ee = E.bottom;
            const se = E.collisionPadding;
            se && (Y -= se[1], ee += se[3]);
            let de = ee - Y;
            de > 0 && (de = Math.max(10, de), this.circleDiameter = de);
          } else {
            const Y = !((q = E.image) === null || q === void 0) && q.content && (E.image.textFitWidth || E.image.textFitHeight) ? Iv(E) : { x1: E.left, y1: E.top, x2: E.right, y2: E.bottom };
            Y.y1 = Y.y1 * L - R[0], Y.y2 = Y.y2 * L + R[2], Y.x1 = Y.x1 * L - R[3], Y.x2 = Y.x2 * L + R[1];
            const ee = E.collisionPadding;
            if (ee && (Y.x1 -= ee[0] * L, Y.y1 -= ee[1] * L, Y.x2 += ee[2] * L, Y.y2 += ee[3] * L), j) {
              const se = new T(Y.x1, Y.y1), de = new T(Y.x2, Y.y1), we = new T(Y.x1, Y.y2), Me = new T(Y.x2, Y.y2), $e = j * Math.PI / 180;
              se._rotate($e), de._rotate($e), we._rotate($e), Me._rotate($e), Y.x1 = Math.min(se.x, de.x, we.x, Me.x), Y.x2 = Math.max(se.x, de.x, we.x, Me.x), Y.y1 = Math.min(se.y, de.y, we.y, Me.y), Y.y2 = Math.max(se.y, de.y, we.y, Me.y);
            }
            a.emplaceBack(d.x, d.y, Y.x1, Y.y1, Y.x2, Y.y2, p, v, x);
          }
          this.boxEndIndex = a.length;
        }
      }
      class XC {
        constructor() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (p, v) => p < v ? -1 : p > v ? 1 : 0;
          if (this.data = a, this.length = this.data.length, this.compare = d, this.length > 0) for (let p = (this.length >> 1) - 1; p >= 0; p--) this._down(p);
        }
        push(a) {
          this.data.push(a), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const a = this.data[0], d = this.data.pop();
          return --this.length > 0 && (this.data[0] = d, this._down(0)), a;
        }
        peek() {
          return this.data[0];
        }
        _up(a) {
          const { data: d, compare: p } = this, v = d[a];
          for (; a > 0; ) {
            const x = a - 1 >> 1, E = d[x];
            if (p(v, E) >= 0) break;
            d[a] = E, a = x;
          }
          d[a] = v;
        }
        _down(a) {
          const { data: d, compare: p } = this, v = this.length >> 1, x = d[a];
          for (; a < v; ) {
            let E = 1 + (a << 1);
            const L = E + 1;
            if (L < this.length && p(d[L], d[E]) < 0 && (E = L), p(d[E], x) >= 0) break;
            d[a] = d[E], a = E;
          }
          d[a] = x;
        }
      }
      function $C(u) {
        let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, p = 1 / 0, v = 1 / 0, x = -1 / 0, E = -1 / 0;
        const L = u[0];
        for (let ee = 0; ee < L.length; ee++) {
          const se = L[ee];
          (!ee || se.x < p) && (p = se.x), (!ee || se.y < v) && (v = se.y), (!ee || se.x > x) && (x = se.x), (!ee || se.y > E) && (E = se.y);
        }
        const R = Math.min(x - p, E - v);
        let F = R / 2;
        const j = new XC([], ZC);
        if (R === 0) return new T(p, v);
        for (let ee = p; ee < x; ee += R) for (let se = v; se < E; se += R) j.push(new dd(ee + F, se + F, F, u));
        let q = function(ee) {
          let se = 0, de = 0, we = 0;
          const Me = ee[0];
          for (let $e = 0, Ne = Me.length, Ve = Ne - 1; $e < Ne; Ve = $e++) {
            const it = Me[$e], At = Me[Ve], Gt = it.x * At.y - At.x * it.y;
            de += (it.x + At.x) * Gt, we += (it.y + At.y) * Gt, se += 3 * Gt;
          }
          return new dd(de / se, we / se, 0, ee);
        }(u), Y = j.length;
        for (; j.length; ) {
          const ee = j.pop();
          (ee.d > q.d || !q.d) && (q = ee, d && console.log("found best %d after %d probes", Math.round(1e4 * ee.d) / 1e4, Y)), ee.max - q.d <= a || (F = ee.h / 2, j.push(new dd(ee.p.x - F, ee.p.y - F, F, u)), j.push(new dd(ee.p.x + F, ee.p.y - F, F, u)), j.push(new dd(ee.p.x - F, ee.p.y + F, F, u)), j.push(new dd(ee.p.x + F, ee.p.y + F, F, u)), Y += 4);
        }
        return d && (console.log(`num probes: ${Y}`), console.log(`best distance: ${q.d}`)), q.p;
      }
      function ZC(u, a) {
        return a.max - u.max;
      }
      function dd(u, a, d, p) {
        this.p = new T(u, a), this.h = d, this.d = function(v, x) {
          let E = !1, L = 1 / 0;
          for (let R = 0; R < x.length; R++) {
            const F = x[R];
            for (let j = 0, q = F.length, Y = q - 1; j < q; Y = j++) {
              const ee = F[j], se = F[Y];
              ee.y > v.y != se.y > v.y && v.x < (se.x - ee.x) * (v.y - ee.y) / (se.y - ee.y) + ee.x && (E = !E), L = Math.min(L, _f(v, ee, se));
            }
          }
          return (E ? 1 : -1) * Math.sqrt(L);
        }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
      }
      var hs;
      c.aq = void 0, (hs = c.aq || (c.aq = {}))[hs.center = 1] = "center", hs[hs.left = 2] = "left", hs[hs.right = 3] = "right", hs[hs.top = 4] = "top", hs[hs.bottom = 5] = "bottom", hs[hs["top-left"] = 6] = "top-left", hs[hs["top-right"] = 7] = "top-right", hs[hs["bottom-left"] = 8] = "bottom-left", hs[hs["bottom-right"] = 9] = "bottom-right";
      const Cu = 7, L0 = Number.POSITIVE_INFINITY;
      function r2(u, a) {
        return a[1] !== L0 ? function(d, p, v) {
          let x = 0, E = 0;
          switch (p = Math.abs(p), v = Math.abs(v), d) {
            case "top-right":
            case "top-left":
            case "top":
              E = v - Cu;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              E = -v + Cu;
          }
          switch (d) {
            case "top-right":
            case "bottom-right":
            case "right":
              x = -p;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              x = p;
          }
          return [x, E];
        }(u, a[0], a[1]) : function(d, p) {
          let v = 0, x = 0;
          p < 0 && (p = 0);
          const E = p / Math.SQRT2;
          switch (d) {
            case "top-right":
            case "top-left":
              x = E - Cu;
              break;
            case "bottom-right":
            case "bottom-left":
              x = -E + Cu;
              break;
            case "bottom":
              x = -p + Cu;
              break;
            case "top":
              x = p - Cu;
          }
          switch (d) {
            case "top-right":
            case "bottom-right":
              v = -E;
              break;
            case "top-left":
            case "bottom-left":
              v = E;
              break;
            case "left":
              v = p;
              break;
            case "right":
              v = -p;
          }
          return [v, x];
        }(u, a[0]);
      }
      function i2(u, a, d) {
        var p;
        const v = u.layout, x = (p = v.get("text-variable-anchor-offset")) === null || p === void 0 ? void 0 : p.evaluate(a, {}, d);
        if (x) {
          const L = x.values, R = [];
          for (let F = 0; F < L.length; F += 2) {
            const j = R[F] = L[F], q = L[F + 1].map((Y) => Y * Mi);
            j.startsWith("top") ? q[1] -= Cu : j.startsWith("bottom") && (q[1] += Cu), R[F + 1] = q;
          }
          return new Mr(R);
        }
        const E = v.get("text-variable-anchor");
        if (E) {
          let L;
          L = u._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [v.get("text-radial-offset").evaluate(a, {}, d) * Mi, L0] : v.get("text-offset").evaluate(a, {}, d).map((F) => F * Mi);
          const R = [];
          for (const F of E) R.push(F, r2(F, L));
          return new Mr(R);
        }
        return null;
      }
      function M0(u) {
        switch (u) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function JC(u, a, d, p, v, x, E, L, R, F, j) {
        let q = x.textMaxSize.evaluate(a, {});
        q === void 0 && (q = E);
        const Y = u.layers[0].layout, ee = Y.get("icon-offset").evaluate(a, {}, j), se = o2(d.horizontal), de = E / 24, we = u.tilePixelRatio * de, Me = u.tilePixelRatio * q / 24, $e = u.tilePixelRatio * L, Ne = u.tilePixelRatio * Y.get("symbol-spacing"), Ve = Y.get("text-padding") * u.tilePixelRatio, it = function(pt, on, tn) {
          let Tn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
          const Ir = pt.get("icon-padding").evaluate(on, {}, tn), wr = Ir && Ir.values;
          return [wr[0] * Tn, wr[1] * Tn, wr[2] * Tn, wr[3] * Tn];
        }(Y, a, j, u.tilePixelRatio), At = Y.get("text-max-angle") / 180 * Math.PI, Gt = Y.get("text-rotation-alignment") !== "viewport" && Y.get("symbol-placement") !== "point", mn = Y.get("icon-rotation-alignment") === "map" && Y.get("symbol-placement") !== "point", Ut = Y.get("symbol-placement"), kt = Ne / 2, sn = Y.get("icon-text-fit");
        let $t;
        p && sn !== "none" && (u.allowVerticalPlacement && d.vertical && ($t = Pv(p, d.vertical, sn, Y.get("icon-text-fit-padding"), ee, de)), se && (p = Pv(p, se, sn, Y.get("icon-text-fit-padding"), ee, de)));
        const Ht = (pt, on) => {
          on.x < 0 || on.x >= kr || on.y < 0 || on.y >= kr || function(tn, Tn, Ir, wr, Gi, ja, ds, Vi, Hs, Ws, Xs, di, qi, Ls, fs, $s, ps, ua, wo, ar, Nr, Vr, zo, ai, fd) {
            const oc = tn.addToLineVertexArray(Tn, Ir);
            let ac, Ga, ha, rs, Hc = 0, Df = 0, u2 = 0, h2 = 0, z0 = -1, U0 = -1;
            const Wc = {};
            let d2 = vu("");
            if (tn.allowVerticalPlacement && wr.vertical) {
              const Ms = Vi.layout.get("text-rotate").evaluate(Nr, {}, ai) + 90;
              ha = new cg(Hs, Tn, Ws, Xs, di, wr.vertical, qi, Ls, fs, Ms), ds && (rs = new cg(Hs, Tn, Ws, Xs, di, ds, ps, ua, fs, Ms));
            }
            if (Gi) {
              const Ms = Vi.layout.get("icon-rotate").evaluate(Nr, {}), da = Vi.layout.get("icon-text-fit") !== "none", gh = t2(Gi, Ms, zo, da), fl = ds ? t2(ds, Ms, zo, da) : void 0;
              Ga = new cg(Hs, Tn, Ws, Xs, di, Gi, ps, ua, !1, Ms), Hc = 4 * gh.length;
              const mh = tn.iconSizeData;
              let lc = null;
              mh.kind === "source" ? (lc = [sc * Vi.layout.get("icon-size").evaluate(Nr, {})], lc[0] > Su && Te(`${tn.layerIds[0]}: Value for "icon-size" is >= ${Lf}. Reduce your "icon-size".`)) : mh.kind === "composite" && (lc = [sc * Vr.compositeIconSizes[0].evaluate(Nr, {}, ai), sc * Vr.compositeIconSizes[1].evaluate(Nr, {}, ai)], (lc[0] > Su || lc[1] > Su) && Te(`${tn.layerIds[0]}: Value for "icon-size" is >= ${Lf}. Reduce your "icon-size".`)), tn.addSymbols(tn.icon, gh, lc, ar, wo, Nr, c.ah.none, Tn, oc.lineStartIndex, oc.lineLength, -1, ai), z0 = tn.icon.placedSymbolArray.length - 1, fl && (Df = 4 * fl.length, tn.addSymbols(tn.icon, fl, lc, ar, wo, Nr, c.ah.vertical, Tn, oc.lineStartIndex, oc.lineLength, -1, ai), U0 = tn.icon.placedSymbolArray.length - 1);
            }
            const f2 = Object.keys(wr.horizontal);
            for (const Ms of f2) {
              const da = wr.horizontal[Ms];
              if (!ac) {
                d2 = vu(da.text);
                const fl = Vi.layout.get("text-rotate").evaluate(Nr, {}, ai);
                ac = new cg(Hs, Tn, Ws, Xs, di, da, qi, Ls, fs, fl);
              }
              const gh = da.positionedLines.length === 1;
              if (u2 += s2(tn, Tn, da, ja, Vi, fs, Nr, $s, oc, wr.vertical ? c.ah.horizontal : c.ah.horizontalOnly, gh ? f2 : [Ms], Wc, z0, Vr, ai), gh) break;
            }
            wr.vertical && (h2 += s2(tn, Tn, wr.vertical, ja, Vi, fs, Nr, $s, oc, c.ah.vertical, ["vertical"], Wc, U0, Vr, ai));
            const QC = ac ? ac.boxStartIndex : tn.collisionBoxArray.length, eI = ac ? ac.boxEndIndex : tn.collisionBoxArray.length, tI = ha ? ha.boxStartIndex : tn.collisionBoxArray.length, nI = ha ? ha.boxEndIndex : tn.collisionBoxArray.length, rI = Ga ? Ga.boxStartIndex : tn.collisionBoxArray.length, iI = Ga ? Ga.boxEndIndex : tn.collisionBoxArray.length, sI = rs ? rs.boxStartIndex : tn.collisionBoxArray.length, oI = rs ? rs.boxEndIndex : tn.collisionBoxArray.length;
            let dl = -1;
            const hg = (Ms, da) => Ms && Ms.circleDiameter ? Math.max(Ms.circleDiameter, da) : da;
            dl = hg(ac, dl), dl = hg(ha, dl), dl = hg(Ga, dl), dl = hg(rs, dl);
            const p2 = dl > -1 ? 1 : 0;
            p2 && (dl *= fd / Mi), tn.glyphOffsetArray.length >= ud.MAX_GLYPHS && Te("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Nr.sortKey !== void 0 && tn.addToSortKeyRanges(tn.symbolInstances.length, Nr.sortKey);
            const aI = i2(Vi, Nr, ai), [lI, cI] = function(Ms, da) {
              const gh = Ms.length, fl = da == null ? void 0 : da.values;
              if ((fl == null ? void 0 : fl.length) > 0) for (let mh = 0; mh < fl.length; mh += 2) {
                const lc = fl[mh + 1];
                Ms.emplaceBack(c.aq[fl[mh]], lc[0], lc[1]);
              }
              return [gh, Ms.length];
            }(tn.textAnchorOffsets, aI);
            tn.symbolInstances.emplaceBack(Tn.x, Tn.y, Wc.right >= 0 ? Wc.right : -1, Wc.center >= 0 ? Wc.center : -1, Wc.left >= 0 ? Wc.left : -1, Wc.vertical || -1, z0, U0, d2, QC, eI, tI, nI, rI, iI, sI, oI, Ws, u2, h2, Hc, Df, p2, 0, qi, dl, lI, cI);
          }(u, on, pt, d, p, v, $t, u.layers[0], u.collisionBoxArray, a.index, a.sourceLayerIndex, u.index, we, [Ve, Ve, Ve, Ve], Gt, R, $e, it, mn, ee, a, x, F, j, E);
        };
        if (Ut === "line") for (const pt of Zv(a.geometry, 0, 0, kr, kr)) {
          const on = WC(pt, Ne, At, d.vertical || se, p, 24, Me, u.overscaling, kr);
          for (const tn of on) se && YC(u, se.text, kt, tn) || Ht(pt, tn);
        }
        else if (Ut === "line-center") {
          for (const pt of a.geometry) if (pt.length > 1) {
            const on = HC(pt, At, d.vertical || se, p, 24, Me);
            on && Ht(pt, on);
          }
        } else if (a.type === "Polygon") for (const pt of Io(a.geometry, 0)) {
          const on = $C(pt, 16);
          Ht(pt[0], new Tu(on.x, on.y, 0));
        }
        else if (a.type === "LineString") for (const pt of a.geometry) Ht(pt, new Tu(pt[0].x, pt[0].y, 0));
        else if (a.type === "Point") for (const pt of a.geometry) for (const on of pt) Ht([on], new Tu(on.x, on.y, 0));
      }
      function s2(u, a, d, p, v, x, E, L, R, F, j, q, Y, ee, se) {
        const de = function($e, Ne, Ve, it, At, Gt, mn, Ut) {
          const kt = it.layout.get("text-rotate").evaluate(Gt, {}) * Math.PI / 180, sn = [];
          for (const $t of Ne.positionedLines) for (const Ht of $t.positionedGlyphs) {
            if (!Ht.rect) continue;
            const pt = Ht.rect || {};
            let on = xv + 1, tn = !0, Tn = 1, Ir = 0;
            const wr = (At || Ut) && Ht.vertical, Gi = Ht.metrics.advance * Ht.scale / 2;
            if (Ut && Ne.verticalizable && (Ir = $t.lineOffset / 2 - (Ht.imageName ? -(Mi - Ht.metrics.width * Ht.scale) / 2 : (Ht.scale - 1) * Mi)), Ht.imageName) {
              const ar = mn[Ht.imageName];
              tn = ar.sdf, Tn = ar.pixelRatio, on = xo / Tn;
            }
            const ja = At ? [Ht.x + Gi, Ht.y] : [0, 0];
            let ds = At ? [0, 0] : [Ht.x + Gi + Ve[0], Ht.y + Ve[1] - Ir], Vi = [0, 0];
            wr && (Vi = ds, ds = [0, 0]);
            const Hs = Ht.metrics.isDoubleResolution ? 2 : 1, Ws = (Ht.metrics.left - on) * Ht.scale - Gi + ds[0], Xs = (-Ht.metrics.top - on) * Ht.scale + ds[1], di = Ws + pt.w / Hs * Ht.scale / Tn, qi = Xs + pt.h / Hs * Ht.scale / Tn, Ls = new T(Ws, Xs), fs = new T(di, Xs), $s = new T(Ws, qi), ps = new T(di, qi);
            if (wr) {
              const ar = new T(-Gi, Gi - If), Nr = -Math.PI / 2, Vr = Mi / 2 - Gi, zo = new T(5 - If - Vr, -(Ht.imageName ? Vr : 0)), ai = new T(...Vi);
              Ls._rotateAround(Nr, ar)._add(zo)._add(ai), fs._rotateAround(Nr, ar)._add(zo)._add(ai), $s._rotateAround(Nr, ar)._add(zo)._add(ai), ps._rotateAround(Nr, ar)._add(zo)._add(ai);
            }
            if (kt) {
              const ar = Math.sin(kt), Nr = Math.cos(kt), Vr = [Nr, -ar, ar, Nr];
              Ls._matMult(Vr), fs._matMult(Vr), $s._matMult(Vr), ps._matMult(Vr);
            }
            const ua = new T(0, 0), wo = new T(0, 0);
            sn.push({ tl: Ls, tr: fs, bl: $s, br: ps, tex: pt, writingMode: Ne.writingMode, glyphOffset: ja, sectionIndex: Ht.sectionIndex, isSDF: tn, pixelOffsetTL: ua, pixelOffsetBR: wo, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return sn;
        }(0, d, L, v, x, E, p, u.allowVerticalPlacement), we = u.textSizeData;
        let Me = null;
        we.kind === "source" ? (Me = [sc * v.layout.get("text-size").evaluate(E, {})], Me[0] > Su && Te(`${u.layerIds[0]}: Value for "text-size" is >= ${Lf}. Reduce your "text-size".`)) : we.kind === "composite" && (Me = [sc * ee.compositeTextSizes[0].evaluate(E, {}, se), sc * ee.compositeTextSizes[1].evaluate(E, {}, se)], (Me[0] > Su || Me[1] > Su) && Te(`${u.layerIds[0]}: Value for "text-size" is >= ${Lf}. Reduce your "text-size".`)), u.addSymbols(u.text, de, Me, L, x, E, F, a, R.lineStartIndex, R.lineLength, Y, se);
        for (const $e of j) q[$e] = u.text.placedSymbolArray.length - 1;
        return 4 * de.length;
      }
      function o2(u) {
        for (const a in u) return u[a];
        return null;
      }
      function YC(u, a, d, p) {
        const v = u.compareText;
        if (a in v) {
          const x = v[a];
          for (let E = x.length - 1; E >= 0; E--) if (p.dist(x[E]) < d) return !0;
        } else v[a] = [];
        return v[a].push(p), !1;
      }
      const a2 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class B0 {
        static from(a) {
          if (!(a instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [d, p] = new Uint8Array(a, 0, 2);
          if (d !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const v = p >> 4;
          if (v !== 1) throw new Error(`Got v${v} data when expected v1.`);
          const x = a2[15 & p];
          if (!x) throw new Error("Unrecognized array type.");
          const [E] = new Uint16Array(a, 2, 1), [L] = new Uint32Array(a, 4, 1);
          return new B0(L, E, x, a);
        }
        constructor(a) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, v = arguments.length > 3 ? arguments[3] : void 0;
          if (isNaN(a) || a < 0) throw new Error(`Unpexpected numItems value: ${a}.`);
          this.numItems = +a, this.nodeSize = Math.min(Math.max(+d, 2), 65535), this.ArrayType = p, this.IndexArrayType = a < 65536 ? Uint16Array : Uint32Array;
          const x = a2.indexOf(this.ArrayType), E = 2 * a * this.ArrayType.BYTES_PER_ELEMENT, L = a * this.IndexArrayType.BYTES_PER_ELEMENT, R = (8 - L % 8) % 8;
          if (x < 0) throw new Error(`Unexpected typed array class: ${p}.`);
          v && v instanceof ArrayBuffer ? (this.data = v, this.ids = new this.IndexArrayType(this.data, 8, a), this.coords = new this.ArrayType(this.data, 8 + L + R, 2 * a), this._pos = 2 * a, this._finished = !0) : (this.data = new ArrayBuffer(8 + E + L + R), this.ids = new this.IndexArrayType(this.data, 8, a), this.coords = new this.ArrayType(this.data, 8 + L + R, 2 * a), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + x]), new Uint16Array(this.data, 2, 1)[0] = d, new Uint32Array(this.data, 4, 1)[0] = a);
        }
        add(a, d) {
          const p = this._pos >> 1;
          return this.ids[p] = p, this.coords[this._pos++] = a, this.coords[this._pos++] = d, p;
        }
        finish() {
          const a = this._pos >> 1;
          if (a !== this.numItems) throw new Error(`Added ${a} items when expected ${this.numItems}.`);
          return R0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(a, d, p, v) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: x, coords: E, nodeSize: L } = this, R = [0, x.length - 1, 0], F = [];
          for (; R.length; ) {
            const j = R.pop() || 0, q = R.pop() || 0, Y = R.pop() || 0;
            if (q - Y <= L) {
              for (let we = Y; we <= q; we++) {
                const Me = E[2 * we], $e = E[2 * we + 1];
                Me >= a && Me <= p && $e >= d && $e <= v && F.push(x[we]);
              }
              continue;
            }
            const ee = Y + q >> 1, se = E[2 * ee], de = E[2 * ee + 1];
            se >= a && se <= p && de >= d && de <= v && F.push(x[ee]), (j === 0 ? a <= se : d <= de) && (R.push(Y), R.push(ee - 1), R.push(1 - j)), (j === 0 ? p >= se : v >= de) && (R.push(ee + 1), R.push(q), R.push(1 - j));
          }
          return F;
        }
        within(a, d, p) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: v, coords: x, nodeSize: E } = this, L = [0, v.length - 1, 0], R = [], F = p * p;
          for (; L.length; ) {
            const j = L.pop() || 0, q = L.pop() || 0, Y = L.pop() || 0;
            if (q - Y <= E) {
              for (let we = Y; we <= q; we++) c2(x[2 * we], x[2 * we + 1], a, d) <= F && R.push(v[we]);
              continue;
            }
            const ee = Y + q >> 1, se = x[2 * ee], de = x[2 * ee + 1];
            c2(se, de, a, d) <= F && R.push(v[ee]), (j === 0 ? a - p <= se : d - p <= de) && (L.push(Y), L.push(ee - 1), L.push(1 - j)), (j === 0 ? a + p >= se : d + p >= de) && (L.push(ee + 1), L.push(q), L.push(1 - j));
          }
          return R;
        }
      }
      function R0(u, a, d, p, v, x) {
        if (v - p <= d) return;
        const E = p + v >> 1;
        l2(u, a, E, p, v, x), R0(u, a, d, p, E - 1, 1 - x), R0(u, a, d, E + 1, v, 1 - x);
      }
      function l2(u, a, d, p, v, x) {
        for (; v > p; ) {
          if (v - p > 600) {
            const F = v - p + 1, j = d - p + 1, q = Math.log(F), Y = 0.5 * Math.exp(2 * q / 3), ee = 0.5 * Math.sqrt(q * Y * (F - Y) / F) * (j - F / 2 < 0 ? -1 : 1);
            l2(u, a, d, Math.max(p, Math.floor(d - j * Y / F + ee)), Math.min(v, Math.floor(d + (F - j) * Y / F + ee)), x);
          }
          const E = a[2 * d + x];
          let L = p, R = v;
          for (Rf(u, a, p, d), a[2 * v + x] > E && Rf(u, a, p, v); L < R; ) {
            for (Rf(u, a, L, R), L++, R--; a[2 * L + x] < E; ) L++;
            for (; a[2 * R + x] > E; ) R--;
          }
          a[2 * p + x] === E ? Rf(u, a, p, R) : (R++, Rf(u, a, R, v)), R <= d && (p = R + 1), d <= R && (v = R - 1);
        }
      }
      function Rf(u, a, d, p) {
        O0(u, d, p), O0(a, 2 * d, 2 * p), O0(a, 2 * d + 1, 2 * p + 1);
      }
      function O0(u, a, d) {
        const p = u[a];
        u[a] = u[d], u[d] = p;
      }
      function c2(u, a, d, p) {
        const v = u - d, x = a - p;
        return v * v + x * x;
      }
      var D0;
      c.bg = void 0, (D0 = c.bg || (c.bg = {})).create = "create", D0.load = "load", D0.fullLoad = "fullLoad";
      let ug = null, Of = [];
      const F0 = 1e3 / 60, k0 = "loadTime", N0 = "fullLoadTime", KC = { mark(u) {
        performance.mark(u);
      }, frame(u) {
        const a = u;
        ug != null && Of.push(a - ug), ug = a;
      }, clearMetrics() {
        ug = null, Of = [], performance.clearMeasures(k0), performance.clearMeasures(N0);
        for (const u in c.bg) performance.clearMarks(c.bg[u]);
      }, getPerformanceMetrics() {
        performance.measure(k0, c.bg.create, c.bg.load), performance.measure(N0, c.bg.create, c.bg.fullLoad);
        const u = performance.getEntriesByName(k0)[0].duration, a = performance.getEntriesByName(N0)[0].duration, d = Of.length, p = 1 / (Of.reduce((x, E) => x + E, 0) / d / 1e3), v = Of.filter((x) => x > F0).reduce((x, E) => x + (E - F0) / F0, 0);
        return { loadTime: u, fullLoadTime: a, fps: p, percentDroppedFrames: v / (d + v) * 100, totalFrames: d };
      } };
      c.$ = class extends z {
      }, c.A = id, c.B = uf, c.C = function(u) {
        if (rt == null) {
          const a = u.navigator ? u.navigator.userAgent : null;
          rt = !!u.safari || !(!a || !(/\b(iPad|iPhone|iPod)\b/.test(a) || a.match("Safari") && !a.match("Chrome")));
        }
        return rt;
      }, c.D = Yt, c.E = at, c.F = class {
        constructor(u, a) {
          this.target = u, this.mapId = a, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new VC(() => this.process()), this.subscription = function(d, p, v, x) {
            return d.addEventListener(p, v, !1), { unsubscribe: () => {
              d.removeEventListener(p, v, !1);
            } };
          }(this.target, "message", (d) => this.receive(d)), this.globalScope = et(self) ? u : window;
        }
        registerMessageHandler(u, a) {
          this.messageHandlers[u] = a;
        }
        sendAsync(u, a) {
          return new Promise((d, p) => {
            const v = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[v] = { resolve: d, reject: p }, a && a.signal.addEventListener("abort", () => {
              delete this.resolveRejects[v];
              const L = { id: v, type: "<cancel>", origin: location.origin, targetMapId: u.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(L);
            }, { once: !0 });
            const x = [], E = Object.assign(Object.assign({}, u), { id: v, sourceMapId: this.mapId, origin: location.origin, data: Jl(u.data, x) });
            this.target.postMessage(E, { transfer: x });
          });
        }
        receive(u) {
          const a = u.data, d = a.id;
          if (!(a.origin !== "file://" && location.origin !== "file://" && a.origin !== "resource://android" && location.origin !== "resource://android" && a.origin !== location.origin || a.targetMapId && this.mapId !== a.targetMapId)) {
            if (a.type === "<cancel>") {
              delete this.tasks[d];
              const p = this.abortControllers[d];
              return delete this.abortControllers[d], void (p && p.abort());
            }
            if (et(self) || a.mustQueue) return this.tasks[d] = a, this.taskQueue.push(d), void this.invoker.trigger();
            this.processTask(d, a);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const u = this.taskQueue.shift(), a = this.tasks[u];
          delete this.tasks[u], this.taskQueue.length > 0 && this.invoker.trigger(), a && this.processTask(u, a);
        }
        processTask(u, a) {
          return l(this, void 0, void 0, function* () {
            if (a.type === "<response>") {
              const v = this.resolveRejects[u];
              return delete this.resolveRejects[u], v ? void (a.error ? v.reject(ll(a.error)) : v.resolve(ll(a.data))) : void 0;
            }
            if (!this.messageHandlers[a.type]) return void this.completeTask(u, new Error(`Could not find a registered handler for ${a.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const d = ll(a.data), p = new AbortController();
            this.abortControllers[u] = p;
            try {
              const v = yield this.messageHandlers[a.type](a.sourceMapId, d, p);
              this.completeTask(u, null, v);
            } catch (v) {
              this.completeTask(u, v);
            }
          });
        }
        completeTask(u, a, d) {
          const p = [];
          delete this.abortControllers[u];
          const v = { id: u, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: a ? Jl(a) : null, data: Jl(d, p) };
          this.target.postMessage(v, { transfer: p });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, c.G = qe, c.H = function() {
        var u = new id(16);
        return id != Float32Array && (u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0), u[0] = 1, u[5] = 1, u[10] = 1, u[15] = 1, u;
      }, c.I = b0, c.J = function(u, a, d) {
        var p, v, x, E, L, R, F, j, q, Y, ee, se, de = d[0], we = d[1], Me = d[2];
        return a === u ? (u[12] = a[0] * de + a[4] * we + a[8] * Me + a[12], u[13] = a[1] * de + a[5] * we + a[9] * Me + a[13], u[14] = a[2] * de + a[6] * we + a[10] * Me + a[14], u[15] = a[3] * de + a[7] * we + a[11] * Me + a[15]) : (v = a[1], x = a[2], E = a[3], L = a[4], R = a[5], F = a[6], j = a[7], q = a[8], Y = a[9], ee = a[10], se = a[11], u[0] = p = a[0], u[1] = v, u[2] = x, u[3] = E, u[4] = L, u[5] = R, u[6] = F, u[7] = j, u[8] = q, u[9] = Y, u[10] = ee, u[11] = se, u[12] = p * de + L * we + q * Me + a[12], u[13] = v * de + R * we + Y * Me + a[13], u[14] = x * de + F * we + ee * Me + a[14], u[15] = E * de + j * we + se * Me + a[15]), u;
      }, c.K = function(u, a, d) {
        var p = d[0], v = d[1], x = d[2];
        return u[0] = a[0] * p, u[1] = a[1] * p, u[2] = a[2] * p, u[3] = a[3] * p, u[4] = a[4] * v, u[5] = a[5] * v, u[6] = a[6] * v, u[7] = a[7] * v, u[8] = a[8] * x, u[9] = a[9] * x, u[10] = a[10] * x, u[11] = a[11] * x, u[12] = a[12], u[13] = a[13], u[14] = a[14], u[15] = a[15], u;
      }, c.L = Vb, c.M = function(u, a) {
        const d = {};
        for (let p = 0; p < a.length; p++) {
          const v = a[p];
          v in u && (d[v] = u[v]);
        }
        return d;
      }, c.N = Eu, c.O = Nv, c.P = T, c.Q = zv, c.R = la, c.S = ca, c.T = bu, c.U = H, c.V = $, c.W = ct, c.X = kr, c.Y = S, c.Z = Mf, c._ = l, c.a = Ce, c.a$ = function(u, a) {
        var d = u[0], p = u[1], v = u[2], x = u[3], E = u[4], L = u[5], R = u[6], F = u[7], j = u[8], q = u[9], Y = u[10], ee = u[11], se = u[12], de = u[13], we = u[14], Me = u[15], $e = a[0], Ne = a[1], Ve = a[2], it = a[3], At = a[4], Gt = a[5], mn = a[6], Ut = a[7], kt = a[8], sn = a[9], $t = a[10], Ht = a[11], pt = a[12], on = a[13], tn = a[14], Tn = a[15];
        return Math.abs(d - $e) <= qs * Math.max(1, Math.abs(d), Math.abs($e)) && Math.abs(p - Ne) <= qs * Math.max(1, Math.abs(p), Math.abs(Ne)) && Math.abs(v - Ve) <= qs * Math.max(1, Math.abs(v), Math.abs(Ve)) && Math.abs(x - it) <= qs * Math.max(1, Math.abs(x), Math.abs(it)) && Math.abs(E - At) <= qs * Math.max(1, Math.abs(E), Math.abs(At)) && Math.abs(L - Gt) <= qs * Math.max(1, Math.abs(L), Math.abs(Gt)) && Math.abs(R - mn) <= qs * Math.max(1, Math.abs(R), Math.abs(mn)) && Math.abs(F - Ut) <= qs * Math.max(1, Math.abs(F), Math.abs(Ut)) && Math.abs(j - kt) <= qs * Math.max(1, Math.abs(j), Math.abs(kt)) && Math.abs(q - sn) <= qs * Math.max(1, Math.abs(q), Math.abs(sn)) && Math.abs(Y - $t) <= qs * Math.max(1, Math.abs(Y), Math.abs($t)) && Math.abs(ee - Ht) <= qs * Math.max(1, Math.abs(ee), Math.abs(Ht)) && Math.abs(se - pt) <= qs * Math.max(1, Math.abs(se), Math.abs(pt)) && Math.abs(de - on) <= qs * Math.max(1, Math.abs(de), Math.abs(on)) && Math.abs(we - tn) <= qs * Math.max(1, Math.abs(we), Math.abs(tn)) && Math.abs(Me - Tn) <= qs * Math.max(1, Math.abs(Me), Math.abs(Tn));
      }, c.a0 = Hn, c.a1 = P0, c.a2 = gt, c.a3 = (u) => {
        const a = window.document.createElement("video");
        return a.muted = !0, new Promise((d) => {
          a.onloadstart = () => {
            d(a);
          };
          for (const p of u) {
            const v = window.document.createElement("source");
            St(p) || (a.crossOrigin = "Anonymous"), v.src = p, a.appendChild(v);
          }
        });
      }, c.a4 = function() {
        return _e++;
      }, c.a5 = It, c.a6 = ud, c.a7 = _o, c.a8 = nc, c.a9 = Hv, c.aA = function(u) {
        if (u.type === "custom") return new GC(u);
        switch (u.type) {
          case "background":
            return new zC(u);
          case "circle":
            return new T3(u);
          case "fill":
            return new V3(u);
          case "fill-extrusion":
            return new iC(u);
          case "heatmap":
            return new I3(u);
          case "hillshade":
            return new L3(u);
          case "line":
            return new dC(u);
          case "raster":
            return new jC(u);
          case "symbol":
            return new sg(u);
        }
      }, c.aB = oe, c.aC = function(u, a) {
        if (!u) return [{ command: "setStyle", args: [a] }];
        let d = [];
        try {
          if (!dt(u.version, a.version)) return [{ command: "setStyle", args: [a] }];
          dt(u.center, a.center) || d.push({ command: "setCenter", args: [a.center] }), dt(u.zoom, a.zoom) || d.push({ command: "setZoom", args: [a.zoom] }), dt(u.bearing, a.bearing) || d.push({ command: "setBearing", args: [a.bearing] }), dt(u.pitch, a.pitch) || d.push({ command: "setPitch", args: [a.pitch] }), dt(u.sprite, a.sprite) || d.push({ command: "setSprite", args: [a.sprite] }), dt(u.glyphs, a.glyphs) || d.push({ command: "setGlyphs", args: [a.glyphs] }), dt(u.transition, a.transition) || d.push({ command: "setTransition", args: [a.transition] }), dt(u.light, a.light) || d.push({ command: "setLight", args: [a.light] }), dt(u.terrain, a.terrain) || d.push({ command: "setTerrain", args: [a.terrain] }), dt(u.sky, a.sky) || d.push({ command: "setSky", args: [a.sky] }), dt(u.projection, a.projection) || d.push({ command: "setProjection", args: [a.projection] });
          const p = {}, v = [];
          (function(E, L, R, F) {
            let j;
            for (j in L = L || {}, E = E || {}) Object.prototype.hasOwnProperty.call(E, j) && (Object.prototype.hasOwnProperty.call(L, j) || Ft(j, R, F));
            for (j in L) Object.prototype.hasOwnProperty.call(L, j) && (Object.prototype.hasOwnProperty.call(E, j) ? dt(E[j], L[j]) || (E[j].type === "geojson" && L[j].type === "geojson" && Sn(E, L, j) ? Et(R, { command: "setGeoJSONSourceData", args: [j, L[j].data] }) : nn(j, L, R, F)) : Bt(j, L, R));
          })(u.sources, a.sources, v, p);
          const x = [];
          u.layers && u.layers.forEach((E) => {
            "source" in E && p[E.source] ? d.push({ command: "removeLayer", args: [E.id] }) : x.push(E);
          }), d = d.concat(v), function(E, L, R) {
            L = L || [];
            const F = (E = E || []).map(On), j = L.map(On), q = E.reduce(Un, {}), Y = L.reduce(Un, {}), ee = F.slice(), se = /* @__PURE__ */ Object.create(null);
            let de, we, Me, $e, Ne;
            for (let Ve = 0, it = 0; Ve < F.length; Ve++) de = F[Ve], Object.prototype.hasOwnProperty.call(Y, de) ? it++ : (Et(R, { command: "removeLayer", args: [de] }), ee.splice(ee.indexOf(de, it), 1));
            for (let Ve = 0, it = 0; Ve < j.length; Ve++) de = j[j.length - 1 - Ve], ee[ee.length - 1 - Ve] !== de && (Object.prototype.hasOwnProperty.call(q, de) ? (Et(R, { command: "removeLayer", args: [de] }), ee.splice(ee.lastIndexOf(de, ee.length - it), 1)) : it++, $e = ee[ee.length - Ve], Et(R, { command: "addLayer", args: [Y[de], $e] }), ee.splice(ee.length - Ve, 0, de), se[de] = !0);
            for (let Ve = 0; Ve < j.length; Ve++) if (de = j[Ve], we = q[de], Me = Y[de], !se[de] && !dt(we, Me)) if (dt(we.source, Me.source) && dt(we["source-layer"], Me["source-layer"]) && dt(we.type, Me.type)) {
              for (Ne in vn(we.layout, Me.layout, R, de, null, "setLayoutProperty"), vn(we.paint, Me.paint, R, de, null, "setPaintProperty"), dt(we.filter, Me.filter) || Et(R, { command: "setFilter", args: [de, Me.filter] }), dt(we.minzoom, Me.minzoom) && dt(we.maxzoom, Me.maxzoom) || Et(R, { command: "setLayerZoomRange", args: [de, Me.minzoom, Me.maxzoom] }), we) Object.prototype.hasOwnProperty.call(we, Ne) && Ne !== "layout" && Ne !== "paint" && Ne !== "filter" && Ne !== "metadata" && Ne !== "minzoom" && Ne !== "maxzoom" && (Ne.indexOf("paint.") === 0 ? vn(we[Ne], Me[Ne], R, de, Ne.slice(6), "setPaintProperty") : dt(we[Ne], Me[Ne]) || Et(R, { command: "setLayerProperty", args: [de, Ne, Me[Ne]] }));
              for (Ne in Me) Object.prototype.hasOwnProperty.call(Me, Ne) && !Object.prototype.hasOwnProperty.call(we, Ne) && Ne !== "layout" && Ne !== "paint" && Ne !== "filter" && Ne !== "metadata" && Ne !== "minzoom" && Ne !== "maxzoom" && (Ne.indexOf("paint.") === 0 ? vn(we[Ne], Me[Ne], R, de, Ne.slice(6), "setPaintProperty") : dt(we[Ne], Me[Ne]) || Et(R, { command: "setLayerProperty", args: [de, Ne, Me[Ne]] }));
            } else Et(R, { command: "removeLayer", args: [de] }), $e = ee[ee.lastIndexOf(de) + 1], Et(R, { command: "addLayer", args: [Me, $e] });
          }(x, a.layers, d);
        } catch (p) {
          console.warn("Unable to compute style diff:", p), d = [{ command: "setStyle", args: [a] }];
        }
        return d;
      }, c.aD = function(u) {
        const a = [], d = u.id;
        return d === void 0 && a.push({ message: `layers.${d}: missing required property "id"` }), u.render === void 0 && a.push({ message: `layers.${d}: missing required method "render"` }), u.renderingMode && u.renderingMode !== "2d" && u.renderingMode !== "3d" && a.push({ message: `layers.${d}: property "renderingMode" must be either "2d" or "3d"` }), a;
      }, c.aE = function u(a, d) {
        if (Array.isArray(a)) {
          if (!Array.isArray(d) || a.length !== d.length) return !1;
          for (let p = 0; p < a.length; p++) if (!u(a[p], d[p])) return !1;
          return !0;
        }
        if (typeof a == "object" && a !== null && d !== null) {
          if (typeof d != "object" || Object.keys(a).length !== Object.keys(d).length) return !1;
          for (const p in a) if (!u(a[p], d[p])) return !1;
          return !0;
        }
        return a === d;
      }, c.aF = Ge, c.aG = ke, c.aH = class extends ec {
        constructor(u, a) {
          super(u, a), this.current = 0;
        }
        set(u) {
          this.current !== u && (this.current = u, this.gl.uniform1i(this.location, u));
        }
      }, c.aI = ch, c.aJ = class extends ec {
        constructor(u, a) {
          super(u, a), this.current = hh;
        }
        set(u) {
          if (u[12] !== this.current[12] || u[0] !== this.current[0]) return this.current = u, void this.gl.uniformMatrix4fv(this.location, !1, u);
          for (let a = 1; a < 16; a++) if (u[a] !== this.current[a]) {
            this.current = u, this.gl.uniformMatrix4fv(this.location, !1, u);
            break;
          }
        }
      }, c.aK = uh, c.aL = Kh, c.aM = Jn, c.aN = class extends ec {
        constructor(u, a) {
          super(u, a), this.current = [0, 0, 0];
        }
        set(u) {
          u[0] === this.current[0] && u[1] === this.current[1] && u[2] === this.current[2] || (this.current = u, this.gl.uniform3f(this.location, u[0], u[1], u[2]));
        }
      }, c.aO = class extends ec {
        constructor(u, a) {
          super(u, a), this.current = [0, 0];
        }
        set(u) {
          u[0] === this.current[0] && u[1] === this.current[1] || (this.current = u, this.gl.uniform2f(this.location, u[0], u[1]));
        }
      }, c.aP = function(u, a, d, p, v, x, E) {
        var L = 1 / (a - d), R = 1 / (p - v), F = 1 / (x - E);
        return u[0] = -2 * L, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = -2 * R, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 2 * F, u[11] = 0, u[12] = (a + d) * L, u[13] = (v + p) * R, u[14] = (E + x) * F, u[15] = 1, u;
      }, c.aQ = E3, c.aR = class extends ve {
      }, c.aS = mC, c.aT = class extends Pe {
      }, c.aU = a0, c.aV = function(u) {
        return u <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(u) / Math.LN2));
      }, c.aW = $b, c.aX = Gr, c.aY = Ui, c.aZ = class extends wt {
      }, c.a_ = function(u, a) {
        return u[0] === a[0] && u[1] === a[1] && u[2] === a[2] && u[3] === a[3] && u[4] === a[4] && u[5] === a[5] && u[6] === a[6] && u[7] === a[7] && u[8] === a[8] && u[9] === a[9] && u[10] === a[10] && u[11] === a[11] && u[12] === a[12] && u[13] === a[13] && u[14] === a[14] && u[15] === a[15];
      }, c.aa = function(u) {
        const a = {};
        if (u.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (d, p, v, x) => {
          const E = v || x;
          return a[p] = !E || E.toLowerCase(), "";
        }), a["max-age"]) {
          const d = parseInt(a["max-age"], 10);
          isNaN(d) ? delete a["max-age"] : a["max-age"] = d;
        }
        return a;
      }, c.ab = function(u, a) {
        const d = [];
        for (const p in u) p in a || d.push(p);
        return d;
      }, c.ac = Se, c.ad = function(u, a, d) {
        var p = Math.sin(d), v = Math.cos(d), x = a[0], E = a[1], L = a[2], R = a[3], F = a[4], j = a[5], q = a[6], Y = a[7];
        return a !== u && (u[8] = a[8], u[9] = a[9], u[10] = a[10], u[11] = a[11], u[12] = a[12], u[13] = a[13], u[14] = a[14], u[15] = a[15]), u[0] = x * v + F * p, u[1] = E * v + j * p, u[2] = L * v + q * p, u[3] = R * v + Y * p, u[4] = F * v - x * p, u[5] = j * v - E * p, u[6] = q * v - L * p, u[7] = Y * v - R * p, u;
      }, c.ae = function(u) {
        var a = new id(16);
        return a[0] = u[0], a[1] = u[1], a[2] = u[2], a[3] = u[3], a[4] = u[4], a[5] = u[5], a[6] = u[6], a[7] = u[7], a[8] = u[8], a[9] = u[9], a[10] = u[10], a[11] = u[11], a[12] = u[12], a[13] = u[13], a[14] = u[14], a[15] = u[15], a;
      }, c.af = Jp, c.ag = function(u, a) {
        let d = 0, p = 0;
        if (u.kind === "constant") p = u.layoutSize;
        else if (u.kind !== "source") {
          const { interpolationType: v, minZoom: x, maxZoom: E } = u, L = v ? Se(dn.interpolationFactor(v, a, x, E), 0, 1) : 0;
          u.kind === "camera" ? p = Ii.number(u.minSize, u.maxSize, L) : d = L;
        }
        return { uSizeT: d, uSize: p };
      }, c.ai = function(u, a, d) {
        let { uSize: p, uSizeT: v } = a, { lowerSize: x, upperSize: E } = d;
        return u.kind === "source" ? x / sc : u.kind === "composite" ? Ii.number(x / sc, E / sc, v) : p;
      }, c.aj = A0, c.ak = function(u, a, d, p) {
        const v = a.y - u.y, x = a.x - u.x, E = p.y - d.y, L = p.x - d.x, R = E * x - L * v;
        if (R === 0) return null;
        const F = (L * (u.y - d.y) - E * (u.x - d.x)) / R;
        return new T(u.x + F * x, u.y + F * v);
      }, c.al = Zv, c.am = td, c.an = i0, c.ao = function(u) {
        let a = 1 / 0, d = 1 / 0, p = -1 / 0, v = -1 / 0;
        for (const x of u) a = Math.min(a, x.x), d = Math.min(d, x.y), p = Math.max(p, x.x), v = Math.max(v, x.y);
        return [a, d, p, v];
      }, c.ap = Mi, c.ar = w0, c.as = function(u, a) {
        var d = a[0], p = a[1], v = a[2], x = a[3], E = a[4], L = a[5], R = a[6], F = a[7], j = a[8], q = a[9], Y = a[10], ee = a[11], se = a[12], de = a[13], we = a[14], Me = a[15], $e = d * L - p * E, Ne = d * R - v * E, Ve = d * F - x * E, it = p * R - v * L, At = p * F - x * L, Gt = v * F - x * R, mn = j * de - q * se, Ut = j * we - Y * se, kt = j * Me - ee * se, sn = q * we - Y * de, $t = q * Me - ee * de, Ht = Y * Me - ee * we, pt = $e * Ht - Ne * $t + Ve * sn + it * kt - At * Ut + Gt * mn;
        return pt ? (u[0] = (L * Ht - R * $t + F * sn) * (pt = 1 / pt), u[1] = (v * $t - p * Ht - x * sn) * pt, u[2] = (de * Gt - we * At + Me * it) * pt, u[3] = (Y * At - q * Gt - ee * it) * pt, u[4] = (R * kt - E * Ht - F * Ut) * pt, u[5] = (d * Ht - v * kt + x * Ut) * pt, u[6] = (we * Ve - se * Gt - Me * Ne) * pt, u[7] = (j * Gt - Y * Ve + ee * Ne) * pt, u[8] = (E * $t - L * kt + F * mn) * pt, u[9] = (p * kt - d * $t - x * mn) * pt, u[10] = (se * At - de * Ve + Me * $e) * pt, u[11] = (q * Ve - j * At - ee * $e) * pt, u[12] = (L * Ut - E * sn - R * mn) * pt, u[13] = (d * sn - p * Ut + v * mn) * pt, u[14] = (de * Ne - se * it - we * $e) * pt, u[15] = (j * it - q * Ne + Y * $e) * pt, u) : null;
      }, c.at = M0, c.au = x0, c.av = B0, c.aw = function() {
        const u = {}, a = ne.$version;
        for (const d in ne.$root) {
          const p = ne.$root[d];
          if (p.required) {
            let v = null;
            v = d === "version" ? a : p.type === "array" ? [] : {}, v != null && (u[d] = v);
          }
        }
        return u;
      }, c.ax = Fo, c.ay = Ye, c.az = function(u) {
        u = u.slice();
        const a = /* @__PURE__ */ Object.create(null);
        for (let d = 0; d < u.length; d++) a[u[d].id] = u[d];
        for (let d = 0; d < u.length; d++) "ref" in u[d] && (u[d] = Qt(u[d], a[u[d].ref]));
        return u;
      }, c.b = st, c.b0 = function(u, a) {
        return u[0] = a[0], u[1] = a[1], u[2] = a[2], u[3] = a[3], u[4] = a[4], u[5] = a[5], u[6] = a[6], u[7] = a[7], u[8] = a[8], u[9] = a[9], u[10] = a[10], u[11] = a[11], u[12] = a[12], u[13] = a[13], u[14] = a[14], u[15] = a[15], u;
      }, c.b1 = function(u, a, d) {
        return u[0] = a[0] * d[0], u[1] = a[1] * d[1], u[2] = a[2] * d[2], u[3] = a[3] * d[3], u;
      }, c.b2 = function(u, a) {
        return u[0] * a[0] + u[1] * a[1] + u[2] * a[2] + u[3] * a[3];
      }, c.b3 = Re, c.b4 = Gv, c.b5 = Uv, c.b6 = function(u, a, d, p, v) {
        var x, E = 1 / Math.tan(a / 2);
        return u[0] = E / d, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = E, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = -1, u[12] = 0, u[13] = 0, u[15] = 0, v != null && v !== 1 / 0 ? (u[10] = (v + p) * (x = 1 / (p - v)), u[14] = 2 * v * p * x) : (u[10] = -1, u[14] = -2 * p), u;
      }, c.b7 = function(u, a, d) {
        var p = Math.sin(d), v = Math.cos(d), x = a[4], E = a[5], L = a[6], R = a[7], F = a[8], j = a[9], q = a[10], Y = a[11];
        return a !== u && (u[0] = a[0], u[1] = a[1], u[2] = a[2], u[3] = a[3], u[12] = a[12], u[13] = a[13], u[14] = a[14], u[15] = a[15]), u[4] = x * v + F * p, u[5] = E * v + j * p, u[6] = L * v + q * p, u[7] = R * v + Y * p, u[8] = F * v - x * p, u[9] = j * v - E * p, u[10] = q * v - L * p, u[11] = Y * v - R * p, u;
      }, c.b8 = ie, c.b9 = ge, c.bA = pv, c.bB = function(u) {
        return u.message === re;
      }, c.bC = Ni, c.bD = Ts, c.ba = function(u) {
        return u * Math.PI / 180;
      }, c.bb = function(u, a) {
        const { x: d, y: p } = Mf.fromLngLat(a);
        return !(u < 0 || u > 25 || p < 0 || p >= 1 || d < 0 || d >= 1);
      }, c.bc = function(u, a) {
        return u[0] = a[0], u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = a[1], u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = a[2], u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }, c.bd = class extends D {
      }, c.be = C0, c.bf = KC, c.bh = He, c.bi = function(u, a) {
        Ce.REGISTERED_PROTOCOLS[u] = a;
      }, c.bj = function(u) {
        delete Ce.REGISTERED_PROTOCOLS[u];
      }, c.bk = function(u, a) {
        const d = {};
        for (let v = 0; v < u.length; v++) {
          const x = a && a[u[v].id] || Ku(u[v]);
          a && (a[u[v].id] = x);
          let E = d[x];
          E || (E = d[x] = []), E.push(u[v]);
        }
        const p = [];
        for (const v in d) p.push(d[v]);
        return p;
      }, c.bl = qt, c.bm = qv, c.bn = Wv, c.bo = Av, c.bp = function(u) {
        u.bucket.createArrays(), u.bucket.tilePixelRatio = kr / (512 * u.bucket.overscaling), u.bucket.compareText = {}, u.bucket.iconsNeedLinear = !1;
        const a = u.bucket.layers[0], d = a.layout, p = a._unevaluatedLayout._values, v = { layoutIconSize: p["icon-size"].possiblyEvaluate(new vr(u.bucket.zoom + 1), u.canonical), layoutTextSize: p["text-size"].possiblyEvaluate(new vr(u.bucket.zoom + 1), u.canonical), textMaxSize: p["text-size"].possiblyEvaluate(new vr(18)) };
        if (u.bucket.textSizeData.kind === "composite") {
          const { minZoom: F, maxZoom: j } = u.bucket.textSizeData;
          v.compositeTextSizes = [p["text-size"].possiblyEvaluate(new vr(F), u.canonical), p["text-size"].possiblyEvaluate(new vr(j), u.canonical)];
        }
        if (u.bucket.iconSizeData.kind === "composite") {
          const { minZoom: F, maxZoom: j } = u.bucket.iconSizeData;
          v.compositeIconSizes = [p["icon-size"].possiblyEvaluate(new vr(F), u.canonical), p["icon-size"].possiblyEvaluate(new vr(j), u.canonical)];
        }
        const x = d.get("text-line-height") * Mi, E = d.get("text-rotation-alignment") !== "viewport" && d.get("symbol-placement") !== "point", L = d.get("text-keep-upright"), R = d.get("text-size");
        for (const F of u.bucket.features) {
          const j = d.get("text-font").evaluate(F, {}, u.canonical).join(","), q = R.evaluate(F, {}, u.canonical), Y = v.layoutTextSize.evaluate(F, {}, u.canonical), ee = v.layoutIconSize.evaluate(F, {}, u.canonical), se = { horizontal: {}, vertical: void 0 }, de = F.text;
          let we, Me = [0, 0];
          if (de) {
            const Ve = de.toString(), it = d.get("text-letter-spacing").evaluate(F, {}, u.canonical) * Mi, At = hf(Ve) ? it : 0, Gt = d.get("text-anchor").evaluate(F, {}, u.canonical), mn = i2(a, F, u.canonical);
            if (!mn) {
              const $t = d.get("text-radial-offset").evaluate(F, {}, u.canonical);
              Me = $t ? r2(Gt, [$t * Mi, L0]) : d.get("text-offset").evaluate(F, {}, u.canonical).map((Ht) => Ht * Mi);
            }
            let Ut = E ? "center" : d.get("text-justify").evaluate(F, {}, u.canonical);
            const kt = d.get("symbol-placement") === "point" ? d.get("text-max-width").evaluate(F, {}, u.canonical) * Mi : 1 / 0, sn = () => {
              u.bucket.allowVerticalPlacement && sh(Ve) && (se.vertical = ng(de, u.glyphMap, u.glyphPositions, u.imagePositions, j, kt, x, Gt, "left", At, Me, c.ah.vertical, !0, Y, q));
            };
            if (!E && mn) {
              const $t = /* @__PURE__ */ new Set();
              if (Ut === "auto") for (let pt = 0; pt < mn.values.length; pt += 2) $t.add(M0(mn.values[pt]));
              else $t.add(Ut);
              let Ht = !1;
              for (const pt of $t) if (!se.horizontal[pt]) if (Ht) se.horizontal[pt] = se.horizontal[0];
              else {
                const on = ng(de, u.glyphMap, u.glyphPositions, u.imagePositions, j, kt, x, "center", pt, At, Me, c.ah.horizontal, !1, Y, q);
                on && (se.horizontal[pt] = on, Ht = on.positionedLines.length === 1);
              }
              sn();
            } else {
              Ut === "auto" && (Ut = M0(Gt));
              const $t = ng(de, u.glyphMap, u.glyphPositions, u.imagePositions, j, kt, x, Gt, Ut, At, Me, c.ah.horizontal, !1, Y, q);
              $t && (se.horizontal[Ut] = $t), sn(), sh(Ve) && E && L && (se.vertical = ng(de, u.glyphMap, u.glyphPositions, u.imagePositions, j, kt, x, Gt, Ut, At, Me, c.ah.vertical, !1, Y, q));
            }
          }
          let $e = !1;
          if (F.icon && F.icon.name) {
            const Ve = u.imageMap[F.icon.name];
            Ve && (we = OC(u.imagePositions[F.icon.name], d.get("icon-offset").evaluate(F, {}, u.canonical), d.get("icon-anchor").evaluate(F, {}, u.canonical)), $e = !!Ve.sdf, u.bucket.sdfIcons === void 0 ? u.bucket.sdfIcons = $e : u.bucket.sdfIcons !== $e && Te("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ve.pixelRatio !== u.bucket.pixelRatio || d.get("icon-rotate").constantOr(1) !== 0) && (u.bucket.iconsNeedLinear = !0));
          }
          const Ne = o2(se.horizontal) || se.vertical;
          u.bucket.iconsInText = !!Ne && Ne.iconsInText, (Ne || we) && JC(u.bucket, F, se, we, u.imageMap, v, Y, ee, Me, $e, u.canonical);
        }
        u.showCollisionBoxes && u.bucket.generateCollisionDebugBuffers();
      }, c.bq = g0, c.br = d0, c.bs = p0, c.bt = wu, c.bu = _0, c.bv = class {
        constructor(u) {
          this._marks = { start: [u.url, "start"].join("#"), end: [u.url, "end"].join("#"), measure: u.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let u = performance.getEntriesByName(this._marks.measure);
          return u.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), u = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), u;
        }
      }, c.bw = function(u, a, d, p, v) {
        return l(this, void 0, void 0, function* () {
          if ($()) try {
            return yield ct(u, a, d, p, v);
          } catch {
          }
          return function(x, E, L, R, F) {
            const j = x.width, q = x.height;
            ot && Mt || (ot = new OffscreenCanvas(j, q), Mt = ot.getContext("2d", { willReadFrequently: !0 })), ot.width = j, ot.height = q, Mt.drawImage(x, 0, 0, j, q);
            const Y = Mt.getImageData(E, L, R, F);
            return Mt.clearRect(0, 0, j, q), Y.data;
          }(u, a, d, p, v);
        });
      }, c.bx = Vv, c.by = _, c.bz = b, c.c = Ae, c.d = (u) => l(void 0, void 0, void 0, function* () {
        if (u.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const a = new Blob([new Uint8Array(u)], { type: "image/png" });
        try {
          return createImageBitmap(a);
        } catch (d) {
          throw new Error(`Could not load image because of ${d.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), c.e = Le, c.f = (u) => new Promise((a, d) => {
        const p = new Image();
        p.onload = () => {
          a(p), URL.revokeObjectURL(p.src), p.onload = null, window.requestAnimationFrame(() => {
            p.src = Je;
          });
        }, p.onerror = () => d(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const v = new Blob([new Uint8Array(u)], { type: "image/png" });
        p.src = u.byteLength ? URL.createObjectURL(v) : Je;
      }), c.g = Ue, c.h = (u, a) => Ze(Le(u, { type: "json" }), a), c.i = et, c.j = an, c.k = Nt, c.l = (u, a) => Ze(Le(u, { type: "arrayBuffer" }), a), c.m = Ze, c.n = function(u) {
        return new _0(u).readFields(CC, []);
      }, c.o = xf, c.p = wv, c.q = g, c.r = Oc, c.s = St, c.t = ih, c.u = ia, c.v = ne, c.w = Te, c.x = function(u) {
        let [a, d, p] = u;
        return d += 90, d *= Math.PI / 180, p *= Math.PI / 180, { x: a * Math.cos(d) * Math.sin(p), y: a * Math.sin(d) * Math.sin(p), z: a * Math.cos(p) };
      }, c.y = Ii, c.z = vr;
    }), i("worker", ["./shared"], function(c) {
      class l {
        constructor(J) {
          this.keyCache = {}, J && this.replace(J);
        }
        replace(J) {
          this._layerConfigs = {}, this._layers = {}, this.update(J, []);
        }
        update(J, K) {
          for (const ye of J) {
            this._layerConfigs[ye.id] = ye;
            const Fe = this._layers[ye.id] = c.aA(ye);
            Fe._featureFilter = c.a7(Fe.filter), this.keyCache[ye.id] && delete this.keyCache[ye.id];
          }
          for (const ye of K) delete this.keyCache[ye], delete this._layerConfigs[ye], delete this._layers[ye];
          this.familiesBySource = {};
          const ce = c.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const ye of ce) {
            const Fe = ye.map((We) => this._layers[We.id]), je = Fe[0];
            if (je.visibility === "none") continue;
            const Oe = je.source || "";
            let Ie = this.familiesBySource[Oe];
            Ie || (Ie = this.familiesBySource[Oe] = {});
            const tt = je.sourceLayer || "_geojsonTileLayer";
            let ut = Ie[tt];
            ut || (ut = Ie[tt] = []), ut.push(Fe);
          }
        }
      }
      class _ {
        constructor(J) {
          const K = {}, ce = [];
          for (const Oe in J) {
            const Ie = J[Oe], tt = K[Oe] = {};
            for (const ut in Ie) {
              const We = Ie[+ut];
              if (!We || We.bitmap.width === 0 || We.bitmap.height === 0) continue;
              const vt = { x: 0, y: 0, w: We.bitmap.width + 2, h: We.bitmap.height + 2 };
              ce.push(vt), tt[ut] = { rect: vt, metrics: We.metrics };
            }
          }
          const { w: ye, h: Fe } = c.p(ce), je = new c.o({ width: ye || 1, height: Fe || 1 });
          for (const Oe in J) {
            const Ie = J[Oe];
            for (const tt in Ie) {
              const ut = Ie[+tt];
              if (!ut || ut.bitmap.width === 0 || ut.bitmap.height === 0) continue;
              const We = K[Oe][tt].rect;
              c.o.copy(ut.bitmap, je, { x: 0, y: 0 }, { x: We.x + 1, y: We.y + 1 }, ut.bitmap);
            }
          }
          this.image = je, this.positions = K;
        }
      }
      c.bl("GlyphAtlas", _);
      class b {
        constructor(J) {
          this.tileID = new c.S(J.tileID.overscaledZ, J.tileID.wrap, J.tileID.canonical.z, J.tileID.canonical.x, J.tileID.canonical.y), this.uid = J.uid, this.zoom = J.zoom, this.pixelRatio = J.pixelRatio, this.tileSize = J.tileSize, this.source = J.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = J.showCollisionBoxes, this.collectResourceTiming = !!J.collectResourceTiming, this.returnDependencies = !!J.returnDependencies, this.promoteId = J.promoteId, this.inFlightDependencies = [];
        }
        parse(J, K, ce, ye) {
          return c._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = J, this.collisionBoxArray = new c.a5();
            const Fe = new c.bm(Object.keys(J.layers).sort()), je = new c.bn(this.tileID, this.promoteId);
            je.bucketLayerIDs = [];
            const Oe = {}, Ie = { featureIndex: je, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: ce }, tt = K.familiesBySource[this.source];
            for (const hn in tt) {
              const Fn = J.layers[hn];
              if (!Fn) continue;
              Fn.version === 1 && c.w(`Vector tile source "${this.source}" layer "${hn}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const er = Fe.encode(hn), fr = [];
              for (let Sr = 0; Sr < Fn.length; Sr++) {
                const Yr = Fn.feature(Sr), so = je.getId(Yr, hn);
                fr.push({ feature: Yr, id: so, index: Sr, sourceLayerIndex: er });
              }
              for (const Sr of tt[hn]) {
                const Yr = Sr[0];
                Yr.source !== this.source && c.w(`layer.source = ${Yr.source} does not equal this.source = ${this.source}`), Yr.minzoom && this.zoom < Math.floor(Yr.minzoom) || Yr.maxzoom && this.zoom >= Yr.maxzoom || Yr.visibility !== "none" && (w(Sr, this.zoom, ce), (Oe[Yr.id] = Yr.createBucket({ index: je.bucketLayerIDs.length, layers: Sr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: er, sourceID: this.source })).populate(fr, Ie, this.tileID.canonical), je.bucketLayerIDs.push(Sr.map((so) => so.id)));
              }
            }
            const ut = c.aF(Ie.glyphDependencies, (hn) => Object.keys(hn).map(Number));
            this.inFlightDependencies.forEach((hn) => hn == null ? void 0 : hn.abort()), this.inFlightDependencies = [];
            let We = Promise.resolve({});
            if (Object.keys(ut).length) {
              const hn = new AbortController();
              this.inFlightDependencies.push(hn), We = ye.sendAsync({ type: "GG", data: { stacks: ut, source: this.source, tileID: this.tileID, type: "glyphs" } }, hn);
            }
            const vt = Object.keys(Ie.iconDependencies);
            let Xt = Promise.resolve({});
            if (vt.length) {
              const hn = new AbortController();
              this.inFlightDependencies.push(hn), Xt = ye.sendAsync({ type: "GI", data: { icons: vt, source: this.source, tileID: this.tileID, type: "icons" } }, hn);
            }
            const Kt = Object.keys(Ie.patternDependencies);
            let Mn = Promise.resolve({});
            if (Kt.length) {
              const hn = new AbortController();
              this.inFlightDependencies.push(hn), Mn = ye.sendAsync({ type: "GI", data: { icons: Kt, source: this.source, tileID: this.tileID, type: "patterns" } }, hn);
            }
            const [en, In, wn] = yield Promise.all([We, Xt, Mn]), ir = new _(en), Wn = new c.bo(In, wn);
            for (const hn in Oe) {
              const Fn = Oe[hn];
              Fn instanceof c.a6 ? (w(Fn.layers, this.zoom, ce), c.bp({ bucket: Fn, glyphMap: en, glyphPositions: ir.positions, imageMap: In, imagePositions: Wn.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Fn.hasPattern && (Fn instanceof c.bq || Fn instanceof c.br || Fn instanceof c.bs) && (w(Fn.layers, this.zoom, ce), Fn.addFeatures(Ie, this.tileID.canonical, Wn.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(Oe).filter((hn) => !hn.isEmpty()), featureIndex: je, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ir.image, imageAtlas: Wn, glyphMap: this.returnDependencies ? en : null, iconMap: this.returnDependencies ? In : null, glyphPositions: this.returnDependencies ? ir.positions : null };
          });
        }
      }
      function w(be, J, K) {
        const ce = new c.z(J);
        for (const ye of be) ye.recalculate(ce, K);
      }
      class T {
        constructor(J, K, ce) {
          this.actor = J, this.layerIndex = K, this.availableImages = ce, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(J, K) {
          return c._(this, void 0, void 0, function* () {
            const ce = yield c.l(J.request, K);
            try {
              return { vectorTile: new c.bt.VectorTile(new c.bu(ce.data)), rawData: ce.data, cacheControl: ce.cacheControl, expires: ce.expires };
            } catch (ye) {
              const Fe = new Uint8Array(ce.data);
              let je = `Unable to parse the tile at ${J.request.url}, `;
              throw je += Fe[0] === 31 && Fe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ye.message}`, new Error(je);
            }
          });
        }
        loadTile(J) {
          return c._(this, void 0, void 0, function* () {
            const K = J.uid, ce = !!(J && J.request && J.request.collectResourceTiming) && new c.bv(J.request), ye = new b(J);
            this.loading[K] = ye;
            const Fe = new AbortController();
            ye.abort = Fe;
            try {
              const je = yield this.loadVectorTile(J, Fe);
              if (delete this.loading[K], !je) return null;
              const Oe = je.rawData, Ie = {};
              je.expires && (Ie.expires = je.expires), je.cacheControl && (Ie.cacheControl = je.cacheControl);
              const tt = {};
              if (ce) {
                const We = ce.finish();
                We && (tt.resourceTiming = JSON.parse(JSON.stringify(We)));
              }
              ye.vectorTile = je.vectorTile;
              const ut = ye.parse(je.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[K] = ye, this.fetching[K] = { rawTileData: Oe, cacheControl: Ie, resourceTiming: tt };
              try {
                const We = yield ut;
                return c.e({ rawTileData: Oe.slice(0) }, We, Ie, tt);
              } finally {
                delete this.fetching[K];
              }
            } catch (je) {
              throw delete this.loading[K], ye.status = "done", this.loaded[K] = ye, je;
            }
          });
        }
        reloadTile(J) {
          return c._(this, void 0, void 0, function* () {
            const K = J.uid;
            if (!this.loaded || !this.loaded[K]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const ce = this.loaded[K];
            if (ce.showCollisionBoxes = J.showCollisionBoxes, ce.status === "parsing") {
              const ye = yield ce.parse(ce.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let Fe;
              if (this.fetching[K]) {
                const { rawTileData: je, cacheControl: Oe, resourceTiming: Ie } = this.fetching[K];
                delete this.fetching[K], Fe = c.e({ rawTileData: je.slice(0) }, ye, Oe, Ie);
              } else Fe = ye;
              return Fe;
            }
            if (ce.status === "done" && ce.vectorTile) return ce.parse(ce.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(J) {
          return c._(this, void 0, void 0, function* () {
            const K = this.loading, ce = J.uid;
            K && K[ce] && K[ce].abort && (K[ce].abort.abort(), delete K[ce]);
          });
        }
        removeTile(J) {
          return c._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[J.uid] && delete this.loaded[J.uid];
          });
        }
      }
      class I {
        constructor() {
          this.loaded = {};
        }
        loadTile(J) {
          return c._(this, void 0, void 0, function* () {
            const { uid: K, encoding: ce, rawImageData: ye, redFactor: Fe, greenFactor: je, blueFactor: Oe, baseShift: Ie } = J, tt = ye.width + 2, ut = ye.height + 2, We = c.b(ye) ? new c.R({ width: tt, height: ut }, yield c.bw(ye, -1, -1, tt, ut)) : ye, vt = new c.bx(K, We, ce, Fe, je, Oe, Ie);
            return this.loaded = this.loaded || {}, this.loaded[K] = vt, vt;
          });
        }
        removeTile(J) {
          const K = this.loaded, ce = J.uid;
          K && K[ce] && delete K[ce];
        }
      }
      function P(be, J) {
        if (be.length !== 0) {
          k(be[0], J);
          for (var K = 1; K < be.length; K++) k(be[K], !J);
        }
      }
      function k(be, J) {
        for (var K = 0, ce = 0, ye = 0, Fe = be.length, je = Fe - 1; ye < Fe; je = ye++) {
          var Oe = (be[ye][0] - be[je][0]) * (be[je][1] + be[ye][1]), Ie = K + Oe;
          ce += Math.abs(K) >= Math.abs(Oe) ? K - Ie + Oe : Oe - Ie + K, K = Ie;
        }
        K + ce >= 0 != !!J && be.reverse();
      }
      var U = c.by(function be(J, K) {
        var ce, ye = J && J.type;
        if (ye === "FeatureCollection") for (ce = 0; ce < J.features.length; ce++) be(J.features[ce], K);
        else if (ye === "GeometryCollection") for (ce = 0; ce < J.geometries.length; ce++) be(J.geometries[ce], K);
        else if (ye === "Feature") be(J.geometry, K);
        else if (ye === "Polygon") P(J.coordinates, K);
        else if (ye === "MultiPolygon") for (ce = 0; ce < J.coordinates.length; ce++) P(J.coordinates[ce], K);
        return J;
      });
      const G = c.bt.VectorTileFeature.prototype.toGeoJSON;
      var H = { exports: {} }, $ = c.bz, ie = c.bt.VectorTileFeature, ge = Se;
      function Se(be, J) {
        this.options = J || {}, this.features = be, this.length = be.length;
      }
      function Re(be, J) {
        this.id = typeof be.id == "number" ? be.id : void 0, this.type = be.type, this.rawGeometry = be.type === 1 ? [be.geometry] : be.geometry, this.properties = be.tags, this.extent = J || 4096;
      }
      Se.prototype.feature = function(be) {
        return new Re(this.features[be], this.options.extent);
      }, Re.prototype.loadGeometry = function() {
        var be = this.rawGeometry;
        this.geometry = [];
        for (var J = 0; J < be.length; J++) {
          for (var K = be[J], ce = [], ye = 0; ye < K.length; ye++) ce.push(new $(K[ye][0], K[ye][1]));
          this.geometry.push(ce);
        }
        return this.geometry;
      }, Re.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var be = this.geometry, J = 1 / 0, K = -1 / 0, ce = 1 / 0, ye = -1 / 0, Fe = 0; Fe < be.length; Fe++) for (var je = be[Fe], Oe = 0; Oe < je.length; Oe++) {
          var Ie = je[Oe];
          J = Math.min(J, Ie.x), K = Math.max(K, Ie.x), ce = Math.min(ce, Ie.y), ye = Math.max(ye, Ie.y);
        }
        return [J, ce, K, ye];
      }, Re.prototype.toGeoJSON = ie.prototype.toGeoJSON;
      var Le = c.bA, _e = ge;
      function Ge(be) {
        var J = new Le();
        return function(K, ce) {
          for (var ye in K.layers) ce.writeMessage(3, ke, K.layers[ye]);
        }(be, J), J.finish();
      }
      function ke(be, J) {
        var K;
        J.writeVarintField(15, be.version || 1), J.writeStringField(1, be.name || ""), J.writeVarintField(5, be.extent || 4096);
        var ce = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (K = 0; K < be.length; K++) ce.feature = be.feature(K), J.writeMessage(2, oe, ce);
        var ye = ce.keys;
        for (K = 0; K < ye.length; K++) J.writeStringField(3, ye[K]);
        var Fe = ce.values;
        for (K = 0; K < Fe.length; K++) J.writeMessage(4, rt, Fe[K]);
      }
      function oe(be, J) {
        var K = be.feature;
        K.id !== void 0 && J.writeVarintField(1, K.id), J.writeMessage(2, pe, be), J.writeVarintField(3, K.type), J.writeMessage(4, et, K);
      }
      function pe(be, J) {
        var K = be.feature, ce = be.keys, ye = be.values, Fe = be.keycache, je = be.valuecache;
        for (var Oe in K.properties) {
          var Ie = K.properties[Oe], tt = Fe[Oe];
          if (Ie !== null) {
            tt === void 0 && (ce.push(Oe), Fe[Oe] = tt = ce.length - 1), J.writeVarint(tt);
            var ut = typeof Ie;
            ut !== "string" && ut !== "boolean" && ut !== "number" && (Ie = JSON.stringify(Ie));
            var We = ut + ":" + Ie, vt = je[We];
            vt === void 0 && (ye.push(Ie), je[We] = vt = ye.length - 1), J.writeVarint(vt);
          }
        }
      }
      function Te(be, J) {
        return (J << 3) + (7 & be);
      }
      function xe(be) {
        return be << 1 ^ be >> 31;
      }
      function et(be, J) {
        for (var K = be.loadGeometry(), ce = be.type, ye = 0, Fe = 0, je = K.length, Oe = 0; Oe < je; Oe++) {
          var Ie = K[Oe], tt = 1;
          ce === 1 && (tt = Ie.length), J.writeVarint(Te(1, tt));
          for (var ut = ce === 3 ? Ie.length - 1 : Ie.length, We = 0; We < ut; We++) {
            We === 1 && ce !== 1 && J.writeVarint(Te(2, ut - 1));
            var vt = Ie[We].x - ye, Xt = Ie[We].y - Fe;
            J.writeVarint(xe(vt)), J.writeVarint(xe(Xt)), ye += vt, Fe += Xt;
          }
          ce === 3 && J.writeVarint(Te(7, 1));
        }
      }
      function rt(be, J) {
        var K = typeof be;
        K === "string" ? J.writeStringField(1, be) : K === "boolean" ? J.writeBooleanField(7, be) : K === "number" && (be % 1 != 0 ? J.writeDoubleField(3, be) : be < 0 ? J.writeSVarintField(6, be) : J.writeVarintField(5, be));
      }
      H.exports = Ge, H.exports.fromVectorTileJs = Ge, H.exports.fromGeojsonVt = function(be, J) {
        J = J || {};
        var K = {};
        for (var ce in be) K[ce] = new _e(be[ce].features, J), K[ce].name = ce, K[ce].version = J.version, K[ce].extent = J.extent;
        return Ge({ layers: K });
      }, H.exports.GeoJSONWrapper = _e;
      var st = c.by(H.exports);
      const Je = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (be) => be }, ct = Math.fround || (ot = new Float32Array(1), (be) => (ot[0] = +be, ot[0]));
      var ot;
      const Mt = 3, re = 5, Ae = 6;
      class Ce {
        constructor(J) {
          this.options = Object.assign(Object.create(Je), J), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(J) {
          const { log: K, minZoom: ce, maxZoom: ye } = this.options;
          K && console.time("total time");
          const Fe = `prepare ${J.length} points`;
          K && console.time(Fe), this.points = J;
          const je = [];
          for (let Ie = 0; Ie < J.length; Ie++) {
            const tt = J[Ie];
            if (!tt.geometry) continue;
            const [ut, We] = tt.geometry.coordinates, vt = ct(He(ut)), Xt = ct(Ye(We));
            je.push(vt, Xt, 1 / 0, Ie, -1, 1), this.options.reduce && je.push(0);
          }
          let Oe = this.trees[ye + 1] = this._createTree(je);
          K && console.timeEnd(Fe);
          for (let Ie = ye; Ie >= ce; Ie--) {
            const tt = +Date.now();
            Oe = this.trees[Ie] = this._createTree(this._cluster(Oe, Ie)), K && console.log("z%d: %d clusters in %dms", Ie, Oe.numItems, +Date.now() - tt);
          }
          return K && console.timeEnd("total time"), this;
        }
        getClusters(J, K) {
          let ce = ((J[0] + 180) % 360 + 360) % 360 - 180;
          const ye = Math.max(-90, Math.min(90, J[1]));
          let Fe = J[2] === 180 ? 180 : ((J[2] + 180) % 360 + 360) % 360 - 180;
          const je = Math.max(-90, Math.min(90, J[3]));
          if (J[2] - J[0] >= 360) ce = -180, Fe = 180;
          else if (ce > Fe) {
            const We = this.getClusters([ce, ye, 180, je], K), vt = this.getClusters([-180, ye, Fe, je], K);
            return We.concat(vt);
          }
          const Oe = this.trees[this._limitZoom(K)], Ie = Oe.range(He(ce), Ye(je), He(Fe), Ye(ye)), tt = Oe.data, ut = [];
          for (const We of Ie) {
            const vt = this.stride * We;
            ut.push(tt[vt + re] > 1 ? Ue(tt, vt, this.clusterProps) : this.points[tt[vt + Mt]]);
          }
          return ut;
        }
        getChildren(J) {
          const K = this._getOriginId(J), ce = this._getOriginZoom(J), ye = "No cluster with the specified id.", Fe = this.trees[ce];
          if (!Fe) throw new Error(ye);
          const je = Fe.data;
          if (K * this.stride >= je.length) throw new Error(ye);
          const Oe = this.options.radius / (this.options.extent * Math.pow(2, ce - 1)), Ie = Fe.within(je[K * this.stride], je[K * this.stride + 1], Oe), tt = [];
          for (const ut of Ie) {
            const We = ut * this.stride;
            je[We + 4] === J && tt.push(je[We + re] > 1 ? Ue(je, We, this.clusterProps) : this.points[je[We + Mt]]);
          }
          if (tt.length === 0) throw new Error(ye);
          return tt;
        }
        getLeaves(J, K, ce) {
          const ye = [];
          return this._appendLeaves(ye, J, K = K || 10, ce = ce || 0, 0), ye;
        }
        getTile(J, K, ce) {
          const ye = this.trees[this._limitZoom(J)], Fe = Math.pow(2, J), { extent: je, radius: Oe } = this.options, Ie = Oe / je, tt = (ce - Ie) / Fe, ut = (ce + 1 + Ie) / Fe, We = { features: [] };
          return this._addTileFeatures(ye.range((K - Ie) / Fe, tt, (K + 1 + Ie) / Fe, ut), ye.data, K, ce, Fe, We), K === 0 && this._addTileFeatures(ye.range(1 - Ie / Fe, tt, 1, ut), ye.data, Fe, ce, Fe, We), K === Fe - 1 && this._addTileFeatures(ye.range(0, tt, Ie / Fe, ut), ye.data, -1, ce, Fe, We), We.features.length ? We : null;
        }
        getClusterExpansionZoom(J) {
          let K = this._getOriginZoom(J) - 1;
          for (; K <= this.options.maxZoom; ) {
            const ce = this.getChildren(J);
            if (K++, ce.length !== 1) break;
            J = ce[0].properties.cluster_id;
          }
          return K;
        }
        _appendLeaves(J, K, ce, ye, Fe) {
          const je = this.getChildren(K);
          for (const Oe of je) {
            const Ie = Oe.properties;
            if (Ie && Ie.cluster ? Fe + Ie.point_count <= ye ? Fe += Ie.point_count : Fe = this._appendLeaves(J, Ie.cluster_id, ce, ye, Fe) : Fe < ye ? Fe++ : J.push(Oe), J.length === ce) break;
          }
          return Fe;
        }
        _createTree(J) {
          const K = new c.av(J.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let ce = 0; ce < J.length; ce += this.stride) K.add(J[ce], J[ce + 1]);
          return K.finish(), K.data = J, K;
        }
        _addTileFeatures(J, K, ce, ye, Fe, je) {
          for (const Oe of J) {
            const Ie = Oe * this.stride, tt = K[Ie + re] > 1;
            let ut, We, vt;
            if (tt) ut = qe(K, Ie, this.clusterProps), We = K[Ie], vt = K[Ie + 1];
            else {
              const Mn = this.points[K[Ie + Mt]];
              ut = Mn.properties;
              const [en, In] = Mn.geometry.coordinates;
              We = He(en), vt = Ye(In);
            }
            const Xt = { type: 1, geometry: [[Math.round(this.options.extent * (We * Fe - ce)), Math.round(this.options.extent * (vt * Fe - ye))]], tags: ut };
            let Kt;
            Kt = tt || this.options.generateId ? K[Ie + Mt] : this.points[K[Ie + Mt]].id, Kt !== void 0 && (Xt.id = Kt), je.features.push(Xt);
          }
        }
        _limitZoom(J) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+J), this.options.maxZoom + 1));
        }
        _cluster(J, K) {
          const { radius: ce, extent: ye, reduce: Fe, minPoints: je } = this.options, Oe = ce / (ye * Math.pow(2, K)), Ie = J.data, tt = [], ut = this.stride;
          for (let We = 0; We < Ie.length; We += ut) {
            if (Ie[We + 2] <= K) continue;
            Ie[We + 2] = K;
            const vt = Ie[We], Xt = Ie[We + 1], Kt = J.within(Ie[We], Ie[We + 1], Oe), Mn = Ie[We + re];
            let en = Mn;
            for (const In of Kt) {
              const wn = In * ut;
              Ie[wn + 2] > K && (en += Ie[wn + re]);
            }
            if (en > Mn && en >= je) {
              let In, wn = vt * Mn, ir = Xt * Mn, Wn = -1;
              const hn = ((We / ut | 0) << 5) + (K + 1) + this.points.length;
              for (const Fn of Kt) {
                const er = Fn * ut;
                if (Ie[er + 2] <= K) continue;
                Ie[er + 2] = K;
                const fr = Ie[er + re];
                wn += Ie[er] * fr, ir += Ie[er + 1] * fr, Ie[er + 4] = hn, Fe && (In || (In = this._map(Ie, We, !0), Wn = this.clusterProps.length, this.clusterProps.push(In)), Fe(In, this._map(Ie, er)));
              }
              Ie[We + 4] = hn, tt.push(wn / en, ir / en, 1 / 0, hn, -1, en), Fe && tt.push(Wn);
            } else {
              for (let In = 0; In < ut; In++) tt.push(Ie[We + In]);
              if (en > 1) for (const In of Kt) {
                const wn = In * ut;
                if (!(Ie[wn + 2] <= K)) {
                  Ie[wn + 2] = K;
                  for (let ir = 0; ir < ut; ir++) tt.push(Ie[wn + ir]);
                }
              }
            }
          }
          return tt;
        }
        _getOriginId(J) {
          return J - this.points.length >> 5;
        }
        _getOriginZoom(J) {
          return (J - this.points.length) % 32;
        }
        _map(J, K, ce) {
          if (J[K + re] > 1) {
            const je = this.clusterProps[J[K + Ae]];
            return ce ? Object.assign({}, je) : je;
          }
          const ye = this.points[J[K + Mt]].properties, Fe = this.options.map(ye);
          return ce && Fe === ye ? Object.assign({}, Fe) : Fe;
        }
      }
      function Ue(be, J, K) {
        return { type: "Feature", id: be[J + Mt], properties: qe(be, J, K), geometry: { type: "Point", coordinates: [(ce = be[J], 360 * (ce - 0.5)), Ze(be[J + 1])] } };
        var ce;
      }
      function qe(be, J, K) {
        const ce = be[J + re], ye = ce >= 1e4 ? `${Math.round(ce / 1e3)}k` : ce >= 1e3 ? Math.round(ce / 100) / 10 + "k" : ce, Fe = be[J + Ae], je = Fe === -1 ? {} : Object.assign({}, K[Fe]);
        return Object.assign(je, { cluster: !0, cluster_id: be[J + Mt], point_count: ce, point_count_abbreviated: ye });
      }
      function He(be) {
        return be / 360 + 0.5;
      }
      function Ye(be) {
        const J = Math.sin(be * Math.PI / 180), K = 0.5 - 0.25 * Math.log((1 + J) / (1 - J)) / Math.PI;
        return K < 0 ? 0 : K > 1 ? 1 : K;
      }
      function Ze(be) {
        const J = (180 - 360 * be) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(J)) / Math.PI - 90;
      }
      function St(be, J, K, ce) {
        let ye = ce;
        const Fe = J + (K - J >> 1);
        let je, Oe = K - J;
        const Ie = be[J], tt = be[J + 1], ut = be[K], We = be[K + 1];
        for (let vt = J + 3; vt < K; vt += 3) {
          const Xt = Lt(be[vt], be[vt + 1], Ie, tt, ut, We);
          if (Xt > ye) je = vt, ye = Xt;
          else if (Xt === ye) {
            const Kt = Math.abs(vt - Fe);
            Kt < Oe && (je = vt, Oe = Kt);
          }
        }
        ye > ce && (je - J > 3 && St(be, J, je, ce), be[je + 2] = ye, K - je > 3 && St(be, je, K, ce));
      }
      function Lt(be, J, K, ce, ye, Fe) {
        let je = ye - K, Oe = Fe - ce;
        if (je !== 0 || Oe !== 0) {
          const Ie = ((be - K) * je + (J - ce) * Oe) / (je * je + Oe * Oe);
          Ie > 1 ? (K = ye, ce = Fe) : Ie > 0 && (K += je * Ie, ce += Oe * Ie);
        }
        return je = be - K, Oe = J - ce, je * je + Oe * Oe;
      }
      function Dt(be, J, K, ce) {
        const ye = { id: be ?? null, type: J, geometry: K, tags: ce, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (J === "Point" || J === "MultiPoint" || J === "LineString") Nt(ye, K);
        else if (J === "Polygon") Nt(ye, K[0]);
        else if (J === "MultiLineString") for (const Fe of K) Nt(ye, Fe);
        else if (J === "MultiPolygon") for (const Fe of K) Nt(ye, Fe[0]);
        return ye;
      }
      function Nt(be, J) {
        for (let K = 0; K < J.length; K += 3) be.minX = Math.min(be.minX, J[K]), be.minY = Math.min(be.minY, J[K + 1]), be.maxX = Math.max(be.maxX, J[K]), be.maxY = Math.max(be.maxY, J[K + 1]);
      }
      function an(be, J, K, ce) {
        if (!J.geometry) return;
        const ye = J.geometry.coordinates;
        if (ye && ye.length === 0) return;
        const Fe = J.geometry.type, je = Math.pow(K.tolerance / ((1 << K.maxZoom) * K.extent), 2);
        let Oe = [], Ie = J.id;
        if (K.promoteId ? Ie = J.properties[K.promoteId] : K.generateId && (Ie = ce || 0), Fe === "Point") at(ye, Oe);
        else if (Fe === "MultiPoint") for (const tt of ye) at(tt, Oe);
        else if (Fe === "LineString") ne(ye, Oe, je, !1);
        else if (Fe === "MultiLineString") {
          if (K.lineMetrics) {
            for (const tt of ye) Oe = [], ne(tt, Oe, je, !1), be.push(Dt(Ie, "LineString", Oe, J.properties));
            return;
          }
          pn(ye, Oe, je, !1);
        } else if (Fe === "Polygon") pn(ye, Oe, je, !0);
        else {
          if (Fe !== "MultiPolygon") {
            if (Fe === "GeometryCollection") {
              for (const tt of J.geometry.geometries) an(be, { id: Ie, geometry: tt, properties: J.properties }, K, ce);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const tt of ye) {
            const ut = [];
            pn(tt, ut, je, !0), Oe.push(ut);
          }
        }
        be.push(Dt(Ie, Fe, Oe, J.properties));
      }
      function at(be, J) {
        J.push(Qt(be[0]), dt(be[1]), 0);
      }
      function ne(be, J, K, ce) {
        let ye, Fe, je = 0;
        for (let Ie = 0; Ie < be.length; Ie++) {
          const tt = Qt(be[Ie][0]), ut = dt(be[Ie][1]);
          J.push(tt, ut, 0), Ie > 0 && (je += ce ? (ye * ut - tt * Fe) / 2 : Math.sqrt(Math.pow(tt - ye, 2) + Math.pow(ut - Fe, 2))), ye = tt, Fe = ut;
        }
        const Oe = J.length - 3;
        J[2] = 1, St(J, 0, Oe, K), J[Oe + 2] = 1, J.size = Math.abs(je), J.start = 0, J.end = J.size;
      }
      function pn(be, J, K, ce) {
        for (let ye = 0; ye < be.length; ye++) {
          const Fe = [];
          ne(be[ye], Fe, K, ce), J.push(Fe);
        }
      }
      function Qt(be) {
        return be / 360 + 0.5;
      }
      function dt(be) {
        const J = Math.sin(be * Math.PI / 180), K = 0.5 - 0.25 * Math.log((1 + J) / (1 - J)) / Math.PI;
        return K < 0 ? 0 : K > 1 ? 1 : K;
      }
      function Et(be, J, K, ce, ye, Fe, je, Oe) {
        if (ce /= J, Fe >= (K /= J) && je < ce) return be;
        if (je < K || Fe >= ce) return null;
        const Ie = [];
        for (const tt of be) {
          const ut = tt.geometry;
          let We = tt.type;
          const vt = ye === 0 ? tt.minX : tt.minY, Xt = ye === 0 ? tt.maxX : tt.maxY;
          if (vt >= K && Xt < ce) {
            Ie.push(tt);
            continue;
          }
          if (Xt < K || vt >= ce) continue;
          let Kt = [];
          if (We === "Point" || We === "MultiPoint") Bt(ut, Kt, K, ce, ye);
          else if (We === "LineString") Ft(ut, Kt, K, ce, ye, !1, Oe.lineMetrics);
          else if (We === "MultiLineString") Sn(ut, Kt, K, ce, ye, !1);
          else if (We === "Polygon") Sn(ut, Kt, K, ce, ye, !0);
          else if (We === "MultiPolygon") for (const Mn of ut) {
            const en = [];
            Sn(Mn, en, K, ce, ye, !0), en.length && Kt.push(en);
          }
          if (Kt.length) {
            if (Oe.lineMetrics && We === "LineString") {
              for (const Mn of Kt) Ie.push(Dt(tt.id, We, Mn, tt.tags));
              continue;
            }
            We !== "LineString" && We !== "MultiLineString" || (Kt.length === 1 ? (We = "LineString", Kt = Kt[0]) : We = "MultiLineString"), We !== "Point" && We !== "MultiPoint" || (We = Kt.length === 3 ? "Point" : "MultiPoint"), Ie.push(Dt(tt.id, We, Kt, tt.tags));
          }
        }
        return Ie.length ? Ie : null;
      }
      function Bt(be, J, K, ce, ye) {
        for (let Fe = 0; Fe < be.length; Fe += 3) {
          const je = be[Fe + ye];
          je >= K && je <= ce && vn(J, be[Fe], be[Fe + 1], be[Fe + 2]);
        }
      }
      function Ft(be, J, K, ce, ye, Fe, je) {
        let Oe = nn(be);
        const Ie = ye === 0 ? On : Un;
        let tt, ut, We = be.start;
        for (let en = 0; en < be.length - 3; en += 3) {
          const In = be[en], wn = be[en + 1], ir = be[en + 2], Wn = be[en + 3], hn = be[en + 4], Fn = ye === 0 ? In : wn, er = ye === 0 ? Wn : hn;
          let fr = !1;
          je && (tt = Math.sqrt(Math.pow(In - Wn, 2) + Math.pow(wn - hn, 2))), Fn < K ? er > K && (ut = Ie(Oe, In, wn, Wn, hn, K), je && (Oe.start = We + tt * ut)) : Fn > ce ? er < ce && (ut = Ie(Oe, In, wn, Wn, hn, ce), je && (Oe.start = We + tt * ut)) : vn(Oe, In, wn, ir), er < K && Fn >= K && (ut = Ie(Oe, In, wn, Wn, hn, K), fr = !0), er > ce && Fn <= ce && (ut = Ie(Oe, In, wn, Wn, hn, ce), fr = !0), !Fe && fr && (je && (Oe.end = We + tt * ut), J.push(Oe), Oe = nn(be)), je && (We += tt);
        }
        let vt = be.length - 3;
        const Xt = be[vt], Kt = be[vt + 1], Mn = ye === 0 ? Xt : Kt;
        Mn >= K && Mn <= ce && vn(Oe, Xt, Kt, be[vt + 2]), vt = Oe.length - 3, Fe && vt >= 3 && (Oe[vt] !== Oe[0] || Oe[vt + 1] !== Oe[1]) && vn(Oe, Oe[0], Oe[1], Oe[2]), Oe.length && J.push(Oe);
      }
      function nn(be) {
        const J = [];
        return J.size = be.size, J.start = be.start, J.end = be.end, J;
      }
      function Sn(be, J, K, ce, ye, Fe) {
        for (const je of be) Ft(je, J, K, ce, ye, Fe, !1);
      }
      function vn(be, J, K, ce) {
        be.push(J, K, ce);
      }
      function On(be, J, K, ce, ye, Fe) {
        const je = (Fe - J) / (ce - J);
        return vn(be, Fe, K + (ye - K) * je, 1), je;
      }
      function Un(be, J, K, ce, ye, Fe) {
        const je = (Fe - K) / (ye - K);
        return vn(be, J + (ce - J) * je, Fe, 1), je;
      }
      function gt(be, J) {
        const K = [];
        for (let ce = 0; ce < be.length; ce++) {
          const ye = be[ce], Fe = ye.type;
          let je;
          if (Fe === "Point" || Fe === "MultiPoint" || Fe === "LineString") je = un(ye.geometry, J);
          else if (Fe === "MultiLineString" || Fe === "Polygon") {
            je = [];
            for (const Oe of ye.geometry) je.push(un(Oe, J));
          } else if (Fe === "MultiPolygon") {
            je = [];
            for (const Oe of ye.geometry) {
              const Ie = [];
              for (const tt of Oe) Ie.push(un(tt, J));
              je.push(Ie);
            }
          }
          K.push(Dt(ye.id, Fe, je, ye.tags));
        }
        return K;
      }
      function un(be, J) {
        const K = [];
        K.size = be.size, be.start !== void 0 && (K.start = be.start, K.end = be.end);
        for (let ce = 0; ce < be.length; ce += 3) K.push(be[ce] + J, be[ce + 1], be[ce + 2]);
        return K;
      }
      function xn(be, J) {
        if (be.transformed) return be;
        const K = 1 << be.z, ce = be.x, ye = be.y;
        for (const Fe of be.features) {
          const je = Fe.geometry, Oe = Fe.type;
          if (Fe.geometry = [], Oe === 1) for (let Ie = 0; Ie < je.length; Ie += 2) Fe.geometry.push(Ot(je[Ie], je[Ie + 1], J, K, ce, ye));
          else for (let Ie = 0; Ie < je.length; Ie++) {
            const tt = [];
            for (let ut = 0; ut < je[Ie].length; ut += 2) tt.push(Ot(je[Ie][ut], je[Ie][ut + 1], J, K, ce, ye));
            Fe.geometry.push(tt);
          }
        }
        return be.transformed = !0, be;
      }
      function Ot(be, J, K, ce, ye, Fe) {
        return [Math.round(K * (be * ce - ye)), Math.round(K * (J * ce - Fe))];
      }
      function _r(be, J, K, ce, ye) {
        const Fe = J === ye.maxZoom ? 0 : ye.tolerance / ((1 << J) * ye.extent), je = { features: [], numPoints: 0, numSimplified: 0, numFeatures: be.length, source: null, x: K, y: ce, z: J, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const Oe of be) mt(je, Oe, Fe, ye);
        return je;
      }
      function mt(be, J, K, ce) {
        const ye = J.geometry, Fe = J.type, je = [];
        if (be.minX = Math.min(be.minX, J.minX), be.minY = Math.min(be.minY, J.minY), be.maxX = Math.max(be.maxX, J.maxX), be.maxY = Math.max(be.maxY, J.maxY), Fe === "Point" || Fe === "MultiPoint") for (let Oe = 0; Oe < ye.length; Oe += 3) je.push(ye[Oe], ye[Oe + 1]), be.numPoints++, be.numSimplified++;
        else if (Fe === "LineString") bn(je, ye, be, K, !1, !1);
        else if (Fe === "MultiLineString" || Fe === "Polygon") for (let Oe = 0; Oe < ye.length; Oe++) bn(je, ye[Oe], be, K, Fe === "Polygon", Oe === 0);
        else if (Fe === "MultiPolygon") for (let Oe = 0; Oe < ye.length; Oe++) {
          const Ie = ye[Oe];
          for (let tt = 0; tt < Ie.length; tt++) bn(je, Ie[tt], be, K, !0, tt === 0);
        }
        if (je.length) {
          let Oe = J.tags || null;
          if (Fe === "LineString" && ce.lineMetrics) {
            Oe = {};
            for (const tt in J.tags) Oe[tt] = J.tags[tt];
            Oe.mapbox_clip_start = ye.start / ye.size, Oe.mapbox_clip_end = ye.end / ye.size;
          }
          const Ie = { geometry: je, type: Fe === "Polygon" || Fe === "MultiPolygon" ? 3 : Fe === "LineString" || Fe === "MultiLineString" ? 2 : 1, tags: Oe };
          J.id !== null && (Ie.id = J.id), be.features.push(Ie);
        }
      }
      function bn(be, J, K, ce, ye, Fe) {
        const je = ce * ce;
        if (ce > 0 && J.size < (ye ? je : ce)) return void (K.numPoints += J.length / 3);
        const Oe = [];
        for (let Ie = 0; Ie < J.length; Ie += 3) (ce === 0 || J[Ie + 2] > je) && (K.numSimplified++, Oe.push(J[Ie], J[Ie + 1])), K.numPoints++;
        ye && function(Ie, tt) {
          let ut = 0;
          for (let We = 0, vt = Ie.length, Xt = vt - 2; We < vt; Xt = We, We += 2) ut += (Ie[We] - Ie[Xt]) * (Ie[We + 1] + Ie[Xt + 1]);
          if (ut > 0 === tt) for (let We = 0, vt = Ie.length; We < vt / 2; We += 2) {
            const Xt = Ie[We], Kt = Ie[We + 1];
            Ie[We] = Ie[vt - 2 - We], Ie[We + 1] = Ie[vt - 1 - We], Ie[vt - 2 - We] = Xt, Ie[vt - 1 - We] = Kt;
          }
        }(Oe, Fe), be.push(Oe);
      }
      const jt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class qn {
        constructor(J, K) {
          const ce = (K = this.options = function(Fe, je) {
            for (const Oe in je) Fe[Oe] = je[Oe];
            return Fe;
          }(Object.create(jt), K)).debug;
          if (ce && console.time("preprocess data"), K.maxZoom < 0 || K.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (K.promoteId && K.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let ye = function(Fe, je) {
            const Oe = [];
            if (Fe.type === "FeatureCollection") for (let Ie = 0; Ie < Fe.features.length; Ie++) an(Oe, Fe.features[Ie], je, Ie);
            else an(Oe, Fe.type === "Feature" ? Fe : { geometry: Fe }, je);
            return Oe;
          }(J, K);
          this.tiles = {}, this.tileCoords = [], ce && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", K.indexMaxZoom, K.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ye = function(Fe, je) {
            const Oe = je.buffer / je.extent;
            let Ie = Fe;
            const tt = Et(Fe, 1, -1 - Oe, Oe, 0, -1, 2, je), ut = Et(Fe, 1, 1 - Oe, 2 + Oe, 0, -1, 2, je);
            return (tt || ut) && (Ie = Et(Fe, 1, -Oe, 1 + Oe, 0, -1, 2, je) || [], tt && (Ie = gt(tt, 1).concat(Ie)), ut && (Ie = Ie.concat(gt(ut, -1)))), Ie;
          }(ye, K), ye.length && this.splitTile(ye, 0, 0, 0), ce && (ye.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(J, K, ce, ye, Fe, je, Oe) {
          const Ie = [J, K, ce, ye], tt = this.options, ut = tt.debug;
          for (; Ie.length; ) {
            ye = Ie.pop(), ce = Ie.pop(), K = Ie.pop(), J = Ie.pop();
            const We = 1 << K, vt = Jr(K, ce, ye);
            let Xt = this.tiles[vt];
            if (!Xt && (ut > 1 && console.time("creation"), Xt = this.tiles[vt] = _r(J, K, ce, ye, tt), this.tileCoords.push({ z: K, x: ce, y: ye }), ut)) {
              ut > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", K, ce, ye, Xt.numFeatures, Xt.numPoints, Xt.numSimplified), console.timeEnd("creation"));
              const fr = `z${K}`;
              this.stats[fr] = (this.stats[fr] || 0) + 1, this.total++;
            }
            if (Xt.source = J, Fe == null) {
              if (K === tt.indexMaxZoom || Xt.numPoints <= tt.indexMaxPoints) continue;
            } else {
              if (K === tt.maxZoom || K === Fe) continue;
              if (Fe != null) {
                const fr = Fe - K;
                if (ce !== je >> fr || ye !== Oe >> fr) continue;
              }
            }
            if (Xt.source = null, J.length === 0) continue;
            ut > 1 && console.time("clipping");
            const Kt = 0.5 * tt.buffer / tt.extent, Mn = 0.5 - Kt, en = 0.5 + Kt, In = 1 + Kt;
            let wn = null, ir = null, Wn = null, hn = null, Fn = Et(J, We, ce - Kt, ce + en, 0, Xt.minX, Xt.maxX, tt), er = Et(J, We, ce + Mn, ce + In, 0, Xt.minX, Xt.maxX, tt);
            J = null, Fn && (wn = Et(Fn, We, ye - Kt, ye + en, 1, Xt.minY, Xt.maxY, tt), ir = Et(Fn, We, ye + Mn, ye + In, 1, Xt.minY, Xt.maxY, tt), Fn = null), er && (Wn = Et(er, We, ye - Kt, ye + en, 1, Xt.minY, Xt.maxY, tt), hn = Et(er, We, ye + Mn, ye + In, 1, Xt.minY, Xt.maxY, tt), er = null), ut > 1 && console.timeEnd("clipping"), Ie.push(wn || [], K + 1, 2 * ce, 2 * ye), Ie.push(ir || [], K + 1, 2 * ce, 2 * ye + 1), Ie.push(Wn || [], K + 1, 2 * ce + 1, 2 * ye), Ie.push(hn || [], K + 1, 2 * ce + 1, 2 * ye + 1);
          }
        }
        getTile(J, K, ce) {
          J = +J, K = +K, ce = +ce;
          const ye = this.options, { extent: Fe, debug: je } = ye;
          if (J < 0 || J > 24) return null;
          const Oe = 1 << J, Ie = Jr(J, K = K + Oe & Oe - 1, ce);
          if (this.tiles[Ie]) return xn(this.tiles[Ie], Fe);
          je > 1 && console.log("drilling down to z%d-%d-%d", J, K, ce);
          let tt, ut = J, We = K, vt = ce;
          for (; !tt && ut > 0; ) ut--, We >>= 1, vt >>= 1, tt = this.tiles[Jr(ut, We, vt)];
          return tt && tt.source ? (je > 1 && (console.log("found parent tile z%d-%d-%d", ut, We, vt), console.time("drilling down")), this.splitTile(tt.source, ut, We, vt, J, K, ce), je > 1 && console.timeEnd("drilling down"), this.tiles[Ie] ? xn(this.tiles[Ie], Fe) : null) : null;
        }
      }
      function Jr(be, J, K) {
        return 32 * ((1 << be) * K + J) + be;
      }
      function zt(be, J) {
        return J ? be.properties[J] : be.id;
      }
      function yi(be, J) {
        if (be == null) return !0;
        if (be.type === "Feature") return zt(be, J) != null;
        if (be.type === "FeatureCollection") {
          const K = /* @__PURE__ */ new Set();
          for (const ce of be.features) {
            const ye = zt(ce, J);
            if (ye == null || K.has(ye)) return !1;
            K.add(ye);
          }
          return !0;
        }
        return !1;
      }
      function rr(be, J) {
        const K = /* @__PURE__ */ new Map();
        if (be != null) if (be.type === "Feature") K.set(zt(be, J), be);
        else for (const ce of be.features) K.set(zt(ce, J), ce);
        return K;
      }
      class ti extends T {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(J, K) {
          return c._(this, void 0, void 0, function* () {
            const ce = J.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const ye = this._geoJSONIndex.getTile(ce.z, ce.x, ce.y);
            if (!ye) return null;
            const Fe = new class {
              constructor(Oe) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = c.X, this.length = Oe.length, this._features = Oe;
              }
              feature(Oe) {
                return new class {
                  constructor(Ie) {
                    this._feature = Ie, this.extent = c.X, this.type = Ie.type, this.properties = Ie.tags, "id" in Ie && !isNaN(Ie.id) && (this.id = parseInt(Ie.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const Ie = [];
                      for (const tt of this._feature.geometry) Ie.push([new c.P(tt[0], tt[1])]);
                      return Ie;
                    }
                    {
                      const Ie = [];
                      for (const tt of this._feature.geometry) {
                        const ut = [];
                        for (const We of tt) ut.push(new c.P(We[0], We[1]));
                        Ie.push(ut);
                      }
                      return Ie;
                    }
                  }
                  toGeoJSON(Ie, tt, ut) {
                    return G.call(this, Ie, tt, ut);
                  }
                }(this._features[Oe]);
              }
            }(ye.features);
            let je = st(Fe);
            return je.byteOffset === 0 && je.byteLength === je.buffer.byteLength || (je = new Uint8Array(je)), { vectorTile: Fe, rawData: je.buffer };
          });
        }
        loadData(J) {
          return c._(this, void 0, void 0, function* () {
            var K;
            (K = this._pendingRequest) === null || K === void 0 || K.abort();
            const ce = !!(J && J.request && J.request.collectResourceTiming) && new c.bv(J.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(J, this._pendingRequest), this._geoJSONIndex = J.cluster ? new Ce(function(je) {
                let { superclusterOptions: Oe, clusterProperties: Ie } = je;
                if (!Ie || !Oe) return Oe;
                const tt = {}, ut = {}, We = { accumulated: null, zoom: 0 }, vt = { properties: null }, Xt = Object.keys(Ie);
                for (const Kt of Xt) {
                  const [Mn, en] = Ie[Kt], In = c.bC(en), wn = c.bC(typeof Mn == "string" ? [Mn, ["accumulated"], ["get", Kt]] : Mn);
                  tt[Kt] = In.value, ut[Kt] = wn.value;
                }
                return Oe.map = (Kt) => {
                  vt.properties = Kt;
                  const Mn = {};
                  for (const en of Xt) Mn[en] = tt[en].evaluate(We, vt);
                  return Mn;
                }, Oe.reduce = (Kt, Mn) => {
                  vt.properties = Mn;
                  for (const en of Xt) We.accumulated = Kt[en], Kt[en] = ut[en].evaluate(We, vt);
                }, Oe;
              }(J)).load((yield this._pendingData).features) : (ye = yield this._pendingData, new qn(ye, J.geojsonVtOptions)), this.loaded = {};
              const Fe = {};
              if (ce) {
                const je = ce.finish();
                je && (Fe.resourceTiming = {}, Fe.resourceTiming[J.source] = JSON.parse(JSON.stringify(je)));
              }
              return Fe;
            } catch (Fe) {
              if (delete this._pendingRequest, c.bB(Fe)) return { abandoned: !0 };
              throw Fe;
            }
            var ye;
          });
        }
        getData() {
          return c._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(J) {
          const K = this.loaded;
          return K && K[J.uid] ? super.reloadTile(J) : this.loadTile(J);
        }
        loadAndProcessGeoJSON(J, K) {
          return c._(this, void 0, void 0, function* () {
            let ce = yield this.loadGeoJSON(J, K);
            if (delete this._pendingRequest, typeof ce != "object") throw new Error(`Input data given to '${J.source}' is not a valid GeoJSON object.`);
            if (U(ce, !0), J.filter) {
              const ye = c.bC(J.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (ye.result === "error") throw new Error(ye.value.map((je) => `${je.key}: ${je.message}`).join(", "));
              ce = { type: "FeatureCollection", features: ce.features.filter((je) => ye.value.evaluate({ zoom: 0 }, je)) };
            }
            return ce;
          });
        }
        loadGeoJSON(J, K) {
          return c._(this, void 0, void 0, function* () {
            const { promoteId: ce } = J;
            if (J.request) {
              const ye = yield c.h(J.request, K);
              return this._dataUpdateable = yi(ye.data, ce) ? rr(ye.data, ce) : void 0, ye.data;
            }
            if (typeof J.data == "string") try {
              const ye = JSON.parse(J.data);
              return this._dataUpdateable = yi(ye, ce) ? rr(ye, ce) : void 0, ye;
            } catch {
              throw new Error(`Input data given to '${J.source}' is not a valid GeoJSON object.`);
            }
            if (!J.dataDiff) throw new Error(`Input data given to '${J.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${J.source}`);
            return function(ye, Fe, je) {
              var Oe, Ie, tt, ut;
              if (Fe.removeAll && ye.clear(), Fe.remove) for (const We of Fe.remove) ye.delete(We);
              if (Fe.add) for (const We of Fe.add) {
                const vt = zt(We, je);
                vt != null && ye.set(vt, We);
              }
              if (Fe.update) for (const We of Fe.update) {
                let vt = ye.get(We.id);
                if (vt == null) continue;
                const Xt = !We.removeAllProperties && (((Oe = We.removeProperties) === null || Oe === void 0 ? void 0 : Oe.length) > 0 || ((Ie = We.addOrUpdateProperties) === null || Ie === void 0 ? void 0 : Ie.length) > 0);
                if ((We.newGeometry || We.removeAllProperties || Xt) && (vt = Object.assign({}, vt), ye.set(We.id, vt), Xt && (vt.properties = Object.assign({}, vt.properties))), We.newGeometry && (vt.geometry = We.newGeometry), We.removeAllProperties) vt.properties = {};
                else if (((tt = We.removeProperties) === null || tt === void 0 ? void 0 : tt.length) > 0) for (const Kt of We.removeProperties) Object.prototype.hasOwnProperty.call(vt.properties, Kt) && delete vt.properties[Kt];
                if (((ut = We.addOrUpdateProperties) === null || ut === void 0 ? void 0 : ut.length) > 0) for (const { key: Kt, value: Mn } of We.addOrUpdateProperties) vt.properties[Kt] = Mn;
              }
            }(this._dataUpdateable, J.dataDiff, ce), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(J) {
          return c._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(J) {
          return this._geoJSONIndex.getClusterExpansionZoom(J.clusterId);
        }
        getClusterChildren(J) {
          return this._geoJSONIndex.getChildren(J.clusterId);
        }
        getClusterLeaves(J) {
          return this._geoJSONIndex.getLeaves(J.clusterId, J.limit, J.offset);
        }
      }
      class ni {
        constructor(J) {
          this.self = J, this.actor = new c.F(J), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (K, ce) => {
            if (this.externalWorkerSourceTypes[K]) throw new Error(`Worker source with name "${K}" already registered.`);
            this.externalWorkerSourceTypes[K] = ce;
          }, this.self.addProtocol = c.bi, this.self.removeProtocol = c.bj, this.self.registerRTLTextPlugin = (K) => {
            if (c.bD.isParsed()) throw new Error("RTL text plugin already registered.");
            c.bD.setMethods(K);
          }, this.actor.registerMessageHandler("LDT", (K, ce) => this._getDEMWorkerSource(K, ce.source).loadTile(ce)), this.actor.registerMessageHandler("RDT", (K, ce) => c._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(K, ce.source).removeTile(ce);
          })), this.actor.registerMessageHandler("GCEZ", (K, ce) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource(K, ce.type, ce.source).getClusterExpansionZoom(ce);
          })), this.actor.registerMessageHandler("GCC", (K, ce) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource(K, ce.type, ce.source).getClusterChildren(ce);
          })), this.actor.registerMessageHandler("GCL", (K, ce) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource(K, ce.type, ce.source).getClusterLeaves(ce);
          })), this.actor.registerMessageHandler("LD", (K, ce) => this._getWorkerSource(K, ce.type, ce.source).loadData(ce)), this.actor.registerMessageHandler("GD", (K, ce) => this._getWorkerSource(K, ce.type, ce.source).getData()), this.actor.registerMessageHandler("LT", (K, ce) => this._getWorkerSource(K, ce.type, ce.source).loadTile(ce)), this.actor.registerMessageHandler("RT", (K, ce) => this._getWorkerSource(K, ce.type, ce.source).reloadTile(ce)), this.actor.registerMessageHandler("AT", (K, ce) => this._getWorkerSource(K, ce.type, ce.source).abortTile(ce)), this.actor.registerMessageHandler("RMT", (K, ce) => this._getWorkerSource(K, ce.type, ce.source).removeTile(ce)), this.actor.registerMessageHandler("RS", (K, ce) => c._(this, void 0, void 0, function* () {
            if (!this.workerSources[K] || !this.workerSources[K][ce.type] || !this.workerSources[K][ce.type][ce.source]) return;
            const ye = this.workerSources[K][ce.type][ce.source];
            delete this.workerSources[K][ce.type][ce.source], ye.removeSource !== void 0 && ye.removeSource(ce);
          })), this.actor.registerMessageHandler("RM", (K) => c._(this, void 0, void 0, function* () {
            delete this.layerIndexes[K], delete this.availableImages[K], delete this.workerSources[K], delete this.demWorkerSources[K];
          })), this.actor.registerMessageHandler("SR", (K, ce) => c._(this, void 0, void 0, function* () {
            this.referrer = ce;
          })), this.actor.registerMessageHandler("SRPS", (K, ce) => this._syncRTLPluginState(K, ce)), this.actor.registerMessageHandler("IS", (K, ce) => c._(this, void 0, void 0, function* () {
            this.self.importScripts(ce);
          })), this.actor.registerMessageHandler("SI", (K, ce) => this._setImages(K, ce)), this.actor.registerMessageHandler("UL", (K, ce) => c._(this, void 0, void 0, function* () {
            this._getLayerIndex(K).update(ce.layers, ce.removedIds);
          })), this.actor.registerMessageHandler("SL", (K, ce) => c._(this, void 0, void 0, function* () {
            this._getLayerIndex(K).replace(ce);
          }));
        }
        _setImages(J, K) {
          return c._(this, void 0, void 0, function* () {
            this.availableImages[J] = K;
            for (const ce in this.workerSources[J]) {
              const ye = this.workerSources[J][ce];
              for (const Fe in ye) ye[Fe].availableImages = K;
            }
          });
        }
        _syncRTLPluginState(J, K) {
          return c._(this, void 0, void 0, function* () {
            if (c.bD.isParsed()) return c.bD.getState();
            if (K.pluginStatus !== "loading") return c.bD.setState(K), K;
            const ce = K.pluginURL;
            if (this.self.importScripts(ce), c.bD.isParsed()) {
              const ye = { pluginStatus: "loaded", pluginURL: ce };
              return c.bD.setState(ye), ye;
            }
            throw c.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${ce}`);
          });
        }
        _getAvailableImages(J) {
          let K = this.availableImages[J];
          return K || (K = []), K;
        }
        _getLayerIndex(J) {
          let K = this.layerIndexes[J];
          return K || (K = this.layerIndexes[J] = new l()), K;
        }
        _getWorkerSource(J, K, ce) {
          if (this.workerSources[J] || (this.workerSources[J] = {}), this.workerSources[J][K] || (this.workerSources[J][K] = {}), !this.workerSources[J][K][ce]) {
            const ye = { sendAsync: (Fe, je) => (Fe.targetMapId = J, this.actor.sendAsync(Fe, je)) };
            switch (K) {
              case "vector":
                this.workerSources[J][K][ce] = new T(ye, this._getLayerIndex(J), this._getAvailableImages(J));
                break;
              case "geojson":
                this.workerSources[J][K][ce] = new ti(ye, this._getLayerIndex(J), this._getAvailableImages(J));
                break;
              default:
                this.workerSources[J][K][ce] = new this.externalWorkerSourceTypes[K](ye, this._getLayerIndex(J), this._getAvailableImages(J));
            }
          }
          return this.workerSources[J][K][ce];
        }
        _getDEMWorkerSource(J, K) {
          return this.demWorkerSources[J] || (this.demWorkerSources[J] = {}), this.demWorkerSources[J][K] || (this.demWorkerSources[J][K] = new I()), this.demWorkerSources[J][K];
        }
      }
      return c.i(self) && (self.worker = new ni(self)), ni;
    }), i("index", ["exports", "./shared"], function(c, l) {
      var _ = "4.7.1";
      let b, w;
      const T = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (g) => new Promise((s, h) => {
        const f = requestAnimationFrame(s);
        g.signal.addEventListener("abort", () => {
          cancelAnimationFrame(f), h(l.c());
        });
      }), getImageData(g) {
        let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.getImageCanvasContext(g).getImageData(-s, -s, g.width + 2 * s, g.height + 2 * s);
      }, getImageCanvasContext(g) {
        const s = window.document.createElement("canvas"), h = s.getContext("2d", { willReadFrequently: !0 });
        if (!h) throw new Error("failed to create canvas 2d context");
        return s.width = g.width, s.height = g.height, h.drawImage(g, 0, 0, g.width, g.height), h;
      }, resolveURL: (g) => (b || (b = document.createElement("a")), b.href = g, b.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (w == null && (w = matchMedia("(prefers-reduced-motion: reduce)")), w.matches);
      } };
      class I {
        static testProp(s) {
          if (!I.docStyle) return s[0];
          for (let h = 0; h < s.length; h++) if (s[h] in I.docStyle) return s[h];
          return s[0];
        }
        static create(s, h, f) {
          const m = window.document.createElement(s);
          return h !== void 0 && (m.className = h), f && f.appendChild(m), m;
        }
        static createNS(s, h) {
          return window.document.createElementNS(s, h);
        }
        static disableDrag() {
          I.docStyle && I.selectProp && (I.userSelect = I.docStyle[I.selectProp], I.docStyle[I.selectProp] = "none");
        }
        static enableDrag() {
          I.docStyle && I.selectProp && (I.docStyle[I.selectProp] = I.userSelect);
        }
        static setTransform(s, h) {
          s.style[I.transformProp] = h;
        }
        static addEventListener(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          s.addEventListener(h, f, "passive" in m ? m : m.capture);
        }
        static removeEventListener(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          s.removeEventListener(h, f, "passive" in m ? m : m.capture);
        }
        static suppressClickInternal(s) {
          s.preventDefault(), s.stopPropagation(), window.removeEventListener("click", I.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", I.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", I.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(s) {
          const h = s.getBoundingClientRect();
          return { x: h.width / s.offsetWidth || 1, y: h.height / s.offsetHeight || 1, boundingClientRect: h };
        }
        static getPoint(s, h, f) {
          const m = h.boundingClientRect;
          return new l.P((f.clientX - m.left) / h.x - s.clientLeft, (f.clientY - m.top) / h.y - s.clientTop);
        }
        static mousePos(s, h) {
          const f = I.getScale(s);
          return I.getPoint(s, f, h);
        }
        static touchPos(s, h) {
          const f = [], m = I.getScale(s);
          for (let y = 0; y < h.length; y++) f.push(I.getPoint(s, m, h[y]));
          return f;
        }
        static mouseButton(s) {
          return s.button;
        }
        static remove(s) {
          s.parentNode && s.parentNode.removeChild(s);
        }
      }
      I.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, I.selectProp = I.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), I.transformProp = I.testProp(["transform", "WebkitTransform"]);
      const P = { supported: !1, testSupport: function(g) {
        !G && U && (H ? $(g) : k = g);
      } };
      let k, U, G = !1, H = !1;
      function $(g) {
        const s = g.createTexture();
        g.bindTexture(g.TEXTURE_2D, s);
        try {
          if (g.texImage2D(g.TEXTURE_2D, 0, g.RGBA, g.RGBA, g.UNSIGNED_BYTE, U), g.isContextLost()) return;
          P.supported = !0;
        } catch {
        }
        g.deleteTexture(s), G = !0;
      }
      var ie;
      typeof document < "u" && (U = document.createElement("img"), U.onload = () => {
        k && $(k), k = null, H = !0;
      }, U.onerror = () => {
        G = !0, k = null;
      }, U.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(g) {
        let s, h, f, m;
        g.resetRequestQueue = () => {
          s = [], h = 0, f = 0, m = {};
        }, g.addThrottleControl = (B) => {
          const D = f++;
          return m[D] = B, D;
        }, g.removeThrottleControl = (B) => {
          delete m[B], S();
        }, g.getImage = function(B, D) {
          let z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          return new Promise((N, X) => {
            P.supported && (B.headers || (B.headers = {}), B.headers.accept = "image/webp,*/*"), l.e(B, { type: "image" }), s.push({ abortController: D, requestParameters: B, supportImageRefresh: z, state: "queued", onError: (Z) => {
              X(Z);
            }, onSuccess: (Z) => {
              N(Z);
            } }), S();
          });
        };
        const y = (B) => l._(this, void 0, void 0, function* () {
          B.state = "running";
          const { requestParameters: D, supportImageRefresh: z, onError: N, onSuccess: X, abortController: Z } = B, W = z === !1 && !l.i(self) && !l.g(D.url) && (!D.headers || Object.keys(D.headers).reduce((ue, fe) => ue && fe === "accept", !0));
          h++;
          const Q = W ? C(D, Z) : l.m(D, Z);
          try {
            const ue = yield Q;
            delete B.abortController, B.state = "completed", ue.data instanceof HTMLImageElement || l.b(ue.data) ? X(ue) : ue.data && X({ data: yield (le = ue.data, typeof createImageBitmap == "function" ? l.d(le) : l.f(le)), cacheControl: ue.cacheControl, expires: ue.expires });
          } catch (ue) {
            delete B.abortController, N(ue);
          } finally {
            h--, S();
          }
          var le;
        }), S = () => {
          const B = (() => {
            for (const D of Object.keys(m)) if (m[D]()) return !0;
            return !1;
          })() ? l.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : l.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let D = h; D < B && s.length > 0; D++) {
            const z = s.shift();
            z.abortController.signal.aborted ? D-- : y(z);
          }
        }, C = (B, D) => new Promise((z, N) => {
          const X = new Image(), Z = B.url, W = B.credentials;
          W && W === "include" ? X.crossOrigin = "use-credentials" : (W && W === "same-origin" || !l.s(Z)) && (X.crossOrigin = "anonymous"), D.signal.addEventListener("abort", () => {
            X.src = "", N(l.c());
          }), X.fetchPriority = "high", X.onload = () => {
            X.onerror = X.onload = null, z({ data: X });
          }, X.onerror = () => {
            X.onerror = X.onload = null, D.signal.aborted || N(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, X.src = Z;
        });
      }(ie || (ie = {})), ie.resetRequestQueue();
      class ge {
        constructor(s) {
          this._transformRequestFn = s;
        }
        transformRequest(s, h) {
          return this._transformRequestFn && this._transformRequestFn(s, h) || { url: s };
        }
        setTransformRequest(s) {
          this._transformRequestFn = s;
        }
      }
      function Se(g) {
        var s = new l.A(3);
        return s[0] = g[0], s[1] = g[1], s[2] = g[2], s;
      }
      var Re, Le = function(g, s, h) {
        return g[0] = s[0] - h[0], g[1] = s[1] - h[1], g[2] = s[2] - h[2], g;
      };
      Re = new l.A(3), l.A != Float32Array && (Re[0] = 0, Re[1] = 0, Re[2] = 0);
      var _e = function(g) {
        var s = g[0], h = g[1];
        return s * s + h * h;
      };
      function Ge(g) {
        const s = [];
        if (typeof g == "string") s.push({ id: "default", url: g });
        else if (g && g.length > 0) {
          const h = [];
          for (const { id: f, url: m } of g) {
            const y = `${f}${m}`;
            h.indexOf(y) === -1 && (h.push(y), s.push({ id: f, url: m }));
          }
        }
        return s;
      }
      function ke(g, s, h) {
        const f = g.split("?");
        return f[0] += `${s}${h}`, f.join("?");
      }
      (function() {
        var g = new l.A(2);
        l.A != Float32Array && (g[0] = 0, g[1] = 0);
      })();
      class oe {
        constructor(s, h, f, m) {
          this.context = s, this.format = f, this.texture = s.gl.createTexture(), this.update(h, m);
        }
        update(s, h, f) {
          const { width: m, height: y } = s, S = !(this.size && this.size[0] === m && this.size[1] === y || f), { context: C } = this, { gl: B } = C;
          if (this.useMipmap = !!(h && h.useMipmap), B.bindTexture(B.TEXTURE_2D, this.texture), C.pixelStoreUnpackFlipY.set(!1), C.pixelStoreUnpack.set(1), C.pixelStoreUnpackPremultiplyAlpha.set(this.format === B.RGBA && (!h || h.premultiply !== !1)), S) this.size = [m, y], s instanceof HTMLImageElement || s instanceof HTMLCanvasElement || s instanceof HTMLVideoElement || s instanceof ImageData || l.b(s) ? B.texImage2D(B.TEXTURE_2D, 0, this.format, this.format, B.UNSIGNED_BYTE, s) : B.texImage2D(B.TEXTURE_2D, 0, this.format, m, y, 0, this.format, B.UNSIGNED_BYTE, s.data);
          else {
            const { x: D, y: z } = f || { x: 0, y: 0 };
            s instanceof HTMLImageElement || s instanceof HTMLCanvasElement || s instanceof HTMLVideoElement || s instanceof ImageData || l.b(s) ? B.texSubImage2D(B.TEXTURE_2D, 0, D, z, B.RGBA, B.UNSIGNED_BYTE, s) : B.texSubImage2D(B.TEXTURE_2D, 0, D, z, m, y, B.RGBA, B.UNSIGNED_BYTE, s.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && B.generateMipmap(B.TEXTURE_2D);
        }
        bind(s, h, f) {
          const { context: m } = this, { gl: y } = m;
          y.bindTexture(y.TEXTURE_2D, this.texture), f !== y.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (f = y.LINEAR), s !== this.filter && (y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, s), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, f || s), this.filter = s), h !== this.wrap && (y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, h), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, h), this.wrap = h);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: s } = this.context;
          s.deleteTexture(this.texture), this.texture = null;
        }
      }
      function pe(g) {
        const { userImage: s } = g;
        return !!(s && s.render && s.render()) && (g.data.replace(new Uint8Array(s.data.buffer)), !0);
      }
      class Te extends l.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new l.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(s) {
          if (this.loaded !== s && (this.loaded = s, s)) {
            for (const { ids: h, promiseResolve: f } of this.requestors) f(this._getImagesForIds(h));
            this.requestors = [];
          }
        }
        getImage(s) {
          const h = this.images[s];
          if (h && !h.data && h.spriteData) {
            const f = h.spriteData;
            h.data = new l.R({ width: f.width, height: f.height }, f.context.getImageData(f.x, f.y, f.width, f.height).data), h.spriteData = null;
          }
          return h;
        }
        addImage(s, h) {
          if (this.images[s]) throw new Error(`Image id ${s} already exist, use updateImage instead`);
          this._validate(s, h) && (this.images[s] = h);
        }
        _validate(s, h) {
          let f = !0;
          const m = h.data || h.spriteData;
          return this._validateStretch(h.stretchX, m && m.width) || (this.fire(new l.j(new Error(`Image "${s}" has invalid "stretchX" value`))), f = !1), this._validateStretch(h.stretchY, m && m.height) || (this.fire(new l.j(new Error(`Image "${s}" has invalid "stretchY" value`))), f = !1), this._validateContent(h.content, h) || (this.fire(new l.j(new Error(`Image "${s}" has invalid "content" value`))), f = !1), f;
        }
        _validateStretch(s, h) {
          if (!s) return !0;
          let f = 0;
          for (const m of s) {
            if (m[0] < f || m[1] < m[0] || h < m[1]) return !1;
            f = m[1];
          }
          return !0;
        }
        _validateContent(s, h) {
          if (!s) return !0;
          if (s.length !== 4) return !1;
          const f = h.spriteData, m = f && f.width || h.data.width, y = f && f.height || h.data.height;
          return !(s[0] < 0 || m < s[0] || s[1] < 0 || y < s[1] || s[2] < 0 || m < s[2] || s[3] < 0 || y < s[3] || s[2] < s[0] || s[3] < s[1]);
        }
        updateImage(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          const m = this.getImage(s);
          if (f && (m.data.width !== h.data.width || m.data.height !== h.data.height)) throw new Error(`size mismatch between old image (${m.data.width}x${m.data.height}) and new image (${h.data.width}x${h.data.height}).`);
          h.version = m.version + 1, this.images[s] = h, this.updatedImages[s] = !0;
        }
        removeImage(s) {
          const h = this.images[s];
          delete this.images[s], delete this.patterns[s], h.userImage && h.userImage.onRemove && h.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(s) {
          return new Promise((h, f) => {
            let m = !0;
            if (!this.isLoaded()) for (const y of s) this.images[y] || (m = !1);
            this.isLoaded() || m ? h(this._getImagesForIds(s)) : this.requestors.push({ ids: s, promiseResolve: h });
          });
        }
        _getImagesForIds(s) {
          const h = {};
          for (const f of s) {
            let m = this.getImage(f);
            m || (this.fire(new l.k("styleimagemissing", { id: f })), m = this.getImage(f)), m ? h[f] = { data: m.data.clone(), pixelRatio: m.pixelRatio, sdf: m.sdf, version: m.version, stretchX: m.stretchX, stretchY: m.stretchY, content: m.content, textFitWidth: m.textFitWidth, textFitHeight: m.textFitHeight, hasRenderCallback: !!(m.userImage && m.userImage.render) } : l.w(`Image "${f}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return h;
        }
        getPixelSize() {
          const { width: s, height: h } = this.atlasImage;
          return { width: s, height: h };
        }
        getPattern(s) {
          const h = this.patterns[s], f = this.getImage(s);
          if (!f) return null;
          if (h && h.position.version === f.version) return h.position;
          if (h) h.position.version = f.version;
          else {
            const m = { w: f.data.width + 2, h: f.data.height + 2, x: 0, y: 0 }, y = new l.I(m, f);
            this.patterns[s] = { bin: m, position: y };
          }
          return this._updatePatternAtlas(), this.patterns[s].position;
        }
        bind(s) {
          const h = s.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new oe(s, this.atlasImage, h.RGBA), this.atlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const s = [];
          for (const y in this.patterns) s.push(this.patterns[y].bin);
          const { w: h, h: f } = l.p(s), m = this.atlasImage;
          m.resize({ width: h || 1, height: f || 1 });
          for (const y in this.patterns) {
            const { bin: S } = this.patterns[y], C = S.x + 1, B = S.y + 1, D = this.getImage(y).data, z = D.width, N = D.height;
            l.R.copy(D, m, { x: 0, y: 0 }, { x: C, y: B }, { width: z, height: N }), l.R.copy(D, m, { x: 0, y: N - 1 }, { x: C, y: B - 1 }, { width: z, height: 1 }), l.R.copy(D, m, { x: 0, y: 0 }, { x: C, y: B + N }, { width: z, height: 1 }), l.R.copy(D, m, { x: z - 1, y: 0 }, { x: C - 1, y: B }, { width: 1, height: N }), l.R.copy(D, m, { x: 0, y: 0 }, { x: C + z, y: B }, { width: 1, height: N });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(s) {
          for (const h of s) {
            if (this.callbackDispatchedThisFrame[h]) continue;
            this.callbackDispatchedThisFrame[h] = !0;
            const f = this.getImage(h);
            f || l.w(`Image with ID: "${h}" was not found`), pe(f) && this.updateImage(h, f);
          }
        }
      }
      const xe = 1e20;
      function et(g, s, h, f, m, y, S, C, B) {
        for (let D = s; D < s + f; D++) rt(g, h * y + D, y, m, S, C, B);
        for (let D = h; D < h + m; D++) rt(g, D * y + s, 1, f, S, C, B);
      }
      function rt(g, s, h, f, m, y, S) {
        y[0] = 0, S[0] = -xe, S[1] = xe, m[0] = g[s];
        for (let C = 1, B = 0, D = 0; C < f; C++) {
          m[C] = g[s + C * h];
          const z = C * C;
          do {
            const N = y[B];
            D = (m[C] - m[N] + z - N * N) / (C - N) / 2;
          } while (D <= S[B] && --B > -1);
          B++, y[B] = C, S[B] = D, S[B + 1] = xe;
        }
        for (let C = 0, B = 0; C < f; C++) {
          for (; S[B + 1] < C; ) B++;
          const D = y[B], z = C - D;
          g[s + C * h] = m[D] + z * z;
        }
      }
      class st {
        constructor(s, h) {
          this.requestManager = s, this.localIdeographFontFamily = h, this.entries = {};
        }
        setURL(s) {
          this.url = s;
        }
        getGlyphs(s) {
          return l._(this, void 0, void 0, function* () {
            const h = [];
            for (const y in s) for (const S of s[y]) h.push(this._getAndCacheGlyphsPromise(y, S));
            const f = yield Promise.all(h), m = {};
            for (const { stack: y, id: S, glyph: C } of f) m[y] || (m[y] = {}), m[y][S] = C && { id: C.id, bitmap: C.bitmap.clone(), metrics: C.metrics };
            return m;
          });
        }
        _getAndCacheGlyphsPromise(s, h) {
          return l._(this, void 0, void 0, function* () {
            let f = this.entries[s];
            f || (f = this.entries[s] = { glyphs: {}, requests: {}, ranges: {} });
            let m = f.glyphs[h];
            if (m !== void 0) return { stack: s, id: h, glyph: m };
            if (m = this._tinySDF(f, s, h), m) return f.glyphs[h] = m, { stack: s, id: h, glyph: m };
            const y = Math.floor(h / 256);
            if (256 * y > 65535) throw new Error("glyphs > 65535 not supported");
            if (f.ranges[y]) return { stack: s, id: h, glyph: m };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!f.requests[y]) {
              const C = st.loadGlyphRange(s, y, this.url, this.requestManager);
              f.requests[y] = C;
            }
            const S = yield f.requests[y];
            for (const C in S) this._doesCharSupportLocalGlyph(+C) || (f.glyphs[+C] = S[+C]);
            return f.ranges[y] = !0, { stack: s, id: h, glyph: S[h] || null };
          });
        }
        _doesCharSupportLocalGlyph(s) {
          return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(s));
        }
        _tinySDF(s, h, f) {
          const m = this.localIdeographFontFamily;
          if (!m || !this._doesCharSupportLocalGlyph(f)) return;
          let y = s.tinySDF;
          if (!y) {
            let C = "400";
            /bold/i.test(h) ? C = "900" : /medium/i.test(h) ? C = "500" : /light/i.test(h) && (C = "200"), y = s.tinySDF = new st.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: m, fontWeight: C });
          }
          const S = y.draw(String.fromCharCode(f));
          return { id: f, bitmap: new l.o({ width: S.width || 60, height: S.height || 60 }, S.data), metrics: { width: S.glyphWidth / 2 || 24, height: S.glyphHeight / 2 || 24, left: S.glyphLeft / 2 + 0.5 || 0, top: S.glyphTop / 2 - 27.5 || -8, advance: S.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      st.loadGlyphRange = function(g, s, h, f) {
        return l._(this, void 0, void 0, function* () {
          const m = 256 * s, y = m + 255, S = f.transformRequest(h.replace("{fontstack}", g).replace("{range}", `${m}-${y}`), "Glyphs"), C = yield l.l(S, new AbortController());
          if (!C || !C.data) throw new Error(`Could not load glyph range. range: ${s}, ${m}-${y}`);
          const B = {};
          for (const D of l.n(C.data)) B[D.id] = D;
          return B;
        });
      }, st.TinySDF = class {
        constructor() {
          let { fontSize: g = 24, buffer: s = 3, radius: h = 8, cutoff: f = 0.25, fontFamily: m = "sans-serif", fontWeight: y = "normal", fontStyle: S = "normal" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.buffer = s, this.cutoff = f, this.radius = h;
          const C = this.size = g + 4 * s, B = this._createCanvas(C), D = this.ctx = B.getContext("2d", { willReadFrequently: !0 });
          D.font = `${S} ${y} ${g}px ${m}`, D.textBaseline = "alphabetic", D.textAlign = "left", D.fillStyle = "black", this.gridOuter = new Float64Array(C * C), this.gridInner = new Float64Array(C * C), this.f = new Float64Array(C), this.z = new Float64Array(C + 1), this.v = new Uint16Array(C);
        }
        _createCanvas(g) {
          const s = document.createElement("canvas");
          return s.width = s.height = g, s;
        }
        draw(g) {
          const { width: s, actualBoundingBoxAscent: h, actualBoundingBoxDescent: f, actualBoundingBoxLeft: m, actualBoundingBoxRight: y } = this.ctx.measureText(g), S = Math.ceil(h), C = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(y - m))), B = Math.min(this.size - this.buffer, S + Math.ceil(f)), D = C + 2 * this.buffer, z = B + 2 * this.buffer, N = Math.max(D * z, 0), X = new Uint8ClampedArray(N), Z = { data: X, width: D, height: z, glyphWidth: C, glyphHeight: B, glyphTop: S, glyphLeft: 0, glyphAdvance: s };
          if (C === 0 || B === 0) return Z;
          const { ctx: W, buffer: Q, gridInner: le, gridOuter: ue } = this;
          W.clearRect(Q, Q, C, B), W.fillText(g, Q, Q + S);
          const fe = W.getImageData(Q, Q, C, B);
          ue.fill(xe, 0, N), le.fill(0, 0, N);
          for (let he = 0; he < B; he++) for (let ve = 0; ve < C; ve++) {
            const Be = fe.data[4 * (he * C + ve) + 3] / 255;
            if (Be === 0) continue;
            const Pe = (he + Q) * D + ve + Q;
            if (Be === 1) ue[Pe] = 0, le[Pe] = xe;
            else {
              const Qe = 0.5 - Be;
              ue[Pe] = Qe > 0 ? Qe * Qe : 0, le[Pe] = Qe < 0 ? Qe * Qe : 0;
            }
          }
          et(ue, 0, 0, D, z, D, this.f, this.v, this.z), et(le, Q, Q, C, B, D, this.f, this.v, this.z);
          for (let he = 0; he < N; he++) {
            const ve = Math.sqrt(ue[he]) - Math.sqrt(le[he]);
            X[he] = Math.round(255 - 255 * (ve / this.radius + this.cutoff));
          }
          return Z;
        }
      };
      class Je {
        constructor() {
          this.specification = l.v.light.position;
        }
        possiblyEvaluate(s, h) {
          return l.x(s.expression.evaluate(h));
        }
        interpolate(s, h, f) {
          return { x: l.y.number(s.x, h.x, f), y: l.y.number(s.y, h.y, f), z: l.y.number(s.z, h.z, f) };
        }
      }
      let ct;
      class ot extends l.E {
        constructor(s) {
          super(), ct = ct || new l.q({ anchor: new l.D(l.v.light.anchor), position: new Je(), color: new l.D(l.v.light.color), intensity: new l.D(l.v.light.intensity) }), this._transitionable = new l.T(ct), this.setLight(s), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this._validate(l.r, s, h)) for (const f in s) {
            const m = s[f];
            f.endsWith("-transition") ? this._transitionable.setTransition(f.slice(0, -11), m) : this._transitionable.setValue(f, m);
          }
        }
        updateTransitions(s) {
          this._transitioning = this._transitionable.transitioned(s, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(s) {
          this.properties = this._transitioning.possiblyEvaluate(s);
        }
        _validate(s, h, f) {
          return (!f || f.validate !== !1) && l.t(this, s.call(l.u, { value: h, style: { glyphs: !0, sprite: !0 }, styleSpec: l.v }));
        }
      }
      const Mt = new l.q({ "sky-color": new l.D(l.v.sky["sky-color"]), "horizon-color": new l.D(l.v.sky["horizon-color"]), "fog-color": new l.D(l.v.sky["fog-color"]), "fog-ground-blend": new l.D(l.v.sky["fog-ground-blend"]), "horizon-fog-blend": new l.D(l.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new l.D(l.v.sky["sky-horizon-blend"]), "atmosphere-blend": new l.D(l.v.sky["atmosphere-blend"]) });
      class re extends l.E {
        constructor(s) {
          super(), this._transitionable = new l.T(Mt), this.setSky(s), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new l.z(0));
        }
        setSky(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this._validate(l.B, s, h)) {
            s || (s = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const f in s) {
              const m = s[f];
              f.endsWith("-transition") ? this._transitionable.setTransition(f.slice(0, -11), m) : this._transitionable.setValue(f, m);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(s) {
          this._transitioning = this._transitionable.transitioned(s, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(s) {
          this.properties = this._transitioning.possiblyEvaluate(s);
        }
        _validate(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return (f == null ? void 0 : f.validate) !== !1 && l.t(this, s.call(l.u, l.e({ value: h, style: { glyphs: !0, sprite: !0 }, styleSpec: l.v })));
        }
        calculateFogBlendOpacity(s) {
          return s < 60 ? 0 : s < 70 ? (s - 60) / 10 : 1;
        }
      }
      class Ae {
        constructor(s, h) {
          this.width = s, this.height = h, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(s, h) {
          const f = s.join(",") + String(h);
          return this.dashEntry[f] || (this.dashEntry[f] = this.addDash(s, h)), this.dashEntry[f];
        }
        getDashRanges(s, h, f) {
          const m = [];
          let y = s.length % 2 == 1 ? -s[s.length - 1] * f : 0, S = s[0] * f, C = !0;
          m.push({ left: y, right: S, isDash: C, zeroLength: s[0] === 0 });
          let B = s[0];
          for (let D = 1; D < s.length; D++) {
            C = !C;
            const z = s[D];
            y = B * f, B += z, S = B * f, m.push({ left: y, right: S, isDash: C, zeroLength: z === 0 });
          }
          return m;
        }
        addRoundDash(s, h, f) {
          const m = h / 2;
          for (let y = -f; y <= f; y++) {
            const S = this.width * (this.nextRow + f + y);
            let C = 0, B = s[C];
            for (let D = 0; D < this.width; D++) {
              D / B.right > 1 && (B = s[++C]);
              const z = Math.abs(D - B.left), N = Math.abs(D - B.right), X = Math.min(z, N);
              let Z;
              const W = y / f * (m + 1);
              if (B.isDash) {
                const Q = m - Math.abs(W);
                Z = Math.sqrt(X * X + Q * Q);
              } else Z = m - Math.sqrt(X * X + W * W);
              this.data[S + D] = Math.max(0, Math.min(255, Z + 128));
            }
          }
        }
        addRegularDash(s) {
          for (let C = s.length - 1; C >= 0; --C) {
            const B = s[C], D = s[C + 1];
            B.zeroLength ? s.splice(C, 1) : D && D.isDash === B.isDash && (D.left = B.left, s.splice(C, 1));
          }
          const h = s[0], f = s[s.length - 1];
          h.isDash === f.isDash && (h.left = f.left - this.width, f.right = h.right + this.width);
          const m = this.width * this.nextRow;
          let y = 0, S = s[y];
          for (let C = 0; C < this.width; C++) {
            C / S.right > 1 && (S = s[++y]);
            const B = Math.abs(C - S.left), D = Math.abs(C - S.right), z = Math.min(B, D);
            this.data[m + C] = Math.max(0, Math.min(255, (S.isDash ? z : -z) + 128));
          }
        }
        addDash(s, h) {
          const f = h ? 7 : 0, m = 2 * f + 1;
          if (this.nextRow + m > this.height) return l.w("LineAtlas out of space"), null;
          let y = 0;
          for (let C = 0; C < s.length; C++) y += s[C];
          if (y !== 0) {
            const C = this.width / y, B = this.getDashRanges(s, this.width, C);
            h ? this.addRoundDash(B, C, f) : this.addRegularDash(B);
          }
          const S = { y: (this.nextRow + f + 0.5) / this.height, height: 2 * f / this.height, width: y };
          return this.nextRow += m, this.dirty = !0, S;
        }
        bind(s) {
          const h = s.gl;
          this.texture ? (h.bindTexture(h.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, this.width, this.height, h.ALPHA, h.UNSIGNED_BYTE, this.data))) : (this.texture = h.createTexture(), h.bindTexture(h.TEXTURE_2D, this.texture), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR), h.texImage2D(h.TEXTURE_2D, 0, h.ALPHA, this.width, this.height, 0, h.ALPHA, h.UNSIGNED_BYTE, this.data));
        }
      }
      const Ce = "maplibre_preloaded_worker_pool";
      class Ue {
        constructor() {
          this.active = {};
        }
        acquire(s) {
          if (!this.workers) for (this.workers = []; this.workers.length < Ue.workerCount; ) this.workers.push(new Worker(l.a.WORKER_URL));
          return this.active[s] = !0, this.workers.slice();
        }
        release(s) {
          delete this.active[s], this.numActive() === 0 && (this.workers.forEach((h) => {
            h.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Ce];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const qe = Math.floor(T.hardwareConcurrency / 2);
      let He, Ye;
      function Ze() {
        return He || (He = new Ue()), He;
      }
      Ue.workerCount = l.C(globalThis) ? Math.max(Math.min(qe, 3), 1) : 1;
      class St {
        constructor(s, h) {
          this.workerPool = s, this.actors = [], this.currentActor = 0, this.id = h;
          const f = this.workerPool.acquire(h);
          for (let m = 0; m < f.length; m++) {
            const y = new l.F(f[m], h);
            y.name = `Worker ${m}`, this.actors.push(y);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(s, h) {
          const f = [];
          for (const m of this.actors) f.push(m.sendAsync({ type: s, data: h }));
          return Promise.all(f);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          this.actors.forEach((h) => {
            h.remove();
          }), this.actors = [], s && this.workerPool.release(this.id);
        }
        registerMessageHandler(s, h) {
          for (const f of this.actors) f.registerMessageHandler(s, h);
        }
      }
      function Lt() {
        return Ye || (Ye = new St(Ze(), l.G), Ye.registerMessageHandler("GR", (g, s, h) => l.m(s, h))), Ye;
      }
      function Dt(g, s) {
        const h = l.H();
        return l.J(h, h, [1, 1, 0]), l.K(h, h, [0.5 * g.width, 0.5 * g.height, 1]), l.L(h, h, g.calculatePosMatrix(s.toUnwrapped()));
      }
      function Nt(g, s, h, f, m, y) {
        const S = function(N, X, Z) {
          if (N) for (const W of N) {
            const Q = X[W];
            if (Q && Q.source === Z && Q.type === "fill-extrusion") return !0;
          }
          else for (const W in X) {
            const Q = X[W];
            if (Q.source === Z && Q.type === "fill-extrusion") return !0;
          }
          return !1;
        }(m && m.layers, s, g.id), C = y.maxPitchScaleFactor(), B = g.tilesIn(f, C, S);
        B.sort(an);
        const D = [];
        for (const N of B) D.push({ wrappedTileID: N.tileID.wrapped().key, queryResults: N.tile.queryRenderedFeatures(s, h, g._state, N.queryGeometry, N.cameraQueryGeometry, N.scale, m, y, C, Dt(g.transform, N.tileID)) });
        const z = function(N) {
          const X = {}, Z = {};
          for (const W of N) {
            const Q = W.queryResults, le = W.wrappedTileID, ue = Z[le] = Z[le] || {};
            for (const fe in Q) {
              const he = Q[fe], ve = ue[fe] = ue[fe] || {}, Be = X[fe] = X[fe] || [];
              for (const Pe of he) ve[Pe.featureIndex] || (ve[Pe.featureIndex] = !0, Be.push(Pe));
            }
          }
          return X;
        }(D);
        for (const N in z) z[N].forEach((X) => {
          const Z = X.feature, W = g.getFeatureState(Z.layer["source-layer"], Z.id);
          Z.source = Z.layer.source, Z.layer["source-layer"] && (Z.sourceLayer = Z.layer["source-layer"]), Z.state = W;
        });
        return z;
      }
      function an(g, s) {
        const h = g.tileID, f = s.tileID;
        return h.overscaledZ - f.overscaledZ || h.canonical.y - f.canonical.y || h.wrap - f.wrap || h.canonical.x - f.canonical.x;
      }
      function at(g, s, h) {
        return l._(this, void 0, void 0, function* () {
          let f = g;
          if (g.url ? f = (yield l.h(s.transformRequest(g.url, "Source"), h)).data : yield T.frameAsync(h), !f) return null;
          const m = l.M(l.e(f, g), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in f && f.vector_layers && (m.vectorLayerIds = f.vector_layers.map((y) => y.id)), m;
        });
      }
      class ne {
        constructor(s, h) {
          s && (h ? this.setSouthWest(s).setNorthEast(h) : Array.isArray(s) && (s.length === 4 ? this.setSouthWest([s[0], s[1]]).setNorthEast([s[2], s[3]]) : this.setSouthWest(s[0]).setNorthEast(s[1])));
        }
        setNorthEast(s) {
          return this._ne = s instanceof l.N ? new l.N(s.lng, s.lat) : l.N.convert(s), this;
        }
        setSouthWest(s) {
          return this._sw = s instanceof l.N ? new l.N(s.lng, s.lat) : l.N.convert(s), this;
        }
        extend(s) {
          const h = this._sw, f = this._ne;
          let m, y;
          if (s instanceof l.N) m = s, y = s;
          else {
            if (!(s instanceof ne)) return Array.isArray(s) ? s.length === 4 || s.every(Array.isArray) ? this.extend(ne.convert(s)) : this.extend(l.N.convert(s)) : s && ("lng" in s || "lon" in s) && "lat" in s ? this.extend(l.N.convert(s)) : this;
            if (m = s._sw, y = s._ne, !m || !y) return this;
          }
          return h || f ? (h.lng = Math.min(m.lng, h.lng), h.lat = Math.min(m.lat, h.lat), f.lng = Math.max(y.lng, f.lng), f.lat = Math.max(y.lat, f.lat)) : (this._sw = new l.N(m.lng, m.lat), this._ne = new l.N(y.lng, y.lat)), this;
        }
        getCenter() {
          return new l.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new l.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new l.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(s) {
          const { lng: h, lat: f } = l.N.convert(s);
          let m = this._sw.lng <= h && h <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (m = this._sw.lng >= h && h >= this._ne.lng), this._sw.lat <= f && f <= this._ne.lat && m;
        }
        static convert(s) {
          return s instanceof ne ? s : s && new ne(s);
        }
        static fromLngLat(s) {
          const f = 360 * (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) / 40075017, m = f / Math.cos(Math.PI / 180 * s.lat);
          return new ne(new l.N(s.lng - m, s.lat - f), new l.N(s.lng + m, s.lat + f));
        }
        adjustAntiMeridian() {
          const s = new l.N(this._sw.lng, this._sw.lat), h = new l.N(this._ne.lng, this._ne.lat);
          return new ne(s, s.lng > h.lng ? new l.N(h.lng + 360, h.lat) : h);
        }
      }
      class pn {
        constructor(s, h, f) {
          this.bounds = ne.convert(this.validateBounds(s)), this.minzoom = h || 0, this.maxzoom = f || 24;
        }
        validateBounds(s) {
          return Array.isArray(s) && s.length === 4 ? [Math.max(-180, s[0]), Math.max(-90, s[1]), Math.min(180, s[2]), Math.min(90, s[3])] : [-180, -90, 180, 90];
        }
        contains(s) {
          const h = Math.pow(2, s.z), f = Math.floor(l.O(this.bounds.getWest()) * h), m = Math.floor(l.Q(this.bounds.getNorth()) * h), y = Math.ceil(l.O(this.bounds.getEast()) * h), S = Math.ceil(l.Q(this.bounds.getSouth()) * h);
          return s.x >= f && s.x < y && s.y >= m && s.y < S;
        }
      }
      class Qt extends l.E {
        constructor(s, h, f, m) {
          if (super(), this.id = s, this.dispatcher = f, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, l.e(this, l.M(h, ["url", "scheme", "tileSize", "promoteId"])), this._options = l.e({ type: "vector" }, h), this._collectResourceTiming = h.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(m);
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const s = yield at(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), s && (l.e(this, s), s.bounds && (this.tileBounds = new pn(s.bounds, this.minzoom, this.maxzoom)), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (s) {
              this._tileJSONRequest = null, this.fire(new l.j(s));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(s) {
          return !this.tileBounds || this.tileBounds.contains(s.canonical);
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        setSourceProperty(s) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), s(), this.load();
        }
        setTiles(s) {
          return this.setSourceProperty(() => {
            this._options.tiles = s;
          }), this;
        }
        setUrl(s) {
          return this.setSourceProperty(() => {
            this.url = s, this._options.url = s;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return l.e({}, this._options);
        }
        loadTile(s) {
          return l._(this, void 0, void 0, function* () {
            const h = s.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), f = { request: this.map._requestManager.transformRequest(h, "Tile"), uid: s.uid, tileID: s.tileID, zoom: s.tileID.overscaledZ, tileSize: this.tileSize * s.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            f.request.collectResourceTiming = this._collectResourceTiming;
            let m = "RT";
            if (s.actor && s.state !== "expired") {
              if (s.state === "loading") return new Promise((y, S) => {
                s.reloadPromise = { resolve: y, reject: S };
              });
            } else s.actor = this.dispatcher.getActor(), m = "LT";
            s.abortController = new AbortController();
            try {
              const y = yield s.actor.sendAsync({ type: m, data: f }, s.abortController);
              if (delete s.abortController, s.aborted) return;
              this._afterTileLoadWorkerResponse(s, y);
            } catch (y) {
              if (delete s.abortController, s.aborted) return;
              if (y && y.status !== 404) throw y;
              this._afterTileLoadWorkerResponse(s, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(s, h) {
          if (h && h.resourceTiming && (s.resourceTiming = h.resourceTiming), h && this.map._refreshExpiredTiles && s.setExpiryData(h), s.loadVectorData(h, this.map.painter), s.reloadPromise) {
            const f = s.reloadPromise;
            s.reloadPromise = null, this.loadTile(s).then(f.resolve).catch(f.reject);
          }
        }
        abortTile(s) {
          return l._(this, void 0, void 0, function* () {
            s.abortController && (s.abortController.abort(), delete s.abortController), s.actor && (yield s.actor.sendAsync({ type: "AT", data: { uid: s.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(s) {
          return l._(this, void 0, void 0, function* () {
            s.unloadVectorData(), s.actor && (yield s.actor.sendAsync({ type: "RMT", data: { uid: s.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class dt extends l.E {
        constructor(s, h, f, m) {
          super(), this.id = s, this.dispatcher = f, this.setEventedParent(m), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = l.e({ type: "raster" }, h), l.e(this, l.M(h, ["url", "scheme", "tileSize"]));
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const s = yield at(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, s && (l.e(this, s), s.bounds && (this.tileBounds = new pn(s.bounds, this.minzoom, this.maxzoom)), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (s) {
              this._tileJSONRequest = null, this.fire(new l.j(s));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(s) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), s(), this.load();
        }
        setTiles(s) {
          return this.setSourceProperty(() => {
            this._options.tiles = s;
          }), this;
        }
        setUrl(s) {
          return this.setSourceProperty(() => {
            this.url = s, this._options.url = s;
          }), this;
        }
        serialize() {
          return l.e({}, this._options);
        }
        hasTile(s) {
          return !this.tileBounds || this.tileBounds.contains(s.canonical);
        }
        loadTile(s) {
          return l._(this, void 0, void 0, function* () {
            const h = s.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            s.abortController = new AbortController();
            try {
              const f = yield ie.getImage(this.map._requestManager.transformRequest(h, "Tile"), s.abortController, this.map._refreshExpiredTiles);
              if (delete s.abortController, s.aborted) return void (s.state = "unloaded");
              if (f && f.data) {
                this.map._refreshExpiredTiles && f.cacheControl && f.expires && s.setExpiryData({ cacheControl: f.cacheControl, expires: f.expires });
                const m = this.map.painter.context, y = m.gl, S = f.data;
                s.texture = this.map.painter.getTileTexture(S.width), s.texture ? s.texture.update(S, { useMipmap: !0 }) : (s.texture = new oe(m, S, y.RGBA, { useMipmap: !0 }), s.texture.bind(y.LINEAR, y.CLAMP_TO_EDGE, y.LINEAR_MIPMAP_NEAREST)), s.state = "loaded";
              }
            } catch (f) {
              if (delete s.abortController, s.aborted) s.state = "unloaded";
              else if (f) throw s.state = "errored", f;
            }
          });
        }
        abortTile(s) {
          return l._(this, void 0, void 0, function* () {
            s.abortController && (s.abortController.abort(), delete s.abortController);
          });
        }
        unloadTile(s) {
          return l._(this, void 0, void 0, function* () {
            s.texture && this.map.painter.saveTileTexture(s.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class Et extends dt {
        constructor(s, h, f, m) {
          super(s, h, f, m), this.type = "raster-dem", this.maxzoom = 22, this._options = l.e({ type: "raster-dem" }, h), this.encoding = h.encoding || "mapbox", this.redFactor = h.redFactor, this.greenFactor = h.greenFactor, this.blueFactor = h.blueFactor, this.baseShift = h.baseShift;
        }
        loadTile(s) {
          return l._(this, void 0, void 0, function* () {
            const h = s.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), f = this.map._requestManager.transformRequest(h, "Tile");
            s.neighboringTiles = this._getNeighboringTiles(s.tileID), s.abortController = new AbortController();
            try {
              const m = yield ie.getImage(f, s.abortController, this.map._refreshExpiredTiles);
              if (delete s.abortController, s.aborted) return void (s.state = "unloaded");
              if (m && m.data) {
                const y = m.data;
                this.map._refreshExpiredTiles && m.cacheControl && m.expires && s.setExpiryData({ cacheControl: m.cacheControl, expires: m.expires });
                const S = l.b(y) && l.U() ? y : yield this.readImageNow(y), C = { type: this.type, uid: s.uid, source: this.id, rawImageData: S, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!s.actor || s.state === "expired") {
                  s.actor = this.dispatcher.getActor();
                  const B = yield s.actor.sendAsync({ type: "LDT", data: C });
                  s.dem = B, s.needsHillshadePrepare = !0, s.needsTerrainPrepare = !0, s.state = "loaded";
                }
              }
            } catch (m) {
              if (delete s.abortController, s.aborted) s.state = "unloaded";
              else if (m) throw s.state = "errored", m;
            }
          });
        }
        readImageNow(s) {
          return l._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && l.V()) {
              const h = s.width + 2, f = s.height + 2;
              try {
                return new l.R({ width: h, height: f }, yield l.W(s, -1, -1, h, f));
              } catch {
              }
            }
            return T.getImageData(s, 1);
          });
        }
        _getNeighboringTiles(s) {
          const h = s.canonical, f = Math.pow(2, h.z), m = (h.x - 1 + f) % f, y = h.x === 0 ? s.wrap - 1 : s.wrap, S = (h.x + 1 + f) % f, C = h.x + 1 === f ? s.wrap + 1 : s.wrap, B = {};
          return B[new l.S(s.overscaledZ, y, h.z, m, h.y).key] = { backfilled: !1 }, B[new l.S(s.overscaledZ, C, h.z, S, h.y).key] = { backfilled: !1 }, h.y > 0 && (B[new l.S(s.overscaledZ, y, h.z, m, h.y - 1).key] = { backfilled: !1 }, B[new l.S(s.overscaledZ, s.wrap, h.z, h.x, h.y - 1).key] = { backfilled: !1 }, B[new l.S(s.overscaledZ, C, h.z, S, h.y - 1).key] = { backfilled: !1 }), h.y + 1 < f && (B[new l.S(s.overscaledZ, y, h.z, m, h.y + 1).key] = { backfilled: !1 }, B[new l.S(s.overscaledZ, s.wrap, h.z, h.x, h.y + 1).key] = { backfilled: !1 }, B[new l.S(s.overscaledZ, C, h.z, S, h.y + 1).key] = { backfilled: !1 }), B;
        }
        unloadTile(s) {
          return l._(this, void 0, void 0, function* () {
            s.demTexture && this.map.painter.saveTileTexture(s.demTexture), s.fbo && (s.fbo.destroy(), delete s.fbo), s.dem && delete s.dem, delete s.neighboringTiles, s.state = "unloaded", s.actor && (yield s.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: s.uid, source: this.id } }));
          });
        }
      }
      class Bt extends l.E {
        constructor(s, h, f, m) {
          super(), this.id = s, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = f.getActor(), this.setEventedParent(m), this._data = h.data, this._options = l.e({}, h), this._collectResourceTiming = h.collectResourceTiming, h.maxzoom !== void 0 && (this.maxzoom = h.maxzoom), h.type && (this.type = h.type), h.attribution && (this.attribution = h.attribution), this.promoteId = h.promoteId;
          const y = l.X / this.tileSize;
          h.clusterMaxZoom !== void 0 && this.maxzoom <= h.clusterMaxZoom && l.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${h.clusterMaxZoom}".`), this.workerOptions = l.e({ source: this.id, cluster: h.cluster || !1, geojsonVtOptions: { buffer: (h.buffer !== void 0 ? h.buffer : 128) * y, tolerance: (h.tolerance !== void 0 ? h.tolerance : 0.375) * y, extent: l.X, maxZoom: this.maxzoom, lineMetrics: h.lineMetrics || !1, generateId: h.generateId || !1 }, superclusterOptions: { maxZoom: h.clusterMaxZoom !== void 0 ? h.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, h.clusterMinPoints || 2), extent: l.X, radius: (h.clusterRadius || 50) * y, log: !1, generateId: h.generateId || !1 }, clusterProperties: h.clusterProperties, filter: h.filter }, h.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        setData(s) {
          return this._data = s, this._updateWorkerData(), this;
        }
        updateData(s) {
          return this._updateWorkerData(s), this;
        }
        getData() {
          return l._(this, void 0, void 0, function* () {
            const s = l.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: s });
          });
        }
        setClusterOptions(s) {
          return this.workerOptions.cluster = s.cluster, s && (s.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = s.clusterRadius), s.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = s.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(s) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: s, source: this.id } });
        }
        getClusterChildren(s) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: s, source: this.id } });
        }
        getClusterLeaves(s, h, f) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: s, limit: h, offset: f } });
        }
        _updateWorkerData(s) {
          return l._(this, void 0, void 0, function* () {
            const h = l.e({ type: this.type }, this.workerOptions);
            s ? h.dataDiff = s : typeof this._data == "string" ? (h.request = this.map._requestManager.transformRequest(T.resolveURL(this._data), "Source"), h.request.collectResourceTiming = this._collectResourceTiming) : h.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new l.k("dataloading", { dataType: "source" }));
            try {
              const f = yield this.actor.sendAsync({ type: "LD", data: h });
              if (this._pendingLoads--, this._removed || f.abandoned) return void this.fire(new l.k("dataabort", { dataType: "source" }));
              let m = null;
              f.resourceTiming && f.resourceTiming[this.id] && (m = f.resourceTiming[this.id].slice(0));
              const y = { dataType: "source" };
              this._collectResourceTiming && m && m.length > 0 && l.e(y, { resourceTiming: m }), this.fire(new l.k("data", Object.assign(Object.assign({}, y), { sourceDataType: "metadata" }))), this.fire(new l.k("data", Object.assign(Object.assign({}, y), { sourceDataType: "content" })));
            } catch (f) {
              if (this._pendingLoads--, this._removed) return void this.fire(new l.k("dataabort", { dataType: "source" }));
              this.fire(new l.j(f));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(s) {
          return l._(this, void 0, void 0, function* () {
            const h = s.actor ? "RT" : "LT";
            s.actor = this.actor;
            const f = { type: this.type, uid: s.uid, tileID: s.tileID, zoom: s.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            s.abortController = new AbortController();
            const m = yield this.actor.sendAsync({ type: h, data: f }, s.abortController);
            delete s.abortController, s.unloadVectorData(), s.aborted || s.loadVectorData(m, this.map.painter, h === "RT");
          });
        }
        abortTile(s) {
          return l._(this, void 0, void 0, function* () {
            s.abortController && (s.abortController.abort(), delete s.abortController), s.aborted = !0;
          });
        }
        unloadTile(s) {
          return l._(this, void 0, void 0, function* () {
            s.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: s.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return l.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var Ft = l.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class nn extends l.E {
        constructor(s, h, f, m) {
          super(), this.id = s, this.dispatcher = f, this.coordinates = h.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(m), this.options = h;
        }
        load(s) {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const h = yield ie.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, h && h.data && (this.image = h.data, s && (this.coordinates = s), this._finishLoading());
            } catch (h) {
              this._request = null, this._loaded = !0, this.fire(new l.j(h));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(s) {
          return s.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = s.url, this.load(s.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(s) {
          this.coordinates = s;
          const h = s.map(l.Z.fromLngLat);
          this.tileID = function(m) {
            let y = 1 / 0, S = 1 / 0, C = -1 / 0, B = -1 / 0;
            for (const X of m) y = Math.min(y, X.x), S = Math.min(S, X.y), C = Math.max(C, X.x), B = Math.max(B, X.y);
            const D = Math.max(C - y, B - S), z = Math.max(0, Math.floor(-Math.log(D) / Math.LN2)), N = Math.pow(2, z);
            return new l.a1(z, Math.floor((y + C) / 2 * N), Math.floor((S + B) / 2 * N));
          }(h), this.minzoom = this.maxzoom = this.tileID.z;
          const f = h.map((m) => this.tileID.getTilePoint(m)._round());
          return this._boundsArray = new l.$(), this._boundsArray.emplaceBack(f[0].x, f[0].y, 0, 0), this._boundsArray.emplaceBack(f[1].x, f[1].y, l.X, 0), this._boundsArray.emplaceBack(f[3].x, f[3].y, 0, l.X), this._boundsArray.emplaceBack(f[2].x, f[2].y, l.X, l.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const s = this.map.painter.context, h = s.gl;
          this.boundsBuffer || (this.boundsBuffer = s.createVertexBuffer(this._boundsArray, Ft.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new oe(s, this.image, h.RGBA), this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
          let f = !1;
          for (const m in this.tiles) {
            const y = this.tiles[m];
            y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, f = !0);
          }
          f && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(s) {
          return l._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(s.tileID.canonical) ? (this.tiles[String(s.tileID.wrap)] = s, s.buckets = {}) : s.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class Sn extends nn {
        constructor(s, h, f, m) {
          super(s, h, f, m), this.roundZoom = !0, this.type = "video", this.options = h;
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const s = this.options;
            this.urls = [];
            for (const h of s.urls) this.urls.push(this.map._requestManager.transformRequest(h, "Source").url);
            try {
              const h = yield l.a3(this.urls);
              if (this._loaded = !0, !h) return;
              this.video = h, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (h) {
              this.fire(new l.j(h));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(s) {
          if (this.video) {
            const h = this.video.seekable;
            s < h.start(0) || s > h.end(0) ? this.fire(new l.j(new l.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${h.start(0)} and ${h.end(0)}-second mark.`))) : this.video.currentTime = s;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(s) {
          this.map || (this.map = s, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const s = this.map.painter.context, h = s.gl;
          this.boundsBuffer || (this.boundsBuffer = s.createVertexBuffer(this._boundsArray, Ft.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, h.RGBA, h.UNSIGNED_BYTE, this.video)) : (this.texture = new oe(s, this.video, h.RGBA), this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
          let f = !1;
          for (const m in this.tiles) {
            const y = this.tiles[m];
            y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, f = !0);
          }
          f && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class vn extends nn {
        constructor(s, h, f, m) {
          super(s, h, f, m), h.coordinates ? Array.isArray(h.coordinates) && h.coordinates.length === 4 && !h.coordinates.some((y) => !Array.isArray(y) || y.length !== 2 || y.some((S) => typeof S != "number")) || this.fire(new l.j(new l.a2(`sources.${s}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new l.j(new l.a2(`sources.${s}`, null, 'missing required property "coordinates"'))), h.animate && typeof h.animate != "boolean" && this.fire(new l.j(new l.a2(`sources.${s}`, null, 'optional "animate" property must be a boolean value'))), h.canvas ? typeof h.canvas == "string" || h.canvas instanceof HTMLCanvasElement || this.fire(new l.j(new l.a2(`sources.${s}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new l.j(new l.a2(`sources.${s}`, null, 'missing required property "canvas"'))), this.options = h, this.animate = h.animate === void 0 || h.animate;
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new l.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(s) {
          this.map = s, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let s = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, s = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, s = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const h = this.map.painter.context, f = h.gl;
          this.boundsBuffer || (this.boundsBuffer = h.createVertexBuffer(this._boundsArray, Ft.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (s || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new oe(h, this.canvas, f.RGBA, { premultiply: !0 });
          let m = !1;
          for (const y in this.tiles) {
            const S = this.tiles[y];
            S.state !== "loaded" && (S.state = "loaded", S.texture = this.texture, m = !0);
          }
          m && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const s of [this.canvas.width, this.canvas.height]) if (isNaN(s) || s <= 0) return !0;
          return !1;
        }
      }
      const On = {}, Un = (g) => {
        switch (g) {
          case "geojson":
            return Bt;
          case "image":
            return nn;
          case "raster":
            return dt;
          case "raster-dem":
            return Et;
          case "vector":
            return Qt;
          case "video":
            return Sn;
          case "canvas":
            return vn;
        }
        return On[g];
      }, gt = "RTLPluginLoaded";
      class un extends l.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Lt();
        }
        _syncState(s) {
          return this.status = s, this.dispatcher.broadcast("SRPS", { pluginStatus: s, pluginURL: this.url }).catch((h) => {
            throw this.status = "error", h;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(s) {
          return l._(this, arguments, void 0, function(h) {
            var f = this;
            let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return function* () {
              if (f.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (f.url = T.resolveURL(h), !f.url) throw new Error(`requested url ${h} is invalid`);
              if (f.status === "unavailable") {
                if (!m) return f._requestImport();
                f.status = "deferred", f._syncState(f.status);
              } else if (f.status === "requested") return f._requestImport();
            }();
          });
        }
        _requestImport() {
          return l._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new l.k(gt));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let xn = null;
      function Ot() {
        return xn || (xn = new un()), xn;
      }
      class _r {
        constructor(s, h) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = s, this.uid = l.a4(), this.uses = 0, this.tileSize = h, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(s) {
          const h = s + this.timeAdded;
          h < this.fadeEndTime || (this.fadeEndTime = h);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(s) {
          this.demTexture && s.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(s, h, f) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", s) {
            s.featureIndex && (this.latestFeatureIndex = s.featureIndex, s.rawTileData ? (this.latestRawTileData = s.rawTileData, this.latestFeatureIndex.rawTileData = s.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = s.collisionBoxArray, this.buckets = function(m, y) {
              const S = {};
              if (!y) return S;
              for (const C of m) {
                const B = C.layerIds.map((D) => y.getLayer(D)).filter(Boolean);
                if (B.length !== 0) {
                  C.layers = B, C.stateDependentLayerIds && (C.stateDependentLayers = C.stateDependentLayerIds.map((D) => B.filter((z) => z.id === D)[0]));
                  for (const D of B) S[D.id] = C;
                }
              }
              return S;
            }(s.buckets, h.style), this.hasSymbolBuckets = !1;
            for (const m in this.buckets) {
              const y = this.buckets[m];
              if (y instanceof l.a6) {
                if (this.hasSymbolBuckets = !0, !f) break;
                y.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const m in this.buckets) {
              const y = this.buckets[m];
              if (y instanceof l.a6 && y.hasRTLText) {
                this.hasRTLText = !0, Ot().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const m in this.buckets) {
              const y = this.buckets[m];
              this.queryPadding = Math.max(this.queryPadding, h.style.getLayer(m).queryRadius(y));
            }
            s.imageAtlas && (this.imageAtlas = s.imageAtlas), s.glyphAtlasImage && (this.glyphAtlasImage = s.glyphAtlasImage);
          } else this.collisionBoxArray = new l.a5();
        }
        unloadVectorData() {
          for (const s in this.buckets) this.buckets[s].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(s) {
          return this.buckets[s.id];
        }
        upload(s) {
          for (const f in this.buckets) {
            const m = this.buckets[f];
            m.uploadPending() && m.upload(s);
          }
          const h = s.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new oe(s, this.imageAtlas.image, h.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new oe(s, this.glyphAtlasImage, h.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(s) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(s, this.imageAtlasTexture);
        }
        queryRenderedFeatures(s, h, f, m, y, S, C, B, D, z) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: m, cameraQueryGeometry: y, scale: S, tileSize: this.tileSize, pixelPosMatrix: z, transform: B, params: C, queryPadding: this.queryPadding * D }, s, h, f) : {};
        }
        querySourceFeatures(s, h) {
          const f = this.latestFeatureIndex;
          if (!f || !f.rawTileData) return;
          const m = f.loadVTLayers(), y = h && h.sourceLayer ? h.sourceLayer : "", S = m._geojsonTileLayer || m[y];
          if (!S) return;
          const C = l.a7(h && h.filter), { z: B, x: D, y: z } = this.tileID.canonical, N = { z: B, x: D, y: z };
          for (let X = 0; X < S.length; X++) {
            const Z = S.feature(X);
            if (C.needGeometry) {
              const le = l.a8(Z, !0);
              if (!C.filter(new l.z(this.tileID.overscaledZ), le, this.tileID.canonical)) continue;
            } else if (!C.filter(new l.z(this.tileID.overscaledZ), Z)) continue;
            const W = f.getId(Z, y), Q = new l.a9(Z, B, D, z, W);
            Q.tile = N, s.push(Q);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(s) {
          const h = this.expirationTime;
          if (s.cacheControl) {
            const f = l.aa(s.cacheControl);
            f["max-age"] && (this.expirationTime = Date.now() + 1e3 * f["max-age"]);
          } else s.expires && (this.expirationTime = new Date(s.expires).getTime());
          if (this.expirationTime) {
            const f = Date.now();
            let m = !1;
            if (this.expirationTime > f) m = !1;
            else if (h)
              if (this.expirationTime < h) m = !0;
              else {
                const y = this.expirationTime - h;
                y ? this.expirationTime = f + Math.max(y, 3e4) : m = !0;
              }
            else m = !0;
            m ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(s, h) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(s).length === 0) return;
          const f = this.latestFeatureIndex.loadVTLayers();
          for (const m in this.buckets) {
            if (!h.style.hasLayer(m)) continue;
            const y = this.buckets[m], S = y.layers[0].sourceLayer || "_geojsonTileLayer", C = f[S], B = s[S];
            if (!C || !B || Object.keys(B).length === 0) continue;
            y.update(B, C, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const D = h && h.style && h.style.getLayer(m);
            D && (this.queryPadding = Math.max(this.queryPadding, D.queryRadius(y)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < T.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(s) {
          this.symbolFadeHoldUntil = T.now() + s;
        }
        setDependencies(s, h) {
          const f = {};
          for (const m of h) f[m] = !0;
          this.dependencies[s] = f;
        }
        hasDependency(s, h) {
          for (const f of s) {
            const m = this.dependencies[f];
            if (m) {
              for (const y of h) if (m[y]) return !0;
            }
          }
          return !1;
        }
      }
      class mt {
        constructor(s, h) {
          this.max = s, this.onRemove = h, this.reset();
        }
        reset() {
          for (const s in this.data) for (const h of this.data[s]) h.timeout && clearTimeout(h.timeout), this.onRemove(h.value);
          return this.data = {}, this.order = [], this;
        }
        add(s, h, f) {
          const m = s.wrapped().key;
          this.data[m] === void 0 && (this.data[m] = []);
          const y = { value: h, timeout: void 0 };
          if (f !== void 0 && (y.timeout = setTimeout(() => {
            this.remove(s, y);
          }, f)), this.data[m].push(y), this.order.push(m), this.order.length > this.max) {
            const S = this._getAndRemoveByKey(this.order[0]);
            S && this.onRemove(S);
          }
          return this;
        }
        has(s) {
          return s.wrapped().key in this.data;
        }
        getAndRemove(s) {
          return this.has(s) ? this._getAndRemoveByKey(s.wrapped().key) : null;
        }
        _getAndRemoveByKey(s) {
          const h = this.data[s].shift();
          return h.timeout && clearTimeout(h.timeout), this.data[s].length === 0 && delete this.data[s], this.order.splice(this.order.indexOf(s), 1), h.value;
        }
        getByKey(s) {
          const h = this.data[s];
          return h ? h[0].value : null;
        }
        get(s) {
          return this.has(s) ? this.data[s.wrapped().key][0].value : null;
        }
        remove(s, h) {
          if (!this.has(s)) return this;
          const f = s.wrapped().key, m = h === void 0 ? 0 : this.data[f].indexOf(h), y = this.data[f][m];
          return this.data[f].splice(m, 1), y.timeout && clearTimeout(y.timeout), this.data[f].length === 0 && delete this.data[f], this.onRemove(y.value), this.order.splice(this.order.indexOf(f), 1), this;
        }
        setMaxSize(s) {
          for (this.max = s; this.order.length > this.max; ) {
            const h = this._getAndRemoveByKey(this.order[0]);
            h && this.onRemove(h);
          }
          return this;
        }
        filter(s) {
          const h = [];
          for (const f in this.data) for (const m of this.data[f]) s(m.value) || h.push(m);
          for (const f of h) this.remove(f.value.tileID, f);
        }
      }
      class bn {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(s, h, f) {
          const m = String(h);
          if (this.stateChanges[s] = this.stateChanges[s] || {}, this.stateChanges[s][m] = this.stateChanges[s][m] || {}, l.e(this.stateChanges[s][m], f), this.deletedStates[s] === null) {
            this.deletedStates[s] = {};
            for (const y in this.state[s]) y !== m && (this.deletedStates[s][y] = null);
          } else if (this.deletedStates[s] && this.deletedStates[s][m] === null) {
            this.deletedStates[s][m] = {};
            for (const y in this.state[s][m]) f[y] || (this.deletedStates[s][m][y] = null);
          } else for (const y in f) this.deletedStates[s] && this.deletedStates[s][m] && this.deletedStates[s][m][y] === null && delete this.deletedStates[s][m][y];
        }
        removeFeatureState(s, h, f) {
          if (this.deletedStates[s] === null) return;
          const m = String(h);
          if (this.deletedStates[s] = this.deletedStates[s] || {}, f && h !== void 0) this.deletedStates[s][m] !== null && (this.deletedStates[s][m] = this.deletedStates[s][m] || {}, this.deletedStates[s][m][f] = null);
          else if (h !== void 0)
            if (this.stateChanges[s] && this.stateChanges[s][m]) for (f in this.deletedStates[s][m] = {}, this.stateChanges[s][m]) this.deletedStates[s][m][f] = null;
            else this.deletedStates[s][m] = null;
          else this.deletedStates[s] = null;
        }
        getState(s, h) {
          const f = String(h), m = l.e({}, (this.state[s] || {})[f], (this.stateChanges[s] || {})[f]);
          if (this.deletedStates[s] === null) return {};
          if (this.deletedStates[s]) {
            const y = this.deletedStates[s][h];
            if (y === null) return {};
            for (const S in y) delete m[S];
          }
          return m;
        }
        initializeTileState(s, h) {
          s.setFeatureState(this.state, h);
        }
        coalesceChanges(s, h) {
          const f = {};
          for (const m in this.stateChanges) {
            this.state[m] = this.state[m] || {};
            const y = {};
            for (const S in this.stateChanges[m]) this.state[m][S] || (this.state[m][S] = {}), l.e(this.state[m][S], this.stateChanges[m][S]), y[S] = this.state[m][S];
            f[m] = y;
          }
          for (const m in this.deletedStates) {
            this.state[m] = this.state[m] || {};
            const y = {};
            if (this.deletedStates[m] === null) for (const S in this.state[m]) y[S] = {}, this.state[m][S] = {};
            else for (const S in this.deletedStates[m]) {
              if (this.deletedStates[m][S] === null) this.state[m][S] = {};
              else for (const C of Object.keys(this.deletedStates[m][S])) delete this.state[m][S][C];
              y[S] = this.state[m][S];
            }
            f[m] = f[m] || {}, l.e(f[m], y);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(f).length !== 0) for (const m in s) s[m].setFeatureState(f, h);
        }
      }
      class jt extends l.E {
        constructor(s, h, f) {
          super(), this.id = s, this.dispatcher = f, this.on("data", (m) => this._dataHandler(m)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((m, y, S, C) => {
            const B = new (Un(y.type))(m, y, S, C);
            if (B.id !== m) throw new Error(`Expected Source id to be ${m} instead of ${B.id}`);
            return B;
          })(s, h, f, this), this._tiles = {}, this._cache = new mt(0, (m) => this._unloadTile(m)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new bn(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(s) {
          this.map = s, this._maxTileCacheSize = s ? s._maxTileCacheSize : null, this._maxTileCacheZoomLevels = s ? s._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(s);
        }
        onRemove(s) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(s);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const s in this._tiles) {
            const h = this._tiles[s];
            if (h.state !== "loaded" && h.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const s = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, s && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(s, h, f) {
          return l._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(s), this._tileLoaded(s, h, f);
            } catch (m) {
              s.state = "errored", m.status !== 404 ? this._source.fire(new l.j(m, { tile: s })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(s) {
          this._source.unloadTile && this._source.unloadTile(s);
        }
        _abortTile(s) {
          this._source.abortTile && this._source.abortTile(s), this._source.fire(new l.k("dataabort", { tile: s, coord: s.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(s) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const h in this._tiles) {
            const f = this._tiles[h];
            f.upload(s), f.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((s) => s.tileID).sort(qn).map((s) => s.key);
        }
        getRenderableIds(s) {
          const h = [];
          for (const f in this._tiles) this._isIdRenderable(f, s) && h.push(this._tiles[f]);
          return s ? h.sort((f, m) => {
            const y = f.tileID, S = m.tileID, C = new l.P(y.canonical.x, y.canonical.y)._rotate(this.transform.angle), B = new l.P(S.canonical.x, S.canonical.y)._rotate(this.transform.angle);
            return y.overscaledZ - S.overscaledZ || B.y - C.y || B.x - C.x;
          }).map((f) => f.tileID.key) : h.map((f) => f.tileID).sort(qn).map((f) => f.key);
        }
        hasRenderableParent(s) {
          const h = this.findLoadedParent(s, 0);
          return !!h && this._isIdRenderable(h.tileID.key);
        }
        _isIdRenderable(s, h) {
          return this._tiles[s] && this._tiles[s].hasData() && !this._coveredTiles[s] && (h || !this._tiles[s].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const s in this._tiles) this._tiles[s].state !== "errored" && this._reloadTile(s, "reloading");
          }
        }
        _reloadTile(s, h) {
          return l._(this, void 0, void 0, function* () {
            const f = this._tiles[s];
            f && (f.state !== "loading" && (f.state = h), yield this._loadTile(f, s, h));
          });
        }
        _tileLoaded(s, h, f) {
          s.timeAdded = T.now(), f === "expired" && (s.refreshedUponExpiration = !0), this._setTileReloadTimer(h, s), this.getSource().type === "raster-dem" && s.dem && this._backfillDEM(s), this._state.initializeTileState(s, this.map ? this.map.painter : null), s.aborted || this._source.fire(new l.k("data", { dataType: "source", tile: s, coord: s.tileID }));
        }
        _backfillDEM(s) {
          const h = this.getRenderableIds();
          for (let m = 0; m < h.length; m++) {
            const y = h[m];
            if (s.neighboringTiles && s.neighboringTiles[y]) {
              const S = this.getTileByID(y);
              f(s, S), f(S, s);
            }
          }
          function f(m, y) {
            m.needsHillshadePrepare = !0, m.needsTerrainPrepare = !0;
            let S = y.tileID.canonical.x - m.tileID.canonical.x;
            const C = y.tileID.canonical.y - m.tileID.canonical.y, B = Math.pow(2, m.tileID.canonical.z), D = y.tileID.key;
            S === 0 && C === 0 || Math.abs(C) > 1 || (Math.abs(S) > 1 && (Math.abs(S + B) === 1 ? S += B : Math.abs(S - B) === 1 && (S -= B)), y.dem && m.dem && (m.dem.backfillBorder(y.dem, S, C), m.neighboringTiles && m.neighboringTiles[D] && (m.neighboringTiles[D].backfilled = !0)));
          }
        }
        getTile(s) {
          return this.getTileByID(s.key);
        }
        getTileByID(s) {
          return this._tiles[s];
        }
        _retainLoadedChildren(s, h, f, m) {
          for (const y in this._tiles) {
            let S = this._tiles[y];
            if (m[y] || !S.hasData() || S.tileID.overscaledZ <= h || S.tileID.overscaledZ > f) continue;
            let C = S.tileID;
            for (; S && S.tileID.overscaledZ > h + 1; ) {
              const D = S.tileID.scaledTo(S.tileID.overscaledZ - 1);
              S = this._tiles[D.key], S && S.hasData() && (C = D);
            }
            let B = C;
            for (; B.overscaledZ > h; ) if (B = B.scaledTo(B.overscaledZ - 1), s[B.key]) {
              m[C.key] = C;
              break;
            }
          }
        }
        findLoadedParent(s, h) {
          if (s.key in this._loadedParentTiles) {
            const f = this._loadedParentTiles[s.key];
            return f && f.tileID.overscaledZ >= h ? f : null;
          }
          for (let f = s.overscaledZ - 1; f >= h; f--) {
            const m = s.scaledTo(f), y = this._getLoadedTile(m);
            if (y) return y;
          }
        }
        findLoadedSibling(s) {
          return this._getLoadedTile(s);
        }
        _getLoadedTile(s) {
          const h = this._tiles[s.key];
          return h && h.hasData() ? h : this._cache.getByKey(s.wrapped().key);
        }
        updateCacheSize(s) {
          const h = Math.ceil(s.width / this._source.tileSize) + 1, f = Math.ceil(s.height / this._source.tileSize) + 1, m = Math.floor(h * f * (this._maxTileCacheZoomLevels === null ? l.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), y = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, m) : m;
          this._cache.setMaxSize(y);
        }
        handleWrapJump(s) {
          const h = Math.round((s - (this._prevLng === void 0 ? s : this._prevLng)) / 360);
          if (this._prevLng = s, h) {
            const f = {};
            for (const m in this._tiles) {
              const y = this._tiles[m];
              y.tileID = y.tileID.unwrapTo(y.tileID.wrap + h), f[y.tileID.key] = y;
            }
            this._tiles = f;
            for (const m in this._timers) clearTimeout(this._timers[m]), delete this._timers[m];
            for (const m in this._tiles) this._setTileReloadTimer(m, this._tiles[m]);
          }
        }
        _updateCoveredAndRetainedTiles(s, h, f, m, y, S) {
          const C = {}, B = {}, D = Object.keys(s), z = T.now();
          for (const N of D) {
            const X = s[N], Z = this._tiles[N];
            if (!Z || Z.fadeEndTime !== 0 && Z.fadeEndTime <= z) continue;
            const W = this.findLoadedParent(X, h), Q = this.findLoadedSibling(X), le = W || Q || null;
            le && (this._addTile(le.tileID), C[le.tileID.key] = le.tileID), B[N] = X;
          }
          this._retainLoadedChildren(B, m, f, s);
          for (const N in C) s[N] || (this._coveredTiles[N] = !0, s[N] = C[N]);
          if (S) {
            const N = {}, X = {};
            for (const Z of y) this._tiles[Z.key].hasData() ? N[Z.key] = Z : X[Z.key] = Z;
            for (const Z in X) {
              const W = X[Z].children(this._source.maxzoom);
              this._tiles[W[0].key] && this._tiles[W[1].key] && this._tiles[W[2].key] && this._tiles[W[3].key] && (N[W[0].key] = s[W[0].key] = W[0], N[W[1].key] = s[W[1].key] = W[1], N[W[2].key] = s[W[2].key] = W[2], N[W[3].key] = s[W[3].key] = W[3], delete X[Z]);
            }
            for (const Z in X) {
              const W = X[Z], Q = this.findLoadedParent(W, this._source.minzoom), le = this.findLoadedSibling(W), ue = Q || le || null;
              if (ue) {
                N[ue.tileID.key] = s[ue.tileID.key] = ue.tileID;
                for (const fe in N) N[fe].isChildOf(ue.tileID) && delete N[fe];
              }
            }
            for (const Z in this._tiles) N[Z] || (this._coveredTiles[Z] = !0);
          }
        }
        update(s, h) {
          if (!this._sourceLoaded || this._paused) return;
          let f;
          this.transform = s, this.terrain = h, this.updateCacheSize(s), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? f = s.getVisibleUnwrappedCoordinates(this._source.tileID).map((z) => new l.S(z.canonical.z, z.wrap, z.canonical.z, z.canonical.x, z.canonical.y)) : (f = s.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: h }), this._source.hasTile && (f = f.filter((z) => this._source.hasTile(z)))) : f = [];
          const m = s.coveringZoomLevel(this._source), y = Math.max(m - jt.maxOverzooming, this._source.minzoom), S = Math.max(m + jt.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const z = {};
            for (const N of f) if (N.canonical.z > this._source.minzoom) {
              const X = N.scaledTo(N.canonical.z - 1);
              z[X.key] = X;
              const Z = N.scaledTo(Math.max(this._source.minzoom, Math.min(N.canonical.z, 5)));
              z[Z.key] = Z;
            }
            f = f.concat(Object.values(z));
          }
          const C = f.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, C && this.fire(new l.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const B = this._updateRetainedTiles(f, m);
          Jr(this._source.type) && this._updateCoveredAndRetainedTiles(B, y, S, m, f, h);
          for (const z in B) this._tiles[z].clearFadeHold();
          const D = l.ab(this._tiles, B);
          for (const z of D) {
            const N = this._tiles[z];
            N.hasSymbolBuckets && !N.holdingForFade() ? N.setHoldDuration(this.map._fadeDuration) : N.hasSymbolBuckets && !N.symbolFadeFinished() || this._removeTile(z);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const s in this._tiles) this._tiles[s].holdingForFade() && this._removeTile(s);
        }
        _updateRetainedTiles(s, h) {
          var f;
          const m = {}, y = {}, S = Math.max(h - jt.maxOverzooming, this._source.minzoom), C = Math.max(h + jt.maxUnderzooming, this._source.minzoom), B = {};
          for (const D of s) {
            const z = this._addTile(D);
            m[D.key] = D, z.hasData() || h < this._source.maxzoom && (B[D.key] = D);
          }
          this._retainLoadedChildren(B, h, C, m);
          for (const D of s) {
            let z = this._tiles[D.key];
            if (z.hasData()) continue;
            if (h + 1 > this._source.maxzoom) {
              const X = D.children(this._source.maxzoom)[0], Z = this.getTile(X);
              if (Z && Z.hasData()) {
                m[X.key] = X;
                continue;
              }
            } else {
              const X = D.children(this._source.maxzoom);
              if (m[X[0].key] && m[X[1].key] && m[X[2].key] && m[X[3].key]) continue;
            }
            let N = z.wasRequested();
            for (let X = D.overscaledZ - 1; X >= S; --X) {
              const Z = D.scaledTo(X);
              if (y[Z.key]) break;
              if (y[Z.key] = !0, z = this.getTile(Z), !z && N && (z = this._addTile(Z)), z) {
                const W = z.hasData();
                if ((W || !(!((f = this.map) === null || f === void 0) && f.cancelPendingTileRequestsWhileZooming) || N) && (m[Z.key] = Z), N = z.wasRequested(), W) break;
              }
            }
          }
          return m;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const s in this._tiles) {
            const h = [];
            let f, m = this._tiles[s].tileID;
            for (; m.overscaledZ > 0; ) {
              if (m.key in this._loadedParentTiles) {
                f = this._loadedParentTiles[m.key];
                break;
              }
              h.push(m.key);
              const y = m.scaledTo(m.overscaledZ - 1);
              if (f = this._getLoadedTile(y), f) break;
              m = y;
            }
            for (const y of h) this._loadedParentTiles[y] = f;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const s in this._tiles) {
            const h = this._tiles[s].tileID, f = this._getLoadedTile(h);
            this._loadedSiblingTiles[h.key] = f;
          }
        }
        _addTile(s) {
          let h = this._tiles[s.key];
          if (h) return h;
          h = this._cache.getAndRemove(s), h && (this._setTileReloadTimer(s.key, h), h.tileID = s, this._state.initializeTileState(h, this.map ? this.map.painter : null), this._cacheTimers[s.key] && (clearTimeout(this._cacheTimers[s.key]), delete this._cacheTimers[s.key], this._setTileReloadTimer(s.key, h)));
          const f = h;
          return h || (h = new _r(s, this._source.tileSize * s.overscaleFactor()), this._loadTile(h, s.key, h.state)), h.uses++, this._tiles[s.key] = h, f || this._source.fire(new l.k("dataloading", { tile: h, coord: h.tileID, dataType: "source" })), h;
        }
        _setTileReloadTimer(s, h) {
          s in this._timers && (clearTimeout(this._timers[s]), delete this._timers[s]);
          const f = h.getExpiryTimeout();
          f && (this._timers[s] = setTimeout(() => {
            this._reloadTile(s, "expired"), delete this._timers[s];
          }, f));
        }
        _removeTile(s) {
          const h = this._tiles[s];
          h && (h.uses--, delete this._tiles[s], this._timers[s] && (clearTimeout(this._timers[s]), delete this._timers[s]), h.uses > 0 || (h.hasData() && h.state !== "reloading" ? this._cache.add(h.tileID, h, h.getExpiryTimeout()) : (h.aborted = !0, this._abortTile(h), this._unloadTile(h))));
        }
        _dataHandler(s) {
          const h = s.sourceDataType;
          s.dataType === "source" && h === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && s.dataType === "source" && h === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const s in this._tiles) this._removeTile(s);
          this._cache.reset();
        }
        tilesIn(s, h, f) {
          const m = [], y = this.transform;
          if (!y) return m;
          const S = f ? y.getCameraQueryGeometry(s) : s, C = s.map((W) => y.pointCoordinate(W, this.terrain)), B = S.map((W) => y.pointCoordinate(W, this.terrain)), D = this.getIds();
          let z = 1 / 0, N = 1 / 0, X = -1 / 0, Z = -1 / 0;
          for (const W of B) z = Math.min(z, W.x), N = Math.min(N, W.y), X = Math.max(X, W.x), Z = Math.max(Z, W.y);
          for (let W = 0; W < D.length; W++) {
            const Q = this._tiles[D[W]];
            if (Q.holdingForFade()) continue;
            const le = Q.tileID, ue = Math.pow(2, y.zoom - Q.tileID.overscaledZ), fe = h * Q.queryPadding * l.X / Q.tileSize / ue, he = [le.getTilePoint(new l.Z(z, N)), le.getTilePoint(new l.Z(X, Z))];
            if (he[0].x - fe < l.X && he[0].y - fe < l.X && he[1].x + fe >= 0 && he[1].y + fe >= 0) {
              const ve = C.map((Pe) => le.getTilePoint(Pe)), Be = B.map((Pe) => le.getTilePoint(Pe));
              m.push({ tile: Q, tileID: le, queryGeometry: ve, cameraQueryGeometry: Be, scale: ue });
            }
          }
          return m;
        }
        getVisibleCoordinates(s) {
          const h = this.getRenderableIds(s).map((f) => this._tiles[f].tileID);
          for (const f of h) f.posMatrix = this.transform.calculatePosMatrix(f.toUnwrapped());
          return h;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Jr(this._source.type)) {
            const s = T.now();
            for (const h in this._tiles) if (this._tiles[h].fadeEndTime >= s) return !0;
          }
          return !1;
        }
        setFeatureState(s, h, f) {
          this._state.updateState(s = s || "_geojsonTileLayer", h, f);
        }
        removeFeatureState(s, h, f) {
          this._state.removeFeatureState(s = s || "_geojsonTileLayer", h, f);
        }
        getFeatureState(s, h) {
          return this._state.getState(s = s || "_geojsonTileLayer", h);
        }
        setDependencies(s, h, f) {
          const m = this._tiles[s];
          m && m.setDependencies(h, f);
        }
        reloadTilesForDependencies(s, h) {
          for (const f in this._tiles) this._tiles[f].hasDependency(s, h) && this._reloadTile(f, "reloading");
          this._cache.filter((f) => !f.hasDependency(s, h));
        }
      }
      function qn(g, s) {
        const h = Math.abs(2 * g.wrap) - +(g.wrap < 0), f = Math.abs(2 * s.wrap) - +(s.wrap < 0);
        return g.overscaledZ - s.overscaledZ || f - h || s.canonical.y - g.canonical.y || s.canonical.x - g.canonical.x;
      }
      function Jr(g) {
        return g === "raster" || g === "image" || g === "video";
      }
      jt.maxOverzooming = 10, jt.maxUnderzooming = 3;
      class zt {
        constructor(s, h) {
          this.reset(s, h);
        }
        reset(s, h) {
          this.points = s || [], this._distances = [0];
          for (let f = 1; f < this.points.length; f++) this._distances[f] = this._distances[f - 1] + this.points[f].dist(this.points[f - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(h || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(s) {
          if (this.points.length === 1) return this.points[0];
          s = l.ac(s, 0, 1);
          let h = 1, f = this._distances[h];
          const m = s * this.paddedLength + this.padding;
          for (; f < m && h < this._distances.length; ) f = this._distances[++h];
          const y = h - 1, S = this._distances[y], C = f - S, B = C > 0 ? (m - S) / C : 0;
          return this.points[y].mult(1 - B).add(this.points[h].mult(B));
        }
      }
      function yi(g, s) {
        let h = !0;
        return g === "always" || g !== "never" && s !== "never" || (h = !1), h;
      }
      class rr {
        constructor(s, h, f) {
          const m = this.boxCells = [], y = this.circleCells = [];
          this.xCellCount = Math.ceil(s / f), this.yCellCount = Math.ceil(h / f);
          for (let S = 0; S < this.xCellCount * this.yCellCount; S++) m.push([]), y.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = s, this.height = h, this.xScale = this.xCellCount / s, this.yScale = this.yCellCount / h, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(s, h, f, m, y) {
          this._forEachCell(h, f, m, y, this._insertBoxCell, this.boxUid++), this.boxKeys.push(s), this.bboxes.push(h), this.bboxes.push(f), this.bboxes.push(m), this.bboxes.push(y);
        }
        insertCircle(s, h, f, m) {
          this._forEachCell(h - m, f - m, h + m, f + m, this._insertCircleCell, this.circleUid++), this.circleKeys.push(s), this.circles.push(h), this.circles.push(f), this.circles.push(m);
        }
        _insertBoxCell(s, h, f, m, y, S) {
          this.boxCells[y].push(S);
        }
        _insertCircleCell(s, h, f, m, y, S) {
          this.circleCells[y].push(S);
        }
        _query(s, h, f, m, y, S, C) {
          if (f < 0 || s > this.width || m < 0 || h > this.height) return [];
          const B = [];
          if (s <= 0 && h <= 0 && this.width <= f && this.height <= m) {
            if (y) return [{ key: null, x1: s, y1: h, x2: f, y2: m }];
            for (let D = 0; D < this.boxKeys.length; D++) B.push({ key: this.boxKeys[D], x1: this.bboxes[4 * D], y1: this.bboxes[4 * D + 1], x2: this.bboxes[4 * D + 2], y2: this.bboxes[4 * D + 3] });
            for (let D = 0; D < this.circleKeys.length; D++) {
              const z = this.circles[3 * D], N = this.circles[3 * D + 1], X = this.circles[3 * D + 2];
              B.push({ key: this.circleKeys[D], x1: z - X, y1: N - X, x2: z + X, y2: N + X });
            }
          } else this._forEachCell(s, h, f, m, this._queryCell, B, { hitTest: y, overlapMode: S, seenUids: { box: {}, circle: {} } }, C);
          return B;
        }
        query(s, h, f, m) {
          return this._query(s, h, f, m, !1, null);
        }
        hitTest(s, h, f, m, y, S) {
          return this._query(s, h, f, m, !0, y, S).length > 0;
        }
        hitTestCircle(s, h, f, m, y) {
          const S = s - f, C = s + f, B = h - f, D = h + f;
          if (C < 0 || S > this.width || D < 0 || B > this.height) return !1;
          const z = [];
          return this._forEachCell(S, B, C, D, this._queryCellCircle, z, { hitTest: !0, overlapMode: m, circle: { x: s, y: h, radius: f }, seenUids: { box: {}, circle: {} } }, y), z.length > 0;
        }
        _queryCell(s, h, f, m, y, S, C, B) {
          const { seenUids: D, hitTest: z, overlapMode: N } = C, X = this.boxCells[y];
          if (X !== null) {
            const W = this.bboxes;
            for (const Q of X) if (!D.box[Q]) {
              D.box[Q] = !0;
              const le = 4 * Q, ue = this.boxKeys[Q];
              if (s <= W[le + 2] && h <= W[le + 3] && f >= W[le + 0] && m >= W[le + 1] && (!B || B(ue)) && (!z || !yi(N, ue.overlapMode)) && (S.push({ key: ue, x1: W[le], y1: W[le + 1], x2: W[le + 2], y2: W[le + 3] }), z)) return !0;
            }
          }
          const Z = this.circleCells[y];
          if (Z !== null) {
            const W = this.circles;
            for (const Q of Z) if (!D.circle[Q]) {
              D.circle[Q] = !0;
              const le = 3 * Q, ue = this.circleKeys[Q];
              if (this._circleAndRectCollide(W[le], W[le + 1], W[le + 2], s, h, f, m) && (!B || B(ue)) && (!z || !yi(N, ue.overlapMode))) {
                const fe = W[le], he = W[le + 1], ve = W[le + 2];
                if (S.push({ key: ue, x1: fe - ve, y1: he - ve, x2: fe + ve, y2: he + ve }), z) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(s, h, f, m, y, S, C, B) {
          const { circle: D, seenUids: z, overlapMode: N } = C, X = this.boxCells[y];
          if (X !== null) {
            const W = this.bboxes;
            for (const Q of X) if (!z.box[Q]) {
              z.box[Q] = !0;
              const le = 4 * Q, ue = this.boxKeys[Q];
              if (this._circleAndRectCollide(D.x, D.y, D.radius, W[le + 0], W[le + 1], W[le + 2], W[le + 3]) && (!B || B(ue)) && !yi(N, ue.overlapMode)) return S.push(!0), !0;
            }
          }
          const Z = this.circleCells[y];
          if (Z !== null) {
            const W = this.circles;
            for (const Q of Z) if (!z.circle[Q]) {
              z.circle[Q] = !0;
              const le = 3 * Q, ue = this.circleKeys[Q];
              if (this._circlesCollide(W[le], W[le + 1], W[le + 2], D.x, D.y, D.radius) && (!B || B(ue)) && !yi(N, ue.overlapMode)) return S.push(!0), !0;
            }
          }
        }
        _forEachCell(s, h, f, m, y, S, C, B) {
          const D = this._convertToXCellCoord(s), z = this._convertToYCellCoord(h), N = this._convertToXCellCoord(f), X = this._convertToYCellCoord(m);
          for (let Z = D; Z <= N; Z++) for (let W = z; W <= X; W++) if (y.call(this, s, h, f, m, this.xCellCount * W + Z, S, C, B)) return;
        }
        _convertToXCellCoord(s) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(s * this.xScale)));
        }
        _convertToYCellCoord(s) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(s * this.yScale)));
        }
        _circlesCollide(s, h, f, m, y, S) {
          const C = m - s, B = y - h, D = f + S;
          return D * D > C * C + B * B;
        }
        _circleAndRectCollide(s, h, f, m, y, S, C) {
          const B = (S - m) / 2, D = Math.abs(s - (m + B));
          if (D > B + f) return !1;
          const z = (C - y) / 2, N = Math.abs(h - (y + z));
          if (N > z + f) return !1;
          if (D <= B || N <= z) return !0;
          const X = D - B, Z = N - z;
          return X * X + Z * Z <= f * f;
        }
      }
      function ti(g, s, h, f, m) {
        const y = l.H();
        return s ? (l.K(y, y, [1 / m, 1 / m, 1]), h || l.ad(y, y, f.angle)) : l.L(y, f.labelPlaneMatrix, g), y;
      }
      function ni(g, s, h, f, m) {
        if (s) {
          const y = l.ae(g);
          return l.K(y, y, [m, m, 1]), h || l.ad(y, y, -f.angle), y;
        }
        return f.glCoordMatrix;
      }
      function be(g, s, h, f) {
        let m;
        f ? (m = [g, s, f(g, s), 1], l.af(m, m, h)) : (m = [g, s, 0, 1], Mn(m, m, h));
        const y = m[3];
        return { point: new l.P(m[0] / y, m[1] / y), signedDistanceFromCamera: y, isOccluded: !1 };
      }
      function J(g, s) {
        return 0.5 + g / s * 0.5;
      }
      function K(g, s) {
        return g.x >= -s[0] && g.x <= s[0] && g.y >= -s[1] && g.y <= s[1];
      }
      function ce(g, s, h, f, m, y, S, C, B, D, z, N, X, Z, W) {
        const Q = f ? g.textSizeData : g.iconSizeData, le = l.ag(Q, h.transform.zoom), ue = [256 / h.width * 2 + 1, 256 / h.height * 2 + 1], fe = f ? g.text.dynamicLayoutVertexArray : g.icon.dynamicLayoutVertexArray;
        fe.clear();
        const he = g.lineVertexArray, ve = f ? g.text.placedSymbolArray : g.icon.placedSymbolArray, Be = h.transform.width / h.transform.height;
        let Pe = !1;
        for (let Qe = 0; Qe < ve.length; Qe++) {
          const ft = ve.get(Qe);
          if (ft.hidden || ft.writingMode === l.ah.vertical && !Pe) {
            Kt(ft.numGlyphs, fe);
            continue;
          }
          Pe = !1;
          const _t = be(ft.anchorX, ft.anchorY, s, W);
          if (!K(_t.point, ue)) {
            Kt(ft.numGlyphs, fe);
            continue;
          }
          const xt = J(h.transform.cameraToCenterDistance, _t.signedDistanceFromCamera), bt = l.ai(Q, le, ft), yt = S ? bt / xt : bt * xt, wt = { getElevation: W, labelPlaneMatrix: m, lineVertexArray: he, pitchWithMap: S, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: D, tileAnchorPoint: new l.P(ft.anchorX, ft.anchorY), unwrappedTileID: z, width: N, height: X, translation: Z }, Jt = je(wt, ft, yt, !1, C, s, y, g.glyphOffsetArray, fe, Be, B);
          Pe = Jt.useVertical, (Jt.notEnoughRoom || Pe || Jt.needsFlipping && je(wt, ft, yt, !0, C, s, y, g.glyphOffsetArray, fe, Be, B).notEnoughRoom) && Kt(ft.numGlyphs, fe);
        }
        f ? g.text.dynamicLayoutVertexBuffer.updateData(fe) : g.icon.dynamicLayoutVertexBuffer.updateData(fe);
      }
      function ye(g, s, h, f, m, y, S, C) {
        const B = y.glyphStartIndex + y.numGlyphs, D = y.lineStartIndex, z = y.lineStartIndex + y.lineLength, N = s.getoffsetX(y.glyphStartIndex), X = s.getoffsetX(B - 1), Z = vt(g * N, h, f, m, y.segment, D, z, C, S);
        if (!Z) return null;
        const W = vt(g * X, h, f, m, y.segment, D, z, C, S);
        return W ? C.projectionCache.anyProjectionOccluded ? null : { first: Z, last: W } : null;
      }
      function Fe(g, s, h, f) {
        return g === l.ah.horizontal && Math.abs(h.y - s.y) > Math.abs(h.x - s.x) * f ? { useVertical: !0 } : (g === l.ah.vertical ? s.y < h.y : s.x > h.x) ? { needsFlipping: !0 } : null;
      }
      function je(g, s, h, f, m, y, S, C, B, D, z) {
        const N = h / 24, X = s.lineOffsetX * N, Z = s.lineOffsetY * N;
        let W;
        if (s.numGlyphs > 1) {
          const Q = s.glyphStartIndex + s.numGlyphs, le = s.lineStartIndex, ue = s.lineStartIndex + s.lineLength, fe = ye(N, C, X, Z, f, s, z, g);
          if (!fe) return { notEnoughRoom: !0 };
          const he = be(fe.first.point.x, fe.first.point.y, S, g.getElevation).point, ve = be(fe.last.point.x, fe.last.point.y, S, g.getElevation).point;
          if (m && !f) {
            const Be = Fe(s.writingMode, he, ve, D);
            if (Be) return Be;
          }
          W = [fe.first];
          for (let Be = s.glyphStartIndex + 1; Be < Q - 1; Be++) W.push(vt(N * C.getoffsetX(Be), X, Z, f, s.segment, le, ue, g, z));
          W.push(fe.last);
        } else {
          if (m && !f) {
            const le = be(g.tileAnchorPoint.x, g.tileAnchorPoint.y, y, g.getElevation).point, ue = s.lineStartIndex + s.segment + 1, fe = new l.P(g.lineVertexArray.getx(ue), g.lineVertexArray.gety(ue)), he = be(fe.x, fe.y, y, g.getElevation), ve = he.signedDistanceFromCamera > 0 ? he.point : function(Pe, Qe, ft, _t, xt, bt) {
              return Oe(Pe, Qe, ft, 1, xt, bt);
            }(g.tileAnchorPoint, fe, le, 0, y, g), Be = Fe(s.writingMode, le, ve, D);
            if (Be) return Be;
          }
          const Q = vt(N * C.getoffsetX(s.glyphStartIndex), X, Z, f, s.segment, s.lineStartIndex, s.lineStartIndex + s.lineLength, g, z);
          if (!Q || g.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          W = [Q];
        }
        for (const Q of W) l.aj(B, Q.point, Q.angle);
        return {};
      }
      function Oe(g, s, h, f, m, y) {
        const S = g.add(g.sub(s)._unit()), C = m !== void 0 ? be(S.x, S.y, m, y.getElevation).point : tt(S.x, S.y, y).point, B = h.sub(C);
        return h.add(B._mult(f / B.mag()));
      }
      function Ie(g, s, h) {
        const f = s.projectionCache;
        if (f.projections[g]) return f.projections[g];
        const m = new l.P(s.lineVertexArray.getx(g), s.lineVertexArray.gety(g)), y = tt(m.x, m.y, s);
        if (y.signedDistanceFromCamera > 0) return f.projections[g] = y.point, f.anyProjectionOccluded = f.anyProjectionOccluded || y.isOccluded, y.point;
        const S = g - h.direction;
        return function(C, B, D, z, N) {
          return Oe(C, B, D, z, void 0, N);
        }(h.distanceFromAnchor === 0 ? s.tileAnchorPoint : new l.P(s.lineVertexArray.getx(S), s.lineVertexArray.gety(S)), m, h.previousVertex, h.absOffsetX - h.distanceFromAnchor + 1, s);
      }
      function tt(g, s, h) {
        const f = g + h.translation[0], m = s + h.translation[1];
        let y;
        return !h.pitchWithMap && h.projection.useSpecialProjectionForSymbols ? (y = h.projection.projectTileCoordinates(f, m, h.unwrappedTileID, h.getElevation), y.point.x = (0.5 * y.point.x + 0.5) * h.width, y.point.y = (0.5 * -y.point.y + 0.5) * h.height) : (y = be(f, m, h.labelPlaneMatrix, h.getElevation), y.isOccluded = !1), y;
      }
      function ut(g, s, h) {
        return g._unit()._perp()._mult(s * h);
      }
      function We(g, s, h, f, m, y, S, C, B) {
        if (C.projectionCache.offsets[g]) return C.projectionCache.offsets[g];
        const D = h.add(s);
        if (g + B.direction < f || g + B.direction >= m) return C.projectionCache.offsets[g] = D, D;
        const z = Ie(g + B.direction, C, B), N = ut(z.sub(h), S, B.direction), X = h.add(N), Z = z.add(N);
        return C.projectionCache.offsets[g] = l.ak(y, D, X, Z) || D, C.projectionCache.offsets[g];
      }
      function vt(g, s, h, f, m, y, S, C, B) {
        const D = f ? g - s : g + s;
        let z = D > 0 ? 1 : -1, N = 0;
        f && (z *= -1, N = Math.PI), z < 0 && (N += Math.PI);
        let X, Z = z > 0 ? y + m : y + m + 1;
        C.projectionCache.cachedAnchorPoint ? X = C.projectionCache.cachedAnchorPoint : (X = tt(C.tileAnchorPoint.x, C.tileAnchorPoint.y, C).point, C.projectionCache.cachedAnchorPoint = X);
        let W, Q, le = X, ue = X, fe = 0, he = 0;
        const ve = Math.abs(D), Be = [];
        let Pe;
        for (; fe + he <= ve; ) {
          if (Z += z, Z < y || Z >= S) return null;
          fe += he, ue = le, Q = W;
          const _t = { absOffsetX: ve, direction: z, distanceFromAnchor: fe, previousVertex: ue };
          if (le = Ie(Z, C, _t), h === 0) Be.push(ue), Pe = le.sub(ue);
          else {
            let xt;
            const bt = le.sub(ue);
            xt = bt.mag() === 0 ? ut(Ie(Z + z, C, _t).sub(le), h, z) : ut(bt, h, z), Q || (Q = ue.add(xt)), W = We(Z, xt, le, y, S, Q, h, C, _t), Be.push(Q), Pe = W.sub(Q);
          }
          he = Pe.mag();
        }
        const Qe = Pe._mult((ve - fe) / he)._add(Q || ue), ft = N + Math.atan2(le.y - ue.y, le.x - ue.x);
        return Be.push(Qe), { point: Qe, angle: B ? ft : 0, path: Be };
      }
      const Xt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Kt(g, s) {
        for (let h = 0; h < g; h++) {
          const f = s.length;
          s.resize(f + 4), s.float32.set(Xt, 3 * f);
        }
      }
      function Mn(g, s, h) {
        const f = s[0], m = s[1];
        return g[0] = h[0] * f + h[4] * m + h[12], g[1] = h[1] * f + h[5] * m + h[13], g[3] = h[3] * f + h[7] * m + h[15], g;
      }
      const en = 100;
      class In {
        constructor(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new rr(s.width + 200, s.height + 200, 25), m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new rr(s.width + 200, s.height + 200, 25);
          this.transform = s, this.mapProjection = h, this.grid = f, this.ignoredGrid = m, this.pitchFactor = Math.cos(s._pitch) * s.cameraToCenterDistance, this.screenRightBoundary = s.width + en, this.screenBottomBoundary = s.height + en, this.gridRightBoundary = s.width + 200, this.gridBottomBoundary = s.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(s, h, f, m, y, S, C, B, D, z, N) {
          const X = s.anchorPointX + B[0], Z = s.anchorPointY + B[1], W = this.projectAndGetPerspectiveRatio(m, X, Z, y, z), Q = f * W.perspectiveRatio;
          let le;
          if (S || C) le = this._projectCollisionBox(s, Q, m, y, S, C, B, W, z, N);
          else {
            const Be = W.point.x + (N ? N.x * Q : 0), Pe = W.point.y + (N ? N.y * Q : 0);
            le = { allPointsOccluded: !1, box: [Be + s.x1 * Q, Pe + s.y1 * Q, Be + s.x2 * Q, Pe + s.y2 * Q] };
          }
          const [ue, fe, he, ve] = le.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (S ? le.allPointsOccluded : this.mapProjection.isOccluded(X, Z, y)) || W.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(ue, fe, he, ve) || h !== "always" && this.grid.hitTest(ue, fe, he, ve, h, D) ? { box: [ue, fe, he, ve], placeable: !1, offscreen: !1 } : { box: [ue, fe, he, ve], placeable: !0, offscreen: this.isOffscreen(ue, fe, he, ve) };
        }
        placeCollisionCircles(s, h, f, m, y, S, C, B, D, z, N, X, Z, W, Q, le) {
          const ue = [], fe = new l.P(h.anchorX, h.anchorY), he = this.getPerspectiveRatio(S, fe.x, fe.y, C, le), ve = (N ? y / he : y * he) / l.ap, Be = { getElevation: le, labelPlaneMatrix: B, lineVertexArray: f, pitchWithMap: N, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: fe, unwrappedTileID: C, width: this.transform.width, height: this.transform.height, translation: Q }, Pe = ye(ve, m, h.lineOffsetX * ve, h.lineOffsetY * ve, !1, h, !1, Be);
          let Qe = !1, ft = !1, _t = !0;
          if (Pe) {
            const xt = 0.5 * Z * he + W, bt = new l.P(-100, -100), yt = new l.P(this.screenRightBoundary, this.screenBottomBoundary), wt = new zt(), Jt = Pe.first, Ct = Pe.last;
            let It = [];
            for (let yn = Jt.path.length - 1; yn >= 1; yn--) It.push(Jt.path[yn]);
            for (let yn = 1; yn < Ct.path.length; yn++) It.push(Ct.path[yn]);
            const rn = 2.5 * xt;
            if (D) {
              const yn = this.projectPathToScreenSpace(It, Be, D);
              It = yn.some((En) => En.signedDistanceFromCamera <= 0) ? [] : yn.map((En) => En.point);
            }
            let An = [];
            if (It.length > 0) {
              const yn = It[0].clone(), En = It[0].clone();
              for (let Dn = 1; Dn < It.length; Dn++) yn.x = Math.min(yn.x, It[Dn].x), yn.y = Math.min(yn.y, It[Dn].y), En.x = Math.max(En.x, It[Dn].x), En.y = Math.max(En.y, It[Dn].y);
              An = yn.x >= bt.x && En.x <= yt.x && yn.y >= bt.y && En.y <= yt.y ? [It] : En.x < bt.x || yn.x > yt.x || En.y < bt.y || yn.y > yt.y ? [] : l.al([It], bt.x, bt.y, yt.x, yt.y);
            }
            for (const yn of An) {
              wt.reset(yn, 0.25 * xt);
              let En = 0;
              En = wt.length <= 0.5 * xt ? 1 : Math.ceil(wt.paddedLength / rn) + 1;
              for (let Dn = 0; Dn < En; Dn++) {
                const sr = Dn / Math.max(En - 1, 1), Dr = wt.lerp(sr), Qn = Dr.x + en, Xr = Dr.y + en;
                ue.push(Qn, Xr, xt, 0);
                const or = Qn - xt, Gr = Xr - xt, oi = Qn + xt, ts = Xr + xt;
                if (_t = _t && this.isOffscreen(or, Gr, oi, ts), ft = ft || this.isInsideGrid(or, Gr, oi, ts), s !== "always" && this.grid.hitTestCircle(Qn, Xr, xt, s, X) && (Qe = !0, !z)) return { circles: [], offscreen: !1, collisionDetected: Qe };
              }
            }
          }
          return { circles: !z && Qe || !ft || he < this.perspectiveRatioCutoff ? [] : ue, offscreen: _t, collisionDetected: Qe };
        }
        projectPathToScreenSpace(s, h, f) {
          return s.map((m) => be(m.x, m.y, f, h.getElevation));
        }
        queryRenderedSymbols(s) {
          if (s.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const h = [];
          let f = 1 / 0, m = 1 / 0, y = -1 / 0, S = -1 / 0;
          for (const z of s) {
            const N = new l.P(z.x + en, z.y + en);
            f = Math.min(f, N.x), m = Math.min(m, N.y), y = Math.max(y, N.x), S = Math.max(S, N.y), h.push(N);
          }
          const C = this.grid.query(f, m, y, S).concat(this.ignoredGrid.query(f, m, y, S)), B = {}, D = {};
          for (const z of C) {
            const N = z.key;
            if (B[N.bucketInstanceId] === void 0 && (B[N.bucketInstanceId] = {}), B[N.bucketInstanceId][N.featureIndex]) continue;
            const X = [new l.P(z.x1, z.y1), new l.P(z.x2, z.y1), new l.P(z.x2, z.y2), new l.P(z.x1, z.y2)];
            l.am(h, X) && (B[N.bucketInstanceId][N.featureIndex] = !0, D[N.bucketInstanceId] === void 0 && (D[N.bucketInstanceId] = []), D[N.bucketInstanceId].push(N.featureIndex));
          }
          return D;
        }
        insertCollisionBox(s, h, f, m, y, S) {
          (f ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: m, featureIndex: y, collisionGroupID: S, overlapMode: h }, s[0], s[1], s[2], s[3]);
        }
        insertCollisionCircles(s, h, f, m, y, S) {
          const C = f ? this.ignoredGrid : this.grid, B = { bucketInstanceId: m, featureIndex: y, collisionGroupID: S, overlapMode: h };
          for (let D = 0; D < s.length; D += 4) C.insertCircle(B, s[D], s[D + 1], s[D + 2]);
        }
        projectAndGetPerspectiveRatio(s, h, f, m, y) {
          let S;
          y ? (S = [h, f, y(h, f), 1], l.af(S, S, s)) : (S = [h, f, 0, 1], Mn(S, S, s));
          const C = S[3];
          return { point: new l.P((S[0] / C + 1) / 2 * this.transform.width + en, (-S[1] / C + 1) / 2 * this.transform.height + en), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / C * 0.5, isOccluded: !1, signedDistanceFromCamera: C };
        }
        getPerspectiveRatio(s, h, f, m, y) {
          const S = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(h, f, m, y) : be(h, f, s, y);
          return 0.5 + this.transform.cameraToCenterDistance / S.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(s, h, f, m) {
          return f < en || s >= this.screenRightBoundary || m < en || h > this.screenBottomBoundary;
        }
        isInsideGrid(s, h, f, m) {
          return f >= 0 && s < this.gridRightBoundary && m >= 0 && h < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const s = l.an([]);
          return l.J(s, s, [-100, -100, 0]), s;
        }
        _projectCollisionBox(s, h, f, m, y, S, C, B, D, z) {
          let N = new l.P(1, 0), X = new l.P(0, 1);
          const Z = new l.P(s.anchorPointX + C[0], s.anchorPointY + C[1]);
          if (S && !y) {
            const _t = this.projectAndGetPerspectiveRatio(f, Z.x + 1, Z.y, m, D).point.sub(B.point).unit(), xt = Math.atan(_t.y / _t.x) + (_t.x < 0 ? Math.PI : 0), bt = Math.sin(xt), yt = Math.cos(xt);
            N = new l.P(yt, bt), X = new l.P(-bt, yt);
          } else if (!S && y) {
            const _t = -this.transform.angle, xt = Math.sin(_t), bt = Math.cos(_t);
            N = new l.P(bt, xt), X = new l.P(-xt, bt);
          }
          let W = B.point, Q = h;
          if (y) {
            W = Z;
            const _t = this.transform.zoom - Math.floor(this.transform.zoom);
            Q = Math.pow(2, -_t), Q *= this.mapProjection.getPitchedTextCorrection(this.transform, Z, m), z || (Q *= l.ac(0.5 + B.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          z && (W = W.add(N.mult(z.x * Q)).add(X.mult(z.y * Q)));
          const le = s.x1 * Q, ue = s.x2 * Q, fe = (le + ue) / 2, he = s.y1 * Q, ve = s.y2 * Q, Be = (he + ve) / 2, Pe = [{ offsetX: le, offsetY: he }, { offsetX: fe, offsetY: he }, { offsetX: ue, offsetY: he }, { offsetX: ue, offsetY: Be }, { offsetX: ue, offsetY: ve }, { offsetX: fe, offsetY: ve }, { offsetX: le, offsetY: ve }, { offsetX: le, offsetY: Be }];
          let Qe = [];
          for (const { offsetX: _t, offsetY: xt } of Pe) Qe.push(new l.P(W.x + N.x * _t + X.x * xt, W.y + N.y * _t + X.y * xt));
          let ft = !1;
          if (y) {
            const _t = Qe.map((xt) => this.projectAndGetPerspectiveRatio(f, xt.x, xt.y, m, D));
            ft = _t.some((xt) => !xt.isOccluded), Qe = _t.map((xt) => xt.point);
          } else ft = !0;
          return { box: l.ao(Qe), allPointsOccluded: !ft };
        }
      }
      function wn(g, s, h) {
        return s * (l.X / (g.tileSize * Math.pow(2, h - g.tileID.overscaledZ)));
      }
      class ir {
        constructor(s, h, f, m) {
          this.opacity = s ? Math.max(0, Math.min(1, s.opacity + (s.placed ? h : -h))) : m && f ? 1 : 0, this.placed = f;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Wn {
        constructor(s, h, f, m, y) {
          this.text = new ir(s ? s.text : null, h, f, y), this.icon = new ir(s ? s.icon : null, h, m, y);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class hn {
        constructor(s, h, f) {
          this.text = s, this.icon = h, this.skipFade = f;
        }
      }
      class Fn {
        constructor() {
          this.invProjMatrix = l.H(), this.viewportMatrix = l.H(), this.circles = [];
        }
      }
      class er {
        constructor(s, h, f, m, y) {
          this.bucketInstanceId = s, this.featureIndex = h, this.sourceLayerIndex = f, this.bucketIndex = m, this.tileID = y;
        }
      }
      class fr {
        constructor(s) {
          this.crossSourceCollisions = s, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(s) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[s]) {
            const h = ++this.maxGroupID;
            this.collisionGroups[s] = { ID: h, predicate: (f) => f.collisionGroupID === h };
          }
          return this.collisionGroups[s];
        }
      }
      function Sr(g, s, h, f, m) {
        const { horizontalAlign: y, verticalAlign: S } = l.au(g);
        return new l.P(-(y - 0.5) * s + f[0] * m, -(S - 0.5) * h + f[1] * m);
      }
      class Yr {
        constructor(s, h, f, m, y, S) {
          this.transform = s.clone(), this.terrain = f, this.collisionIndex = new In(this.transform, h), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = m, this.retainedQueryData = {}, this.collisionGroups = new fr(y), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = S, S && (S.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(s) {
          const h = this.terrain;
          return h ? (f, m) => h.getElevation(s, f, m) : null;
        }
        getBucketParts(s, h, f, m) {
          const y = f.getBucket(h), S = f.latestFeatureIndex;
          if (!y || !S || h.id !== y.layerIds[0]) return;
          const C = f.collisionBoxArray, B = y.layers[0].layout, D = y.layers[0].paint, z = Math.pow(2, this.transform.zoom - f.tileID.overscaledZ), N = f.tileSize / l.X, X = f.tileID.toUnwrapped(), Z = this.transform.calculatePosMatrix(X), W = B.get("text-pitch-alignment") === "map", Q = B.get("text-rotation-alignment") === "map", le = wn(f, 1, this.transform.zoom), ue = this.collisionIndex.mapProjection.translatePosition(this.transform, f, D.get("text-translate"), D.get("text-translate-anchor")), fe = this.collisionIndex.mapProjection.translatePosition(this.transform, f, D.get("icon-translate"), D.get("icon-translate-anchor")), he = ti(Z, W, Q, this.transform, le);
          let ve = null;
          if (W) {
            const Pe = ni(Z, W, Q, this.transform, le);
            ve = l.L([], this.transform.labelPlaneMatrix, Pe);
          }
          this.retainedQueryData[y.bucketInstanceId] = new er(y.bucketInstanceId, S, y.sourceLayerIndex, y.index, f.tileID);
          const Be = { bucket: y, layout: B, translationText: ue, translationIcon: fe, posMatrix: Z, unwrappedTileID: X, textLabelPlaneMatrix: he, labelToScreenMatrix: ve, scale: z, textPixelRatio: N, holdingForFade: f.holdingForFade(), collisionBoxArray: C, partiallyEvaluatedTextSize: l.ag(y.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(y.sourceID) };
          if (m) for (const Pe of y.sortKeyRanges) {
            const { sortKey: Qe, symbolInstanceStart: ft, symbolInstanceEnd: _t } = Pe;
            s.push({ sortKey: Qe, symbolInstanceStart: ft, symbolInstanceEnd: _t, parameters: Be });
          }
          else s.push({ symbolInstanceStart: 0, symbolInstanceEnd: y.symbolInstances.length, parameters: Be });
        }
        attemptAnchorPlacement(s, h, f, m, y, S, C, B, D, z, N, X, Z, W, Q, le, ue, fe, he) {
          const ve = l.aq[s.textAnchor], Be = [s.textOffset0, s.textOffset1], Pe = Sr(ve, f, m, Be, y), Qe = this.collisionIndex.placeCollisionBox(h, X, B, D, z, C, S, le, N.predicate, he, Pe);
          if ((!fe || this.collisionIndex.placeCollisionBox(fe, X, B, D, z, C, S, ue, N.predicate, he, Pe).placeable) && Qe.placeable) {
            let ft;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[Z.crossTileID] && this.prevPlacement.placements[Z.crossTileID] && this.prevPlacement.placements[Z.crossTileID].text && (ft = this.prevPlacement.variableOffsets[Z.crossTileID].anchor), Z.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[Z.crossTileID] = { textOffset: Be, width: f, height: m, anchor: ve, textBoxScale: y, prevAnchor: ft }, this.markUsedJustification(W, ve, Z, Q), W.allowVerticalPlacement && (this.markUsedOrientation(W, Q, Z), this.placedOrientations[Z.crossTileID] = Q), { shift: Pe, placedGlyphBoxes: Qe };
          }
        }
        placeLayerBucketPart(s, h, f) {
          const { bucket: m, layout: y, translationText: S, translationIcon: C, posMatrix: B, unwrappedTileID: D, textLabelPlaneMatrix: z, labelToScreenMatrix: N, textPixelRatio: X, holdingForFade: Z, collisionBoxArray: W, partiallyEvaluatedTextSize: Q, collisionGroup: le } = s.parameters, ue = y.get("text-optional"), fe = y.get("icon-optional"), he = l.ar(y, "text-overlap", "text-allow-overlap"), ve = he === "always", Be = l.ar(y, "icon-overlap", "icon-allow-overlap"), Pe = Be === "always", Qe = y.get("text-rotation-alignment") === "map", ft = y.get("text-pitch-alignment") === "map", _t = y.get("icon-text-fit") !== "none", xt = y.get("symbol-z-order") === "viewport-y", bt = ve && (Pe || !m.hasIconData() || fe), yt = Pe && (ve || !m.hasTextData() || ue);
          !m.collisionArrays && W && m.deserializeCollisionBoxes(W);
          const wt = this._getTerrainElevationFunc(this.retainedQueryData[m.bucketInstanceId].tileID), Jt = (Ct, It, rn) => {
            var An, yn;
            if (h[Ct.crossTileID]) return;
            if (Z) return void (this.placements[Ct.crossTileID] = new hn(!1, !1, !1));
            let En = !1, Dn = !1, sr = !0, Dr = null, Qn = { box: null, placeable: !1, offscreen: null }, Xr = { box: null, placeable: !1, offscreen: null }, or = null, Gr = null, oi = null, ts = 0, Cs = 0, Fr = 0;
            It.textFeatureIndex ? ts = It.textFeatureIndex : Ct.useRuntimeCollisionCircles && (ts = Ct.featureIndex), It.verticalTextFeatureIndex && (Cs = It.verticalTextFeatureIndex);
            const Fa = It.textBox;
            if (Fa) {
              const zi = (Kr) => {
                let Li = l.ah.horizontal;
                if (m.allowVerticalPlacement && !Kr && this.prevPlacement) {
                  const ji = this.prevPlacement.placedOrientations[Ct.crossTileID];
                  ji && (this.placedOrientations[Ct.crossTileID] = ji, Li = ji, this.markUsedOrientation(m, Li, Ct));
                }
                return Li;
              }, ns = (Kr, Li) => {
                if (m.allowVerticalPlacement && Ct.numVerticalGlyphVertices > 0 && It.verticalTextBox) {
                  for (const ji of m.writingModes) if (ji === l.ah.vertical ? (Qn = Li(), Xr = Qn) : Qn = Kr(), Qn && Qn.placeable) break;
                } else Qn = Kr();
              }, wi = Ct.textAnchorOffsetStartIndex, Ui = Ct.textAnchorOffsetEndIndex;
              if (Ui === wi) {
                const Kr = (Li, ji) => {
                  const Hn = this.collisionIndex.placeCollisionBox(Li, he, X, B, D, ft, Qe, S, le.predicate, wt);
                  return Hn && Hn.placeable && (this.markUsedOrientation(m, ji, Ct), this.placedOrientations[Ct.crossTileID] = ji), Hn;
                };
                ns(() => Kr(Fa, l.ah.horizontal), () => {
                  const Li = It.verticalTextBox;
                  return m.allowVerticalPlacement && Ct.numVerticalGlyphVertices > 0 && Li ? Kr(Li, l.ah.vertical) : { box: null, offscreen: null };
                }), zi(Qn && Qn.placeable);
              } else {
                let Kr = l.aq[(yn = (An = this.prevPlacement) === null || An === void 0 ? void 0 : An.variableOffsets[Ct.crossTileID]) === null || yn === void 0 ? void 0 : yn.anchor];
                const Li = (Hn, ko, ka) => {
                  const sa = Hn.x2 - Hn.x1, Ql = Hn.y2 - Hn.y1, df = Ct.textBoxScale, Yh = _t && Be === "never" ? ko : null;
                  let No = null, oa = he === "never" ? 1 : 2, vu = "never";
                  Kr && oa++;
                  for (let Uc = 0; Uc < oa; Uc++) {
                    for (let xu = wi; xu < Ui; xu++) {
                      const jc = m.textAnchorOffsets.get(xu);
                      if (Kr && jc.textAnchor !== Kr) continue;
                      const aa = this.attemptAnchorPlacement(jc, Hn, sa, Ql, df, Qe, ft, X, B, D, le, vu, Ct, m, ka, S, C, Yh, wt);
                      if (aa && (No = aa.placedGlyphBoxes, No && No.placeable)) return En = !0, Dr = aa.shift, No;
                    }
                    Kr ? Kr = null : vu = he;
                  }
                  return f && !No && (No = { box: this.collisionIndex.placeCollisionBox(Fa, "always", X, B, D, ft, Qe, S, le.predicate, wt, new l.P(0, 0)).box, offscreen: !1, placeable: !1 }), No;
                };
                ns(() => Li(Fa, It.iconBox, l.ah.horizontal), () => {
                  const Hn = It.verticalTextBox;
                  return m.allowVerticalPlacement && (!Qn || !Qn.placeable) && Ct.numVerticalGlyphVertices > 0 && Hn ? Li(Hn, It.verticalIconBox, l.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), Qn && (En = Qn.placeable, sr = Qn.offscreen);
                const ji = zi(Qn && Qn.placeable);
                if (!En && this.prevPlacement) {
                  const Hn = this.prevPlacement.variableOffsets[Ct.crossTileID];
                  Hn && (this.variableOffsets[Ct.crossTileID] = Hn, this.markUsedJustification(m, Hn.anchor, Ct, ji));
                }
              }
            }
            if (or = Qn, En = or && or.placeable, sr = or && or.offscreen, Ct.useRuntimeCollisionCircles) {
              const zi = m.text.placedSymbolArray.get(Ct.centerJustifiedTextSymbolIndex), ns = l.ai(m.textSizeData, Q, zi), wi = y.get("text-padding");
              Gr = this.collisionIndex.placeCollisionCircles(he, zi, m.lineVertexArray, m.glyphOffsetArray, ns, B, D, z, N, f, ft, le.predicate, Ct.collisionCircleDiameter, wi, S, wt), Gr.circles.length && Gr.collisionDetected && !f && l.w("Collisions detected, but collision boxes are not shown"), En = ve || Gr.circles.length > 0 && !Gr.collisionDetected, sr = sr && Gr.offscreen;
            }
            if (It.iconFeatureIndex && (Fr = It.iconFeatureIndex), It.iconBox) {
              const zi = (ns) => this.collisionIndex.placeCollisionBox(ns, Be, X, B, D, ft, Qe, C, le.predicate, wt, _t && Dr ? Dr : void 0);
              Xr && Xr.placeable && It.verticalIconBox ? (oi = zi(It.verticalIconBox), Dn = oi.placeable) : (oi = zi(It.iconBox), Dn = oi.placeable), sr = sr && oi.offscreen;
            }
            const Is = ue || Ct.numHorizontalGlyphVertices === 0 && Ct.numVerticalGlyphVertices === 0, zc = fe || Ct.numIconVertices === 0;
            Is || zc ? zc ? Is || (Dn = Dn && En) : En = Dn && En : Dn = En = Dn && En;
            const Kl = Dn && oi.placeable;
            if (En && or.placeable && this.collisionIndex.insertCollisionBox(or.box, he, y.get("text-ignore-placement"), m.bucketInstanceId, Xr && Xr.placeable && Cs ? Cs : ts, le.ID), Kl && this.collisionIndex.insertCollisionBox(oi.box, Be, y.get("icon-ignore-placement"), m.bucketInstanceId, Fr, le.ID), Gr && En && this.collisionIndex.insertCollisionCircles(Gr.circles, he, y.get("text-ignore-placement"), m.bucketInstanceId, ts, le.ID), f && this.storeCollisionData(m.bucketInstanceId, rn, It, or, oi, Gr), Ct.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (m.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[Ct.crossTileID] = new hn(En || bt, Dn || yt, sr || m.justReloaded), h[Ct.crossTileID] = !0;
          };
          if (xt) {
            if (s.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const Ct = m.getSortedSymbolIndexes(this.transform.angle);
            for (let It = Ct.length - 1; It >= 0; --It) {
              const rn = Ct[It];
              Jt(m.symbolInstances.get(rn), m.collisionArrays[rn], rn);
            }
          } else for (let Ct = s.symbolInstanceStart; Ct < s.symbolInstanceEnd; Ct++) Jt(m.symbolInstances.get(Ct), m.collisionArrays[Ct], Ct);
          if (f && m.bucketInstanceId in this.collisionCircleArrays) {
            const Ct = this.collisionCircleArrays[m.bucketInstanceId];
            l.as(Ct.invProjMatrix, B), Ct.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          m.justReloaded = !1;
        }
        storeCollisionData(s, h, f, m, y, S) {
          if (f.textBox || f.iconBox) {
            let C, B;
            this.collisionBoxArrays.has(s) ? C = this.collisionBoxArrays.get(s) : (C = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(s, C)), C.has(h) ? B = C.get(h) : (B = { text: null, icon: null }, C.set(h, B)), f.textBox && (B.text = m.box), f.iconBox && (B.icon = y.box);
          }
          if (S) {
            let C = this.collisionCircleArrays[s];
            C === void 0 && (C = this.collisionCircleArrays[s] = new Fn());
            for (let B = 0; B < S.circles.length; B += 4) C.circles.push(S.circles[B + 0]), C.circles.push(S.circles[B + 1]), C.circles.push(S.circles[B + 2]), C.circles.push(S.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(s, h, f, m) {
          let y;
          y = m === l.ah.vertical ? f.verticalPlacedTextSymbolIndex : { left: f.leftJustifiedTextSymbolIndex, center: f.centerJustifiedTextSymbolIndex, right: f.rightJustifiedTextSymbolIndex }[l.at(h)];
          const S = [f.leftJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.rightJustifiedTextSymbolIndex, f.verticalPlacedTextSymbolIndex];
          for (const C of S) C >= 0 && (s.text.placedSymbolArray.get(C).crossTileID = y >= 0 && C !== y ? 0 : f.crossTileID);
        }
        markUsedOrientation(s, h, f) {
          const m = h === l.ah.horizontal || h === l.ah.horizontalOnly ? h : 0, y = h === l.ah.vertical ? h : 0, S = [f.leftJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.rightJustifiedTextSymbolIndex];
          for (const C of S) s.text.placedSymbolArray.get(C).placedOrientation = m;
          f.verticalPlacedTextSymbolIndex && (s.text.placedSymbolArray.get(f.verticalPlacedTextSymbolIndex).placedOrientation = y);
        }
        commit(s) {
          this.commitTime = s, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const h = this.prevPlacement;
          let f = !1;
          this.prevZoomAdjustment = h ? h.zoomAdjustment(this.transform.zoom) : 0;
          const m = h ? h.symbolFadeChange(s) : 1, y = h ? h.opacities : {}, S = h ? h.variableOffsets : {}, C = h ? h.placedOrientations : {};
          for (const B in this.placements) {
            const D = this.placements[B], z = y[B];
            z ? (this.opacities[B] = new Wn(z, m, D.text, D.icon), f = f || D.text !== z.text.placed || D.icon !== z.icon.placed) : (this.opacities[B] = new Wn(null, m, D.text, D.icon, D.skipFade), f = f || D.text || D.icon);
          }
          for (const B in y) {
            const D = y[B];
            if (!this.opacities[B]) {
              const z = new Wn(D, m, !1, !1);
              z.isHidden() || (this.opacities[B] = z, f = f || D.text.placed || D.icon.placed);
            }
          }
          for (const B in S) this.variableOffsets[B] || !this.opacities[B] || this.opacities[B].isHidden() || (this.variableOffsets[B] = S[B]);
          for (const B in C) this.placedOrientations[B] || !this.opacities[B] || this.opacities[B].isHidden() || (this.placedOrientations[B] = C[B]);
          if (h && h.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          f ? this.lastPlacementChangeTime = s : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = h ? h.lastPlacementChangeTime : s);
        }
        updateLayerOpacities(s, h) {
          const f = {};
          for (const m of h) {
            const y = m.getBucket(s);
            y && m.latestFeatureIndex && s.id === y.layerIds[0] && this.updateBucketOpacities(y, m.tileID, f, m.collisionBoxArray);
          }
        }
        updateBucketOpacities(s, h, f, m) {
          s.hasTextData() && (s.text.opacityVertexArray.clear(), s.text.hasVisibleVertices = !1), s.hasIconData() && (s.icon.opacityVertexArray.clear(), s.icon.hasVisibleVertices = !1), s.hasIconCollisionBoxData() && s.iconCollisionBox.collisionVertexArray.clear(), s.hasTextCollisionBoxData() && s.textCollisionBox.collisionVertexArray.clear();
          const y = s.layers[0], S = y.layout, C = new Wn(null, 0, !1, !1, !0), B = S.get("text-allow-overlap"), D = S.get("icon-allow-overlap"), z = y._unevaluatedLayout.hasValue("text-variable-anchor") || y._unevaluatedLayout.hasValue("text-variable-anchor-offset"), N = S.get("text-rotation-alignment") === "map", X = S.get("text-pitch-alignment") === "map", Z = S.get("icon-text-fit") !== "none", W = new Wn(null, 0, B && (D || !s.hasIconData() || S.get("icon-optional")), D && (B || !s.hasTextData() || S.get("text-optional")), !0);
          !s.collisionArrays && m && (s.hasIconCollisionBoxData() || s.hasTextCollisionBoxData()) && s.deserializeCollisionBoxes(m);
          const Q = (ue, fe, he) => {
            for (let ve = 0; ve < fe / 4; ve++) ue.opacityVertexArray.emplaceBack(he);
            ue.hasVisibleVertices = ue.hasVisibleVertices || he !== ao;
          }, le = this.collisionBoxArrays.get(s.bucketInstanceId);
          for (let ue = 0; ue < s.symbolInstances.length; ue++) {
            const fe = s.symbolInstances.get(ue), { numHorizontalGlyphVertices: he, numVerticalGlyphVertices: ve, crossTileID: Be } = fe;
            let Pe = this.opacities[Be];
            f[Be] ? Pe = C : Pe || (Pe = W, this.opacities[Be] = Pe), f[Be] = !0;
            const Qe = fe.numIconVertices > 0, ft = this.placedOrientations[fe.crossTileID], _t = ft === l.ah.vertical, xt = ft === l.ah.horizontal || ft === l.ah.horizontalOnly;
            if (he > 0 || ve > 0) {
              const yt = Er(Pe.text);
              Q(s.text, he, _t ? ao : yt), Q(s.text, ve, xt ? ao : yt);
              const wt = Pe.text.isHidden();
              [fe.rightJustifiedTextSymbolIndex, fe.centerJustifiedTextSymbolIndex, fe.leftJustifiedTextSymbolIndex].forEach((It) => {
                It >= 0 && (s.text.placedSymbolArray.get(It).hidden = wt || _t ? 1 : 0);
              }), fe.verticalPlacedTextSymbolIndex >= 0 && (s.text.placedSymbolArray.get(fe.verticalPlacedTextSymbolIndex).hidden = wt || xt ? 1 : 0);
              const Jt = this.variableOffsets[fe.crossTileID];
              Jt && this.markUsedJustification(s, Jt.anchor, fe, ft);
              const Ct = this.placedOrientations[fe.crossTileID];
              Ct && (this.markUsedJustification(s, "left", fe, Ct), this.markUsedOrientation(s, Ct, fe));
            }
            if (Qe) {
              const yt = Er(Pe.icon), wt = !(Z && fe.verticalPlacedIconSymbolIndex && _t);
              fe.placedIconSymbolIndex >= 0 && (Q(s.icon, fe.numIconVertices, wt ? yt : ao), s.icon.placedSymbolArray.get(fe.placedIconSymbolIndex).hidden = Pe.icon.isHidden()), fe.verticalPlacedIconSymbolIndex >= 0 && (Q(s.icon, fe.numVerticalIconVertices, wt ? ao : yt), s.icon.placedSymbolArray.get(fe.verticalPlacedIconSymbolIndex).hidden = Pe.icon.isHidden());
            }
            const bt = le && le.has(ue) ? le.get(ue) : { text: null, icon: null };
            if (s.hasIconCollisionBoxData() || s.hasTextCollisionBoxData()) {
              const yt = s.collisionArrays[ue];
              if (yt) {
                let wt = new l.P(0, 0);
                if (yt.textBox || yt.verticalTextBox) {
                  let Jt = !0;
                  if (z) {
                    const Ct = this.variableOffsets[Be];
                    Ct ? (wt = Sr(Ct.anchor, Ct.width, Ct.height, Ct.textOffset, Ct.textBoxScale), N && wt._rotate(X ? this.transform.angle : -this.transform.angle)) : Jt = !1;
                  }
                  if (yt.textBox || yt.verticalTextBox) {
                    let Ct;
                    yt.textBox && (Ct = _t), yt.verticalTextBox && (Ct = xt), so(s.textCollisionBox.collisionVertexArray, Pe.text.placed, !Jt || Ct, bt.text, wt.x, wt.y);
                  }
                }
                if (yt.iconBox || yt.verticalIconBox) {
                  const Jt = !!(!xt && yt.verticalIconBox);
                  let Ct;
                  yt.iconBox && (Ct = Jt), yt.verticalIconBox && (Ct = !Jt), so(s.iconCollisionBox.collisionVertexArray, Pe.icon.placed, Ct, bt.icon, Z ? wt.x : 0, Z ? wt.y : 0);
                }
              }
            }
          }
          if (s.sortFeatures(this.transform.angle), this.retainedQueryData[s.bucketInstanceId] && (this.retainedQueryData[s.bucketInstanceId].featureSortOrder = s.featureSortOrder), s.hasTextData() && s.text.opacityVertexBuffer && s.text.opacityVertexBuffer.updateData(s.text.opacityVertexArray), s.hasIconData() && s.icon.opacityVertexBuffer && s.icon.opacityVertexBuffer.updateData(s.icon.opacityVertexArray), s.hasIconCollisionBoxData() && s.iconCollisionBox.collisionVertexBuffer && s.iconCollisionBox.collisionVertexBuffer.updateData(s.iconCollisionBox.collisionVertexArray), s.hasTextCollisionBoxData() && s.textCollisionBox.collisionVertexBuffer && s.textCollisionBox.collisionVertexBuffer.updateData(s.textCollisionBox.collisionVertexArray), s.text.opacityVertexArray.length !== s.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${s.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${s.text.layoutVertexArray.length}) / 4`);
          if (s.icon.opacityVertexArray.length !== s.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${s.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${s.icon.layoutVertexArray.length}) / 4`);
          if (s.bucketInstanceId in this.collisionCircleArrays) {
            const ue = this.collisionCircleArrays[s.bucketInstanceId];
            s.placementInvProjMatrix = ue.invProjMatrix, s.placementViewportMatrix = ue.viewportMatrix, s.collisionCircleArray = ue.circles, delete this.collisionCircleArrays[s.bucketInstanceId];
          }
        }
        symbolFadeChange(s) {
          return this.fadeDuration === 0 ? 1 : (s - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(s) {
          return Math.max(0, (this.transform.zoom - s) / 1.5);
        }
        hasTransitions(s) {
          return this.stale || s - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(s, h) {
          const f = this.zoomAtLastRecencyCheck === h ? 1 - this.zoomAdjustment(h) : 1;
          return this.zoomAtLastRecencyCheck = h, this.commitTime + this.fadeDuration * f > s;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function so(g, s, h, f, m, y) {
        f && f.length !== 0 || (f = [0, 0, 0, 0]);
        const S = f[0] - en, C = f[1] - en, B = f[2] - en, D = f[3] - en;
        g.emplaceBack(s ? 1 : 0, h ? 1 : 0, m || 0, y || 0, S, C), g.emplaceBack(s ? 1 : 0, h ? 1 : 0, m || 0, y || 0, B, C), g.emplaceBack(s ? 1 : 0, h ? 1 : 0, m || 0, y || 0, B, D), g.emplaceBack(s ? 1 : 0, h ? 1 : 0, m || 0, y || 0, S, D);
      }
      const Jn = Math.pow(2, 25), bi = Math.pow(2, 24), Xi = Math.pow(2, 17), Pr = Math.pow(2, 16), Lr = Math.pow(2, 9), oo = Math.pow(2, 8), Mr = Math.pow(2, 1);
      function Er(g) {
        if (g.opacity === 0 && !g.placed) return 0;
        if (g.opacity === 1 && g.placed) return 4294967295;
        const s = g.placed ? 1 : 0, h = Math.floor(127 * g.opacity);
        return h * Jn + s * bi + h * Xi + s * Pr + h * Lr + s * oo + h * Mr + s;
      }
      const ao = 0;
      function $i() {
        return { isOccluded: (g, s, h) => !1, getPitchedTextCorrection: (g, s, h) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(g, s, h, f) {
          throw new Error("Not implemented.");
        }, translatePosition: (g, s, h, f) => function(m, y, S, C) {
          let B = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
          if (!S[0] && !S[1]) return [0, 0];
          const D = B ? C === "map" ? m.angle : 0 : C === "viewport" ? -m.angle : 0;
          if (D) {
            const z = Math.sin(D), N = Math.cos(D);
            S = [S[0] * N - S[1] * z, S[0] * z + S[1] * N];
          }
          return [B ? S[0] : wn(y, S[0], m.zoom), B ? S[1] : wn(y, S[1], m.zoom)];
        }(g, s, h, f), getCircleRadiusCorrection: (g) => 1 };
      }
      class yr {
        constructor(s) {
          this._sortAcrossTiles = s.layout.get("symbol-z-order") !== "viewport-y" && !s.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(s, h, f, m, y) {
          const S = this._bucketParts;
          for (; this._currentTileIndex < s.length; ) if (h.getBucketParts(S, m, s[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, y()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, S.sort((C, B) => C.sortKey - B.sortKey)); this._currentPartIndex < S.length; ) if (h.placeLayerBucketPart(S[this._currentPartIndex], this._seenCrossTileIDs, f), this._currentPartIndex++, y()) return !0;
          return !1;
        }
      }
      class Yn {
        constructor(s, h, f, m, y, S, C, B) {
          this.placement = new Yr(s, $i(), h, S, C, B), this._currentPlacementIndex = f.length - 1, this._forceFullPlacement = m, this._showCollisionBoxes = y, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(s, h, f) {
          const m = T.now(), y = () => !this._forceFullPlacement && T.now() - m > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const S = h[s[this._currentPlacementIndex]], C = this.placement.collisionIndex.transform.zoom;
            if (S.type === "symbol" && (!S.minzoom || S.minzoom <= C) && (!S.maxzoom || S.maxzoom > C)) {
              if (this._inProgressLayer || (this._inProgressLayer = new yr(S)), this._inProgressLayer.continuePlacement(f[S.source], this.placement, this._showCollisionBoxes, S, y)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(s) {
          return this.placement.commit(s), this.placement;
        }
      }
      const fi = 512 / l.X / 2;
      class pr {
        constructor(s, h, f) {
          this.tileID = s, this.bucketInstanceId = f, this._symbolsByKey = {};
          const m = /* @__PURE__ */ new Map();
          for (let y = 0; y < h.length; y++) {
            const S = h.get(y), C = S.key, B = m.get(C);
            B ? B.push(S) : m.set(C, [S]);
          }
          for (const [y, S] of m) {
            const C = { positions: S.map((B) => ({ x: Math.floor(B.anchorX * fi), y: Math.floor(B.anchorY * fi) })), crossTileIDs: S.map((B) => B.crossTileID) };
            if (C.positions.length > 128) {
              const B = new l.av(C.positions.length, 16, Uint16Array);
              for (const { x: D, y: z } of C.positions) B.add(D, z);
              B.finish(), delete C.positions, C.index = B;
            }
            this._symbolsByKey[y] = C;
          }
        }
        getScaledCoordinates(s, h) {
          const { x: f, y: m, z: y } = this.tileID.canonical, { x: S, y: C, z: B } = h.canonical, D = fi / Math.pow(2, B - y), z = (C * l.X + s.anchorY) * D, N = m * l.X * fi;
          return { x: Math.floor((S * l.X + s.anchorX) * D - f * l.X * fi), y: Math.floor(z - N) };
        }
        findMatches(s, h, f) {
          const m = this.tileID.canonical.z < h.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - h.canonical.z);
          for (let y = 0; y < s.length; y++) {
            const S = s.get(y);
            if (S.crossTileID) continue;
            const C = this._symbolsByKey[S.key];
            if (!C) continue;
            const B = this.getScaledCoordinates(S, h);
            if (C.index) {
              const D = C.index.range(B.x - m, B.y - m, B.x + m, B.y + m).sort();
              for (const z of D) {
                const N = C.crossTileIDs[z];
                if (!f[N]) {
                  f[N] = !0, S.crossTileID = N;
                  break;
                }
              }
            } else if (C.positions) for (let D = 0; D < C.positions.length; D++) {
              const z = C.positions[D], N = C.crossTileIDs[D];
              if (Math.abs(z.x - B.x) <= m && Math.abs(z.y - B.y) <= m && !f[N]) {
                f[N] = !0, S.crossTileID = N;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map((s) => {
            let { crossTileIDs: h } = s;
            return h;
          });
        }
      }
      class lo {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class pi {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(s) {
          const h = Math.round((s - this.lng) / 360);
          if (h !== 0) for (const f in this.indexes) {
            const m = this.indexes[f], y = {};
            for (const S in m) {
              const C = m[S];
              C.tileID = C.tileID.unwrapTo(C.tileID.wrap + h), y[C.tileID.key] = C;
            }
            this.indexes[f] = y;
          }
          this.lng = s;
        }
        addBucket(s, h, f) {
          if (this.indexes[s.overscaledZ] && this.indexes[s.overscaledZ][s.key]) {
            if (this.indexes[s.overscaledZ][s.key].bucketInstanceId === h.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(s.overscaledZ, this.indexes[s.overscaledZ][s.key]);
          }
          for (let y = 0; y < h.symbolInstances.length; y++) h.symbolInstances.get(y).crossTileID = 0;
          this.usedCrossTileIDs[s.overscaledZ] || (this.usedCrossTileIDs[s.overscaledZ] = {});
          const m = this.usedCrossTileIDs[s.overscaledZ];
          for (const y in this.indexes) {
            const S = this.indexes[y];
            if (Number(y) > s.overscaledZ) for (const C in S) {
              const B = S[C];
              B.tileID.isChildOf(s) && B.findMatches(h.symbolInstances, s, m);
            }
            else {
              const C = S[s.scaledTo(Number(y)).key];
              C && C.findMatches(h.symbolInstances, s, m);
            }
          }
          for (let y = 0; y < h.symbolInstances.length; y++) {
            const S = h.symbolInstances.get(y);
            S.crossTileID || (S.crossTileID = f.generate(), m[S.crossTileID] = !0);
          }
          return this.indexes[s.overscaledZ] === void 0 && (this.indexes[s.overscaledZ] = {}), this.indexes[s.overscaledZ][s.key] = new pr(s, h.symbolInstances, h.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(s, h) {
          for (const f of h.getCrossTileIDsLists()) for (const m of f) delete this.usedCrossTileIDs[s][m];
        }
        removeStaleBuckets(s) {
          let h = !1;
          for (const f in this.indexes) {
            const m = this.indexes[f];
            for (const y in m) s[m[y].bucketInstanceId] || (this.removeBucketCrossTileIDs(f, m[y]), delete m[y], h = !0);
          }
          return h;
        }
      }
      class Zo {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new lo(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(s, h, f) {
          let m = this.layerIndexes[s.id];
          m === void 0 && (m = this.layerIndexes[s.id] = new pi());
          let y = !1;
          const S = {};
          m.handleWrapJump(f);
          for (const C of h) {
            const B = C.getBucket(s);
            B && s.id === B.layerIds[0] && (B.bucketInstanceId || (B.bucketInstanceId = ++this.maxBucketInstanceId), m.addBucket(C.tileID, B, this.crossTileIDs) && (y = !0), S[B.bucketInstanceId] = !0);
          }
          return m.removeStaleBuckets(S) && (y = !0), y;
        }
        pruneUnusedLayers(s) {
          const h = {};
          s.forEach((f) => {
            h[f] = !0;
          });
          for (const f in this.layerIndexes) h[f] || delete this.layerIndexes[f];
        }
      }
      const Tr = (g, s) => l.t(g, s && s.filter((h) => h.identifier !== "source.canvas")), Zi = l.aw();
      class gi extends l.E {
        constructor(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super(), this._rtlPluginLoaded = () => {
            for (const f in this.sourceCaches) {
              const m = this.sourceCaches[f].getSource().type;
              m !== "vector" && m !== "geojson" || this.sourceCaches[f].reload();
            }
          }, this.map = s, this.dispatcher = new St(Ze(), s._getMapId()), this.dispatcher.registerMessageHandler("GG", (f, m) => this.getGlyphs(f, m)), this.dispatcher.registerMessageHandler("GI", (f, m) => this.getImages(f, m)), this.imageManager = new Te(), this.imageManager.setEventedParent(this), this.glyphManager = new st(s._requestManager, h.localIdeographFontFamily), this.lineAtlas = new Ae(256, 512), this.crossTileSymbolIndex = new Zo(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new l.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", l.ay()), Ot().on(gt, this._rtlPluginLoaded), this.on("data", (f) => {
            if (f.dataType !== "source" || f.sourceDataType !== "metadata") return;
            const m = this.sourceCaches[f.sourceId];
            if (!m) return;
            const y = m.getSource();
            if (y && y.vectorLayerIds) for (const S in this._layers) {
              const C = this._layers[S];
              C.source === y.id && this._validateLayer(C);
            }
          });
        }
        loadURL(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = arguments.length > 2 ? arguments[2] : void 0;
          this.fire(new l.k("dataloading", { dataType: "style" })), h.validate = typeof h.validate != "boolean" || h.validate;
          const m = this.map._requestManager.transformRequest(s, "Style");
          this._loadStyleRequest = new AbortController();
          const y = this._loadStyleRequest;
          l.h(m, this._loadStyleRequest).then((S) => {
            this._loadStyleRequest = null, this._load(S.data, h, f);
          }).catch((S) => {
            this._loadStyleRequest = null, S && !y.signal.aborted && this.fire(new l.j(S));
          });
        }
        loadJSON(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = arguments.length > 2 ? arguments[2] : void 0;
          this.fire(new l.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), T.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, h.validate = h.validate !== !1, this._load(s, h, f);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new l.k("dataloading", { dataType: "style" })), this._load(Zi, { validate: !1 });
        }
        _load(s, h, f) {
          var m;
          const y = h.transformStyle ? h.transformStyle(f, s) : s;
          if (!h.validate || !Tr(this, l.u(y))) {
            this._loaded = !0, this.stylesheet = y;
            for (const S in y.sources) this.addSource(S, y.sources[S], { validate: !1 });
            y.sprite ? this._loadSprite(y.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(y.glyphs), this._createLayers(), this.light = new ot(this.stylesheet.light), this.sky = new re(this.stylesheet.sky), this.map.setTerrain((m = this.stylesheet.terrain) !== null && m !== void 0 ? m : null), this.fire(new l.k("data", { dataType: "style" })), this.fire(new l.k("style.load"));
          }
        }
        _createLayers() {
          const s = l.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", s), this._order = s.map((h) => h.id), this._layers = {}, this._serializedLayers = null;
          for (const h of s) {
            const f = l.aA(h);
            f.setEventedParent(this, { layer: { id: h.id } }), this._layers[h.id] = f;
          }
        }
        _loadSprite(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, m;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(y, S, C, B) {
            return l._(this, void 0, void 0, function* () {
              const D = Ge(y), z = C > 1 ? "@2x" : "", N = {}, X = {};
              for (const { id: Z, url: W } of D) {
                const Q = S.transformRequest(ke(W, z, ".json"), "SpriteJSON");
                N[Z] = l.h(Q, B);
                const le = S.transformRequest(ke(W, z, ".png"), "SpriteImage");
                X[Z] = ie.getImage(le, B);
              }
              return yield Promise.all([...Object.values(N), ...Object.values(X)]), function(Z, W) {
                return l._(this, void 0, void 0, function* () {
                  const Q = {};
                  for (const le in Z) {
                    Q[le] = {};
                    const ue = T.getImageCanvasContext((yield W[le]).data), fe = (yield Z[le]).data;
                    for (const he in fe) {
                      const { width: ve, height: Be, x: Pe, y: Qe, sdf: ft, pixelRatio: _t, stretchX: xt, stretchY: bt, content: yt, textFitWidth: wt, textFitHeight: Jt } = fe[he];
                      Q[le][he] = { data: null, pixelRatio: _t, sdf: ft, stretchX: xt, stretchY: bt, content: yt, textFitWidth: wt, textFitHeight: Jt, spriteData: { width: ve, height: Be, x: Pe, y: Qe, context: ue } };
                    }
                  }
                  return Q;
                });
              }(N, X);
            });
          }(s, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((y) => {
            if (this._spriteRequest = null, y) for (const S in y) {
              this._spritesImagesIds[S] = [];
              const C = this._spritesImagesIds[S] ? this._spritesImagesIds[S].filter((B) => !(B in y)) : [];
              for (const B of C) this.imageManager.removeImage(B), this._changedImages[B] = !0;
              for (const B in y[S]) {
                const D = S === "default" ? B : `${S}:${B}`;
                this._spritesImagesIds[S].push(D), D in this.imageManager.images ? this.imageManager.updateImage(D, y[S][B], !1) : this.imageManager.addImage(D, y[S][B]), h && (this._changedImages[D] = !0);
              }
            }
          }).catch((y) => {
            this._spriteRequest = null, m = y, this.fire(new l.j(m));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), h && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" })), f && f(m);
          });
        }
        _unloadSprite() {
          for (const s of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(s), this._changedImages[s] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
        }
        _validateLayer(s) {
          const h = this.sourceCaches[s.source];
          if (!h) return;
          const f = s.sourceLayer;
          if (!f) return;
          const m = h.getSource();
          (m.type === "geojson" || m.vectorLayerIds && m.vectorLayerIds.indexOf(f) === -1) && this.fire(new l.j(new Error(`Source layer "${f}" does not exist on source "${m.id}" as specified by style layer "${s.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const s in this.sourceCaches) if (!this.sourceCaches[s].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
          const f = this._serializedAllLayers();
          if (!s || s.length === 0) return Object.values(h ? l.aB(f) : f);
          const m = [];
          for (const y of s) if (f[y]) {
            const S = h ? l.aB(f[y]) : f[y];
            m.push(S);
          }
          return m;
        }
        _serializedAllLayers() {
          let s = this._serializedLayers;
          if (s) return s;
          s = this._serializedLayers = {};
          const h = Object.keys(this._layers);
          for (const f of h) {
            const m = this._layers[f];
            m.type !== "custom" && (s[f] = m.serialize());
          }
          return s;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition()) return !0;
          for (const s in this.sourceCaches) if (this.sourceCaches[s].hasTransition()) return !0;
          for (const s in this._layers) if (this._layers[s].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(s) {
          if (!this._loaded) return;
          const h = this._changed;
          if (h) {
            const m = Object.keys(this._updatedLayers), y = Object.keys(this._removedLayers);
            (m.length || y.length) && this._updateWorkerLayers(m, y);
            for (const S in this._updatedSources) {
              const C = this._updatedSources[S];
              if (C === "reload") this._reloadSource(S);
              else {
                if (C !== "clear") throw new Error(`Invalid action ${C}`);
                this._clearSource(S);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const S in this._updatedPaintProps) this._layers[S].updateTransitions(s);
            this.light.updateTransitions(s), this.sky.updateTransitions(s), this._resetUpdates();
          }
          const f = {};
          for (const m in this.sourceCaches) {
            const y = this.sourceCaches[m];
            f[m] = y.used, y.used = !1;
          }
          for (const m of this._order) {
            const y = this._layers[m];
            y.recalculate(s, this._availableImages), !y.isHidden(s.zoom) && y.source && (this.sourceCaches[y.source].used = !0);
          }
          for (const m in f) {
            const y = this.sourceCaches[m];
            !!f[m] != !!y.used && y.fire(new l.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: m }));
          }
          this.light.recalculate(s), this.sky.recalculate(s), this.z = s.zoom, h && this.fire(new l.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const s = Object.keys(this._changedImages);
          if (s.length) {
            for (const h in this.sourceCaches) this.sourceCaches[h].reloadTilesForDependencies(["icons", "patterns"], s);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const s in this.sourceCaches) this.sourceCaches[s].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(s, h) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(s, !1), removedIds: h });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var f;
          this._checkLoaded();
          const m = this.serialize();
          if (s = h.transformStyle ? h.transformStyle(m, s) : s, ((f = h.validate) === null || f === void 0 || f) && Tr(this, l.u(s))) return !1;
          (s = l.aB(s)).layers = l.az(s.layers);
          const y = l.aC(m, s), S = this._getOperationsToPerform(y);
          if (S.unimplemented.length > 0) throw new Error(`Unimplemented: ${S.unimplemented.join(", ")}.`);
          if (S.operations.length === 0) return !1;
          for (const C of S.operations) C();
          return this.stylesheet = s, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(s) {
          const h = [], f = [];
          for (const m of s) switch (m.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              h.push(() => this.addLayer.apply(this, m.args));
              break;
            case "removeLayer":
              h.push(() => this.removeLayer.apply(this, m.args));
              break;
            case "setPaintProperty":
              h.push(() => this.setPaintProperty.apply(this, m.args));
              break;
            case "setLayoutProperty":
              h.push(() => this.setLayoutProperty.apply(this, m.args));
              break;
            case "setFilter":
              h.push(() => this.setFilter.apply(this, m.args));
              break;
            case "addSource":
              h.push(() => this.addSource.apply(this, m.args));
              break;
            case "removeSource":
              h.push(() => this.removeSource.apply(this, m.args));
              break;
            case "setLayerZoomRange":
              h.push(() => this.setLayerZoomRange.apply(this, m.args));
              break;
            case "setLight":
              h.push(() => this.setLight.apply(this, m.args));
              break;
            case "setGeoJSONSourceData":
              h.push(() => this.setGeoJSONSourceData.apply(this, m.args));
              break;
            case "setGlyphs":
              h.push(() => this.setGlyphs.apply(this, m.args));
              break;
            case "setSprite":
              h.push(() => this.setSprite.apply(this, m.args));
              break;
            case "setSky":
              h.push(() => this.setSky.apply(this, m.args));
              break;
            case "setTerrain":
              h.push(() => this.map.setTerrain.apply(this, m.args));
              break;
            case "setTransition":
              h.push(() => {
              });
              break;
            default:
              f.push(m.command);
          }
          return { operations: h, unimplemented: f };
        }
        addImage(s, h) {
          if (this.getImage(s)) return this.fire(new l.j(new Error(`An image named "${s}" already exists.`)));
          this.imageManager.addImage(s, h), this._afterImageUpdated(s);
        }
        updateImage(s, h) {
          this.imageManager.updateImage(s, h);
        }
        getImage(s) {
          return this.imageManager.getImage(s);
        }
        removeImage(s) {
          if (!this.getImage(s)) return this.fire(new l.j(new Error(`An image named "${s}" does not exist.`)));
          this.imageManager.removeImage(s), this._afterImageUpdated(s);
        }
        _afterImageUpdated(s) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[s] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (this._checkLoaded(), this.sourceCaches[s] !== void 0) throw new Error(`Source "${s}" already exists.`);
          if (!h.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(h).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(h.type) >= 0 && this._validate(l.u.source, `sources.${s}`, h, null, f)) return;
          this.map && this.map._collectResourceTiming && (h.collectResourceTiming = !0);
          const m = this.sourceCaches[s] = new jt(s, h, this.dispatcher);
          m.style = this, m.setEventedParent(this, () => ({ isSourceLoaded: m.loaded(), source: m.serialize(), sourceId: s })), m.onAdd(this.map), this._changed = !0;
        }
        removeSource(s) {
          if (this._checkLoaded(), this.sourceCaches[s] === void 0) throw new Error("There is no source with this ID");
          for (const f in this._layers) if (this._layers[f].source === s) return this.fire(new l.j(new Error(`Source "${s}" cannot be removed while layer "${f}" is using it.`)));
          const h = this.sourceCaches[s];
          delete this.sourceCaches[s], delete this._updatedSources[s], h.fire(new l.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: s })), h.setEventedParent(null), h.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(s, h) {
          if (this._checkLoaded(), this.sourceCaches[s] === void 0) throw new Error(`There is no source with this ID=${s}`);
          const f = this.sourceCaches[s].getSource();
          if (f.type !== "geojson") throw new Error(`geojsonSource.type is ${f.type}, which is !== 'geojson`);
          f.setData(h), this._changed = !0;
        }
        getSource(s) {
          return this.sourceCaches[s] && this.sourceCaches[s].getSource();
        }
        addLayer(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._checkLoaded();
          const m = s.id;
          if (this.getLayer(m)) return void this.fire(new l.j(new Error(`Layer "${m}" already exists on this map.`)));
          let y;
          if (s.type === "custom") {
            if (Tr(this, l.aD(s))) return;
            y = l.aA(s);
          } else {
            if ("source" in s && typeof s.source == "object" && (this.addSource(m, s.source), s = l.aB(s), s = l.e(s, { source: m })), this._validate(l.u.layer, `layers.${m}`, s, { arrayIndex: -1 }, f)) return;
            y = l.aA(s), this._validateLayer(y), y.setEventedParent(this, { layer: { id: m } });
          }
          const S = h ? this._order.indexOf(h) : this._order.length;
          if (h && S === -1) this.fire(new l.j(new Error(`Cannot add layer "${m}" before non-existing layer "${h}".`)));
          else {
            if (this._order.splice(S, 0, m), this._layerOrderChanged = !0, this._layers[m] = y, this._removedLayers[m] && y.source && y.type !== "custom") {
              const C = this._removedLayers[m];
              delete this._removedLayers[m], C.type !== y.type ? this._updatedSources[y.source] = "clear" : (this._updatedSources[y.source] = "reload", this.sourceCaches[y.source].pause());
            }
            this._updateLayer(y), y.onAdd && y.onAdd(this.map);
          }
        }
        moveLayer(s, h) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[s]) return void this.fire(new l.j(new Error(`The layer '${s}' does not exist in the map's style and cannot be moved.`)));
          if (s === h) return;
          const f = this._order.indexOf(s);
          this._order.splice(f, 1);
          const m = h ? this._order.indexOf(h) : this._order.length;
          h && m === -1 ? this.fire(new l.j(new Error(`Cannot move layer "${s}" before non-existing layer "${h}".`))) : (this._order.splice(m, 0, s), this._layerOrderChanged = !0);
        }
        removeLayer(s) {
          this._checkLoaded();
          const h = this._layers[s];
          if (!h) return void this.fire(new l.j(new Error(`Cannot remove non-existing layer "${s}".`)));
          h.setEventedParent(null);
          const f = this._order.indexOf(s);
          this._order.splice(f, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[s] = h, delete this._layers[s], this._serializedLayers && delete this._serializedLayers[s], delete this._updatedLayers[s], delete this._updatedPaintProps[s], h.onRemove && h.onRemove(this.map);
        }
        getLayer(s) {
          return this._layers[s];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(s) {
          return s in this._layers;
        }
        setLayerZoomRange(s, h, f) {
          this._checkLoaded();
          const m = this.getLayer(s);
          m ? m.minzoom === h && m.maxzoom === f || (h != null && (m.minzoom = h), f != null && (m.maxzoom = f), this._updateLayer(m)) : this.fire(new l.j(new Error(`Cannot set the zoom range of non-existing layer "${s}".`)));
        }
        setFilter(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._checkLoaded();
          const m = this.getLayer(s);
          if (m) {
            if (!l.aE(m.filter, h)) return h == null ? (m.filter = void 0, void this._updateLayer(m)) : void (this._validate(l.u.filter, `layers.${m.id}.filter`, h, null, f) || (m.filter = l.aB(h), this._updateLayer(m)));
          } else this.fire(new l.j(new Error(`Cannot filter non-existing layer "${s}".`)));
        }
        getFilter(s) {
          return l.aB(this.getLayer(s).filter);
        }
        setLayoutProperty(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          this._checkLoaded();
          const y = this.getLayer(s);
          y ? l.aE(y.getLayoutProperty(h), f) || (y.setLayoutProperty(h, f, m), this._updateLayer(y)) : this.fire(new l.j(new Error(`Cannot style non-existing layer "${s}".`)));
        }
        getLayoutProperty(s, h) {
          const f = this.getLayer(s);
          if (f) return f.getLayoutProperty(h);
          this.fire(new l.j(new Error(`Cannot get style of non-existing layer "${s}".`)));
        }
        setPaintProperty(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          this._checkLoaded();
          const y = this.getLayer(s);
          y ? l.aE(y.getPaintProperty(h), f) || (y.setPaintProperty(h, f, m) && this._updateLayer(y), this._changed = !0, this._updatedPaintProps[s] = !0, this._serializedLayers = null) : this.fire(new l.j(new Error(`Cannot style non-existing layer "${s}".`)));
        }
        getPaintProperty(s, h) {
          return this.getLayer(s).getPaintProperty(h);
        }
        setFeatureState(s, h) {
          this._checkLoaded();
          const f = s.source, m = s.sourceLayer, y = this.sourceCaches[f];
          if (y === void 0) return void this.fire(new l.j(new Error(`The source '${f}' does not exist in the map's style.`)));
          const S = y.getSource().type;
          S === "geojson" && m ? this.fire(new l.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : S !== "vector" || m ? (s.id === void 0 && this.fire(new l.j(new Error("The feature id parameter must be provided."))), y.setFeatureState(m, s.id, h)) : this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(s, h) {
          this._checkLoaded();
          const f = s.source, m = this.sourceCaches[f];
          if (m === void 0) return void this.fire(new l.j(new Error(`The source '${f}' does not exist in the map's style.`)));
          const y = m.getSource().type, S = y === "vector" ? s.sourceLayer : void 0;
          y !== "vector" || S ? h && typeof s.id != "string" && typeof s.id != "number" ? this.fire(new l.j(new Error("A feature id is required to remove its specific state property."))) : m.removeFeatureState(S, s.id, h) : this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(s) {
          this._checkLoaded();
          const h = s.source, f = s.sourceLayer, m = this.sourceCaches[h];
          if (m !== void 0) return m.getSource().type !== "vector" || f ? (s.id === void 0 && this.fire(new l.j(new Error("The feature id parameter must be provided."))), m.getFeatureState(f, s.id)) : void this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new l.j(new Error(`The source '${h}' does not exist in the map's style.`)));
        }
        getTransition() {
          return l.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const s = l.aF(this.sourceCaches, (y) => y.serialize()), h = this._serializeByIds(this._order, !0), f = this.map.getTerrain() || void 0, m = this.stylesheet;
          return l.aG({ version: m.version, name: m.name, metadata: m.metadata, light: m.light, sky: m.sky, center: m.center, zoom: m.zoom, bearing: m.bearing, pitch: m.pitch, sprite: m.sprite, glyphs: m.glyphs, transition: m.transition, sources: s, layers: h, terrain: f }, (y) => y !== void 0);
        }
        _updateLayer(s) {
          this._updatedLayers[s.id] = !0, s.source && !this._updatedSources[s.source] && this.sourceCaches[s.source].getSource().type !== "raster" && (this._updatedSources[s.source] = "reload", this.sourceCaches[s.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(s) {
          const h = (S) => this._layers[S].type === "fill-extrusion", f = {}, m = [];
          for (let S = this._order.length - 1; S >= 0; S--) {
            const C = this._order[S];
            if (h(C)) {
              f[C] = S;
              for (const B of s) {
                const D = B[C];
                if (D) for (const z of D) m.push(z);
              }
            }
          }
          m.sort((S, C) => C.intersectionZ - S.intersectionZ);
          const y = [];
          for (let S = this._order.length - 1; S >= 0; S--) {
            const C = this._order[S];
            if (h(C)) for (let B = m.length - 1; B >= 0; B--) {
              const D = m[B].feature;
              if (f[D.layer.id] < S) break;
              y.push(D), m.pop();
            }
            else for (const B of s) {
              const D = B[C];
              if (D) for (const z of D) y.push(z.feature);
            }
          }
          return y;
        }
        queryRenderedFeatures(s, h, f) {
          h && h.filter && this._validate(l.u.filter, "queryRenderedFeatures.filter", h.filter, null, h);
          const m = {};
          if (h && h.layers) {
            if (!Array.isArray(h.layers)) return this.fire(new l.j(new Error("parameters.layers must be an Array."))), [];
            for (const C of h.layers) {
              const B = this._layers[C];
              if (!B) return this.fire(new l.j(new Error(`The layer '${C}' does not exist in the map's style and cannot be queried for features.`))), [];
              m[B.source] = !0;
            }
          }
          const y = [];
          h.availableImages = this._availableImages;
          const S = this._serializedAllLayers();
          for (const C in this.sourceCaches) h.layers && !m[C] || y.push(Nt(this.sourceCaches[C], this._layers, S, s, h, f));
          return this.placement && y.push(function(C, B, D, z, N, X, Z) {
            const W = {}, Q = X.queryRenderedSymbols(z), le = [];
            for (const ue of Object.keys(Q).map(Number)) le.push(Z[ue]);
            le.sort(an);
            for (const ue of le) {
              const fe = ue.featureIndex.lookupSymbolFeatures(Q[ue.bucketInstanceId], B, ue.bucketIndex, ue.sourceLayerIndex, N.filter, N.layers, N.availableImages, C);
              for (const he in fe) {
                const ve = W[he] = W[he] || [], Be = fe[he];
                Be.sort((Pe, Qe) => {
                  const ft = ue.featureSortOrder;
                  if (ft) {
                    const _t = ft.indexOf(Pe.featureIndex);
                    return ft.indexOf(Qe.featureIndex) - _t;
                  }
                  return Qe.featureIndex - Pe.featureIndex;
                });
                for (const Pe of Be) ve.push(Pe);
              }
            }
            for (const ue in W) W[ue].forEach((fe) => {
              const he = fe.feature, ve = D[C[ue].source].getFeatureState(he.layer["source-layer"], he.id);
              he.source = he.layer.source, he.layer["source-layer"] && (he.sourceLayer = he.layer["source-layer"]), he.state = ve;
            });
            return W;
          }(this._layers, S, this.sourceCaches, s, h, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(y);
        }
        querySourceFeatures(s, h) {
          h && h.filter && this._validate(l.u.filter, "querySourceFeatures.filter", h.filter, null, h);
          const f = this.sourceCaches[s];
          return f ? function(m, y) {
            const S = m.getRenderableIds().map((D) => m.getTileByID(D)), C = [], B = {};
            for (let D = 0; D < S.length; D++) {
              const z = S[D], N = z.tileID.canonical.key;
              B[N] || (B[N] = !0, z.querySourceFeatures(C, y));
            }
            return C;
          }(f, h) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this._checkLoaded();
          const f = this.light.getLight();
          let m = !1;
          for (const S in s) if (!l.aE(s[S], f[S])) {
            m = !0;
            break;
          }
          if (!m) return;
          const y = { now: T.now(), transition: l.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(s, h), this.light.updateTransitions(y);
        }
        getSky() {
          var s;
          return (s = this.stylesheet) === null || s === void 0 ? void 0 : s.sky;
        }
        setSky(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const f = this.getSky();
          let m = !1;
          if (!s && !f) return;
          if (s && !f) m = !0;
          else if (!s && f) m = !0;
          else for (const S in s) if (!l.aE(s[S], f[S])) {
            m = !0;
            break;
          }
          if (!m) return;
          const y = { now: T.now(), transition: l.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = s, this.sky.setSky(s, h), this.sky.updateTransitions(y);
        }
        _validate(s, h, f, m) {
          let y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return (!y || y.validate !== !1) && Tr(this, s.call(l.u, l.e({ key: h, style: this.serialize(), value: f, styleSpec: l.v }, m)));
        }
        _remove() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Ot().off(gt, this._rtlPluginLoaded);
          for (const h in this._layers) this._layers[h].setEventedParent(null);
          for (const h in this.sourceCaches) {
            const f = this.sourceCaches[h];
            f.setEventedParent(null), f.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), s && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(s);
        }
        _clearSource(s) {
          this.sourceCaches[s].clearTiles();
        }
        _reloadSource(s) {
          this.sourceCaches[s].resume(), this.sourceCaches[s].reload();
        }
        _updateSources(s) {
          for (const h in this.sourceCaches) this.sourceCaches[h].update(s, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const s in this.sourceCaches) this._reloadSource(s);
        }
        _updatePlacement(s, h, f, m) {
          let y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, S = !1, C = !1;
          const B = {};
          for (const D of this._order) {
            const z = this._layers[D];
            if (z.type !== "symbol") continue;
            if (!B[z.source]) {
              const X = this.sourceCaches[z.source];
              B[z.source] = X.getRenderableIds(!0).map((Z) => X.getTileByID(Z)).sort((Z, W) => W.tileID.overscaledZ - Z.tileID.overscaledZ || (Z.tileID.isLessThan(W.tileID) ? -1 : 1));
            }
            const N = this.crossTileSymbolIndex.addLayer(z, B[z.source], s.center.lng);
            S = S || N;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((y = y || this._layerOrderChanged || f === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(T.now(), s.zoom)) && (this.pauseablePlacement = new Yn(s, this.map.terrain, this._order, y, h, f, m, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, B), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(T.now()), C = !0), S && this.pauseablePlacement.placement.setStale()), C || S) for (const D of this._order) {
            const z = this._layers[D];
            z.type === "symbol" && this.placement.updateLayerOpacities(z, B[z.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(T.now());
        }
        _releaseSymbolFadeTiles() {
          for (const s in this.sourceCaches) this.sourceCaches[s].releaseSymbolFadeTiles();
        }
        getImages(s, h) {
          return l._(this, void 0, void 0, function* () {
            const f = yield this.imageManager.getImages(h.icons);
            this._updateTilesForChangedImages();
            const m = this.sourceCaches[h.source];
            return m && m.setDependencies(h.tileID.key, h.type, h.icons), f;
          });
        }
        getGlyphs(s, h) {
          return l._(this, void 0, void 0, function* () {
            const f = yield this.glyphManager.getGlyphs(h.stacks), m = this.sourceCaches[h.source];
            return m && m.setDependencies(h.tileID.key, h.type, [""]), f;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this._checkLoaded(), s && this._validate(l.u.glyphs, "glyphs", s, null, h) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = s, this.glyphManager.entries = {}, this.glyphManager.setURL(s));
        }
        addSprite(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m = arguments.length > 3 ? arguments[3] : void 0;
          this._checkLoaded();
          const y = [{ id: s, url: h }], S = [...Ge(this.stylesheet.sprite), ...y];
          this._validate(l.u.sprite, "sprite", S, null, f) || (this.stylesheet.sprite = S, this._loadSprite(y, !0, m));
        }
        removeSprite(s) {
          this._checkLoaded();
          const h = Ge(this.stylesheet.sprite);
          if (h.find((f) => f.id === s)) {
            if (this._spritesImagesIds[s]) for (const f of this._spritesImagesIds[s]) this.imageManager.removeImage(f), this._changedImages[f] = !0;
            h.splice(h.findIndex((f) => f.id === s), 1), this.stylesheet.sprite = h.length > 0 ? h : void 0, delete this._spritesImagesIds[s], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
          } else this.fire(new l.j(new Error(`Sprite "${s}" doesn't exists on this map.`)));
        }
        getSprite() {
          return Ge(this.stylesheet.sprite);
        }
        setSprite(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = arguments.length > 2 ? arguments[2] : void 0;
          this._checkLoaded(), s && this._validate(l.u.sprite, "sprite", s, null, h) || (this.stylesheet.sprite = s, s ? this._loadSprite(s, !0, f) : (this._unloadSprite(), f && f(null)));
        }
      }
      var as = l.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const Ji = { prelude: Xn(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Xn(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Xn(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Xn(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Xn("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Xn(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`), heatmapTexture: Xn(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Xn("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Xn("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Xn("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Xn(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Xn(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Xn(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Xn(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Xn(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Xn(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Xn(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Xn(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Xn(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Xn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Xn(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Xn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Xn(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Xn(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Xn(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Xn(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Xn("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Xn("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Xn("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: Xn("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Xn(g, s) {
        const h = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, f = s.match(/attribute ([\w]+) ([\w]+)/g), m = g.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), y = s.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), S = y ? y.concat(m) : m, C = {};
        return { fragmentSource: g = g.replace(h, (B, D, z, N, X) => (C[X] = !0, D === "define" ? `
#ifndef HAS_UNIFORM_u_${X}
varying ${z} ${N} ${X};
#else
uniform ${z} ${N} u_${X};
#endif
` : `
#ifdef HAS_UNIFORM_u_${X}
    ${z} ${N} ${X} = u_${X};
#endif
`)), vertexSource: s = s.replace(h, (B, D, z, N, X) => {
          const Z = N === "float" ? "vec2" : "vec4", W = X.match(/color/) ? "color" : Z;
          return C[X] ? D === "define" ? `
#ifndef HAS_UNIFORM_u_${X}
uniform lowp float u_${X}_t;
attribute ${z} ${Z} a_${X};
varying ${z} ${N} ${X};
#else
uniform ${z} ${N} u_${X};
#endif
` : W === "vec4" ? `
#ifndef HAS_UNIFORM_u_${X}
    ${X} = a_${X};
#else
    ${z} ${N} ${X} = u_${X};
#endif
` : `
#ifndef HAS_UNIFORM_u_${X}
    ${X} = unpack_mix_${W}(a_${X}, u_${X}_t);
#else
    ${z} ${N} ${X} = u_${X};
#endif
` : D === "define" ? `
#ifndef HAS_UNIFORM_u_${X}
uniform lowp float u_${X}_t;
attribute ${z} ${Z} a_${X};
#else
uniform ${z} ${N} u_${X};
#endif
` : W === "vec4" ? `
#ifndef HAS_UNIFORM_u_${X}
    ${z} ${N} ${X} = a_${X};
#else
    ${z} ${N} ${X} = u_${X};
#endif
` : `
#ifndef HAS_UNIFORM_u_${X}
    ${z} ${N} ${X} = unpack_mix_${W}(a_${X}, u_${X}_t);
#else
    ${z} ${N} ${X} = u_${X};
#endif
`;
        }), staticAttributes: f, staticUniforms: S };
      }
      class Sa {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(s, h, f, m, y, S, C, B, D) {
          this.context = s;
          let z = this.boundPaintVertexBuffers.length !== m.length;
          for (let N = 0; !z && N < m.length; N++) this.boundPaintVertexBuffers[N] !== m[N] && (z = !0);
          !this.vao || this.boundProgram !== h || this.boundLayoutVertexBuffer !== f || z || this.boundIndexBuffer !== y || this.boundVertexOffset !== S || this.boundDynamicVertexBuffer !== C || this.boundDynamicVertexBuffer2 !== B || this.boundDynamicVertexBuffer3 !== D ? this.freshBind(h, f, m, y, S, C, B, D) : (s.bindVertexArray.set(this.vao), C && C.bind(), y && y.dynamicDraw && y.bind(), B && B.bind(), D && D.bind());
        }
        freshBind(s, h, f, m, y, S, C, B) {
          const D = s.numAttributes, z = this.context, N = z.gl;
          this.vao && this.destroy(), this.vao = z.createVertexArray(), z.bindVertexArray.set(this.vao), this.boundProgram = s, this.boundLayoutVertexBuffer = h, this.boundPaintVertexBuffers = f, this.boundIndexBuffer = m, this.boundVertexOffset = y, this.boundDynamicVertexBuffer = S, this.boundDynamicVertexBuffer2 = C, this.boundDynamicVertexBuffer3 = B, h.enableAttributes(N, s);
          for (const X of f) X.enableAttributes(N, s);
          S && S.enableAttributes(N, s), C && C.enableAttributes(N, s), B && B.enableAttributes(N, s), h.bind(), h.setVertexAttribPointers(N, s, y);
          for (const X of f) X.bind(), X.setVertexAttribPointers(N, s, y);
          S && (S.bind(), S.setVertexAttribPointers(N, s, y)), m && m.bind(), C && (C.bind(), C.setVertexAttribPointers(N, s, y)), B && (B.bind(), B.setVertexAttribPointers(N, s, y)), z.currentNumAttributes = D;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const Ya = (g, s, h, f, m) => ({ u_matrix: g, u_texture: 0, u_ele_delta: s, u_fog_matrix: h, u_fog_color: f ? f.properties.get("fog-color") : l.aM.white, u_fog_ground_blend: f ? f.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: f ? f.calculateFogBlendOpacity(m) : 0, u_horizon_color: f ? f.properties.get("horizon-color") : l.aM.white, u_horizon_fog_blend: f ? f.properties.get("horizon-fog-blend") : 1 });
      function ae(g) {
        const s = [];
        for (let h = 0; h < g.length; h++) {
          if (g[h] === null) continue;
          const f = g[h].split(" ");
          s.push(f.pop());
        }
        return s;
      }
      class me {
        constructor(s, h, f, m, y, S) {
          const C = s.gl;
          this.program = C.createProgram();
          const B = ae(h.staticAttributes), D = f ? f.getBinderAttributes() : [], z = B.concat(D), N = Ji.prelude.staticUniforms ? ae(Ji.prelude.staticUniforms) : [], X = h.staticUniforms ? ae(h.staticUniforms) : [], Z = f ? f.getBinderUniforms() : [], W = N.concat(X).concat(Z), Q = [];
          for (const Pe of W) Q.indexOf(Pe) < 0 && Q.push(Pe);
          const le = f ? f.defines() : [];
          y && le.push("#define OVERDRAW_INSPECTOR;"), S && le.push("#define TERRAIN3D;");
          const ue = le.concat(Ji.prelude.fragmentSource, h.fragmentSource).join(`
`), fe = le.concat(Ji.prelude.vertexSource, h.vertexSource).join(`
`), he = C.createShader(C.FRAGMENT_SHADER);
          if (C.isContextLost()) return void (this.failedToCreate = !0);
          if (C.shaderSource(he, ue), C.compileShader(he), !C.getShaderParameter(he, C.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${C.getShaderInfoLog(he)}`);
          C.attachShader(this.program, he);
          const ve = C.createShader(C.VERTEX_SHADER);
          if (C.isContextLost()) return void (this.failedToCreate = !0);
          if (C.shaderSource(ve, fe), C.compileShader(ve), !C.getShaderParameter(ve, C.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${C.getShaderInfoLog(ve)}`);
          C.attachShader(this.program, ve), this.attributes = {};
          const Be = {};
          this.numAttributes = z.length;
          for (let Pe = 0; Pe < this.numAttributes; Pe++) z[Pe] && (C.bindAttribLocation(this.program, Pe, z[Pe]), this.attributes[z[Pe]] = Pe);
          if (C.linkProgram(this.program), !C.getProgramParameter(this.program, C.LINK_STATUS)) throw new Error(`Program failed to link: ${C.getProgramInfoLog(this.program)}`);
          C.deleteShader(ve), C.deleteShader(he);
          for (let Pe = 0; Pe < Q.length; Pe++) {
            const Qe = Q[Pe];
            if (Qe && !Be[Qe]) {
              const ft = C.getUniformLocation(this.program, Qe);
              ft && (Be[Qe] = ft);
            }
          }
          this.fixedUniforms = m(s, Be), this.terrainUniforms = ((Pe, Qe) => ({ u_depth: new l.aH(Pe, Qe.u_depth), u_terrain: new l.aH(Pe, Qe.u_terrain), u_terrain_dim: new l.aI(Pe, Qe.u_terrain_dim), u_terrain_matrix: new l.aJ(Pe, Qe.u_terrain_matrix), u_terrain_unpack: new l.aK(Pe, Qe.u_terrain_unpack), u_terrain_exaggeration: new l.aI(Pe, Qe.u_terrain_exaggeration) }))(s, Be), this.binderUniforms = f ? f.getUniforms(s, Be) : [];
        }
        draw(s, h, f, m, y, S, C, B, D, z, N, X, Z, W, Q, le, ue, fe) {
          const he = s.gl;
          if (this.failedToCreate) return;
          if (s.program.set(this.program), s.setDepthMode(f), s.setStencilMode(m), s.setColorMode(y), s.setCullFace(S), B) {
            s.activeTexture.set(he.TEXTURE2), he.bindTexture(he.TEXTURE_2D, B.depthTexture), s.activeTexture.set(he.TEXTURE3), he.bindTexture(he.TEXTURE_2D, B.texture);
            for (const Be in this.terrainUniforms) this.terrainUniforms[Be].set(B[Be]);
          }
          for (const Be in this.fixedUniforms) this.fixedUniforms[Be].set(C[Be]);
          Q && Q.setUniforms(s, this.binderUniforms, Z, { zoom: W });
          let ve = 0;
          switch (h) {
            case he.LINES:
              ve = 2;
              break;
            case he.TRIANGLES:
              ve = 3;
              break;
            case he.LINE_STRIP:
              ve = 1;
          }
          for (const Be of X.get()) {
            const Pe = Be.vaos || (Be.vaos = {});
            (Pe[D] || (Pe[D] = new Sa())).bind(s, this, z, Q ? Q.getPaintVertexBuffers() : [], N, Be.vertexOffset, le, ue, fe), he.drawElements(h, Be.primitiveLength * ve, he.UNSIGNED_SHORT, Be.primitiveOffset * ve * 2);
          }
        }
      }
      function De(g, s, h) {
        const f = 1 / wn(h, 1, s.transform.tileZoom), m = Math.pow(2, h.tileID.overscaledZ), y = h.tileSize * Math.pow(2, s.transform.tileZoom) / m, S = y * (h.tileID.canonical.x + h.tileID.wrap * m), C = y * h.tileID.canonical.y;
        return { u_image: 0, u_texsize: h.imageAtlasTexture.size, u_scale: [f, g.fromScale, g.toScale], u_fade: g.t, u_pixel_coord_upper: [S >> 16, C >> 16], u_pixel_coord_lower: [65535 & S, 65535 & C] };
      }
      const nt = (g, s, h, f) => {
        const m = s.style.light, y = m.properties.get("position"), S = [y.x, y.y, y.z], C = function() {
          var D = new l.A(9);
          return l.A != Float32Array && (D[1] = 0, D[2] = 0, D[3] = 0, D[5] = 0, D[6] = 0, D[7] = 0), D[0] = 1, D[4] = 1, D[8] = 1, D;
        }();
        m.properties.get("anchor") === "viewport" && function(D, z) {
          var N = Math.sin(z), X = Math.cos(z);
          D[0] = X, D[1] = N, D[2] = 0, D[3] = -N, D[4] = X, D[5] = 0, D[6] = 0, D[7] = 0, D[8] = 1;
        }(C, -s.transform.angle), function(D, z, N) {
          var X = z[0], Z = z[1], W = z[2];
          D[0] = X * N[0] + Z * N[3] + W * N[6], D[1] = X * N[1] + Z * N[4] + W * N[7], D[2] = X * N[2] + Z * N[5] + W * N[8];
        }(S, S, C);
        const B = m.properties.get("color");
        return { u_matrix: g, u_lightpos: S, u_lightintensity: m.properties.get("intensity"), u_lightcolor: [B.r, B.g, B.b], u_vertical_gradient: +h, u_opacity: f };
      }, Tt = (g, s, h, f, m, y, S) => l.e(nt(g, s, h, f), De(y, s, S), { u_height_factor: -Math.pow(2, m.overscaledZ) / S.tileSize / 8 }), Vt = (g) => ({ u_matrix: g }), Pn = (g, s, h, f) => l.e(Vt(g), De(h, s, f)), Br = (g, s) => ({ u_matrix: g, u_world: s }), Rr = (g, s, h, f, m) => l.e(Pn(g, s, h, f), { u_world: m }), ui = (g, s, h, f) => {
        const m = g.transform;
        let y, S;
        if (f.paint.get("circle-pitch-alignment") === "map") {
          const C = wn(h, 1, m.zoom);
          y = !0, S = [C, C];
        } else y = !1, S = m.pixelsToGLUnits;
        return { u_camera_to_center_distance: m.cameraToCenterDistance, u_scale_with_map: +(f.paint.get("circle-pitch-scale") === "map"), u_matrix: g.translatePosMatrix(s.posMatrix, h, f.paint.get("circle-translate"), f.paint.get("circle-translate-anchor")), u_pitch_with_map: +y, u_device_pixel_ratio: g.pixelRatio, u_extrude_scale: S };
      }, nr = (g, s, h) => ({ u_matrix: g, u_inv_matrix: s, u_camera_to_center_distance: h.cameraToCenterDistance, u_viewport_size: [h.width, h.height] }), Ka = function(g, s) {
        let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        return { u_matrix: g, u_color: s, u_overlay: 0, u_overlay_scale: h };
      }, Ii = (g) => ({ u_matrix: g }), dn = (g, s, h, f) => ({ u_matrix: g, u_extrude_scale: wn(s, 1, h), u_intensity: f }), Ll = (g, s, h, f) => {
        const m = l.H();
        l.aP(m, 0, g.width, g.height, 0, 0, 1);
        const y = g.context.gl;
        return { u_matrix: m, u_world: [y.drawingBufferWidth, y.drawingBufferHeight], u_image: h, u_color_ramp: f, u_opacity: s.paint.get("heatmap-opacity") };
      };
      function Ml(g, s) {
        const h = Math.pow(2, s.canonical.z), f = s.canonical.y;
        return [new l.Z(0, f / h).toLngLat().lat, new l.Z(0, (f + 1) / h).toLngLat().lat];
      }
      const xs = (g, s, h, f) => {
        const m = g.transform;
        return { u_matrix: uu(g, s, h, f), u_ratio: 1 / wn(s, 1, m.zoom), u_device_pixel_ratio: g.pixelRatio, u_units_to_pixels: [1 / m.pixelsToGLUnits[0], 1 / m.pixelsToGLUnits[1]] };
      }, Sc = (g, s, h, f, m) => l.e(xs(g, s, h, m), { u_image: 0, u_image_height: f }), Jo = (g, s, h, f, m) => {
        const y = g.transform, S = Rl(s, y);
        return { u_matrix: uu(g, s, h, m), u_texsize: s.imageAtlasTexture.size, u_ratio: 1 / wn(s, 1, y.zoom), u_device_pixel_ratio: g.pixelRatio, u_image: 0, u_scale: [S, f.fromScale, f.toScale], u_fade: f.t, u_units_to_pixels: [1 / y.pixelsToGLUnits[0], 1 / y.pixelsToGLUnits[1]] };
      }, Bl = (g, s, h, f, m, y) => {
        const S = g.lineAtlas, C = Rl(s, g.transform), B = h.layout.get("line-cap") === "round", D = S.getDash(f.from, B), z = S.getDash(f.to, B), N = D.width * m.fromScale, X = z.width * m.toScale;
        return l.e(xs(g, s, h, y), { u_patternscale_a: [C / N, -D.height / 2], u_patternscale_b: [C / X, -z.height / 2], u_sdfgamma: S.width / (256 * Math.min(N, X) * g.pixelRatio) / 2, u_image: 0, u_tex_y_a: D.y, u_tex_y_b: z.y, u_mix: m.t });
      };
      function Rl(g, s) {
        return 1 / wn(g, 1, s.tileZoom);
      }
      function uu(g, s, h, f) {
        return g.translatePosMatrix(f ? f.posMatrix : s.tileID.posMatrix, s, h.paint.get("line-translate"), h.paint.get("line-translate-anchor"));
      }
      const Zu = (g, s, h, f, m) => {
        return { u_matrix: g, u_tl_parent: s, u_scale_parent: h, u_buffer_scale: 1, u_fade_t: f.mix, u_opacity: f.opacity * m.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: m.paint.get("raster-brightness-min"), u_brightness_high: m.paint.get("raster-brightness-max"), u_saturation_factor: (S = m.paint.get("raster-saturation"), S > 0 ? 1 - 1 / (1.001 - S) : -S), u_contrast_factor: (y = m.paint.get("raster-contrast"), y > 0 ? 1 / (1 - y) : 1 + y), u_spin_weights: Ju(m.paint.get("raster-hue-rotate")) };
        var y, S;
      };
      function Ju(g) {
        g *= Math.PI / 180;
        const s = Math.sin(g), h = Math.cos(g);
        return [(2 * h + 1) / 3, (-Math.sqrt(3) * s - h + 1) / 3, (Math.sqrt(3) * s - h + 1) / 3];
      }
      const Ol = (g, s, h, f, m, y, S, C, B, D, z, N, X, Z) => {
        const W = S.transform;
        return { u_is_size_zoom_constant: +(g === "constant" || g === "source"), u_is_size_feature_constant: +(g === "constant" || g === "camera"), u_size_t: s ? s.uSizeT : 0, u_size: s ? s.uSize : 0, u_camera_to_center_distance: W.cameraToCenterDistance, u_pitch: W.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +h, u_aspect_ratio: W.width / W.height, u_fade_change: S.options.fadeDuration ? S.symbolFadeChange : 1, u_matrix: C, u_label_plane_matrix: B, u_coord_matrix: D, u_is_text: +N, u_pitch_with_map: +f, u_is_along_line: m, u_is_variable_anchor: y, u_texsize: X, u_texture: 0, u_translation: z, u_pitched_scale: Z };
      }, co = (g, s, h, f, m, y, S, C, B, D, z, N, X, Z, W) => {
        const Q = S.transform;
        return l.e(Ol(g, s, h, f, m, y, S, C, B, D, z, N, X, W), { u_gamma_scale: f ? Math.cos(Q._pitch) * Q.cameraToCenterDistance : 1, u_device_pixel_ratio: S.pixelRatio, u_is_halo: +Z });
      }, To = (g, s, h, f, m, y, S, C, B, D, z, N, X, Z) => l.e(co(g, s, h, f, m, y, S, C, B, D, z, !0, N, !0, Z), { u_texsize_icon: X, u_texture_icon: 1 }), Dl = (g, s, h) => ({ u_matrix: g, u_opacity: s, u_color: h }), Yo = (g, s, h, f, m, y) => l.e(function(S, C, B, D) {
        const z = B.imageManager.getPattern(S.from.toString()), N = B.imageManager.getPattern(S.to.toString()), { width: X, height: Z } = B.imageManager.getPixelSize(), W = Math.pow(2, D.tileID.overscaledZ), Q = D.tileSize * Math.pow(2, B.transform.tileZoom) / W, le = Q * (D.tileID.canonical.x + D.tileID.wrap * W), ue = Q * D.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: z.tl, u_pattern_br_a: z.br, u_pattern_tl_b: N.tl, u_pattern_br_b: N.br, u_texsize: [X, Z], u_mix: C.t, u_pattern_size_a: z.displaySize, u_pattern_size_b: N.displaySize, u_scale_a: C.fromScale, u_scale_b: C.toScale, u_tile_units_to_pixels: 1 / wn(D, 1, B.transform.tileZoom), u_pixel_coord_upper: [le >> 16, ue >> 16], u_pixel_coord_lower: [65535 & le, 65535 & ue] };
      }(f, y, h, m), { u_matrix: g, u_opacity: s }), Qa = { fillExtrusion: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_lightpos: new l.aN(g, s.u_lightpos), u_lightintensity: new l.aI(g, s.u_lightintensity), u_lightcolor: new l.aN(g, s.u_lightcolor), u_vertical_gradient: new l.aI(g, s.u_vertical_gradient), u_opacity: new l.aI(g, s.u_opacity) }), fillExtrusionPattern: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_lightpos: new l.aN(g, s.u_lightpos), u_lightintensity: new l.aI(g, s.u_lightintensity), u_lightcolor: new l.aN(g, s.u_lightcolor), u_vertical_gradient: new l.aI(g, s.u_vertical_gradient), u_height_factor: new l.aI(g, s.u_height_factor), u_image: new l.aH(g, s.u_image), u_texsize: new l.aO(g, s.u_texsize), u_pixel_coord_upper: new l.aO(g, s.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(g, s.u_pixel_coord_lower), u_scale: new l.aN(g, s.u_scale), u_fade: new l.aI(g, s.u_fade), u_opacity: new l.aI(g, s.u_opacity) }), fill: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix) }), fillPattern: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_image: new l.aH(g, s.u_image), u_texsize: new l.aO(g, s.u_texsize), u_pixel_coord_upper: new l.aO(g, s.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(g, s.u_pixel_coord_lower), u_scale: new l.aN(g, s.u_scale), u_fade: new l.aI(g, s.u_fade) }), fillOutline: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_world: new l.aO(g, s.u_world) }), fillOutlinePattern: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_world: new l.aO(g, s.u_world), u_image: new l.aH(g, s.u_image), u_texsize: new l.aO(g, s.u_texsize), u_pixel_coord_upper: new l.aO(g, s.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(g, s.u_pixel_coord_lower), u_scale: new l.aN(g, s.u_scale), u_fade: new l.aI(g, s.u_fade) }), circle: (g, s) => ({ u_camera_to_center_distance: new l.aI(g, s.u_camera_to_center_distance), u_scale_with_map: new l.aH(g, s.u_scale_with_map), u_pitch_with_map: new l.aH(g, s.u_pitch_with_map), u_extrude_scale: new l.aO(g, s.u_extrude_scale), u_device_pixel_ratio: new l.aI(g, s.u_device_pixel_ratio), u_matrix: new l.aJ(g, s.u_matrix) }), collisionBox: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_pixel_extrude_scale: new l.aO(g, s.u_pixel_extrude_scale) }), collisionCircle: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_inv_matrix: new l.aJ(g, s.u_inv_matrix), u_camera_to_center_distance: new l.aI(g, s.u_camera_to_center_distance), u_viewport_size: new l.aO(g, s.u_viewport_size) }), debug: (g, s) => ({ u_color: new l.aL(g, s.u_color), u_matrix: new l.aJ(g, s.u_matrix), u_overlay: new l.aH(g, s.u_overlay), u_overlay_scale: new l.aI(g, s.u_overlay_scale) }), clippingMask: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix) }), heatmap: (g, s) => ({ u_extrude_scale: new l.aI(g, s.u_extrude_scale), u_intensity: new l.aI(g, s.u_intensity), u_matrix: new l.aJ(g, s.u_matrix) }), heatmapTexture: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_world: new l.aO(g, s.u_world), u_image: new l.aH(g, s.u_image), u_color_ramp: new l.aH(g, s.u_color_ramp), u_opacity: new l.aI(g, s.u_opacity) }), hillshade: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_image: new l.aH(g, s.u_image), u_latrange: new l.aO(g, s.u_latrange), u_light: new l.aO(g, s.u_light), u_shadow: new l.aL(g, s.u_shadow), u_highlight: new l.aL(g, s.u_highlight), u_accent: new l.aL(g, s.u_accent) }), hillshadePrepare: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_image: new l.aH(g, s.u_image), u_dimension: new l.aO(g, s.u_dimension), u_zoom: new l.aI(g, s.u_zoom), u_unpack: new l.aK(g, s.u_unpack) }), line: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_ratio: new l.aI(g, s.u_ratio), u_device_pixel_ratio: new l.aI(g, s.u_device_pixel_ratio), u_units_to_pixels: new l.aO(g, s.u_units_to_pixels) }), lineGradient: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_ratio: new l.aI(g, s.u_ratio), u_device_pixel_ratio: new l.aI(g, s.u_device_pixel_ratio), u_units_to_pixels: new l.aO(g, s.u_units_to_pixels), u_image: new l.aH(g, s.u_image), u_image_height: new l.aI(g, s.u_image_height) }), linePattern: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_texsize: new l.aO(g, s.u_texsize), u_ratio: new l.aI(g, s.u_ratio), u_device_pixel_ratio: new l.aI(g, s.u_device_pixel_ratio), u_image: new l.aH(g, s.u_image), u_units_to_pixels: new l.aO(g, s.u_units_to_pixels), u_scale: new l.aN(g, s.u_scale), u_fade: new l.aI(g, s.u_fade) }), lineSDF: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_ratio: new l.aI(g, s.u_ratio), u_device_pixel_ratio: new l.aI(g, s.u_device_pixel_ratio), u_units_to_pixels: new l.aO(g, s.u_units_to_pixels), u_patternscale_a: new l.aO(g, s.u_patternscale_a), u_patternscale_b: new l.aO(g, s.u_patternscale_b), u_sdfgamma: new l.aI(g, s.u_sdfgamma), u_image: new l.aH(g, s.u_image), u_tex_y_a: new l.aI(g, s.u_tex_y_a), u_tex_y_b: new l.aI(g, s.u_tex_y_b), u_mix: new l.aI(g, s.u_mix) }), raster: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_tl_parent: new l.aO(g, s.u_tl_parent), u_scale_parent: new l.aI(g, s.u_scale_parent), u_buffer_scale: new l.aI(g, s.u_buffer_scale), u_fade_t: new l.aI(g, s.u_fade_t), u_opacity: new l.aI(g, s.u_opacity), u_image0: new l.aH(g, s.u_image0), u_image1: new l.aH(g, s.u_image1), u_brightness_low: new l.aI(g, s.u_brightness_low), u_brightness_high: new l.aI(g, s.u_brightness_high), u_saturation_factor: new l.aI(g, s.u_saturation_factor), u_contrast_factor: new l.aI(g, s.u_contrast_factor), u_spin_weights: new l.aN(g, s.u_spin_weights) }), symbolIcon: (g, s) => ({ u_is_size_zoom_constant: new l.aH(g, s.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aH(g, s.u_is_size_feature_constant), u_size_t: new l.aI(g, s.u_size_t), u_size: new l.aI(g, s.u_size), u_camera_to_center_distance: new l.aI(g, s.u_camera_to_center_distance), u_pitch: new l.aI(g, s.u_pitch), u_rotate_symbol: new l.aH(g, s.u_rotate_symbol), u_aspect_ratio: new l.aI(g, s.u_aspect_ratio), u_fade_change: new l.aI(g, s.u_fade_change), u_matrix: new l.aJ(g, s.u_matrix), u_label_plane_matrix: new l.aJ(g, s.u_label_plane_matrix), u_coord_matrix: new l.aJ(g, s.u_coord_matrix), u_is_text: new l.aH(g, s.u_is_text), u_pitch_with_map: new l.aH(g, s.u_pitch_with_map), u_is_along_line: new l.aH(g, s.u_is_along_line), u_is_variable_anchor: new l.aH(g, s.u_is_variable_anchor), u_texsize: new l.aO(g, s.u_texsize), u_texture: new l.aH(g, s.u_texture), u_translation: new l.aO(g, s.u_translation), u_pitched_scale: new l.aI(g, s.u_pitched_scale) }), symbolSDF: (g, s) => ({ u_is_size_zoom_constant: new l.aH(g, s.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aH(g, s.u_is_size_feature_constant), u_size_t: new l.aI(g, s.u_size_t), u_size: new l.aI(g, s.u_size), u_camera_to_center_distance: new l.aI(g, s.u_camera_to_center_distance), u_pitch: new l.aI(g, s.u_pitch), u_rotate_symbol: new l.aH(g, s.u_rotate_symbol), u_aspect_ratio: new l.aI(g, s.u_aspect_ratio), u_fade_change: new l.aI(g, s.u_fade_change), u_matrix: new l.aJ(g, s.u_matrix), u_label_plane_matrix: new l.aJ(g, s.u_label_plane_matrix), u_coord_matrix: new l.aJ(g, s.u_coord_matrix), u_is_text: new l.aH(g, s.u_is_text), u_pitch_with_map: new l.aH(g, s.u_pitch_with_map), u_is_along_line: new l.aH(g, s.u_is_along_line), u_is_variable_anchor: new l.aH(g, s.u_is_variable_anchor), u_texsize: new l.aO(g, s.u_texsize), u_texture: new l.aH(g, s.u_texture), u_gamma_scale: new l.aI(g, s.u_gamma_scale), u_device_pixel_ratio: new l.aI(g, s.u_device_pixel_ratio), u_is_halo: new l.aH(g, s.u_is_halo), u_translation: new l.aO(g, s.u_translation), u_pitched_scale: new l.aI(g, s.u_pitched_scale) }), symbolTextAndIcon: (g, s) => ({ u_is_size_zoom_constant: new l.aH(g, s.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aH(g, s.u_is_size_feature_constant), u_size_t: new l.aI(g, s.u_size_t), u_size: new l.aI(g, s.u_size), u_camera_to_center_distance: new l.aI(g, s.u_camera_to_center_distance), u_pitch: new l.aI(g, s.u_pitch), u_rotate_symbol: new l.aH(g, s.u_rotate_symbol), u_aspect_ratio: new l.aI(g, s.u_aspect_ratio), u_fade_change: new l.aI(g, s.u_fade_change), u_matrix: new l.aJ(g, s.u_matrix), u_label_plane_matrix: new l.aJ(g, s.u_label_plane_matrix), u_coord_matrix: new l.aJ(g, s.u_coord_matrix), u_is_text: new l.aH(g, s.u_is_text), u_pitch_with_map: new l.aH(g, s.u_pitch_with_map), u_is_along_line: new l.aH(g, s.u_is_along_line), u_is_variable_anchor: new l.aH(g, s.u_is_variable_anchor), u_texsize: new l.aO(g, s.u_texsize), u_texsize_icon: new l.aO(g, s.u_texsize_icon), u_texture: new l.aH(g, s.u_texture), u_texture_icon: new l.aH(g, s.u_texture_icon), u_gamma_scale: new l.aI(g, s.u_gamma_scale), u_device_pixel_ratio: new l.aI(g, s.u_device_pixel_ratio), u_is_halo: new l.aH(g, s.u_is_halo), u_translation: new l.aO(g, s.u_translation), u_pitched_scale: new l.aI(g, s.u_pitched_scale) }), background: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_opacity: new l.aI(g, s.u_opacity), u_color: new l.aL(g, s.u_color) }), backgroundPattern: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_opacity: new l.aI(g, s.u_opacity), u_image: new l.aH(g, s.u_image), u_pattern_tl_a: new l.aO(g, s.u_pattern_tl_a), u_pattern_br_a: new l.aO(g, s.u_pattern_br_a), u_pattern_tl_b: new l.aO(g, s.u_pattern_tl_b), u_pattern_br_b: new l.aO(g, s.u_pattern_br_b), u_texsize: new l.aO(g, s.u_texsize), u_mix: new l.aI(g, s.u_mix), u_pattern_size_a: new l.aO(g, s.u_pattern_size_a), u_pattern_size_b: new l.aO(g, s.u_pattern_size_b), u_scale_a: new l.aI(g, s.u_scale_a), u_scale_b: new l.aI(g, s.u_scale_b), u_pixel_coord_upper: new l.aO(g, s.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(g, s.u_pixel_coord_lower), u_tile_units_to_pixels: new l.aI(g, s.u_tile_units_to_pixels) }), terrain: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_texture: new l.aH(g, s.u_texture), u_ele_delta: new l.aI(g, s.u_ele_delta), u_fog_matrix: new l.aJ(g, s.u_fog_matrix), u_fog_color: new l.aL(g, s.u_fog_color), u_fog_ground_blend: new l.aI(g, s.u_fog_ground_blend), u_fog_ground_blend_opacity: new l.aI(g, s.u_fog_ground_blend_opacity), u_horizon_color: new l.aL(g, s.u_horizon_color), u_horizon_fog_blend: new l.aI(g, s.u_horizon_fog_blend) }), terrainDepth: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_ele_delta: new l.aI(g, s.u_ele_delta) }), terrainCoords: (g, s) => ({ u_matrix: new l.aJ(g, s.u_matrix), u_texture: new l.aH(g, s.u_texture), u_terrain_coords_id: new l.aI(g, s.u_terrain_coords_id), u_ele_delta: new l.aI(g, s.u_ele_delta) }), sky: (g, s) => ({ u_sky_color: new l.aL(g, s.u_sky_color), u_horizon_color: new l.aL(g, s.u_horizon_color), u_horizon: new l.aI(g, s.u_horizon), u_sky_horizon_blend: new l.aI(g, s.u_sky_horizon_blend) }) };
      class Yi {
        constructor(s, h, f) {
          this.context = s;
          const m = s.gl;
          this.buffer = m.createBuffer(), this.dynamicDraw = !!f, this.context.unbindVAO(), s.bindElementBuffer.set(this.buffer), m.bufferData(m.ELEMENT_ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? m.DYNAMIC_DRAW : m.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(s) {
          const h = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), h.bufferSubData(h.ELEMENT_ARRAY_BUFFER, 0, s.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const hu = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Fl {
        constructor(s, h, f, m) {
          this.length = h.length, this.attributes = f, this.itemSize = h.bytesPerElement, this.dynamicDraw = m, this.context = s;
          const y = s.gl;
          this.buffer = y.createBuffer(), s.bindVertexBuffer.set(this.buffer), y.bufferData(y.ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(s) {
          if (s.length !== this.length) throw new Error(`Length of new data is ${s.length}, which doesn't match current length of ${this.length}`);
          const h = this.context.gl;
          this.bind(), h.bufferSubData(h.ARRAY_BUFFER, 0, s.arrayBuffer);
        }
        enableAttributes(s, h) {
          for (let f = 0; f < this.attributes.length; f++) {
            const m = h.attributes[this.attributes[f].name];
            m !== void 0 && s.enableVertexAttribArray(m);
          }
        }
        setVertexAttribPointers(s, h, f) {
          for (let m = 0; m < this.attributes.length; m++) {
            const y = this.attributes[m], S = h.attributes[y.name];
            S !== void 0 && s.vertexAttribPointer(S, y.components, s[hu[y.type]], !1, this.itemSize, y.offset + this.itemSize * (f || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Co = /* @__PURE__ */ new WeakMap();
      function uo(g) {
        var s;
        if (Co.has(g)) return Co.get(g);
        {
          const h = (s = g.getParameter(g.VERSION)) === null || s === void 0 ? void 0 : s.startsWith("WebGL 2.0");
          return Co.set(g, h), h;
        }
      }
      class jn {
        constructor(s) {
          this.gl = s.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(s) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class ho extends jn {
        getDefault() {
          return l.aM.transparent;
        }
        set(s) {
          const h = this.current;
          (s.r !== h.r || s.g !== h.g || s.b !== h.b || s.a !== h.a || this.dirty) && (this.gl.clearColor(s.r, s.g, s.b, s.a), this.current = s, this.dirty = !1);
        }
      }
      class Yu extends jn {
        getDefault() {
          return 1;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.clearDepth(s), this.current = s, this.dirty = !1);
        }
      }
      class ws extends jn {
        getDefault() {
          return 0;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.clearStencil(s), this.current = s, this.dirty = !1);
        }
      }
      class fo extends jn {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(s) {
          const h = this.current;
          (s[0] !== h[0] || s[1] !== h[1] || s[2] !== h[2] || s[3] !== h[3] || this.dirty) && (this.gl.colorMask(s[0], s[1], s[2], s[3]), this.current = s, this.dirty = !1);
        }
      }
      class kl extends jn {
        getDefault() {
          return !0;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.depthMask(s), this.current = s, this.dirty = !1);
        }
      }
      class el extends jn {
        getDefault() {
          return 255;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.stencilMask(s), this.current = s, this.dirty = !1);
        }
      }
      class du extends jn {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(s) {
          const h = this.current;
          (s.func !== h.func || s.ref !== h.ref || s.mask !== h.mask || this.dirty) && (this.gl.stencilFunc(s.func, s.ref, s.mask), this.current = s, this.dirty = !1);
        }
      }
      class Ea extends jn {
        getDefault() {
          const s = this.gl;
          return [s.KEEP, s.KEEP, s.KEEP];
        }
        set(s) {
          const h = this.current;
          (s[0] !== h[0] || s[1] !== h[1] || s[2] !== h[2] || this.dirty) && (this.gl.stencilOp(s[0], s[1], s[2]), this.current = s, this.dirty = !1);
        }
      }
      class fu extends jn {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          s ? h.enable(h.STENCIL_TEST) : h.disable(h.STENCIL_TEST), this.current = s, this.dirty = !1;
        }
      }
      class Nl extends jn {
        getDefault() {
          return [0, 1];
        }
        set(s) {
          const h = this.current;
          (s[0] !== h[0] || s[1] !== h[1] || this.dirty) && (this.gl.depthRange(s[0], s[1]), this.current = s, this.dirty = !1);
        }
      }
      class zl extends jn {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          s ? h.enable(h.DEPTH_TEST) : h.disable(h.DEPTH_TEST), this.current = s, this.dirty = !1;
        }
      }
      class Ec extends jn {
        getDefault() {
          return this.gl.LESS;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.depthFunc(s), this.current = s, this.dirty = !1);
        }
      }
      class Os extends jn {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          s ? h.enable(h.BLEND) : h.disable(h.BLEND), this.current = s, this.dirty = !1;
        }
      }
      class Ul extends jn {
        getDefault() {
          const s = this.gl;
          return [s.ONE, s.ZERO];
        }
        set(s) {
          const h = this.current;
          (s[0] !== h[0] || s[1] !== h[1] || this.dirty) && (this.gl.blendFunc(s[0], s[1]), this.current = s, this.dirty = !1);
        }
      }
      class Tc extends jn {
        getDefault() {
          return l.aM.transparent;
        }
        set(s) {
          const h = this.current;
          (s.r !== h.r || s.g !== h.g || s.b !== h.b || s.a !== h.a || this.dirty) && (this.gl.blendColor(s.r, s.g, s.b, s.a), this.current = s, this.dirty = !1);
        }
      }
      class Cc extends jn {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.blendEquation(s), this.current = s, this.dirty = !1);
        }
      }
      class tl extends jn {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          s ? h.enable(h.CULL_FACE) : h.disable(h.CULL_FACE), this.current = s, this.dirty = !1;
        }
      }
      class jl extends jn {
        getDefault() {
          return this.gl.BACK;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.cullFace(s), this.current = s, this.dirty = !1);
        }
      }
      class Io extends jn {
        getDefault() {
          return this.gl.CCW;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.frontFace(s), this.current = s, this.dirty = !1);
        }
      }
      class Ic extends jn {
        getDefault() {
          return null;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.useProgram(s), this.current = s, this.dirty = !1);
        }
      }
      class Ta extends jn {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.activeTexture(s), this.current = s, this.dirty = !1);
        }
      }
      class Gl extends jn {
        getDefault() {
          const s = this.gl;
          return [0, 0, s.drawingBufferWidth, s.drawingBufferHeight];
        }
        set(s) {
          const h = this.current;
          (s[0] !== h[0] || s[1] !== h[1] || s[2] !== h[2] || s[3] !== h[3] || this.dirty) && (this.gl.viewport(s[0], s[1], s[2], s[3]), this.current = s, this.dirty = !1);
        }
      }
      class O extends jn {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          h.bindFramebuffer(h.FRAMEBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class te extends jn {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          h.bindRenderbuffer(h.RENDERBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class Ee extends jn {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          h.bindTexture(h.TEXTURE_2D, s), this.current = s, this.dirty = !1;
        }
      }
      class ze extends jn {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          h.bindBuffer(h.ARRAY_BUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class Xe extends jn {
        getDefault() {
          return null;
        }
        set(s) {
          const h = this.gl;
          h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class lt extends jn {
        getDefault() {
          return null;
        }
        set(s) {
          var h;
          if (s === this.current && !this.dirty) return;
          const f = this.gl;
          uo(f) ? f.bindVertexArray(s) : (h = f.getExtension("OES_vertex_array_object")) === null || h === void 0 || h.bindVertexArrayOES(s), this.current = s, this.dirty = !1;
        }
      }
      class Pt extends jn {
        getDefault() {
          return 4;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          h.pixelStorei(h.UNPACK_ALIGNMENT, s), this.current = s, this.dirty = !1;
        }
      }
      class Wt extends jn {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s), this.current = s, this.dirty = !1;
        }
      }
      class _n extends jn {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const h = this.gl;
          h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, s), this.current = s, this.dirty = !1;
        }
      }
      class Ln extends jn {
        constructor(s, h) {
          super(s), this.context = s, this.parent = h;
        }
        getDefault() {
          return null;
        }
      }
      class kn extends Ln {
        setDirty() {
          this.dirty = !0;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const h = this.gl;
          h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, s, 0), this.current = s, this.dirty = !1;
        }
      }
      class Gn extends Ln {
        set(s) {
          if (s === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const h = this.gl;
          h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_ATTACHMENT, h.RENDERBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class Or extends Ln {
        set(s) {
          if (s === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const h = this.gl;
          h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_STENCIL_ATTACHMENT, h.RENDERBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class ri {
        constructor(s, h, f, m, y) {
          this.context = s, this.width = h, this.height = f;
          const S = s.gl, C = this.framebuffer = S.createFramebuffer();
          if (this.colorAttachment = new kn(s, C), m) this.depthAttachment = y ? new Or(s, C) : new Gn(s, C);
          else if (y) throw new Error("Stencil cannot be set without depth");
          if (S.checkFramebufferStatus(S.FRAMEBUFFER) !== S.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const s = this.context.gl, h = this.colorAttachment.get();
          if (h && s.deleteTexture(h), this.depthAttachment) {
            const f = this.depthAttachment.get();
            f && s.deleteRenderbuffer(f);
          }
          s.deleteFramebuffer(this.framebuffer);
        }
      }
      class Nn {
        constructor(s, h, f) {
          this.blendFunction = s, this.blendColor = h, this.mask = f;
        }
      }
      Nn.Replace = [1, 0], Nn.disabled = new Nn(Nn.Replace, l.aM.transparent, [!1, !1, !1, !1]), Nn.unblended = new Nn(Nn.Replace, l.aM.transparent, [!0, !0, !0, !0]), Nn.alphaBlended = new Nn([1, 771], l.aM.transparent, [!0, !0, !0, !0]);
      class Di {
        constructor(s) {
          var h, f;
          if (this.gl = s, this.clearColor = new ho(this), this.clearDepth = new Yu(this), this.clearStencil = new ws(this), this.colorMask = new fo(this), this.depthMask = new kl(this), this.stencilMask = new el(this), this.stencilFunc = new du(this), this.stencilOp = new Ea(this), this.stencilTest = new fu(this), this.depthRange = new Nl(this), this.depthTest = new zl(this), this.depthFunc = new Ec(this), this.blend = new Os(this), this.blendFunc = new Ul(this), this.blendColor = new Tc(this), this.blendEquation = new Cc(this), this.cullFace = new tl(this), this.cullFaceSide = new jl(this), this.frontFace = new Io(this), this.program = new Ic(this), this.activeTexture = new Ta(this), this.viewport = new Gl(this), this.bindFramebuffer = new O(this), this.bindRenderbuffer = new te(this), this.bindTexture = new Ee(this), this.bindVertexBuffer = new ze(this), this.bindElementBuffer = new Xe(this), this.bindVertexArray = new lt(this), this.pixelStoreUnpack = new Pt(this), this.pixelStoreUnpackPremultiplyAlpha = new Wt(this), this.pixelStoreUnpackFlipY = new _n(this), this.extTextureFilterAnisotropic = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = s.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = s.getParameter(s.MAX_TEXTURE_SIZE), uo(s)) {
            this.HALF_FLOAT = s.HALF_FLOAT;
            const m = s.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (h = s.RGBA16F) !== null && h !== void 0 ? h : m == null ? void 0 : m.RGBA16F_EXT, this.RGB16F = (f = s.RGB16F) !== null && f !== void 0 ? f : m == null ? void 0 : m.RGB16F_EXT, s.getExtension("EXT_color_buffer_float");
          } else {
            s.getExtension("EXT_color_buffer_half_float"), s.getExtension("OES_texture_half_float_linear");
            const m = s.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = m == null ? void 0 : m.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(s, h) {
          return new Yi(this, s, h);
        }
        createVertexBuffer(s, h, f) {
          return new Fl(this, s, h, f);
        }
        createRenderbuffer(s, h, f) {
          const m = this.gl, y = m.createRenderbuffer();
          return this.bindRenderbuffer.set(y), m.renderbufferStorage(m.RENDERBUFFER, s, h, f), this.bindRenderbuffer.set(null), y;
        }
        createFramebuffer(s, h, f, m) {
          return new ri(this, s, h, f, m);
        }
        clear(s) {
          let { color: h, depth: f, stencil: m } = s;
          const y = this.gl;
          let S = 0;
          h && (S |= y.COLOR_BUFFER_BIT, this.clearColor.set(h), this.colorMask.set([!0, !0, !0, !0])), f !== void 0 && (S |= y.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(f), this.depthMask.set(!0)), m !== void 0 && (S |= y.STENCIL_BUFFER_BIT, this.clearStencil.set(m), this.stencilMask.set(255)), y.clear(S);
        }
        setCullFace(s) {
          s.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(s.mode), this.frontFace.set(s.frontFace));
        }
        setDepthMode(s) {
          s.func !== this.gl.ALWAYS || s.mask ? (this.depthTest.set(!0), this.depthFunc.set(s.func), this.depthMask.set(s.mask), this.depthRange.set(s.range)) : this.depthTest.set(!1);
        }
        setStencilMode(s) {
          s.test.func !== this.gl.ALWAYS || s.mask ? (this.stencilTest.set(!0), this.stencilMask.set(s.mask), this.stencilOp.set([s.fail, s.depthFail, s.pass]), this.stencilFunc.set({ func: s.test.func, ref: s.ref, mask: s.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(s) {
          l.aE(s.blendFunction, Nn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(s.blendFunction), this.blendColor.set(s.blendColor)), this.colorMask.set(s.mask);
        }
        createVertexArray() {
          var s;
          return uo(this.gl) ? this.gl.createVertexArray() : (s = this.gl.getExtension("OES_vertex_array_object")) === null || s === void 0 ? void 0 : s.createVertexArrayOES();
        }
        deleteVertexArray(s) {
          var h;
          return uo(this.gl) ? this.gl.deleteVertexArray(s) : (h = this.gl.getExtension("OES_vertex_array_object")) === null || h === void 0 ? void 0 : h.deleteVertexArrayOES(s);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class fn {
        constructor(s, h, f) {
          this.func = s, this.mask = h, this.range = f;
        }
      }
      fn.ReadOnly = !1, fn.ReadWrite = !0, fn.disabled = new fn(519, fn.ReadOnly, [0, 1]);
      const ls = 7680;
      class $n {
        constructor(s, h, f, m, y, S) {
          this.test = s, this.ref = h, this.mask = f, this.fail = m, this.depthFail = y, this.pass = S;
        }
      }
      $n.disabled = new $n({ func: 519, mask: 0 }, 0, 0, ls, ls, ls);
      class Kn {
        constructor(s, h, f) {
          this.enable = s, this.mode = h, this.frontFace = f;
        }
      }
      let Po;
      function Ko(g, s, h, f, m) {
        const y = g.context, S = y.gl, C = g.useProgram("collisionBox"), B = [];
        let D = 0, z = 0;
        for (let ue = 0; ue < f.length; ue++) {
          const fe = f[ue], he = s.getTile(fe).getBucket(h);
          if (!he) continue;
          const ve = m ? he.textCollisionBox : he.iconCollisionBox, Be = he.collisionCircleArray;
          if (Be.length > 0) {
            const Pe = l.H();
            l.aQ(Pe, he.placementInvProjMatrix, g.transform.glCoordMatrix), l.aQ(Pe, Pe, he.placementViewportMatrix), B.push({ circleArray: Be, circleOffset: z, transform: fe.posMatrix, invTransform: Pe, coord: fe }), D += Be.length / 4, z = D;
          }
          ve && C.draw(y, S.LINES, fn.disabled, $n.disabled, g.colorModeForRenderPass(), Kn.disabled, { u_matrix: fe.posMatrix, u_pixel_extrude_scale: [1 / (N = g.transform).width, 1 / N.height] }, g.style.map.terrain && g.style.map.terrain.getTerrainData(fe), h.id, ve.layoutVertexBuffer, ve.indexBuffer, ve.segments, null, g.transform.zoom, null, null, ve.collisionVertexBuffer);
        }
        var N;
        if (!m || !B.length) return;
        const X = g.useProgram("collisionCircle"), Z = new l.aR();
        Z.resize(4 * D), Z._trim();
        let W = 0;
        for (const ue of B) for (let fe = 0; fe < ue.circleArray.length / 4; fe++) {
          const he = 4 * fe, ve = ue.circleArray[he + 0], Be = ue.circleArray[he + 1], Pe = ue.circleArray[he + 2], Qe = ue.circleArray[he + 3];
          Z.emplace(W++, ve, Be, Pe, Qe, 0), Z.emplace(W++, ve, Be, Pe, Qe, 1), Z.emplace(W++, ve, Be, Pe, Qe, 2), Z.emplace(W++, ve, Be, Pe, Qe, 3);
        }
        (!Po || Po.length < 2 * D) && (Po = function(ue) {
          const fe = 2 * ue, he = new l.aT();
          he.resize(fe), he._trim();
          for (let ve = 0; ve < fe; ve++) {
            const Be = 6 * ve;
            he.uint16[Be + 0] = 4 * ve + 0, he.uint16[Be + 1] = 4 * ve + 1, he.uint16[Be + 2] = 4 * ve + 2, he.uint16[Be + 3] = 4 * ve + 2, he.uint16[Be + 4] = 4 * ve + 3, he.uint16[Be + 5] = 4 * ve + 0;
          }
          return he;
        }(D));
        const Q = y.createIndexBuffer(Po, !0), le = y.createVertexBuffer(Z, l.aS.members, !0);
        for (const ue of B) {
          const fe = nr(ue.transform, ue.invTransform, g.transform);
          X.draw(y, S.TRIANGLES, fn.disabled, $n.disabled, g.colorModeForRenderPass(), Kn.disabled, fe, g.style.map.terrain && g.style.map.terrain.getTerrainData(ue.coord), h.id, le, Q, l.a0.simpleSegment(0, 2 * ue.circleOffset, ue.circleArray.length, ue.circleArray.length / 2), null, g.transform.zoom, null, null, null);
        }
        le.destroy(), Q.destroy();
      }
      Kn.disabled = new Kn(!1, 1029, 2305), Kn.backCCW = new Kn(!0, 1029, 2305);
      const Qo = l.an(new Float32Array(16));
      function Ca(g, s, h, f, m, y) {
        const { horizontalAlign: S, verticalAlign: C } = l.au(g);
        return new l.P((-(S - 0.5) * s / m + f[0]) * y, (-(C - 0.5) * h / m + f[1]) * y);
      }
      function po(g, s, h, f, m, y) {
        const S = s.tileAnchorPoint.add(new l.P(s.translation[0], s.translation[1]));
        if (s.pitchWithMap) {
          let C = f.mult(y);
          h || (C = C.rotate(-m));
          const B = S.add(C);
          return be(B.x, B.y, s.labelPlaneMatrix, s.getElevation).point;
        }
        if (h) {
          const C = tt(s.tileAnchorPoint.x + 1, s.tileAnchorPoint.y, s).point.sub(g), B = Math.atan(C.y / C.x) + (C.x < 0 ? Math.PI : 0);
          return g.add(f.rotate(B));
        }
        return g.add(f);
      }
      function Lo(g, s, h, f, m, y, S, C, B, D, z, N, X, Z) {
        const W = g.text.placedSymbolArray, Q = g.text.dynamicLayoutVertexArray, le = g.icon.dynamicLayoutVertexArray, ue = {};
        Q.clear();
        for (let fe = 0; fe < W.length; fe++) {
          const he = W.get(fe), ve = he.hidden || !he.crossTileID || g.allowVerticalPlacement && !he.placedOrientation ? null : f[he.crossTileID];
          if (ve) {
            const Be = new l.P(he.anchorX, he.anchorY), Pe = { getElevation: Z, width: m.width, height: m.height, labelPlaneMatrix: y, lineVertexArray: null, pitchWithMap: h, projection: z, projectionCache: null, tileAnchorPoint: Be, translation: N, unwrappedTileID: X }, Qe = h ? be(Be.x, Be.y, S, Z) : tt(Be.x, Be.y, Pe), ft = J(m.cameraToCenterDistance, Qe.signedDistanceFromCamera);
            let _t = l.ai(g.textSizeData, B, he) * ft / l.ap;
            h && (_t *= g.tilePixelRatio / C);
            const { width: xt, height: bt, anchor: yt, textOffset: wt, textBoxScale: Jt } = ve, Ct = Ca(yt, xt, bt, wt, Jt, _t), It = z.getPitchedTextCorrection(m, Be.add(new l.P(N[0], N[1])), X), rn = po(Qe.point, Pe, s, Ct, m.angle, It), An = g.allowVerticalPlacement && he.placedOrientation === l.ah.vertical ? Math.PI / 2 : 0;
            for (let yn = 0; yn < he.numGlyphs; yn++) l.aj(Q, rn, An);
            D && he.associatedIconIndex >= 0 && (ue[he.associatedIconIndex] = { shiftedAnchor: rn, angle: An });
          } else Kt(he.numGlyphs, Q);
        }
        if (D) {
          le.clear();
          const fe = g.icon.placedSymbolArray;
          for (let he = 0; he < fe.length; he++) {
            const ve = fe.get(he);
            if (ve.hidden) Kt(ve.numGlyphs, le);
            else {
              const Be = ue[he];
              if (Be) for (let Pe = 0; Pe < ve.numGlyphs; Pe++) l.aj(le, Be.shiftedAnchor, Be.angle);
              else Kt(ve.numGlyphs, le);
            }
          }
          g.icon.dynamicLayoutVertexBuffer.updateData(le);
        }
        g.text.dynamicLayoutVertexBuffer.updateData(Q);
      }
      function Pi(g, s, h) {
        return h.iconsInText && s ? "symbolTextAndIcon" : g ? "symbolSDF" : "symbolIcon";
      }
      function Fi(g, s, h, f, m, y, S, C, B, D, z, N) {
        const X = g.context, Z = X.gl, W = g.transform, Q = $i(), le = C === "map", ue = B === "map", fe = C !== "viewport" && h.layout.get("symbol-placement") !== "point", he = le && !ue && !fe, ve = !ue && fe, Be = !h.layout.get("symbol-sort-key").isConstant();
        let Pe = !1;
        const Qe = g.depthModeForSublayer(0, fn.ReadOnly), ft = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset"), _t = [], xt = Q.getCircleRadiusCorrection(W);
        for (const bt of f) {
          const yt = s.getTile(bt), wt = yt.getBucket(h);
          if (!wt) continue;
          const Jt = m ? wt.text : wt.icon;
          if (!Jt || !Jt.segments.get().length || !Jt.hasVisibleVertices) continue;
          const Ct = Jt.programConfigurations.get(h.id), It = m || wt.sdfIcons, rn = m ? wt.textSizeData : wt.iconSizeData, An = ue || W.pitch !== 0, yn = g.useProgram(Pi(It, m, wt), Ct), En = l.ag(rn, W.zoom), Dn = g.style.map.terrain && g.style.map.terrain.getTerrainData(bt);
          let sr, Dr, Qn, Xr, or = [0, 0], Gr = null;
          if (m) Dr = yt.glyphAtlasTexture, Qn = Z.LINEAR, sr = yt.glyphAtlasTexture.size, wt.iconsInText && (or = yt.imageAtlasTexture.size, Gr = yt.imageAtlasTexture, Xr = An || g.options.rotating || g.options.zooming || rn.kind === "composite" || rn.kind === "camera" ? Z.LINEAR : Z.NEAREST);
          else {
            const Hn = h.layout.get("icon-size").constantOr(0) !== 1 || wt.iconsNeedLinear;
            Dr = yt.imageAtlasTexture, Qn = It || g.options.rotating || g.options.zooming || Hn || An ? Z.LINEAR : Z.NEAREST, sr = yt.imageAtlasTexture.size;
          }
          const oi = wn(yt, 1, g.transform.zoom), ts = ve ? bt.posMatrix : Qo, Cs = ti(ts, ue, le, g.transform, oi), Fr = ni(ts, ue, le, g.transform, oi), Fa = ni(bt.posMatrix, ue, le, g.transform, oi), Is = Q.translatePosition(g.transform, yt, y, S), zc = ft && wt.hasTextData(), Kl = h.layout.get("icon-text-fit") !== "none" && zc && wt.hasIconData();
          if (fe) {
            const Hn = g.style.map.terrain ? (ka, sa) => g.style.map.terrain.getElevation(bt, ka, sa) : null, ko = h.layout.get("text-rotation-alignment") === "map";
            ce(wt, bt.posMatrix, g, m, Cs, Fa, ue, D, ko, Q, bt.toUnwrapped(), W.width, W.height, Is, Hn);
          }
          const zi = bt.posMatrix, ns = m && ft || Kl, wi = fe || ns ? Qo : Cs, Ui = Fr, Kr = It && h.paint.get(m ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Li;
          Li = It ? wt.iconsInText ? To(rn.kind, En, he, ue, fe, ns, g, zi, wi, Ui, Is, sr, or, xt) : co(rn.kind, En, he, ue, fe, ns, g, zi, wi, Ui, Is, m, sr, !0, xt) : Ol(rn.kind, En, he, ue, fe, ns, g, zi, wi, Ui, Is, m, sr, xt);
          const ji = { program: yn, buffers: Jt, uniformValues: Li, atlasTexture: Dr, atlasTextureIcon: Gr, atlasInterpolation: Qn, atlasInterpolationIcon: Xr, isSDF: It, hasHalo: Kr };
          if (Be && wt.canOverlap) {
            Pe = !0;
            const Hn = Jt.segments.get();
            for (const ko of Hn) _t.push({ segments: new l.a0([ko]), sortKey: ko.sortKey, state: ji, terrainData: Dn });
          } else _t.push({ segments: Jt.segments, sortKey: 0, state: ji, terrainData: Dn });
        }
        Pe && _t.sort((bt, yt) => bt.sortKey - yt.sortKey);
        for (const bt of _t) {
          const yt = bt.state;
          if (X.activeTexture.set(Z.TEXTURE0), yt.atlasTexture.bind(yt.atlasInterpolation, Z.CLAMP_TO_EDGE), yt.atlasTextureIcon && (X.activeTexture.set(Z.TEXTURE1), yt.atlasTextureIcon && yt.atlasTextureIcon.bind(yt.atlasInterpolationIcon, Z.CLAMP_TO_EDGE)), yt.isSDF) {
            const wt = yt.uniformValues;
            yt.hasHalo && (wt.u_is_halo = 1, Ia(yt.buffers, bt.segments, h, g, yt.program, Qe, z, N, wt, bt.terrainData)), wt.u_is_halo = 0;
          }
          Ia(yt.buffers, bt.segments, h, g, yt.program, Qe, z, N, yt.uniformValues, bt.terrainData);
        }
      }
      function Ia(g, s, h, f, m, y, S, C, B, D) {
        const z = f.context;
        m.draw(z, z.gl.TRIANGLES, y, S, C, Kn.disabled, B, D, h.id, g.layoutVertexBuffer, g.indexBuffer, s, h.paint, f.transform.zoom, g.programConfigurations.get(h.id), g.dynamicLayoutVertexBuffer, g.opacityVertexBuffer);
      }
      function Pa(g, s, h, f) {
        const m = g.context, y = m.gl, S = $n.disabled, C = new Nn([y.ONE, y.ONE], l.aM.transparent, [!0, !0, !0, !0]), B = s.getBucket(h);
        if (!B) return;
        const D = f.key;
        let z = h.heatmapFbos.get(D);
        z || (z = ea(m, s.tileSize, s.tileSize), h.heatmapFbos.set(D, z)), m.bindFramebuffer.set(z.framebuffer), m.viewport.set([0, 0, s.tileSize, s.tileSize]), m.clear({ color: l.aM.transparent });
        const N = B.programConfigurations.get(h.id), X = g.useProgram("heatmap", N), Z = g.style.map.terrain.getTerrainData(f);
        X.draw(m, y.TRIANGLES, fn.disabled, S, C, Kn.disabled, dn(f.posMatrix, s, g.transform.zoom, h.paint.get("heatmap-intensity")), Z, h.id, B.layoutVertexBuffer, B.indexBuffer, B.segments, h.paint, g.transform.zoom, N);
      }
      function Ds(g, s, h) {
        const f = g.context, m = f.gl;
        f.setColorMode(g.colorModeForRenderPass());
        const y = vi(f, s), S = h.key, C = s.heatmapFbos.get(S);
        C && (f.activeTexture.set(m.TEXTURE0), m.bindTexture(m.TEXTURE_2D, C.colorAttachment.get()), f.activeTexture.set(m.TEXTURE1), y.bind(m.LINEAR, m.CLAMP_TO_EDGE), g.useProgram("heatmapTexture").draw(f, m.TRIANGLES, fn.disabled, $n.disabled, g.colorModeForRenderPass(), Kn.disabled, Ll(g, s, 0, 1), null, s.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments, s.paint, g.transform.zoom), C.destroy(), s.heatmapFbos.delete(S));
      }
      function ea(g, s, h) {
        var f, m;
        const y = g.gl, S = y.createTexture();
        y.bindTexture(y.TEXTURE_2D, S), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.LINEAR), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.LINEAR);
        const C = (f = g.HALF_FLOAT) !== null && f !== void 0 ? f : y.UNSIGNED_BYTE, B = (m = g.RGBA16F) !== null && m !== void 0 ? m : y.RGBA;
        y.texImage2D(y.TEXTURE_2D, 0, B, s, h, 0, y.RGBA, C, null);
        const D = g.createFramebuffer(s, h, !1, !1);
        return D.colorAttachment.set(S), D;
      }
      function vi(g, s) {
        return s.colorRampTexture || (s.colorRampTexture = new oe(g, s.colorRamp, g.gl.RGBA)), s.colorRampTexture;
      }
      function La(g, s, h, f, m) {
        if (!h || !f || !f.imageAtlas) return;
        const y = f.imageAtlas.patternPositions;
        let S = y[h.to.toString()], C = y[h.from.toString()];
        if (!S && C && (S = C), !C && S && (C = S), !S || !C) {
          const B = m.getPaintProperty(s);
          S = y[B], C = y[B];
        }
        S && C && g.setConstantPatternPositions(S, C);
      }
      function ta(g, s, h, f, m, y, S) {
        const C = g.context.gl, B = "fill-pattern", D = h.paint.get(B), z = D && D.constantOr(1), N = h.getCrossfadeParameters();
        let X, Z, W, Q, le;
        S ? (Z = z && !h.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", X = C.LINES) : (Z = z ? "fillPattern" : "fill", X = C.TRIANGLES);
        const ue = D.constantOr(null);
        for (const fe of f) {
          const he = s.getTile(fe);
          if (z && !he.patternsLoaded()) continue;
          const ve = he.getBucket(h);
          if (!ve) continue;
          const Be = ve.programConfigurations.get(h.id), Pe = g.useProgram(Z, Be), Qe = g.style.map.terrain && g.style.map.terrain.getTerrainData(fe);
          z && (g.context.activeTexture.set(C.TEXTURE0), he.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE), Be.updatePaintBuffers(N)), La(Be, B, ue, he, h);
          const ft = Qe ? fe : null, _t = g.translatePosMatrix(ft ? ft.posMatrix : fe.posMatrix, he, h.paint.get("fill-translate"), h.paint.get("fill-translate-anchor"));
          if (S) {
            Q = ve.indexBuffer2, le = ve.segments2;
            const xt = [C.drawingBufferWidth, C.drawingBufferHeight];
            W = Z === "fillOutlinePattern" && z ? Rr(_t, g, N, he, xt) : Br(_t, xt);
          } else Q = ve.indexBuffer, le = ve.segments, W = z ? Pn(_t, g, N, he) : Vt(_t);
          Pe.draw(g.context, X, m, g.stencilModeForClipping(fe), y, Kn.disabled, W, Qe, h.id, ve.layoutVertexBuffer, Q, le, h.paint, g.transform.zoom, Be);
        }
      }
      function nl(g, s, h, f, m, y, S) {
        const C = g.context, B = C.gl, D = "fill-extrusion-pattern", z = h.paint.get(D), N = z.constantOr(1), X = h.getCrossfadeParameters(), Z = h.paint.get("fill-extrusion-opacity"), W = z.constantOr(null);
        for (const Q of f) {
          const le = s.getTile(Q), ue = le.getBucket(h);
          if (!ue) continue;
          const fe = g.style.map.terrain && g.style.map.terrain.getTerrainData(Q), he = ue.programConfigurations.get(h.id), ve = g.useProgram(N ? "fillExtrusionPattern" : "fillExtrusion", he);
          N && (g.context.activeTexture.set(B.TEXTURE0), le.imageAtlasTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE), he.updatePaintBuffers(X)), La(he, D, W, le, h);
          const Be = g.translatePosMatrix(Q.posMatrix, le, h.paint.get("fill-extrusion-translate"), h.paint.get("fill-extrusion-translate-anchor")), Pe = h.paint.get("fill-extrusion-vertical-gradient"), Qe = N ? Tt(Be, g, Pe, Z, Q, X, le) : nt(Be, g, Pe, Z);
          ve.draw(C, C.gl.TRIANGLES, m, y, S, Kn.backCCW, Qe, fe, h.id, ue.layoutVertexBuffer, ue.indexBuffer, ue.segments, h.paint, g.transform.zoom, he, g.style.map.terrain && ue.centroidVertexBuffer);
        }
      }
      function ki(g, s, h, f, m, y, S) {
        const C = g.context, B = C.gl, D = h.fbo;
        if (!D) return;
        const z = g.useProgram("hillshade"), N = g.style.map.terrain && g.style.map.terrain.getTerrainData(s);
        C.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_2D, D.colorAttachment.get()), z.draw(C, B.TRIANGLES, m, y, S, Kn.disabled, ((X, Z, W, Q) => {
          const le = W.paint.get("hillshade-shadow-color"), ue = W.paint.get("hillshade-highlight-color"), fe = W.paint.get("hillshade-accent-color");
          let he = W.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          W.paint.get("hillshade-illumination-anchor") === "viewport" && (he -= X.transform.angle);
          const ve = !X.options.moving;
          return { u_matrix: Q ? Q.posMatrix : X.transform.calculatePosMatrix(Z.tileID.toUnwrapped(), ve), u_image: 0, u_latrange: Ml(0, Z.tileID), u_light: [W.paint.get("hillshade-exaggeration"), he], u_shadow: le, u_highlight: ue, u_accent: fe };
        })(g, h, f, N ? s : null), N, f.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments);
      }
      function Mo(g, s, h, f, m, y) {
        const S = g.context, C = S.gl, B = s.dem;
        if (B && B.data) {
          const D = B.dim, z = B.stride, N = B.getPixels();
          if (S.activeTexture.set(C.TEXTURE1), S.pixelStoreUnpackPremultiplyAlpha.set(!1), s.demTexture = s.demTexture || g.getTileTexture(z), s.demTexture) {
            const Z = s.demTexture;
            Z.update(N, { premultiply: !1 }), Z.bind(C.NEAREST, C.CLAMP_TO_EDGE);
          } else s.demTexture = new oe(S, N, C.RGBA, { premultiply: !1 }), s.demTexture.bind(C.NEAREST, C.CLAMP_TO_EDGE);
          S.activeTexture.set(C.TEXTURE0);
          let X = s.fbo;
          if (!X) {
            const Z = new oe(S, { width: D, height: D, data: null }, C.RGBA);
            Z.bind(C.LINEAR, C.CLAMP_TO_EDGE), X = s.fbo = S.createFramebuffer(D, D, !0, !1), X.colorAttachment.set(Z.texture);
          }
          S.bindFramebuffer.set(X.framebuffer), S.viewport.set([0, 0, D, D]), g.useProgram("hillshadePrepare").draw(S, C.TRIANGLES, f, m, y, Kn.disabled, ((Z, W) => {
            const Q = W.stride, le = l.H();
            return l.aP(le, 0, l.X, -l.X, 0, 0, 1), l.J(le, le, [0, -l.X, 0]), { u_matrix: le, u_image: 1, u_dimension: [Q, Q], u_zoom: Z.overscaledZ, u_unpack: W.getUnpackVector() };
          })(s.tileID, B), null, h.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments), s.needsHillshadePrepare = !1;
        }
      }
      function pu(g, s, h, f, m, y) {
        const S = f.paint.get("raster-fade-duration");
        if (!y && S > 0) {
          const C = T.now(), B = (C - g.timeAdded) / S, D = s ? (C - s.timeAdded) / S : -1, z = h.getSource(), N = m.coveringZoomLevel({ tileSize: z.tileSize, roundZoom: z.roundZoom }), X = !s || Math.abs(s.tileID.overscaledZ - N) > Math.abs(g.tileID.overscaledZ - N), Z = X && g.refreshedUponExpiration ? 1 : l.ac(X ? B : 1 - D, 0, 1);
          return g.refreshedUponExpiration && B >= 1 && (g.refreshedUponExpiration = !1), s ? { opacity: 1, mix: 1 - Z } : { opacity: Z, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const Pc = new l.aM(1, 0, 0, 1), zn = new l.aM(0, 1, 0, 1), Ki = new l.aM(0, 0, 1, 1), go = new l.aM(1, 0, 1, 1), na = new l.aM(0, 1, 1, 1);
      function Qi(g, s, h, f) {
        ra(g, 0, s + h / 2, g.transform.width, h, f);
      }
      function Bo(g, s, h, f) {
        ra(g, s - h / 2, 0, h, g.transform.height, f);
      }
      function ra(g, s, h, f, m, y) {
        const S = g.context, C = S.gl;
        C.enable(C.SCISSOR_TEST), C.scissor(s * g.pixelRatio, h * g.pixelRatio, f * g.pixelRatio, m * g.pixelRatio), S.clear({ color: y }), C.disable(C.SCISSOR_TEST);
      }
      function Fs(g, s, h) {
        const f = g.context, m = f.gl, y = h.posMatrix, S = g.useProgram("debug"), C = fn.disabled, B = $n.disabled, D = g.colorModeForRenderPass(), z = "$debug", N = g.style.map.terrain && g.style.map.terrain.getTerrainData(h);
        f.activeTexture.set(m.TEXTURE0);
        const X = s.getTileByID(h.key).latestRawTileData, Z = Math.floor((X && X.byteLength || 0) / 1024), W = s.getTile(h).tileSize, Q = 512 / Math.min(W, 512) * (h.overscaledZ / g.transform.zoom) * 0.5;
        let le = h.canonical.toString();
        h.overscaledZ !== h.canonical.z && (le += ` => ${h.overscaledZ}`), function(ue, fe) {
          ue.initDebugOverlayCanvas();
          const he = ue.debugOverlayCanvas, ve = ue.context.gl, Be = ue.debugOverlayCanvas.getContext("2d");
          Be.clearRect(0, 0, he.width, he.height), Be.shadowColor = "white", Be.shadowBlur = 2, Be.lineWidth = 1.5, Be.strokeStyle = "white", Be.textBaseline = "top", Be.font = "bold 36px Open Sans, sans-serif", Be.fillText(fe, 5, 5), Be.strokeText(fe, 5, 5), ue.debugOverlayTexture.update(he), ue.debugOverlayTexture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE);
        }(g, `${le} ${Z}kB`), S.draw(f, m.TRIANGLES, C, B, Nn.alphaBlended, Kn.disabled, Ka(y, l.aM.transparent, Q), null, z, g.debugBuffer, g.quadTriangleIndexBuffer, g.debugSegments), S.draw(f, m.LINE_STRIP, C, B, D, Kn.disabled, Ka(y, l.aM.red), N, z, g.debugBuffer, g.tileBorderIndexBuffer, g.debugSegments);
      }
      function rl(g, s, h) {
        const f = g.context, m = f.gl, y = g.colorModeForRenderPass(), S = new fn(m.LEQUAL, fn.ReadWrite, g.depthRangeFor3D), C = g.useProgram("terrain"), B = s.getTerrainMesh();
        f.bindFramebuffer.set(null), f.viewport.set([0, 0, g.width, g.height]);
        for (const D of h) {
          const z = g.renderToTexture.getTexture(D), N = s.getTerrainData(D.tileID);
          f.activeTexture.set(m.TEXTURE0), m.bindTexture(m.TEXTURE_2D, z.texture);
          const X = g.transform.calculatePosMatrix(D.tileID.toUnwrapped()), Z = s.getMeshFrameDelta(g.transform.zoom), W = g.transform.calculateFogMatrix(D.tileID.toUnwrapped()), Q = Ya(X, Z, W, g.style.sky, g.transform.pitch);
          C.draw(f, m.TRIANGLES, S, $n.disabled, y, Kn.backCCW, Q, N, "terrain", B.vertexBuffer, B.indexBuffer, B.segments);
        }
      }
      class Ma {
        constructor(s, h, f) {
          this.vertexBuffer = s, this.indexBuffer = h, this.segments = f;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class mo {
        constructor(s, h) {
          this.context = new Di(s), this.transform = h, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: l.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = jt.maxUnderzooming + jt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Zo();
        }
        resize(s, h, f) {
          if (this.width = Math.floor(s * f), this.height = Math.floor(h * f), this.pixelRatio = f, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const m of this.style._order) this.style._layers[m].resize();
        }
        setup() {
          const s = this.context, h = new l.aX();
          h.emplaceBack(0, 0), h.emplaceBack(l.X, 0), h.emplaceBack(0, l.X), h.emplaceBack(l.X, l.X), this.tileExtentBuffer = s.createVertexBuffer(h, as.members), this.tileExtentSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const f = new l.aX();
          f.emplaceBack(0, 0), f.emplaceBack(l.X, 0), f.emplaceBack(0, l.X), f.emplaceBack(l.X, l.X), this.debugBuffer = s.createVertexBuffer(f, as.members), this.debugSegments = l.a0.simpleSegment(0, 0, 4, 5);
          const m = new l.$();
          m.emplaceBack(0, 0, 0, 0), m.emplaceBack(l.X, 0, l.X, 0), m.emplaceBack(0, l.X, 0, l.X), m.emplaceBack(l.X, l.X, l.X, l.X), this.rasterBoundsBuffer = s.createVertexBuffer(m, Ft.members), this.rasterBoundsSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const y = new l.aX();
          y.emplaceBack(0, 0), y.emplaceBack(1, 0), y.emplaceBack(0, 1), y.emplaceBack(1, 1), this.viewportBuffer = s.createVertexBuffer(y, as.members), this.viewportSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const S = new l.aZ();
          S.emplaceBack(0), S.emplaceBack(1), S.emplaceBack(3), S.emplaceBack(2), S.emplaceBack(0), this.tileBorderIndexBuffer = s.createIndexBuffer(S);
          const C = new l.aY();
          C.emplaceBack(0, 1, 2), C.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = s.createIndexBuffer(C);
          const B = this.context.gl;
          this.stencilClearMode = new $n({ func: B.ALWAYS, mask: 0 }, 0, 255, B.ZERO, B.ZERO, B.ZERO);
        }
        clearStencil() {
          const s = this.context, h = s.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const f = l.H();
          l.aP(f, 0, this.width, this.height, 0, 0, 1), l.K(f, f, [h.drawingBufferWidth, h.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(s, h.TRIANGLES, fn.disabled, this.stencilClearMode, Nn.disabled, Kn.disabled, Ii(f), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(s, h) {
          if (this.currentStencilSource === s.source || !s.isTileClipped() || !h || !h.length) return;
          this.currentStencilSource = s.source;
          const f = this.context, m = f.gl;
          this.nextStencilID + h.length > 256 && this.clearStencil(), f.setColorMode(Nn.disabled), f.setDepthMode(fn.disabled);
          const y = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const S of h) {
            const C = this._tileClippingMaskIDs[S.key] = this.nextStencilID++, B = this.style.map.terrain && this.style.map.terrain.getTerrainData(S);
            y.draw(f, m.TRIANGLES, fn.disabled, new $n({ func: m.ALWAYS, mask: 0 }, C, 255, m.KEEP, m.KEEP, m.REPLACE), Nn.disabled, Kn.disabled, Ii(S.posMatrix), B, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const s = this.nextStencilID++, h = this.context.gl;
          return new $n({ func: h.NOTEQUAL, mask: 255 }, s, 255, h.KEEP, h.KEEP, h.REPLACE);
        }
        stencilModeForClipping(s) {
          const h = this.context.gl;
          return new $n({ func: h.EQUAL, mask: 255 }, this._tileClippingMaskIDs[s.key], 0, h.KEEP, h.KEEP, h.REPLACE);
        }
        stencilConfigForOverlap(s) {
          const h = this.context.gl, f = s.sort((S, C) => C.overscaledZ - S.overscaledZ), m = f[f.length - 1].overscaledZ, y = f[0].overscaledZ - m + 1;
          if (y > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + y > 256 && this.clearStencil();
            const S = {};
            for (let C = 0; C < y; C++) S[C + m] = new $n({ func: h.GEQUAL, mask: 255 }, C + this.nextStencilID, 255, h.KEEP, h.KEEP, h.REPLACE);
            return this.nextStencilID += y, [S, f];
          }
          return [{ [m]: $n.disabled }, f];
        }
        colorModeForRenderPass() {
          const s = this.context.gl;
          return this._showOverdrawInspector ? new Nn([s.CONSTANT_COLOR, s.ONE], new l.aM(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Nn.unblended : Nn.alphaBlended;
        }
        depthModeForSublayer(s, h, f) {
          if (!this.opaquePassEnabledForLayer()) return fn.disabled;
          const m = 1 - ((1 + this.currentLayer) * this.numSublayers + s) * this.depthEpsilon;
          return new fn(f || this.context.gl.LEQUAL, h, [m, m]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(s, h) {
          this.style = s, this.options = h, this.lineAtlas = s.lineAtlas, this.imageManager = s.imageManager, this.glyphManager = s.glyphManager, this.symbolFadeChange = s.placement.symbolFadeChange(T.now()), this.imageManager.beginFrame();
          const f = this.style._order, m = this.style.sourceCaches, y = {}, S = {}, C = {};
          for (const B in m) {
            const D = m[B];
            D.used && D.prepare(this.context), y[B] = D.getVisibleCoordinates(), S[B] = y[B].slice().reverse(), C[B] = D.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let B = 0; B < f.length; B++) if (this.style._layers[f[B]].is3D()) {
            this.opaquePassCutoff = B;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const B of f) {
            const D = this.style._layers[B];
            if (!D.hasOffscreenPass() || D.isHidden(this.transform.zoom)) continue;
            const z = S[D.source];
            (D.type === "custom" || z.length) && this.renderLayer(this, m[D.source], D, z);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: h.showOverdrawInspector ? l.aM.black : l.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(B, D) {
            const z = B.context, N = z.gl, X = ((ue, fe, he) => ({ u_sky_color: ue.properties.get("sky-color"), u_horizon_color: ue.properties.get("horizon-color"), u_horizon: (fe.height / 2 + fe.getHorizon()) * he, u_sky_horizon_blend: ue.properties.get("sky-horizon-blend") * fe.height / 2 * he }))(D, B.style.map.transform, B.pixelRatio), Z = new fn(N.LEQUAL, fn.ReadWrite, [0, 1]), W = $n.disabled, Q = B.colorModeForRenderPass(), le = B.useProgram("sky");
            if (!D.mesh) {
              const ue = new l.aX();
              ue.emplaceBack(-1, -1), ue.emplaceBack(1, -1), ue.emplaceBack(1, 1), ue.emplaceBack(-1, 1);
              const fe = new l.aY();
              fe.emplaceBack(0, 1, 2), fe.emplaceBack(0, 2, 3), D.mesh = new Ma(z.createVertexBuffer(ue, as.members), z.createIndexBuffer(fe), l.a0.simpleSegment(0, 0, ue.length, fe.length));
            }
            le.draw(z, N.TRIANGLES, Z, W, Q, Kn.disabled, X, void 0, "sky", D.mesh.vertexBuffer, D.mesh.indexBuffer, D.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = h.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (s._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = f.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const B = this.style._layers[f[this.currentLayer]], D = m[B.source], z = y[B.source];
            this._renderTileClippingMasks(B, z), this.renderLayer(this, D, B, z);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < f.length; this.currentLayer++) {
            const B = this.style._layers[f[this.currentLayer]], D = m[B.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(B)) continue;
            const z = (B.type === "symbol" ? C : S)[B.source];
            this._renderTileClippingMasks(B, y[B.source]), this.renderLayer(this, D, B, z);
          }
          if (this.options.showTileBoundaries) {
            const B = function(D, z) {
              let N = null;
              const X = Object.values(D._layers).flatMap((le) => le.source && !le.isHidden(z) ? [D.sourceCaches[le.source]] : []), Z = X.filter((le) => le.getSource().type === "vector"), W = X.filter((le) => le.getSource().type !== "vector"), Q = (le) => {
                (!N || N.getSource().maxzoom < le.getSource().maxzoom) && (N = le);
              };
              return Z.forEach((le) => Q(le)), N || W.forEach((le) => Q(le)), N;
            }(this.style, this.transform.zoom);
            B && function(D, z, N) {
              for (let X = 0; X < N.length; X++) Fs(D, z, N[X]);
            }(this, B, B.getVisibleCoordinates());
          }
          this.options.showPadding && function(B) {
            const D = B.transform.padding;
            Qi(B, B.transform.height - (D.top || 0), 3, Pc), Qi(B, D.bottom || 0, 3, zn), Bo(B, D.left || 0, 3, Ki), Bo(B, B.transform.width - (D.right || 0), 3, go);
            const z = B.transform.centerPoint;
            (function(N, X, Z, W) {
              ra(N, X - 1, Z - 10, 2, 20, W), ra(N, X - 10, Z - 1, 20, 2, W);
            })(B, z.x, B.transform.height - z.y, na);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(s) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const h = this.terrainFacilitator.matrix, f = this.transform.modelViewProjectionMatrix;
          let m = this.terrainFacilitator.dirty;
          m || (m = s ? !l.a_(h, f) : !l.a$(h, f)), m || (m = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), m && (l.b0(h, f), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(y, S) {
            const C = y.context, B = C.gl, D = Nn.unblended, z = new fn(B.LEQUAL, fn.ReadWrite, [0, 1]), N = S.getTerrainMesh(), X = S.sourceCache.getRenderableTiles(), Z = y.useProgram("terrainDepth");
            C.bindFramebuffer.set(S.getFramebuffer("depth").framebuffer), C.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), C.clear({ color: l.aM.transparent, depth: 1 });
            for (const W of X) {
              const Q = S.getTerrainData(W.tileID), le = { u_matrix: y.transform.calculatePosMatrix(W.tileID.toUnwrapped()), u_ele_delta: S.getMeshFrameDelta(y.transform.zoom) };
              Z.draw(C, B.TRIANGLES, z, $n.disabled, D, Kn.backCCW, le, Q, "terrain", N.vertexBuffer, N.indexBuffer, N.segments);
            }
            C.bindFramebuffer.set(null), C.viewport.set([0, 0, y.width, y.height]);
          }(this, this.style.map.terrain), function(y, S) {
            const C = y.context, B = C.gl, D = Nn.unblended, z = new fn(B.LEQUAL, fn.ReadWrite, [0, 1]), N = S.getTerrainMesh(), X = S.getCoordsTexture(), Z = S.sourceCache.getRenderableTiles(), W = y.useProgram("terrainCoords");
            C.bindFramebuffer.set(S.getFramebuffer("coords").framebuffer), C.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), C.clear({ color: l.aM.transparent, depth: 1 }), S.coordsIndex = [];
            for (const Q of Z) {
              const le = S.getTerrainData(Q.tileID);
              C.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_2D, X.texture);
              const ue = { u_matrix: y.transform.calculatePosMatrix(Q.tileID.toUnwrapped()), u_terrain_coords_id: (255 - S.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: S.getMeshFrameDelta(y.transform.zoom) };
              W.draw(C, B.TRIANGLES, z, $n.disabled, D, Kn.backCCW, ue, le, "terrain", N.vertexBuffer, N.indexBuffer, N.segments), S.coordsIndex.push(Q.tileID.key);
            }
            C.bindFramebuffer.set(null), C.viewport.set([0, 0, y.width, y.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(s, h, f, m) {
          if (!f.isHidden(this.transform.zoom) && (f.type === "background" || f.type === "custom" || (m || []).length)) switch (this.id = f.id, f.type) {
            case "symbol":
              (function(y, S, C, B, D) {
                if (y.renderPass !== "translucent") return;
                const z = $n.disabled, N = y.colorModeForRenderPass();
                (C._unevaluatedLayout.hasValue("text-variable-anchor") || C._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(X, Z, W, Q, le, ue, fe, he, ve) {
                  const Be = Z.transform, Pe = $i(), Qe = le === "map", ft = ue === "map";
                  for (const _t of X) {
                    const xt = Q.getTile(_t), bt = xt.getBucket(W);
                    if (!bt || !bt.text || !bt.text.segments.get().length) continue;
                    const yt = l.ag(bt.textSizeData, Be.zoom), wt = wn(xt, 1, Z.transform.zoom), Jt = ti(_t.posMatrix, ft, Qe, Z.transform, wt), Ct = W.layout.get("icon-text-fit") !== "none" && bt.hasIconData();
                    if (yt) {
                      const It = Math.pow(2, Be.zoom - xt.tileID.overscaledZ), rn = Z.style.map.terrain ? (yn, En) => Z.style.map.terrain.getElevation(_t, yn, En) : null, An = Pe.translatePosition(Be, xt, fe, he);
                      Lo(bt, Qe, ft, ve, Be, Jt, _t.posMatrix, It, yt, Ct, Pe, An, _t.toUnwrapped(), rn);
                    }
                  }
                }(B, y, C, S, C.layout.get("text-rotation-alignment"), C.layout.get("text-pitch-alignment"), C.paint.get("text-translate"), C.paint.get("text-translate-anchor"), D), C.paint.get("icon-opacity").constantOr(1) !== 0 && Fi(y, S, C, B, !1, C.paint.get("icon-translate"), C.paint.get("icon-translate-anchor"), C.layout.get("icon-rotation-alignment"), C.layout.get("icon-pitch-alignment"), C.layout.get("icon-keep-upright"), z, N), C.paint.get("text-opacity").constantOr(1) !== 0 && Fi(y, S, C, B, !0, C.paint.get("text-translate"), C.paint.get("text-translate-anchor"), C.layout.get("text-rotation-alignment"), C.layout.get("text-pitch-alignment"), C.layout.get("text-keep-upright"), z, N), S.map.showCollisionBoxes && (Ko(y, S, C, B, !0), Ko(y, S, C, B, !1));
              })(s, h, f, m, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(y, S, C, B) {
                if (y.renderPass !== "translucent") return;
                const D = C.paint.get("circle-opacity"), z = C.paint.get("circle-stroke-width"), N = C.paint.get("circle-stroke-opacity"), X = !C.layout.get("circle-sort-key").isConstant();
                if (D.constantOr(1) === 0 && (z.constantOr(1) === 0 || N.constantOr(1) === 0)) return;
                const Z = y.context, W = Z.gl, Q = y.depthModeForSublayer(0, fn.ReadOnly), le = $n.disabled, ue = y.colorModeForRenderPass(), fe = [];
                for (let he = 0; he < B.length; he++) {
                  const ve = B[he], Be = S.getTile(ve), Pe = Be.getBucket(C);
                  if (!Pe) continue;
                  const Qe = Pe.programConfigurations.get(C.id), ft = y.useProgram("circle", Qe), _t = Pe.layoutVertexBuffer, xt = Pe.indexBuffer, bt = y.style.map.terrain && y.style.map.terrain.getTerrainData(ve), yt = { programConfiguration: Qe, program: ft, layoutVertexBuffer: _t, indexBuffer: xt, uniformValues: ui(y, ve, Be, C), terrainData: bt };
                  if (X) {
                    const wt = Pe.segments.get();
                    for (const Jt of wt) fe.push({ segments: new l.a0([Jt]), sortKey: Jt.sortKey, state: yt });
                  } else fe.push({ segments: Pe.segments, sortKey: 0, state: yt });
                }
                X && fe.sort((he, ve) => he.sortKey - ve.sortKey);
                for (const he of fe) {
                  const { programConfiguration: ve, program: Be, layoutVertexBuffer: Pe, indexBuffer: Qe, uniformValues: ft, terrainData: _t } = he.state;
                  Be.draw(Z, W.TRIANGLES, Q, le, ue, Kn.disabled, ft, _t, C.id, Pe, Qe, he.segments, C.paint, y.transform.zoom, ve);
                }
              })(s, h, f, m);
              break;
            case "heatmap":
              (function(y, S, C, B) {
                if (C.paint.get("heatmap-opacity") === 0) return;
                const D = y.context;
                if (y.style.map.terrain) {
                  for (const z of B) {
                    const N = S.getTile(z);
                    S.hasRenderableParent(z) || (y.renderPass === "offscreen" ? Pa(y, N, C, z) : y.renderPass === "translucent" && Ds(y, C, z));
                  }
                  D.viewport.set([0, 0, y.width, y.height]);
                } else y.renderPass === "offscreen" ? function(z, N, X, Z) {
                  const W = z.context, Q = W.gl, le = $n.disabled, ue = new Nn([Q.ONE, Q.ONE], l.aM.transparent, [!0, !0, !0, !0]);
                  (function(fe, he, ve) {
                    const Be = fe.gl;
                    fe.activeTexture.set(Be.TEXTURE1), fe.viewport.set([0, 0, he.width / 4, he.height / 4]);
                    let Pe = ve.heatmapFbos.get(l.aU);
                    Pe ? (Be.bindTexture(Be.TEXTURE_2D, Pe.colorAttachment.get()), fe.bindFramebuffer.set(Pe.framebuffer)) : (Pe = ea(fe, he.width / 4, he.height / 4), ve.heatmapFbos.set(l.aU, Pe));
                  })(W, z, X), W.clear({ color: l.aM.transparent });
                  for (let fe = 0; fe < Z.length; fe++) {
                    const he = Z[fe];
                    if (N.hasRenderableParent(he)) continue;
                    const ve = N.getTile(he), Be = ve.getBucket(X);
                    if (!Be) continue;
                    const Pe = Be.programConfigurations.get(X.id), Qe = z.useProgram("heatmap", Pe), { zoom: ft } = z.transform;
                    Qe.draw(W, Q.TRIANGLES, fn.disabled, le, ue, Kn.disabled, dn(he.posMatrix, ve, ft, X.paint.get("heatmap-intensity")), null, X.id, Be.layoutVertexBuffer, Be.indexBuffer, Be.segments, X.paint, z.transform.zoom, Pe);
                  }
                  W.viewport.set([0, 0, z.width, z.height]);
                }(y, S, C, B) : y.renderPass === "translucent" && function(z, N) {
                  const X = z.context, Z = X.gl;
                  X.setColorMode(z.colorModeForRenderPass());
                  const W = N.heatmapFbos.get(l.aU);
                  W && (X.activeTexture.set(Z.TEXTURE0), Z.bindTexture(Z.TEXTURE_2D, W.colorAttachment.get()), X.activeTexture.set(Z.TEXTURE1), vi(X, N).bind(Z.LINEAR, Z.CLAMP_TO_EDGE), z.useProgram("heatmapTexture").draw(X, Z.TRIANGLES, fn.disabled, $n.disabled, z.colorModeForRenderPass(), Kn.disabled, Ll(z, N, 0, 1), null, N.id, z.viewportBuffer, z.quadTriangleIndexBuffer, z.viewportSegments, N.paint, z.transform.zoom));
                }(y, C);
              })(s, h, f, m);
              break;
            case "line":
              (function(y, S, C, B) {
                if (y.renderPass !== "translucent") return;
                const D = C.paint.get("line-opacity"), z = C.paint.get("line-width");
                if (D.constantOr(1) === 0 || z.constantOr(1) === 0) return;
                const N = y.depthModeForSublayer(0, fn.ReadOnly), X = y.colorModeForRenderPass(), Z = C.paint.get("line-dasharray"), W = C.paint.get("line-pattern"), Q = W.constantOr(1), le = C.paint.get("line-gradient"), ue = C.getCrossfadeParameters(), fe = Q ? "linePattern" : Z ? "lineSDF" : le ? "lineGradient" : "line", he = y.context, ve = he.gl;
                let Be = !0;
                for (const Pe of B) {
                  const Qe = S.getTile(Pe);
                  if (Q && !Qe.patternsLoaded()) continue;
                  const ft = Qe.getBucket(C);
                  if (!ft) continue;
                  const _t = ft.programConfigurations.get(C.id), xt = y.context.program.get(), bt = y.useProgram(fe, _t), yt = Be || bt.program !== xt, wt = y.style.map.terrain && y.style.map.terrain.getTerrainData(Pe), Jt = W.constantOr(null);
                  if (Jt && Qe.imageAtlas) {
                    const rn = Qe.imageAtlas, An = rn.patternPositions[Jt.to.toString()], yn = rn.patternPositions[Jt.from.toString()];
                    An && yn && _t.setConstantPatternPositions(An, yn);
                  }
                  const Ct = wt ? Pe : null, It = Q ? Jo(y, Qe, C, ue, Ct) : Z ? Bl(y, Qe, C, Z, ue, Ct) : le ? Sc(y, Qe, C, ft.lineClipsArray.length, Ct) : xs(y, Qe, C, Ct);
                  if (Q) he.activeTexture.set(ve.TEXTURE0), Qe.imageAtlasTexture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE), _t.updatePaintBuffers(ue);
                  else if (Z && (yt || y.lineAtlas.dirty)) he.activeTexture.set(ve.TEXTURE0), y.lineAtlas.bind(he);
                  else if (le) {
                    const rn = ft.gradients[C.id];
                    let An = rn.texture;
                    if (C.gradientVersion !== rn.version) {
                      let yn = 256;
                      if (C.stepInterpolant) {
                        const En = S.getSource().maxzoom, Dn = Pe.canonical.z === En ? Math.ceil(1 << y.transform.maxZoom - Pe.canonical.z) : 1;
                        yn = l.ac(l.aV(ft.maxLineLength / l.X * 1024 * Dn), 256, he.maxTextureSize);
                      }
                      rn.gradient = l.aW({ expression: C.gradientExpression(), evaluationKey: "lineProgress", resolution: yn, image: rn.gradient || void 0, clips: ft.lineClipsArray }), rn.texture ? rn.texture.update(rn.gradient) : rn.texture = new oe(he, rn.gradient, ve.RGBA), rn.version = C.gradientVersion, An = rn.texture;
                    }
                    he.activeTexture.set(ve.TEXTURE0), An.bind(C.stepInterpolant ? ve.NEAREST : ve.LINEAR, ve.CLAMP_TO_EDGE);
                  }
                  bt.draw(he, ve.TRIANGLES, N, y.stencilModeForClipping(Pe), X, Kn.disabled, It, wt, C.id, ft.layoutVertexBuffer, ft.indexBuffer, ft.segments, C.paint, y.transform.zoom, _t, ft.layoutVertexBuffer2), Be = !1;
                }
              })(s, h, f, m);
              break;
            case "fill":
              (function(y, S, C, B) {
                const D = C.paint.get("fill-color"), z = C.paint.get("fill-opacity");
                if (z.constantOr(1) === 0) return;
                const N = y.colorModeForRenderPass(), X = C.paint.get("fill-pattern"), Z = y.opaquePassEnabledForLayer() && !X.constantOr(1) && D.constantOr(l.aM.transparent).a === 1 && z.constantOr(0) === 1 ? "opaque" : "translucent";
                if (y.renderPass === Z) {
                  const W = y.depthModeForSublayer(1, y.renderPass === "opaque" ? fn.ReadWrite : fn.ReadOnly);
                  ta(y, S, C, B, W, N, !1);
                }
                if (y.renderPass === "translucent" && C.paint.get("fill-antialias")) {
                  const W = y.depthModeForSublayer(C.getPaintProperty("fill-outline-color") ? 2 : 0, fn.ReadOnly);
                  ta(y, S, C, B, W, N, !0);
                }
              })(s, h, f, m);
              break;
            case "fill-extrusion":
              (function(y, S, C, B) {
                const D = C.paint.get("fill-extrusion-opacity");
                if (D !== 0 && y.renderPass === "translucent") {
                  const z = new fn(y.context.gl.LEQUAL, fn.ReadWrite, y.depthRangeFor3D);
                  if (D !== 1 || C.paint.get("fill-extrusion-pattern").constantOr(1)) nl(y, S, C, B, z, $n.disabled, Nn.disabled), nl(y, S, C, B, z, y.stencilModeFor3D(), y.colorModeForRenderPass());
                  else {
                    const N = y.colorModeForRenderPass();
                    nl(y, S, C, B, z, $n.disabled, N);
                  }
                }
              })(s, h, f, m);
              break;
            case "hillshade":
              (function(y, S, C, B) {
                if (y.renderPass !== "offscreen" && y.renderPass !== "translucent") return;
                const D = y.context, z = y.depthModeForSublayer(0, fn.ReadOnly), N = y.colorModeForRenderPass(), [X, Z] = y.renderPass === "translucent" ? y.stencilConfigForOverlap(B) : [{}, B];
                for (const W of Z) {
                  const Q = S.getTile(W);
                  Q.needsHillshadePrepare !== void 0 && Q.needsHillshadePrepare && y.renderPass === "offscreen" ? Mo(y, Q, C, z, $n.disabled, N) : y.renderPass === "translucent" && ki(y, W, Q, C, z, X[W.overscaledZ], N);
                }
                D.viewport.set([0, 0, y.width, y.height]);
              })(s, h, f, m);
              break;
            case "raster":
              (function(y, S, C, B) {
                if (y.renderPass !== "translucent" || C.paint.get("raster-opacity") === 0 || !B.length) return;
                const D = y.context, z = D.gl, N = S.getSource(), X = y.useProgram("raster"), Z = y.colorModeForRenderPass(), [W, Q] = N instanceof nn ? [{}, B] : y.stencilConfigForOverlap(B), le = Q[Q.length - 1].overscaledZ, ue = !y.options.moving;
                for (const fe of Q) {
                  const he = y.depthModeForSublayer(fe.overscaledZ - le, C.paint.get("raster-opacity") === 1 ? fn.ReadWrite : fn.ReadOnly, z.LESS), ve = S.getTile(fe);
                  ve.registerFadeDuration(C.paint.get("raster-fade-duration"));
                  const Be = S.findLoadedParent(fe, 0), Pe = S.findLoadedSibling(fe), Qe = pu(ve, Be || Pe || null, S, C, y.transform, y.style.map.terrain);
                  let ft, _t;
                  const xt = C.paint.get("raster-resampling") === "nearest" ? z.NEAREST : z.LINEAR;
                  D.activeTexture.set(z.TEXTURE0), ve.texture.bind(xt, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), D.activeTexture.set(z.TEXTURE1), Be ? (Be.texture.bind(xt, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), ft = Math.pow(2, Be.tileID.overscaledZ - ve.tileID.overscaledZ), _t = [ve.tileID.canonical.x * ft % 1, ve.tileID.canonical.y * ft % 1]) : ve.texture.bind(xt, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), ve.texture.useMipmap && D.extTextureFilterAnisotropic && y.transform.pitch > 20 && z.texParameterf(z.TEXTURE_2D, D.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, D.extTextureFilterAnisotropicMax);
                  const bt = y.style.map.terrain && y.style.map.terrain.getTerrainData(fe), yt = bt ? fe : null, wt = yt ? yt.posMatrix : y.transform.calculatePosMatrix(fe.toUnwrapped(), ue), Jt = Zu(wt, _t || [0, 0], ft || 1, Qe, C);
                  N instanceof nn ? X.draw(D, z.TRIANGLES, he, $n.disabled, Z, Kn.disabled, Jt, bt, C.id, N.boundsBuffer, y.quadTriangleIndexBuffer, N.boundsSegments) : X.draw(D, z.TRIANGLES, he, W[fe.overscaledZ], Z, Kn.disabled, Jt, bt, C.id, y.rasterBoundsBuffer, y.quadTriangleIndexBuffer, y.rasterBoundsSegments);
                }
              })(s, h, f, m);
              break;
            case "background":
              (function(y, S, C, B) {
                const D = C.paint.get("background-color"), z = C.paint.get("background-opacity");
                if (z === 0) return;
                const N = y.context, X = N.gl, Z = y.transform, W = Z.tileSize, Q = C.paint.get("background-pattern");
                if (y.isPatternMissing(Q)) return;
                const le = !Q && D.a === 1 && z === 1 && y.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (y.renderPass !== le) return;
                const ue = $n.disabled, fe = y.depthModeForSublayer(0, le === "opaque" ? fn.ReadWrite : fn.ReadOnly), he = y.colorModeForRenderPass(), ve = y.useProgram(Q ? "backgroundPattern" : "background"), Be = B || Z.coveringTiles({ tileSize: W, terrain: y.style.map.terrain });
                Q && (N.activeTexture.set(X.TEXTURE0), y.imageManager.bind(y.context));
                const Pe = C.getCrossfadeParameters();
                for (const Qe of Be) {
                  const ft = B ? Qe.posMatrix : y.transform.calculatePosMatrix(Qe.toUnwrapped()), _t = Q ? Yo(ft, z, y, Q, { tileID: Qe, tileSize: W }, Pe) : Dl(ft, z, D), xt = y.style.map.terrain && y.style.map.terrain.getTerrainData(Qe);
                  ve.draw(N, X.TRIANGLES, fe, ue, he, Kn.disabled, _t, xt, C.id, y.tileExtentBuffer, y.quadTriangleIndexBuffer, y.tileExtentSegments);
                }
              })(s, 0, f, m);
              break;
            case "custom":
              (function(y, S, C) {
                const B = y.context, D = C.implementation;
                if (y.renderPass === "offscreen") {
                  const z = D.prerender;
                  z && (y.setCustomLayerDefaults(), B.setColorMode(y.colorModeForRenderPass()), z.call(D, B.gl, y.transform.customLayerMatrix()), B.setDirty(), y.setBaseState());
                } else if (y.renderPass === "translucent") {
                  y.setCustomLayerDefaults(), B.setColorMode(y.colorModeForRenderPass()), B.setStencilMode($n.disabled);
                  const z = D.renderingMode === "3d" ? new fn(y.context.gl.LEQUAL, fn.ReadWrite, y.depthRangeFor3D) : y.depthModeForSublayer(0, fn.ReadOnly);
                  B.setDepthMode(z), D.render(B.gl, y.transform.customLayerMatrix(), { farZ: y.transform.farZ, nearZ: y.transform.nearZ, fov: y.transform._fov, modelViewProjectionMatrix: y.transform.modelViewProjectionMatrix, projectionMatrix: y.transform.projectionMatrix }), B.setDirty(), y.setBaseState(), B.bindFramebuffer.set(null);
                }
              })(s, 0, f);
          }
        }
        translatePosMatrix(s, h, f, m, y) {
          if (!f[0] && !f[1]) return s;
          const S = y ? m === "map" ? this.transform.angle : 0 : m === "viewport" ? -this.transform.angle : 0;
          if (S) {
            const D = Math.sin(S), z = Math.cos(S);
            f = [f[0] * z - f[1] * D, f[0] * D + f[1] * z];
          }
          const C = [y ? f[0] : wn(h, f[0], this.transform.zoom), y ? f[1] : wn(h, f[1], this.transform.zoom), 0], B = new Float32Array(16);
          return l.J(B, s, C), B;
        }
        saveTileTexture(s) {
          const h = this._tileTextures[s.size[0]];
          h ? h.push(s) : this._tileTextures[s.size[0]] = [s];
        }
        getTileTexture(s) {
          const h = this._tileTextures[s];
          return h && h.length > 0 ? h.pop() : null;
        }
        isPatternMissing(s) {
          if (!s) return !1;
          if (!s.from || !s.to) return !0;
          const h = this.imageManager.getPattern(s.from.toString()), f = this.imageManager.getPattern(s.to.toString());
          return !h || !f;
        }
        useProgram(s, h) {
          this.cache = this.cache || {};
          const f = s + (h ? h.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[f] || (this.cache[f] = new me(this.context, Ji[s], h, Qa[s], this._showOverdrawInspector, this.style.map.terrain)), this.cache[f];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const s = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(s.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new oe(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: s, drawingBufferHeight: h } = this.context.gl;
          return this.width !== s || this.height !== h;
        }
      }
      class Ni {
        constructor(s, h) {
          this.points = s, this.planes = h;
        }
        static fromInvProjectionMatrix(s, h, f) {
          const m = Math.pow(2, f), y = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((C) => {
            const B = 1 / (C = l.af([], C, s))[3] / h * m;
            return l.b1(C, C, [B, B, 1 / C[3], B]);
          }), S = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((C) => {
            const B = function(X, Z) {
              var W = Z[0], Q = Z[1], le = Z[2], ue = W * W + Q * Q + le * le;
              return ue > 0 && (ue = 1 / Math.sqrt(ue)), X[0] = Z[0] * ue, X[1] = Z[1] * ue, X[2] = Z[2] * ue, X;
            }([], function(X, Z, W) {
              var Q = Z[0], le = Z[1], ue = Z[2], fe = W[0], he = W[1], ve = W[2];
              return X[0] = le * ve - ue * he, X[1] = ue * fe - Q * ve, X[2] = Q * he - le * fe, X;
            }([], Le([], y[C[0]], y[C[1]]), Le([], y[C[2]], y[C[1]]))), D = -((z = B)[0] * (N = y[C[1]])[0] + z[1] * N[1] + z[2] * N[2]);
            var z, N;
            return B.concat(D);
          });
          return new Ni(y, S);
        }
      }
      class cs {
        constructor(s, h) {
          this.min = s, this.max = h, this.center = function(f, m, y) {
            return f[0] = 0.5 * m[0], f[1] = 0.5 * m[1], f[2] = 0.5 * m[2], f;
          }([], function(f, m, y) {
            return f[0] = m[0] + y[0], f[1] = m[1] + y[1], f[2] = m[2] + y[2], f;
          }([], this.min, this.max));
        }
        quadrant(s) {
          const h = [s % 2 == 0, s < 2], f = Se(this.min), m = Se(this.max);
          for (let y = 0; y < h.length; y++) f[y] = h[y] ? this.min[y] : this.center[y], m[y] = h[y] ? this.center[y] : this.max[y];
          return m[2] = this.max[2], new cs(f, m);
        }
        distanceX(s) {
          return Math.max(Math.min(this.max[0], s[0]), this.min[0]) - s[0];
        }
        distanceY(s) {
          return Math.max(Math.min(this.max[1], s[1]), this.min[1]) - s[1];
        }
        intersects(s) {
          const h = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let f = !0;
          for (let m = 0; m < s.planes.length; m++) {
            const y = s.planes[m];
            let S = 0;
            for (let C = 0; C < h.length; C++) l.b2(y, h[C]) >= 0 && S++;
            if (S === 0) return 0;
            S !== h.length && (f = !1);
          }
          if (f) return 2;
          for (let m = 0; m < 3; m++) {
            let y = Number.MAX_VALUE, S = -Number.MAX_VALUE;
            for (let C = 0; C < s.points.length; C++) {
              const B = s.points[C][m] - this.min[m];
              y = Math.min(y, B), S = Math.max(S, B);
            }
            if (S < 0 || y > this.max[m] - this.min[m]) return 0;
          }
          return 1;
        }
      }
      class ks {
        constructor() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          if (isNaN(s) || s < 0 || isNaN(h) || h < 0 || isNaN(f) || f < 0 || isNaN(m) || m < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = s, this.bottom = h, this.left = f, this.right = m;
        }
        interpolate(s, h, f) {
          return h.top != null && s.top != null && (this.top = l.y.number(s.top, h.top, f)), h.bottom != null && s.bottom != null && (this.bottom = l.y.number(s.bottom, h.bottom, f)), h.left != null && s.left != null && (this.left = l.y.number(s.left, h.left, f)), h.right != null && s.right != null && (this.right = l.y.number(s.right, h.right, f)), this;
        }
        getCenter(s, h) {
          const f = l.ac((this.left + s - this.right) / 2, 0, s), m = l.ac((this.top + h - this.bottom) / 2, 0, h);
          return new l.P(f, m);
        }
        equals(s) {
          return this.top === s.top && this.bottom === s.bottom && this.left === s.left && this.right === s.right;
        }
        clone() {
          return new ks(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const Ba = 85.051129;
      class Ns {
        constructor(s, h, f, m, y) {
          this.tileSize = 512, this._renderWorldCopies = y === void 0 || !!y, this._minZoom = s || 0, this._maxZoom = h || 22, this._minPitch = f ?? 0, this._maxPitch = m ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new l.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new ks(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const s = new Ns(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return s.apply(this), s;
        }
        apply(s) {
          this.tileSize = s.tileSize, this.latRange = s.latRange, this.lngRange = s.lngRange, this.width = s.width, this.height = s.height, this._center = s._center, this._elevation = s._elevation, this.minElevationForCurrentTile = s.minElevationForCurrentTile, this.zoom = s.zoom, this.angle = s.angle, this._fov = s._fov, this._pitch = s._pitch, this._unmodified = s._unmodified, this._edgeInsets = s._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(s) {
          this._minZoom !== s && (this._minZoom = s, this.zoom = Math.max(this.zoom, s));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(s) {
          this._maxZoom !== s && (this._maxZoom = s, this.zoom = Math.min(this.zoom, s));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(s) {
          this._minPitch !== s && (this._minPitch = s, this.pitch = Math.max(this.pitch, s));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(s) {
          this._maxPitch !== s && (this._maxPitch = s, this.pitch = Math.min(this.pitch, s));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(s) {
          s === void 0 ? s = !0 : s === null && (s = !1), this._renderWorldCopies = s;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new l.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(s) {
          const h = -l.b3(s, -180, 180) * Math.PI / 180;
          this.angle !== h && (this._unmodified = !1, this.angle = h, this._calcMatrices(), this.rotationMatrix = function() {
            var f = new l.A(4);
            return l.A != Float32Array && (f[1] = 0, f[2] = 0), f[0] = 1, f[3] = 1, f;
          }(), function(f, m, y) {
            var S = m[0], C = m[1], B = m[2], D = m[3], z = Math.sin(y), N = Math.cos(y);
            f[0] = S * N + B * z, f[1] = C * N + D * z, f[2] = S * -z + B * N, f[3] = C * -z + D * N;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(s) {
          const h = l.ac(s, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== h && (this._unmodified = !1, this._pitch = h, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(s) {
          s = Math.max(0.01, Math.min(60, s)), this._fov !== s && (this._unmodified = !1, this._fov = s / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(s) {
          const h = Math.min(Math.max(s, this.minZoom), this.maxZoom);
          this._zoom !== h && (this._unmodified = !1, this._zoom = h, this.tileZoom = Math.max(0, Math.floor(h)), this.scale = this.zoomScale(h), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(s) {
          s.lat === this._center.lat && s.lng === this._center.lng || (this._unmodified = !1, this._center = s, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(s) {
          s !== this._elevation && (this._elevation = s, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(s) {
          this._edgeInsets.equals(s) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, s, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(s) {
          return this._edgeInsets.equals(s);
        }
        interpolatePadding(s, h, f) {
          this._unmodified = !1, this._edgeInsets.interpolate(s, h, f), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(s) {
          const h = (s.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / s.tileSize));
          return Math.max(0, h);
        }
        getVisibleUnwrappedCoordinates(s) {
          const h = [new l.b4(0, s)];
          if (this._renderWorldCopies) {
            const f = this.pointCoordinate(new l.P(0, 0)), m = this.pointCoordinate(new l.P(this.width, 0)), y = this.pointCoordinate(new l.P(this.width, this.height)), S = this.pointCoordinate(new l.P(0, this.height)), C = Math.floor(Math.min(f.x, m.x, y.x, S.x)), B = Math.floor(Math.max(f.x, m.x, y.x, S.x)), D = 1;
            for (let z = C - D; z <= B + D; z++) z !== 0 && h.push(new l.b4(z, s));
          }
          return h;
        }
        coveringTiles(s) {
          var h, f;
          let m = this.coveringZoomLevel(s);
          const y = m;
          if (s.minzoom !== void 0 && m < s.minzoom) return [];
          s.maxzoom !== void 0 && m > s.maxzoom && (m = s.maxzoom);
          const S = this.pointCoordinate(this.getCameraPoint()), C = l.Z.fromLngLat(this.center), B = Math.pow(2, m), D = [B * S.x, B * S.y, 0], z = [B * C.x, B * C.y, 0], N = Ni.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, m);
          let X = s.minzoom || 0;
          !s.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (X = m);
          const Z = s.terrain ? 2 / Math.min(this.tileSize, s.tileSize) * this.tileSize : 3, W = (he) => ({ aabb: new cs([he * B, 0, 0], [(he + 1) * B, B, 0]), zoom: 0, x: 0, y: 0, wrap: he, fullyVisible: !1 }), Q = [], le = [], ue = m, fe = s.reparseOverscaled ? y : m;
          if (this._renderWorldCopies) for (let he = 1; he <= 3; he++) Q.push(W(-he)), Q.push(W(he));
          for (Q.push(W(0)); Q.length > 0; ) {
            const he = Q.pop(), ve = he.x, Be = he.y;
            let Pe = he.fullyVisible;
            if (!Pe) {
              const bt = he.aabb.intersects(N);
              if (bt === 0) continue;
              Pe = bt === 2;
            }
            const Qe = s.terrain ? D : z, ft = he.aabb.distanceX(Qe), _t = he.aabb.distanceY(Qe), xt = Math.max(Math.abs(ft), Math.abs(_t));
            if (he.zoom === ue || xt > Z + (1 << ue - he.zoom) - 2 && he.zoom >= X) {
              const bt = ue - he.zoom, yt = D[0] - 0.5 - (ve << bt), wt = D[1] - 0.5 - (Be << bt);
              le.push({ tileID: new l.S(he.zoom === ue ? fe : he.zoom, he.wrap, he.zoom, ve, Be), distanceSq: _e([z[0] - 0.5 - ve, z[1] - 0.5 - Be]), tileDistanceToCamera: Math.sqrt(yt * yt + wt * wt) });
            } else for (let bt = 0; bt < 4; bt++) {
              const yt = (ve << 1) + bt % 2, wt = (Be << 1) + (bt >> 1), Jt = he.zoom + 1;
              let Ct = he.aabb.quadrant(bt);
              if (s.terrain) {
                const It = new l.S(Jt, he.wrap, Jt, yt, wt), rn = s.terrain.getMinMaxElevation(It), An = (h = rn.minElevation) !== null && h !== void 0 ? h : this.elevation, yn = (f = rn.maxElevation) !== null && f !== void 0 ? f : this.elevation;
                Ct = new cs([Ct.min[0], Ct.min[1], An], [Ct.max[0], Ct.max[1], yn]);
              }
              Q.push({ aabb: Ct, zoom: Jt, x: yt, y: wt, wrap: he.wrap, fullyVisible: Pe });
            }
          }
          return le.sort((he, ve) => he.distanceSq - ve.distanceSq).map((he) => he.tileID);
        }
        resize(s, h) {
          this.width = s, this.height = h, this.pixelsToGLUnits = [2 / s, -2 / h], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(s) {
          return Math.pow(2, s);
        }
        scaleZoom(s) {
          return Math.log(s) / Math.LN2;
        }
        project(s) {
          const h = l.ac(s.lat, -85.051129, Ba);
          return new l.P(l.O(s.lng) * this.worldSize, l.Q(h) * this.worldSize);
        }
        unproject(s) {
          return new l.Z(s.x / this.worldSize, s.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(s) {
          const h = this.elevation, f = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, m = this.pointLocation(this.centerPoint, s), y = s.getElevationForLngLatZoom(m, this.tileZoom);
          if (!(this.elevation - y)) return;
          const S = f + h - y, C = Math.cos(this._pitch) * this.cameraToCenterDistance / S / l.b5(1, m.lat), B = this.scaleZoom(C / this.tileSize);
          this._elevation = y, this._center = m, this.zoom = B;
        }
        setLocationAtPoint(s, h) {
          const f = this.pointCoordinate(h), m = this.pointCoordinate(this.centerPoint), y = this.locationCoordinate(s), S = new l.Z(y.x - (f.x - m.x), y.y - (f.y - m.y));
          this.center = this.coordinateLocation(S), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(s, h) {
          return h ? this.coordinatePoint(this.locationCoordinate(s), h.getElevationForLngLatZoom(s, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(s));
        }
        pointLocation(s, h) {
          return this.coordinateLocation(this.pointCoordinate(s, h));
        }
        locationCoordinate(s) {
          return l.Z.fromLngLat(s);
        }
        coordinateLocation(s) {
          return s && s.toLngLat();
        }
        pointCoordinate(s, h) {
          if (h) {
            const X = h.pointCoordinate(s);
            if (X != null) return X;
          }
          const f = [s.x, s.y, 0, 1], m = [s.x, s.y, 1, 1];
          l.af(f, f, this.pixelMatrixInverse), l.af(m, m, this.pixelMatrixInverse);
          const y = f[3], S = m[3], C = f[1] / y, B = m[1] / S, D = f[2] / y, z = m[2] / S, N = D === z ? 0 : (0 - D) / (z - D);
          return new l.Z(l.y.number(f[0] / y, m[0] / S, N) / this.worldSize, l.y.number(C, B, N) / this.worldSize);
        }
        coordinatePoint(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.pixelMatrix;
          const m = [s.x * this.worldSize, s.y * this.worldSize, h, 1];
          return l.af(m, m, f), new l.P(m[0] / m[3], m[1] / m[3]);
        }
        getBounds() {
          const s = Math.max(0, this.height / 2 - this.getHorizon());
          return new ne().extend(this.pointLocation(new l.P(0, s))).extend(this.pointLocation(new l.P(this.width, s))).extend(this.pointLocation(new l.P(this.width, this.height))).extend(this.pointLocation(new l.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new ne([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(s) {
          s ? (this.lngRange = [s.getWest(), s.getEast()], this.latRange = [s.getSouth(), s.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, Ba]);
        }
        calculateTileMatrix(s) {
          const h = s.canonical, f = this.worldSize / this.zoomScale(h.z), m = h.x + Math.pow(2, h.z) * s.wrap, y = l.an(new Float64Array(16));
          return l.J(y, y, [m * f, h.y * f, 0]), l.K(y, y, [f / l.X, f / l.X, 1]), y;
        }
        calculatePosMatrix(s) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
          const f = s.key, m = h ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (m[f]) return m[f];
          const y = this.calculateTileMatrix(s);
          return l.L(y, h ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, y), m[f] = new Float32Array(y), m[f];
        }
        calculateFogMatrix(s) {
          const h = s.key, f = this._fogMatrixCache;
          if (f[h]) return f[h];
          const m = this.calculateTileMatrix(s);
          return l.L(m, this.fogMatrix, m), f[h] = new Float32Array(m), f[h];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(s, h) {
          h = l.ac(+h, this.minZoom, this.maxZoom);
          const f = { center: new l.N(s.lng, s.lat), zoom: h };
          let m = this.lngRange;
          if (!this._renderWorldCopies && m === null) {
            const he = 179.9999999999;
            m = [-he, he];
          }
          const y = this.tileSize * this.zoomScale(f.zoom);
          let S = 0, C = y, B = 0, D = y, z = 0, N = 0;
          const { x: X, y: Z } = this.size;
          if (this.latRange) {
            const he = this.latRange;
            S = l.Q(he[1]) * y, C = l.Q(he[0]) * y, C - S < Z && (z = Z / (C - S));
          }
          m && (B = l.b3(l.O(m[0]) * y, 0, y), D = l.b3(l.O(m[1]) * y, 0, y), D < B && (D += y), D - B < X && (N = X / (D - B)));
          const { x: W, y: Q } = this.project.call({ worldSize: y }, s);
          let le, ue;
          const fe = Math.max(N || 0, z || 0);
          if (fe) {
            const he = new l.P(N ? (D + B) / 2 : W, z ? (C + S) / 2 : Q);
            return f.center = this.unproject.call({ worldSize: y }, he).wrap(), f.zoom += this.scaleZoom(fe), f;
          }
          if (this.latRange) {
            const he = Z / 2;
            Q - he < S && (ue = S + he), Q + he > C && (ue = C - he);
          }
          if (m) {
            const he = (B + D) / 2;
            let ve = W;
            this._renderWorldCopies && (ve = l.b3(W, he - y / 2, he + y / 2));
            const Be = X / 2;
            ve - Be < B && (le = B + Be), ve + Be > D && (le = D - Be);
          }
          if (le !== void 0 || ue !== void 0) {
            const he = new l.P(le ?? W, ue ?? Q);
            f.center = this.unproject.call({ worldSize: y }, he).wrap();
          }
          return f;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const s = this._unmodified, { center: h, zoom: f } = this.getConstrained(this.center, this.zoom);
          this.center = h, this.zoom = f, this._unmodified = s, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const s = this.centerOffset, h = this.point.x, f = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = l.b5(1, this.center.lat) * this.worldSize;
          let m = l.an(new Float64Array(16));
          l.K(m, m, [this.width / 2, -this.height / 2, 1]), l.J(m, m, [1, -1, 0]), this.labelPlaneMatrix = m, m = l.an(new Float64Array(16)), l.K(m, m, [1, -1, 1]), l.J(m, m, [-1, -1, 0]), l.K(m, m, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = m;
          const y = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), S = Math.min(this.elevation, this.minElevationForCurrentTile), C = y - S * this._pixelPerMeter / Math.cos(this._pitch), B = S < 0 ? C : y, D = Math.PI / 2 + this._pitch, z = this._fov * (0.5 + s.y / this.height), N = Math.sin(z) * B / Math.sin(l.ac(Math.PI - D - z, 0.01, Math.PI - 0.01)), X = this.getHorizon(), Z = 2 * Math.atan(X / this.cameraToCenterDistance) * (0.5 + s.y / (2 * X)), W = Math.sin(Z) * B / Math.sin(l.ac(Math.PI - D - Z, 0.01, Math.PI - 0.01)), Q = Math.min(N, W);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * Q + B), this.nearZ = this.height / 50, m = new Float64Array(16), l.b6(m, this._fov, this.width / this.height, this.nearZ, this.farZ), m[8] = 2 * -s.x / this.width, m[9] = 2 * s.y / this.height, this.projectionMatrix = l.ae(m), l.K(m, m, [1, -1, 1]), l.J(m, m, [0, 0, -this.cameraToCenterDistance]), l.b7(m, m, this._pitch), l.ad(m, m, this.angle), l.J(m, m, [-h, -f, 0]), this.mercatorMatrix = l.K([], m, [this.worldSize, this.worldSize, this.worldSize]), l.K(m, m, [1, 1, this._pixelPerMeter]), this.pixelMatrix = l.L(new Float64Array(16), this.labelPlaneMatrix, m), l.J(m, m, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = m, this.invModelViewProjectionMatrix = l.as([], m), this.fogMatrix = new Float64Array(16), l.b6(this.fogMatrix, this._fov, this.width / this.height, y, this.farZ), this.fogMatrix[8] = 2 * -s.x / this.width, this.fogMatrix[9] = 2 * s.y / this.height, l.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), l.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), l.b7(this.fogMatrix, this.fogMatrix, this._pitch), l.ad(this.fogMatrix, this.fogMatrix, this.angle), l.J(this.fogMatrix, this.fogMatrix, [-h, -f, 0]), l.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), l.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = l.L(new Float64Array(16), this.labelPlaneMatrix, m);
          const le = this.width % 2 / 2, ue = this.height % 2 / 2, fe = Math.cos(this.angle), he = Math.sin(this.angle), ve = h - Math.round(h) + fe * le + he * ue, Be = f - Math.round(f) + fe * ue + he * le, Pe = new Float64Array(m);
          if (l.J(Pe, Pe, [ve > 0.5 ? ve - 1 : ve, Be > 0.5 ? Be - 1 : Be, 0]), this.alignedModelViewProjectionMatrix = Pe, m = l.as(new Float64Array(16), this.pixelMatrix), !m) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = m, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const s = this.pointCoordinate(new l.P(0, 0)), h = [s.x * this.worldSize, s.y * this.worldSize, 0, 1];
          return l.af(h, h, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const s = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new l.P(0, s));
        }
        getCameraQueryGeometry(s) {
          const h = this.getCameraPoint();
          if (s.length === 1) return [s[0], h];
          {
            let f = h.x, m = h.y, y = h.x, S = h.y;
            for (const C of s) f = Math.min(f, C.x), m = Math.min(m, C.y), y = Math.max(y, C.x), S = Math.max(S, C.y);
            return [new l.P(f, m), new l.P(y, m), new l.P(y, S), new l.P(f, S), new l.P(f, m)];
          }
        }
        lngLatToCameraDepth(s, h) {
          const f = this.locationCoordinate(s), m = [f.x * this.worldSize, f.y * this.worldSize, h, 1];
          return l.af(m, m, this.modelViewProjectionMatrix), m[2] / m[3];
        }
      }
      function zs(g, s) {
        var h = this;
        let f, m = !1, y = null, S = null;
        const C = () => {
          y = null, m && (g.apply(S, f), y = setTimeout(C, s), m = !1);
        };
        return function() {
          for (var B = arguments.length, D = new Array(B), z = 0; z < B; z++)
            D[z] = arguments[z];
          return m = !0, S = h, f = D, y || C(), y;
        };
      }
      class Ra {
        constructor(s) {
          this._getCurrentHash = () => {
            const h = window.location.hash.replace("#", "");
            if (this._hashName) {
              let f;
              return h.split("&").map((m) => m.split("=")).forEach((m) => {
                m[0] === this._hashName && (f = m);
              }), (f && f[1] || "").split("/");
            }
            return h.split("/");
          }, this._onHashChange = () => {
            const h = this._getCurrentHash();
            if (h.length >= 3 && !h.some((f) => isNaN(f))) {
              const f = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(h[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+h[2], +h[1]], zoom: +h[0], bearing: f, pitch: +(h[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const h = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, h);
          }, this._removeHash = () => {
            const h = this._getCurrentHash();
            if (h.length === 0) return;
            const f = h.join("/");
            let m = f;
            m.split("&").length > 0 && (m = m.split("&")[0]), this._hashName && (m = `${this._hashName}=${f}`);
            let y = window.location.hash.replace(m, "");
            y.startsWith("#&") ? y = y.slice(0, 1) + y.slice(2) : y === "#" && (y = "");
            let S = window.location.href.replace(/(#.+)?$/, y);
            S = S.replace("&&", "&"), window.history.replaceState(window.history.state, null, S);
          }, this._updateHash = zs(this._updateHashUnthrottled, 300), this._hashName = s && encodeURIComponent(s);
        }
        addTo(s) {
          return this._map = s, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(s) {
          const h = this._map.getCenter(), f = Math.round(100 * this._map.getZoom()) / 100, m = Math.ceil((f * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), y = Math.pow(10, m), S = Math.round(h.lng * y) / y, C = Math.round(h.lat * y) / y, B = this._map.getBearing(), D = this._map.getPitch();
          let z = "";
          if (z += s ? `/${S}/${C}/${f}` : `${f}/${C}/${S}`, (B || D) && (z += "/" + Math.round(10 * B) / 10), D && (z += `/${Math.round(D)}`), this._hashName) {
            const N = this._hashName;
            let X = !1;
            const Z = window.location.hash.slice(1).split("&").map((W) => {
              const Q = W.split("=")[0];
              return Q === N ? (X = !0, `${Q}=${z}`) : W;
            }).filter((W) => W);
            return X || Z.push(`${N}=${z}`), `#${Z.join("&")}`;
          }
          return `#${z}`;
        }
      }
      const es = { linearity: 0.3, easing: l.b8(0, 0, 0.3, 1) }, _o = l.e({ deceleration: 2500, maxSpeed: 1400 }, es), Cr = l.e({ deceleration: 20, maxSpeed: 1400 }, es), br = l.e({ deceleration: 1e3, maxSpeed: 360 }, es), jr = l.e({ deceleration: 1e3, maxSpeed: 90 }, es);
      class ii {
        constructor(s) {
          this._map = s, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(s) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: T.now(), settings: s });
        }
        _drainInertiaBuffer() {
          const s = this._inertiaBuffer, h = T.now();
          for (; s.length > 0 && h - s[0].time > 160; ) s.shift();
        }
        _onMoveEnd(s) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const h = { zoom: 0, bearing: 0, pitch: 0, pan: new l.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: y } of this._inertiaBuffer) h.zoom += y.zoomDelta || 0, h.bearing += y.bearingDelta || 0, h.pitch += y.pitchDelta || 0, y.panDelta && h.pan._add(y.panDelta), y.around && (h.around = y.around), y.pinchAround && (h.pinchAround = y.pinchAround);
          const f = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, m = {};
          if (h.pan.mag()) {
            const y = Us(h.pan.mag(), f, l.e({}, _o, s || {}));
            m.offset = h.pan.mult(y.amount / h.pan.mag()), m.center = this._map.transform.center, As(m, y);
          }
          if (h.zoom) {
            const y = Us(h.zoom, f, Cr);
            m.zoom = this._map.transform.zoom + y.amount, As(m, y);
          }
          if (h.bearing) {
            const y = Us(h.bearing, f, br);
            m.bearing = this._map.transform.bearing + l.ac(y.amount, -179, 179), As(m, y);
          }
          if (h.pitch) {
            const y = Us(h.pitch, f, jr);
            m.pitch = this._map.transform.pitch + y.amount, As(m, y);
          }
          if (m.zoom || m.bearing) {
            const y = h.pinchAround === void 0 ? h.around : h.pinchAround;
            m.around = y ? this._map.unproject(y) : this._map.getCenter();
          }
          return this.clear(), l.e(m, { noMoveStart: !0 });
        }
      }
      function As(g, s) {
        (!g.duration || g.duration < s.duration) && (g.duration = s.duration, g.easing = s.easing);
      }
      function Us(g, s, h) {
        const { maxSpeed: f, linearity: m, deceleration: y } = h, S = l.ac(g * m / (s / 1e3), -f, f), C = Math.abs(S) / (y * m);
        return { easing: h.easing, duration: 1e3 * C, amount: S * (C / 2) };
      }
      class si extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          const y = I.mousePos(h.getCanvas(), f), S = h.unproject(y);
          super(s, l.e({ point: y, lngLat: S, originalEvent: f }, m)), this._defaultPrevented = !1, this.target = h;
        }
      }
      class Ro extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(s, h, f) {
          const m = s === "touchend" ? f.changedTouches : f.touches, y = I.touchPos(h.getCanvasContainer(), m), S = y.map((B) => h.unproject(B)), C = y.reduce((B, D, z, N) => B.add(D.div(N.length)), new l.P(0, 0));
          super(s, { points: y, point: C, lngLats: S, lngLat: h.unproject(C), originalEvent: f }), this._defaultPrevented = !1;
        }
      }
      class Ku extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(s, h, f) {
          super(s, { originalEvent: f }), this._defaultPrevented = !1;
        }
      }
      class Qu {
        constructor(s, h) {
          this._map = s, this._clickTolerance = h.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(s) {
          return this._firePreventable(new Ku(s.type, this._map, s));
        }
        mousedown(s, h) {
          return this._mousedownPos = h, this._firePreventable(new si(s.type, this._map, s));
        }
        mouseup(s) {
          this._map.fire(new si(s.type, this._map, s));
        }
        click(s, h) {
          this._mousedownPos && this._mousedownPos.dist(h) >= this._clickTolerance || this._map.fire(new si(s.type, this._map, s));
        }
        dblclick(s) {
          return this._firePreventable(new si(s.type, this._map, s));
        }
        mouseover(s) {
          this._map.fire(new si(s.type, this._map, s));
        }
        mouseout(s) {
          this._map.fire(new si(s.type, this._map, s));
        }
        touchstart(s) {
          return this._firePreventable(new Ro(s.type, this._map, s));
        }
        touchmove(s) {
          this._map.fire(new Ro(s.type, this._map, s));
        }
        touchend(s) {
          this._map.fire(new Ro(s.type, this._map, s));
        }
        touchcancel(s) {
          this._map.fire(new Ro(s.type, this._map, s));
        }
        _firePreventable(s) {
          if (this._map.fire(s), s.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Wr {
        constructor(s) {
          this._map = s;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(s) {
          this._map.fire(new si(s.type, this._map, s));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new si("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(s) {
          this._delayContextMenu ? this._contextMenuEvent = s : this._ignoreContextMenu || this._map.fire(new si(s.type, this._map, s)), this._map.listens("contextmenu") && s.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class js {
        constructor(s) {
          this._map = s;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(s) {
          return this.transform.pointLocation(l.P.convert(s), this._map.terrain);
        }
      }
      class us {
        constructor(s, h) {
          this._map = s, this._tr = new js(s), this._el = s.getCanvasContainer(), this._container = s.getContainer(), this._clickTolerance = h.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(s, h) {
          this.isEnabled() && s.shiftKey && s.button === 0 && (I.disableDrag(), this._startPos = this._lastPos = h, this._active = !0);
        }
        mousemoveWindow(s, h) {
          if (!this._active) return;
          const f = h;
          if (this._lastPos.equals(f) || !this._box && f.dist(this._startPos) < this._clickTolerance) return;
          const m = this._startPos;
          this._lastPos = f, this._box || (this._box = I.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", s));
          const y = Math.min(m.x, f.x), S = Math.max(m.x, f.x), C = Math.min(m.y, f.y), B = Math.max(m.y, f.y);
          I.setTransform(this._box, `translate(${y}px,${C}px)`), this._box.style.width = S - y + "px", this._box.style.height = B - C + "px";
        }
        mouseupWindow(s, h) {
          if (!this._active || s.button !== 0) return;
          const f = this._startPos, m = h;
          if (this.reset(), I.suppressClick(), f.x !== m.x || f.y !== m.y) return this._map.fire(new l.k("boxzoomend", { originalEvent: s })), { cameraAnimation: (y) => y.fitScreenCoordinates(f, m, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", s);
        }
        keydown(s) {
          this._active && s.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", s));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (I.remove(this._box), this._box = null), I.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(s, h) {
          return this._map.fire(new l.k(s, { originalEvent: h }));
        }
      }
      function Vl(g, s) {
        if (g.length !== s.length) throw new Error(`The number of touches and points are not equal - touches ${g.length}, points ${s.length}`);
        const h = {};
        for (let f = 0; f < g.length; f++) h[g[f].identifier] = s[f];
        return h;
      }
      class Lc {
        constructor(s) {
          this.reset(), this.numTouches = s.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(s, h, f) {
          (this.centroid || f.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = s.timeStamp), f.length === this.numTouches && (this.centroid = function(m) {
            const y = new l.P(0, 0);
            for (const S of m) y._add(S);
            return y.div(m.length);
          }(h), this.touches = Vl(f, h)));
        }
        touchmove(s, h, f) {
          if (this.aborted || !this.centroid) return;
          const m = Vl(f, h);
          for (const y in this.touches) {
            const S = m[y];
            (!S || S.dist(this.touches[y]) > 30) && (this.aborted = !0);
          }
        }
        touchend(s, h, f) {
          if ((!this.centroid || s.timeStamp - this.startTime > 500) && (this.aborted = !0), f.length === 0) {
            const m = !this.aborted && this.centroid;
            if (this.reset(), m) return m;
          }
        }
      }
      class il {
        constructor(s) {
          this.singleTap = new Lc(s), this.numTaps = s.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(s, h, f) {
          this.singleTap.touchstart(s, h, f);
        }
        touchmove(s, h, f) {
          this.singleTap.touchmove(s, h, f);
        }
        touchend(s, h, f) {
          const m = this.singleTap.touchend(s, h, f);
          if (m) {
            const y = s.timeStamp - this.lastTime < 500, S = !this.lastTap || this.lastTap.dist(m) < 30;
            if (y && S || this.reset(), this.count++, this.lastTime = s.timeStamp, this.lastTap = m, this.count === this.numTaps) return this.reset(), m;
          }
        }
      }
      class xi {
        constructor(s) {
          this._tr = new js(s), this._zoomIn = new il({ numTouches: 1, numTaps: 2 }), this._zoomOut = new il({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(s, h, f) {
          this._zoomIn.touchstart(s, h, f), this._zoomOut.touchstart(s, h, f);
        }
        touchmove(s, h, f) {
          this._zoomIn.touchmove(s, h, f), this._zoomOut.touchmove(s, h, f);
        }
        touchend(s, h, f) {
          const m = this._zoomIn.touchend(s, h, f), y = this._zoomOut.touchend(s, h, f), S = this._tr;
          return m ? (this._active = !0, s.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: S.zoom + 1, around: S.unproject(m) }, { originalEvent: s }) }) : y ? (this._active = !0, s.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: S.zoom - 1, around: S.unproject(y) }, { originalEvent: s }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class hi {
        constructor(s) {
          this._enabled = !!s.enable, this._moveStateManager = s.moveStateManager, this._clickTolerance = s.clickTolerance || 1, this._moveFunction = s.move, this._activateOnStart = !!s.activateOnStart, s.assignEvents(this), this.reset();
        }
        reset(s) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(s);
        }
        _move() {
          const s = this._moveFunction(...arguments);
          if (s.bearingDelta || s.pitchDelta || s.around || s.panDelta) return this._active = !0, s;
        }
        dragStart(s, h) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(s) && (this._moveStateManager.startMove(s), this._lastPoint = h.length ? h[0] : h, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(s, h) {
          if (!this.isEnabled()) return;
          const f = this._lastPoint;
          if (!f) return;
          if (s.preventDefault(), !this._moveStateManager.isValidMoveEvent(s)) return void this.reset(s);
          const m = h.length ? h[0] : h;
          return !this._moved && m.dist(f) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = m, this._move(f, m));
        }
        dragEnd(s) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(s) && (this._moved && I.suppressClick(), this.reset(s));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const ql = { 0: 1, 2: 2 };
      class sl {
        constructor(s) {
          this._correctEvent = s.checkCorrectEvent;
        }
        startMove(s) {
          const h = I.mouseButton(s);
          this._eventButton = h;
        }
        endMove(s) {
          delete this._eventButton;
        }
        isValidStartEvent(s) {
          return this._correctEvent(s);
        }
        isValidMoveEvent(s) {
          return !function(h, f) {
            const m = ql[f];
            return h.buttons === void 0 || (h.buttons & m) !== m;
          }(s, this._eventButton);
        }
        isValidEndEvent(s) {
          return I.mouseButton(s) === this._eventButton;
        }
      }
      class gu {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(s) {
          return s.targetTouches.length === 1;
        }
        _isSameTouchEvent(s) {
          return s.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(s) {
          this._firstTouch = s.targetTouches[0].identifier;
        }
        endMove(s) {
          delete this._firstTouch;
        }
        isValidStartEvent(s) {
          return this._isOneFingerTouch(s);
        }
        isValidMoveEvent(s) {
          return this._isOneFingerTouch(s) && this._isSameTouchEvent(s);
        }
        isValidEndEvent(s) {
          return this._isOneFingerTouch(s) && this._isSameTouchEvent(s);
        }
      }
      const ol = (g) => {
        g.mousedown = g.dragStart, g.mousemoveWindow = g.dragMove, g.mouseup = g.dragEnd, g.contextmenu = (s) => {
          s.preventDefault();
        };
      }, Hl = (g) => {
        let { enable: s, clickTolerance: h, bearingDegreesPerPixelMoved: f = 0.8 } = g;
        const m = new sl({ checkCorrectEvent: (y) => I.mouseButton(y) === 0 && y.ctrlKey || I.mouseButton(y) === 2 });
        return new hi({ clickTolerance: h, move: (y, S) => ({ bearingDelta: (S.x - y.x) * f }), moveStateManager: m, enable: s, assignEvents: ol });
      }, Mc = (g) => {
        let { enable: s, clickTolerance: h, pitchDegreesPerPixelMoved: f = -0.5 } = g;
        const m = new sl({ checkCorrectEvent: (y) => I.mouseButton(y) === 0 && y.ctrlKey || I.mouseButton(y) === 2 });
        return new hi({ clickTolerance: h, move: (y, S) => ({ pitchDelta: (S.y - y.y) * f }), moveStateManager: m, enable: s, assignEvents: ol });
      };
      class Oa {
        constructor(s, h) {
          this._clickTolerance = s.clickTolerance || 1, this._map = h, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new l.P(0, 0);
        }
        _shouldBePrevented(s) {
          return s < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(s, h, f) {
          return this._calculateTransform(s, h, f);
        }
        touchmove(s, h, f) {
          if (this._active) {
            if (!this._shouldBePrevented(f.length)) return s.preventDefault(), this._calculateTransform(s, h, f);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", s);
          }
        }
        touchend(s, h, f) {
          this._calculateTransform(s, h, f), this._active && this._shouldBePrevented(f.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(s, h, f) {
          f.length > 0 && (this._active = !0);
          const m = Vl(f, h), y = new l.P(0, 0), S = new l.P(0, 0);
          let C = 0;
          for (const D in m) {
            const z = m[D], N = this._touches[D];
            N && (y._add(z), S._add(z.sub(N)), C++, m[D] = z);
          }
          if (this._touches = m, this._shouldBePrevented(C) || !S.mag()) return;
          const B = S.div(C);
          return this._sum._add(B), this._sum.mag() < this._clickTolerance ? void 0 : { around: y.div(C), panDelta: B };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Wl {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(s, h, f) {
          this._firstTwoTouches || f.length < 2 || (this._firstTwoTouches = [f[0].identifier, f[1].identifier], this._start([h[0], h[1]]));
        }
        touchmove(s, h, f) {
          if (!this._firstTwoTouches) return;
          s.preventDefault();
          const [m, y] = this._firstTwoTouches, S = al(f, h, m), C = al(f, h, y);
          if (!S || !C) return;
          const B = this._aroundCenter ? null : S.add(C).div(2);
          return this._move([S, C], B, s);
        }
        touchend(s, h, f) {
          if (!this._firstTwoTouches) return;
          const [m, y] = this._firstTwoTouches, S = al(f, h, m), C = al(f, h, y);
          S && C || (this._active && I.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(s) {
          this._enabled = !0, this._aroundCenter = !!s && s.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function al(g, s, h) {
        for (let f = 0; f < g.length; f++) if (g[f].identifier === h) return s[f];
      }
      function Xl(g, s) {
        return Math.log(g / s) / Math.LN2;
      }
      class Bc extends Wl {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(s) {
          this._startDistance = this._distance = s[0].dist(s[1]);
        }
        _move(s, h) {
          const f = this._distance;
          if (this._distance = s[0].dist(s[1]), this._active || !(Math.abs(Xl(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: Xl(this._distance, f), pinchAround: h };
        }
      }
      function eh(g, s) {
        return 180 * g.angleWith(s) / Math.PI;
      }
      class th extends Wl {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(s) {
          this._startVector = this._vector = s[0].sub(s[1]), this._minDiameter = s[0].dist(s[1]);
        }
        _move(s, h, f) {
          const m = this._vector;
          if (this._vector = s[0].sub(s[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: eh(this._vector, m), pinchAround: h };
        }
        _isBelowThreshold(s) {
          this._minDiameter = Math.min(this._minDiameter, s.mag());
          const h = 25 / (Math.PI * this._minDiameter) * 360, f = eh(s, this._startVector);
          return Math.abs(f) < h;
        }
      }
      function Rc(g) {
        return Math.abs(g.y) > Math.abs(g.x);
      }
      class $l extends Wl {
        constructor(s) {
          super(), this._currentTouchCount = 0, this._map = s;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(s, h, f) {
          super.touchstart(s, h, f), this._currentTouchCount = f.length;
        }
        _start(s) {
          this._lastPoints = s, Rc(s[0].sub(s[1])) && (this._valid = !1);
        }
        _move(s, h, f) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const m = s[0].sub(this._lastPoints[0]), y = s[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(m, y, f.timeStamp), this._valid ? (this._lastPoints = s, this._active = !0, { pitchDelta: (m.y + y.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(s, h, f) {
          if (this._valid !== void 0) return this._valid;
          const m = s.mag() >= 2, y = h.mag() >= 2;
          if (!m && !y) return;
          if (!m || !y) return this._firstMove === void 0 && (this._firstMove = f), f - this._firstMove < 100 && void 0;
          const S = s.y > 0 == h.y > 0;
          return Rc(s) && Rc(h) && S;
        }
      }
      const Wh = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Gs {
        constructor(s) {
          this._tr = new js(s);
          const h = Wh;
          this._panStep = h.panStep, this._bearingStep = h.bearingStep, this._pitchStep = h.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(s) {
          if (s.altKey || s.ctrlKey || s.metaKey) return;
          let h = 0, f = 0, m = 0, y = 0, S = 0;
          switch (s.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              h = 1;
              break;
            case 189:
            case 109:
            case 173:
              h = -1;
              break;
            case 37:
              s.shiftKey ? f = -1 : (s.preventDefault(), y = -1);
              break;
            case 39:
              s.shiftKey ? f = 1 : (s.preventDefault(), y = 1);
              break;
            case 38:
              s.shiftKey ? m = 1 : (s.preventDefault(), S = -1);
              break;
            case 40:
              s.shiftKey ? m = -1 : (s.preventDefault(), S = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (f = 0, m = 0), { cameraAnimation: (C) => {
            const B = this._tr;
            C.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Oo, zoom: h ? Math.round(B.zoom) + h * (s.shiftKey ? 2 : 1) : B.zoom, bearing: B.bearing + f * this._bearingStep, pitch: B.pitch + m * this._pitchStep, offset: [-y * this._panStep, -S * this._panStep], center: B.center }, { originalEvent: s });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Oo(g) {
        return g * (2 - g);
      }
      const nh = 4.000244140625;
      class Ss {
        constructor(s, h) {
          this._onTimeout = (f) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(f);
          }, this._map = s, this._tr = new js(s), this._triggerRenderFrame = h, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(s) {
          this._defaultZoomRate = s;
        }
        setWheelZoomRate(s) {
          this._wheelZoomRate = s;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(s) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!s && s.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(s) {
          return !!this._map.cooperativeGestures.isEnabled() && !(s.ctrlKey || this._map.cooperativeGestures.isBypassed(s));
        }
        wheel(s) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(s)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", s);
          let h = s.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * s.deltaY : s.deltaY;
          const f = T.now(), m = f - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = f, h !== 0 && h % nh == 0 ? this._type = "wheel" : h !== 0 && Math.abs(h) < 4 ? this._type = "trackpad" : m > 400 ? (this._type = null, this._lastValue = h, this._timeout = setTimeout(this._onTimeout, 40, s)) : this._type || (this._type = Math.abs(m * h) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, h += this._lastValue)), s.shiftKey && h && (h /= 4), this._type && (this._lastWheelEvent = s, this._delta -= h, this._active || this._start(s)), s.preventDefault();
        }
        _start(s) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const h = I.mousePos(this._map.getCanvas(), s), f = this._tr;
          this._around = h.y > f.transform.height / 2 - f.transform.getHorizon() ? l.N.convert(this._aroundCenter ? f.center : f.unproject(h)) : l.N.convert(f.center), this._aroundPoint = f.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const s = this._tr.transform;
          if (this._delta !== 0) {
            const B = this._type === "wheel" && Math.abs(this._delta) > nh ? this._wheelZoomRate : this._defaultZoomRate;
            let D = 2 / (1 + Math.exp(-Math.abs(this._delta * B)));
            this._delta < 0 && D !== 0 && (D = 1 / D);
            const z = typeof this._targetZoom == "number" ? s.zoomScale(this._targetZoom) : s.scale;
            this._targetZoom = Math.min(s.maxZoom, Math.max(s.minZoom, s.scaleZoom(z * D))), this._type === "wheel" && (this._startZoom = s.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const h = typeof this._targetZoom == "number" ? this._targetZoom : s.zoom, f = this._startZoom, m = this._easing;
          let y, S = !1;
          const C = T.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && f && m && C) {
            const B = Math.min(C / 200, 1), D = m(B);
            y = l.y.number(f, h, D), B < 1 ? this._frameId || (this._frameId = !0) : S = !0;
          } else y = h, S = !0;
          return this._active = !0, S && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !S, zoomDelta: y - s.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(s) {
          let h = l.b9;
          if (this._prevEase) {
            const f = this._prevEase, m = (T.now() - f.start) / f.duration, y = f.easing(m + 0.01) - f.easing(m), S = 0.27 / Math.sqrt(y * y + 1e-4) * 0.01, C = Math.sqrt(0.0729 - S * S);
            h = l.b8(S, C, 0.25, 1);
          }
          return this._prevEase = { start: T.now(), duration: s, easing: h }, h;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class ia {
        constructor(s, h) {
          this._clickZoom = s, this._tapZoom = h;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Oc {
        constructor(s) {
          this._tr = new js(s), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(s, h) {
          return s.preventDefault(), { cameraAnimation: (f) => {
            f.easeTo({ duration: 300, zoom: this._tr.zoom + (s.shiftKey ? -1 : 1), around: this._tr.unproject(h) }, { originalEvent: s });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class uf {
        constructor() {
          this._tap = new il({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(s, h, f) {
          if (!this._swipePoint) if (this._tapTime) {
            const m = h[0], y = s.timeStamp - this._tapTime < 500, S = this._tapPoint.dist(m) < 30;
            y && S ? f.length > 0 && (this._swipePoint = m, this._swipeTouch = f[0].identifier) : this.reset();
          } else this._tap.touchstart(s, h, f);
        }
        touchmove(s, h, f) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (f[0].identifier !== this._swipeTouch) return;
              const m = h[0], y = m.y - this._swipePoint.y;
              return this._swipePoint = m, s.preventDefault(), this._active = !0, { zoomDelta: y / 128 };
            }
          } else this._tap.touchmove(s, h, f);
        }
        touchend(s, h, f) {
          if (this._tapTime) this._swipePoint && f.length === 0 && this.reset();
          else {
            const m = this._tap.touchend(s, h, f);
            m && (this._tapTime = s.timeStamp, this._tapPoint = m);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Xh {
        constructor(s, h, f) {
          this._el = s, this._mousePan = h, this._touchPan = f;
        }
        enable(s) {
          this._inertiaOptions = s || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class rh {
        constructor(s, h, f) {
          this._pitchWithRotate = s.pitchWithRotate, this._mouseRotate = h, this._mousePitch = f;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class ih {
        constructor(s, h, f, m) {
          this._el = s, this._touchZoom = h, this._touchRotate = f, this._tapDragZoom = m, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(s) {
          this._touchZoom.enable(s), this._rotationDisabled || this._touchRotate.enable(s), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class Zl {
        constructor(s, h) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = s, this._options = h, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const s = this._map.getCanvasContainer();
          s.classList.add("maplibregl-cooperative-gestures"), this._container = I.create("div", "maplibregl-cooperative-gesture-screen", s);
          let h = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (h = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const f = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), m = document.createElement("div");
          m.className = "maplibregl-desktop-message", m.textContent = h, this._container.appendChild(m);
          const y = document.createElement("div");
          y.className = "maplibregl-mobile-message", y.textContent = f, this._container.appendChild(y), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (I.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(s) {
          return s[this._bypassKey];
        }
        notifyGestureBlocked(s, h) {
          this._enabled && (this._map.fire(new l.k("cooperativegestureprevented", { gestureType: s, originalEvent: h })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const Vs = (g) => g.zoom || g.drag || g.pitch || g.rotate;
      class qt extends l.k {
      }
      function yo(g) {
        return g.panDelta && g.panDelta.mag() || g.zoomDelta || g.bearingDelta || g.pitchDelta;
      }
      class Es {
        constructor(s, h) {
          this.handleWindowEvent = (m) => {
            this.handleEvent(m, `${m.type}Window`);
          }, this.handleEvent = (m, y) => {
            if (m.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const S = m.type === "renderFrame" ? void 0 : m, C = { needsRenderFrame: !1 }, B = {}, D = {}, z = m.touches, N = z ? this._getMapTouches(z) : void 0, X = N ? I.touchPos(this._map.getCanvas(), N) : I.mousePos(this._map.getCanvas(), m);
            for (const { handlerName: Q, handler: le, allowed: ue } of this._handlers) {
              if (!le.isEnabled()) continue;
              let fe;
              this._blockedByActive(D, ue, Q) ? le.reset() : le[y || m.type] && (fe = le[y || m.type](m, X, N), this.mergeHandlerResult(C, B, fe, Q, S), fe && fe.needsRenderFrame && this._triggerRenderFrame()), (fe || le.isActive()) && (D[Q] = le);
            }
            const Z = {};
            for (const Q in this._previousActiveHandlers) D[Q] || (Z[Q] = S);
            this._previousActiveHandlers = D, (Object.keys(Z).length || yo(C)) && (this._changes.push([C, B, Z]), this._triggerRenderFrame()), (Object.keys(D).length || yo(C)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: W } = C;
            W && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], W(this._map));
          }, this._map = s, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ii(s), this._bearingSnap = h.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(h);
          const f = this._el;
          this._listeners = [[f, "touchstart", { passive: !0 }], [f, "touchmove", { passive: !1 }], [f, "touchend", void 0], [f, "touchcancel", void 0], [f, "mousedown", void 0], [f, "mousemove", void 0], [f, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [f, "mouseover", void 0], [f, "mouseout", void 0], [f, "dblclick", void 0], [f, "click", void 0], [f, "keydown", { capture: !1 }], [f, "keyup", void 0], [f, "wheel", { passive: !1 }], [f, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [m, y, S] of this._listeners) I.addEventListener(m, y, m === document ? this.handleWindowEvent : this.handleEvent, S);
        }
        destroy() {
          for (const [s, h, f] of this._listeners) I.removeEventListener(s, h, s === document ? this.handleWindowEvent : this.handleEvent, f);
        }
        _addDefaultHandlers(s) {
          const h = this._map, f = h.getCanvasContainer();
          this._add("mapEvent", new Qu(h, s));
          const m = h.boxZoom = new us(h, s);
          this._add("boxZoom", m), s.interactive && s.boxZoom && m.enable();
          const y = h.cooperativeGestures = new Zl(h, s.cooperativeGestures);
          this._add("cooperativeGestures", y), s.cooperativeGestures && y.enable();
          const S = new xi(h), C = new Oc(h);
          h.doubleClickZoom = new ia(C, S), this._add("tapZoom", S), this._add("clickZoom", C), s.interactive && s.doubleClickZoom && h.doubleClickZoom.enable();
          const B = new uf();
          this._add("tapDragZoom", B);
          const D = h.touchPitch = new $l(h);
          this._add("touchPitch", D), s.interactive && s.touchPitch && h.touchPitch.enable(s.touchPitch);
          const z = Hl(s), N = Mc(s);
          h.dragRotate = new rh(s, z, N), this._add("mouseRotate", z, ["mousePitch"]), this._add("mousePitch", N, ["mouseRotate"]), s.interactive && s.dragRotate && h.dragRotate.enable();
          const X = ((fe) => {
            let { enable: he, clickTolerance: ve } = fe;
            const Be = new sl({ checkCorrectEvent: (Pe) => I.mouseButton(Pe) === 0 && !Pe.ctrlKey });
            return new hi({ clickTolerance: ve, move: (Pe, Qe) => ({ around: Qe, panDelta: Qe.sub(Pe) }), activateOnStart: !0, moveStateManager: Be, enable: he, assignEvents: ol });
          })(s), Z = new Oa(s, h);
          h.dragPan = new Xh(f, X, Z), this._add("mousePan", X), this._add("touchPan", Z, ["touchZoom", "touchRotate"]), s.interactive && s.dragPan && h.dragPan.enable(s.dragPan);
          const W = new th(), Q = new Bc();
          h.touchZoomRotate = new ih(f, Q, W, B), this._add("touchRotate", W, ["touchPan", "touchZoom"]), this._add("touchZoom", Q, ["touchPan", "touchRotate"]), s.interactive && s.touchZoomRotate && h.touchZoomRotate.enable(s.touchZoomRotate);
          const le = h.scrollZoom = new Ss(h, () => this._triggerRenderFrame());
          this._add("scrollZoom", le, ["mousePan"]), s.interactive && s.scrollZoom && h.scrollZoom.enable(s.scrollZoom);
          const ue = h.keyboard = new Gs(h);
          this._add("keyboard", ue), s.interactive && s.keyboard && h.keyboard.enable(), this._add("blockableMapEvent", new Wr(h));
        }
        _add(s, h, f) {
          this._handlers.push({ handlerName: s, handler: h, allowed: f }), this._handlersById[s] = h;
        }
        stop(s) {
          if (!this._updatingCamera) {
            for (const { handler: h } of this._handlers) h.reset();
            this._inertia.clear(), this._fireEvents({}, {}, s), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: s } of this._handlers) if (s.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Vs(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(s, h, f) {
          for (const m in s) if (m !== f && (!h || h.indexOf(m) < 0)) return !0;
          return !1;
        }
        _getMapTouches(s) {
          const h = [];
          for (const f of s) this._el.contains(f.target) && h.push(f);
          return h;
        }
        mergeHandlerResult(s, h, f, m, y) {
          if (!f) return;
          l.e(s, f);
          const S = { handlerName: m, originalEvent: f.originalEvent || y };
          f.zoomDelta !== void 0 && (h.zoom = S), f.panDelta !== void 0 && (h.drag = S), f.pitchDelta !== void 0 && (h.pitch = S), f.bearingDelta !== void 0 && (h.rotate = S);
        }
        _applyChanges() {
          const s = {}, h = {}, f = {};
          for (const [m, y, S] of this._changes) m.panDelta && (s.panDelta = (s.panDelta || new l.P(0, 0))._add(m.panDelta)), m.zoomDelta && (s.zoomDelta = (s.zoomDelta || 0) + m.zoomDelta), m.bearingDelta && (s.bearingDelta = (s.bearingDelta || 0) + m.bearingDelta), m.pitchDelta && (s.pitchDelta = (s.pitchDelta || 0) + m.pitchDelta), m.around !== void 0 && (s.around = m.around), m.pinchAround !== void 0 && (s.pinchAround = m.pinchAround), m.noInertia && (s.noInertia = m.noInertia), l.e(h, y), l.e(f, S);
          this._updateMapTransform(s, h, f), this._changes = [];
        }
        _updateMapTransform(s, h, f) {
          const m = this._map, y = m._getTransformForUpdate(), S = m.terrain;
          if (!(yo(s) || S && this._terrainMovement)) return this._fireEvents(h, f, !0);
          let { panDelta: C, zoomDelta: B, bearingDelta: D, pitchDelta: z, around: N, pinchAround: X } = s;
          X !== void 0 && (N = X), m._stop(!0), N = N || m.transform.centerPoint;
          const Z = y.pointLocation(C ? N.sub(C) : N);
          D && (y.bearing += D), z && (y.pitch += z), B && (y.zoom += B), S ? this._terrainMovement || !h.drag && !h.zoom ? h.drag && this._terrainMovement ? y.center = y.pointLocation(y.centerPoint.sub(C)) : y.setLocationAtPoint(Z, N) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, y.setLocationAtPoint(Z, N)) : y.setLocationAtPoint(Z, N), m._applyUpdatedTransform(y), this._map._update(), s.noInertia || this._inertia.record(s), this._fireEvents(h, f, !0);
        }
        _fireEvents(s, h, f) {
          const m = Vs(this._eventsInProgress), y = Vs(s), S = {};
          for (const N in s) {
            const { originalEvent: X } = s[N];
            this._eventsInProgress[N] || (S[`${N}start`] = X), this._eventsInProgress[N] = s[N];
          }
          !m && y && this._fireEvent("movestart", y.originalEvent);
          for (const N in S) this._fireEvent(N, S[N]);
          y && this._fireEvent("move", y.originalEvent);
          for (const N in s) {
            const { originalEvent: X } = s[N];
            this._fireEvent(N, X);
          }
          const C = {};
          let B;
          for (const N in this._eventsInProgress) {
            const { handlerName: X, originalEvent: Z } = this._eventsInProgress[N];
            this._handlersById[X].isActive() || (delete this._eventsInProgress[N], B = h[X] || Z, C[`${N}end`] = B);
          }
          for (const N in C) this._fireEvent(N, C[N]);
          const D = Vs(this._eventsInProgress), z = (m || y) && !D;
          if (z && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const N = this._map._getTransformForUpdate();
            N.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(N);
          }
          if (f && z) {
            this._updatingCamera = !0;
            const N = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), X = (Z) => Z !== 0 && -this._bearingSnap < Z && Z < this._bearingSnap;
            !N || !N.essential && T.prefersReducedMotion ? (this._map.fire(new l.k("moveend", { originalEvent: B })), X(this._map.getBearing()) && this._map.resetNorth()) : (X(N.bearing || this._map.getBearing()) && (N.bearing = 0), N.freezeElevation = !0, this._map.easeTo(N, { originalEvent: B })), this._updatingCamera = !1;
          }
        }
        _fireEvent(s, h) {
          this._map.fire(new l.k(s, h ? { originalEvent: h } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((s) => {
            delete this._frameId, this.handleEvent(new qt("renderFrame", { timeStamp: s })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Do extends l.E {
        constructor(s, h) {
          super(), this._renderFrameCallback = () => {
            const f = Math.min((T.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(f)), f < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = s, this._bearingSnap = h.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new l.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(s, h) {
          return this.jumpTo({ center: s }, h);
        }
        panBy(s, h, f) {
          return s = l.P.convert(s).mult(-1), this.panTo(this.transform.center, l.e({ offset: s }, h), f);
        }
        panTo(s, h, f) {
          return this.easeTo(l.e({ center: s }, h), f);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(s, h) {
          return this.jumpTo({ zoom: s }, h), this;
        }
        zoomTo(s, h, f) {
          return this.easeTo(l.e({ zoom: s }, h), f);
        }
        zoomIn(s, h) {
          return this.zoomTo(this.getZoom() + 1, s, h), this;
        }
        zoomOut(s, h) {
          return this.zoomTo(this.getZoom() - 1, s, h), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(s, h) {
          return this.jumpTo({ bearing: s }, h), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(s, h) {
          return this.jumpTo({ padding: s }, h), this;
        }
        rotateTo(s, h, f) {
          return this.easeTo(l.e({ bearing: s }, h), f);
        }
        resetNorth(s, h) {
          return this.rotateTo(0, l.e({ duration: 1e3 }, s), h), this;
        }
        resetNorthPitch(s, h) {
          return this.easeTo(l.e({ bearing: 0, pitch: 0, duration: 1e3 }, s), h), this;
        }
        snapToNorth(s, h) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(s, h) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(s, h) {
          return this.jumpTo({ pitch: s }, h), this;
        }
        cameraForBounds(s, h) {
          s = ne.convert(s).adjustAntiMeridian();
          const f = h && h.bearing || 0;
          return this._cameraForBoxAndBearing(s.getNorthWest(), s.getSouthEast(), f, h);
        }
        _cameraForBoxAndBearing(s, h, f, m) {
          const y = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (m = l.e({ padding: y, offset: [0, 0], maxZoom: this.transform.maxZoom }, m)).padding == "number") {
            const bt = m.padding;
            m.padding = { top: bt, bottom: bt, right: bt, left: bt };
          }
          m.padding = l.e(y, m.padding);
          const S = this.transform, C = S.padding, B = new ne(s, h), D = S.project(B.getNorthWest()), z = S.project(B.getNorthEast()), N = S.project(B.getSouthEast()), X = S.project(B.getSouthWest()), Z = l.ba(-f), W = D.rotate(Z), Q = z.rotate(Z), le = N.rotate(Z), ue = X.rotate(Z), fe = new l.P(Math.max(W.x, Q.x, ue.x, le.x), Math.max(W.y, Q.y, ue.y, le.y)), he = new l.P(Math.min(W.x, Q.x, ue.x, le.x), Math.min(W.y, Q.y, ue.y, le.y)), ve = fe.sub(he), Be = (S.width - (C.left + C.right + m.padding.left + m.padding.right)) / ve.x, Pe = (S.height - (C.top + C.bottom + m.padding.top + m.padding.bottom)) / ve.y;
          if (Pe < 0 || Be < 0) return void l.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const Qe = Math.min(S.scaleZoom(S.scale * Math.min(Be, Pe)), m.maxZoom), ft = l.P.convert(m.offset), _t = new l.P((m.padding.left - m.padding.right) / 2, (m.padding.top - m.padding.bottom) / 2).rotate(l.ba(f)), xt = ft.add(_t).mult(S.scale / S.zoomScale(Qe));
          return { center: S.unproject(D.add(N).div(2).sub(xt)), zoom: Qe, bearing: f };
        }
        fitBounds(s, h, f) {
          return this._fitInternal(this.cameraForBounds(s, h), h, f);
        }
        fitScreenCoordinates(s, h, f, m, y) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(l.P.convert(s)), this.transform.pointLocation(l.P.convert(h)), f, m), m, y);
        }
        _fitInternal(s, h, f) {
          return s ? (delete (h = l.e(s, h)).padding, h.linear ? this.easeTo(h, f) : this.flyTo(h, f)) : this;
        }
        jumpTo(s, h) {
          this.stop();
          const f = this._getTransformForUpdate();
          let m = !1, y = !1, S = !1;
          return "zoom" in s && f.zoom !== +s.zoom && (m = !0, f.zoom = +s.zoom), s.center !== void 0 && (f.center = l.N.convert(s.center)), "bearing" in s && f.bearing !== +s.bearing && (y = !0, f.bearing = +s.bearing), "pitch" in s && f.pitch !== +s.pitch && (S = !0, f.pitch = +s.pitch), s.padding == null || f.isPaddingEqual(s.padding) || (f.padding = s.padding), this._applyUpdatedTransform(f), this.fire(new l.k("movestart", h)).fire(new l.k("move", h)), m && this.fire(new l.k("zoomstart", h)).fire(new l.k("zoom", h)).fire(new l.k("zoomend", h)), y && this.fire(new l.k("rotatestart", h)).fire(new l.k("rotate", h)).fire(new l.k("rotateend", h)), S && this.fire(new l.k("pitchstart", h)).fire(new l.k("pitch", h)).fire(new l.k("pitchend", h)), this.fire(new l.k("moveend", h));
        }
        calculateCameraOptionsFromTo(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          const y = l.Z.fromLngLat(s, h), S = l.Z.fromLngLat(f, m), C = S.x - y.x, B = S.y - y.y, D = S.z - y.z, z = Math.hypot(C, B, D);
          if (z === 0) throw new Error("Can't calculate camera options with same From and To");
          const N = Math.hypot(C, B), X = this.transform.scaleZoom(this.transform.cameraToCenterDistance / z / this.transform.tileSize), Z = 180 * Math.atan2(C, -B) / Math.PI;
          let W = 180 * Math.acos(N / z) / Math.PI;
          return W = D < 0 ? 90 - W : 90 + W, { center: S.toLngLat(), zoom: X, pitch: W, bearing: Z };
        }
        easeTo(s, h) {
          var f;
          this._stop(!1, s.easeId), ((s = l.e({ offset: [0, 0], duration: 500, easing: l.b9 }, s)).animate === !1 || !s.essential && T.prefersReducedMotion) && (s.duration = 0);
          const m = this._getTransformForUpdate(), y = m.zoom, S = m.bearing, C = m.pitch, B = m.padding, D = "bearing" in s ? this._normalizeBearing(s.bearing, S) : S, z = "pitch" in s ? +s.pitch : C, N = "padding" in s ? s.padding : m.padding, X = l.P.convert(s.offset);
          let Z = m.centerPoint.add(X);
          const W = m.pointLocation(Z), { center: Q, zoom: le } = m.getConstrained(l.N.convert(s.center || W), (f = s.zoom) !== null && f !== void 0 ? f : y);
          this._normalizeCenter(Q, m);
          const ue = m.project(W), fe = m.project(Q).sub(ue), he = m.zoomScale(le - y);
          let ve, Be;
          s.around && (ve = l.N.convert(s.around), Be = m.locationPoint(ve));
          const Pe = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || le !== y, this._rotating = this._rotating || S !== D, this._pitching = this._pitching || z !== C, this._padding = !m.isPaddingEqual(N), this._easeId = s.easeId, this._prepareEase(h, s.noMoveStart, Pe), this.terrain && this._prepareElevation(Q), this._ease((Qe) => {
            if (this._zooming && (m.zoom = l.y.number(y, le, Qe)), this._rotating && (m.bearing = l.y.number(S, D, Qe)), this._pitching && (m.pitch = l.y.number(C, z, Qe)), this._padding && (m.interpolatePadding(B, N, Qe), Z = m.centerPoint.add(X)), this.terrain && !s.freezeElevation && this._updateElevation(Qe), ve) m.setLocationAtPoint(ve, Be);
            else {
              const ft = m.zoomScale(m.zoom - y), _t = le > y ? Math.min(2, he) : Math.max(0.5, he), xt = Math.pow(_t, 1 - Qe), bt = m.unproject(ue.add(fe.mult(Qe * xt)).mult(ft));
              m.setLocationAtPoint(m.renderWorldCopies ? bt.wrap() : bt, Z);
            }
            this._applyUpdatedTransform(m), this._fireMoveEvents(h);
          }, (Qe) => {
            this.terrain && s.freezeElevation && this._finalizeElevation(), this._afterEase(h, Qe);
          }, s), this;
        }
        _prepareEase(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._moving = !0, h || f.moving || this.fire(new l.k("movestart", s)), this._zooming && !f.zooming && this.fire(new l.k("zoomstart", s)), this._rotating && !f.rotating && this.fire(new l.k("rotatestart", s)), this._pitching && !f.pitching && this.fire(new l.k("pitchstart", s));
        }
        _prepareElevation(s) {
          this._elevationCenter = s, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(s, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(s) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const h = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (s < 1 && h !== this._elevationTarget) {
            const f = this._elevationTarget - this._elevationStart;
            this._elevationStart += s * (f - (h - (f * s + this._elevationStart)) / (1 - s)), this._elevationTarget = h;
          }
          this.transform.elevation = l.y.number(this._elevationStart, this._elevationTarget, s);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(s) {
          const h = s.getCameraPosition(), f = this.terrain.getElevationForLngLatZoom(h.lngLat, s.zoom);
          if (h.altitude < f) {
            const m = this.calculateCameraOptionsFromTo(h.lngLat, f, s.center, s.elevation);
            return { pitch: m.pitch, zoom: m.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(s) {
          const h = [];
          if (this.terrain && h.push((m) => this._elevateCameraIfInsideTerrain(m)), this.transformCameraUpdate && h.push((m) => this.transformCameraUpdate(m)), !h.length) return;
          const f = s.clone();
          for (const m of h) {
            const y = f.clone(), { center: S, zoom: C, pitch: B, bearing: D, elevation: z } = m(y);
            S && (y.center = S), C !== void 0 && (y.zoom = C), B !== void 0 && (y.pitch = B), D !== void 0 && (y.bearing = D), z !== void 0 && (y.elevation = z), f.apply(y);
          }
          this.transform.apply(f);
        }
        _fireMoveEvents(s) {
          this.fire(new l.k("move", s)), this._zooming && this.fire(new l.k("zoom", s)), this._rotating && this.fire(new l.k("rotate", s)), this._pitching && this.fire(new l.k("pitch", s));
        }
        _afterEase(s, h) {
          if (this._easeId && h && this._easeId === h) return;
          delete this._easeId;
          const f = this._zooming, m = this._rotating, y = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, f && this.fire(new l.k("zoomend", s)), m && this.fire(new l.k("rotateend", s)), y && this.fire(new l.k("pitchend", s)), this.fire(new l.k("moveend", s));
        }
        flyTo(s, h) {
          var f;
          if (!s.essential && T.prefersReducedMotion) {
            const It = l.M(s, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(It, h);
          }
          this.stop(), s = l.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: l.b9 }, s);
          const m = this._getTransformForUpdate(), y = m.zoom, S = m.bearing, C = m.pitch, B = m.padding, D = "bearing" in s ? this._normalizeBearing(s.bearing, S) : S, z = "pitch" in s ? +s.pitch : C, N = "padding" in s ? s.padding : m.padding, X = l.P.convert(s.offset);
          let Z = m.centerPoint.add(X);
          const W = m.pointLocation(Z), { center: Q, zoom: le } = m.getConstrained(l.N.convert(s.center || W), (f = s.zoom) !== null && f !== void 0 ? f : y);
          this._normalizeCenter(Q, m);
          const ue = m.zoomScale(le - y), fe = m.project(W), he = m.project(Q).sub(fe);
          let ve = s.curve;
          const Be = Math.max(m.width, m.height), Pe = Be / ue, Qe = he.mag();
          if ("minZoom" in s) {
            const It = l.ac(Math.min(s.minZoom, y, le), m.minZoom, m.maxZoom), rn = Be / m.zoomScale(It - y);
            ve = Math.sqrt(rn / Qe * 2);
          }
          const ft = ve * ve;
          function _t(It) {
            const rn = (Pe * Pe - Be * Be + (It ? -1 : 1) * ft * ft * Qe * Qe) / (2 * (It ? Pe : Be) * ft * Qe);
            return Math.log(Math.sqrt(rn * rn + 1) - rn);
          }
          function xt(It) {
            return (Math.exp(It) - Math.exp(-It)) / 2;
          }
          function bt(It) {
            return (Math.exp(It) + Math.exp(-It)) / 2;
          }
          const yt = _t(!1);
          let wt = function(It) {
            return bt(yt) / bt(yt + ve * It);
          }, Jt = function(It) {
            return Be * ((bt(yt) * (xt(rn = yt + ve * It) / bt(rn)) - xt(yt)) / ft) / Qe;
            var rn;
          }, Ct = (_t(!0) - yt) / ve;
          if (Math.abs(Qe) < 1e-6 || !isFinite(Ct)) {
            if (Math.abs(Be - Pe) < 1e-6) return this.easeTo(s, h);
            const It = Pe < Be ? -1 : 1;
            Ct = Math.abs(Math.log(Pe / Be)) / ve, Jt = () => 0, wt = (rn) => Math.exp(It * ve * rn);
          }
          return s.duration = "duration" in s ? +s.duration : 1e3 * Ct / ("screenSpeed" in s ? +s.screenSpeed / ve : +s.speed), s.maxDuration && s.duration > s.maxDuration && (s.duration = 0), this._zooming = !0, this._rotating = S !== D, this._pitching = z !== C, this._padding = !m.isPaddingEqual(N), this._prepareEase(h, !1), this.terrain && this._prepareElevation(Q), this._ease((It) => {
            const rn = It * Ct, An = 1 / wt(rn);
            m.zoom = It === 1 ? le : y + m.scaleZoom(An), this._rotating && (m.bearing = l.y.number(S, D, It)), this._pitching && (m.pitch = l.y.number(C, z, It)), this._padding && (m.interpolatePadding(B, N, It), Z = m.centerPoint.add(X)), this.terrain && !s.freezeElevation && this._updateElevation(It);
            const yn = It === 1 ? Q : m.unproject(fe.add(he.mult(Jt(rn))).mult(An));
            m.setLocationAtPoint(m.renderWorldCopies ? yn.wrap() : yn, Z), this._applyUpdatedTransform(m), this._fireMoveEvents(h);
          }, () => {
            this.terrain && s.freezeElevation && this._finalizeElevation(), this._afterEase(h);
          }, s), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(s, h) {
          var f;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const m = this._onEaseEnd;
            delete this._onEaseEnd, m.call(this, h);
          }
          return s || (f = this.handlers) === null || f === void 0 || f.stop(!1), this;
        }
        _ease(s, h, f) {
          f.animate === !1 || f.duration === 0 ? (s(1), h()) : (this._easeStart = T.now(), this._easeOptions = f, this._onEaseFrame = s, this._onEaseEnd = h, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(s, h) {
          s = l.b3(s, -180, 180);
          const f = Math.abs(s - h);
          return Math.abs(s - 360 - h) < f && (s -= 360), Math.abs(s + 360 - h) < f && (s += 360), s;
        }
        _normalizeCenter(s, h) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const f = s.lng - h.center.lng;
          s.lng += f > 180 ? -360 : f < -180 ? 360 : 0;
        }
        queryTerrainElevation(s) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(l.N.convert(s), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const Jl = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class ll {
        constructor() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Jl;
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (h) => {
            !h || h.sourceDataType !== "metadata" && h.sourceDataType !== "visibility" && h.dataType !== "style" && h.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = s;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(s) {
          return this._map = s, this._compact = this.options.compact, this._container = I.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = I.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = I.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(s, h) {
          const f = this._map._getUIString(`AttributionControl.${h}`);
          s.title = f, s.setAttribute("aria-label", f);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let s = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? s = s.concat(this.options.customAttribution.map((m) => typeof m != "string" ? "" : m)) : typeof this.options.customAttribution == "string" && s.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const m = this._map.style.stylesheet;
            this.styleOwner = m.owner, this.styleId = m.id;
          }
          const h = this._map.style.sourceCaches;
          for (const m in h) {
            const y = h[m];
            if (y.used || y.usedForTerrain) {
              const S = y.getSource();
              S.attribution && s.indexOf(S.attribution) < 0 && s.push(S.attribution);
            }
          }
          s = s.filter((m) => String(m).trim()), s.sort((m, y) => m.length - y.length), s = s.filter((m, y) => {
            for (let S = y + 1; S < s.length; S++) if (s[S].indexOf(m) >= 0) return !1;
            return !0;
          });
          const f = s.join(" | ");
          f !== this._attribHTML && (this._attribHTML = f, s.length ? (this._innerContainer.innerHTML = f, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class Fo {
        constructor() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this._updateCompact = () => {
            const h = this._container.children;
            if (h.length) {
              const f = h[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && f.classList.add("maplibregl-compact") : f.classList.remove("maplibregl-compact");
            }
          }, this.options = s;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(s) {
          this._map = s, this._compact = this.options && this.options.compact, this._container = I.create("div", "maplibregl-ctrl");
          const h = I.create("a", "maplibregl-ctrl-logo");
          return h.target = "_blank", h.rel = "noopener nofollow", h.href = "https://maplibre.org/", h.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), h.setAttribute("rel", "noopener nofollow"), this._container.appendChild(h), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class Cn {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(s) {
          const h = ++this._id;
          return this._queue.push({ callback: s, id: h, cancelled: !1 }), h;
        }
        remove(s) {
          const h = this._currentlyRunning, f = h ? this._queue.concat(h) : this._queue;
          for (const m of f) if (m.id === s) return void (m.cancelled = !0);
        }
        run() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const h = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const f of h) if (!f.cancelled && (f.callback(s), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var sh = l.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class hf extends l.E {
        constructor(s) {
          super(), this.sourceCache = s, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, s.usedForTerrain = !0, s.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(s, h) {
          this.sourceCache.update(s, h), this._renderableTilesKeys = [];
          const f = {};
          for (const m of s.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: h })) f[m.key] = !0, this._renderableTilesKeys.push(m.key), this._tiles[m.key] || (m.posMatrix = new Float64Array(16), l.aP(m.posMatrix, 0, l.X, 0, l.X, 0, 1), this._tiles[m.key] = new _r(m, this.tileSize));
          for (const m in this._tiles) f[m] || delete this._tiles[m];
        }
        freeRtt(s) {
          for (const h in this._tiles) {
            const f = this._tiles[h];
            (!s || f.tileID.equals(s) || f.tileID.isChildOf(s) || s.isChildOf(f.tileID)) && (f.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((s) => this.getTileByID(s));
        }
        getTileByID(s) {
          return this._tiles[s];
        }
        getTerrainCoords(s) {
          const h = {};
          for (const f of this._renderableTilesKeys) {
            const m = this._tiles[f].tileID;
            if (m.canonical.equals(s.canonical)) {
              const y = s.clone();
              y.posMatrix = new Float64Array(16), l.aP(y.posMatrix, 0, l.X, 0, l.X, 0, 1), h[f] = y;
            } else if (m.canonical.isChildOf(s.canonical)) {
              const y = s.clone();
              y.posMatrix = new Float64Array(16);
              const S = m.canonical.z - s.canonical.z, C = m.canonical.x - (m.canonical.x >> S << S), B = m.canonical.y - (m.canonical.y >> S << S), D = l.X >> S;
              l.aP(y.posMatrix, 0, D, 0, D, 0, 1), l.J(y.posMatrix, y.posMatrix, [-C * D, -B * D, 0]), h[f] = y;
            } else if (s.canonical.isChildOf(m.canonical)) {
              const y = s.clone();
              y.posMatrix = new Float64Array(16);
              const S = s.canonical.z - m.canonical.z, C = s.canonical.x - (s.canonical.x >> S << S), B = s.canonical.y - (s.canonical.y >> S << S), D = l.X >> S;
              l.aP(y.posMatrix, 0, l.X, 0, l.X, 0, 1), l.J(y.posMatrix, y.posMatrix, [C * D, B * D, 0]), l.K(y.posMatrix, y.posMatrix, [1 / 2 ** S, 1 / 2 ** S, 0]), h[f] = y;
            }
          }
          return h;
        }
        getSourceTile(s, h) {
          const f = this.sourceCache._source;
          let m = s.overscaledZ - this.deltaZoom;
          if (m > f.maxzoom && (m = f.maxzoom), m < f.minzoom) return null;
          this._sourceTileCache[s.key] || (this._sourceTileCache[s.key] = s.scaledTo(m).key);
          let y = this.sourceCache.getTileByID(this._sourceTileCache[s.key]);
          if ((!y || !y.dem) && h) for (; m >= f.minzoom && (!y || !y.dem); ) y = this.sourceCache.getTileByID(s.scaledTo(m--).key);
          return y;
        }
        tilesAfterTime() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();
          return Object.values(this._tiles).filter((h) => h.timeAdded >= s);
        }
      }
      class mu {
        constructor(s, h, f) {
          this.painter = s, this.sourceCache = new hf(h), this.options = f, this.exaggeration = typeof f.exaggeration == "number" ? f.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : l.X;
          var y;
          if (!(h >= 0 && h < m && f >= 0 && f < m)) return 0;
          const S = this.getTerrainData(s), C = (y = S.tile) === null || y === void 0 ? void 0 : y.dem;
          if (!C) return 0;
          const B = function(W, Q, le) {
            var ue = Q[0], fe = Q[1];
            return W[0] = le[0] * ue + le[4] * fe + le[12], W[1] = le[1] * ue + le[5] * fe + le[13], W;
          }([], [h / m * l.X, f / m * l.X], S.u_terrain_matrix), D = [B[0] * C.dim, B[1] * C.dim], z = Math.floor(D[0]), N = Math.floor(D[1]), X = D[0] - z, Z = D[1] - N;
          return C.get(z, N) * (1 - X) * (1 - Z) + C.get(z + 1, N) * X * (1 - Z) + C.get(z, N + 1) * (1 - X) * Z + C.get(z + 1, N + 1) * X * Z;
        }
        getElevationForLngLatZoom(s, h) {
          if (!l.bb(h, s.wrap())) return 0;
          const { tileID: f, mercatorX: m, mercatorY: y } = this._getOverscaledTileIDFromLngLatZoom(s, h);
          return this.getElevation(f, m % l.X, y % l.X, l.X);
        }
        getElevation(s, h, f) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : l.X;
          return this.getDEMElevation(s, h, f, m) * this.exaggeration;
        }
        getTerrainData(s) {
          if (!this._emptyDemTexture) {
            const m = this.painter.context, y = new l.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new oe(m, y, m.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new oe(m, new l.R({ width: 1, height: 1 }), m.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = l.an([]);
          }
          const h = this.sourceCache.getSourceTile(s, !0);
          if (h && h.dem && (!h.demTexture || h.needsTerrainPrepare)) {
            const m = this.painter.context;
            h.demTexture = this.painter.getTileTexture(h.dem.stride), h.demTexture ? h.demTexture.update(h.dem.getPixels(), { premultiply: !1 }) : h.demTexture = new oe(m, h.dem.getPixels(), m.gl.RGBA, { premultiply: !1 }), h.demTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), h.needsTerrainPrepare = !1;
          }
          const f = h && h + h.tileID.key + s.key;
          if (f && !this._demMatrixCache[f]) {
            const m = this.sourceCache.sourceCache._source.maxzoom;
            let y = s.canonical.z - h.tileID.canonical.z;
            s.overscaledZ > s.canonical.z && (s.canonical.z >= m ? y = s.canonical.z - m : l.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const S = s.canonical.x - (s.canonical.x >> y << y), C = s.canonical.y - (s.canonical.y >> y << y), B = l.bc(new Float64Array(16), [1 / (l.X << y), 1 / (l.X << y), 0]);
            l.J(B, B, [S * l.X, C * l.X, 0]), this._demMatrixCache[s.key] = { matrix: B, coord: s };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: h && h.dem && h.dem.dim || 1, u_terrain_matrix: f ? this._demMatrixCache[s.key].matrix : this._emptyDemMatrix, u_terrain_unpack: h && h.dem && h.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (h && h.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: h };
        }
        getFramebuffer(s) {
          const h = this.painter, f = h.width / devicePixelRatio, m = h.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === f && this._fbo.height === m || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new oe(h.context, { width: f, height: m, data: null }, h.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(h.context.gl.NEAREST, h.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new oe(h.context, { width: f, height: m, data: null }, h.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(h.context.gl.NEAREST, h.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = h.context.createFramebuffer(f, m, !0, !1), this._fbo.depthAttachment.set(h.context.createRenderbuffer(h.context.gl.DEPTH_COMPONENT16, f, m))), this._fbo.colorAttachment.set(s === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const s = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const h = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let y = 0, S = 0; y < this._coordsTextureSize; y++) for (let C = 0; C < this._coordsTextureSize; C++, S += 4) h[S + 0] = 255 & C, h[S + 1] = 255 & y, h[S + 2] = C >> 8 << 4 | y >> 8, h[S + 3] = 0;
          const f = new l.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(h.buffer)), m = new oe(s, f, s.gl.RGBA, { premultiply: !1 });
          return m.bind(s.gl.NEAREST, s.gl.CLAMP_TO_EDGE), this._coordsTexture = m, m;
        }
        pointCoordinate(s) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const h = new Uint8Array(4), f = this.painter.context, m = f.gl, y = Math.round(s.x * this.painter.pixelRatio / devicePixelRatio), S = Math.round(s.y * this.painter.pixelRatio / devicePixelRatio), C = Math.round(this.painter.height / devicePixelRatio);
          f.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), m.readPixels(y, C - S - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, h), f.bindFramebuffer.set(null);
          const B = h[0] + (h[2] >> 4 << 8), D = h[1] + ((15 & h[2]) << 8), z = this.coordsIndex[255 - h[3]], N = z && this.sourceCache.getTileByID(z);
          if (!N) return null;
          const X = this._coordsTextureSize, Z = (1 << N.tileID.canonical.z) * X;
          return new l.Z((N.tileID.canonical.x * X + B) / Z + N.tileID.wrap, (N.tileID.canonical.y * X + D) / Z, this.getElevation(N.tileID, B, D, X));
        }
        depthAtPoint(s) {
          const h = new Uint8Array(4), f = this.painter.context, m = f.gl;
          return f.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), m.readPixels(s.x, this.painter.height / devicePixelRatio - s.y - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, h), f.bindFramebuffer.set(null), (h[0] / 16777216 + h[1] / 65536 + h[2] / 256 + h[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const s = this.painter.context, h = new l.bd(), f = new l.aY(), m = this.meshSize, y = l.X / m, S = m * m;
          for (let N = 0; N <= m; N++) for (let X = 0; X <= m; X++) h.emplaceBack(X * y, N * y, 0);
          for (let N = 0; N < S; N += m + 1) for (let X = 0; X < m; X++) f.emplaceBack(X + N, m + X + N + 1, m + X + N + 2), f.emplaceBack(X + N, m + X + N + 2, X + N + 1);
          const C = h.length, B = C + 2 * (m + 1);
          for (const N of [0, 1]) for (let X = 0; X <= m; X++) for (const Z of [0, 1]) h.emplaceBack(X * y, N * l.X, Z);
          for (let N = 0; N < 2 * m; N += 2) f.emplaceBack(B + N, B + N + 1, B + N + 3), f.emplaceBack(B + N, B + N + 3, B + N + 2), f.emplaceBack(C + N, C + N + 3, C + N + 1), f.emplaceBack(C + N, C + N + 2, C + N + 3);
          const D = h.length, z = D + 2 * (m + 1);
          for (const N of [0, 1]) for (let X = 0; X <= m; X++) for (const Z of [0, 1]) h.emplaceBack(N * l.X, X * y, Z);
          for (let N = 0; N < 2 * m; N += 2) f.emplaceBack(D + N, D + N + 1, D + N + 3), f.emplaceBack(D + N, D + N + 3, D + N + 2), f.emplaceBack(z + N, z + N + 3, z + N + 1), f.emplaceBack(z + N, z + N + 2, z + N + 3);
          return this._mesh = new Ma(s.createVertexBuffer(h, sh.members), s.createIndexBuffer(f), l.a0.simpleSegment(0, 0, h.length, f.length)), this._mesh;
        }
        getMeshFrameDelta(s) {
          return 2 * Math.PI * l.be / Math.pow(2, s) / 5;
        }
        getMinTileElevationForLngLatZoom(s, h) {
          var f;
          const { tileID: m } = this._getOverscaledTileIDFromLngLatZoom(s, h);
          return (f = this.getMinMaxElevation(m).minElevation) !== null && f !== void 0 ? f : 0;
        }
        getMinMaxElevation(s) {
          const h = this.getTerrainData(s).tile, f = { minElevation: null, maxElevation: null };
          return h && h.dem && (f.minElevation = h.dem.min * this.exaggeration, f.maxElevation = h.dem.max * this.exaggeration), f;
        }
        _getOverscaledTileIDFromLngLatZoom(s, h) {
          const f = l.Z.fromLngLat(s.wrap()), m = (1 << h) * l.X, y = f.x * m, S = f.y * m, C = Math.floor(y / l.X), B = Math.floor(S / l.X);
          return { tileID: new l.S(h, 0, h, C, B), mercatorX: y, mercatorY: S };
        }
      }
      class $h {
        constructor(s, h, f) {
          this._context = s, this._size = h, this._tileSize = f, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const s of this._objects) s.texture.destroy(), s.fbo.destroy();
        }
        _createObject(s) {
          const h = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), f = new oe(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return f.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), h.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), h.colorAttachment.set(f.texture), { id: s, fbo: h, texture: f, stamp: -1, inUse: !1 };
        }
        getObjectForId(s) {
          return this._objects[s];
        }
        useObject(s) {
          s.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((h) => s.id !== h), this._recentlyUsed.push(s.id);
        }
        stampObject(s) {
          s.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const h of this._recentlyUsed) if (!this._objects[h].inUse) return this._objects[h];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const s = this._createObject(this._objects.length);
          return this._objects.push(s), s;
        }
        freeObject(s) {
          s.inUse = !1;
        }
        freeAllObjects() {
          for (const s of this._objects) this.freeObject(s);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((s) => !s.inUse) === !1;
        }
      }
      const cl = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class oh {
        constructor(s, h) {
          this.painter = s, this.terrain = h, this.pool = new $h(s.context, 30, h.sourceCache.tileSize * h.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(s) {
          return this.pool.getObjectForId(s.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(s, h) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = s._order.filter((f) => !s._layers[f].isHidden(h)), this._coordsDescendingInv = {};
          for (const f in s.sourceCaches) {
            this._coordsDescendingInv[f] = {};
            const m = s.sourceCaches[f].getVisibleCoordinates();
            for (const y of m) {
              const S = this.terrain.sourceCache.getTerrainCoords(y);
              for (const C in S) this._coordsDescendingInv[f][C] || (this._coordsDescendingInv[f][C] = []), this._coordsDescendingInv[f][C].push(S[C]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const f of s._order) {
            const m = s._layers[f], y = m.source;
            if (cl[m.type] && !this._coordsDescendingInvStr[y]) {
              this._coordsDescendingInvStr[y] = {};
              for (const S in this._coordsDescendingInv[y]) this._coordsDescendingInvStr[y][S] = this._coordsDescendingInv[y][S].map((C) => C.key).sort().join();
            }
          }
          for (const f of this._renderableTiles) for (const m in this._coordsDescendingInvStr) {
            const y = this._coordsDescendingInvStr[m][f.tileID.key];
            y && y !== f.rttCoords[m] && (f.rtt = []);
          }
        }
        renderLayer(s) {
          if (s.isHidden(this.painter.transform.zoom)) return !1;
          const h = s.type, f = this.painter, m = this._renderableLayerIds[this._renderableLayerIds.length - 1] === s.id;
          if (cl[h] && (this._prevType && cl[this._prevType] || this._stacks.push([]), this._prevType = h, this._stacks[this._stacks.length - 1].push(s.id), !m)) return !0;
          if (cl[this._prevType] || cl[h] && m) {
            this._prevType = h;
            const y = this._stacks.length - 1, S = this._stacks[y] || [];
            for (const C of this._renderableTiles) {
              if (this.pool.isFull() && (rl(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(C), C.rtt[y]) {
                const D = this.pool.getObjectForId(C.rtt[y].id);
                if (D.stamp === C.rtt[y].stamp) {
                  this.pool.useObject(D);
                  continue;
                }
              }
              const B = this.pool.getOrCreateFreeObject();
              this.pool.useObject(B), this.pool.stampObject(B), C.rtt[y] = { id: B.id, stamp: B.stamp }, f.context.bindFramebuffer.set(B.fbo.framebuffer), f.context.clear({ color: l.aM.transparent, stencil: 0 }), f.currentStencilSource = void 0;
              for (let D = 0; D < S.length; D++) {
                const z = f.style._layers[S[D]], N = z.source ? this._coordsDescendingInv[z.source][C.tileID.key] : [C.tileID];
                f.context.viewport.set([0, 0, B.fbo.width, B.fbo.height]), f._renderTileClippingMasks(z, N), f.renderLayer(f, f.style.sourceCaches[z.source], z, N), z.source && (C.rttCoords[z.source] = this._coordsDescendingInvStr[z.source][C.tileID.key]);
              }
            }
            return rl(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), cl[h];
          }
          return !1;
        }
      }
      const ah = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Dc = _, _u = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: Jl, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: l.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, ul = (g) => {
        g.touchstart = g.dragStart, g.touchmoveWindow = g.dragMove, g.touchend = g.dragEnd;
      }, lh = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class Zh {
        constructor(s, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
          this.mousedown = (S) => {
            this.startMouse(l.e({}, S, { ctrlKey: !0, preventDefault: () => S.preventDefault() }), I.mousePos(this.element, S)), I.addEventListener(window, "mousemove", this.mousemove), I.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (S) => {
            this.moveMouse(S, I.mousePos(this.element, S));
          }, this.mouseup = (S) => {
            this.mouseRotate.dragEnd(S), this.mousePitch && this.mousePitch.dragEnd(S), this.offTemp();
          }, this.touchstart = (S) => {
            S.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = I.touchPos(this.element, S.targetTouches)[0], this.startTouch(S, this._startPos), I.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), I.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (S) => {
            S.targetTouches.length !== 1 ? this.reset() : (this._lastPos = I.touchPos(this.element, S.targetTouches)[0], this.moveTouch(S, this._lastPos));
          }, this.touchend = (S) => {
            S.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const m = s.dragRotate._mouseRotate.getClickTolerance(), y = s.dragRotate._mousePitch.getClickTolerance();
          this.element = h, this.mouseRotate = Hl({ clickTolerance: m, enable: !0 }), this.touchRotate = ((S) => {
            let { enable: C, clickTolerance: B, bearingDegreesPerPixelMoved: D = 0.8 } = S;
            const z = new gu();
            return new hi({ clickTolerance: B, move: (N, X) => ({ bearingDelta: (X.x - N.x) * D }), moveStateManager: z, enable: C, assignEvents: ul });
          })({ clickTolerance: m, enable: !0 }), this.map = s, f && (this.mousePitch = Mc({ clickTolerance: y, enable: !0 }), this.touchPitch = ((S) => {
            let { enable: C, clickTolerance: B, pitchDegreesPerPixelMoved: D = -0.5 } = S;
            const z = new gu();
            return new hi({ clickTolerance: B, move: (N, X) => ({ pitchDelta: (X.y - N.y) * D }), moveStateManager: z, enable: C, assignEvents: ul });
          })({ clickTolerance: y, enable: !0 })), I.addEventListener(h, "mousedown", this.mousedown), I.addEventListener(h, "touchstart", this.touchstart, { passive: !1 }), I.addEventListener(h, "touchcancel", this.reset);
        }
        startMouse(s, h) {
          this.mouseRotate.dragStart(s, h), this.mousePitch && this.mousePitch.dragStart(s, h), I.disableDrag();
        }
        startTouch(s, h) {
          this.touchRotate.dragStart(s, h), this.touchPitch && this.touchPitch.dragStart(s, h), I.disableDrag();
        }
        moveMouse(s, h) {
          const f = this.map, { bearingDelta: m } = this.mouseRotate.dragMove(s, h) || {};
          if (m && f.setBearing(f.getBearing() + m), this.mousePitch) {
            const { pitchDelta: y } = this.mousePitch.dragMove(s, h) || {};
            y && f.setPitch(f.getPitch() + y);
          }
        }
        moveTouch(s, h) {
          const f = this.map, { bearingDelta: m } = this.touchRotate.dragMove(s, h) || {};
          if (m && f.setBearing(f.getBearing() + m), this.touchPitch) {
            const { pitchDelta: y } = this.touchPitch.dragMove(s, h) || {};
            y && f.setPitch(f.getPitch() + y);
          }
        }
        off() {
          const s = this.element;
          I.removeEventListener(s, "mousedown", this.mousedown), I.removeEventListener(s, "touchstart", this.touchstart, { passive: !1 }), I.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), I.removeEventListener(window, "touchend", this.touchend), I.removeEventListener(s, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          I.enableDrag(), I.removeEventListener(window, "mousemove", this.mousemove), I.removeEventListener(window, "mouseup", this.mouseup), I.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), I.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Ts;
      function vr(g, s, h) {
        const f = new l.N(g.lng, g.lat);
        if (g = new l.N(g.lng, g.lat), s) {
          const m = new l.N(g.lng - 360, g.lat), y = new l.N(g.lng + 360, g.lat), S = h.locationPoint(g).distSqr(s);
          h.locationPoint(m).distSqr(s) < S ? g = m : h.locationPoint(y).distSqr(s) < S && (g = y);
        }
        for (; Math.abs(g.lng - h.center.lng) > 180; ) {
          const m = h.locationPoint(g);
          if (m.x >= 0 && m.y >= 0 && m.x <= h.width && m.y <= h.height) break;
          g.lng > h.center.lng ? g.lng -= 360 : g.lng += 360;
        }
        return g.lng !== f.lng && h.locationPoint(g).y > h.height / 2 - h.getHorizon() ? g : f;
      }
      const Yl = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function yu(g, s, h) {
        const f = g.classList;
        for (const m in Yl) f.remove(`maplibregl-${h}-anchor-${m}`);
        f.add(`maplibregl-${h}-anchor-${s}`);
      }
      class bu extends l.E {
        constructor(s) {
          if (super(), this._onKeyPress = (h) => {
            const f = h.code, m = h.charCode || h.keyCode;
            f !== "Space" && f !== "Enter" && m !== 32 && m !== 13 || this.togglePopup();
          }, this._onMapClick = (h) => {
            const f = h.originalEvent.target, m = this._element;
            this._popup && (f === m || m.contains(f)) && this.togglePopup();
          }, this._update = (h) => {
            var f;
            if (!this._map) return;
            const m = this._map.loaded() && !this._map.isMoving();
            ((h == null ? void 0 : h.type) === "terrain" || (h == null ? void 0 : h.type) === "render" && !m) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? vr(this._lngLat, this._flatPos, this._map.transform) : (f = this._lngLat) === null || f === void 0 ? void 0 : f.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let y = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? y = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (y = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let S = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? S = "rotateX(0deg)" : this._pitchAlignment === "map" && (S = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || h && h.type !== "moveend" || (this._pos = this._pos.round()), I.setTransform(this._element, `${Yl[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${S} ${y}`), T.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(h && h.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (h) => {
            if (!this._isDragging) {
              const f = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = h.point.dist(this._pointerdownPos) >= f;
            }
            this._isDragging && (this._pos = h.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new l.k("dragstart"))), this.fire(new l.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new l.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (h) => {
            this._element.contains(h.originalEvent.target) && (h.preventDefault(), this._positionDelta = h.point.sub(this._pos).add(this._offset), this._pointerdownPos = h.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = s && s.anchor || "center", this._color = s && s.color || "#3FB1CE", this._scale = s && s.scale || 1, this._draggable = s && s.draggable || !1, this._clickTolerance = s && s.clickTolerance || 0, this._subpixelPositioning = s && s.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = s && s.rotation || 0, this._rotationAlignment = s && s.rotationAlignment || "auto", this._pitchAlignment = s && s.pitchAlignment && s.pitchAlignment !== "auto" ? s.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(s == null ? void 0 : s.opacity, s == null ? void 0 : s.opacityWhenCovered), s && s.element) this._element = s.element, this._offset = l.P.convert(s && s.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = I.create("div");
            const h = I.createNS("http://www.w3.org/2000/svg", "svg"), f = 41, m = 27;
            h.setAttributeNS(null, "display", "block"), h.setAttributeNS(null, "height", `${f}px`), h.setAttributeNS(null, "width", `${m}px`), h.setAttributeNS(null, "viewBox", `0 0 ${m} ${f}`);
            const y = I.createNS("http://www.w3.org/2000/svg", "g");
            y.setAttributeNS(null, "stroke", "none"), y.setAttributeNS(null, "stroke-width", "1"), y.setAttributeNS(null, "fill", "none"), y.setAttributeNS(null, "fill-rule", "evenodd");
            const S = I.createNS("http://www.w3.org/2000/svg", "g");
            S.setAttributeNS(null, "fill-rule", "nonzero");
            const C = I.createNS("http://www.w3.org/2000/svg", "g");
            C.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), C.setAttributeNS(null, "fill", "#000000");
            const B = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const ue of B) {
              const fe = I.createNS("http://www.w3.org/2000/svg", "ellipse");
              fe.setAttributeNS(null, "opacity", "0.04"), fe.setAttributeNS(null, "cx", "10.5"), fe.setAttributeNS(null, "cy", "5.80029008"), fe.setAttributeNS(null, "rx", ue.rx), fe.setAttributeNS(null, "ry", ue.ry), C.appendChild(fe);
            }
            const D = I.createNS("http://www.w3.org/2000/svg", "g");
            D.setAttributeNS(null, "fill", this._color);
            const z = I.createNS("http://www.w3.org/2000/svg", "path");
            z.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), D.appendChild(z);
            const N = I.createNS("http://www.w3.org/2000/svg", "g");
            N.setAttributeNS(null, "opacity", "0.25"), N.setAttributeNS(null, "fill", "#000000");
            const X = I.createNS("http://www.w3.org/2000/svg", "path");
            X.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), N.appendChild(X);
            const Z = I.createNS("http://www.w3.org/2000/svg", "g");
            Z.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Z.setAttributeNS(null, "fill", "#FFFFFF");
            const W = I.createNS("http://www.w3.org/2000/svg", "g");
            W.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const Q = I.createNS("http://www.w3.org/2000/svg", "circle");
            Q.setAttributeNS(null, "fill", "#000000"), Q.setAttributeNS(null, "opacity", "0.25"), Q.setAttributeNS(null, "cx", "5.5"), Q.setAttributeNS(null, "cy", "5.5"), Q.setAttributeNS(null, "r", "5.4999962");
            const le = I.createNS("http://www.w3.org/2000/svg", "circle");
            le.setAttributeNS(null, "fill", "#FFFFFF"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962"), W.appendChild(Q), W.appendChild(le), S.appendChild(C), S.appendChild(D), S.appendChild(N), S.appendChild(Z), S.appendChild(W), h.appendChild(S), h.setAttributeNS(null, "height", f * this._scale + "px"), h.setAttributeNS(null, "width", m * this._scale + "px"), this._element.appendChild(h), this._offset = l.P.convert(s && s.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (h) => {
            h.preventDefault();
          }), this._element.addEventListener("mousedown", (h) => {
            h.preventDefault();
          }), yu(this._element, this._anchor, "marker"), s && s.className) for (const h of s.className.split(" ")) this._element.classList.add(h);
          this._popup = null;
        }
        addTo(s) {
          return this.remove(), this._map = s, this._element.setAttribute("aria-label", s._getUIString("Marker.Title")), s.getCanvasContainer().appendChild(this._element), s.on("move", this._update), s.on("moveend", this._update), s.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), I.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(s) {
          return this._lngLat = l.N.convert(s), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(s) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), s) {
            if (!("offset" in s.options)) {
              const m = Math.abs(13.5) / Math.SQRT2;
              s.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [m, -1 * (38.1 - 13.5 + m)], "bottom-right": [-m, -1 * (38.1 - 13.5 + m)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = s, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(s) {
          return this._subpixelPositioning = s, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const s = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : s ? (s.isOpen() ? s.remove() : (s.setLngLat(this._lngLat), s.addTo(this._map)), this) : this;
        }
        _updateOpacity() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
          var h, f;
          if (!(!((h = this._map) === null || h === void 0) && h.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (s) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const m = this._map, y = m.terrain.depthAtPoint(this._pos), S = m.terrain.getElevationForLngLatZoom(this._lngLat, m.transform.tileZoom);
          if (m.transform.lngLatToCameraDepth(this._lngLat, S) - y < 6e-3) return void (this._element.style.opacity = this._opacity);
          const C = -this._offset.y / m.transform._pixelPerMeter, B = Math.sin(m.getPitch() * Math.PI / 180) * C, D = m.terrain.depthAtPoint(new l.P(this._pos.x, this._pos.y - this._offset.y)), z = m.transform.lngLatToCameraDepth(this._lngLat, S + B) - D > 6e-3;
          !((f = this._popup) === null || f === void 0) && f.isOpen() && z && this._popup.remove(), this._element.style.opacity = z ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(s) {
          return this._offset = l.P.convert(s), this._update(), this;
        }
        addClassName(s) {
          this._element.classList.add(s);
        }
        removeClassName(s) {
          this._element.classList.remove(s);
        }
        toggleClassName(s) {
          return this._element.classList.toggle(s);
        }
        setDraggable(s) {
          return this._draggable = !!s, this._map && (s ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(s) {
          return this._rotation = s || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(s) {
          return this._rotationAlignment = s || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(s) {
          return this._pitchAlignment = s && s !== "auto" ? s : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(s, h) {
          return s === void 0 && h === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), s !== void 0 && (this._opacity = s), h !== void 0 && (this._opacityWhenCovered = h), this._map && this._updateOpacity(!0), this;
        }
      }
      const Jh = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let Fc = 0, kc = !1;
      const bo = { maxWidth: 100, unit: "metric" };
      function Da(g, s, h) {
        const f = h && h.maxWidth || 100, m = g._container.clientHeight / 2, y = g.unproject([0, m]), S = g.unproject([f, m]), C = y.distanceTo(S);
        if (h && h.unit === "imperial") {
          const B = 3.2808 * C;
          B > 5280 ? Yt(s, f, B / 5280, g._getUIString("ScaleControl.Miles")) : Yt(s, f, B, g._getUIString("ScaleControl.Feet"));
        } else h && h.unit === "nautical" ? Yt(s, f, C / 1852, g._getUIString("ScaleControl.NauticalMiles")) : C >= 1e3 ? Yt(s, f, C / 1e3, g._getUIString("ScaleControl.Kilometers")) : Yt(s, f, C, g._getUIString("ScaleControl.Meters"));
      }
      function Yt(g, s, h, f) {
        const m = function(y) {
          const S = Math.pow(10, `${Math.floor(y)}`.length - 1);
          let C = y / S;
          return C = C >= 10 ? 10 : C >= 5 ? 5 : C >= 3 ? 3 : C >= 2 ? 2 : C >= 1 ? 1 : function(B) {
            const D = Math.pow(10, Math.ceil(-Math.log(B) / Math.LN10));
            return Math.round(B * D) / D;
          }(C), S * C;
        }(h);
        g.style.width = s * (m / h) + "px", g.innerHTML = `${m}&nbsp;${f}`;
      }
      const gn = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, Nc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function A(g) {
        if (g) {
          if (typeof g == "number") {
            const s = Math.round(Math.abs(g) / Math.SQRT2);
            return { center: new l.P(0, 0), top: new l.P(0, g), "top-left": new l.P(s, s), "top-right": new l.P(-s, s), bottom: new l.P(0, -g), "bottom-left": new l.P(s, -s), "bottom-right": new l.P(-s, -s), left: new l.P(g, 0), right: new l.P(-g, 0) };
          }
          if (g instanceof l.P || Array.isArray(g)) {
            const s = l.P.convert(g);
            return { center: s, top: s, "top-left": s, "top-right": s, bottom: s, "bottom-left": s, "bottom-right": s, left: s, right: s };
          }
          return { center: l.P.convert(g.center || [0, 0]), top: l.P.convert(g.top || [0, 0]), "top-left": l.P.convert(g["top-left"] || [0, 0]), "top-right": l.P.convert(g["top-right"] || [0, 0]), bottom: l.P.convert(g.bottom || [0, 0]), "bottom-left": l.P.convert(g["bottom-left"] || [0, 0]), "bottom-right": l.P.convert(g["bottom-right"] || [0, 0]), left: l.P.convert(g.left || [0, 0]), right: l.P.convert(g.right || [0, 0]) };
        }
        return A(new l.P(0, 0));
      }
      const M = _;
      c.AJAXError = l.bh, c.Evented = l.E, c.LngLat = l.N, c.MercatorCoordinate = l.Z, c.Point = l.P, c.addProtocol = l.bi, c.config = l.a, c.removeProtocol = l.bj, c.AttributionControl = ll, c.BoxZoomHandler = us, c.CanvasSource = vn, c.CooperativeGesturesHandler = Zl, c.DoubleClickZoomHandler = ia, c.DragPanHandler = Xh, c.DragRotateHandler = rh, c.EdgeInsets = ks, c.FullscreenControl = class extends l.E {
        constructor() {
          let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super(), this._onFullscreenChange = () => {
            var s;
            let h = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((s = h == null ? void 0 : h.shadowRoot) === null || s === void 0) && s.fullscreenElement; ) h = h.shadowRoot.fullscreenElement;
            h === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, g && g.container && (g.container instanceof HTMLElement ? this._container = g.container : l.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(g) {
          return this._map = g, this._container || (this._container = this._map.getContainer()), this._controlContainer = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          I.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const g = this._fullscreenButton = I.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          I.create("span", "maplibregl-ctrl-icon", g).setAttribute("aria-hidden", "true"), g.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const g = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", g), this._fullscreenButton.title = g;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new l.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new l.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, c.GeoJSONSource = Bt, c.GeolocateControl = class extends l.E {
        constructor(g) {
          super(), this._onSuccess = (s) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(s)) return this._setErrorState(), this.fire(new l.k("outofmaxbounds", s)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = s, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(s), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(s), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new l.k("geolocate", s)), this._finish();
            }
          }, this._updateCamera = (s) => {
            const h = new l.N(s.coords.longitude, s.coords.latitude), f = s.coords.accuracy, m = this._map.getBearing(), y = l.e({ bearing: m }, this.options.fitBoundsOptions), S = ne.fromLngLat(h, f);
            this._map.fitBounds(S, y, { geolocateSource: !0 });
          }, this._updateMarker = (s) => {
            if (s) {
              const h = new l.N(s.coords.longitude, s.coords.latitude);
              this._accuracyCircleMarker.setLngLat(h).addTo(this._map), this._userLocationDotMarker.setLngLat(h).addTo(this._map), this._accuracy = s.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (s) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (s.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const h = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (s.code === 3 && kc) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new l.k("error", s)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (s) => s.preventDefault()), this._geolocateButton = I.create("button", "maplibregl-ctrl-geolocate", this._container), I.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (s) => {
            if (this._map) {
              if (s === !1) {
                l.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const h = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h);
              } else {
                const h = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = I.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new bu({ element: this._dotElement }), this._circleElement = I.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new bu({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (h) => {
                h.geolocateSource || this._watchState !== "ACTIVE_LOCK" || h.originalEvent && h.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new l.k("trackuserlocationend")), this.fire(new l.k("userlocationlostfocus")));
              });
            }
          }, this.options = l.e({}, Jh, g);
        }
        onAdd(g) {
          return this._map = g, this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return l._(this, arguments, void 0, function() {
              let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return function* () {
                if (Ts !== void 0 && !s) return Ts;
                if (window.navigator.permissions === void 0) return Ts = !!window.navigator.geolocation, Ts;
                try {
                  Ts = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Ts = !!window.navigator.geolocation;
                }
                return Ts;
              }();
            });
          }().then((s) => this._finishSetupUI(s)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), I.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fc = 0, kc = !1;
        }
        _isOutOfMapMaxBounds(g) {
          const s = this._map.getMaxBounds(), h = g.coords;
          return s && (h.longitude < s.getWest() || h.longitude > s.getEast() || h.latitude < s.getSouth() || h.latitude > s.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const g = this._map.getBounds(), s = g.getSouthEast(), h = g.getNorthEast(), f = s.distanceTo(h), m = Math.ceil(this._accuracy / (f / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${m}px`, this._circleElement.style.height = `${m}px`;
        }
        trigger() {
          if (!this._setup) return l.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new l.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Fc--, kc = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new l.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new l.k("trackuserlocationstart")), this.fire(new l.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let g;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Fc++, Fc > 1 ? (g = { maximumAge: 6e5, timeout: 0 }, kc = !0) : (g = this.options.positionOptions, kc = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, g);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, c.Hash = Ra, c.ImageSource = nn, c.KeyboardHandler = Gs, c.LngLatBounds = ne, c.LogoControl = Fo, c.Map = class extends Do {
        constructor(g) {
          l.bf.mark(l.bg.create);
          const s = Object.assign(Object.assign({}, _u), g);
          if (s.minZoom != null && s.maxZoom != null && s.minZoom > s.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (s.minPitch != null && s.maxPitch != null && s.minPitch > s.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (s.minPitch != null && s.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (s.maxPitch != null && s.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new Ns(s.minZoom, s.maxZoom, s.minPitch, s.maxPitch, s.renderWorldCopies), { bearingSnap: s.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Cn(), this._controls = [], this._mapId = l.a4(), this._contextLost = (h) => {
            h.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new l.k("webglcontextlost", { originalEvent: h }));
          }, this._contextRestored = (h) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new l.k("webglcontextrestored", { originalEvent: h }));
          }, this._onMapScroll = (h) => {
            if (h.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = s.interactive, this._maxTileCacheSize = s.maxTileCacheSize, this._maxTileCacheZoomLevels = s.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = s.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = s.preserveDrawingBuffer === !0, this._antialias = s.antialias === !0, this._trackResize = s.trackResize === !0, this._bearingSnap = s.bearingSnap, this._refreshExpiredTiles = s.refreshExpiredTiles === !0, this._fadeDuration = s.fadeDuration, this._crossSourceCollisions = s.crossSourceCollisions === !0, this._collectResourceTiming = s.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, ah), s.locale), this._clickTolerance = s.clickTolerance, this._overridePixelRatio = s.pixelRatio, this._maxCanvasSize = s.maxCanvasSize, this.transformCameraUpdate = s.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = s.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = ie.addThrottleControl(() => this.isMoving()), this._requestManager = new ge(s.transformRequest), typeof s.container == "string") {
            if (this._container = document.getElementById(s.container), !this._container) throw new Error(`Container '${s.container}' not found.`);
          } else {
            if (!(s.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = s.container;
          }
          if (s.maxBounds && this.setMaxBounds(s.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let h = !1;
            const f = zs((m) => {
              this._trackResize && !this._removed && (this.resize(m), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((m) => {
              h ? f(m) : h = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new Es(this, s), this._hash = s.hash && new Ra(typeof s.hash == "string" && s.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: s.center, zoom: s.zoom, bearing: s.bearing, pitch: s.pitch }), s.bounds && (this.resize(), this.fitBounds(s.bounds, l.e({}, s.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = s.localIdeographFontFamily, this._validateStyle = s.validateStyle, s.style && this.setStyle(s.style, { localIdeographFontFamily: s.localIdeographFontFamily }), s.attributionControl && this.addControl(new ll(typeof s.attributionControl == "boolean" ? void 0 : s.attributionControl)), s.maplibreLogo && this.addControl(new Fo(), s.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (h) => {
            this._update(h.dataType === "style"), this.fire(new l.k(`${h.dataType}data`, h));
          }), this.on("dataloading", (h) => {
            this.fire(new l.k(`${h.dataType}dataloading`, h));
          }), this.on("dataabort", (h) => {
            this.fire(new l.k("sourcedataabort", h));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(g, s) {
          if (s === void 0 && (s = g.getDefaultPosition ? g.getDefaultPosition() : "top-right"), !g || !g.onAdd) return this.fire(new l.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const h = g.onAdd(this);
          this._controls.push(g);
          const f = this._controlPositions[s];
          return s.indexOf("bottom") !== -1 ? f.insertBefore(h, f.firstChild) : f.appendChild(h), this;
        }
        removeControl(g) {
          if (!g || !g.onRemove) return this.fire(new l.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const s = this._controls.indexOf(g);
          return s > -1 && this._controls.splice(s, 1), g.onRemove(this), this;
        }
        hasControl(g) {
          return this._controls.indexOf(g) > -1;
        }
        calculateCameraOptionsFromTo(g, s, h, f) {
          return f == null && this.terrain && (f = this.terrain.getElevationForLngLatZoom(h, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(g, s, h, f);
        }
        resize(g) {
          var s;
          const h = this._containerDimensions(), f = h[0], m = h[1], y = this._getClampedPixelRatio(f, m);
          if (this._resizeCanvas(f, m, y), this.painter.resize(f, m, y), this.painter.overLimit()) {
            const C = this.painter.context.gl;
            this._maxCanvasSize = [C.drawingBufferWidth, C.drawingBufferHeight];
            const B = this._getClampedPixelRatio(f, m);
            this._resizeCanvas(f, m, B), this.painter.resize(f, m, B);
          }
          this.transform.resize(f, m), (s = this._requestedCameraState) === null || s === void 0 || s.resize(f, m);
          const S = !this._moving;
          return S && (this.stop(), this.fire(new l.k("movestart", g)).fire(new l.k("move", g))), this.fire(new l.k("resize", g)), S && this.fire(new l.k("moveend", g)), this;
        }
        _getClampedPixelRatio(g, s) {
          const { 0: h, 1: f } = this._maxCanvasSize, m = this.getPixelRatio(), y = g * m, S = s * m;
          return Math.min(y > h ? h / y : 1, S > f ? f / S : 1) * m;
        }
        getPixelRatio() {
          var g;
          return (g = this._overridePixelRatio) !== null && g !== void 0 ? g : devicePixelRatio;
        }
        setPixelRatio(g) {
          this._overridePixelRatio = g, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(g) {
          return this.transform.setMaxBounds(ne.convert(g)), this._update();
        }
        setMinZoom(g) {
          if ((g = g ?? -2) >= -2 && g <= this.transform.maxZoom) return this.transform.minZoom = g, this._update(), this.getZoom() < g && this.setZoom(g), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(g) {
          if ((g = g ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = g, this._update(), this.getZoom() > g && this.setZoom(g), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(g) {
          if ((g = g ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (g >= 0 && g <= this.transform.maxPitch) return this.transform.minPitch = g, this._update(), this.getPitch() < g && this.setPitch(g), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(g) {
          if ((g = g ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (g >= this.transform.minPitch) return this.transform.maxPitch = g, this._update(), this.getPitch() > g && this.setPitch(g), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(g) {
          return this.transform.renderWorldCopies = g, this._update();
        }
        project(g) {
          return this.transform.locationPoint(l.N.convert(g), this.style && this.terrain);
        }
        unproject(g) {
          return this.transform.pointLocation(l.P.convert(g), this.terrain);
        }
        isMoving() {
          var g;
          return this._moving || ((g = this.handlers) === null || g === void 0 ? void 0 : g.isMoving());
        }
        isZooming() {
          var g;
          return this._zooming || ((g = this.handlers) === null || g === void 0 ? void 0 : g.isZooming());
        }
        isRotating() {
          var g;
          return this._rotating || ((g = this.handlers) === null || g === void 0 ? void 0 : g.isRotating());
        }
        _createDelegatedListener(g, s, h) {
          if (g === "mouseenter" || g === "mouseover") {
            let f = !1;
            return { layers: s, listener: h, delegates: { mousemove: (y) => {
              const S = s.filter((B) => this.getLayer(B)), C = S.length !== 0 ? this.queryRenderedFeatures(y.point, { layers: S }) : [];
              C.length ? f || (f = !0, h.call(this, new si(g, this, y.originalEvent, { features: C }))) : f = !1;
            }, mouseout: () => {
              f = !1;
            } } };
          }
          if (g === "mouseleave" || g === "mouseout") {
            let f = !1;
            return { layers: s, listener: h, delegates: { mousemove: (S) => {
              const C = s.filter((B) => this.getLayer(B));
              (C.length !== 0 ? this.queryRenderedFeatures(S.point, { layers: C }) : []).length ? f = !0 : f && (f = !1, h.call(this, new si(g, this, S.originalEvent)));
            }, mouseout: (S) => {
              f && (f = !1, h.call(this, new si(g, this, S.originalEvent)));
            } } };
          }
          {
            const f = (m) => {
              const y = s.filter((C) => this.getLayer(C)), S = y.length !== 0 ? this.queryRenderedFeatures(m.point, { layers: y }) : [];
              S.length && (m.features = S, h.call(this, m), delete m.features);
            };
            return { layers: s, listener: h, delegates: { [g]: f } };
          }
        }
        _saveDelegatedListener(g, s) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[g] = this._delegatedListeners[g] || [], this._delegatedListeners[g].push(s);
        }
        _removeDelegatedListener(g, s, h) {
          if (!this._delegatedListeners || !this._delegatedListeners[g]) return;
          const f = this._delegatedListeners[g];
          for (let m = 0; m < f.length; m++) {
            const y = f[m];
            if (y.listener === h && y.layers.length === s.length && y.layers.every((S) => s.includes(S))) {
              for (const S in y.delegates) this.off(S, y.delegates[S]);
              return void f.splice(m, 1);
            }
          }
        }
        on(g, s, h) {
          if (h === void 0) return super.on(g, s);
          const f = this._createDelegatedListener(g, typeof s == "string" ? [s] : s, h);
          this._saveDelegatedListener(g, f);
          for (const m in f.delegates) this.on(m, f.delegates[m]);
          return this;
        }
        once(g, s, h) {
          var f = this;
          if (h === void 0) return super.once(g, s);
          const m = typeof s == "string" ? [s] : s, y = this._createDelegatedListener(g, m, h);
          for (const S in y.delegates) {
            const C = y.delegates[S];
            y.delegates[S] = function() {
              f._removeDelegatedListener(g, m, h), C(...arguments);
            };
          }
          this._saveDelegatedListener(g, y);
          for (const S in y.delegates) this.once(S, y.delegates[S]);
          return this;
        }
        off(g, s, h) {
          return h === void 0 ? super.off(g, s) : (this._removeDelegatedListener(g, typeof s == "string" ? [s] : s, h), this);
        }
        queryRenderedFeatures(g, s) {
          if (!this.style) return [];
          let h;
          const f = g instanceof l.P || Array.isArray(g), m = f ? g : [[0, 0], [this.transform.width, this.transform.height]];
          if (s = s || (f ? {} : g) || {}, m instanceof l.P || typeof m[0] == "number") h = [l.P.convert(m)];
          else {
            const y = l.P.convert(m[0]), S = l.P.convert(m[1]);
            h = [y, new l.P(S.x, y.y), S, new l.P(y.x, S.y), y];
          }
          return this.style.queryRenderedFeatures(h, s, this.transform);
        }
        querySourceFeatures(g, s) {
          return this.style.querySourceFeatures(g, s);
        }
        setStyle(g, s) {
          return (s = l.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, s)).diff !== !1 && s.localIdeographFontFamily === this._localIdeographFontFamily && this.style && g ? (this._diffStyle(g, s), this) : (this._localIdeographFontFamily = s.localIdeographFontFamily, this._updateStyle(g, s));
        }
        setTransformRequest(g) {
          return this._requestManager.setTransformRequest(g), this;
        }
        _getUIString(g) {
          const s = this._locale[g];
          if (s == null) throw new Error(`Missing UI string '${g}'`);
          return s;
        }
        _updateStyle(g, s) {
          if (s.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(g, s));
          const h = this.style && s.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!g)), g ? (this.style = new gi(this, s || {}), this.style.setEventedParent(this, { style: this.style }), typeof g == "string" ? this.style.loadURL(g, s, h) : this.style.loadJSON(g, s, h), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new gi(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(g, s) {
          if (typeof g == "string") {
            const h = this._requestManager.transformRequest(g, "Style");
            l.h(h, new AbortController()).then((f) => {
              this._updateDiff(f.data, s);
            }).catch((f) => {
              f && this.fire(new l.j(f));
            });
          } else typeof g == "object" && this._updateDiff(g, s);
        }
        _updateDiff(g, s) {
          try {
            this.style.setState(g, s) && this._update(!0);
          } catch (h) {
            l.w(`Unable to perform style diff: ${h.message || h.error || h}.  Rebuilding the style from scratch.`), this._updateStyle(g, s);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : l.w("There is no style added to the map.");
        }
        addSource(g, s) {
          return this._lazyInitEmptyStyle(), this.style.addSource(g, s), this._update(!0);
        }
        isSourceLoaded(g) {
          const s = this.style && this.style.sourceCaches[g];
          if (s !== void 0) return s.loaded();
          this.fire(new l.j(new Error(`There is no source with ID '${g}'`)));
        }
        setTerrain(g) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), g) {
            const s = this.style.sourceCaches[g.source];
            if (!s) throw new Error(`cannot load terrain, because there exists no source with ID: ${g.source}`);
            this.terrain === null && s.reload();
            for (const h in this.style._layers) {
              const f = this.style._layers[h];
              f.type === "hillshade" && f.source === g.source && l.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new mu(this.painter, s, g), this.painter.renderToTexture = new oh(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (h) => {
              h.dataType === "style" ? this.terrain.sourceCache.freeRtt() : h.dataType === "source" && h.tile && (h.sourceId !== g.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(h.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new l.k("terrain", { terrain: g })), this;
        }
        getTerrain() {
          var g, s;
          return (s = (g = this.terrain) === null || g === void 0 ? void 0 : g.options) !== null && s !== void 0 ? s : null;
        }
        areTilesLoaded() {
          const g = this.style && this.style.sourceCaches;
          for (const s in g) {
            const h = g[s]._tiles;
            for (const f in h) {
              const m = h[f];
              if (m.state !== "loaded" && m.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(g) {
          return this.style.removeSource(g), this._update(!0);
        }
        getSource(g) {
          return this.style.getSource(g);
        }
        addImage(g, s) {
          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const { pixelRatio: f = 1, sdf: m = !1, stretchX: y, stretchY: S, content: C, textFitWidth: B, textFitHeight: D } = h;
          if (this._lazyInitEmptyStyle(), !(s instanceof HTMLImageElement || l.b(s))) {
            if (s.width === void 0 || s.height === void 0) return this.fire(new l.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: z, height: N, data: X } = s, Z = s;
              return this.style.addImage(g, { data: new l.R({ width: z, height: N }, new Uint8Array(X)), pixelRatio: f, stretchX: y, stretchY: S, content: C, textFitWidth: B, textFitHeight: D, sdf: m, version: 0, userImage: Z }), Z.onAdd && Z.onAdd(this, g), this;
            }
          }
          {
            const { width: z, height: N, data: X } = T.getImageData(s);
            this.style.addImage(g, { data: new l.R({ width: z, height: N }, X), pixelRatio: f, stretchX: y, stretchY: S, content: C, textFitWidth: B, textFitHeight: D, sdf: m, version: 0 });
          }
        }
        updateImage(g, s) {
          const h = this.style.getImage(g);
          if (!h) return this.fire(new l.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const f = s instanceof HTMLImageElement || l.b(s) ? T.getImageData(s) : s, { width: m, height: y, data: S } = f;
          if (m === void 0 || y === void 0) return this.fire(new l.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (m !== h.data.width || y !== h.data.height) return this.fire(new l.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const C = !(s instanceof HTMLImageElement || l.b(s));
          return h.data.replace(S, C), this.style.updateImage(g, h), this;
        }
        getImage(g) {
          return this.style.getImage(g);
        }
        hasImage(g) {
          return g ? !!this.style.getImage(g) : (this.fire(new l.j(new Error("Missing required image id"))), !1);
        }
        removeImage(g) {
          this.style.removeImage(g);
        }
        loadImage(g) {
          return ie.getImage(this._requestManager.transformRequest(g, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(g, s) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(g, s), this._update(!0);
        }
        moveLayer(g, s) {
          return this.style.moveLayer(g, s), this._update(!0);
        }
        removeLayer(g) {
          return this.style.removeLayer(g), this._update(!0);
        }
        getLayer(g) {
          return this.style.getLayer(g);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(g, s, h) {
          return this.style.setLayerZoomRange(g, s, h), this._update(!0);
        }
        setFilter(g, s) {
          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this.style.setFilter(g, s, h), this._update(!0);
        }
        getFilter(g) {
          return this.style.getFilter(g);
        }
        setPaintProperty(g, s, h) {
          let f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          return this.style.setPaintProperty(g, s, h, f), this._update(!0);
        }
        getPaintProperty(g, s) {
          return this.style.getPaintProperty(g, s);
        }
        setLayoutProperty(g, s, h) {
          let f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          return this.style.setLayoutProperty(g, s, h, f), this._update(!0);
        }
        getLayoutProperty(g, s) {
          return this.style.getLayoutProperty(g, s);
        }
        setGlyphs(g) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(g, s), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(g, s) {
          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this._lazyInitEmptyStyle(), this.style.addSprite(g, s, h, (f) => {
            f || this._update(!0);
          }), this;
        }
        removeSprite(g) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(g), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(g) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setSprite(g, s, (h) => {
            h || this._update(!0);
          }), this;
        }
        setLight(g) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setLight(g, s), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(g) {
          return this._lazyInitEmptyStyle(), this.style.setSky(g), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(g, s) {
          return this.style.setFeatureState(g, s), this._update();
        }
        removeFeatureState(g, s) {
          return this.style.removeFeatureState(g, s), this._update();
        }
        getFeatureState(g) {
          return this.style.getFeatureState(g);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let g = 0, s = 0;
          return this._container && (g = this._container.clientWidth || 400, s = this._container.clientHeight || 300), [g, s];
        }
        _setupContainer() {
          const g = this._container;
          g.classList.add("maplibregl-map");
          const s = this._canvasContainer = I.create("div", "maplibregl-canvas-container", g);
          this._interactive && s.classList.add("maplibregl-interactive"), this._canvas = I.create("canvas", "maplibregl-canvas", s), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const h = this._containerDimensions(), f = this._getClampedPixelRatio(h[0], h[1]);
          this._resizeCanvas(h[0], h[1], f);
          const m = this._controlContainer = I.create("div", "maplibregl-control-container", g), y = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((S) => {
            y[S] = I.create("div", `maplibregl-ctrl-${S} `, m);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(g, s, h) {
          this._canvas.width = Math.floor(h * g), this._canvas.height = Math.floor(h * s), this._canvas.style.width = `${g}px`, this._canvas.style.height = `${s}px`;
        }
        _setupPainter() {
          const g = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let s = null;
          this._canvas.addEventListener("webglcontextcreationerror", (f) => {
            s = { requestedAttributes: g }, f && (s.statusMessage = f.statusMessage, s.type = f.type);
          }, { once: !0 });
          const h = this._canvas.getContext("webgl2", g) || this._canvas.getContext("webgl", g);
          if (!h) {
            const f = "Failed to initialize WebGL";
            throw s ? (s.message = f, new Error(JSON.stringify(s))) : new Error(f);
          }
          this.painter = new mo(h, this.transform), P.testSupport(h);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(g) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || g, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(g) {
          return this._update(), this._renderTaskQueue.add(g);
        }
        _cancelRenderFrame(g) {
          this._renderTaskQueue.remove(g);
        }
        _render(g) {
          const s = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(g), this._removed) return;
          let h = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const m = this.transform.zoom, y = T.now();
            this.style.zoomHistory.update(m, y);
            const S = new l.z(m, { now: y, fadeDuration: s, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), C = S.crossFadingFactor();
            C === 1 && C === this._crossFadingFactor || (h = !0, this._crossFadingFactor = C), this.style.update(S);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, s, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: s, showPadding: this.showPadding }), this.fire(new l.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, l.bf.mark(l.bg.load), this.fire(new l.k("load"))), this.style && (this.style.hasTransitions() || h) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const f = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return f || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new l.k("idle")), !this._loaded || this._fullyLoaded || f || (this._fullyLoaded = !0, l.bf.mark(l.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var g;
          this._hash && this._hash.remove();
          for (const h of this._controls) h.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ie.removeThrottleControl(this._imageQueueHandle), (g = this._resizeObserver) === null || g === void 0 || g.disconnect();
          const s = this.painter.context.gl.getExtension("WEBGL_lose_context");
          s != null && s.loseContext && s.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), I.remove(this._canvasContainer), I.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), l.bf.clearMetrics(), this._removed = !0, this.fire(new l.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), T.frameAsync(this._frameRequest).then((g) => {
            l.bf.frame(g), this._frameRequest = null, this._render(g);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(g) {
          this._showTileBoundaries !== g && (this._showTileBoundaries = g, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(g) {
          this._showPadding !== g && (this._showPadding = g, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(g) {
          this._showCollisionBoxes !== g && (this._showCollisionBoxes = g, g ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(g) {
          this._showOverdrawInspector !== g && (this._showOverdrawInspector = g, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(g) {
          this._repaint !== g && (this._repaint = g, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(g) {
          this._vertices = g, this._update();
        }
        get version() {
          return Dc;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, c.MapMouseEvent = si, c.MapTouchEvent = Ro, c.MapWheelEvent = Ku, c.Marker = bu, c.NavigationControl = class {
        constructor(g) {
          this._updateZoomButtons = () => {
            const s = this._map.getZoom(), h = s === this._map.getMaxZoom(), f = s === this._map.getMinZoom();
            this._zoomInButton.disabled = h, this._zoomOutButton.disabled = f, this._zoomInButton.setAttribute("aria-disabled", h.toString()), this._zoomOutButton.setAttribute("aria-disabled", f.toString());
          }, this._rotateCompassArrow = () => {
            const s = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = s;
          }, this._setButtonTitle = (s, h) => {
            const f = this._map._getUIString(`NavigationControl.${h}`);
            s.title = f, s.setAttribute("aria-label", f);
          }, this.options = l.e({}, lh, g), this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (s) => s.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (s) => this._map.zoomIn({}, { originalEvent: s })), I.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (s) => this._map.zoomOut({}, { originalEvent: s })), I.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (s) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: s }) : this._map.resetNorth({}, { originalEvent: s });
          }), this._compassIcon = I.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(g) {
          return this._map = g, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Zh(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          I.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(g, s) {
          const h = I.create("button", g, this._container);
          return h.type = "button", h.addEventListener("click", s), h;
        }
      }, c.Popup = class extends l.E {
        constructor(g) {
          super(), this.remove = () => (this._content && I.remove(this._content), this._container && (I.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new l.k("close"))), this), this._onMouseUp = (s) => {
            this._update(s.point);
          }, this._onMouseMove = (s) => {
            this._update(s.point);
          }, this._onDrag = (s) => {
            this._update(s.point);
          }, this._update = (s) => {
            var h;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = I.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = I.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const C of this.options.className.split(" ")) this._container.classList.add(C);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? vr(this._lngLat, this._flatPos, this._map.transform) : (h = this._lngLat) === null || h === void 0 ? void 0 : h.wrap(), this._trackPointer && !s) return;
            const f = this._flatPos = this._pos = this._trackPointer && s ? s : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && s ? s : this._map.transform.locationPoint(this._lngLat));
            let m = this.options.anchor;
            const y = A(this.options.offset);
            if (!m) {
              const C = this._container.offsetWidth, B = this._container.offsetHeight;
              let D;
              D = f.y + y.bottom.y < B ? ["top"] : f.y > this._map.transform.height - B ? ["bottom"] : [], f.x < C / 2 ? D.push("left") : f.x > this._map.transform.width - C / 2 && D.push("right"), m = D.length === 0 ? "bottom" : D.join("-");
            }
            let S = f.add(y[m]);
            this.options.subpixelPositioning || (S = S.round()), I.setTransform(this._container, `${Yl[m]} translate(${S.x}px,${S.y}px)`), yu(this._container, m, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = l.e(Object.create(gn), g);
        }
        addTo(g) {
          return this._map && this.remove(), this._map = g, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new l.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(g) {
          return this._lngLat = l.N.convert(g), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(g) {
          return this.setDOMContent(document.createTextNode(g));
        }
        setHTML(g) {
          const s = document.createDocumentFragment(), h = document.createElement("body");
          let f;
          for (h.innerHTML = g; f = h.firstChild, f; ) s.appendChild(f);
          return this.setDOMContent(s);
        }
        getMaxWidth() {
          var g;
          return (g = this._container) === null || g === void 0 ? void 0 : g.style.maxWidth;
        }
        setMaxWidth(g) {
          return this.options.maxWidth = g, this._update(), this;
        }
        setDOMContent(g) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = I.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(g), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(g) {
          return this._container && this._container.classList.add(g), this;
        }
        removeClassName(g) {
          return this._container && this._container.classList.remove(g), this;
        }
        setOffset(g) {
          return this.options.offset = g, this._update(), this;
        }
        toggleClassName(g) {
          if (this._container) return this._container.classList.toggle(g);
        }
        setSubpixelPositioning(g) {
          this.options.subpixelPositioning = g;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = I.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const g = this._container.querySelector(Nc);
          g && g.focus();
        }
      }, c.RasterDEMTileSource = Et, c.RasterTileSource = dt, c.ScaleControl = class {
        constructor(g) {
          this._onMove = () => {
            Da(this._map, this._container, this.options);
          }, this.setUnit = (s) => {
            this.options.unit = s, Da(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, bo), g);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(g) {
          return this._map = g, this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", g.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, c.ScrollZoomHandler = Ss, c.Style = gi, c.TerrainControl = class {
        constructor(g) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = g;
        }
        onAdd(g) {
          return this._map = g, this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = I.create("button", "maplibregl-ctrl-terrain", this._container), I.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, c.TwoFingersTouchPitchHandler = $l, c.TwoFingersTouchRotateHandler = th, c.TwoFingersTouchZoomHandler = Bc, c.TwoFingersTouchZoomRotateHandler = ih, c.VectorTileSource = Qt, c.VideoSource = Sn, c.addSourceType = (g, s) => l._(void 0, void 0, void 0, function* () {
        if (Un(g)) throw new Error(`A source type called "${g}" already exists.`);
        ((h, f) => {
          On[h] = f;
        })(g, s);
      }), c.clearPrewarmedResources = function() {
        const g = He;
        g && (g.isPreloaded() && g.numActive() === 1 ? (g.release(Ce), He = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, c.getMaxParallelImageRequests = function() {
        return l.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, c.getRTLTextPluginStatus = function() {
        return Ot().getRTLTextPluginStatus();
      }, c.getVersion = function() {
        return M;
      }, c.getWorkerCount = function() {
        return Ue.workerCount;
      }, c.getWorkerUrl = function() {
        return l.a.WORKER_URL;
      }, c.importScriptInWorkers = function(g) {
        return Lt().broadcast("IS", g);
      }, c.prewarm = function() {
        Ze().acquire(Ce);
      }, c.setMaxParallelImageRequests = function(g) {
        l.a.MAX_PARALLEL_IMAGE_REQUESTS = g;
      }, c.setRTLTextPlugin = function(g, s) {
        return Ot().setRTLTextPlugin(g, s);
      }, c.setWorkerCount = function(g) {
        Ue.workerCount = g;
      }, c.setWorkerUrl = function(g) {
        l.a.WORKER_URL = g;
      };
    });
    var o = t;
    return o;
  });
})(w5);
var S5 = w5.exports;
const gs = /* @__PURE__ */ Ip(S5);
var bs;
(function(n) {
  n[n.Unknown = 0] = "Unknown", n[n.Point = 1] = "Point", n[n.LineString = 2] = "LineString", n[n.Polygon = 3] = "Polygon", n[n.MultiPoint = 4] = "MultiPoint", n[n.MultiLineString = 5] = "MultiLineString", n[n.MultiPolygon = 6] = "MultiPolygon", n[n.GeometryCollection = 7] = "GeometryCollection", n[n.CircularString = 8] = "CircularString", n[n.CompoundCurve = 9] = "CompoundCurve", n[n.CurvePolygon = 10] = "CurvePolygon", n[n.MultiCurve = 11] = "MultiCurve", n[n.MultiSurface = 12] = "MultiSurface", n[n.Curve = 13] = "Curve", n[n.Surface = 14] = "Surface", n[n.PolyhedralSurface = 15] = "PolyhedralSurface", n[n.TIN = 16] = "TIN", n[n.Triangle = 17] = "Triangle";
})(bs || (bs = {}));
const Ff = 4, kf = 4, Pp = 4, Nu = new Int32Array(2), g2 = new Float32Array(Nu.buffer), m2 = new Float64Array(Nu.buffer), dg = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var ny;
(function(n) {
  n[n.UTF8_BYTES = 1] = "UTF8_BYTES", n[n.UTF16_STRING = 2] = "UTF16_STRING";
})(ny || (ny = {}));
class iu {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(e) {
    this.bytes_ = e, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(e) {
    return new iu(new Uint8Array(e));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(e) {
    this.position_ = e;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(e) {
    return this.readUint8(e) << 24 >> 24;
  }
  readUint8(e) {
    return this.bytes_[e];
  }
  readInt16(e) {
    return this.readUint16(e) << 16 >> 16;
  }
  readUint16(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8;
  }
  readInt32(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
  }
  readUint32(e) {
    return this.readInt32(e) >>> 0;
  }
  readInt64(e) {
    return BigInt.asIntN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readUint64(e) {
    return BigInt.asUintN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readFloat32(e) {
    return Nu[0] = this.readInt32(e), g2[0];
  }
  readFloat64(e) {
    return Nu[dg ? 0 : 1] = this.readInt32(e), Nu[dg ? 1 : 0] = this.readInt32(e + 4), m2[0];
  }
  writeInt8(e, t) {
    this.bytes_[e] = t;
  }
  writeUint8(e, t) {
    this.bytes_[e] = t;
  }
  writeInt16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeUint16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeInt32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeUint32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeInt64(e, t) {
    this.writeInt32(e, Number(BigInt.asIntN(32, t))), this.writeInt32(e + 4, Number(BigInt.asIntN(32, t >> BigInt(32))));
  }
  writeUint64(e, t) {
    this.writeUint32(e, Number(BigInt.asUintN(32, t))), this.writeUint32(e + 4, Number(BigInt.asUintN(32, t >> BigInt(32))));
  }
  writeFloat32(e, t) {
    g2[0] = t, this.writeInt32(e, Nu[0]);
  }
  writeFloat64(e, t) {
    m2[0] = t, this.writeInt32(e, Nu[dg ? 0 : 1]), this.writeInt32(e + 4, Nu[dg ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Ff + kf)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let e = "";
    for (let t = 0; t < kf; t++)
      e += String.fromCharCode(this.readInt8(this.position_ + Ff + t));
    return e;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(e, t) {
    const r = e - this.readInt32(e);
    return t < this.readInt16(r) ? this.readInt16(r + t) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(e, t) {
    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(e, t) {
    e += this.readInt32(e);
    const r = this.readInt32(e);
    e += Ff;
    const i = this.bytes_.subarray(e, e + r);
    return t === ny.UTF8_BYTES ? i : this.text_decoder_.decode(i);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(e, t) {
    return typeof e == "string" ? this.__string(t) : this.__union(e, t);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(e) {
    return e + this.readInt32(e);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(e) {
    return e + this.readInt32(e) + Ff;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(e) {
    return this.readInt32(e + this.readInt32(e));
  }
  __has_identifier(e) {
    if (e.length != kf)
      throw new Error("FlatBuffers: file identifier must be length " + kf);
    for (let t = 0; t < kf; t++)
      if (e.charCodeAt(t) != this.readInt8(this.position() + Ff + t))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(e, t) {
    const r = [];
    for (let i = 0; i < t; ++i) {
      const o = e(i);
      o !== null && r.push(o);
    }
    return r;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(e, t) {
    const r = [];
    for (let i = 0; i < t; ++i) {
      const o = e(i);
      o !== null && r.push(o.unpack());
    }
    return r;
  }
}
let hI = class jo {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsGeometry(e, t) {
    return (t || new jo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsGeometry(e, t) {
    return e.setPosition(e.position() + Pp), (t || new jo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  ends(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + e * 4) : 0;
  }
  endsLength() {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  endsArray() {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  xy(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  xyLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  xyArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  z(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  zLength() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  zArray() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  m(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  mLength() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  mArray() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  t(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  tLength() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  tArray() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  tm(e) {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + e * 8) : BigInt(0);
  }
  tmLength() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  type() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readUint8(this.bb_pos + e) : bs.Unknown;
  }
  parts(e, t) {
    const r = this.bb.__offset(this.bb_pos, 18);
    return r ? (t || new jo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + e * 4), this.bb) : null;
  }
  partsLength() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startGeometry(e) {
    e.startObject(8);
  }
  static addEnds(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static createEndsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let r = t.length - 1; r >= 0; r--)
      e.addInt32(t[r]);
    return e.endVector();
  }
  static startEndsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addXy(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createXyVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let r = t.length - 1; r >= 0; r--)
      e.addFloat64(t[r]);
    return e.endVector();
  }
  static startXyVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addZ(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createZVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let r = t.length - 1; r >= 0; r--)
      e.addFloat64(t[r]);
    return e.endVector();
  }
  static startZVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addM(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static createMVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let r = t.length - 1; r >= 0; r--)
      e.addFloat64(t[r]);
    return e.endVector();
  }
  static startMVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addT(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static createTVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let r = t.length - 1; r >= 0; r--)
      e.addFloat64(t[r]);
    return e.endVector();
  }
  static startTVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addTm(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static createTmVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let r = t.length - 1; r >= 0; r--)
      e.addInt64(t[r]);
    return e.endVector();
  }
  static startTmVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addType(e, t) {
    e.addFieldInt8(6, t, bs.Unknown);
  }
  static addParts(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createPartsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let r = t.length - 1; r >= 0; r--)
      e.addOffset(t[r]);
    return e.endVector();
  }
  static startPartsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endGeometry(e) {
    return e.endObject();
  }
  static createGeometry(e, t, r, i, o, c, l, _, b) {
    return jo.startGeometry(e), jo.addEnds(e, t), jo.addXy(e, r), jo.addZ(e, i), jo.addM(e, o), jo.addT(e, c), jo.addTm(e, l), jo.addType(e, _), jo.addParts(e, b), jo.endGeometry(e);
  }
};
function ry(n, e) {
  const t = [];
  for (let r = 0; r < n.length; r += 2) {
    const i = [n[r], n[r + 1]];
    e && i.push(e[r >> 1]), t.push(i);
  }
  return t;
}
function _2(n, e, t) {
  if (!t || t.length === 0) return [ry(n, e)];
  let r = 0;
  const i = Array.from(t).map((c) => n.slice(r, r = c << 1));
  let o;
  return e && (r = 0, o = Array.from(t).map((c) => e.slice(r, r = c))), i.map((c, l) => ry(c, o ? o[l] : void 0));
}
function dI(n, e) {
  const t = n.xyArray(), r = n.zArray();
  switch (e) {
    case bs.Point: {
      const i = Array.from(t);
      return r && i.push(r[0]), i;
    }
    case bs.MultiPoint:
    case bs.LineString:
      return ry(t, r);
    case bs.MultiLineString:
      return _2(t, r, n.endsArray());
    case bs.Polygon:
      return _2(t, r, n.endsArray());
  }
}
function iy(n, e) {
  let t = e;
  if (t === bs.Unknown && (t = n.type()), t === bs.GeometryCollection) {
    const i = [];
    for (let o = 0; o < n.partsLength(); o++) {
      const c = n.parts(o), l = c.type();
      i.push(iy(c, l));
    }
    return {
      type: bs[t],
      geometries: i
    };
  } else if (t === bs.MultiPolygon) {
    const i = [];
    for (let o = 0; o < n.partsLength(); o++) i.push(iy(n.parts(o), bs.Polygon));
    return {
      type: bs[t],
      coordinates: i.map((o) => o.coordinates)
    };
  }
  const r = dI(n, t);
  return {
    type: bs[t],
    coordinates: r
  };
}
var _s;
(function(n) {
  n[n.Byte = 0] = "Byte", n[n.UByte = 1] = "UByte", n[n.Bool = 2] = "Bool", n[n.Short = 3] = "Short", n[n.UShort = 4] = "UShort", n[n.Int = 5] = "Int", n[n.UInt = 6] = "UInt", n[n.Long = 7] = "Long", n[n.ULong = 8] = "ULong", n[n.Float = 9] = "Float", n[n.Double = 10] = "Double", n[n.String = 11] = "String", n[n.Json = 12] = "Json", n[n.DateTime = 13] = "DateTime", n[n.Binary = 14] = "Binary";
})(_s || (_s = {}));
class ms {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsColumn(e, t) {
    return (t || new ms()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsColumn(e, t) {
    return e.setPosition(e.position() + Pp), (t || new ms()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  type() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readUint8(this.bb_pos + e) : _s.Byte;
  }
  title(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  width() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  precision() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  scale() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  nullable() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !0;
  }
  unique() {
    const e = this.bb.__offset(this.bb_pos, 20);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  primaryKey() {
    const e = this.bb.__offset(this.bb_pos, 22);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  metadata(e) {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startColumn(e) {
    e.startObject(11);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addType(e, t) {
    e.addFieldInt8(1, t, _s.Byte);
  }
  static addTitle(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWidth(e, t) {
    e.addFieldInt32(4, t, -1);
  }
  static addPrecision(e, t) {
    e.addFieldInt32(5, t, -1);
  }
  static addScale(e, t) {
    e.addFieldInt32(6, t, -1);
  }
  static addNullable(e, t) {
    e.addFieldInt8(7, +t, 1);
  }
  static addUnique(e, t) {
    e.addFieldInt8(8, +t, 0);
  }
  static addPrimaryKey(e, t) {
    e.addFieldInt8(9, +t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static endColumn(e) {
    const t = e.endObject();
    return e.requiredField(t, 4), t;
  }
  static createColumn(e, t, r, i, o, c, l, _, b, w, T, I) {
    return ms.startColumn(e), ms.addName(e, t), ms.addType(e, r), ms.addTitle(e, i), ms.addDescription(e, o), ms.addWidth(e, c), ms.addPrecision(e, l), ms.addScale(e, _), ms.addNullable(e, b), ms.addUnique(e, w), ms.addPrimaryKey(e, T), ms.addMetadata(e, I), ms.endColumn(e);
  }
}
class yl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsFeature(e, t) {
    return (t || new yl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsFeature(e, t) {
    return e.setPosition(e.position() + Pp), (t || new yl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  geometry(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? (e || new hI()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  properties(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
  }
  propertiesLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  propertiesArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  columns(e, t) {
    const r = this.bb.__offset(this.bb_pos, 8);
    return r ? (t || new ms()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + e * 4), this.bb) : null;
  }
  columnsLength() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startFeature(e) {
    e.startObject(3);
  }
  static addGeometry(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addProperties(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createPropertiesVector(e, t) {
    e.startVector(1, t.length, 1);
    for (let r = t.length - 1; r >= 0; r--)
      e.addInt8(t[r]);
    return e.endVector();
  }
  static startPropertiesVector(e, t) {
    e.startVector(1, t, 1);
  }
  static addColumns(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let r = t.length - 1; r >= 0; r--)
      e.addOffset(t[r]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endFeature(e) {
    return e.endObject();
  }
  static finishFeatureBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedFeatureBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
  static createFeature(e, t, r, i) {
    return yl.startFeature(e), yl.addGeometry(e, t), yl.addProperties(e, r), yl.addColumns(e, i), yl.endFeature(e);
  }
}
new TextEncoder();
const y2 = new TextDecoder();
function fI(n, e) {
  const t = {};
  if (!e || e.length === 0) return t;
  const r = n.propertiesArray();
  if (!r) return t;
  const i = new DataView(r.buffer, r.byteOffset), o = n.propertiesLength();
  let c = 0;
  for (; c < o; ) {
    const l = i.getUint16(c, !0);
    c += 2;
    const _ = e[l], b = _.name;
    switch (_.type) {
      case _s.Bool: {
        t[b] = !!i.getUint8(c), c += 1;
        break;
      }
      case _s.Byte: {
        t[b] = i.getInt8(c), c += 1;
        break;
      }
      case _s.UByte: {
        t[b] = i.getUint8(c), c += 1;
        break;
      }
      case _s.Short: {
        t[b] = i.getInt16(c, !0), c += 2;
        break;
      }
      case _s.UShort: {
        t[b] = i.getUint16(c, !0), c += 2;
        break;
      }
      case _s.Int: {
        t[b] = i.getInt32(c, !0), c += 4;
        break;
      }
      case _s.UInt: {
        t[b] = i.getUint32(c, !0), c += 4;
        break;
      }
      case _s.Long: {
        t[b] = Number(i.getBigInt64(c, !0)), c += 8;
        break;
      }
      case _s.ULong: {
        t[b] = Number(i.getBigUint64(c, !0)), c += 8;
        break;
      }
      case _s.Float: {
        t[b] = i.getFloat32(c, !0), c += 4;
        break;
      }
      case _s.Double: {
        t[b] = i.getFloat64(c, !0), c += 8;
        break;
      }
      case _s.DateTime:
      case _s.String: {
        const w = i.getUint32(c, !0);
        c += 4, t[b] = y2.decode(r.subarray(c, c + w)), c += w;
        break;
      }
      case _s.Json: {
        const w = i.getUint32(c, !0);
        c += 4;
        const T = y2.decode(r.subarray(c, c + w));
        t[b] = JSON.parse(T), c += w;
        break;
      }
      default:
        throw new Error("Unknown type " + _.type);
    }
  }
  return t;
}
function g1(n, e) {
  const t = e.columns;
  return {
    type: "Feature",
    geometry: iy(n.geometry(), e.geometryType),
    properties: fI(n, t)
  };
}
const m1 = new Uint8Array(0);
function pI() {
  return this._source.cancel();
}
function gI(n, e) {
  if (!n.length) return e;
  if (!e.length) return n;
  var t = new Uint8Array(n.length + e.length);
  return t.set(n), t.set(e, n.length), t;
}
function mI() {
  var n = this, e = n._array.subarray(n._index);
  return n._source.read().then(function(t) {
    return n._array = m1, n._index = 0, t.done ? e.length > 0 ? {
      done: !1,
      value: e
    } : {
      done: !0,
      value: void 0
    } : {
      done: !1,
      value: gI(e, t.value)
    };
  });
}
function _I(n) {
  if ((n |= 0) < 0) throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + n <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += n));
  var r = new Uint8Array(n);
  return r.set(this._array.subarray(this._index)), function i() {
    return e._source.read().then(function(o) {
      return o.done ? (e._array = m1, e._index = 0, t > 0 ? r.subarray(0, t) : null) : t + o.value.length >= n ? (e._array = o.value, e._index = n - t, r.set(o.value.subarray(0, n - t), t), r) : (r.set(o.value, t), t += o.value.length, i());
    });
  }();
}
function yI(n) {
  return typeof n.slice == "function" ? n : new Om(typeof n.read == "function" ? n : n.getReader());
}
function Om(n) {
  this._source = n, this._array = m1, this._index = 0;
}
Om.prototype.read = mI;
Om.prototype.slice = _I;
Om.prototype.cancel = pI;
class Va {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsCrs(e, t) {
    return (t || new Va()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsCrs(e, t) {
    return e.setPosition(e.position() + Pp), (t || new Va()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  org(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  code() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  wkt(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  codeString(e) {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startCrs(e) {
    e.startObject(6);
  }
  static addOrg(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addCode(e, t) {
    e.addFieldInt32(1, t, 0);
  }
  static addName(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWkt(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static addCodeString(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static endCrs(e) {
    return e.endObject();
  }
  static createCrs(e, t, r, i, o, c, l) {
    return Va.startCrs(e), Va.addOrg(e, t), Va.addCode(e, r), Va.addName(e, i), Va.addDescription(e, o), Va.addWkt(e, c), Va.addCodeString(e, l), Va.endCrs(e);
  }
}
class cm {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsHeader(e, t) {
    return (t || new cm()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsHeader(e, t) {
    return e.setPosition(e.position() + Pp), (t || new cm()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  envelope(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  envelopeLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  envelopeArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  geometryType() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.readUint8(this.bb_pos + e) : bs.Unknown;
  }
  hasZ() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasM() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasT() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasTm() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  columns(e, t) {
    const r = this.bb.__offset(this.bb_pos, 18);
    return r ? (t || new ms()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + e * 4), this.bb) : null;
  }
  columnsLength() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  featuresCount() {
    const e = this.bb.__offset(this.bb_pos, 20);
    return e ? this.bb.readUint64(this.bb_pos + e) : BigInt("0");
  }
  indexNodeSize() {
    const e = this.bb.__offset(this.bb_pos, 22);
    return e ? this.bb.readUint16(this.bb_pos + e) : 16;
  }
  crs(e) {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? (e || new Va()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  title(e) {
    const t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 28);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  metadata(e) {
    const t = this.bb.__offset(this.bb_pos, 30);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startHeader(e) {
    e.startObject(14);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addEnvelope(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createEnvelopeVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let r = t.length - 1; r >= 0; r--)
      e.addFloat64(t[r]);
    return e.endVector();
  }
  static startEnvelopeVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addGeometryType(e, t) {
    e.addFieldInt8(2, t, bs.Unknown);
  }
  static addHasZ(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static addHasM(e, t) {
    e.addFieldInt8(4, +t, 0);
  }
  static addHasT(e, t) {
    e.addFieldInt8(5, +t, 0);
  }
  static addHasTm(e, t) {
    e.addFieldInt8(6, +t, 0);
  }
  static addColumns(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let r = t.length - 1; r >= 0; r--)
      e.addOffset(t[r]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addFeaturesCount(e, t) {
    e.addFieldInt64(8, t, BigInt("0"));
  }
  static addIndexNodeSize(e, t) {
    e.addFieldInt16(9, t, 16);
  }
  static addCrs(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static addTitle(e, t) {
    e.addFieldOffset(11, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(12, t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(13, t, 0);
  }
  static endHeader(e) {
    return e.endObject();
  }
  static finishHeaderBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedHeaderBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
function _1(n) {
  const e = cm.getRootAsHeader(n), t = e.featuresCount(), r = e.indexNodeSize(), i = [];
  for (let _ = 0; _ < e.columnsLength(); _++) {
    const b = e.columns(_);
    if (!b) throw new Error("Column unexpectedly missing");
    if (!b.name()) throw new Error("Column name unexpectedly missing");
    i.push({
      name: b.name(),
      type: b.type(),
      title: b.title(),
      description: b.description(),
      width: b.width(),
      precision: b.precision(),
      scale: b.scale(),
      nullable: b.nullable(),
      unique: b.unique(),
      primary_key: b.primaryKey()
    });
  }
  const o = e.crs(), c = o ? {
    org: o.org(),
    code: o.code(),
    name: o.name(),
    description: o.description(),
    wkt: o.wkt(),
    code_string: o.codeString()
  } : null;
  return {
    geometryType: e.geometryType(),
    columns: i,
    envelope: null,
    featuresCount: Number(t),
    indexNodeSize: r,
    crs: c,
    title: e.title(),
    description: e.description(),
    metadata: e.metadata()
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var sy = function(n, e) {
  return sy = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var i in r) r.hasOwnProperty(i) && (t[i] = r[i]);
  }, sy(n, e);
};
function bI(n, e) {
  sy(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Hd(n, e, t, r) {
  function i(o) {
    return o instanceof t ? o : new t(function(c) {
      c(o);
    });
  }
  return new (t || (t = Promise))(function(o, c) {
    function l(w) {
      try {
        b(r.next(w));
      } catch (T) {
        c(T);
      }
    }
    function _(w) {
      try {
        b(r.throw(w));
      } catch (T) {
        c(T);
      }
    }
    function b(w) {
      w.done ? o(w.value) : i(w.value).then(l, _);
    }
    b((r = r.apply(n, [])).next());
  });
}
function qu(n, e) {
  var t = {
    label: 0,
    sent: function() {
      if (o[0] & 1) throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  }, r, i, o, c;
  return c = {
    next: l(0),
    throw: l(1),
    return: l(2)
  }, typeof Symbol == "function" && (c[Symbol.iterator] = function() {
    return this;
  }), c;
  function l(b) {
    return function(w) {
      return _([b, w]);
    };
  }
  function _(b) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (r = 1, i && (o = b[0] & 2 ? i.return : b[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, b[1])).done) return o;
      switch (i = 0, o && (b = [b[0] & 2, o.value]), b[0]) {
        case 0:
        case 1:
          o = b;
          break;
        case 4:
          return t.label++, {
            value: b[1],
            done: !1
          };
        case 5:
          t.label++, i = b[1], b = [0];
          continue;
        case 7:
          b = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (o = t.trys, !(o = o.length > 0 && o[o.length - 1]) && (b[0] === 6 || b[0] === 2)) {
            t = 0;
            continue;
          }
          if (b[0] === 3 && (!o || b[1] > o[0] && b[1] < o[3])) {
            t.label = b[1];
            break;
          }
          if (b[0] === 6 && t.label < o[1]) {
            t.label = o[1], o = b;
            break;
          }
          if (o && t.label < o[2]) {
            t.label = o[2], t.ops.push(b);
            break;
          }
          o[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      b = e.call(n, t);
    } catch (w) {
      b = [6, w], i = 0;
    } finally {
      r = o = 0;
    }
    if (b[0] & 5) throw b[1];
    return {
      value: b[0] ? b[1] : void 0,
      done: !0
    };
  }
}
function nf(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], r = 0;
  if (t) return t.call(n);
  if (n && typeof n.length == "number") return {
    next: function() {
      return n && r >= n.length && (n = void 0), {
        value: n && n[r++],
        done: !n
      };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function pp(n) {
  return this instanceof pp ? (this.v = n, this) : new pp(n);
}
function vI(n, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = t.apply(n, e || []), i, o = [];
  return i = {}, c("next"), c("throw"), c("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function c(I) {
    r[I] && (i[I] = function(P) {
      return new Promise(function(k, U) {
        o.push([I, P, k, U]) > 1 || l(I, P);
      });
    });
  }
  function l(I, P) {
    try {
      _(r[I](P));
    } catch (k) {
      T(o[0][3], k);
    }
  }
  function _(I) {
    I.value instanceof pp ? Promise.resolve(I.value.v).then(b, w) : T(o[0][2], I);
  }
  function b(I) {
    l("next", I);
  }
  function w(I) {
    l("throw", I);
  }
  function T(I, P) {
    I(P), o.shift(), o.length && l(o[0][0], o[0][1]);
  }
}
var E5 = (
  /** @class */
  function(n) {
    bI(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return Object.defineProperty(r, "name", {
        value: "RepeaterOverflowError",
        enumerable: !1
      }), typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(r, r.constructor.prototype) : r.__proto__ = r.constructor.prototype, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(r, r.constructor), r;
    }
    return e;
  }(Error)
);
(function() {
  function n(e) {
    if (e < 0)
      throw new RangeError("Capacity may not be less than 0");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    if (this.full)
      throw new Error("Buffer full");
    this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
(function() {
  function n(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    for (; this._q.length >= this._c; )
      this._q.shift();
    this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
(function() {
  function n(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    this._q.length < this._c && this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
function oy(n) {
  n != null && typeof n.then == "function" && n.then(dm, dm);
}
var j0 = 0, b2 = 1, Fh = 2, um = 3, ay = 4, hm = 1024, dm = function() {
};
function Dd(n) {
  var e = n.err, t = Promise.resolve(n.execution).then(function(r) {
    if (e != null)
      throw e;
    return r;
  });
  return n.err = void 0, n.execution = t.then(function() {
  }, function() {
  }), n.pending === void 0 ? t : n.pending.then(function() {
    return t;
  });
}
function Sh(n, e) {
  var t = n.state >= um;
  return Promise.resolve(e).then(function(r) {
    return !t && n.state >= ay ? Dd(n).then(function(i) {
      return {
        value: i,
        done: !0
      };
    }) : {
      value: r,
      done: t
    };
  });
}
function y1(n, e) {
  var t, r;
  if (!(n.state >= Fh))
    if (n.state = Fh, n.onnext(), n.onstop(), n.err == null && (n.err = e), n.pushes.length === 0 && (typeof n.buffer > "u" || n.buffer.empty))
      sp(n);
    else
      try {
        for (var i = nf(n.pushes), o = i.next(); !o.done; o = i.next()) {
          var c = o.value;
          c.resolve();
        }
      } catch (l) {
        t = {
          error: l
        };
      } finally {
        try {
          o && !o.done && (r = i.return) && r.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
}
function sp(n) {
  var e, t;
  if (!(n.state >= um)) {
    n.state < Fh && y1(n), n.state = um, n.buffer = void 0;
    try {
      for (var r = nf(n.nexts), i = r.next(); !i.done; i = r.next()) {
        var o = i.value, c = n.pending === void 0 ? Dd(n) : n.pending.then(function() {
          return Dd(n);
        });
        o.resolve(Sh(n, c));
      }
    } catch (l) {
      e = {
        error: l
      };
    } finally {
      try {
        i && !i.done && (t = r.return) && t.call(r);
      } finally {
        if (e) throw e.error;
      }
    }
    n.pushes = [], n.nexts = [];
  }
}
function v2(n) {
  n.state >= ay || (n.state < um && sp(n), n.state = ay);
}
function xI(n, e) {
  if (oy(e), n.pushes.length >= hm)
    throw new E5("No more than " + hm + " pending calls to push are allowed on a single repeater.");
  if (n.state >= Fh)
    return Promise.resolve(void 0);
  var t = n.pending === void 0 ? Promise.resolve(e) : n.pending.then(function() {
    return e;
  });
  t = t.catch(function(_) {
    n.state < Fh && (n.err = _), v2(n);
  });
  var r;
  if (n.nexts.length) {
    var i = n.nexts.shift();
    i.resolve(Sh(n, t)), n.nexts.length ? r = Promise.resolve(n.nexts[0].value) : r = new Promise(function(_) {
      return n.onnext = _;
    });
  } else typeof n.buffer < "u" && !n.buffer.full ? (n.buffer.add(t), r = Promise.resolve(void 0)) : r = new Promise(function(_) {
    return n.pushes.push({
      resolve: _,
      value: t
    });
  });
  var o = !0, c = {}, l = r.catch(function(_) {
    if (o)
      throw _;
  });
  return c.then = function(_, b) {
    return o = !1, Promise.prototype.then.call(r, _, b);
  }, c.catch = function(_) {
    return o = !1, Promise.prototype.catch.call(r, _);
  }, c.finally = r.finally.bind(r), n.pending = t.then(function() {
    return l;
  }).catch(function(_) {
    n.err = _, v2(n);
  }), c;
}
function wI(n) {
  var e = y1.bind(null, n), t = new Promise(function(r) {
    return n.onstop = r;
  });
  return e.then = t.then.bind(t), e.catch = t.catch.bind(t), e.finally = t.finally.bind(t), e;
}
function AI(n) {
  if (!(n.state >= b2)) {
    n.state = b2;
    var e = xI.bind(null, n), t = wI(n);
    n.execution = new Promise(function(r) {
      return r(n.executor(e, t));
    }), n.execution.catch(function() {
      return y1(n);
    });
  }
}
var fg = /* @__PURE__ */ new WeakMap(), Lp = (
  /** @class */
  function() {
    function n(e, t) {
      fg.set(this, {
        executor: e,
        buffer: t,
        err: void 0,
        state: j0,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: dm,
        onstop: dm
      });
    }
    return n.prototype.next = function(e) {
      oy(e);
      var t = fg.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      if (t.nexts.length >= hm)
        throw new E5("No more than " + hm + " pending calls to next are allowed on a single repeater.");
      if (t.state <= j0 && AI(t), t.onnext(e), typeof t.buffer < "u" && !t.buffer.empty) {
        var r = Sh(t, t.buffer.remove());
        if (t.pushes.length) {
          var i = t.pushes.shift();
          t.buffer.add(i.value), t.onnext = i.resolve;
        }
        return r;
      } else if (t.pushes.length) {
        var o = t.pushes.shift();
        return t.onnext = o.resolve, Sh(t, o.value);
      } else if (t.state >= Fh)
        return sp(t), Sh(t, Dd(t));
      return new Promise(function(c) {
        return t.nexts.push({
          resolve: c,
          value: e
        });
      });
    }, n.prototype.return = function(e) {
      oy(e);
      var t = fg.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return sp(t), t.execution = Promise.resolve(t.execution).then(function() {
        return e;
      }), Sh(t, Dd(t));
    }, n.prototype.throw = function(e) {
      var t = fg.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return t.state <= j0 || t.state >= Fh || typeof t.buffer < "u" && !t.buffer.empty ? (sp(t), t.err == null && (t.err = e), Sh(t, Dd(t))) : this.next(Promise.reject(e));
    }, n.prototype[Symbol.asyncIterator] = function() {
      return this;
    }, n.race = SI, n.merge = EI, n.zip = TI, n.latest = CI, n;
  }()
);
function Dm(n, e) {
  var t, r, i = [], o = function(b) {
    b != null && typeof b[Symbol.asyncIterator] == "function" ? i.push(b[Symbol.asyncIterator]()) : b != null && typeof b[Symbol.iterator] == "function" ? i.push(b[Symbol.iterator]()) : i.push(function() {
      return vI(this, arguments, function() {
        return qu(this, function(I) {
          switch (I.label) {
            case 0:
              return e.yieldValues ? [4, pp(b)] : [3, 3];
            case 1:
              return [4, I.sent()];
            case 2:
              I.sent(), I.label = 3;
            case 3:
              return e.returnValues ? [4, pp(b)] : [3, 5];
            case 4:
              return [2, I.sent()];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }());
  };
  try {
    for (var c = nf(n), l = c.next(); !l.done; l = c.next()) {
      var _ = l.value;
      o(_);
    }
  } catch (b) {
    t = {
      error: b
    };
  } finally {
    try {
      l && !l.done && (r = c.return) && r.call(c);
    } finally {
      if (t) throw t.error;
    }
  }
  return i;
}
function SI(n) {
  var e = this, t = Dm(n, {
    returnValues: !0
  });
  return new Lp(function(r, i) {
    return Hd(e, void 0, void 0, function() {
      var o, c, l, _, b, w;
      return qu(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return i(), [
                2
                /*return*/
              ];
            c = !1, i.then(function() {
              o(), c = !0;
            }), T.label = 1;
          case 1:
            T.trys.push([1, , 5, 7]), _ = void 0, b = 0, w = function() {
              var I, P, k, U, G, H;
              return qu(this, function($) {
                switch ($.label) {
                  case 0:
                    I = b;
                    try {
                      for (P = (G = void 0, nf(t)), k = P.next(); !k.done; k = P.next())
                        U = k.value, Promise.resolve(U.next()).then(function(ie) {
                          ie.done ? (i(), l === void 0 && (l = ie)) : b === I && (b++, o(ie));
                        }, function(ie) {
                          return i(ie);
                        });
                    } catch (ie) {
                      G = {
                        error: ie
                      };
                    } finally {
                      try {
                        k && !k.done && (H = P.return) && H.call(P);
                      } finally {
                        if (G) throw G.error;
                      }
                    }
                    return [4, new Promise(function(ie) {
                      return o = ie;
                    })];
                  case 1:
                    return _ = $.sent(), _ === void 0 ? [3, 3] : [4, r(_.value)];
                  case 2:
                    $.sent(), $.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            }, T.label = 2;
          case 2:
            return c ? [3, 4] : [5, w()];
          case 3:
            return T.sent(), [3, 2];
          case 4:
            return [2, l && l.value];
          case 5:
            return i(), [4, Promise.race(t.map(function(I) {
              return I.return && I.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function EI(n) {
  var e = this, t = Dm(n, {
    yieldValues: !0
  });
  return new Lp(function(r, i) {
    return Hd(e, void 0, void 0, function() {
      var o, c, l, _ = this;
      return qu(this, function(b) {
        switch (b.label) {
          case 0:
            if (!t.length)
              return i(), [
                2
                /*return*/
              ];
            o = [], c = !1, i.then(function() {
              var w, T;
              c = !0;
              try {
                for (var I = nf(o), P = I.next(); !P.done; P = I.next()) {
                  var k = P.value;
                  k();
                }
              } catch (U) {
                w = {
                  error: U
                };
              } finally {
                try {
                  P && !P.done && (T = I.return) && T.call(I);
                } finally {
                  if (w) throw w.error;
                }
              }
            }), b.label = 1;
          case 1:
            return b.trys.push([1, , 3, 4]), [4, Promise.all(t.map(function(w, T) {
              return Hd(_, void 0, void 0, function() {
                var I, P;
                return qu(this, function(k) {
                  switch (k.label) {
                    case 0:
                      k.trys.push([0, , 6, 9]), k.label = 1;
                    case 1:
                      return c ? [3, 5] : (Promise.resolve(w.next()).then(function(U) {
                        return o[T](U);
                      }, function(U) {
                        return i(U);
                      }), [4, new Promise(function(U) {
                        o[T] = U;
                      })]);
                    case 2:
                      return I = k.sent(), I === void 0 ? [3, 4] : I.done ? (l = I, [
                        2
                        /*return*/
                      ]) : [4, r(I.value)];
                    case 3:
                      k.sent(), k.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      return P = w.return, P ? [4, w.return()] : [3, 8];
                    case 7:
                      P = k.sent(), k.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            return b.sent(), [2, l && l.value];
          case 3:
            return i(), [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function TI(n) {
  var e = this, t = Dm(n, {
    returnValues: !0
  });
  return new Lp(function(r, i) {
    return Hd(e, void 0, void 0, function() {
      var o, c, l, _;
      return qu(this, function(b) {
        switch (b.label) {
          case 0:
            if (!t.length)
              return i(), [2, []];
            c = !1, i.then(function() {
              o(), c = !0;
            }), b.label = 1;
          case 1:
            b.trys.push([1, , 6, 8]), b.label = 2;
          case 2:
            return c ? [3, 5] : (Promise.all(t.map(function(w) {
              return w.next();
            })).then(function(w) {
              return o(w);
            }, function(w) {
              return i(w);
            }), [4, new Promise(function(w) {
              return o = w;
            })]);
          case 3:
            return l = b.sent(), l === void 0 ? [
              2
              /*return*/
            ] : (_ = l.map(function(w) {
              return w.value;
            }), l.some(function(w) {
              return w.done;
            }) ? [2, _] : [4, r(_)]);
          case 4:
            return b.sent(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return i(), [4, Promise.all(t.map(function(w) {
              return w.return && w.return();
            }))];
          case 7:
            return b.sent(), [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function CI(n) {
  var e = this, t = Dm(n, {
    yieldValues: !0,
    returnValues: !0
  });
  return new Lp(function(r, i) {
    return Hd(e, void 0, void 0, function() {
      var o, c, l, _, b, w = this;
      return qu(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return i(), [2, []];
            c = [], l = !1, i.then(function() {
              var I, P;
              o();
              try {
                for (var k = nf(c), U = k.next(); !U.done; U = k.next()) {
                  var G = U.value;
                  G();
                }
              } catch (H) {
                I = {
                  error: H
                };
              } finally {
                try {
                  U && !U.done && (P = k.return) && P.call(k);
                } finally {
                  if (I) throw I.error;
                }
              }
              l = !0;
            }), T.label = 1;
          case 1:
            return T.trys.push([1, , 5, 7]), Promise.all(t.map(function(I) {
              return I.next();
            })).then(function(I) {
              return o(I);
            }, function(I) {
              return i(I);
            }), [4, new Promise(function(I) {
              return o = I;
            })];
          case 2:
            return _ = T.sent(), _ === void 0 ? [
              2
              /*return*/
            ] : (b = _.map(function(I) {
              return I.value;
            }), _.every(function(I) {
              return I.done;
            }) ? [2, b] : [4, r(b.slice())]);
          case 3:
            return T.sent(), [4, Promise.all(t.map(function(I, P) {
              return Hd(w, void 0, void 0, function() {
                var k;
                return qu(this, function(U) {
                  switch (U.label) {
                    case 0:
                      if (_[P].done)
                        return [2, _[P].value];
                      U.label = 1;
                    case 1:
                      return l ? [3, 4] : (Promise.resolve(I.next()).then(function(G) {
                        return c[P](G);
                      }, function(G) {
                        return i(G);
                      }), [4, new Promise(function(G) {
                        return c[P] = G;
                      })]);
                    case 2:
                      return k = U.sent(), k === void 0 ? [2, _[P].value] : k.done ? [2, k.value] : (b[P] = k.value, [4, r(b.slice())]);
                    case 3:
                      return U.sent(), [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, T.sent()];
          case 5:
            return i(), [4, Promise.all(t.map(function(I) {
              return I.return && I.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
let fm = class {
  constructor() {
    this._extraRequestThreshold = 256 * 1024;
  }
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e) {
    if (e < 0)
      throw new Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e;
  }
};
fm.global = new fm();
var _l;
(function(n) {
  n[n.Debug = 0] = "Debug", n[n.Info = 1] = "Info", n[n.Warn = 2] = "Warn", n[n.Error = 3] = "Error";
})(_l || (_l = {}));
class vs {
  static debug() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    this.log(_l.Debug, ...t);
  }
  static info() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    this.log(_l.Info, ...t);
  }
  static warn() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    this.log(_l.Warn, ...t);
  }
  static error() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    this.log(_l.Error, ...t);
  }
  static log(e) {
    if (!(this.logLevel > e)) {
      for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
        r[i - 1] = arguments[i];
      switch (e) {
        case _l.Debug: {
          console.debug(...r);
          break;
        }
        case _l.Info: {
          console.info(...r);
          break;
        }
        case _l.Warn: {
          console.warn(...r);
          break;
        }
        case _l.Error: {
          console.error(...r);
          break;
        }
      }
    }
  }
}
vs.logLevel = _l.Warn;
const Eh = 8 * 4 + 8, II = 16;
function b1(n, e) {
  e = Math.min(Math.max(+e, 2), 65535);
  let t = n, r = t;
  do
    t = Math.ceil(t / e), r += t;
  while (t !== 1);
  return r * Eh;
}
function PI(n, e) {
  if (e < 2) throw new Error("Node size must be at least 2");
  if (n === 0) throw new Error("Number of items must be greater than 0");
  let t = n, r = t;
  const i = [t];
  do
    t = Math.ceil(t / e), r += t, i.push(t);
  while (t !== 1);
  const o = [];
  t = r;
  for (const l of i)
    o.push(t - l), t -= l;
  const c = [];
  for (let l = 0; l < i.length; l++) c.push([o[l], o[l] + i[l]]);
  return c;
}
async function* LI(n, e, t, r) {
  class i {
    constructor(k, U) {
      this._level = U, this.nodes = k;
    }
    level() {
      return this._level;
    }
    startNodeIdx() {
      return this.nodes[0];
    }
    endNodeIdx() {
      return this.nodes[1];
    }
    extendEndNodeIdx(k) {
      console.assert(k > this.nodes[1]), this.nodes[1] = k;
    }
    toString() {
      return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;
    }
  }
  const {
    minX: o,
    minY: c,
    maxX: l,
    maxY: _
  } = t;
  vs.info(`tree items: ${n}, nodeSize: ${e}`);
  const b = PI(n, e), w = b[0][0], I = [(() => {
    const P = [0, 1], k = b.length - 1;
    return new i(P, k);
  })()];
  for (vs.debug(`starting stream search with queue: ${I}, numItems: ${n}, nodeSize: ${e}, levelBounds: ${b}`); I.length != 0; ) {
    const P = I.shift();
    vs.debug(`popped node: ${P}, queueLength: ${I.length}`);
    const k = P.startNodeIdx(), U = k >= w, G = (() => {
      const [, ge] = b[P.level()], Se = Math.min(P.endNodeIdx() + e, ge);
      return U && Se < ge ? Se + 1 : Se;
    })(), H = G - k, $ = await r(k * Eh, H * Eh), ie = new DataView($);
    for (let ge = k; ge < G; ge++) {
      const Se = ge - k, Re = Se * Eh;
      if (l < ie.getFloat64(Re + 0, !0) || _ < ie.getFloat64(Re + 8, !0) || o > ie.getFloat64(Re + 16, !0) || c > ie.getFloat64(Re + 24, !0)) continue;
      const Le = ie.getBigUint64(Re + 32, !0);
      if (U) {
        const pe = Le, Te = (() => {
          if (ge < n - 1) {
            const et = (Se + 1) * Eh;
            return ie.getBigUint64(et + 32, !0) - pe;
          } else
            return null;
        })(), xe = ge - w;
        yield [Number(pe), xe, Number(Te)];
        continue;
      }
      const _e = Le, Ge = fm.global.extraRequestThreshold() / Eh, ke = I[I.length - 1];
      if (ke !== void 0 && ke.level() == P.level() - 1 && _e < ke.endNodeIdx() + Ge) {
        vs.debug(`Merging "nodeRange" request into existing range: ${ke}, newEndNodeIdx: ${ke.endNodeIdx()} -> ${_e}`), ke.extendEndNodeIdx(Number(_e));
        continue;
      }
      const oe = (() => {
        const pe = P.level() - 1, Te = [Number(_e), Number(_e) + 1];
        return new i(Te, pe);
      })();
      ke !== void 0 && ke.level() == oe.level() ? vs.info(`Same level, but too far away. Pushing new request for nodeIdx: ${_e} rather than merging with distant ${ke}`) : vs.info(`Pushing new level for ${oe} onto queue with nearestNodeRange: ${ke} since there's not already a range for this level.`), I.push(oe);
    }
  }
}
const zu = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]), Kc = 4;
class v1 {
  constructor(e, t, r, i, o) {
    this.headerClient = e, this.header = t, this.headerLength = r, this.indexLength = i, this.nocache = o;
  }
  static async open(e, t) {
    const i = new x2(e, t), o = (() => {
      const I = II, P = 3;
      let k = 0, U;
      for (U = 0; U < P; U++) {
        const G = I ** U * Eh;
        k += G;
      }
      return k;
    })(), c = 2024 + o;
    vs.debug(`fetching header. minReqLength: ${c} (assumedHeaderLength: 2024, assumedIndexLength: ${o})`);
    {
      const I = new Uint8Array(await i.getRange(0, 8, c, "header"));
      if (!I.subarray(0, 3).every((P, k) => zu[k] === P))
        throw vs.error(`bytes: ${I} != ${zu}`), new Error("Not a FlatGeobuf file");
      vs.debug("magic bytes look good");
    }
    let l;
    {
      const I = await i.getRange(8, 4, c, "header");
      l = new DataView(I).getUint32(0, !0);
      const P = 1048576 * 10;
      if (l > P || l < 8)
        throw new Error("Invalid header size");
      vs.debug(`headerLength: ${l}`);
    }
    const _ = await i.getRange(12, l, c, "header"), b = new iu(new Uint8Array(_)), w = _1(b), T = b1(w.featuresCount, w.indexNodeSize);
    return vs.debug("completed: opening http reader"), new v1(i, w, l, T, t);
  }
  async *selectBbox(e) {
    const t = this.lengthBeforeTree(), r = this.headerClient, i = async function(_, b) {
      return r.getRange(t + _, b, 0, "index");
    }, o = [];
    let c = [];
    for await (const _ of LI(this.header.featuresCount, this.header.indexNodeSize, e, i)) {
      const [b, ,] = _;
      let [, , w] = _;
      if (w || (vs.info("final feature"), w = 4), c.length == 0) {
        c.push([b, w]);
        continue;
      }
      const T = c[c.length - 1], I = b - (T[0] + T[1]);
      I > fm.global.extraRequestThreshold() && (vs.info(`Pushing new feature batch, since gap ${I} was too large`), o.push(c), c = []), c.push([b, w]);
    }
    this.headerClient.logUsage("header+index"), c.length > 0 && o.push(c);
    const l = o.flatMap((_) => this.readFeatureBatch(_, this.nocache));
    yield* Lp.merge(l);
  }
  lengthBeforeTree() {
    return zu.length + Kc + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  buildFeatureClient(e) {
    return new x2(this.headerClient.httpClient, e);
  }
  async *readFeatureBatch(e, t) {
    const [r] = e[0], [i, o] = e[e.length - 1], c = r, _ = i + o - c, b = this.buildFeatureClient(t);
    let w = _;
    for (const [T] of e)
      yield await this.readFeature(b, T, w), w = 0;
    b.logUsage("feature");
  }
  async readFeature(e, t, r) {
    const i = t + this.lengthBeforeFeatures();
    let o;
    {
      const w = await e.getRange(i, 4, r, "feature length");
      o = new DataView(w).getUint32(0, !0);
    }
    const c = await e.getRange(i + 4, o, r, "feature data"), l = new Uint8Array(c), _ = new Uint8Array(o + Kc);
    _.set(l, Kc);
    const b = new iu(_);
    return b.setPosition(Kc), yl.getRootAsFeature(b);
  }
}
class x2 {
  constructor(e, t) {
    if (this.bytesEverUsed = 0, this.bytesEverFetched = 0, this.buffer = new ArrayBuffer(0), this.head = 0, typeof e == "string")
      this.httpClient = new w2(e, t);
    else if (e instanceof w2)
      this.httpClient = e;
    else
      throw new Error("Unknown source ");
  }
  async getRange(e, t, r, i) {
    this.bytesEverUsed += t;
    const o = e - this.head, c = o + t;
    if (o >= 0 && c <= this.buffer.byteLength)
      return this.buffer.slice(o, c);
    const l = Math.max(t, r);
    return this.bytesEverFetched += l, vs.debug(`requesting for new Range: ${e}-${e + l - 1}`), this.buffer = await this.httpClient.getRange(e, l, i), this.head = e, this.buffer.slice(0, t);
  }
  logUsage(e) {
    const t = e.split(" ")[0], r = this.bytesEverUsed, i = this.bytesEverFetched, o = (100 * r / i).toFixed(2);
    vs.info(`${t} bytes used/requested: ${r} / ${i} = ${o}%`);
  }
}
class w2 {
  constructor(e, t) {
    this.requestsEverMade = 0, this.bytesEverRequested = 0, this.url = e, this.nocache = t;
  }
  async getRange(e, t, r) {
    this.requestsEverMade += 1, this.bytesEverRequested += t;
    const i = `bytes=${e}-${e + t - 1}`;
    vs.info(`request: #${this.requestsEverMade}, purpose: ${r}), bytes: (this_request: ${t}, ever: ${this.bytesEverRequested}), Range: ${i}`);
    const o = {
      Range: i
    };
    return this.nocache && (o["Cache-Control"] = "no-cache, no-store"), (await fetch(this.url, {
      headers: o
    })).arrayBuffer();
  }
}
function MI(n, e, t) {
  if (!n.subarray(0, 3).every((w, T) => zu[T] === w)) throw new Error("Not a FlatGeobuf file");
  const r = new iu(n), i = r.readUint32(zu.length);
  r.setPosition(zu.length + Kc);
  const o = _1(r);
  let c = zu.length + Kc + i;
  const {
    indexNodeSize: l,
    featuresCount: _
  } = o;
  l > 0 && (c += b1(_, l));
  const b = [];
  for (; c < r.capacity(); ) {
    const w = r.readUint32(c);
    r.setPosition(c + Kc);
    const T = yl.getRootAsFeature(r);
    b.push(e(T, o)), c += Kc + w;
  }
  return b;
}
async function* BI(n, e, t) {
  const r = yI(n), i = async (I) => await r.slice(I);
  let o = new Uint8Array(await i(8));
  if (!o.subarray(0, 3).every((I, P) => zu[P] === I)) throw new Error("Not a FlatGeobuf file");
  o = new Uint8Array(await i(4));
  let c = new iu(o);
  const l = c.readUint32(0);
  o = new Uint8Array(await i(l)), c = new iu(o);
  const _ = _1(c), {
    indexNodeSize: b,
    featuresCount: w
  } = _;
  if (b > 0) {
    const I = b1(w, b);
    await i(I);
  }
  let T;
  for (; T = await OI(i, _, e); ) yield T;
}
function RI(n, e, t, r) {
  try {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    return async function* () {
      const o = await v1.open(n, i);
      vs.debug("opened reader");
      for await (const c of o.selectBbox(e))
        yield t(c, o.header);
    }();
  } catch (i) {
    return Promise.reject(i);
  }
}
async function OI(n, e, t) {
  let r = new Uint8Array(await n(4, "feature length"));
  if (r.byteLength === 0) return;
  let i = new iu(r);
  const o = i.readUint32(0);
  r = new Uint8Array(await n(o, "feature data"));
  const c = new Uint8Array(o + 4);
  c.set(r, 4), i = new iu(c), i.setPosition(Kc);
  const l = yl.getRootAsFeature(i);
  return t(l, e);
}
function DI(n, e) {
  return {
    type: "FeatureCollection",
    features: MI(n, g1)
  };
}
function FI(n, e) {
  return BI(n, g1);
}
function kI(n, e, t) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return RI(n, e, g1, t, r);
}
function A2(n, e, t) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return n instanceof Uint8Array ? DI(n) : n instanceof ReadableStream ? FI(n) : kI(n, e, t, r);
}
class NI {
  constructor() {
    this._bearing = 0, this._pitch = 60, this._minpitchzoom = null;
  }
  onAdd(e) {
    this._map = e;
    let t = this;
    return this._btn = document.createElement("button"), this._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d", this._btn.id = "bt3D", this._btn.type = "button", this._btn["aria-label"] = "Vista 3D", this._btn.onclick = function() {
      if (t._btn.className.indexOf("3d") != -1) {
        let b = {
          pitch: t._pitch,
          bearing: t._bearing
        };
        t._minpitchzoom && e.getZoom() > t._minpitchzoom && (b.zoom = t._minpitchzoom);
        var r = 0, i = 38.5, o = 6, c = 62.33, {
          longitude: l,
          latitude: _
        } = e.getCenter();
        e.getZoom() < 10 ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }) : l >= r && l <= o && _ >= i && _ <= c ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.2
        }) : e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }), e.easeTo(b), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d";
      } else
        e.setTerrain(null), e.easeTo({
          pitch: 0,
          bearing: 0
        }), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-3d";
    }, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl maplibregl-ctrl-group", this._container.title = "Vista 3D", this._container.appendChild(this._btn), this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function gp(n) {
  "@babel/helpers - typeof";
  return gp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, gp(n);
}
function zI(n, e) {
  if (gp(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (gp(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function UI(n) {
  var e = zI(n, "string");
  return gp(e) == "symbol" ? e : e + "";
}
function V(n, e, t) {
  return e = UI(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Zr(n, e) {
  if (!n)
    throw new Error(e || "loader assertion failed.");
}
const Fm = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser), S2 = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
S2 && parseFloat(S2[1]);
const jI = "3.4.15";
function wc(n, e) {
  if (!n)
    throw new Error(e || "loaders.gl assertion failed.");
}
const G0 = {
  self: typeof self < "u" && self,
  window: typeof window < "u" && window,
  global: typeof global < "u" && global,
  document: typeof document < "u" && document
}, GI = G0.global || G0.self || G0.window || {}, nu = typeof process != "object" || String(process) !== "[object process]" || process.browser, x1 = typeof importScripts == "function", VI = typeof window < "u" && typeof window.orientation < "u", E2 = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
E2 && parseFloat(E2[1]);
class qI {
  constructor(e, t) {
    V(this, "name", void 0), V(this, "workerThread", void 0), V(this, "isRunning", !0), V(this, "result", void 0), V(this, "_resolve", () => {
    }), V(this, "_reject", () => {
    }), this.name = e, this.workerThread = t, this.result = new Promise((r, i) => {
      this._resolve = r, this._reject = i;
    });
  }
  postMessage(e, t) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      type: e,
      payload: t
    });
  }
  done(e) {
    wc(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  error(e) {
    wc(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
let V0 = class {
  terminate() {
  }
};
const q0 = /* @__PURE__ */ new Map();
function HI(n) {
  wc(n.source && !n.url || !n.source && n.url);
  let e = q0.get(n.source || n.url);
  return e || (n.url && (e = WI(n.url), q0.set(n.url, e)), n.source && (e = T5(n.source), q0.set(n.source, e))), wc(e), e;
}
function WI(n) {
  if (!n.startsWith("http"))
    return n;
  const e = XI(n);
  return T5(e);
}
function T5(n) {
  const e = new Blob([n], {
    type: "application/javascript"
  });
  return URL.createObjectURL(e);
}
function XI(n) {
  return `try {
  importScripts('`.concat(n, `');
} catch (error) {
  console.error(error);
  throw error;
}`);
}
function C5(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, t = arguments.length > 2 ? arguments[2] : void 0;
  const r = t || /* @__PURE__ */ new Set();
  if (n) {
    if (T2(n))
      r.add(n);
    else if (T2(n.buffer))
      r.add(n.buffer);
    else if (!ArrayBuffer.isView(n)) {
      if (e && typeof n == "object")
        for (const i in n)
          C5(n[i], e, r);
    }
  }
  return t === void 0 ? Array.from(r) : [];
}
function T2(n) {
  return n ? n instanceof ArrayBuffer || typeof MessagePort < "u" && n instanceof MessagePort || typeof ImageBitmap < "u" && n instanceof ImageBitmap || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas : !1;
}
const H0 = () => {
};
class ly {
  static isSupported() {
    return typeof Worker < "u" && nu || typeof V0 < "u" && !nu;
  }
  constructor(e) {
    V(this, "name", void 0), V(this, "source", void 0), V(this, "url", void 0), V(this, "terminated", !1), V(this, "worker", void 0), V(this, "onMessage", void 0), V(this, "onError", void 0), V(this, "_loadableURL", "");
    const {
      name: t,
      source: r,
      url: i
    } = e;
    wc(r || i), this.name = t, this.source = r, this.url = i, this.onMessage = H0, this.onError = (o) => console.log(o), this.worker = nu ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = H0, this.onError = H0, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  postMessage(e, t) {
    t = t || C5(e), this.worker.postMessage(e, t);
  }
  _getErrorFromErrorEvent(e) {
    let t = "Failed to load ";
    return t += "worker ".concat(this.name, " from ").concat(this.url, ". "), e.message && (t += "".concat(e.message, " in ")), e.lineno && (t += ":".concat(e.lineno, ":").concat(e.colno)), new Error(t);
  }
  _createBrowserWorker() {
    this._loadableURL = HI({
      source: this.source,
      url: this.url
    });
    const e = new Worker(this._loadableURL, {
      name: this.name
    });
    return e.onmessage = (t) => {
      t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
    }, e.onerror = (t) => {
      this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
    }, e.onmessageerror = (t) => console.error(t), e;
  }
  _createNodeWorker() {
    let e;
    if (this.url) {
      const r = this.url.includes(":/") || this.url.startsWith("/") ? this.url : "./".concat(this.url);
      e = new V0(r, {
        eval: !1
      });
    } else if (this.source)
      e = new V0(this.source, {
        eval: !0
      });
    else
      throw new Error("no worker");
    return e.on("message", (t) => {
      this.onMessage(t);
    }), e.on("error", (t) => {
      this.onError(t);
    }), e.on("exit", (t) => {
    }), e;
  }
}
class $I {
  static isSupported() {
    return ly.isSupported();
  }
  constructor(e) {
    V(this, "name", "unnamed"), V(this, "source", void 0), V(this, "url", void 0), V(this, "maxConcurrency", 1), V(this, "maxMobileConcurrency", 1), V(this, "onDebug", () => {
    }), V(this, "reuseWorkers", !0), V(this, "props", {}), V(this, "jobQueue", []), V(this, "idleQueue", []), V(this, "count", 0), V(this, "isDestroyed", !1), this.source = e.source, this.url = e.url, this.setProps(e);
  }
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (o, c, l) => o.done(l), r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (o, c) => o.error(c);
    const i = new Promise((o) => (this.jobQueue.push({
      name: e,
      onMessage: t,
      onError: r,
      onStart: o
    }), this));
    return this._startQueuedJob(), await i;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const t = this.jobQueue.shift();
    if (t) {
      this.onDebug({
        message: "Starting job",
        name: t.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const r = new qI(t.name, e);
      e.onMessage = (i) => t.onMessage(r, i.type, i.payload), e.onError = (i) => t.onError(r, i), t.onStart(r);
      try {
        await r.result;
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  returnWorkerToQueue(e) {
    this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new ly({
        name: e,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return VI ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const ZI = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class Jc {
  static isSupported() {
    return ly.isSupported();
  }
  static getWorkerFarm() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Jc._workerFarm = Jc._workerFarm || new Jc({}), Jc._workerFarm.setProps(e), Jc._workerFarm;
  }
  constructor(e) {
    V(this, "props", void 0), V(this, "workerPools", /* @__PURE__ */ new Map()), this.props = {
      ...ZI
    }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    };
    for (const t of this.workerPools.values())
      t.setProps(this._getWorkerPoolProps());
  }
  getWorkerPool(e) {
    const {
      name: t,
      source: r,
      url: i
    } = e;
    let o = this.workerPools.get(t);
    return o || (o = new $I({
      name: t,
      source: r,
      url: i
    }), o.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, o)), o;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
V(Jc, "_workerFarm", void 0);
const JI = "latest";
function YI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e[n.id] || {}, r = "".concat(n.id, "-worker.js");
  let i = t.workerUrl;
  if (!i && n.id === "compression" && (i = e.workerUrl), e._workerType === "test" && (i = "modules/".concat(n.module, "/dist/").concat(r)), !i) {
    let o = n.version;
    o === "latest" && (o = JI);
    const c = o ? "@".concat(o) : "";
    i = "https://unpkg.com/@loaders.gl/".concat(n.module).concat(c, "/dist/").concat(r);
  }
  return wc(i), i;
}
function KI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : jI;
  wc(n, "no worker provided");
  const t = n.version;
  return !(!e || !t);
}
const QI = null, eP = null, cy = null, I5 = null, tP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  readFileAsArrayBuffer: QI,
  readFileAsText: eP,
  requireFromFile: cy,
  requireFromString: I5
}, Symbol.toStringTag, { value: "Module" })), nP = "3.4.15", W0 = {};
async function Bh(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return e && (n = rP(n, e, t)), W0[n] = W0[n] || iP(n), await W0[n];
}
function rP(n, e, t) {
  if (n.startsWith("http"))
    return n;
  const r = t.modules || {};
  return r[n] ? r[n] : nu ? t.CDN ? (wc(t.CDN.startsWith("http")), "".concat(t.CDN, "/").concat(e, "@").concat(nP, "/dist/libs/").concat(n)) : x1 ? "../src/libs/".concat(n) : "modules/".concat(e, "/src/libs/").concat(n) : "modules/".concat(e, "/dist/libs/").concat(n);
}
async function iP(n) {
  if (n.endsWith("wasm"))
    return await (await fetch(n)).arrayBuffer();
  if (!nu)
    try {
      return tP && cy && await cy(n);
    } catch {
      return null;
    }
  if (x1)
    return importScripts(n);
  const t = await (await fetch(n)).text();
  return sP(t, n);
}
function sP(n, e) {
  if (!nu)
    return I5;
  if (x1)
    return eval.call(GI, n), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(n));
  } catch {
    t.text = n;
  }
  return document.body.appendChild(t), null;
}
function oP(n, e) {
  return !Jc.isSupported() || !nu && !(e != null && e._nodeWorkers) ? !1 : n.worker && (e == null ? void 0 : e.worker);
}
async function aP(n, e, t, r, i) {
  const o = n.id, c = YI(n, t), _ = Jc.getWorkerFarm(t).getWorkerPool({
    name: o,
    url: c
  });
  t = JSON.parse(JSON.stringify(t)), r = JSON.parse(JSON.stringify(r || {}));
  const b = await _.startJob("process-on-worker", lP.bind(null, i));
  return b.postMessage("process", {
    input: e,
    options: t,
    context: r
  }), await (await b.result).result;
}
async function lP(n, e, t, r) {
  switch (t) {
    case "done":
      e.done(r);
      break;
    case "error":
      e.error(new Error(r.error));
      break;
    case "process":
      const {
        id: i,
        input: o,
        options: c
      } = r;
      try {
        const l = await n(o, c);
        e.postMessage("done", {
          id: i,
          result: l
        });
      } catch (l) {
        const _ = l instanceof Error ? l.message : "unknown error";
        e.postMessage("error", {
          id: i,
          error: _
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(t));
  }
}
function cP(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? C2(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? C2(n, 0, e) : "";
}
function C2(n, e, t) {
  if (n.byteLength <= e + t)
    return "";
  const r = new DataView(n);
  let i = "";
  for (let o = 0; o < t; o++)
    i += String.fromCharCode(r.getUint8(e + o));
  return i;
}
function uP(n) {
  try {
    return JSON.parse(n);
  } catch {
    throw new Error('Failed to parse JSON from data starting with "'.concat(cP(n), '"'));
  }
}
function hP(n, e, t) {
  if (t = t || n.byteLength, n.byteLength < t || e.byteLength < t)
    return !1;
  const r = new Uint8Array(n), i = new Uint8Array(e);
  for (let o = 0; o < r.length; ++o)
    if (r[o] !== i[o])
      return !1;
  return !0;
}
function dP() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  const r = e.map((l) => l instanceof ArrayBuffer ? new Uint8Array(l) : l), i = r.reduce((l, _) => l + _.byteLength, 0), o = new Uint8Array(i);
  let c = 0;
  for (const l of r)
    o.set(l, c), c += l.byteLength;
  return o.buffer;
}
function w1(n, e, t) {
  const r = t !== void 0 ? new Uint8Array(n).subarray(e, e + t) : new Uint8Array(n).subarray(e);
  return new Uint8Array(r).buffer;
}
function Mp(n, e) {
  return Zr(n >= 0), Zr(e > 0), n + (e - 1) & ~(e - 1);
}
function fP(n, e, t) {
  let r;
  if (n instanceof ArrayBuffer)
    r = new Uint8Array(n);
  else {
    const i = n.byteOffset, o = n.byteLength;
    r = new Uint8Array(n.buffer || n.arrayBuffer, i, o);
  }
  return e.set(r, t), t + Mp(r.byteLength, 4);
}
async function pP(n) {
  const e = [];
  for await (const t of n)
    e.push(t);
  return dP(...e);
}
function I2() {
  let n;
  if (typeof window < "u" && window.performance)
    n = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    n = e[0] * 1e3 + e[1] / 1e6;
  } else
    n = Date.now();
  return n;
}
class P2 {
  constructor(e, t) {
    V(this, "name", void 0), V(this, "type", void 0), V(this, "sampleSize", 1), V(this, "time", void 0), V(this, "count", void 0), V(this, "samples", void 0), V(this, "lastTiming", void 0), V(this, "lastSampleTime", void 0), V(this, "lastSampleCount", void 0), V(this, "_count", 0), V(this, "_time", 0), V(this, "_samples", 0), V(this, "_startTime", 0), V(this, "_timerPending", !1), this.name = e, this.type = t, this.reset();
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  incrementCount() {
    return this.addCount(1), this;
  }
  decrementCount() {
    return this.subtractCount(1), this;
  }
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  timeStart() {
    return this._startTime = I2(), this._timerPending = !0, this;
  }
  timeEnd() {
    return this._timerPending ? (this.addTime(I2() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class Bp {
  constructor(e) {
    V(this, "id", void 0), V(this, "stats", {}), this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  get(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
    return this._getOrCreate({
      name: e,
      type: t
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const e in this.stats)
      this.stats[e].reset();
    return this;
  }
  forEach(e) {
    for (const t in this.stats)
      e(this.stats[t]);
  }
  getTable() {
    const e = {};
    return this.forEach((t) => {
      e[t.name] = {
        time: t.time || 0,
        count: t.count || 0,
        average: t.getAverageTime() || 0,
        hz: t.getHz() || 0
      };
    }), e;
  }
  _initializeStats() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((t) => this._getOrCreate(t));
  }
  _getOrCreate(e) {
    if (!e || !e.name)
      return null;
    const {
      name: t,
      type: r
    } = e;
    return this.stats[t] || (e instanceof P2 ? this.stats[t] = e : this.stats[t] = new P2(t, r)), this.stats[t];
  }
}
const gP = "Queued Requests", mP = "Active Requests", _P = "Cancelled Requests", yP = "Queued Requests Ever", bP = "Active Requests Ever", vP = {
  id: "request-scheduler",
  throttleRequests: !0,
  maxRequests: 6
};
class xP {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    V(this, "props", void 0), V(this, "stats", void 0), V(this, "activeRequestCount", 0), V(this, "requestQueue", []), V(this, "requestMap", /* @__PURE__ */ new Map()), V(this, "deferredUpdate", null), this.props = {
      ...vP,
      ...e
    }, this.stats = new Bp({
      id: this.props.id
    }), this.stats.get(gP), this.stats.get(mP), this.stats.get(_P), this.stats.get(yP), this.stats.get(bP);
  }
  scheduleRequest(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
    if (!this.props.throttleRequests)
      return Promise.resolve({
        done: () => {
        }
      });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const r = {
      handle: e,
      priority: 0,
      getPriority: t
    }, i = new Promise((o) => (r.resolve = o, r));
    return this.requestQueue.push(r), this.requestMap.set(e, i), this._issueNewRequests(), i;
  }
  _issueRequest(e) {
    const {
      handle: t,
      resolve: r
    } = e;
    let i = !1;
    const o = () => {
      i || (i = !0, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, r ? r({
      done: o
    }) : Promise.resolve({
      done: o
    });
  }
  _issueNewRequests() {
    this.deferredUpdate || (this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));
  }
  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let t = 0; t < e; ++t) {
        const r = this.requestQueue.shift();
        r && this._issueRequest(r);
      }
    }
  }
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let t = 0; t < e.length; ++t) {
      const r = e[t];
      this._updateRequest(r) || (e.splice(t, 1), this.requestMap.delete(r.handle), t--);
    }
    e.sort((t, r) => t.priority - r.priority);
  }
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let wP = "";
const L2 = {};
function AP(n) {
  for (const e in L2)
    if (n.startsWith(e)) {
      const t = L2[e];
      n = n.replace(e, t);
    }
  return !n.startsWith("http://") && !n.startsWith("https://") && (n = "".concat(wP).concat(n)), n;
}
function SP(n) {
  return n && typeof n == "object" && n.isBuffer;
}
function P5(n) {
  if (SP(n))
    return n;
  if (n instanceof ArrayBuffer)
    return n;
  if (ArrayBuffer.isView(n))
    return n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
  if (typeof n == "string") {
    const e = n;
    return new TextEncoder().encode(e).buffer;
  }
  if (n && typeof n == "object" && n._toArrayBuffer)
    return n._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function L5(n) {
  const e = n ? n.lastIndexOf("/") : -1;
  return e >= 0 ? n.substr(e + 1) : "";
}
function A1(n) {
  const e = n ? n.lastIndexOf("/") : -1;
  return e >= 0 ? n.substr(0, e) : "";
}
const EP = (n) => typeof n == "boolean", op = (n) => typeof n == "function", Rp = (n) => n !== null && typeof n == "object", M2 = (n) => Rp(n) && n.constructor === {}.constructor, TP = (n) => n && typeof n[Symbol.iterator] == "function", CP = (n) => n && typeof n[Symbol.asyncIterator] == "function", jh = (n) => typeof Response < "u" && n instanceof Response || n && n.arrayBuffer && n.text && n.json, Gh = (n) => typeof Blob < "u" && n instanceof Blob, IP = (n) => n && typeof n == "object" && n.isBuffer, PP = (n) => typeof ReadableStream < "u" && n instanceof ReadableStream || Rp(n) && op(n.tee) && op(n.cancel) && op(n.getReader), LP = (n) => Rp(n) && op(n.read) && op(n.pipe) && EP(n.readable), M5 = (n) => PP(n) || LP(n), MP = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, BP = /^([-\w.]+\/[-\w.+]+)/;
function RP(n) {
  const e = BP.exec(n);
  return e ? e[1] : n;
}
function B2(n) {
  const e = MP.exec(n);
  return e ? e[1] : "";
}
const B5 = /\?.*/;
function OP(n) {
  const e = n.match(B5);
  return e && e[0];
}
function S1(n) {
  return n.replace(B5, "");
}
function km(n) {
  return jh(n) ? n.url : Gh(n) ? n.name || "" : typeof n == "string" ? n : "";
}
function E1(n) {
  if (jh(n)) {
    const e = n, t = e.headers.get("content-type") || "", r = S1(e.url);
    return RP(t) || B2(r);
  }
  return Gh(n) ? n.type || "" : typeof n == "string" ? B2(n) : "";
}
function DP(n) {
  return jh(n) ? n.headers["content-length"] || -1 : Gh(n) ? n.size : typeof n == "string" ? n.length : n instanceof ArrayBuffer || ArrayBuffer.isView(n) ? n.byteLength : -1;
}
async function R5(n) {
  if (jh(n))
    return n;
  const e = {}, t = DP(n);
  t >= 0 && (e["content-length"] = String(t));
  const r = km(n), i = E1(n);
  i && (e["content-type"] = i);
  const o = await NP(n);
  o && (e["x-first-bytes"] = o), typeof n == "string" && (n = new TextEncoder().encode(n));
  const c = new Response(n, {
    headers: e
  });
  return Object.defineProperty(c, "url", {
    value: r
  }), c;
}
async function FP(n) {
  if (!n.ok) {
    const e = await kP(n);
    throw new Error(e);
  }
}
async function kP(n) {
  let e = "Failed to fetch resource ".concat(n.url, " (").concat(n.status, "): ");
  try {
    const t = n.headers.get("Content-Type");
    let r = n.statusText;
    t.includes("application/json") && (r += " ".concat(await n.text())), e += r, e = e.length > 60 ? "".concat(e.slice(0, 60), "...") : e;
  } catch {
  }
  return e;
}
async function NP(n) {
  if (typeof n == "string")
    return "data:,".concat(n.slice(0, 5));
  if (n instanceof Blob) {
    const t = n.slice(0, 5);
    return await new Promise((r) => {
      const i = new FileReader();
      i.onload = (o) => {
        var c;
        return r(o == null || (c = o.target) === null || c === void 0 ? void 0 : c.result);
      }, i.readAsDataURL(t);
    });
  }
  if (n instanceof ArrayBuffer) {
    const t = n.slice(0, 5), r = zP(t);
    return "data:base64,".concat(r);
  }
  return null;
}
function zP(n) {
  let e = "";
  const t = new Uint8Array(n);
  for (let r = 0; r < t.byteLength; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
async function R2(n, e) {
  if (typeof n == "string") {
    n = AP(n);
    let t = e;
    return e != null && e.fetch && typeof (e == null ? void 0 : e.fetch) != "function" && (t = e.fetch), await fetch(n, t);
  }
  return await R5(n);
}
function O5(n) {
  if (typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && process.versions.electron)
    return !0;
  const t = typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent;
  return !!(t && t.indexOf("Electron") >= 0);
}
function lu() {
  return !(typeof process == "object" && String(process) === "[object process]" && !process.browser) || O5();
}
const qg = {
  self: typeof self < "u" && self,
  window: typeof window < "u" && window,
  global: typeof global < "u" && global,
  document: typeof document < "u" && document,
  process: typeof process == "object" && process
}, pg = qg.window || qg.self || qg.global, Nf = qg.process || {}, D5 = typeof __VERSION__ < "u" ? __VERSION__ : "untranspiled source";
lu();
const X0 = globalThis;
function F5(n) {
  if (!lu())
    return "Node";
  if (O5())
    return "Electron";
  const t = (typeof navigator < "u" ? navigator : {}).userAgent || "";
  if (t.indexOf("Edge") > -1)
    return "Edge";
  const r = t.indexOf("MSIE ") !== -1, i = t.indexOf("Trident/") !== -1;
  return r || i ? "IE" : X0.chrome ? "Chrome" : X0.safari ? "Safari" : X0.mozInnerScreenX ? "Firefox" : "Unknown";
}
function UP(n) {
  try {
    const e = window[n], t = "__storage_test__";
    return e.setItem(t, t), e.removeItem(t), e;
  } catch {
    return null;
  }
}
class jP {
  constructor(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    V(this, "storage", void 0), V(this, "id", void 0), V(this, "config", void 0), this.storage = UP(r), this.id = e, this.config = t, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const t = JSON.stringify(this.config);
      this.storage.setItem(this.id, t);
    }
  }
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const t = this.storage.getItem(this.id);
      e = t ? JSON.parse(t) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function GP(n) {
  let e;
  return n < 10 ? e = "".concat(n.toFixed(2), "ms") : n < 100 ? e = "".concat(n.toFixed(1), "ms") : n < 1e3 ? e = "".concat(n.toFixed(0), "ms") : e = "".concat((n / 1e3).toFixed(2), "s"), e;
}
function VP(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const t = Math.max(e - n.length, 0);
  return "".concat(" ".repeat(t)).concat(n);
}
function $0(n, e, t) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const i = n.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  n.width > r && (t = Math.min(t, r / n.width));
  const o = n.width * t, c = n.height * t, l = ["font-size:1px;", "padding:".concat(Math.floor(c / 2), "px ").concat(Math.floor(o / 2), "px;"), "line-height:".concat(c, "px;"), "background:url(".concat(i, ");"), "background-size:".concat(o, "px ").concat(c, "px;"), "color:transparent;"].join("");
  return ["".concat(e, " %c+"), l];
}
let pm;
(function(n) {
  n[n.BLACK = 30] = "BLACK", n[n.RED = 31] = "RED", n[n.GREEN = 32] = "GREEN", n[n.YELLOW = 33] = "YELLOW", n[n.BLUE = 34] = "BLUE", n[n.MAGENTA = 35] = "MAGENTA", n[n.CYAN = 36] = "CYAN", n[n.WHITE = 37] = "WHITE", n[n.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", n[n.BRIGHT_RED = 91] = "BRIGHT_RED", n[n.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", n[n.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", n[n.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", n[n.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", n[n.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", n[n.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(pm || (pm = {}));
function O2(n) {
  return typeof n == "string" ? pm[n.toUpperCase()] || pm.WHITE : n;
}
function qP(n, e, t) {
  return !lu && typeof n == "string" && (e && (e = O2(e), n = "\x1B[".concat(e, "m").concat(n, "\x1B[39m")), t && (e = O2(t), n = "\x1B[".concat(t + 10, "m").concat(n, "\x1B[49m"))), n;
}
function HP(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const t = Object.getPrototypeOf(n), r = Object.getOwnPropertyNames(t);
  for (const i of r)
    typeof n[i] == "function" && (e.find((o) => i === o) || (n[i] = n[i].bind(n)));
}
function gm(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
function pd() {
  let n;
  if (lu && "performance" in pg) {
    var e, t;
    n = pg == null || (e = pg.performance) === null || e === void 0 || (t = e.now) === null || t === void 0 ? void 0 : t.call(e);
  } else if ("hrtime" in Nf) {
    var r;
    const i = Nf == null || (r = Nf.hrtime) === null || r === void 0 ? void 0 : r.call(Nf);
    n = i[0] * 1e3 + i[1] / 1e6;
  } else
    n = Date.now();
  return n;
}
const gd = {
  debug: lu && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, WP = {
  enabled: !0,
  level: 0
};
function Wa() {
}
const D2 = {}, F2 = {
  once: !0
};
class Op {
  constructor() {
    let {
      id: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    V(this, "id", void 0), V(this, "VERSION", D5), V(this, "_startTs", pd()), V(this, "_deltaTs", pd()), V(this, "_storage", void 0), V(this, "userData", {}), V(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = e, this.userData = {}, this._storage = new jP("__probe-".concat(this.id, "__"), WP), this.timeStamp("".concat(this.id, " started")), HP(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number((pd() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number((pd() - this._deltaTs).toPrecision(10));
  }
  set priority(e) {
    this.level = e;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return this._storage.setConfiguration({
      enabled: e
    }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({
      level: e
    }), this;
  }
  get(e) {
    return this._storage.config[e];
  }
  set(e, t) {
    this._storage.setConfiguration({
      [e]: t
    });
  }
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  assert(e, t) {
    gm(e, t);
  }
  warn(e) {
    return this._getLogFunction(0, e, gd.warn, arguments, F2);
  }
  error(e) {
    return this._getLogFunction(0, e, gd.error, arguments);
  }
  deprecated(e, t) {
    return this.warn("`".concat(e, "` is deprecated and will be removed in a later version. Use `").concat(t, "` instead"));
  }
  removed(e, t) {
    return this.error("`".concat(e, "` has been removed. Use `").concat(t, "` instead"));
  }
  probe(e, t) {
    return this._getLogFunction(e, t, gd.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, t) {
    return this._getLogFunction(e, t, gd.debug, arguments);
  }
  info(e, t) {
    return this._getLogFunction(e, t, console.info, arguments);
  }
  once(e, t) {
    for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
      i[o - 2] = arguments[o];
    return this._getLogFunction(e, t, gd.debug || gd.info, arguments, F2);
  }
  table(e, t, r) {
    return t ? this._getLogFunction(e, t, console.table || Wa, r && [r], {
      tag: JP(t)
    }) : Wa;
  }
  image(e) {
    let {
      logLevel: t,
      priority: r,
      image: i,
      message: o = "",
      scale: c = 1
    } = e;
    return this._shouldLog(t || r) ? lu ? ZP({
      image: i,
      message: o,
      scale: c
    }) : $P() : Wa;
  }
  time(e, t) {
    return this._getLogFunction(e, t, console.time ? console.time : console.info);
  }
  timeEnd(e, t) {
    return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, t) {
    return this._getLogFunction(e, t, console.timeStamp || Wa);
  }
  group(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: !1
    };
    const i = k2({
      logLevel: e,
      message: t,
      opts: r
    }), {
      collapsed: o
    } = r;
    return i.method = (o ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(i);
  }
  groupCollapsed(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(e, t, Object.assign({}, r, {
      collapsed: !0
    }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || Wa);
  }
  withGroup(e, t, r) {
    this.group(e, t)();
    try {
      r();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= k5(e);
  }
  _getLogFunction(e, t, r, i, o) {
    if (this._shouldLog(e)) {
      o = k2({
        logLevel: e,
        message: t,
        args: i,
        opts: o
      }), r = r || o.method, gm(r), o.total = this.getTotal(), o.delta = this.getDelta(), this._deltaTs = pd();
      const c = o.tag || o.message;
      if (o.once)
        if (!D2[c])
          D2[c] = pd();
        else
          return Wa;
      return t = XP(this.id, o.message, o), r.bind(console, t, ...o.args);
    }
    return Wa;
  }
}
V(Op, "VERSION", D5);
function k5(n) {
  if (!n)
    return 0;
  let e;
  switch (typeof n) {
    case "number":
      e = n;
      break;
    case "object":
      e = n.logLevel || n.priority || 0;
      break;
    default:
      return 0;
  }
  return gm(Number.isFinite(e) && e >= 0), e;
}
function k2(n) {
  const {
    logLevel: e,
    message: t
  } = n;
  n.logLevel = k5(e);
  const r = n.args ? Array.from(n.args) : [];
  for (; r.length && r.shift() !== t; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      t !== void 0 && r.unshift(t), n.message = e;
      break;
    case "object":
      Object.assign(n, e);
      break;
  }
  typeof n.message == "function" && (n.message = n.message());
  const i = typeof n.message;
  return gm(i === "string" || i === "object"), Object.assign(n, {
    args: r
  }, n.opts);
}
function XP(n, e, t) {
  if (typeof e == "string") {
    const r = t.time ? VP(GP(t.total)) : "";
    e = t.time ? "".concat(n, ": ").concat(r, "  ").concat(e) : "".concat(n, ": ").concat(e), e = qP(e, t.color, t.background);
  }
  return e;
}
function $P(n) {
  return console.warn("removed"), Wa;
}
function ZP(n) {
  let {
    image: e,
    message: t = "",
    scale: r = 1
  } = n;
  if (typeof e == "string") {
    const o = new Image();
    return o.onload = () => {
      const c = $0(o, t, r);
      console.log(...c);
    }, o.src = e, Wa;
  }
  const i = e.nodeName || "";
  if (i.toLowerCase() === "img")
    return console.log(...$0(e, t, r)), Wa;
  if (i.toLowerCase() === "canvas") {
    const o = new Image();
    return o.onload = () => console.log(...$0(o, t, r)), o.src = e.toDataURL(), Wa;
  }
  return Wa;
}
function JP(n) {
  for (const e in n)
    for (const t in n[e])
      return t || "untitled";
  return "empty";
}
const N2 = new Op({
  id: "loaders.gl"
});
class YP {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class KP {
  constructor() {
    V(this, "console", void 0), this.console = console;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return this.console.log.bind(this.console, ...t);
  }
  info() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return this.console.info.bind(this.console, ...t);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return this.console.warn.bind(this.console, ...t);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return this.console.error.bind(this.console, ...t);
  }
}
const N5 = {
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new KP(),
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: Fm,
  _nodeWorkers: !1,
  _workerType: "",
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  transforms: []
}, QP = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function z5() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders: n
  } = globalThis;
  return n._state = n._state || {}, n._state;
}
const U5 = () => {
  const n = z5();
  return n.globalOptions = n.globalOptions || {
    ...N5
  }, n.globalOptions;
};
function eL(n, e, t, r) {
  return t = t || [], t = Array.isArray(t) ? t : [t], tL(n, t), rL(e, n, r);
}
function tL(n, e) {
  z2(n, null, N5, QP, e);
  for (const t of e) {
    const r = n && n[t.id] || {}, i = t.options && t.options[t.id] || {}, o = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
    z2(r, t.id, i, o, e);
  }
}
function z2(n, e, t, r, i) {
  const o = e || "Top level", c = e ? "".concat(e, ".") : "";
  for (const l in n) {
    const _ = !e && Rp(n[l]), b = l === "baseUri" && !e, w = l === "workerUrl" && e;
    if (!(l in t) && !b && !w) {
      if (l in r)
        N2.warn("".concat(o, " loader option '").concat(c).concat(l, "' no longer supported, use '").concat(r[l], "'"))();
      else if (!_) {
        const T = nL(l, i);
        N2.warn("".concat(o, " loader option '").concat(c).concat(l, "' not recognized. ").concat(T))();
      }
    }
  }
}
function nL(n, e) {
  const t = n.toLowerCase();
  let r = "";
  for (const i of e)
    for (const o in i.options) {
      if (n === o)
        return "Did you mean '".concat(i.id, ".").concat(o, "'?");
      const c = o.toLowerCase();
      (t.startsWith(c) || c.startsWith(t)) && (r = r || "Did you mean '".concat(i.id, ".").concat(o, "'?"));
    }
  return r;
}
function rL(n, e, t) {
  const i = {
    ...n.options || {}
  };
  return iL(i, t), i.log === null && (i.log = new YP()), U2(i, U5()), U2(i, e), i;
}
function U2(n, e) {
  for (const t in e)
    if (t in e) {
      const r = e[t];
      M2(r) && M2(n[t]) ? n[t] = {
        ...n[t],
        ...e[t]
      } : n[t] = e[t];
    }
}
function iL(n, e) {
  e && !("baseUri" in n) && (n.baseUri = e);
}
function T1(n) {
  var e;
  return n ? (Array.isArray(n) && (n = n[0]), Array.isArray((e = n) === null || e === void 0 ? void 0 : e.extensions)) : !1;
}
function C1(n) {
  var e, t;
  Zr(n, "null loader"), Zr(T1(n), "invalid loader");
  let r;
  return Array.isArray(n) && (r = n[1], n = n[0], n = {
    ...n,
    options: {
      ...n.options,
      ...r
    }
  }), ((e = n) !== null && e !== void 0 && e.parseTextSync || (t = n) !== null && t !== void 0 && t.parseText) && (n.text = !0), n.text || (n.binary = !0), n;
}
const j5 = () => {
  const n = z5();
  return n.loaderRegistry = n.loaderRegistry || [], n.loaderRegistry;
};
function sL(n) {
  const e = j5();
  n = Array.isArray(n) ? n : [n];
  for (const t of n) {
    const r = C1(t);
    e.find((i) => r === i) || e.unshift(r);
  }
}
function oL() {
  return j5();
}
const aL = new Op({
  id: "loaders.gl"
}), lL = /\.([^.]+)$/;
async function cL(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, r = arguments.length > 3 ? arguments[3] : void 0;
  if (!G5(n))
    return null;
  let i = j2(n, e, {
    ...t,
    nothrow: !0
  }, r);
  if (i)
    return i;
  if (Gh(n) && (n = await n.slice(0, 10).arrayBuffer(), i = j2(n, e, t, r)), !i && !(t != null && t.nothrow))
    throw new Error(V5(n));
  return i;
}
function j2(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, r = arguments.length > 3 ? arguments[3] : void 0;
  if (!G5(n))
    return null;
  if (e && !Array.isArray(e))
    return C1(e);
  let i = [];
  e && (i = i.concat(e)), t != null && t.ignoreRegisteredLoaders || i.push(...oL()), hL(i);
  const o = uL(n, i, t, r);
  if (!o && !(t != null && t.nothrow))
    throw new Error(V5(n));
  return o;
}
function uL(n, e, t, r) {
  const i = km(n), o = E1(n), c = S1(i) || (r == null ? void 0 : r.url);
  let l = null, _ = "";
  if (t != null && t.mimeType && (l = Z0(e, t == null ? void 0 : t.mimeType), _ = "match forced by supplied MIME type ".concat(t == null ? void 0 : t.mimeType)), l = l || dL(e, c), _ = _ || (l ? "matched url ".concat(c) : ""), l = l || Z0(e, o), _ = _ || (l ? "matched MIME type ".concat(o) : ""), l = l || pL(e, n), _ = _ || (l ? "matched initial data ".concat(q5(n)) : ""), l = l || Z0(e, t == null ? void 0 : t.fallbackMimeType), _ = _ || (l ? "matched fallback MIME type ".concat(o) : ""), _) {
    var b;
    aL.log(1, "selectLoader selected ".concat((b = l) === null || b === void 0 ? void 0 : b.name, ": ").concat(_, "."));
  }
  return l;
}
function G5(n) {
  return !(n instanceof Response && n.status === 204);
}
function V5(n) {
  const e = km(n), t = E1(n);
  let r = "No valid loader found (";
  r += e ? "".concat(L5(e), ", ") : "no url provided, ", r += "MIME type: ".concat(t ? '"'.concat(t, '"') : "not provided", ", ");
  const i = n ? q5(n) : "";
  return r += i ? ' first bytes: "'.concat(i, '"') : "first bytes: not available", r += ")", r;
}
function hL(n) {
  for (const e of n)
    C1(e);
}
function dL(n, e) {
  const t = e && lL.exec(e), r = t && t[1];
  return r ? fL(n, r) : null;
}
function fL(n, e) {
  e = e.toLowerCase();
  for (const t of n)
    for (const r of t.extensions)
      if (r.toLowerCase() === e)
        return t;
  return null;
}
function Z0(n, e) {
  for (const t of n)
    if (t.mimeTypes && t.mimeTypes.includes(e) || e === "application/x.".concat(t.id))
      return t;
  return null;
}
function pL(n, e) {
  if (!e)
    return null;
  for (const t of n)
    if (typeof e == "string") {
      if (gL(e, t))
        return t;
    } else if (ArrayBuffer.isView(e)) {
      if (G2(e.buffer, e.byteOffset, t))
        return t;
    } else if (e instanceof ArrayBuffer && G2(e, 0, t))
      return t;
  return null;
}
function gL(n, e) {
  return e.testText ? e.testText(n) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((r) => n.startsWith(r));
}
function G2(n, e, t) {
  return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((i) => mL(n, e, t, i));
}
function mL(n, e, t, r) {
  if (r instanceof ArrayBuffer)
    return hP(r, n, r.byteLength);
  switch (typeof r) {
    case "function":
      return r(n, t);
    case "string":
      const i = uy(n, e, r.length);
      return r === i;
    default:
      return !1;
  }
}
function q5(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? uy(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? uy(n, 0, e) : "";
}
function uy(n, e, t) {
  if (n.byteLength < e + t)
    return "";
  const r = new DataView(n);
  let i = "";
  for (let o = 0; o < t; o++)
    i += String.fromCharCode(r.getUint8(e + o));
  return i;
}
const _L = 256 * 1024;
function* yL(n, e) {
  const t = (e == null ? void 0 : e.chunkSize) || _L;
  let r = 0;
  const i = new TextEncoder();
  for (; r < n.length; ) {
    const o = Math.min(n.length - r, t), c = n.slice(r, r + o);
    r += o, yield i.encode(c);
  }
}
const bL = 256 * 1024;
function vL(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    const {
      chunkSize: t = bL
    } = e;
    let r = 0;
    for (; r < n.byteLength; ) {
      const i = Math.min(n.byteLength - r, t), o = new ArrayBuffer(i), c = new Uint8Array(n, r, i);
      new Uint8Array(o).set(c), r += i, yield o;
    }
  }();
}
const xL = 1024 * 1024;
async function* wL(n, e) {
  const t = (e == null ? void 0 : e.chunkSize) || xL;
  let r = 0;
  for (; r < n.size; ) {
    const i = r + t, o = await n.slice(r, i).arrayBuffer();
    r = i, yield o;
  }
}
function V2(n, e) {
  return Fm ? AL(n, e) : SL(n);
}
async function* AL(n, e) {
  const t = n.getReader();
  let r;
  try {
    for (; ; ) {
      const i = r || t.read();
      e != null && e._streamReadAhead && (r = t.read());
      const {
        done: o,
        value: c
      } = await i;
      if (o)
        return;
      yield P5(c);
    }
  } catch {
    t.releaseLock();
  }
}
async function* SL(n, e) {
  for await (const t of n)
    yield P5(t);
}
function EL(n, e) {
  if (typeof n == "string")
    return yL(n, e);
  if (n instanceof ArrayBuffer)
    return vL(n, e);
  if (Gh(n))
    return wL(n, e);
  if (M5(n))
    return V2(n, e);
  if (jh(n))
    return V2(n.body, e);
  throw new Error("makeIterator");
}
const H5 = "Cannot convert supplied data type";
function TL(n, e, t) {
  if (e.text && typeof n == "string")
    return n;
  if (IP(n) && (n = n.buffer), n instanceof ArrayBuffer) {
    const r = n;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(r) : r;
  }
  if (ArrayBuffer.isView(n)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(n);
    let r = n.buffer;
    const i = n.byteLength || n.length;
    return (n.byteOffset !== 0 || i !== r.byteLength) && (r = r.slice(n.byteOffset, n.byteOffset + i)), r;
  }
  throw new Error(H5);
}
async function CL(n, e, t) {
  const r = n instanceof ArrayBuffer || ArrayBuffer.isView(n);
  if (typeof n == "string" || r)
    return TL(n, e);
  if (Gh(n) && (n = await R5(n)), jh(n)) {
    const i = n;
    return await FP(i), e.binary ? await i.arrayBuffer() : await i.text();
  }
  if (M5(n) && (n = EL(n, t)), TP(n) || CP(n))
    return pP(n);
  throw new Error(H5);
}
function W5(n, e) {
  const t = U5(), r = n || t;
  return typeof r.fetch == "function" ? r.fetch : Rp(r.fetch) ? (i) => R2(i, r) : e != null && e.fetch ? e == null ? void 0 : e.fetch : R2;
}
function IL(n, e, t) {
  if (t)
    return t;
  const r = {
    fetch: W5(e, n),
    ...n
  };
  if (r.url) {
    const i = S1(r.url);
    r.baseUrl = i, r.queryString = OP(r.url), r.filename = L5(i), r.baseUrl = A1(i);
  }
  return Array.isArray(r.loaders) || (r.loaders = null), r;
}
function PL(n, e) {
  if (!e && n && !Array.isArray(n))
    return n;
  let t;
  if (n && (t = Array.isArray(n) ? n : [n]), e && e.loaders) {
    const r = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    t = t ? [...t, ...r] : r;
  }
  return t && t.length ? t : null;
}
async function I1(n, e, t, r) {
  wc(!r || typeof r == "object"), e && !Array.isArray(e) && !T1(e) && (r = void 0, t = e, e = void 0), n = await n, t = t || {};
  const i = km(n), c = PL(e, r), l = await cL(n, c, t);
  return l ? (t = eL(t, l, c, i), r = IL({
    url: i,
    parse: I1,
    loaders: c
  }, t, r || null), await LL(l, n, t, r)) : null;
}
async function LL(n, e, t, r) {
  if (KI(n), jh(e)) {
    const i = e, {
      ok: o,
      redirected: c,
      status: l,
      statusText: _,
      type: b,
      url: w
    } = i, T = Object.fromEntries(i.headers.entries());
    r.response = {
      headers: T,
      ok: o,
      redirected: c,
      status: l,
      statusText: _,
      type: b,
      url: w
    };
  }
  if (e = await CL(e, n, t), n.parseTextSync && typeof e == "string")
    return t.dataType = "text", n.parseTextSync(e, t, r, n);
  if (oP(n, t))
    return await aP(n, e, t, r, I1);
  if (n.parseText && typeof e == "string")
    return await n.parseText(e, t, r, n);
  if (n.parse)
    return await n.parse(e, t, r, n);
  throw wc(!n.parseSync), new Error("".concat(n.id, " loader - no parser found and worker is disabled"));
}
async function Hu(n, e, t, r) {
  !Array.isArray(e) && !T1(e) && (t = e, e = void 0);
  const i = W5(t);
  let o = n;
  return typeof n == "string" && (o = await i(n)), Gh(n) && (o = await i(n)), await I1(o, e, t);
}
const ML = "3.4.15", {
  _parseImageNode: BL
} = globalThis, hy = typeof Image < "u", dy = typeof ImageBitmap < "u", RL = !!BL, fy = Fm ? !0 : RL;
function OL(n) {
  switch (n) {
    case "auto":
      return dy || hy || fy;
    case "imagebitmap":
      return dy;
    case "image":
      return hy;
    case "data":
      return fy;
    default:
      throw new Error("@loaders.gl/images: image ".concat(n, " not supported in this environment"));
  }
}
function DL() {
  if (dy)
    return "imagebitmap";
  if (hy)
    return "image";
  if (fy)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function FL(n) {
  const e = NL(n);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function kL(n) {
  switch (FL(n)) {
    case "data":
      return n;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = n.width, e.height = n.height, t.drawImage(n, 0, 0), t.getImageData(0, 0, n.width, n.height);
    default:
      throw new Error("getImageData");
  }
}
function NL(n) {
  return typeof ImageBitmap < "u" && n instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && n instanceof Image ? "image" : n && typeof n == "object" && n.data && n.width && n.height ? "data" : null;
}
const zL = /^data:image\/svg\+xml/, UL = /\.svg((\?|#).*)?$/;
function P1(n) {
  return n && (zL.test(n) || UL.test(n));
}
function jL(n, e) {
  if (P1(e)) {
    let r = new TextDecoder().decode(n);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (r = unescape(encodeURIComponent(r)));
    } catch (o) {
      throw new Error(o.message);
    }
    return "data:image/svg+xml;base64,".concat(btoa(r));
  }
  return X5(n, e);
}
function X5(n, e) {
  if (P1(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(n)]);
}
async function $5(n, e, t) {
  const r = jL(n, t), i = self.URL || self.webkitURL, o = typeof r != "string" && i.createObjectURL(r);
  try {
    return await VL(o || r, e);
  } finally {
    o && i.revokeObjectURL(o);
  }
}
async function VL(n, e) {
  const t = new Image();
  return t.src = n, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((r, i) => {
    try {
      t.onload = () => r(t), t.onerror = (o) => i(new Error("Could not load image ".concat(n, ": ").concat(o)));
    } catch (o) {
      i(o);
    }
  });
}
const qL = {};
let q2 = !0;
async function HL(n, e, t) {
  let r;
  P1(t) ? r = await $5(n, e, t) : r = X5(n, t);
  const i = e && e.imagebitmap;
  return await WL(r, i);
}
async function WL(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if ((XL(e) || !q2) && (e = null), e)
    try {
      return await createImageBitmap(n, e);
    } catch (t) {
      console.warn(t), q2 = !1;
    }
  return await createImageBitmap(n);
}
function XL(n) {
  for (const e in n || qL)
    return !1;
  return !0;
}
function $L(n) {
  return !KL(n, "ftyp", 4) || !(n[8] & 96) ? null : ZL(n);
}
function ZL(n) {
  switch (JL(n, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function JL(n, e, t) {
  return String.fromCharCode(...n.slice(e, t));
}
function YL(n) {
  return [...n].map((e) => e.charCodeAt(0));
}
function KL(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const r = YL(e);
  for (let i = 0; i < r.length; ++i)
    if (r[i] !== n[i + t])
      return !1;
  return !0;
}
const gc = !1, ap = !0;
function L1(n) {
  const e = Dp(n);
  return eM(e) || rM(e) || tM(e) || nM(e) || QL(e);
}
function QL(n) {
  const e = new Uint8Array(n instanceof DataView ? n.buffer : n), t = $L(e);
  return t ? {
    mimeType: t.mimeType,
    width: 0,
    height: 0
  } : null;
}
function eM(n) {
  const e = Dp(n);
  return e.byteLength >= 24 && e.getUint32(0, gc) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, gc),
    height: e.getUint32(20, gc)
  } : null;
}
function tM(n) {
  const e = Dp(n);
  return e.byteLength >= 10 && e.getUint32(0, gc) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, ap),
    height: e.getUint16(8, ap)
  } : null;
}
function nM(n) {
  const e = Dp(n);
  return e.byteLength >= 14 && e.getUint16(0, gc) === 16973 && e.getUint32(2, ap) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, ap),
    height: e.getUint32(22, ap)
  } : null;
}
function rM(n) {
  const e = Dp(n);
  if (!(e.byteLength >= 3 && e.getUint16(0, gc) === 65496 && e.getUint8(2) === 255))
    return null;
  const {
    tableMarkers: r,
    sofMarkers: i
  } = iM();
  let o = 2;
  for (; o + 9 < e.byteLength; ) {
    const c = e.getUint16(o, gc);
    if (i.has(c))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(o + 5, gc),
        width: e.getUint16(o + 7, gc)
      };
    if (!r.has(c))
      return null;
    o += 2, o += e.getUint16(o, gc);
  }
  return null;
}
function iM() {
  const n = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    n.add(t);
  return {
    tableMarkers: n,
    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
  };
}
function Dp(n) {
  if (n instanceof DataView)
    return n;
  if (ArrayBuffer.isView(n))
    return new DataView(n.buffer);
  if (n instanceof ArrayBuffer)
    return new DataView(n);
  throw new Error("toDataView");
}
async function sM(n, e) {
  const {
    mimeType: t
  } = L1(n) || {}, r = globalThis._parseImageNode;
  return Zr(r), await r(n, t);
}
async function oM(n, e, t) {
  e = e || {};
  const i = (e.image || {}).type || "auto", {
    url: o
  } = t || {}, c = aM(i);
  let l;
  switch (c) {
    case "imagebitmap":
      l = await HL(n, e, o);
      break;
    case "image":
      l = await $5(n, e, o);
      break;
    case "data":
      l = await sM(n);
      break;
    default:
      Zr(!1);
  }
  return i === "data" && (l = kL(l)), l;
}
function aM(n) {
  switch (n) {
    case "auto":
    case "data":
      return DL();
    default:
      return OL(n), n;
  }
}
const lM = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], cM = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], uM = {
  image: {
    type: "auto",
    decode: !0
  }
}, Z5 = {
  id: "image",
  module: "images",
  name: "Images",
  version: ML,
  mimeTypes: cM,
  extensions: lM,
  parse: oM,
  tests: [(n) => !!L1(new DataView(n))],
  options: uM
}, J0 = {};
function hM(n) {
  if (J0[n] === void 0) {
    const e = Fm ? fM(n) : dM(n);
    J0[n] = e;
  }
  return J0[n];
}
function dM(n) {
  const e = ["image/png", "image/jpeg", "image/gif"], {
    _parseImageNode: t,
    _imageFormatsNode: r = e
  } = globalThis;
  return !!t && r.includes(n);
}
function fM(n) {
  switch (n) {
    case "image/avif":
    case "image/webp":
      return pM(n);
    default:
      return !0;
  }
}
function pM(n) {
  try {
    return document.createElement("canvas").toDataURL(n).indexOf("data:".concat(n)) === 0;
  } catch {
    return !1;
  }
}
const ur = new Op({
  id: "deck"
}), Iu = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
}, Y0 = 1, zf = 2, K0 = 3, Q0 = 4, gM = 2, mM = (n) => ({
  "layer.changeFlag": (e, t, r) => {
    n.log(K0, "".concat(e.id, " ").concat(t, ": "), r[t])();
  },
  "layer.initialize": (e) => {
    n.log(Y0, "Initializing ".concat(e))();
  },
  "layer.update": (e, t) => {
    if (t) {
      const r = e.getChangeFlags();
      n.log(zf, "Updating ".concat(e, " because: ").concat(Object.keys(r).filter((i) => r[i]).join(", ")))();
    } else
      n.log(Q0, "".concat(e, " does not need update"))();
  },
  "layer.matched": (e, t) => {
    t && n.log(Q0, "Matched ".concat(e, ", state transfered"))();
  },
  "layer.finalize": (e) => {
    n.log(Y0, "Finalizing ".concat(e))();
  },
  "compositeLayer.renderLayers": (e, t, r) => {
    t ? n.log(zf, "Composite layer rendered new subLayers ".concat(e), r)() : n.log(Q0, "Composite layer reused subLayers ".concat(e), r)();
  },
  "layerManager.setLayers": (e, t, r) => {
    t && n.log(zf, "Updating ".concat(r.length, " deck layers"))();
  },
  "layerManager.activateViewport": (e, t) => {
    n.log(K0, "Viewport changed", t)();
  },
  "attributeManager.invalidate": (e, t, r) => {
    n.log(Y0, r ? "invalidated attributes ".concat(r, " (").concat(t, ") for ").concat(e.id) : "invalidated all attributes for ".concat(e.id))();
  },
  "attributeManager.updateStart": (e) => {
    Iu.attributeUpdateMessages.length = 0, Iu.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (e, t) => {
    const r = Math.round(Date.now() - Iu.attributeManagerUpdateStart);
    n.groupCollapsed(zf, "Updated attributes for ".concat(t, " instances in ").concat(e.id, " in ").concat(r, "ms"))();
    for (const i of Iu.attributeUpdateMessages)
      n.log(K0, i)();
    n.groupEnd(zf)();
  },
  "attribute.updateStart": (e) => {
    Iu.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (e, t) => {
    const r = "".concat(e.id, " allocated ").concat(t);
    Iu.attributeUpdateMessages.push(r);
  },
  "attribute.updateEnd": (e, t) => {
    const r = Math.round(Date.now() - Iu.attributeUpdateStart), i = "".concat(e.id, " updated ").concat(t, " in ").concat(r, "ms");
    Iu.attributeUpdateMessages.push(i);
  },
  "deckRenderer.renderLayers": (e, t, r) => {
    const {
      pass: i,
      redrawReason: o,
      stats: c
    } = r;
    for (const l of t) {
      const {
        totalCount: _,
        visibleCount: b,
        compositeCount: w,
        pickableCount: T
      } = l, P = _ - w - b;
      n.log(gM, "RENDER #".concat(e.renderCount, "   ").concat(b, " (of ").concat(_, " layers) to ").concat(i, " because ").concat(o, "   (").concat(P, " hidden, ").concat(w, " composite ").concat(T, " pickable)"))(), c && c.get("Redraw Layers").add(b);
    }
  }
});
var _M = {};
let mm = {};
_M.NODE_ENV !== "production" && (mm = mM(ur));
function yM(n) {
  mm = n;
}
function eo(n, e, t, r) {
  ur.level > 0 && mm[n] && mm[n].call(null, e, t, r);
}
function bM(n) {
  const e = n[0], t = n[n.length - 1];
  return e === "{" && t === "}" || e === "[" && t === "]";
}
const vM = {
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: bM,
  parseTextSync: JSON.parse
};
function xM() {
  const n = "8.9.36", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== n)
    throw new Error("deck.gl - multiple versions detected: ".concat(e, " vs ").concat(n));
  return e || (ur.log(1, "deck.gl ".concat(n))(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: n,
    version: n,
    log: ur,
    _registerLoggers: yM
  }, sL([vM, [Z5, {
    imagebitmap: {
      premultiplyAlpha: "none"
    }
  }]])), n;
}
const wM = xM(), cr = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
Object.defineProperty(cr, "IDENTITY", {
  get: () => (ur.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const _c = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
}, py = {
  common: 0,
  meters: 1,
  pixels: 2
}, H2 = {
  click: {
    handler: "onClick"
  },
  panstart: {
    handler: "onDragStart"
  },
  panmove: {
    handler: "onDrag"
  },
  panend: {
    handler: "onDragEnd"
  }
}, ln = new Op({
  id: "luma.gl"
});
function Ao(n, e) {
  if (!n)
    throw new Error(e || "luma.gl: assertion failed.");
}
const AM = "Invalid WebGLRenderingContext", SM = "Requires WebGL2";
function Nm(n) {
  return typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext || typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && Number.isFinite(n._version));
}
function tr(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && n._version === 2);
}
function EM(n) {
  return tr(n) ? n : null;
}
function zm(n) {
  return Ao(Nm(n), AM), n;
}
function So(n) {
  return Ao(tr(n), SM), n;
}
const tp = {};
function TM(n) {
  globalThis.console && globalThis.console.error && globalThis.console.error(n);
}
function CM(n) {
  globalThis.console && globalThis.console.log && globalThis.console.log(n);
}
function IM(n, e) {
  tp[n] = !0, TM(e);
}
function PM(n) {
  const e = n.getError;
  n.getError = function() {
    let r;
    do
      r = e.apply(n), r !== 0 && (tp[r] = !0);
    while (r !== 0);
    for (r in tp)
      if (tp[r])
        return delete tp[r], parseInt(r, 10);
    return 0;
  };
}
const Fp = function n(e) {
  const t = e.gl;
  this.ext = e, this.isAlive = !0, this.hasBeenBound = !1, this.elementArrayBuffer = null, this.attribs = new Array(e.maxVertexAttribs);
  for (let r = 0; r < this.attribs.length; r++) {
    const i = new n.VertexAttrib(t);
    this.attribs[r] = i;
  }
  this.maxAttrib = 0;
};
Fp.VertexAttrib = function(e) {
  this.enabled = !1, this.buffer = null, this.size = 4, this.type = 5126, this.normalized = !1, this.stride = 16, this.offset = 0, this.cached = "", this.recache();
};
Fp.VertexAttrib.prototype.recache = function() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};
const Vh = function(e) {
  const t = this;
  this.gl = e, PM(e);
  const r = this.original = {
    getParameter: e.getParameter,
    enableVertexAttribArray: e.enableVertexAttribArray,
    disableVertexAttribArray: e.disableVertexAttribArray,
    bindBuffer: e.bindBuffer,
    getVertexAttrib: e.getVertexAttrib,
    vertexAttribPointer: e.vertexAttribPointer
  };
  e.getParameter = function(o) {
    return o === t.VERTEX_ARRAY_BINDING_OES ? t.currentVertexArrayObject === t.defaultVertexArrayObject ? null : t.currentVertexArrayObject : r.getParameter.apply(this, arguments);
  }, e.enableVertexAttribArray = function(o) {
    const c = t.currentVertexArrayObject;
    c.maxAttrib = Math.max(c.maxAttrib, o);
    const l = c.attribs[o];
    return l.enabled = !0, r.enableVertexAttribArray.apply(this, arguments);
  }, e.disableVertexAttribArray = function(o) {
    const c = t.currentVertexArrayObject;
    c.maxAttrib = Math.max(c.maxAttrib, o);
    const l = c.attribs[o];
    return l.enabled = !1, r.disableVertexAttribArray.apply(this, arguments);
  }, e.bindBuffer = function(o, c) {
    switch (o) {
      case 34962:
        t.currentArrayBuffer = c;
        break;
      case 34963:
        t.currentVertexArrayObject.elementArrayBuffer = c;
        break;
    }
    return r.bindBuffer.apply(this, arguments);
  }, e.getVertexAttrib = function(o, c) {
    const _ = t.currentVertexArrayObject.attribs[o];
    switch (c) {
      case 34975:
        return _.buffer;
      case 34338:
        return _.enabled;
      case 34339:
        return _.size;
      case 34340:
        return _.stride;
      case 34341:
        return _.type;
      case 34922:
        return _.normalized;
      default:
        return r.getVertexAttrib.apply(this, arguments);
    }
  }, e.vertexAttribPointer = function(o, c, l, _, b, w) {
    const T = t.currentVertexArrayObject;
    T.maxAttrib = Math.max(T.maxAttrib, o);
    const I = T.attribs[o];
    return I.buffer = t.currentArrayBuffer, I.size = c, I.type = l, I.normalized = _, I.stride = b, I.offset = w, I.recache(), r.vertexAttribPointer.apply(this, arguments);
  }, e.instrumentExtension && e.instrumentExtension(this, "OES_vertex_array_object"), e.canvas && e.canvas.addEventListener("webglcontextrestored", () => {
    CM("OESVertexArrayObject emulation library context restored"), t.reset_();
  }, !0), this.reset_();
};
Vh.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
Vh.prototype.reset_ = function() {
  if (this.vertexArrayObjects !== void 0)
    for (let r = 0; r < this.vertexArrayObjects.length; ++r)
      this.vertexArrayObjects.isAlive = !1;
  const t = this.gl;
  this.maxVertexAttribs = t.getParameter(34921), this.defaultVertexArrayObject = new Fp(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null);
};
Vh.prototype.createVertexArrayOES = function() {
  const e = new Fp(this);
  return this.vertexArrayObjects.push(e), e;
};
Vh.prototype.deleteVertexArrayOES = function(e) {
  e.isAlive = !1, this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e), 1), this.currentVertexArrayObject === e && this.bindVertexArrayOES(null);
};
Vh.prototype.isVertexArrayOES = function(e) {
  return !!(e && e instanceof Fp && e.hasBeenBound && e.ext === this);
};
Vh.prototype.bindVertexArrayOES = function(e) {
  const t = this.gl;
  if (e && !e.isAlive) {
    IM(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
    return;
  }
  const r = this.original, i = this.currentVertexArrayObject;
  this.currentVertexArrayObject = e || this.defaultVertexArrayObject, this.currentVertexArrayObject.hasBeenBound = !0;
  const o = this.currentVertexArrayObject;
  if (i === o)
    return;
  (!i || o.elementArrayBuffer !== i.elementArrayBuffer) && r.bindBuffer.call(t, 34963, o.elementArrayBuffer);
  let c = this.currentArrayBuffer;
  const l = Math.max(i ? i.maxAttrib : 0, o.maxAttrib);
  for (let _ = 0; _ <= l; _++) {
    const b = o.attribs[_], w = i ? i.attribs[_] : null;
    if ((!i || b.enabled !== w.enabled) && (b.enabled ? r.enableVertexAttribArray.call(t, _) : r.disableVertexAttribArray.call(t, _)), b.enabled) {
      let T = !1;
      (!i || b.buffer !== w.buffer) && (c !== b.buffer && (r.bindBuffer.call(t, 34962, b.buffer), c = b.buffer), T = !0), (T || b.cached !== w.cached) && r.vertexAttribPointer.call(t, _, b.size, b.type, b.normalized, b.stride, b.offset);
    }
  }
  this.currentArrayBuffer !== c && r.bindBuffer.call(t, 34962, this.currentArrayBuffer);
};
function LM(n) {
  if (typeof n.createVertexArray == "function")
    return;
  const e = n.getSupportedExtensions;
  n.getSupportedExtensions = function() {
    const i = e.call(this) || [];
    return i.indexOf("OES_vertex_array_object") < 0 && i.push("OES_vertex_array_object"), i;
  };
  const t = n.getExtension;
  n.getExtension = function(i) {
    const o = t.call(this, i);
    return o || (i !== "OES_vertex_array_object" ? null : (n.__OESVertexArrayObject || (this.__OESVertexArrayObject = new Vh(this)), this.__OESVertexArrayObject));
  };
}
const W2 = "OES_element_index", X2 = "WEBGL_draw_buffers", MM = "EXT_disjoint_timer_query", BM = "EXT_disjoint_timer_query_webgl2", RM = "EXT_texture_filter_anisotropic", $2 = "WEBGL_debug_renderer_info", OM = 35723, DM = 4352, FM = 36795, kM = 34047, NM = 37445, zM = 37446, Qr = (n) => tr(n) ? void 0 : 0, UM = {
  3074: (n) => tr(n) ? void 0 : 36064,
  [OM]: (n) => tr(n) ? void 0 : DM,
  35977: Qr,
  32937: Qr,
  [FM]: (n, e) => {
    const t = tr(n) ? n.getExtension(BM) : n.getExtension(MM);
    return t && t.GPU_DISJOINT_EXT ? e(t.GPU_DISJOINT_EXT) : 0;
  },
  [NM]: (n, e) => {
    const t = n.getExtension($2);
    return e(t && t.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [zM]: (n, e) => {
    const t = n.getExtension($2);
    return e(t && t.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [kM]: (n, e) => {
    const t = n.luma.extensions[RM];
    return t ? e(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  },
  32883: Qr,
  35071: Qr,
  37447: Qr,
  36063: (n, e) => {
    if (!tr(n)) {
      const t = n.getExtension(X2);
      return t ? e(t.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
  },
  35379: Qr,
  35374: Qr,
  35377: Qr,
  34852: (n) => {
    if (!tr(n)) {
      const e = n.getExtension(X2);
      return e ? e.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
  },
  36203: (n) => n.getExtension(W2) ? 2147483647 : 65535,
  33001: (n) => n.getExtension(W2) ? 16777216 : 65535,
  33e3: (n) => 16777216,
  37157: Qr,
  35373: Qr,
  35657: Qr,
  36183: Qr,
  37137: Qr,
  34045: Qr,
  35978: Qr,
  35979: Qr,
  35968: Qr,
  35376: Qr,
  35375: Qr,
  35659: Qr,
  37154: Qr,
  35371: Qr,
  35658: Qr,
  35076: Qr,
  35077: Qr,
  35380: Qr
};
function jM(n, e, t) {
  const r = UM[t], i = typeof r == "function" ? r(n, e, t) : r;
  return i !== void 0 ? i : e(t);
}
const GM = "OES_vertex_array_object", J5 = "ANGLE_instanced_arrays", VM = "WEBGL_draw_buffers", qM = "EXT_disjoint_timer_query", HM = "EXT_texture_filter_anisotropic", WM = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
function XM(n, e) {
  return {
    webgl2: tr(n),
    ext: n.getExtension(e)
  };
}
const Y5 = {
  [GM]: {
    meta: {
      suffix: "OES"
    },
    createVertexArray: () => {
      Ao(!1, WM);
    },
    deleteVertexArray: () => {
    },
    bindVertexArray: () => {
    },
    isVertexArray: () => !1
  },
  [J5]: {
    meta: {
      suffix: "ANGLE"
    },
    vertexAttribDivisor(n, e) {
      Ao(e === 0, "WebGL instanced rendering not supported");
    },
    drawElementsInstanced: () => {
    },
    drawArraysInstanced: () => {
    }
  },
  [VM]: {
    meta: {
      suffix: "WEBGL"
    },
    drawBuffers: () => {
      Ao(!1);
    }
  },
  [qM]: {
    meta: {
      suffix: "EXT"
    },
    createQuery: () => {
      Ao(!1);
    },
    deleteQuery: () => {
      Ao(!1);
    },
    beginQuery: () => {
      Ao(!1);
    },
    endQuery: () => {
    },
    getQuery(n, e) {
      return this.getQueryObject(n, e);
    },
    getQueryParameter(n, e) {
      return this.getQueryObject(n, e);
    },
    getQueryObject: () => {
    }
  }
}, e_ = {
  readBuffer: (n, e, t) => {
    tr(n) && e(t);
  },
  getVertexAttrib: (n, e, t, r) => {
    const {
      webgl2: i,
      ext: o
    } = XM(n, J5);
    let c;
    switch (r) {
      case 35069:
        c = i ? void 0 : !1;
        break;
      case 35070:
        c = !i && !o ? 0 : void 0;
        break;
    }
    return c !== void 0 ? c : e(t, r);
  },
  getProgramParameter: (n, e, t, r) => {
    if (!tr(n))
      switch (r) {
        case 35967:
          return 35981;
        case 35971:
          return 0;
        case 35382:
          return 0;
      }
    return e(t, r);
  },
  getInternalformatParameter: (n, e, t, r, i) => {
    if (!tr(n))
      switch (i) {
        case 32937:
          return new Int32Array([0]);
      }
    return n.getInternalformatParameter(t, r, i);
  },
  getTexParameter(n, e, t, r) {
    switch (r) {
      case 34046:
        const {
          extensions: i
        } = n.luma, o = i[HM];
        r = o && o.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;
    }
    return e(t, r);
  },
  getParameter: jM,
  hint(n, e, t, r) {
    return e(t, r);
  }
};
function $M(n) {
  n.luma = n.luma || {};
  const {
    luma: e
  } = n;
  return e.polyfilled || (LM(n), ZM(n), YM(n, Y5), JM(n, {
    target: e,
    target2: n
  }), e.polyfilled = !0), n;
}
globalThis.polyfillContext = $M;
function ZM(n) {
  n.luma.extensions = {};
  const e = n.getSupportedExtensions() || [];
  for (const t of e)
    n.luma[t] = n.getExtension(t);
}
function JM(n, e) {
  let {
    target: t,
    target2: r
  } = e;
  Object.keys(e_).forEach((i) => {
    if (typeof e_[i] == "function") {
      const o = n[i] ? n[i].bind(n) : () => {
      }, c = e_[i].bind(null, n, o);
      t[i] = c, r[i] = c;
    }
  });
}
function YM(n, e) {
  for (const t of Object.getOwnPropertyNames(e))
    t !== "overrides" && KM(n, {
      extension: t,
      target: n.luma,
      target2: n
    });
}
function KM(n, e) {
  let {
    extension: t,
    target: r,
    target2: i
  } = e;
  const o = Y5[t];
  Ao(o);
  const {
    meta: c = {}
  } = o, {
    suffix: l = ""
  } = c, _ = n.getExtension(t);
  for (const b of Object.keys(o)) {
    const w = "".concat(b).concat(l);
    let T = null;
    b === "meta" || typeof n[b] == "function" || (_ && typeof _[w] == "function" ? T = function() {
      return _[w](...arguments);
    } : typeof o[b] == "function" && (T = o[b].bind(r))), T && (r[b] = T, i[b] = T);
  }
}
const M1 = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  2930: !0,
  3024: !0,
  36006: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32938: 1,
  32939: !1,
  3089: !1,
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  2978: [0, 0, 1024, 1024],
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  35723: 4352,
  36010: null,
  35977: !1,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, Pu = (n, e, t) => e ? n.enable(t) : n.disable(t), Z2 = (n, e, t) => n.hint(t, e), fa = (n, e, t) => n.pixelStorei(t, e), QM = (n, e) => {
  const t = tr(n) ? 36009 : 36160;
  return n.bindFramebuffer(t, e);
}, e4 = (n, e) => n.bindFramebuffer(36008, e);
function Uf(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n);
}
const t4 = {
  3042: Pu,
  32773: (n, e) => n.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (n, e) => n.clearColor(...e),
  3107: (n, e) => n.colorMask(...e),
  2884: Pu,
  2885: (n, e) => n.cullFace(e),
  2929: Pu,
  2931: (n, e) => n.clearDepth(e),
  2932: (n, e) => n.depthFunc(e),
  2928: (n, e) => n.depthRange(...e),
  2930: (n, e) => n.depthMask(e),
  3024: Pu,
  35723: Z2,
  36006: QM,
  2886: (n, e) => n.frontFace(e),
  33170: Z2,
  2849: (n, e) => n.lineWidth(e),
  32823: Pu,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: Pu,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: Pu,
  3088: (n, e) => n.scissor(...e),
  2960: Pu,
  2961: (n, e) => n.clearStencil(e),
  2968: (n, e) => n.stencilMaskSeparate(1028, e),
  36005: (n, e) => n.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (n, e) => n.viewport(...e),
  3333: fa,
  3317: fa,
  37440: fa,
  37441: fa,
  37443: fa,
  3330: fa,
  3332: fa,
  3331: fa,
  36010: e4,
  3314: fa,
  32878: fa,
  3316: fa,
  3315: fa,
  32877: fa,
  framebuffer: (n, e) => {
    const t = e && "handle" in e ? e.handle : e;
    return n.bindFramebuffer(36160, t);
  },
  blend: (n, e) => e ? n.enable(3042) : n.disable(3042),
  blendColor: (n, e) => n.blendColor(...e),
  blendEquation: (n, e) => {
    e = Uf(e) ? e : [e, e], n.blendEquationSeparate(...e);
  },
  blendFunc: (n, e) => {
    e = Uf(e) && e.length === 2 ? [...e, ...e] : e, n.blendFuncSeparate(...e);
  },
  clearColor: (n, e) => n.clearColor(...e),
  clearDepth: (n, e) => n.clearDepth(e),
  clearStencil: (n, e) => n.clearStencil(e),
  colorMask: (n, e) => n.colorMask(...e),
  cull: (n, e) => e ? n.enable(2884) : n.disable(2884),
  cullFace: (n, e) => n.cullFace(e),
  depthTest: (n, e) => e ? n.enable(2929) : n.disable(2929),
  depthFunc: (n, e) => n.depthFunc(e),
  depthMask: (n, e) => n.depthMask(e),
  depthRange: (n, e) => n.depthRange(...e),
  dither: (n, e) => e ? n.enable(3024) : n.disable(3024),
  derivativeHint: (n, e) => {
    n.hint(35723, e);
  },
  frontFace: (n, e) => n.frontFace(e),
  mipmapHint: (n, e) => n.hint(33170, e),
  lineWidth: (n, e) => n.lineWidth(e),
  polygonOffsetFill: (n, e) => e ? n.enable(32823) : n.disable(32823),
  polygonOffset: (n, e) => n.polygonOffset(...e),
  sampleCoverage: (n, e) => n.sampleCoverage(...e),
  scissorTest: (n, e) => e ? n.enable(3089) : n.disable(3089),
  scissor: (n, e) => n.scissor(...e),
  stencilTest: (n, e) => e ? n.enable(2960) : n.disable(2960),
  stencilMask: (n, e) => {
    e = Uf(e) ? e : [e, e];
    const [t, r] = e;
    n.stencilMaskSeparate(1028, t), n.stencilMaskSeparate(1029, r);
  },
  stencilFunc: (n, e) => {
    e = Uf(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, r, i, o, c, l] = e;
    n.stencilFuncSeparate(1028, t, r, i), n.stencilFuncSeparate(1029, o, c, l);
  },
  stencilOp: (n, e) => {
    e = Uf(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, r, i, o, c, l] = e;
    n.stencilOpSeparate(1028, t, r, i), n.stencilOpSeparate(1029, o, c, l);
  },
  viewport: (n, e) => n.viewport(...e)
};
function Ai(n, e, t) {
  return e[n] !== void 0 ? e[n] : t[n];
}
const n4 = {
  blendEquation: (n, e, t) => n.blendEquationSeparate(Ai(32777, e, t), Ai(34877, e, t)),
  blendFunc: (n, e, t) => n.blendFuncSeparate(Ai(32969, e, t), Ai(32968, e, t), Ai(32971, e, t), Ai(32970, e, t)),
  polygonOffset: (n, e, t) => n.polygonOffset(Ai(32824, e, t), Ai(10752, e, t)),
  sampleCoverage: (n, e, t) => n.sampleCoverage(Ai(32938, e, t), Ai(32939, e, t)),
  stencilFuncFront: (n, e, t) => n.stencilFuncSeparate(1028, Ai(2962, e, t), Ai(2967, e, t), Ai(2963, e, t)),
  stencilFuncBack: (n, e, t) => n.stencilFuncSeparate(1029, Ai(34816, e, t), Ai(36003, e, t), Ai(36004, e, t)),
  stencilOpFront: (n, e, t) => n.stencilOpSeparate(1028, Ai(2964, e, t), Ai(2965, e, t), Ai(2966, e, t)),
  stencilOpBack: (n, e, t) => n.stencilOpSeparate(1029, Ai(34817, e, t), Ai(34818, e, t), Ai(34819, e, t))
}, J2 = {
  enable: (n, e) => n({
    [e]: !0
  }),
  disable: (n, e) => n({
    [e]: !1
  }),
  pixelStorei: (n, e, t) => n({
    [e]: t
  }),
  hint: (n, e, t) => n({
    [e]: t
  }),
  bindFramebuffer: (n, e, t) => {
    switch (e) {
      case 36160:
        return n({
          36006: t,
          36010: t
        });
      case 36009:
        return n({
          36006: t
        });
      case 36008:
        return n({
          36010: t
        });
      default:
        return null;
    }
  },
  blendColor: (n, e, t, r, i) => n({
    32773: new Float32Array([e, t, r, i])
  }),
  blendEquation: (n, e) => n({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (n, e, t) => n({
    32777: e,
    34877: t
  }),
  blendFunc: (n, e, t) => n({
    32969: e,
    32968: t,
    32971: e,
    32970: t
  }),
  blendFuncSeparate: (n, e, t, r, i) => n({
    32969: e,
    32968: t,
    32971: r,
    32970: i
  }),
  clearColor: (n, e, t, r, i) => n({
    3106: new Float32Array([e, t, r, i])
  }),
  clearDepth: (n, e) => n({
    2931: e
  }),
  clearStencil: (n, e) => n({
    2961: e
  }),
  colorMask: (n, e, t, r, i) => n({
    3107: [e, t, r, i]
  }),
  cullFace: (n, e) => n({
    2885: e
  }),
  depthFunc: (n, e) => n({
    2932: e
  }),
  depthRange: (n, e, t) => n({
    2928: new Float32Array([e, t])
  }),
  depthMask: (n, e) => n({
    2930: e
  }),
  frontFace: (n, e) => n({
    2886: e
  }),
  lineWidth: (n, e) => n({
    2849: e
  }),
  polygonOffset: (n, e, t) => n({
    32824: e,
    10752: t
  }),
  sampleCoverage: (n, e, t) => n({
    32938: e,
    32939: t
  }),
  scissor: (n, e, t, r, i) => n({
    3088: new Int32Array([e, t, r, i])
  }),
  stencilMask: (n, e) => n({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (n, e, t) => n({
    [e === 1028 ? 2968 : 36005]: t
  }),
  stencilFunc: (n, e, t, r) => n({
    2962: e,
    2967: t,
    2963: r,
    34816: e,
    36003: t,
    36004: r
  }),
  stencilFuncSeparate: (n, e, t, r, i) => n({
    [e === 1028 ? 2962 : 34816]: t,
    [e === 1028 ? 2967 : 36003]: r,
    [e === 1028 ? 2963 : 36004]: i
  }),
  stencilOp: (n, e, t, r) => n({
    2964: e,
    2965: t,
    2966: r,
    34817: e,
    34818: t,
    34819: r
  }),
  stencilOpSeparate: (n, e, t, r, i) => n({
    [e === 1028 ? 2964 : 34817]: t,
    [e === 1028 ? 2965 : 34818]: r,
    [e === 1028 ? 2966 : 34819]: i
  }),
  viewport: (n, e, t, r, i) => n({
    2978: [e, t, r, i]
  })
}, cc = (n, e) => n.isEnabled(e), Y2 = {
  3042: cc,
  2884: cc,
  2929: cc,
  3024: cc,
  32823: cc,
  32926: cc,
  32928: cc,
  3089: cc,
  2960: cc,
  35977: cc
};
function K5(n) {
  for (const e in n)
    return !1;
  return !0;
}
function r4(n, e) {
  if (n === e)
    return !0;
  const t = Array.isArray(n) || ArrayBuffer.isView(n), r = Array.isArray(e) || ArrayBuffer.isView(e);
  if (t && r && n.length === e.length) {
    for (let i = 0; i < n.length; ++i)
      if (n[i] !== e[i])
        return !1;
    return !0;
  }
  return !1;
}
function K2(n, e) {
  const t = n[e].bind(n);
  n[e] = function() {
    const i = arguments.length <= 0 ? void 0 : arguments[0];
    return i in n.state.cache ? n.state.enable ? n.state.cache[i] : t(...arguments) : t(...arguments);
  }, Object.defineProperty(n[e], "name", {
    value: "".concat(e, "-from-cache"),
    configurable: !1
  });
}
function i4(n, e, t) {
  const r = n[e].bind(n);
  n[e] = function() {
    for (var o = arguments.length, c = new Array(o), l = 0; l < o; l++)
      c[l] = arguments[l];
    const {
      valueChanged: _,
      oldValue: b
    } = t(n.state._updateCache, ...c);
    return _ && r(...c), b;
  }, Object.defineProperty(n[e], "name", {
    value: "".concat(e, "-to-cache"),
    configurable: !1
  });
}
function s4(n) {
  const e = n.useProgram.bind(n);
  n.useProgram = function(r) {
    n.state.program !== r && (e(r), n.state.program = r);
  };
}
class o4 {
  constructor(e) {
    let {
      copyState: t = !1,
      log: r = () => {
      }
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.program = null, this.stateStack = [], this.enable = !0, this.cache = t ? l4(e) : Object.assign({}, M1), this.log = r, this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push() {
    this.stateStack.push({});
  }
  pop() {
    Ao(this.stateStack.length > 0);
    const e = this.stateStack[this.stateStack.length - 1];
    su(this.gl, e), this.stateStack.pop();
  }
  _updateCache(e) {
    let t = !1, r;
    const i = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
    for (const o in e) {
      Ao(o !== void 0);
      const c = e[o], l = this.cache[o];
      r4(c, l) || (t = !0, r = l, i && !(o in i) && (i[o] = l), this.cache[o] = c);
    }
    return {
      valueChanged: t,
      oldValue: r
    };
  }
}
function Q5(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    enable: t = !0,
    copyState: r
  } = e;
  if (Ao(r !== void 0), !n.state) {
    const {
      polyfillContext: i
    } = globalThis;
    i && i(n), n.state = new o4(n, {
      copyState: r
    }), s4(n);
    for (const o in J2) {
      const c = J2[o];
      i4(n, o, c);
    }
    K2(n, "getParameter"), K2(n, "isEnabled");
  }
  return n.state.enable = t, n;
}
function a4(n) {
  n.state || Q5(n, {
    copyState: !1
  }), n.state.push();
}
function Q2(n) {
  Ao(n.state), n.state.pop();
}
function su(n, e) {
  if (Ao(Nm(n), "setParameters requires a WebGL context"), K5(e))
    return;
  const t = {};
  for (const i in e) {
    const o = Number(i), c = t4[i];
    c && (typeof c == "string" ? t[c] = !0 : c(n, e[i], o));
  }
  const r = n.state && n.state.cache;
  if (r)
    for (const i in t) {
      const o = n4[i];
      o(n, e, r);
    }
}
function l4(n, e) {
  if (e = e || M1, typeof e == "number") {
    const i = e, o = Y2[i];
    return o ? o(n, i) : n.getParameter(i);
  }
  const t = Array.isArray(e) ? e : Object.keys(e), r = {};
  for (const i of t) {
    const o = Y2[i];
    r[i] = o ? o(n, Number(i)) : n.getParameter(Number(i));
  }
  return r;
}
function c4(n) {
  su(n, M1);
}
function Al(n, e, t) {
  if (K5(e))
    return t(n);
  const {
    nocatch: r = !0
  } = e;
  a4(n), su(n, e);
  let i;
  if (r)
    i = t(n), Q2(n);
  else
    try {
      i = t(n);
    } finally {
      Q2(n);
    }
  return i;
}
function Wd(n) {
  const {
    luma: e
  } = n;
  if (n.canvas && e) {
    const t = e.canvasSizeInfo, r = "clientWidth" in t ? t.clientWidth : n.canvas.clientWidth;
    return r ? n.drawingBufferWidth / r : 1;
  }
  return 1;
}
function t_(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const r = Wd(n), i = n.drawingBufferWidth, o = n.drawingBufferHeight;
  return h4(e, r, i, o, t);
}
function u4(n) {
  const e = typeof window > "u" ? 1 : window.devicePixelRatio || 1;
  return Number.isFinite(n) ? n <= 0 ? 1 : n : n ? e : 1;
}
function h4(n, e, t, r, i) {
  const o = ex(n[0], e, t);
  let c = tx(n[1], e, r, i), l = ex(n[0] + 1, e, t);
  const _ = l === t - 1 ? l : l - 1;
  l = tx(n[1] + 1, e, r, i);
  let b;
  return i ? (l = l === 0 ? l : l + 1, b = c, c = l) : b = l === r - 1 ? l : l - 1, {
    x: o,
    y: c,
    width: Math.max(_ - o + 1, 1),
    height: Math.max(b - c + 1, 1)
  };
}
function ex(n, e, t) {
  return Math.min(Math.round(n * e), t - 1);
}
function tx(n, e, t, r) {
  return r ? Math.max(0, t - 1 - Math.round(n * e)) : Math.min(Math.round(n * e), t - 1);
}
const B1 = lu(), d4 = B1 && typeof document < "u", eS = {
  webgl2: !0,
  webgl1: !0,
  throwOnError: !0,
  manageState: !0,
  canvas: null,
  debug: !1,
  width: 800,
  height: 600
};
function tS() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  Ao(B1, `createGLContext only available in the browser.
Create your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils`), n = Object.assign({}, eS, n);
  const {
    width: e,
    height: t
  } = n;
  function r(l) {
    if (n.throwOnError)
      throw new Error(l);
    return console.error(l), null;
  }
  n.onError = r;
  let i;
  const {
    canvas: o
  } = n, c = m4({
    canvas: o,
    width: e,
    height: t,
    onError: r
  });
  return i = g4(c, n), i ? (i = R1(i, n), _4(i), i) : null;
}
function R1(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!n || n._instrumented)
    return n;
  n._version = n._version || y4(n), n.luma = n.luma || {}, n.luma.canvasSizeInfo = n.luma.canvasSizeInfo || {}, e = Object.assign({}, eS, e);
  const {
    manageState: t,
    debug: r
  } = e;
  return t && Q5(n, {
    copyState: !1,
    log: function() {
      for (var i = arguments.length, o = new Array(i), c = 0; c < i; c++)
        o[c] = arguments[c];
      return ln.log(1, ...o)();
    }
  }), B1 && r && (globalThis.makeDebugContext ? (n = globalThis.makeDebugContext(n, e), ln.level = Math.max(ln.level, 1)) : ln.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()), n._instrumented = !0, n;
}
function f4(n) {
  const e = n.getParameter(7936), t = n.getParameter(7937), r = n.getExtension("WEBGL_debug_renderer_info"), i = r && n.getParameter(r.UNMASKED_VENDOR_WEBGL || 7936), o = r && n.getParameter(r.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: i || e,
    renderer: o || t,
    vendorMasked: e,
    rendererMasked: t,
    version: n.getParameter(7938),
    shadingLanguageVersion: n.getParameter(35724)
  };
}
function p4(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (n.canvas) {
    const r = u4(e.useDevicePixels);
    b4(n, r, e);
    return;
  }
  const t = n.getExtension("STACKGL_resize_drawingbuffer");
  t && "width" in e && "height" in e && t.resize(e.width, e.height);
}
function g4(n, e) {
  const {
    onError: t
  } = e;
  let r = null;
  const i = (_) => r = _.statusMessage || r;
  n.addEventListener("webglcontextcreationerror", i, !1);
  const {
    webgl1: o = !0,
    webgl2: c = !0
  } = e;
  let l = null;
  return c && (l = l || n.getContext("webgl2", e), l = l || n.getContext("experimental-webgl2", e)), o && (l = l || n.getContext("webgl", e), l = l || n.getContext("experimental-webgl", e)), n.removeEventListener("webglcontextcreationerror", i, !1), l ? (e.onContextLost && n.addEventListener("webglcontextlost", e.onContextLost, !1), e.onContextRestored && n.addEventListener("webglcontextrestored", e.onContextRestored, !1), l) : t("Failed to create ".concat(c && !o ? "WebGL2" : "WebGL", " context: ").concat(r || "Unknown error"));
}
function m4(n) {
  let {
    canvas: e,
    width: t = 800,
    height: r = 600,
    onError: i
  } = n, o;
  return typeof e == "string" ? (d4 && document.readyState === "complete" || i("createGLContext called on canvas '".concat(e, "' before page was loaded")), o = document.getElementById(e)) : e ? o = e : (o = document.createElement("canvas"), o.id = "lumagl-canvas", o.style.width = Number.isFinite(t) ? "".concat(t, "px") : "100%", o.style.height = Number.isFinite(r) ? "".concat(r, "px") : "100%", document.body.insertBefore(o, document.body.firstChild)), o;
}
function _4(n) {
  const e = tr(n) ? "WebGL2" : "WebGL1", t = f4(n), r = t ? "(".concat(t.vendor, ",").concat(t.renderer, ")") : "", i = n.debug ? " debug" : "";
  ln.info(1, "".concat(e).concat(i, " context ").concat(r))();
}
function y4(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? 2 : 1;
}
function b4(n, e, t) {
  let r = "width" in t ? t.width : n.canvas.clientWidth, i = "height" in t ? t.height : n.canvas.clientHeight;
  (!r || !i) && (ln.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, r = n.canvas.width || 1, i = n.canvas.height || 1), n.luma = n.luma || {}, n.luma.canvasSizeInfo = n.luma.canvasSizeInfo || {};
  const o = n.luma.canvasSizeInfo;
  if (o.clientWidth !== r || o.clientHeight !== i || o.devicePixelRatio !== e) {
    let c = e;
    const l = Math.floor(r * c), _ = Math.floor(i * c);
    n.canvas.width = l, n.canvas.height = _, (n.drawingBufferWidth !== l || n.drawingBufferHeight !== _) && (ln.warn("Device pixel ratio clamped")(), c = Math.min(n.drawingBufferWidth / r, n.drawingBufferHeight / i), n.canvas.width = Math.floor(r * c), n.canvas.height = Math.floor(i * c)), Object.assign(n.luma.canvasSizeInfo, {
      clientWidth: r,
      clientHeight: i,
      devicePixelRatio: e
    });
  }
}
const lp = "8.5.21", v4 = "set luma.log.level=1 (or higher) to trace rendering";
class x4 {
  constructor() {
    this.stats = /* @__PURE__ */ new Map();
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new Bp({
      id: e
    })), this.stats.get(e);
  }
}
const Ch = new x4();
if (globalThis.luma && globalThis.luma.VERSION !== lp)
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(lp));
globalThis.luma || (lu() && ln.log(1, "luma.gl ".concat(lp, " - ").concat(v4))(), globalThis.luma = globalThis.luma || {
  VERSION: lp,
  version: lp,
  log: ln,
  stats: Ch,
  globals: {
    modules: {},
    nodeIO: {}
  }
});
function w4(n) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(n) : setTimeout(n, 1e3 / 60);
}
function A4(n) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(n) : clearTimeout(n);
}
function Zt(n, e) {
  if (!n)
    throw new Error(e || "luma.gl: assertion failed.");
}
function n_(n, e) {
  if (typeof e != "string")
    return e;
  const t = Number(e);
  if (!isNaN(t))
    return t;
  e = e.replace(/^.*\./, "");
  const r = n[e];
  return Zt(r !== void 0, "Accessing undefined constant GL.".concat(e)), r;
}
function Gu(n, e) {
  e = Number(e);
  for (const t in n)
    if (n[t] === e)
      return "GL.".concat(t);
  return String(e);
}
const r_ = {};
function ou() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  r_[n] = r_[n] || 1;
  const e = r_[n]++;
  return "".concat(n, "-").concat(e);
}
function nx(n) {
  return Zt(typeof n == "number", "Input must be a number"), n && (n & n - 1) === 0;
}
function Xd(n) {
  let e = !0;
  for (const t in n) {
    e = !1;
    break;
  }
  return e;
}
function nS(n, e, t, r) {
  const i = "See luma.gl ".concat(t, " Upgrade Guide at https://luma.gl/docs/upgrade-guide"), o = Object.getPrototypeOf(n);
  r.forEach((c) => {
    o.methodName || (o[c] = () => {
      throw ln.removed("Calling removed method ".concat(e, ".").concat(c, ": "), i)(), new Error(c);
    });
  });
}
const md = "Resource subclass must define virtual methods";
let cu = class {
  get [Symbol.toStringTag]() {
    return "Resource";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    zm(e);
    const {
      id: r,
      userData: i = {}
    } = t;
    this.gl = e, this.gl2 = e, this.id = r || ou(this[Symbol.toStringTag]), this.userData = i, this._bound = !1, this._handle = t.handle, this._handle === void 0 && (this._handle = this._createHandle()), this.byteLength = 0, this._addStats();
  }
  toString() {
    return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
  }
  get handle() {
    return this._handle;
  }
  delete() {
    let {
      deleteChildren: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this._handle && this._deleteHandle(this._handle);
    return this._handle && this._removeStats(), this._handle = null, t && e && t.filter(Boolean).forEach((r) => r.delete()), this;
  }
  bind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
    if (typeof e != "function")
      return this._bindHandle(e), this;
    let t;
    return this._bound ? t = e() : (this._bindHandle(this.handle), this._bound = !0, t = e(), this._bound = !1, this._bindHandle(null)), t;
  }
  unbind() {
    this.bind(null);
  }
  getParameter(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e = n_(this.gl, e), Zt(e);
    const i = (this.constructor.PARAMETERS || {})[e];
    if (i) {
      const o = tr(this.gl);
      if (!((!("webgl2" in i) || o) && (!("extension" in i) || this.gl.getExtension(i.extension)))) {
        const l = i.webgl1, _ = "webgl2" in i ? i.webgl2 : i.webgl1;
        return o ? _ : l;
      }
    }
    return this._getParameter(e, t);
  }
  getParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      parameters: t,
      keys: r
    } = e, i = this.constructor.PARAMETERS || {}, o = tr(this.gl), c = {}, l = t || Object.keys(i);
    for (const _ of l) {
      const b = i[_];
      if (b && (!("webgl2" in b) || o) && (!("extension" in b) || this.gl.getExtension(b.extension))) {
        const T = r ? Gu(this.gl, _) : _;
        c[T] = this.getParameter(_, e), r && b.type === "GLenum" && (c[T] = Gu(this.gl, c[T]));
      }
    }
    return c;
  }
  setParameter(e, t) {
    e = n_(this.gl, e), Zt(e);
    const i = (this.constructor.PARAMETERS || {})[e];
    if (i) {
      const o = tr(this.gl);
      if (!((!("webgl2" in i) || o) && (!("extension" in i) || this.gl.getExtension(i.extension))))
        throw new Error("Parameter not available on this platform");
      i.type === "GLenum" && (t = n_(t));
    }
    return this._setParameter(e, t), this;
  }
  setParameters(e) {
    for (const t in e)
      this.setParameter(t, e[t]);
    return this;
  }
  stubRemovedMethods(e, t, r) {
    return nS(this, e, t, r);
  }
  initialize(e) {
  }
  _createHandle() {
    throw new Error(md);
  }
  _deleteHandle() {
    throw new Error(md);
  }
  _bindHandle(e) {
    throw new Error(md);
  }
  _getOptsFromHandle() {
    throw new Error(md);
  }
  _getParameter(e, t) {
    throw new Error(md);
  }
  _setParameter(e, t) {
    throw new Error(md);
  }
  _context() {
    return this.gl.luma = this.gl.luma || {}, this.gl.luma;
  }
  _addStats() {
    const e = this[Symbol.toStringTag], t = Ch.get("Resource Counts");
    t.get("Resources Created").incrementCount(), t.get("".concat(e, "s Created")).incrementCount(), t.get("".concat(e, "s Active")).incrementCount();
  }
  _removeStats() {
    const e = this[Symbol.toStringTag];
    Ch.get("Resource Counts").get("".concat(e, "s Active")).decrementCount();
  }
  _trackAllocatedMemory(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
    this._trackAllocatedMemoryForContext(e, t), this._trackAllocatedMemoryForContext(e, t, this.gl.canvas && this.gl.canvas.id), this.byteLength = e;
  }
  _trackAllocatedMemoryForContext(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag], r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    const i = Ch.get("Memory Usage".concat(r));
    i.get("GPU Memory").addCount(e), i.get("".concat(t, " Memory")).addCount(e);
  }
  _trackDeallocatedMemory() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
    this._trackDeallocatedMemoryForContext(e), this._trackDeallocatedMemoryForContext(e, this.gl.canvas && this.gl.canvas.id), this.byteLength = 0;
  }
  _trackDeallocatedMemoryForContext() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const r = Ch.get("Memory Usage".concat(t));
    r.get("GPU Memory").subtractCount(this.byteLength), r.get("".concat(e, " Memory")).subtractCount(this.byteLength);
  }
};
const S4 = "Failed to deduce GL constant from typed array";
function gy(n) {
  switch (ArrayBuffer.isView(n) ? n.constructor : n) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(S4);
  }
}
function mp(n) {
  let {
    clamped: e = !0
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  switch (n) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return e ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function E4(n) {
  let {
    data: e,
    width: t,
    height: r,
    bytesPerPixel: i = 4,
    temp: o
  } = n;
  const c = t * i;
  o = o || new Uint8Array(c);
  for (let l = 0; l < r / 2; ++l) {
    const _ = l * c, b = (r - l - 1) * c;
    o.set(e.subarray(_, _ + c)), e.copyWithin(_, b, b + c), e.set(o, b);
  }
}
function T4(n) {
  let {
    data: e,
    width: t,
    height: r
  } = n;
  const i = Math.round(t / 2), o = Math.round(r / 2), c = new Uint8Array(i * o * 4);
  for (let l = 0; l < o; l++)
    for (let _ = 0; _ < i; _++)
      for (let b = 0; b < 4; b++)
        c[(l * i + _) * 4 + b] = e[(l * 2 * t + _ * 2) * 4 + b];
  return {
    data: c,
    width: i,
    height: o
  };
}
function my(n, e, t) {
  const {
    removedProps: r = {},
    deprecatedProps: i = {},
    replacedProps: o = {}
  } = t;
  for (const l in r)
    if (l in e) {
      const b = r[l] ? "".concat(n, ".").concat(r[l]) : "N/A";
      ln.removed("".concat(n, ".").concat(l), b)();
    }
  for (const l in i)
    if (l in e) {
      const _ = i[l];
      ln.deprecated("".concat(n, ".").concat(l), "".concat(n, ".").concat(_))();
    }
  let c = null;
  for (const l in o)
    if (l in e) {
      const _ = o[l];
      ln.deprecated("".concat(n, ".").concat(l), "".concat(n, ".").concat(_))(), c = c || Object.assign({}, e), c[_] = e[l], delete c[l];
    }
  return c || e;
}
const C4 = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: !1,
  integer: !1
}, I4 = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
class Go {
  static getBytesPerElement(e) {
    return mp(e.type || 5126).BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(e) {
    return Zt(e.size), mp(e.type || 5126).BYTES_PER_ELEMENT * e.size;
  }
  static resolve() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return new Go(C4, ...t);
  }
  constructor() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    t.forEach((i) => this._assign(i)), Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  get BYTES_PER_ELEMENT() {
    return Go.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Go.getBytesPerVertex(this);
  }
  _assign() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e = my("Accessor", e, I4), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = !0)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this;
  }
}
const rx = 10, rS = {
  offset: "accessor.offset",
  stride: "accessor.stride",
  type: "accessor.type",
  size: "accessor.size",
  divisor: "accessor.divisor",
  normalized: "accessor.normalized",
  integer: "accessor.integer",
  instanced: "accessor.divisor",
  isInstanced: "accessor.divisor"
}, P4 = {
  removedProps: {},
  replacedProps: {
    bytes: "byteLength"
  },
  deprecatedProps: rS
}, L4 = {
  removedProps: rS
};
let qr = class extends cu {
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]), this.target = t.target || (this.gl.webgl2 ? 36662 : 34962), this.initialize(t), Object.seal(this);
  }
  getElementCount() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Go.getBytesPerElement(e));
  }
  getVertexCount() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Go.getBytesPerVertex(e));
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ArrayBuffer.isView(e) && (e = {
      data: e
    }), Number.isFinite(e) && (e = {
      byteLength: e
    }), e = my("Buffer", e, P4), this.usage = e.usage || 35044, this.debugData = null, this.setAccessor(Object.assign({}, e, e.accessor)), e.data ? this._setData(e.data, e.offset, e.byteLength) : this._setByteLength(e.byteLength || 0), this;
  }
  setProps(e) {
    return e = my("Buffer", e, L4), "accessor" in e && this.setAccessor(e.accessor), this;
  }
  setAccessor(e) {
    return e = Object.assign({}, e), delete e.buffer, this.accessor = new Go(e), this;
  }
  reallocate(e) {
    return e > this.byteLength ? (this._setByteLength(e), !0) : (this.bytesUsed = e, !1);
  }
  setData(e) {
    return this.initialize(e);
  }
  subData(e) {
    ArrayBuffer.isView(e) && (e = {
      data: e
    });
    const {
      data: t,
      offset: r = 0,
      srcOffset: i = 0
    } = e, o = e.byteLength || e.length;
    Zt(t);
    const c = this.gl.webgl2 ? 36663 : this.target;
    return this.gl.bindBuffer(c, this.handle), i !== 0 || o !== void 0 ? (So(this.gl), this.gl.bufferSubData(this.target, r, t, i, o)) : this.gl.bufferSubData(c, r, t), this.gl.bindBuffer(c, null), this.debugData = null, this._inferType(t), this;
  }
  copyData(e) {
    let {
      sourceBuffer: t,
      readOffset: r = 0,
      writeOffset: i = 0,
      size: o
    } = e;
    const {
      gl: c
    } = this;
    return So(c), c.bindBuffer(36662, t.handle), c.bindBuffer(36663, this.handle), c.copyBufferSubData(36662, 36663, r, i, o), c.bindBuffer(36662, null), c.bindBuffer(36663, null), this.debugData = null, this;
  }
  getData() {
    let {
      dstData: e = null,
      srcByteOffset: t = 0,
      dstOffset: r = 0,
      length: i = 0
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    So(this.gl);
    const o = mp(this.accessor.type || 5126, {
      clamped: !1
    }), c = this._getAvailableElementCount(t), l = r;
    let _, b;
    e ? (b = e.length, _ = b - l) : (_ = Math.min(c, i || c), b = l + _);
    const w = Math.min(c, _);
    return i = i || w, Zt(i <= w), e = e || new o(b), this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, t, e, r, i), this.gl.bindBuffer(36662, null), e;
  }
  bind() {
    let {
      target: e = this.target,
      index: t = this.accessor && this.accessor.index,
      offset: r = 0,
      size: i
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e === 35345 || e === 35982 ? i !== void 0 ? this.gl.bindBufferRange(e, t, this.handle, r, i) : (Zt(r === 0), this.gl.bindBufferBase(e, t, this.handle)) : this.gl.bindBuffer(e, this.handle), this;
  }
  unbind() {
    let {
      target: e = this.target,
      index: t = this.accessor && this.accessor.index
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e === 35345 || e === 35982 ? this.gl.bindBufferBase(e, t, null) : this.gl.bindBuffer(e, null), this;
  }
  getDebugData() {
    return this.debugData ? {
      data: this.debugData,
      changed: !1
    } : (this.debugData = this.getData({
      length: Math.min(rx, this.byteLength)
    }), {
      data: this.debugData,
      changed: !0
    });
  }
  invalidateDebugData() {
    this.debugData = null;
  }
  _setData(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.byteLength + t;
    Zt(ArrayBuffer.isView(e)), this._trackDeallocatedMemory();
    const i = this._getTarget();
    this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, r, this.usage), this.gl.bufferSubData(i, t, e), this.gl.bindBuffer(i, null), this.debugData = e.slice(0, rx), this.bytesUsed = r, this._trackAllocatedMemory(r);
    const o = gy(e);
    return Zt(o), this.setAccessor(new Go(this.accessor, {
      type: o
    })), this;
  }
  _setByteLength(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
    Zt(e >= 0), this._trackDeallocatedMemory();
    let r = e;
    e === 0 && (r = new Float32Array(0));
    const i = this._getTarget();
    return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, r, t), this.gl.bindBuffer(i, null), this.usage = t, this.debugData = null, this.bytesUsed = e, this._trackAllocatedMemory(e), this;
  }
  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }
  _getAvailableElementCount(e) {
    const t = mp(this.accessor.type || 5126, {
      clamped: !1
    }), r = e / t.BYTES_PER_ELEMENT;
    return this.getElementCount() - r;
  }
  _inferType(e) {
    this.accessor.type || this.setAccessor(new Go(this.accessor, {
      type: gy(e)
    }));
  }
  _createHandle() {
    return this.gl.createBuffer();
  }
  _deleteHandle() {
    this.gl.deleteBuffer(this.handle), this._trackDeallocatedMemory();
  }
  _getParameter(e) {
    this.gl.bindBuffer(this.target, this.handle);
    const t = this.gl.getBufferParameter(this.target, e);
    return this.gl.bindBuffer(this.target, null), t;
  }
  get type() {
    return ln.deprecated("Buffer.type", "Buffer.accessor.type")(), this.accessor.type;
  }
  get bytes() {
    return ln.deprecated("Buffer.bytes", "Buffer.byteLength")(), this.byteLength;
  }
  setByteLength(e) {
    return ln.deprecated("setByteLength", "reallocate")(), this.reallocate(e);
  }
  updateAccessor(e) {
    return ln.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")(), this.accessor = new Go(this.accessor, e), this;
  }
};
const O1 = {
  6407: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  6408: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  6406: {
    dataFormat: 6406,
    types: [5121]
  },
  6409: {
    dataFormat: 6409,
    types: [5121]
  },
  6410: {
    dataFormat: 6410,
    types: [5121]
  },
  33326: {
    dataFormat: 6403,
    types: [5126],
    gl2: !0
  },
  33328: {
    dataFormat: 33319,
    types: [5126],
    gl2: !0
  },
  34837: {
    dataFormat: 6407,
    types: [5126],
    gl2: !0
  },
  34836: {
    dataFormat: 6408,
    types: [5126],
    gl2: !0
  }
}, iS = {
  6403: 1,
  36244: 1,
  33319: 2,
  33320: 2,
  6407: 3,
  36248: 3,
  6408: 4,
  36249: 4,
  6402: 1,
  34041: 1,
  6406: 1,
  6409: 1,
  6410: 2
}, sS = {
  5126: 4,
  5125: 4,
  5124: 4,
  5123: 2,
  5122: 2,
  5131: 2,
  5120: 1,
  5121: 1
};
function M4(n, e) {
  const t = O1[e];
  if (!t)
    return !1;
  if (t.gl1 === void 0 && t.gl2 === void 0)
    return !0;
  const r = tr(n) && t.gl2 || t.gl1;
  return typeof r == "string" ? n.getExtension(r) : r;
}
function B4(n, e) {
  const t = O1[e];
  switch (t && t.types[0]) {
    case 5126:
      return n.getExtension("OES_texture_float_linear");
    case 5131:
      return n.getExtension("OES_texture_half_float_linear");
    default:
      return !0;
  }
}
const R4 = [9729, 9728], ix = globalThis.WebGLBuffer || function() {
};
class $d extends cu {
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      format: r,
      linearFiltering: i
    } = t;
    let o = !0;
    return r && (o = o && M4(e, r), o = o && (!i || B4(e, r))), o;
  }
  constructor(e, t) {
    const {
      id: r = ou("texture"),
      handle: i,
      target: o
    } = t;
    super(e, {
      id: r,
      handle: i
    }), this.target = o, this.textureUnit = void 0, this.loaded = !1, this.width = void 0, this.height = void 0, this.depth = void 0, this.format = void 0, this.type = void 0, this.dataFormat = void 0, this.border = void 0, this.textureUnit = void 0, this.mipmaps = void 0;
  }
  toString() {
    return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.data;
    if (t instanceof Promise)
      return t.then(($) => this.initialize(Object.assign({}, e, {
        pixels: $,
        data: $
      }))), this;
    const r = typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement;
    if (r && t.readyState < HTMLVideoElement.HAVE_METADATA)
      return this._video = null, t.addEventListener("loadeddata", () => this.initialize(e)), this;
    const {
      pixels: i = null,
      format: o = 6408,
      border: c = 0,
      recreate: l = !1,
      parameters: _ = {},
      pixelStore: b = {},
      textureUnit: w = void 0
    } = e;
    t || (t = i);
    let {
      width: T,
      height: I,
      dataFormat: P,
      type: k,
      compressed: U = !1,
      mipmaps: G = !0
    } = e;
    const {
      depth: H = 0
    } = e;
    return {
      width: T,
      height: I,
      compressed: U,
      dataFormat: P,
      type: k
    } = this._deduceParameters({
      format: o,
      type: k,
      dataFormat: P,
      compressed: U,
      data: t,
      width: T,
      height: I
    }), this.width = T, this.height = I, this.depth = H, this.format = o, this.type = k, this.dataFormat = P, this.border = c, this.textureUnit = w, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), G && this._isNPOT() && (ln.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), G = !1, this._updateForNPOT(_)), this.mipmaps = G, this.setImageData({
      data: t,
      width: T,
      height: I,
      depth: H,
      format: o,
      type: k,
      dataFormat: P,
      border: c,
      mipmaps: G,
      parameters: b,
      compressed: U
    }), G && this.generateMipmap(), this.setParameters(_), l && (this.data = t), r && (this._video = {
      video: t,
      parameters: _,
      lastTime: t.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? t.currentTime : -1
    }), this;
  }
  update() {
    if (this._video) {
      const {
        video: e,
        parameters: t,
        lastTime: r
      } = this._video;
      if (r === e.currentTime || e.readyState < HTMLVideoElement.HAVE_CURRENT_DATA)
        return;
      this.setSubImageData({
        data: e,
        parameters: t
      }), this.mipmaps && this.generateMipmap(), this._video.lastTime = e.currentTime;
    }
  }
  resize(e) {
    let {
      height: t,
      width: r,
      mipmaps: i = !1
    } = e;
    return r !== this.width || t !== this.height ? this.initialize({
      width: r,
      height: t,
      format: this.format,
      type: this.type,
      dataFormat: this.dataFormat,
      border: this.border,
      mipmaps: i
    }) : this;
  }
  generateMipmap() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this._isNPOT() ? (ln.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), this) : (this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), Al(this.gl, e, () => {
      this.gl.generateMipmap(this.target);
    }), this.gl.bindTexture(this.target, null), this);
  }
  setImageData(e) {
    this._trackDeallocatedMemory("Texture");
    const {
      target: t = this.target,
      pixels: r = null,
      level: i = 0,
      format: o = this.format,
      border: c = this.border,
      offset: l = 0,
      parameters: _ = {}
    } = e;
    let {
      data: b = null,
      type: w = this.type,
      width: T = this.width,
      height: I = this.height,
      dataFormat: P = this.dataFormat,
      compressed: k = !1
    } = e;
    b || (b = r), {
      type: w,
      dataFormat: P,
      compressed: k,
      width: T,
      height: I
    } = this._deduceParameters({
      format: o,
      type: w,
      dataFormat: P,
      compressed: k,
      data: b,
      width: T,
      height: I
    });
    const {
      gl: U
    } = this;
    U.bindTexture(this.target, this.handle);
    let G = null;
    ({
      data: b,
      dataType: G
    } = this._getDataType({
      data: b,
      compressed: k
    }));
    let H, $ = 0;
    if (Al(this.gl, _, () => {
      switch (G) {
        case "null":
          U.texImage2D(t, i, o, T, I, c, P, w, b);
          break;
        case "typed-array":
          U.texImage2D(t, i, o, T, I, c, P, w, b, l);
          break;
        case "buffer":
          H = So(U), H.bindBuffer(35052, b.handle || b), H.texImage2D(t, i, o, T, I, c, P, w, l), H.bindBuffer(35052, null);
          break;
        case "browser-object":
          tr(U) ? U.texImage2D(t, i, o, T, I, c, P, w, b) : U.texImage2D(t, i, o, P, w, b);
          break;
        case "compressed":
          for (const [ie, ge] of b.entries())
            U.compressedTexImage2D(t, ie, ge.format, ge.width, ge.height, c, ge.data), $ += ge.levelSize;
          break;
        default:
          Zt(!1, "Unknown image data type");
      }
    }), G === "compressed")
      this._trackAllocatedMemory($, "Texture");
    else if (b && b.byteLength)
      this._trackAllocatedMemory(b.byteLength, "Texture");
    else {
      const ie = iS[this.dataFormat] || 4, ge = sS[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * ie * ge, "Texture");
    }
    return this.loaded = !0, this;
  }
  setSubImageData(e) {
    let {
      target: t = this.target,
      pixels: r = null,
      data: i = null,
      x: o = 0,
      y: c = 0,
      width: l = this.width,
      height: _ = this.height,
      level: b = 0,
      format: w = this.format,
      type: T = this.type,
      dataFormat: I = this.dataFormat,
      compressed: P = !1,
      offset: k = 0,
      border: U = this.border,
      parameters: G = {}
    } = e;
    if ({
      type: T,
      dataFormat: I,
      compressed: P,
      width: l,
      height: _
    } = this._deduceParameters({
      format: w,
      type: T,
      dataFormat: I,
      compressed: P,
      data: i,
      width: l,
      height: _
    }), Zt(this.depth === 0, "texSubImage not supported for 3D textures"), i || (i = r), i && i.data) {
      const H = i;
      i = H.data, l = H.shape[0], _ = H.shape[1];
    }
    i instanceof qr && (i = i.handle), this.gl.bindTexture(this.target, this.handle), Al(this.gl, G, () => {
      if (P)
        this.gl.compressedTexSubImage2D(t, b, o, c, l, _, w, i);
      else if (i === null)
        this.gl.texSubImage2D(t, b, o, c, l, _, I, T, null);
      else if (ArrayBuffer.isView(i))
        this.gl.texSubImage2D(t, b, o, c, l, _, I, T, i, k);
      else if (i instanceof ix) {
        const H = So(this.gl);
        H.bindBuffer(35052, i), H.texSubImage2D(t, b, o, c, l, _, I, T, k), H.bindBuffer(35052, null);
      } else tr(this.gl) ? So(this.gl).texSubImage2D(t, b, o, c, l, _, I, T, i) : this.gl.texSubImage2D(t, b, o, c, I, T, i);
    }), this.gl.bindTexture(this.target, null);
  }
  copyFramebuffer() {
    return ln.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl: t
    } = this;
    return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, this.handle), e;
  }
  unbind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl: t
    } = this;
    return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, null), e;
  }
  _getDataType(e) {
    let {
      data: t,
      compressed: r = !1
    } = e;
    return r ? {
      data: t,
      dataType: "compressed"
    } : t === null ? {
      data: t,
      dataType: "null"
    } : ArrayBuffer.isView(t) ? {
      data: t,
      dataType: "typed-array"
    } : t instanceof qr ? {
      data: t.handle,
      dataType: "buffer"
    } : t instanceof ix ? {
      data: t,
      dataType: "buffer"
    } : {
      data: t,
      dataType: "browser-object"
    };
  }
  _deduceParameters(e) {
    const {
      format: t,
      data: r
    } = e;
    let {
      width: i,
      height: o,
      dataFormat: c,
      type: l,
      compressed: _
    } = e;
    const b = O1[t];
    return c = c || b && b.dataFormat, l = l || b && b.types[0], _ = _ || b && b.compressed, {
      width: i,
      height: o
    } = this._deduceImageSize(r, i, o), {
      dataFormat: c,
      type: l,
      compressed: _,
      width: i,
      height: o,
      format: t,
      data: r
    };
  }
  _deduceImageSize(e, t, r) {
    let i;
    return typeof ImageData < "u" && e instanceof ImageData ? i = {
      width: e.width,
      height: e.height
    } : typeof HTMLImageElement < "u" && e instanceof HTMLImageElement ? i = {
      width: e.naturalWidth,
      height: e.naturalHeight
    } : typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement ? i = {
      width: e.width,
      height: e.height
    } : typeof ImageBitmap < "u" && e instanceof ImageBitmap ? i = {
      width: e.width,
      height: e.height
    } : typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement ? i = {
      width: e.videoWidth,
      height: e.videoHeight
    } : e ? i = {
      width: t,
      height: r
    } : i = {
      width: t >= 0 ? t : 1,
      height: r >= 0 ? r : 1
    }, Zt(i, "Could not deduced texture size"), Zt(t === void 0 || i.width === t, "Deduced texture width does not match supplied width"), Zt(r === void 0 || i.height === r, "Deduced texture height does not match supplied height"), i;
  }
  _createHandle() {
    return this.gl.createTexture();
  }
  _deleteHandle() {
    this.gl.deleteTexture(this.handle), this._trackDeallocatedMemory("Texture");
  }
  _getParameter(e) {
    switch (e) {
      case 4096:
        return this.width;
      case 4097:
        return this.height;
      default:
        this.gl.bindTexture(this.target, this.handle);
        const t = this.gl.getTexParameter(this.target, e);
        return this.gl.bindTexture(this.target, null), t;
    }
  }
  _setParameter(e, t) {
    switch (this.gl.bindTexture(this.target, this.handle), t = this._getNPOTParam(e, t), e) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, e, t);
        break;
      case 4096:
      case 4097:
        Zt(!1);
        break;
      default:
        this.gl.texParameteri(this.target, e, t);
        break;
    }
    return this.gl.bindTexture(this.target, null), this;
  }
  _isNPOT() {
    return tr(this.gl) || !this.width || !this.height ? !1 : !nx(this.width) || !nx(this.height);
  }
  _updateForNPOT(e) {
    e[this.gl.TEXTURE_MIN_FILTER] === void 0 && (e[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR), e[this.gl.TEXTURE_WRAP_S] === void 0 && (e[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE), e[this.gl.TEXTURE_WRAP_T] === void 0 && (e[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE);
  }
  _getNPOTParam(e, t) {
    if (this._isNPOT())
      switch (e) {
        case 10241:
          R4.indexOf(t) === -1 && (t = 9729);
          break;
        case 10242:
        case 10243:
          t !== 33071 && (t = 33071);
          break;
      }
    return t;
  }
}
let O4 = "";
function D4(n, e) {
  return Zt(typeof n == "string"), n = O4 + n, new Promise((t, r) => {
    try {
      const i = new Image();
      i.onload = () => t(i), i.onerror = () => r(new Error("Could not load image ".concat(n, "."))), i.crossOrigin = e && e.crossOrigin || "anonymous", i.src = n;
    } catch (i) {
      r(i);
    }
  });
}
class Aa extends $d {
  get [Symbol.toStringTag]() {
    return "Texture2D";
  }
  static isSupported(e, t) {
    return $d.isSupported(e, t);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    zm(e), (t instanceof Promise || typeof t == "string") && (t = {
      data: t
    }), typeof t.data == "string" && (t = Object.assign({}, t, {
      data: D4(t.data)
    })), super(e, Object.assign({}, t, {
      target: 3553
    })), this.initialize(t), Object.seal(this);
  }
}
const _y = [34069, 34070, 34071, 34072, 34073, 34074];
class oS extends $d {
  get [Symbol.toStringTag]() {
    return "TextureCube";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    zm(e), super(e, Object.assign({}, t, {
      target: 34067
    })), this.initialize(t), Object.seal(this);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      mipmaps: t = !0,
      parameters: r = {}
    } = e;
    return this.opts = e, this.setCubeMapImageData(e).then(() => {
      this.loaded = !0, t && this.generateMipmap(e), this.setParameters(r);
    }), this;
  }
  subImage(e) {
    let {
      face: t,
      data: r,
      x: i = 0,
      y: o = 0,
      mipmapLevel: c = 0
    } = e;
    return this._subImage({
      target: t,
      data: r,
      x: i,
      y: o,
      mipmapLevel: c
    });
  }
  async setCubeMapImageData(e) {
    let {
      width: t,
      height: r,
      pixels: i,
      data: o,
      border: c = 0,
      format: l = 6408,
      type: _ = 5121
    } = e;
    const {
      gl: b
    } = this, w = i || o, T = await Promise.all(_y.map((I) => {
      const P = w[I];
      return Promise.all(Array.isArray(P) ? P : [P]);
    }));
    this.bind(), _y.forEach((I, P) => {
      T[P].length > 1 && this.opts.mipmaps !== !1 && ln.warn("".concat(this.id, " has mipmap and multiple LODs."))(), T[P].forEach((k, U) => {
        t && r ? b.texImage2D(I, U, l, t, r, c, l, _, k) : b.texImage2D(I, U, l, l, _, k);
      });
    }), this.unbind();
  }
  setImageDataForFace(e) {
    const {
      face: t,
      width: r,
      height: i,
      pixels: o,
      data: c,
      border: l = 0,
      format: _ = 6408,
      type: b = 5121
    } = e, {
      gl: w
    } = this, T = o || c;
    return this.bind(), T instanceof Promise ? T.then((I) => this.setImageDataForFace(Object.assign({}, e, {
      face: t,
      data: I,
      pixels: I
    }))) : this.width || this.height ? w.texImage2D(t, 0, _, r, i, l, _, b, T) : w.texImage2D(t, 0, _, _, b, T), this;
  }
}
oS.FACES = _y;
class F4 extends $d {
  get [Symbol.toStringTag]() {
    return "Texture3D";
  }
  static isSupported(e) {
    return tr(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    So(e), t = Object.assign({
      depth: 1
    }, t, {
      target: 32879,
      unpackFlipY: !1
    }), super(e, t), this.initialize(t), Object.seal(this);
  }
  setImageData(e) {
    let {
      level: t = 0,
      dataFormat: r = 6408,
      width: i,
      height: o,
      depth: c = 1,
      border: l = 0,
      format: _,
      type: b = 5121,
      offset: w = 0,
      data: T,
      parameters: I = {}
    } = e;
    if (this._trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle), Al(this.gl, I, () => {
      ArrayBuffer.isView(T) && this.gl.texImage3D(this.target, t, r, i, o, c, l, _, b, T), T instanceof qr && (this.gl.bindBuffer(35052, T.handle), this.gl.texImage3D(this.target, t, r, i, o, c, l, _, b, w));
    }), T && T.byteLength)
      this._trackAllocatedMemory(T.byteLength, "Texture");
    else {
      const P = iS[this.dataFormat] || 4, k = sS[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * this.depth * P * k, "Texture");
    }
    return this.loaded = !0, this;
  }
}
const _h = "EXT_color_buffer_float", sx = {
  33189: {
    bpp: 2
  },
  33190: {
    gl2: !0,
    bpp: 3
  },
  36012: {
    gl2: !0,
    bpp: 4
  },
  36168: {
    bpp: 1
  },
  34041: {
    bpp: 4
  },
  35056: {
    gl2: !0,
    bpp: 4
  },
  36013: {
    gl2: !0,
    bpp: 5
  },
  32854: {
    bpp: 2
  },
  36194: {
    bpp: 2
  },
  32855: {
    bpp: 2
  },
  33321: {
    gl2: !0,
    bpp: 1
  },
  33330: {
    gl2: !0,
    bpp: 1
  },
  33329: {
    gl2: !0,
    bpp: 1
  },
  33332: {
    gl2: !0,
    bpp: 2
  },
  33331: {
    gl2: !0,
    bpp: 2
  },
  33334: {
    gl2: !0,
    bpp: 4
  },
  33333: {
    gl2: !0,
    bpp: 4
  },
  33323: {
    gl2: !0,
    bpp: 2
  },
  33336: {
    gl2: !0,
    bpp: 2
  },
  33335: {
    gl2: !0,
    bpp: 2
  },
  33338: {
    gl2: !0,
    bpp: 4
  },
  33337: {
    gl2: !0,
    bpp: 4
  },
  33340: {
    gl2: !0,
    bpp: 8
  },
  33339: {
    gl2: !0,
    bpp: 8
  },
  32849: {
    gl2: !0,
    bpp: 3
  },
  32856: {
    gl2: !0,
    bpp: 4
  },
  32857: {
    gl2: !0,
    bpp: 4
  },
  36220: {
    gl2: !0,
    bpp: 4
  },
  36238: {
    gl2: !0,
    bpp: 4
  },
  36975: {
    gl2: !0,
    bpp: 4
  },
  36214: {
    gl2: !0,
    bpp: 8
  },
  36232: {
    gl2: !0,
    bpp: 8
  },
  36226: {
    gl2: !0,
    bpp: 16
  },
  36208: {
    gl2: !0,
    bpp: 16
  },
  33325: {
    gl2: _h,
    bpp: 2
  },
  33327: {
    gl2: _h,
    bpp: 4
  },
  34842: {
    gl2: _h,
    bpp: 8
  },
  33326: {
    gl2: _h,
    bpp: 4
  },
  33328: {
    gl2: _h,
    bpp: 8
  },
  34836: {
    gl2: _h,
    bpp: 16
  },
  35898: {
    gl2: _h,
    bpp: 4
  }
};
function k4(n, e, t) {
  const r = t[e];
  if (!r)
    return !1;
  const i = tr(n) && r.gl2 || r.gl1;
  return typeof i == "string" ? n.getExtension(i) : i;
}
class Ld extends cu {
  get [Symbol.toStringTag]() {
    return "Renderbuffer";
  }
  static isSupported(e) {
    let {
      format: t
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      format: null
    };
    return !t || k4(e, t, sx);
  }
  static getSamplesForFormat(e, t) {
    let {
      format: r
    } = t;
    return e.getInternalformatParameter(36161, r, 32937);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.initialize(t), Object.seal(this);
  }
  initialize(e) {
    let {
      format: t,
      width: r = 1,
      height: i = 1,
      samples: o = 0
    } = e;
    return Zt(t, "Needs format"), this._trackDeallocatedMemory(), this.gl.bindRenderbuffer(36161, this.handle), o !== 0 && tr(this.gl) ? this.gl.renderbufferStorageMultisample(36161, o, t, r, i) : this.gl.renderbufferStorage(36161, t, r, i), this.format = t, this.width = r, this.height = i, this.samples = o, this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * sx[this.format].bpp), this;
  }
  resize(e) {
    let {
      width: t,
      height: r
    } = e;
    return t !== this.width || r !== this.height ? this.initialize({
      width: t,
      height: r,
      format: this.format,
      samples: this.samples
    }) : this;
  }
  _createHandle() {
    return this.gl.createRenderbuffer();
  }
  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle), this._trackDeallocatedMemory();
  }
  _bindHandle(e) {
    this.gl.bindRenderbuffer(36161, e);
  }
  _syncHandle(e) {
    this.format = this.getParameter(36164), this.width = this.getParameter(36162), this.height = this.getParameter(36163), this.samples = this.getParameter(36011);
  }
  _getParameter(e) {
    return this.gl.bindRenderbuffer(36161, this.handle), this.gl.getRenderbufferParameter(36161, e);
  }
}
const N4 = 256, z4 = 1024, U4 = 16384, ox = 6144, ax = 6145, lx = 6146, cx = 34041, aS = "clear: bad arguments";
function D1(n) {
  let {
    framebuffer: e = null,
    color: t = null,
    depth: r = null,
    stencil: i = null
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const o = {};
  e && (o.framebuffer = e);
  let c = 0;
  t && (c |= U4, t !== !0 && (o.clearColor = t)), r && (c |= N4, r !== !0 && (o.clearDepth = r)), i && (c |= z4, r !== !0 && (o.clearStencil = r)), Zt(c !== 0, aS), Al(n, o, () => {
    n.clear(c);
  });
}
function j4(n) {
  let {
    framebuffer: e = null,
    buffer: t = ox,
    drawBuffer: r = 0,
    value: i = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  So(n), Al(n, {
    framebuffer: e
  }, () => {
    switch (t) {
      case ox:
        switch (i.constructor) {
          case Int32Array:
            n.clearBufferiv(t, r, i);
            break;
          case Uint32Array:
            n.clearBufferuiv(t, r, i);
            break;
          case Float32Array:
          default:
            n.clearBufferfv(t, r, i);
        }
        break;
      case ax:
        n.clearBufferfv(ax, 0, [i]);
        break;
      case lx:
        n.clearBufferiv(lx, 0, [i]);
        break;
      case cx:
        const [o, c] = i;
        n.clearBufferfi(cx, 0, o, c);
        break;
      default:
        Zt(!1, aS);
    }
  });
}
function G4(n) {
  switch (n) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      return Zt(!1), 0;
  }
}
function Um(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    sourceX: t = 0,
    sourceY: r = 0,
    sourceFormat: i = 6408
  } = e;
  let {
    sourceAttachment: o = 36064,
    target: c = null,
    sourceWidth: l,
    sourceHeight: _,
    sourceType: b
  } = e;
  const {
    framebuffer: w,
    deleteFramebuffer: T
  } = V4(n);
  Zt(w);
  const {
    gl: I,
    handle: P,
    attachments: k
  } = w;
  l = l || w.width, _ = _ || w.height, o === 36064 && P === null && (o = 1028), Zt(k[o]), b = b || k[o].type, c = q4(c, b, i, l, _), b = b || gy(c);
  const U = I.bindFramebuffer(36160, P);
  return I.readPixels(t, r, l, _, i, b, c), I.bindFramebuffer(36160, U || null), T && w.delete(), c;
}
function ux(n) {
  let {
    sourceAttachment: e = 36064,
    targetMaxHeight: t = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = Um(n, {
    sourceAttachment: e
  }), {
    width: i,
    height: o
  } = n;
  for (; o > t; )
    ({
      data: r,
      width: i,
      height: o
    } = T4({
      data: r,
      width: i,
      height: o
    }));
  E4({
    data: r,
    width: i,
    height: o
  });
  const c = document.createElement("canvas");
  c.width = i, c.height = o;
  const l = c.getContext("2d"), _ = l.createImageData(i, o);
  return _.data.set(r), l.putImageData(_, 0, 0), c.toDataURL();
}
function V4(n) {
  return n instanceof os ? {
    framebuffer: n,
    deleteFramebuffer: !1
  } : {
    framebuffer: Q4(n),
    deleteFramebuffer: !0
  };
}
function q4(n, e, t, r, i) {
  if (n)
    return n;
  e = e || 5121;
  const o = mp(e, {
    clamped: !1
  }), c = G4(t);
  return new o(r * i * c);
}
const ei = {
  WEBGL2: "WEBGL2",
  VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
  TIMER_QUERY: "TIMER_QUERY",
  INSTANCED_RENDERING: "INSTANCED_RENDERING",
  MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
  ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
  BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
  FLOAT_BLEND: "FLOAT_BLEND",
  COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
  TEXTURE_DEPTH: "TEXTURE_DEPTH",
  TEXTURE_FLOAT: "TEXTURE_FLOAT",
  TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
  TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
  TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
  COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
  COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
  COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
  GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
  GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
  GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
  GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
};
function H4(n) {
  const e = new Aa(n, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  }), t = new os(n, {
    id: "test-framebuffer",
    check: !1,
    attachments: {
      36064: e
    }
  }), r = t.getStatus();
  return e.delete(), t.delete(), r === 36053;
}
const lS = {
  [ei.WEBGL2]: [!1, !0],
  [ei.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", !0],
  [ei.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
  [ei.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", !0],
  [ei.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", !0],
  [ei.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", !0],
  [ei.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", !0],
  [ei.FLOAT_BLEND]: ["EXT_float_blend"],
  [ei.COLOR_ENCODING_SRGB]: ["EXT_sRGB", !0],
  [ei.TEXTURE_DEPTH]: ["WEBGL_depth_texture", !0],
  [ei.TEXTURE_FLOAT]: ["OES_texture_float", !0],
  [ei.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", !0],
  [ei.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
  [ei.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
  [ei.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
  [ei.COLOR_ATTACHMENT_RGBA32F]: [H4, "EXT_color_buffer_float"],
  [ei.COLOR_ATTACHMENT_FLOAT]: [!1, "EXT_color_buffer_float"],
  [ei.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
  [ei.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", !0],
  [ei.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", !0],
  [ei.GLSL_DERIVATIVES]: ["OES_standard_derivatives", !0],
  [ei.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", !0]
}, W4 = 2;
function F1(n, e) {
  return cS(n, e);
}
function cS(n, e) {
  return e = Array.isArray(e) ? e : [e], e.every((t) => uS(n, t));
}
function X4(n) {
  n.luma = n.luma || {}, n.luma.caps = n.luma.caps || {};
  for (const e in lS)
    n.luma.caps[e] === void 0 && (n.luma.caps[e] = uS(n, e));
  return n.luma.caps;
}
function uS(n, e) {
  return n.luma = n.luma || {}, n.luma.caps = n.luma.caps || {}, n.luma.caps[e] === void 0 && (n.luma.caps[e] = $4(n, e)), n.luma.caps[e] || ln.log(W4, "Feature: ".concat(e, " not supported"))(), n.luma.caps[e];
}
function $4(n, e) {
  const t = lS[e];
  Zt(t, e);
  let r;
  const i = tr(n) && t[1] || t[0];
  if (typeof i == "function")
    r = i(n);
  else if (Array.isArray(i)) {
    r = !0;
    for (const o of i)
      r = r && !!n.getExtension(o);
  } else typeof i == "string" ? r = !!n.getExtension(i) : typeof i == "boolean" ? r = i : Zt(!1);
  return r;
}
const hx = "Multiple render targets not supported";
class os extends cu {
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      colorBufferFloat: r,
      colorBufferHalfFloat: i
    } = t;
    let o = !0;
    return r && (o = !!(e.getExtension("EXT_color_buffer_float") || e.getExtension("WEBGL_color_buffer_float") || e.getExtension("OES_texture_float"))), i && (o = o && !!(e.getExtension("EXT_color_buffer_float") || e.getExtension("EXT_color_buffer_half_float"))), o;
  }
  static getDefaultFramebuffer(e) {
    return e.luma = e.luma || {}, e.luma.defaultFramebuffer = e.luma.defaultFramebuffer || new os(e, {
      id: "default-framebuffer",
      handle: null,
      attachments: {}
    }), e.luma.defaultFramebuffer;
  }
  get MAX_COLOR_ATTACHMENTS() {
    const e = So(this.gl);
    return e.getParameter(e.MAX_COLOR_ATTACHMENTS);
  }
  get MAX_DRAW_BUFFERS() {
    const e = So(this.gl);
    return e.getParameter(e.MAX_DRAW_BUFFERS);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.width = null, this.height = null, this.attachments = {}, this.readBuffer = 36064, this.drawBuffers = [36064], this.ownResources = [], this.initialize(t), Object.seal(this);
  }
  get color() {
    return this.attachments[36064] || null;
  }
  get texture() {
    return this.attachments[36064] || null;
  }
  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }
  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }
  initialize(e) {
    let {
      width: t = 1,
      height: r = 1,
      attachments: i = null,
      color: o = !0,
      depth: c = !0,
      stencil: l = !1,
      check: _ = !0,
      readBuffer: b = void 0,
      drawBuffers: w = void 0
    } = e;
    if (Zt(t >= 0 && r >= 0, "Width and height need to be integers"), this.width = t, this.height = r, i)
      for (const T in i) {
        const I = i[T];
        (Array.isArray(I) ? I[0] : I).resize({
          width: t,
          height: r
        });
      }
    else
      i = this._createDefaultAttachments(o, c, l, t, r);
    this.update({
      clearAttachments: !0,
      attachments: i,
      readBuffer: b,
      drawBuffers: w
    }), i && _ && this.checkStatus();
  }
  delete() {
    for (const e of this.ownResources)
      e.delete();
    return super.delete(), this;
  }
  update(e) {
    let {
      attachments: t = {},
      readBuffer: r,
      drawBuffers: i,
      clearAttachments: o = !1,
      resizeAttachments: c = !0
    } = e;
    this.attach(t, {
      clearAttachments: o,
      resizeAttachments: c
    });
    const {
      gl: l
    } = this, _ = l.bindFramebuffer(36160, this.handle);
    return r && this._setReadBuffer(r), i && this._setDrawBuffers(i), l.bindFramebuffer(36160, _ || null), this;
  }
  resize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
      width: t,
      height: r
    } = e;
    if (this.handle === null)
      return Zt(t === void 0 && r === void 0), this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
    t === void 0 && (t = this.gl.drawingBufferWidth), r === void 0 && (r = this.gl.drawingBufferHeight), t !== this.width && r !== this.height && ln.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(t, "x").concat(r))();
    for (const i in this.attachments)
      this.attachments[i].resize({
        width: t,
        height: r
      });
    return this.width = t, this.height = r, this;
  }
  attach(e) {
    let {
      clearAttachments: t = !1,
      resizeAttachments: r = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = {};
    t && Object.keys(this.attachments).forEach((c) => {
      i[c] = null;
    }), Object.assign(i, e);
    const o = this.gl.bindFramebuffer(36160, this.handle);
    for (const c in i) {
      Zt(c !== void 0, "Misspelled framebuffer binding point?");
      const l = Number(c), _ = i[l];
      let b = _;
      if (!b)
        this._unattach(l);
      else if (b instanceof Ld)
        this._attachRenderbuffer({
          attachment: l,
          renderbuffer: b
        });
      else if (Array.isArray(_)) {
        const [w, T = 0, I = 0] = _;
        b = w, this._attachTexture({
          attachment: l,
          texture: w,
          layer: T,
          level: I
        });
      } else
        this._attachTexture({
          attachment: l,
          texture: b,
          layer: 0,
          level: 0
        });
      r && b && b.resize({
        width: this.width,
        height: this.height
      });
    }
    this.gl.bindFramebuffer(36160, o || null), Object.assign(this.attachments, e), Object.keys(this.attachments).filter((c) => !this.attachments[c]).forEach((c) => {
      delete this.attachments[c];
    });
  }
  checkStatus() {
    const e = this.getStatus();
    if (e !== 36053)
      throw new Error(J4(e));
    return this;
  }
  getStatus() {
    const {
      gl: e
    } = this, t = e.bindFramebuffer(36160, this.handle), r = e.checkFramebufferStatus(36160);
    return e.bindFramebuffer(36160, t || null), r;
  }
  clear() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      color: t,
      depth: r,
      stencil: i,
      drawBuffers: o = []
    } = e, c = this.gl.bindFramebuffer(36160, this.handle);
    return (t || r || i) && D1(this.gl, {
      color: t,
      depth: r,
      stencil: i
    }), o.forEach((l, _) => {
      j4(this.gl, {
        drawBuffer: _,
        value: l
      });
    }), this.gl.bindFramebuffer(36160, c || null), this;
  }
  readPixels() {
    return ln.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")(), null;
  }
  readPixelsToBuffer() {
    return ln.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")(), null;
  }
  copyToDataUrl() {
    return ln.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")(), null;
  }
  copyToImage() {
    return ln.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")(), null;
  }
  copyToTexture() {
    return ln.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  blit() {
    return ln.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")(), null;
  }
  invalidate(e) {
    let {
      attachments: t = [],
      x: r = 0,
      y: i = 0,
      width: o,
      height: c
    } = e;
    const l = So(this.gl), _ = l.bindFramebuffer(36008, this.handle);
    return r === 0 && i === 0 && o === void 0 && c === void 0 ? l.invalidateFramebuffer(36008, t) : l.invalidateFramebuffer(36008, t, r, i, o, c), l.bindFramebuffer(36008, _), this;
  }
  getAttachmentParameter(e, t, r) {
    let i = this._getAttachmentParameterFallback(t);
    return i === null && (this.gl.bindFramebuffer(36160, this.handle), i = this.gl.getFramebufferAttachmentParameter(36160, e, t), this.gl.bindFramebuffer(36160, null)), r && i > 1e3 && (i = Gu(this.gl, i)), i;
  }
  getAttachmentParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
    const i = {};
    for (const o of r) {
      const c = t ? Gu(this.gl, o) : o;
      i[c] = this.getAttachmentParameter(e, o, t);
    }
    return i;
  }
  getParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    const t = Object.keys(this.attachments), r = {};
    for (const i of t) {
      const o = Number(i), c = e ? Gu(this.gl, o) : o;
      r[c] = this.getAttachmentParameters(o, e);
    }
    return r;
  }
  show() {
    return typeof window < "u" && window.open(ux(this), "luma-debug-texture"), this;
  }
  log() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (e > ln.level || typeof window > "u")
      return this;
    t = t || "Framebuffer ".concat(this.id);
    const r = ux(this, {
      targetMaxHeight: 100
    });
    return ln.image({
      logLevel: e,
      message: t,
      image: r
    }, t)(), this;
  }
  bind() {
    let {
      target: e = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.gl.bindFramebuffer(e, this.handle), this;
  }
  unbind() {
    let {
      target: e = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.gl.bindFramebuffer(e, null), this;
  }
  _createDefaultAttachments(e, t, r, i, o) {
    let c = null;
    return e && (c = c || {}, c[36064] = new Aa(this.gl, {
      id: "".concat(this.id, "-color0"),
      pixels: null,
      format: 6408,
      type: 5121,
      width: i,
      height: o,
      mipmaps: !1,
      parameters: {
        10241: 9729,
        10240: 9729,
        10242: 33071,
        10243: 33071
      }
    }), this.ownResources.push(c[36064])), t && r ? (c = c || {}, c[33306] = new Ld(this.gl, {
      id: "".concat(this.id, "-depth-stencil"),
      format: 35056,
      width: i,
      height: 111
    }), this.ownResources.push(c[33306])) : t ? (c = c || {}, c[36096] = new Ld(this.gl, {
      id: "".concat(this.id, "-depth"),
      format: 33189,
      width: i,
      height: o
    }), this.ownResources.push(c[36096])) : r && Zt(!1), c;
  }
  _unattach(e) {
    const t = this.attachments[e];
    t && (t instanceof Ld ? this.gl.framebufferRenderbuffer(36160, e, 36161, null) : this.gl.framebufferTexture2D(36160, e, 3553, null, 0), delete this.attachments[e]);
  }
  _attachRenderbuffer(e) {
    let {
      attachment: t = 36064,
      renderbuffer: r
    } = e;
    const {
      gl: i
    } = this;
    i.framebufferRenderbuffer(36160, t, 36161, r.handle), this.attachments[t] = r;
  }
  _attachTexture(e) {
    let {
      attachment: t = 36064,
      texture: r,
      layer: i,
      level: o
    } = e;
    const {
      gl: c
    } = this;
    switch (c.bindTexture(r.target, r.handle), r.target) {
      case 35866:
      case 32879:
        So(c).framebufferTextureLayer(36160, t, r.target, o, i);
        break;
      case 34067:
        const _ = Z4(i);
        c.framebufferTexture2D(36160, t, _, r.handle, o);
        break;
      case 3553:
        c.framebufferTexture2D(36160, t, 3553, r.handle, o);
        break;
      default:
        Zt(!1, "Illegal texture type");
    }
    c.bindTexture(r.target, null), this.attachments[t] = r;
  }
  _setReadBuffer(e) {
    const t = EM(this.gl);
    t ? t.readBuffer(e) : Zt(e === 36064 || e === 1029, hx), this.readBuffer = e;
  }
  _setDrawBuffers(e) {
    const {
      gl: t
    } = this, r = So(t);
    if (r)
      r.drawBuffers(e);
    else {
      const i = t.getExtension("WEBGL_draw_buffers");
      i ? i.drawBuffersWEBGL(e) : Zt(e.length === 1 && (e[0] === 36064 || e[0] === 1029), hx);
    }
    this.drawBuffers = e;
  }
  _getAttachmentParameterFallback(e) {
    const t = X4(this.gl);
    switch (e) {
      case 36052:
        return t.WEBGL2 ? null : 0;
      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return t.WEBGL2 ? null : 8;
      case 33297:
        return t.WEBGL2 ? null : 5125;
      case 33296:
        return !t.WEBGL2 && !t.EXT_sRGB ? 9729 : null;
      default:
        return null;
    }
  }
  _createHandle() {
    return this.gl.createFramebuffer();
  }
  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }
  _bindHandle(e) {
    return this.gl.bindFramebuffer(36160, e);
  }
}
function Z4(n) {
  return n < 34069 ? n + 34069 : n;
}
function J4(n) {
  return (os.STATUS || {})[n] || "Framebuffer error ".concat(n);
}
const Y4 = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
os.ATTACHMENT_PARAMETERS = Y4;
function K4(n, e) {
  Zt(n instanceof Aa || n instanceof oS || n instanceof F4);
  const t = n.constructor, {
    gl: r,
    width: i,
    height: o,
    format: c,
    type: l,
    dataFormat: _,
    border: b,
    mipmaps: w
  } = n, T = Object.assign({
    width: i,
    height: o,
    format: c,
    type: l,
    dataFormat: _,
    border: b,
    mipmaps: w
  }, e);
  return new t(r, T);
}
function Q4(n, e) {
  const {
    gl: t,
    width: r,
    height: i,
    id: o
  } = n;
  return new os(t, Object.assign({}, e, {
    id: "framebuffer-for-".concat(o),
    width: r,
    height: i,
    attachments: {
      36064: n
    }
  }));
}
function Hg(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const t = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/, r = n.match(t);
  return r ? r[1] : e;
}
const eB = 35632, tB = 35633;
function nB(n) {
  switch (n) {
    case eB:
      return "fragment";
    case tB:
      return "vertex";
    default:
      return "unknown type";
  }
}
function rB(n, e, t, r) {
  const i = n.split(/\r?\n/), o = {}, c = {}, l = r || Hg(e) || "(unnamed)", _ = "".concat(nB(t), " shader ").concat(l);
  for (let w = 0; w < i.length; w++) {
    const T = i[w];
    if (T.length <= 1)
      continue;
    const I = T.split(":"), P = I[0], k = parseInt(I[2], 10);
    if (isNaN(k))
      throw new Error("GLSL compilation error in ".concat(_, ": ").concat(n));
    P !== "WARNING" ? o[k] = T : c[k] = T;
  }
  const b = iB(e);
  return {
    shaderName: _,
    errors: dx(o, b),
    warnings: dx(c, b)
  };
}
function dx(n, e) {
  let t = "";
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (!(!n[r + 3] && !n[r + 2] && !n[r + 1]) && (t += "".concat(i, `
`), n[r + 1])) {
      const o = n[r + 1], c = o.split(":", 3), l = c[0], _ = parseInt(c[1], 10) || 0, b = o.substring(c.join(":").length + 1).trim();
      t += hS("^^^ ".concat(l, ": ").concat(b, `

`), _);
    }
  }
  return t;
}
function iB(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
  const r = n.split(/\r?\n/), i = String(r.length + e - 1).length;
  return r.map((o, c) => {
    const l = String(c + e), _ = l.length;
    return hS(l, i - _) + t + o;
  });
}
function hS(n, e) {
  let t = "";
  for (let r = 0; r < e; ++r)
    t += " ";
  return "".concat(t).concat(n);
}
function dS(n) {
  let e = 100;
  const t = n.match(/[^\s]+/g);
  if (t.length >= 2 && t[0] === "#version") {
    const r = parseInt(t[1], 10);
    Number.isFinite(r) && (e = r);
  }
  return e;
}
const sB = "Shader: GLSL source code must be a JavaScript string";
class _p extends cu {
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  static getTypeName(e) {
    switch (e) {
      case 35633:
        return "vertex-shader";
      case 35632:
        return "fragment-shader";
      default:
        return Zt(!1), "unknown";
    }
  }
  constructor(e, t) {
    zm(e), Zt(typeof t.source == "string", sB);
    const r = Hg(t.source, null) || t.id || ou("unnamed ".concat(_p.getTypeName(t.shaderType)));
    super(e, {
      id: r
    }), this.shaderType = t.shaderType, this.source = t.source, this.initialize(t);
  }
  initialize(e) {
    let {
      source: t
    } = e;
    const r = Hg(t, null);
    r && (this.id = ou(r)), this._compile(t);
  }
  getParameter(e) {
    return this.gl.getShaderParameter(this.handle, e);
  }
  toString() {
    return "".concat(_p.getTypeName(this.shaderType), ":").concat(this.id);
  }
  getName() {
    return Hg(this.source) || "unnamed-shader";
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  getTranslatedSource() {
    const e = this.gl.getExtension("WEBGL_debug_shaders");
    return e ? e.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
  }
  _compile() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
    if (e.startsWith("#version ") || (e = `#version 100
`.concat(e)), this.source = e, this.gl.shaderSource(this.handle, this.source), this.gl.compileShader(this.handle), !this.getParameter(35713)) {
      const r = this.gl.getShaderInfoLog(this.handle), {
        shaderName: i,
        errors: o,
        warnings: c
      } = rB(r, this.source, this.shaderType, this.id);
      throw ln.error("GLSL compilation errors in ".concat(i, `
`).concat(o))(), ln.warn("GLSL compilation warnings in ".concat(i, `
`).concat(c))(), new Error("GLSL compilation errors in ".concat(i));
    }
  }
  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }
}
class i_ extends _p {
  get [Symbol.toStringTag]() {
    return "VertexShader";
  }
  constructor(e, t) {
    typeof t == "string" && (t = {
      source: t
    }), super(e, Object.assign({}, t, {
      shaderType: 35633
    }));
  }
  _createHandle() {
    return this.gl.createShader(35633);
  }
}
class s_ extends _p {
  get [Symbol.toStringTag]() {
    return "FragmentShader";
  }
  constructor(e, t) {
    typeof t == "string" && (t = {
      source: t
    }), super(e, Object.assign({}, t, {
      shaderType: 35632
    }));
  }
  _createHandle() {
    return this.gl.createShader(35632);
  }
}
const oB = {
  5126: li.bind(null, "uniform1fv", pa, 1, Zs),
  35664: li.bind(null, "uniform2fv", pa, 2, Zs),
  35665: li.bind(null, "uniform3fv", pa, 3, Zs),
  35666: li.bind(null, "uniform4fv", pa, 4, Zs),
  5124: li.bind(null, "uniform1iv", Lu, 1, Zs),
  35667: li.bind(null, "uniform2iv", Lu, 2, Zs),
  35668: li.bind(null, "uniform3iv", Lu, 3, Zs),
  35669: li.bind(null, "uniform4iv", Lu, 4, Zs),
  35670: li.bind(null, "uniform1iv", Lu, 1, Zs),
  35671: li.bind(null, "uniform2iv", Lu, 2, Zs),
  35672: li.bind(null, "uniform3iv", Lu, 3, Zs),
  35673: li.bind(null, "uniform4iv", Lu, 4, Zs),
  35674: li.bind(null, "uniformMatrix2fv", pa, 4, Xc),
  35675: li.bind(null, "uniformMatrix3fv", pa, 9, Xc),
  35676: li.bind(null, "uniformMatrix4fv", pa, 16, Xc),
  35678: Bs,
  35680: Bs,
  5125: li.bind(null, "uniform1uiv", gg, 1, Zs),
  36294: li.bind(null, "uniform2uiv", gg, 2, Zs),
  36295: li.bind(null, "uniform3uiv", gg, 3, Zs),
  36296: li.bind(null, "uniform4uiv", gg, 4, Zs),
  35685: li.bind(null, "uniformMatrix2x3fv", pa, 6, Xc),
  35686: li.bind(null, "uniformMatrix2x4fv", pa, 8, Xc),
  35687: li.bind(null, "uniformMatrix3x2fv", pa, 6, Xc),
  35688: li.bind(null, "uniformMatrix3x4fv", pa, 12, Xc),
  35689: li.bind(null, "uniformMatrix4x2fv", pa, 8, Xc),
  35690: li.bind(null, "uniformMatrix4x3fv", pa, 12, Xc),
  35678: Bs,
  35680: Bs,
  35679: Bs,
  35682: Bs,
  36289: Bs,
  36292: Bs,
  36293: Bs,
  36298: Bs,
  36299: Bs,
  36300: Bs,
  36303: Bs,
  36306: Bs,
  36307: Bs,
  36308: Bs,
  36311: Bs
}, aB = {}, lB = {}, cB = {}, fx = [0];
function k1(n, e, t, r) {
  e === 1 && typeof n == "boolean" && (n = n ? 1 : 0), Number.isFinite(n) && (fx[0] = n, n = fx);
  const i = n.length;
  if (i % e && ln.warn("Uniform size should be multiples of ".concat(e), n)(), n instanceof t)
    return n;
  let o = r[i];
  o || (o = new t(i), r[i] = o);
  for (let c = 0; c < i; c++)
    o[c] = n[c];
  return o;
}
function pa(n, e) {
  return k1(n, e, Float32Array, aB);
}
function Lu(n, e) {
  return k1(n, e, Int32Array, lB);
}
function gg(n, e) {
  return k1(n, e, Uint32Array, cB);
}
function px(n, e, t) {
  const r = oB[t.type];
  if (!r)
    throw new Error("Unknown GLSL uniform type ".concat(t.type));
  return r().bind(null, n, e);
}
function uB(n) {
  if (n[n.length - 1] !== "]")
    return {
      name: n,
      length: 1,
      isArray: !1
    };
  const e = /([^[]*)(\[[0-9]+\])?/, t = n.match(e);
  if (!t || t.length < 2)
    throw new Error("Failed to parse GLSL uniform name ".concat(n));
  return {
    name: t[1],
    length: t[2] || 1,
    isArray: !!t[2]
  };
}
function hB(n, e, t) {
  for (const r in n) {
    const i = n[r];
    if ((!t || !!t[r]) && !dB(i))
      throw e = e ? "".concat(e, " ") : "", console.error("".concat(e, " Bad uniform ").concat(r), i), new Error("".concat(e, " Bad uniform ").concat(r));
  }
  return !0;
}
function dB(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) ? pB(n) : isFinite(n) || n === !0 || n === !1 || n instanceof $d || n instanceof Ld ? !0 : n instanceof os ? !!n.texture : !1;
}
function fB(n, e, t) {
  if (Array.isArray(t) || ArrayBuffer.isView(t))
    if (n[e]) {
      const r = n[e];
      for (let i = 0, o = t.length; i < o; ++i)
        r[i] = t[i];
    } else
      n[e] = t.slice();
  else
    n[e] = t;
}
function pB(n) {
  if (n.length === 0)
    return !1;
  const e = Math.min(n.length, 16);
  for (let t = 0; t < e; ++t)
    if (!Number.isFinite(n[t]))
      return !1;
  return !0;
}
function Bs() {
  let n = null;
  return (e, t, r) => {
    const i = n !== r;
    return i && (e.uniform1i(t, r), n = r), i;
  };
}
function li(n, e, t, r) {
  let i = null, o = null;
  return (c, l, _) => {
    const b = e(_, t), w = b.length;
    let T = !1;
    if (i === null)
      i = new Float32Array(w), o = w, T = !0;
    else {
      Zt(o === w, "Uniform length cannot change.");
      for (let I = 0; I < w; ++I)
        if (b[I] !== i[I]) {
          T = !0;
          break;
        }
    }
    return T && (r(c, n, l, b), i.set(b)), T;
  };
}
function Zs(n, e, t, r) {
  n[e](t, r);
}
function Xc(n, e, t, r) {
  n[e](t, !1, r);
}
const gB = 5120, mB = 5121, _B = 5122, yB = 5123, gx = 0, mg = 1, bB = 2, vB = 3, _g = 4, xB = 5, wB = 6, is = 5126, AB = 35664, SB = 35665, EB = 35666, jf = 5124, TB = 35667, CB = 35668, IB = 35669, Gf = 5125, PB = 36294, LB = 36295, MB = 36296, BB = 35670, RB = 35671, OB = 35672, DB = 35673, FB = 35674, kB = 35675, NB = 35676, zB = 35685, UB = 35686, jB = 35687, GB = 35688, VB = 35689, qB = 35690, yy = {
  [is]: [is, 1, "float"],
  [AB]: [is, 2, "vec2"],
  [SB]: [is, 3, "vec3"],
  [EB]: [is, 4, "vec4"],
  [jf]: [jf, 1, "int"],
  [TB]: [jf, 2, "ivec2"],
  [CB]: [jf, 3, "ivec3"],
  [IB]: [jf, 4, "ivec4"],
  [Gf]: [Gf, 1, "uint"],
  [PB]: [Gf, 2, "uvec2"],
  [LB]: [Gf, 3, "uvec3"],
  [MB]: [Gf, 4, "uvec4"],
  [BB]: [is, 1, "bool"],
  [RB]: [is, 2, "bvec2"],
  [OB]: [is, 3, "bvec3"],
  [DB]: [is, 4, "bvec4"],
  [FB]: [is, 8, "mat2"],
  [zB]: [is, 8, "mat2x3"],
  [UB]: [is, 8, "mat2x4"],
  [kB]: [is, 12, "mat3"],
  [jB]: [is, 12, "mat3x2"],
  [GB]: [is, 12, "mat3x4"],
  [NB]: [is, 16, "mat4"],
  [VB]: [is, 16, "mat4x2"],
  [qB]: [is, 16, "mat4x3"]
};
function HB(n) {
  switch (n) {
    case gx:
      return gx;
    case mg:
      return mg;
    case vB:
      return mg;
    case bB:
      return mg;
    case _g:
      return _g;
    case xB:
      return _g;
    case wB:
      return _g;
    default:
      return Zt(!1), 0;
  }
}
function mx(n) {
  const e = yy[n];
  if (!e)
    return null;
  const [t, r] = e;
  return {
    type: t,
    components: r
  };
}
function fS(n, e) {
  switch (n) {
    case gB:
    case mB:
    case _B:
    case yB:
      n = is;
      break;
  }
  for (const t in yy) {
    const [r, i, o] = yy[t];
    if (r === n && i === e)
      return {
        glType: t,
        name: o
      };
  }
  return null;
}
class WB {
  constructor(e) {
    this.id = e.id, this.attributeInfos = [], this.attributeInfosByName = {}, this.attributeInfosByLocation = [], this.varyingInfos = [], this.varyingInfosByName = {}, Object.seal(this), this._readAttributesFromProgram(e), this._readVaryingsFromProgram(e);
  }
  getAttributeInfo(e) {
    const t = Number(e);
    return Number.isFinite(t) ? this.attributeInfosByLocation[t] : this.attributeInfosByName[e] || null;
  }
  getAttributeLocation(e) {
    const t = this.getAttributeInfo(e);
    return t ? t.location : -1;
  }
  getAttributeAccessor(e) {
    const t = this.getAttributeInfo(e);
    return t ? t.accessor : null;
  }
  getVaryingInfo(e) {
    const t = Number(e);
    return Number.isFinite(t) ? this.varyingInfos[t] : this.varyingInfosByName[e] || null;
  }
  getVaryingIndex(e) {
    const t = this.getVaryingInfo();
    return t ? t.location : -1;
  }
  getVaryingAccessor(e) {
    const t = this.getVaryingInfo();
    return t ? t.accessor : null;
  }
  _readAttributesFromProgram(e) {
    const {
      gl: t
    } = e, r = t.getProgramParameter(e.handle, 35721);
    for (let i = 0; i < r; i++) {
      const {
        name: o,
        type: c,
        size: l
      } = t.getActiveAttrib(e.handle, i), _ = t.getAttribLocation(e.handle, o);
      _ >= 0 && this._addAttribute(_, o, c, l);
    }
    this.attributeInfos.sort((i, o) => i.location - o.location);
  }
  _readVaryingsFromProgram(e) {
    const {
      gl: t
    } = e;
    if (!tr(t))
      return;
    const r = t.getProgramParameter(e.handle, 35971);
    for (let i = 0; i < r; i++) {
      const {
        name: o,
        type: c,
        size: l
      } = t.getTransformFeedbackVarying(e.handle, i);
      this._addVarying(i, o, c, l);
    }
    this.varyingInfos.sort((i, o) => i.location - o.location);
  }
  _addAttribute(e, t, r, i) {
    const {
      type: o,
      components: c
    } = mx(r), l = {
      type: o,
      size: i * c
    };
    this._inferProperties(e, t, l);
    const _ = {
      location: e,
      name: t,
      accessor: new Go(l)
    };
    this.attributeInfos.push(_), this.attributeInfosByLocation[e] = _, this.attributeInfosByName[_.name] = _;
  }
  _inferProperties(e, t, r) {
    /instance/i.test(t) && (r.divisor = 1);
  }
  _addVarying(e, t, r, i) {
    const {
      type: o,
      components: c
    } = mx(r), l = new Go({
      type: o,
      size: i * c
    }), _ = {
      location: e,
      name: t,
      accessor: l
    };
    this.varyingInfos.push(_), this.varyingInfosByName[_.name] = _;
  }
}
const _x = 4, XB = 35981, $B = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
class pS extends cu {
  get [Symbol.toStringTag]() {
    return "Program";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.stubRemovedMethods("Program", "v6.0", $B), this._isCached = !1, this.initialize(t), Object.seal(this), this._setId(t.id);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      hash: t,
      vs: r,
      fs: i,
      varyings: o,
      bufferMode: c = XB
    } = e;
    return this.hash = t || "", this.vs = typeof r == "string" ? new i_(this.gl, {
      id: "".concat(e.id, "-vs"),
      source: r
    }) : r, this.fs = typeof i == "string" ? new s_(this.gl, {
      id: "".concat(e.id, "-fs"),
      source: i
    }) : i, Zt(this.vs instanceof i_), Zt(this.fs instanceof s_), this.uniforms = {}, this._textureUniforms = {}, o && o.length > 0 && (So(this.gl), this.varyings = o, this.gl2.transformFeedbackVaryings(this.handle, o, c)), this._compileAndLink(), this._readUniformLocationsFromLinkedProgram(), this.configuration = new WB(this), this.setProps(e);
  }
  delete() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this._isCached ? this : super.delete(e);
  }
  setProps(e) {
    return "uniforms" in e && this.setUniforms(e.uniforms), this;
  }
  draw(e) {
    let {
      logPriority: t,
      drawMode: r = 4,
      vertexCount: i,
      offset: o = 0,
      start: c,
      end: l,
      isIndexed: _ = !1,
      indexType: b = 5123,
      instanceCount: w = 0,
      isInstanced: T = w > 0,
      vertexArray: I = null,
      transformFeedback: P,
      framebuffer: k,
      parameters: U = {},
      uniforms: G,
      samplers: H
    } = e;
    if ((G || H) && (ln.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")(), this.setUniforms(G || {})), ln.priority >= t) {
      const $ = k ? k.id : "default", ie = "mode=".concat(Gu(this.gl, r), " verts=").concat(i, " ") + "instances=".concat(w, " indexType=").concat(Gu(this.gl, b), " ") + "isInstanced=".concat(T, " isIndexed=").concat(_, " ") + "Framebuffer=".concat($);
      ln.log(t, ie)();
    }
    return Zt(I), this.gl.useProgram(this.handle), !this._areTexturesRenderable() || i === 0 || T && w === 0 ? !1 : (I.bindForDraw(i, w, () => {
      if (k !== void 0 && (U = Object.assign({}, U, {
        framebuffer: k
      })), P) {
        const $ = HB(r);
        P.begin($);
      }
      this._bindTextures(), Al(this.gl, U, () => {
        _ && T ? this.gl2.drawElementsInstanced(r, i, b, o, w) : _ && tr(this.gl) && !isNaN(c) && !isNaN(l) ? this.gl2.drawRangeElements(r, c, l, i, b, o) : _ ? this.gl.drawElements(r, i, b, o) : T ? this.gl2.drawArraysInstanced(r, o, i, w) : this.gl.drawArrays(r, o, i);
      }), P && P.end();
    }), !0);
  }
  setUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    ln.priority >= 2 && hB(e, this.id, this._uniformSetters), this.gl.useProgram(this.handle);
    for (const t in e) {
      const r = e[t], i = this._uniformSetters[t];
      if (i) {
        let o = r, c = !1;
        if (o instanceof os && (o = o.texture), o instanceof $d)
          if (c = this.uniforms[t] !== r, c) {
            i.textureIndex === void 0 && (i.textureIndex = this._textureIndexCounter++);
            const l = o, {
              textureIndex: _
            } = i;
            l.bind(_), o = _, this._textureUniforms[t] = l;
          } else
            o = i.textureIndex;
        else this._textureUniforms[t] && delete this._textureUniforms[t];
        (i(o) || c) && fB(this.uniforms, t, r);
      }
    }
    return this;
  }
  _areTexturesRenderable() {
    let e = !0;
    for (const t in this._textureUniforms) {
      const r = this._textureUniforms[t];
      r.update(), e = e && r.loaded;
    }
    return e;
  }
  _bindTextures() {
    for (const e in this._textureUniforms) {
      const t = this._uniformSetters[e].textureIndex;
      this._textureUniforms[e].bind(t);
    }
  }
  _createHandle() {
    return this.gl.createProgram();
  }
  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  _getOptionsFromHandle(e) {
    const t = this.gl.getAttachedShaders(e), r = {};
    for (const i of t)
      switch (this.gl.getShaderParameter(this.handle, 35663)) {
        case 35633:
          r.vs = new i_({
            handle: i
          });
          break;
        case 35632:
          r.fs = new s_({
            handle: i
          });
          break;
      }
    return r;
  }
  _getParameter(e) {
    return this.gl.getProgramParameter(this.handle, e);
  }
  _setId(e) {
    if (!e) {
      const t = this._getName();
      this.id = ou(t);
    }
  }
  _getName() {
    let e = this.vs.getName() || this.fs.getName();
    return e = e.replace(/shader/i, ""), e = e ? "".concat(e, "-program") : "program", e;
  }
  _compileAndLink() {
    const {
      gl: e
    } = this;
    if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), ln.time(_x, "linkProgram for ".concat(this._getName()))(), e.linkProgram(this.handle), ln.timeEnd(_x, "linkProgram for ".concat(this._getName()))(), e.debug || ln.level > 0) {
      if (!e.getProgramParameter(this.handle, 35714))
        throw new Error("Error linking: ".concat(e.getProgramInfoLog(this.handle)));
      if (e.validateProgram(this.handle), !e.getProgramParameter(this.handle, 35715))
        throw new Error("Error validating: ".concat(e.getProgramInfoLog(this.handle)));
    }
  }
  _readUniformLocationsFromLinkedProgram() {
    const {
      gl: e
    } = this;
    this._uniformSetters = {}, this._uniformCount = this._getParameter(35718);
    for (let t = 0; t < this._uniformCount; t++) {
      const r = this.gl.getActiveUniform(this.handle, t), {
        name: i
      } = uB(r.name);
      let o = e.getUniformLocation(this.handle, i);
      if (this._uniformSetters[i] = px(e, o, r), r.size > 1)
        for (let c = 0; c < r.size; c++)
          o = e.getUniformLocation(this.handle, "".concat(i, "[").concat(c, "]")), this._uniformSetters["".concat(i, "[").concat(c, "]")] = px(e, o, r);
    }
    this._textureIndexCounter = 0;
  }
  getActiveUniforms(e, t) {
    return this.gl2.getActiveUniforms(this.handle, e, t);
  }
  getUniformBlockIndex(e) {
    return this.gl2.getUniformBlockIndex(this.handle, e);
  }
  getActiveUniformBlockParameter(e, t) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, e, t);
  }
  uniformBlockBinding(e, t) {
    this.gl2.uniformBlockBinding(this.handle, e, t);
  }
}
const ZB = 34918, JB = 34919, YB = 35007, KB = 36795, QB = 35976, eR = 35887, tR = 36202;
class _m extends cu {
  get [Symbol.toStringTag]() {
    return "Query";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const r = tr(e), i = cS(e, ei.TIMER_QUERY);
    let o = r || i;
    for (const c of t)
      switch (c) {
        case "queries":
          o = o && r;
          break;
        case "timers":
          o = o && i;
          break;
        default:
          Zt(!1);
      }
    return o;
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.target = null, this._queryPending = !1, this._pollingPromise = null, Object.seal(this);
  }
  beginTimeElapsedQuery() {
    return this.begin(YB);
  }
  beginOcclusionQuery() {
    let {
      conservative: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.begin(e ? tR : eR);
  }
  beginTransformFeedbackQuery() {
    return this.begin(QB);
  }
  begin(e) {
    return this._queryPending ? this : (this.target = e, this.gl2.beginQuery(this.target, this.handle), this);
  }
  end() {
    return this._queryPending ? this : (this.target && (this.gl2.endQuery(this.target), this.target = null, this._queryPending = !0), this);
  }
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const e = this.gl2.getQueryParameter(this.handle, JB);
    return e && (this._queryPending = !1), e;
  }
  isTimerDisjoint() {
    return this.gl2.getParameter(KB);
  }
  getResult() {
    return this.gl2.getQueryParameter(this.handle, ZB);
  }
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  createPoll() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise)
      return this._pollingPromise;
    let t = 0;
    return this._pollingPromise = new Promise((r, i) => {
      const o = () => {
        this.isResultAvailable() ? (r(this.getResult()), this._pollingPromise = null) : t++ > e ? (i("Timed out"), this._pollingPromise = null) : requestAnimationFrame(o);
      };
      requestAnimationFrame(o);
    }), this._pollingPromise;
  }
  _createHandle() {
    return _m.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }
  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }
}
class gS extends cu {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  static isSupported(e) {
    return tr(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    So(e), super(e, t), this.initialize(t), this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]), Object.seal(this);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.buffers = {}, this.unused = {}, this.configuration = null, this.bindOnUse = !0, Xd(this.buffers) || this.bind(() => this._unbindBuffers()), this.setProps(e), this;
  }
  setProps(e) {
    "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "bindOnUse" in e && (e = e.bindOnUse), "buffers" in e && this.setBuffers(e.buffers);
  }
  setBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.bind(() => {
      for (const t in e)
        this.setBuffer(t, e[t]);
    }), this;
  }
  setBuffer(e, t) {
    const r = this._getVaryingIndex(e), {
      buffer: i,
      byteSize: o,
      byteOffset: c
    } = this._getBufferParams(t);
    return r < 0 ? (this.unused[e] = i, ln.warn("".concat(this.id, " unused varying buffer ").concat(e))(), this) : (this.buffers[r] = t, this.bindOnUse || this._bindBuffer(r, i, c, o), this);
  }
  begin() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.gl.bindTransformFeedback(36386, this.handle), this._bindBuffers(), this.gl.beginTransformFeedback(e), this;
  }
  end() {
    return this.gl.endTransformFeedback(), this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null), this;
  }
  _getBufferParams(e) {
    let t, r, i;
    return e instanceof qr ? i = e : (i = e.buffer, r = e.byteSize, t = e.byteOffset), (t !== void 0 || r !== void 0) && (t = t || 0, r = r || i.byteLength - t), {
      buffer: i,
      byteOffset: t,
      byteSize: r
    };
  }
  _getVaryingInfo(e) {
    return this.configuration && this.configuration.getVaryingInfo(e);
  }
  _getVaryingIndex(e) {
    if (this.configuration)
      return this.configuration.getVaryingInfo(e).location;
    const t = Number(e);
    return Number.isFinite(t) ? t : -1;
  }
  _bindBuffers() {
    if (this.bindOnUse)
      for (const e in this.buffers) {
        const {
          buffer: t,
          byteSize: r,
          byteOffset: i
        } = this._getBufferParams(this.buffers[e]);
        this._bindBuffer(e, t, i, r);
      }
  }
  _unbindBuffers() {
    if (this.bindOnUse)
      for (const e in this.buffers)
        this._bindBuffer(e, null);
  }
  _bindBuffer(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 ? arguments[3] : void 0;
    const o = t && t.handle;
    return !o || i === void 0 ? this.gl.bindBufferBase(35982, e, o) : this.gl.bindBufferRange(35982, e, o, r, i), this;
  }
  _createHandle() {
    return this.gl.createTransformFeedback();
  }
  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }
  _bindHandle(e) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }
}
let yg = null;
function nR(n) {
  return (!yg || yg.byteLength < n) && (yg = new ArrayBuffer(n)), yg;
}
function rR(n, e) {
  const t = nR(n.BYTES_PER_ELEMENT * e);
  return new n(t, 0, e);
}
function iR(n) {
  let {
    target: e,
    source: t,
    start: r = 0,
    count: i = 1
  } = n;
  const o = t.length, c = i * o;
  let l = 0;
  for (let _ = r; l < o; l++)
    e[_++] = t[l];
  for (; l < c; )
    l < c - l ? (e.copyWithin(r + l, r, r + l), l *= 2) : (e.copyWithin(r + l, r, r + c - l), l = c);
  return e;
}
const sR = "elements must be GL.ELEMENT_ARRAY_BUFFER";
class ya extends cu {
  get [Symbol.toStringTag]() {
    return "VertexArrayObject";
  }
  static isSupported(e) {
    return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}).constantAttributeZero ? tr(e) || F5() === "Chrome" : !0;
  }
  static getDefaultArray(e) {
    return e.luma = e.luma || {}, e.luma.defaultVertexArray || (e.luma.defaultVertexArray = new ya(e, {
      handle: null,
      isDefaultArray: !0
    })), e.luma.defaultVertexArray;
  }
  static getMaxAttributes(e) {
    return ya.MAX_ATTRIBUTES = ya.MAX_ATTRIBUTES || e.getParameter(34921), ya.MAX_ATTRIBUTES;
  }
  static setConstant(e, t, r) {
    switch (r.constructor) {
      case Float32Array:
        ya._setConstantFloatArray(e, t, r);
        break;
      case Int32Array:
        ya._setConstantIntArray(e, t, r);
        break;
      case Uint32Array:
        ya._setConstantUintArray(e, t, r);
        break;
      default:
        Zt(!1);
    }
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = t.id || t.program && t.program.id;
    super(e, Object.assign({}, t, {
      id: r
    })), this.buffer = null, this.bufferValue = null, this.isDefaultArray = t.isDefaultArray || !1, this.gl2 = e, this.initialize(t), Object.seal(this);
  }
  delete() {
    return super.delete(), this.buffer && this.buffer.delete(), this;
  }
  get MAX_ATTRIBUTES() {
    return ya.getMaxAttributes(this.gl);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.setProps(e);
  }
  setProps(e) {
    return this;
  }
  setElementBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return Zt(!e || e.target === 34963, sR), this.bind(() => {
      this.gl.bindBuffer(34963, e ? e.handle : null);
    }), this;
  }
  setBuffer(e, t, r) {
    if (t.target === 34963)
      return this.setElementBuffer(t, r);
    const {
      size: i,
      type: o,
      stride: c,
      offset: l,
      normalized: _,
      integer: b,
      divisor: w
    } = r, {
      gl: T,
      gl2: I
    } = this;
    return e = Number(e), this.bind(() => {
      T.bindBuffer(34962, t.handle), b ? (Zt(tr(T)), I.vertexAttribIPointer(e, i, o, c, l)) : T.vertexAttribPointer(e, i, o, _, c, l), T.enableVertexAttribArray(e), I.vertexAttribDivisor(e, w || 0);
    }), this;
  }
  enable(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return !t && e === 0 && !ya.isSupported(this.gl, {
      constantAttributeZero: !0
    }) || (e = Number(e), this.bind(() => t ? this.gl.enableVertexAttribArray(e) : this.gl.disableVertexAttribArray(e))), this;
  }
  getConstantBuffer(e, t) {
    const r = this._normalizeConstantArrayValue(t), i = r.byteLength * e, o = r.length * e;
    let c = !this.buffer;
    if (this.buffer = this.buffer || new qr(this.gl, i), c = c || this.buffer.reallocate(i), c = c || !this._compareConstantArrayValues(r, this.bufferValue), c) {
      const l = rR(t.constructor, o);
      iR({
        target: l,
        source: r,
        start: 0,
        count: o
      }), this.buffer.subData(l), this.bufferValue = t;
    }
    return this.buffer;
  }
  _normalizeConstantArrayValue(e) {
    return Array.isArray(e) ? new Float32Array(e) : e;
  }
  _compareConstantArrayValues(e, t) {
    if (!e || !t || e.length !== t.length || e.constructor !== t.constructor)
      return !1;
    for (let r = 0; r < e.length; ++r)
      if (e[r] !== t[r])
        return !1;
    return !0;
  }
  static _setConstantFloatArray(e, t, r) {
    switch (r.length) {
      case 1:
        e.vertexAttrib1fv(t, r);
        break;
      case 2:
        e.vertexAttrib2fv(t, r);
        break;
      case 3:
        e.vertexAttrib3fv(t, r);
        break;
      case 4:
        e.vertexAttrib4fv(t, r);
        break;
      default:
        Zt(!1);
    }
  }
  static _setConstantIntArray(e, t, r) {
    switch (Zt(tr(e)), r.length) {
      case 1:
        e.vertexAttribI1iv(t, r);
        break;
      case 2:
        e.vertexAttribI2iv(t, r);
        break;
      case 3:
        e.vertexAttribI3iv(t, r);
        break;
      case 4:
        e.vertexAttribI4iv(t, r);
        break;
      default:
        Zt(!1);
    }
  }
  static _setConstantUintArray(e, t, r) {
    switch (Zt(tr(e)), r.length) {
      case 1:
        e.vertexAttribI1uiv(t, r);
        break;
      case 2:
        e.vertexAttribI2uiv(t, r);
        break;
      case 3:
        e.vertexAttribI3uiv(t, r);
        break;
      case 4:
        e.vertexAttribI4uiv(t, r);
        break;
      default:
        Zt(!1);
    }
  }
  _createHandle() {
    return this.gl.createVertexArray();
  }
  _deleteHandle(e) {
    return this.gl2.deleteVertexArray(e), [this.elements];
  }
  _bindHandle(e) {
    this.gl2.bindVertexArray(e);
  }
  _getParameter(e, t) {
    let {
      location: r
    } = t;
    return Zt(Number.isFinite(r)), this.bind(() => {
      switch (e) {
        case 34373:
          return this.gl.getVertexAttribOffset(r, e);
        default:
          return this.gl.getVertexAttrib(r, e);
      }
    });
  }
}
const oR = "VertexArray: attributes must be Buffers or constants (i.e. typed array)", aR = /^(.+)__LOCATION_([0-9]+)$/, lR = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
class cR {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = t.id || t.program && t.program.id;
    this.id = r, this.gl = e, this.configuration = null, this.elements = null, this.elementsAccessor = null, this.values = null, this.accessors = null, this.unused = null, this.drawParams = null, this.buffer = null, this.attributes = {}, this.vertexArrayObject = new ya(e), nS(this, "VertexArray", "v6.0", lR), this.initialize(t), Object.seal(this);
  }
  delete() {
    this.buffer && this.buffer.delete(), this.vertexArrayObject.delete();
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.reset(), this.configuration = null, this.bindOnUse = !1, this.setProps(e);
  }
  reset() {
    this.elements = null, this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES: e
    } = this.vertexArrayObject;
    return this.values = new Array(e).fill(null), this.accessors = new Array(e).fill(null), this.unused = {}, this.drawParams = null, this;
  }
  setProps(e) {
    return "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "attributes" in e && this.setAttributes(e.attributes), "elements" in e && this.setElementBuffer(e.elements), "bindOnUse" in e && (e = e.bindOnUse), this;
  }
  clearDrawParams() {
    this.drawParams = null;
  }
  getDrawParams() {
    return this.drawParams = this.drawParams || this._updateDrawParams(), this.drawParams;
  }
  setAttributes(e) {
    return Object.assign(this.attributes, e), this.vertexArrayObject.bind(() => {
      for (const t in e) {
        const r = e[t];
        this._setAttribute(t, r);
      }
      this.gl.bindBuffer(34962, null);
    }), this;
  }
  setElementBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this.elements = e, this.elementsAccessor = t, this.clearDrawParams(), this.vertexArrayObject.setElementBuffer(e, t), this;
  }
  setBuffer(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (t.target === 34963)
      return this.setElementBuffer(t, r);
    const {
      location: i,
      accessor: o
    } = this._resolveLocationAndAccessor(e, t, t.accessor, r);
    return i >= 0 && (this.values[i] = t, this.accessors[i] = o, this.clearDrawParams(), this.vertexArrayObject.setBuffer(i, t, o)), this;
  }
  setConstant(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      location: i,
      accessor: o
    } = this._resolveLocationAndAccessor(e, t, Object.assign({
      size: t.length
    }, r));
    return i >= 0 && (t = this.vertexArrayObject._normalizeConstantArrayValue(t), this.values[i] = t, this.accessors[i] = o, this.clearDrawParams(), this.vertexArrayObject.enable(i, !1)), this;
  }
  unbindBuffers() {
    return this.vertexArrayObject.bind(() => {
      this.elements && this.vertexArrayObject.setElementBuffer(null), this.buffer = this.buffer || new qr(this.gl, {
        accessor: {
          size: 4
        }
      });
      for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++)
        this.values[e] instanceof qr && (this.gl.disableVertexAttribArray(e), this.gl.bindBuffer(34962, this.buffer.handle), this.gl.vertexAttribPointer(e, 1, 5126, !1, 0, 0));
    }), this;
  }
  bindBuffers() {
    return this.vertexArrayObject.bind(() => {
      this.elements && this.setElementBuffer(this.elements);
      for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++) {
        const t = this.values[e];
        t instanceof qr && this.setBuffer(e, t);
      }
    }), this;
  }
  bindForDraw(e, t, r) {
    let i;
    return this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(e, t), i = r();
    }), i;
  }
  _resolveLocationAndAccessor(e, t, r, i) {
    const o = {
      location: -1,
      accessor: null
    }, {
      location: c,
      name: l
    } = this._getAttributeIndex(e);
    if (!Number.isFinite(c) || c < 0)
      return this.unused[e] = t, ln.once(3, () => "unused value ".concat(e, " in ").concat(this.id))(), o;
    const _ = this._getAttributeInfo(l || c);
    if (!_)
      return o;
    const b = this.accessors[c] || {}, w = Go.resolve(_.accessor, b, r, i), {
      size: T,
      type: I
    } = w;
    return Zt(Number.isFinite(T) && Number.isFinite(I)), {
      location: c,
      accessor: w
    };
  }
  _getAttributeInfo(e) {
    return this.configuration && this.configuration.getAttributeInfo(e);
  }
  _getAttributeIndex(e) {
    const t = Number(e);
    if (Number.isFinite(t))
      return {
        location: t
      };
    const r = aR.exec(e), i = r ? r[1] : e, o = r ? Number(r[2]) : 0;
    return this.configuration ? {
      location: this.configuration.getAttributeLocation(i) + o,
      name: i
    } : {
      location: -1
    };
  }
  _setAttribute(e, t) {
    if (t instanceof qr)
      this.setBuffer(e, t);
    else if (Array.isArray(t) && t.length && t[0] instanceof qr) {
      const r = t[0], i = t[1];
      this.setBuffer(e, r, i);
    } else if (ArrayBuffer.isView(t) || Array.isArray(t)) {
      const r = t;
      this.setConstant(e, r);
    } else if (t.buffer instanceof qr) {
      const r = t;
      this.setBuffer(e, r.buffer, r);
    } else
      throw new Error(oR);
  }
  _setConstantAttributes(e, t) {
    const r = Math.max(e | 0, t | 0);
    let i = this.values[0];
    ArrayBuffer.isView(i) && this._setConstantAttributeZero(i, r);
    for (let o = 1; o < this.vertexArrayObject.MAX_ATTRIBUTES; o++)
      i = this.values[o], ArrayBuffer.isView(i) && this._setConstantAttribute(o, i);
  }
  _setConstantAttributeZero(e, t) {
    if (ya.isSupported(this.gl, {
      constantAttributeZero: !0
    })) {
      this._setConstantAttribute(0, e);
      return;
    }
    const r = this.vertexArrayObject.getConstantBuffer(t, e);
    this.vertexArrayObject.setBuffer(0, r, this.accessors[0]);
  }
  _setConstantAttribute(e, t) {
    ya.setConstant(this.gl, e, t);
  }
  _updateDrawParams() {
    const e = {
      isIndexed: !1,
      isInstanced: !1,
      indexCount: 1 / 0,
      vertexCount: 1 / 0,
      instanceCount: 1 / 0
    };
    for (let t = 0; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++)
      this._updateDrawParamsForLocation(e, t);
    return this.elements && (e.elementCount = this.elements.getElementCount(this.elements.accessor), e.isIndexed = !0, e.indexType = this.elementsAccessor.type || this.elements.accessor.type, e.indexOffset = this.elementsAccessor.offset || 0), e.indexCount === 1 / 0 && (e.indexCount = 0), e.vertexCount === 1 / 0 && (e.vertexCount = 0), e.instanceCount === 1 / 0 && (e.instanceCount = 0), e;
  }
  _updateDrawParamsForLocation(e, t) {
    const r = this.values[t], i = this.accessors[t];
    if (!r)
      return;
    const {
      divisor: o
    } = i, c = o > 0;
    if (e.isInstanced = e.isInstanced || c, r instanceof qr) {
      const l = r;
      if (c) {
        const _ = l.getVertexCount(i);
        e.instanceCount = Math.min(e.instanceCount, _);
      } else {
        const _ = l.getVertexCount(i);
        e.vertexCount = Math.min(e.vertexCount, _);
      }
    }
  }
  setElements() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return ln.deprecated("setElements", "setElementBuffer")(), this.setElementBuffer(e, t);
  }
}
function uR(n, e) {
  const {
    maxElts: t = 16,
    size: r = 1
  } = e;
  let i = "[";
  for (let c = 0; c < n.length && c < t; ++c)
    c > 0 && (i += ",".concat(c % r === 0 ? " " : "")), i += yp(n[c], e);
  const o = n.length > t ? "..." : "]";
  return "".concat(i).concat(o);
}
function yp(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = 1e-16, {
    isInteger: r = !1
  } = e;
  if (Array.isArray(n) || ArrayBuffer.isView(n))
    return uR(n, e);
  if (!Number.isFinite(n))
    return String(n);
  if (Math.abs(n) < t)
    return r ? "0" : "0.";
  if (r || Math.abs(n) > 100 && Math.abs(n) < 1e4)
    return n.toFixed(0);
  const i = n.toPrecision(2);
  return i.indexOf(".0") === i.length - 2 ? i.slice(0, -1) : i;
}
function yx(n) {
  let {
    header: e = "Uniforms",
    program: t,
    uniforms: r,
    undefinedOnly: i = !1
  } = n;
  Zt(t);
  const o = ".*_.*", c = ".*Matrix", l = t._uniformSetters, _ = {}, b = Object.keys(l).sort();
  let w = 0;
  for (const P of b)
    !P.match(o) && !P.match(c) && o_({
      table: _,
      header: e,
      uniforms: r,
      uniformName: P,
      undefinedOnly: i
    }) && w++;
  for (const P of b)
    P.match(c) && o_({
      table: _,
      header: e,
      uniforms: r,
      uniformName: P,
      undefinedOnly: i
    }) && w++;
  for (const P of b)
    _[P] || o_({
      table: _,
      header: e,
      uniforms: r,
      uniformName: P,
      undefinedOnly: i
    }) && w++;
  let T = 0;
  const I = {};
  if (!i)
    for (const P in r) {
      const k = r[P];
      _[P] || (T++, I[P] = {
        Type: "NOT USED: ".concat(k),
        [e]: yp(k)
      });
    }
  return {
    table: _,
    count: w,
    unusedTable: I,
    unusedCount: T
  };
}
function o_(n) {
  let {
    table: e,
    header: t,
    uniforms: r,
    uniformName: i,
    undefinedOnly: o
  } = n;
  const c = r[i], l = hR(c);
  return !o || !l ? (e[i] = {
    [t]: l ? yp(c) : "N/A",
    "Uniform Type": l ? c : "NOT PROVIDED"
  }, !0) : !1;
}
function hR(n) {
  return n != null;
}
function dR(n) {
  let {
    vertexArray: e,
    header: t = "Attributes"
  } = n;
  if (!e.configuration)
    return {};
  const r = {};
  e.elements && (r.ELEMENT_ARRAY_BUFFER = bx(e, e.elements, null, t));
  const i = e.values;
  for (const o in i) {
    const c = e._getAttributeInfo(o);
    if (c) {
      let l = "".concat(o, ": ").concat(c.name);
      const _ = e.accessors[c.location];
      _ && (l = "".concat(o, ": ").concat(fR(c.name, _))), r[l] = bx(e, i[o], _, t);
    }
  }
  return r;
}
function bx(n, e, t, r) {
  const {
    gl: i
  } = n;
  if (!e)
    return {
      [r]: "null",
      "Format ": "N/A"
    };
  let o = "NOT PROVIDED", c = 1, l = 0, _ = 0, b, w, T;
  if (t && (o = t.type, c = t.size, o = String(o).replace("Array", ""), b = o.indexOf("nt") !== -1), e instanceof qr) {
    const I = e, {
      data: P,
      changed: k
    } = I.getDebugData();
    w = k ? "*" : "", T = P, _ = I.byteLength, l = _ / P.BYTES_PER_ELEMENT / c;
    let U;
    if (t) {
      const G = t.divisor > 0;
      U = "".concat(G ? "I " : "P ", " ").concat(l, " (x").concat(c, "=").concat(_, " bytes ").concat(Gu(i, o), ")");
    } else
      b = !0, U = "".concat(_, " bytes");
    return {
      [r]: "".concat(w).concat(yp(T, {
        size: c,
        isInteger: b
      })),
      "Format ": U
    };
  }
  return T = e, c = e.length, o = String(e.constructor.name).replace("Array", ""), b = o.indexOf("nt") !== -1, {
    [r]: "".concat(yp(T, {
      size: c,
      isInteger: b
    }), " (constant)"),
    "Format ": "".concat(c, "x").concat(o, " (constant)")
  };
}
function fR(n, e) {
  const {
    type: t,
    size: r
  } = e, i = fS(t, r);
  return i ? "".concat(n, " (").concat(i.name, ")") : n;
}
function pR(n) {
  const e = {}, t = "Accessors for ".concat(n.id);
  for (const r of n.attributeInfos)
    if (r) {
      const i = vx(r);
      e["in ".concat(i)] = {
        [t]: JSON.stringify(r.accessor)
      };
    }
  for (const r of n.varyingInfos)
    if (r) {
      const i = vx(r);
      e["out ".concat(i)] = {
        [t]: JSON.stringify(r.accessor)
      };
    }
  return e;
}
function vx(n) {
  const {
    type: e,
    size: t
  } = n.accessor, r = fS(e, t);
  return r ? "".concat(r.name, " ").concat(n.name) : n.name;
}
const xx = lu() && typeof document < "u";
let gR = 0;
class mR {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      onCreateContext: t = (G) => tS(G),
      onAddHTML: r = null,
      onInitialize: i = () => {
      },
      onRender: o = () => {
      },
      onFinalize: c = () => {
      },
      onError: l,
      gl: _ = null,
      glOptions: b = {},
      debug: w = !1,
      createFramebuffer: T = !1,
      autoResizeViewport: I = !0,
      autoResizeDrawingBuffer: P = !0,
      stats: k = Ch.get("animation-loop-".concat(gR++))
    } = e;
    let {
      useDevicePixels: U = !0
    } = e;
    "useDevicePixelRatio" in e && (ln.deprecated("useDevicePixelRatio", "useDevicePixels")(), U = e.useDevicePixelRatio), this.props = {
      onCreateContext: t,
      onAddHTML: r,
      onInitialize: i,
      onRender: o,
      onFinalize: c,
      onError: l,
      gl: _,
      glOptions: b,
      debug: w,
      createFramebuffer: T
    }, this.gl = _, this.needsRedraw = null, this.timeline = null, this.stats = k, this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this._initialized = !1, this._running = !1, this._animationFrameId = null, this._nextFramePromise = null, this._resolveNextFrame = null, this._cpuStartTime = 0, this.setProps({
      autoResizeViewport: I,
      autoResizeDrawingBuffer: P,
      useDevicePixels: U
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._pageLoadPromise = null, this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  delete() {
    this.stop(), this._setDisplay(null);
  }
  setNeedsRedraw(e) {
    return Zt(typeof e == "string"), this.needsRedraw = this.needsRedraw || e, this;
  }
  setProps(e) {
    return "autoResizeViewport" in e && (this.autoResizeViewport = e.autoResizeViewport), "autoResizeDrawingBuffer" in e && (this.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer), "useDevicePixels" in e && (this.useDevicePixels = e.useDevicePixels), this;
  }
  start() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this._running)
      return this;
    this._running = !0;
    const t = this._getPageLoadPromise().then(() => !this._running || this._initialized ? null : (this._createWebGLContext(e), this._createFramebuffer(), this._startEventHandling(), this._initializeCallbackData(), this._updateCallbackData(), this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._gpuTimeQuery = _m.isSupported(this.gl, ["timers"]) ? new _m(this.gl) : null, this._initialized = !0, this.onInitialize(this.animationProps))).then((r) => {
      this._running && (this._addCallbackData(r || {}), r !== !1 && this._startLoop());
    });
    return this.props.onError && t.catch(this.props.onError), this;
  }
  redraw() {
    return this.isContextLost() ? this : (this._beginTimers(), this._setupFrame(), this._updateCallbackData(), this._renderFrame(this.animationProps), this._clearNeedsRedraw(), this.offScreen && this.gl.commit && this.gl.commit(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endTimers(), this);
  }
  stop() {
    return this._running && (this._finalizeCallbackData(), this._cancelAnimationFrame(this._animationFrameId), this._nextFramePromise = null, this._resolveNextFrame = null, this._animationFrameId = null, this._running = !1), this;
  }
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  detachTimeline() {
    this.timeline = null;
  }
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  async toDataURL() {
    return this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.gl.canvas.toDataURL();
  }
  isContextLost() {
    return this.gl.isContextLost();
  }
  onCreateContext() {
    return this.props.onCreateContext(...arguments);
  }
  onInitialize() {
    return this.props.onInitialize(...arguments);
  }
  onRender() {
    return this.props.onRender(...arguments);
  }
  onFinalize() {
    return this.props.onFinalize(...arguments);
  }
  getHTMLControlValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const r = document.getElementById(e);
    return r ? Number(r.value) : t;
  }
  setViewParameters() {
    return ln.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")(), this;
  }
  _startLoop() {
    const e = () => {
      this._running && (this.redraw(), this._animationFrameId = this._requestAnimationFrame(e));
    };
    this._cancelAnimationFrame(this._animationFrameId), this._animationFrameId = this._requestAnimationFrame(e);
  }
  _getPageLoadPromise() {
    return this._pageLoadPromise || (this._pageLoadPromise = xx ? new Promise((e, t) => {
      if (xx && document.readyState === "complete") {
        e(document);
        return;
      }
      window.addEventListener("load", () => {
        e(document);
      });
    }) : Promise.resolve({})), this._pageLoadPromise;
  }
  _setDisplay(e) {
    this.display && (this.display.delete(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _cancelAnimationFrame(e) {
    return this.display && this.display.cancelAnimationFrame ? this.display.cancelAnimationFrame(e) : A4(e);
  }
  _requestAnimationFrame(e) {
    if (this._running)
      return this.display && this.display.requestAnimationFrame ? this.display.requestAnimationFrame(e) : w4(e);
  }
  _renderFrame() {
    if (this.display) {
      this.display._renderFrame(...arguments);
      return;
    }
    this.onRender(...arguments);
  }
  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._resizeFramebuffer();
  }
  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }
  _updateCallbackData() {
    const {
      width: e,
      height: t,
      aspect: r
    } = this._getSizeAndAspect();
    (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), r !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = r, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime, this.animationProps._offScreen = this.offScreen;
  }
  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }
  _addCallbackData(e) {
    typeof e == "object" && e !== null && (this.animationProps = Object.assign({}, this.animationProps, e));
  }
  _createWebGLContext(e) {
    if (this.offScreen = e.canvas && typeof OffscreenCanvas < "u" && e.canvas instanceof OffscreenCanvas, e = Object.assign({}, e, this.props.glOptions), this.gl = this.props.gl ? R1(this.props.gl, e) : this.onCreateContext(e), !Nm(this.gl))
      throw new Error("AnimationLoop.onCreateContext - illegal context returned");
    c4(this.gl), this._createInfoDiv();
  }
  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", e.appendChild(this.gl.canvas), e.appendChild(t);
      const r = this.props.onAddHTML(t);
      r && (t.innerHTML = r);
    }
  }
  _getSizeAndAspect() {
    const e = this.gl.drawingBufferWidth, t = this.gl.drawingBufferHeight;
    let r = 1;
    const {
      canvas: i
    } = this.gl;
    return i && i.clientHeight ? r = i.clientWidth / i.clientHeight : e > 0 && t > 0 && (r = e / t), {
      width: e,
      height: t,
      aspect: r
    };
  }
  _resizeViewport() {
    this.autoResizeViewport && this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
  }
  _resizeCanvasDrawingBuffer() {
    this.autoResizeDrawingBuffer && p4(this.gl, {
      useDevicePixels: this.useDevicePixels
    });
  }
  _createFramebuffer() {
    this.props.createFramebuffer && (this.framebuffer = new os(this.gl));
  }
  _resizeFramebuffer() {
    this.framebuffer && this.framebuffer.resize({
      width: this.gl.drawingBufferWidth,
      height: this.gl.drawingBufferHeight
    });
  }
  _beginTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint() && this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds()), this._gpuTimeQuery && this._gpuTimeQuery.beginTimeElapsedQuery(), this.cpuTime.timeStart();
  }
  _endTimers() {
    this.cpuTime.timeEnd(), this._gpuTimeQuery && this._gpuTimeQuery.end();
  }
  _startEventHandling() {
    const {
      canvas: e
    } = this.gl;
    e && (e.addEventListener("mousemove", this._onMousemove), e.addEventListener("mouseleave", this._onMouseleave));
  }
  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }
  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }
}
const kp = "vs", N1 = "fs";
function xa(n, e) {
  if (!n)
    throw new Error(e || "shadertools: assertion failed.");
}
const a_ = {
  number: {
    validate(n, e) {
      return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
    }
  },
  array: {
    validate(n, e) {
      return Array.isArray(n) || ArrayBuffer.isView(n);
    }
  }
};
function _R(n) {
  const e = {};
  for (const t in n) {
    const r = n[t], i = yR(r);
    e[t] = i;
  }
  return e;
}
function yR(n) {
  let e = wx(n);
  return e === "object" ? n ? "type" in n ? Object.assign({}, n, a_[n.type]) : "value" in n ? (e = wx(n.value), Object.assign({
    type: e
  }, n, a_[e])) : {
    type: "object",
    value: n
  } : {
    type: "object",
    value: null
  } : Object.assign({
    type: e,
    value: n
  }, a_[e]);
}
function wx(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) ? "array" : typeof n;
}
const bR = "vs", vR = "fs";
class Ax {
  constructor(e) {
    let {
      name: t,
      vs: r,
      fs: i,
      dependencies: o = [],
      uniforms: c,
      getUniforms: l,
      deprecations: _ = [],
      defines: b = {},
      inject: w = {},
      vertexShader: T,
      fragmentShader: I
    } = e;
    xa(typeof t == "string"), this.name = t, this.vs = r || T, this.fs = i || I, this.getModuleUniforms = l, this.dependencies = o, this.deprecations = this._parseDeprecationDefinitions(_), this.defines = b, this.injections = xR(w), c && (this.uniforms = _R(c));
  }
  getModuleSource(e) {
    let t;
    switch (e) {
      case bR:
        t = this.vs || "";
        break;
      case vR:
        t = this.fs || "";
        break;
      default:
        xa(!1);
    }
    return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), `
`).concat(t, "// END MODULE_").concat(this.name, `

`);
  }
  getUniforms(e, t) {
    return this.getModuleUniforms ? this.getModuleUniforms(e, t) : this.uniforms ? this._defaultGetUniforms(e) : {};
  }
  getDefines() {
    return this.defines;
  }
  checkDeprecations(e, t) {
    this.deprecations.forEach((r) => {
      r.regex.test(e) && (r.deprecated ? t.deprecated(r.old, r.new)() : t.removed(r.old, r.new)());
    });
  }
  _parseDeprecationDefinitions(e) {
    return e.forEach((t) => {
      switch (t.type) {
        case "function":
          t.regex = new RegExp("\\b".concat(t.old, "\\("));
          break;
        default:
          t.regex = new RegExp("".concat(t.type, " ").concat(t.old, ";"));
      }
    }), e;
  }
  _defaultGetUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {}, r = this.uniforms;
    for (const i in r) {
      const o = r[i];
      i in e && !o.private ? (o.validate && xa(o.validate(e[i], o), "".concat(this.name, ": invalid ").concat(i)), t[i] = e[i]) : t[i] = o.value;
    }
    return t;
  }
}
function xR(n) {
  const e = {
    vs: {},
    fs: {}
  };
  for (const t in n) {
    let r = n[t];
    const i = t.slice(0, 2);
    typeof r == "string" && (r = {
      order: 0,
      injection: r
    }), e[i][t] = r;
  }
  return e;
}
function wR(n) {
  return AR(_S(n));
}
function AR(n) {
  const e = {}, t = {};
  return mS({
    modules: n,
    level: 0,
    moduleMap: e,
    moduleDepth: t
  }), Object.keys(t).sort((r, i) => t[i] - t[r]).map((r) => e[r]);
}
function mS(n) {
  let {
    modules: e,
    level: t,
    moduleMap: r,
    moduleDepth: i
  } = n;
  if (t >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const o of e)
    r[o.name] = o, (i[o.name] === void 0 || i[o.name] < t) && (i[o.name] = t);
  for (const o of e)
    o.dependencies && mS({
      modules: o.dependencies,
      level: t + 1,
      moduleMap: r,
      moduleDepth: i
    });
}
function _S(n, e) {
  return n.map((t) => (t instanceof Ax || (xa(typeof t != "string", "Shader module use by name is deprecated. Import shader module '".concat(t, "' and use it directly.")), xa(t.name, "shader module has no name"), t = new Ax(t), t.dependencies = _S(t.dependencies)), t));
}
function SR() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const e = typeof window < "u" ? window.navigator || {} : {}, t = n.userAgent || e.userAgent || "", r = t.indexOf("MSIE ") !== -1, i = t.indexOf("Trident/") !== -1;
  return r || i;
}
const ER = 7936, TR = 7937, CR = 7938, IR = 35724, z1 = {
  GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
  GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
  GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
  GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0]
}, wh = {};
Object.keys(z1).forEach((n) => {
  wh[n] = n;
});
function PR(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && n._version === 2);
}
function LR(n) {
  const e = n.getExtension("WEBGL_debug_renderer_info"), t = n.getParameter(e && e.UNMASKED_VENDOR_WEBGL || ER), r = n.getParameter(e && e.UNMASKED_RENDERER_WEBGL || TR);
  return {
    gpuVendor: MR(t, r),
    vendor: t,
    renderer: r,
    version: n.getParameter(CR),
    shadingLanguageVersion: n.getParameter(IR)
  };
}
function MR(n, e) {
  return n.match(/NVIDIA/i) || e.match(/NVIDIA/i) ? "NVIDIA" : n.match(/INTEL/i) || e.match(/INTEL/i) ? "INTEL" : n.match(/AMD/i) || e.match(/AMD/i) || n.match(/ATI/i) || e.match(/ATI/i) ? "AMD" : "UNKNOWN GPU";
}
const l_ = {};
function Sx(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const r = z1[e];
  if (xa(r, e), !SR(t))
    return !0;
  if (e in l_)
    return l_[e];
  const i = r[0], o = t.behavior || "enable", c = "#extension GL_".concat(i, " : ").concat(o, `
void main(void) {}`), l = n.createShader(35633);
  n.shaderSource(l, c), n.compileShader(l);
  const _ = n.getShaderParameter(l, 35713);
  return n.deleteShader(l), l_[e] = _, _;
}
function BR(n, e) {
  const t = z1[e];
  xa(t, e);
  const r = PR(n) && t[1] || t[0], i = typeof r == "string" ? !!n.getExtension(r) : r;
  return xa(i === !1 || i === !0), i;
}
function bg(n, e) {
  return e = Array.isArray(e) ? e : [e], e.every((t) => BR(n, t));
}
function RR(n) {
  switch (LR(n).gpuVendor.toLowerCase()) {
    case "nvidia":
      return `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
    case "intel":
      return `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "amd":
      return `#define AMD_GPU
`;
    default:
      return `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}
function OR(n, e, t) {
  let r = `#if (__VERSION__ > 120)

# define FEATURE_GLSL_DERIVATIVES
# define FEATURE_GLSL_DRAW_BUFFERS
# define FEATURE_GLSL_FRAG_DEPTH
# define FEATURE_GLSL_TEXTURE_LOD

// DEPRECATED FLAGS, remove in v9
# define FRAG_DEPTH
# define DERIVATIVES
# define DRAW_BUFFERS
# define TEXTURE_LOD

#endif // __VERSION
`;
  return bg(n, wh.GLSL_FRAG_DEPTH) && (r += `
// FRAG_DEPTH => gl_FragDepth is available
#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
# define FEATURE_GLSL_FRAG_DEPTH
# define FRAG_DEPTH
# define gl_FragDepth gl_FragDepthEXT
#endif
`), bg(n, wh.GLSL_DERIVATIVES) && Sx(n, wh.GLSL_DERIVATIVES) && (r += `
// DERIVATIVES => dxdF, dxdY and fwidth are available
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
# define FEATURE_GLSL_DERIVATIVES
# define DERIVATIVES
#endif
`), bg(n, wh.GLSL_FRAG_DATA) && Sx(n, wh.GLSL_FRAG_DATA, {
    behavior: "require"
  }) && (r += `
// DRAW_BUFFERS => gl_FragData[] is available
#ifdef GL_EXT_draw_buffers
#extension GL_EXT_draw_buffers : require
#define FEATURE_GLSL_DRAW_BUFFERS
#define DRAW_BUFFERS
#endif
`), bg(n, wh.GLSL_TEXTURE_LOD) && (r += `// TEXTURE_LOD => texture2DLod etc are available
#ifdef GL_EXT_shader_texture_lod
#extension GL_EXT_shader_texture_lod : enable

# define FEATURE_GLSL_TEXTURE_LOD
# define TEXTURE_LOD

#endif
`), r;
}
const DR = `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`, FR = `#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`, kR = {
  [kp]: DR,
  [N1]: FR
}, Wg = "__LUMA_INJECT_DECLARATIONS__", Ex = /void\s+main\s*\([^)]*\)\s*\{\n?/, Tx = /}\n?[^{}]*$/, c_ = [];
function Cx(n, e, t) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const i = e === kp;
  for (const o in t) {
    const c = t[o];
    c.sort((_, b) => _.order - b.order), c_.length = c.length;
    for (let _ = 0, b = c.length; _ < b; ++_)
      c_[_] = c[_].injection;
    const l = "".concat(c_.join(`
`), `
`);
    switch (o) {
      case "vs:#decl":
        i && (n = n.replace(Wg, l));
        break;
      case "vs:#main-start":
        i && (n = n.replace(Ex, (_) => _ + l));
        break;
      case "vs:#main-end":
        i && (n = n.replace(Tx, (_) => l + _));
        break;
      case "fs:#decl":
        i || (n = n.replace(Wg, l));
        break;
      case "fs:#main-start":
        i || (n = n.replace(Ex, (_) => _ + l));
        break;
      case "fs:#main-end":
        i || (n = n.replace(Tx, (_) => l + _));
        break;
      default:
        n = n.replace(o, (_) => _ + l);
    }
  }
  return n = n.replace(Wg, ""), r && (n = n.replace(/\}\s*$/, (o) => o + kR[e])), n;
}
function by(n) {
  const e = {};
  return xa(Array.isArray(n) && n.length > 1), n.forEach((t) => {
    for (const r in t)
      e[r] = e[r] ? "".concat(e[r], `
`).concat(t[r]) : t[r];
  }), e;
}
function Zd(n) {
  return new RegExp("\\b".concat(n, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
const yS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]], NR = [...yS, [Zd("attribute"), "in $1"], [Zd("varying"), "out $1"]], zR = [...yS, [Zd("varying"), "in $1"]], bS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]], UR = [...bS, [Zd("in"), "attribute $1"], [Zd("out"), "varying $1"]], jR = [...bS, [Zd("in"), "varying $1"]], vy = "gl_FragColor", xy = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/, GR = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function VR(n, e, t) {
  switch (e) {
    case 300:
      return t ? ym(n, NR) : qR(n);
    case 100:
      return t ? ym(n, UR) : HR(n);
    default:
      throw new Error("unknown GLSL version ".concat(e));
  }
}
function ym(n, e) {
  for (const [t, r] of e)
    n = n.replace(t, r);
  return n;
}
function qR(n) {
  n = ym(n, zR);
  const e = n.match(xy);
  if (e) {
    const t = e[1];
    n = n.replace(new RegExp("\\b".concat(vy, "\\b"), "g"), t);
  } else {
    const t = "fragmentColor";
    n = n.replace(GR, (r) => "out vec4 ".concat(t, `;
`).concat(r)).replace(new RegExp("\\b".concat(vy, "\\b"), "g"), t);
  }
  return n;
}
function HR(n) {
  n = ym(n, jR);
  const e = n.match(xy);
  if (e) {
    const t = e[1];
    n = n.replace(xy, "").replace(new RegExp("\\b".concat(t, "\\b"), "g"), vy);
  }
  return n;
}
const WR = `

`.concat(Wg, `

`), vS = {
  [kp]: "vertex",
  [N1]: "fragment"
}, XR = `precision highp float;

`;
function $R(n, e) {
  const {
    vs: t,
    fs: r
  } = e, i = wR(e.modules || []);
  return {
    gl: n,
    vs: Ix(n, Object.assign({}, e, {
      source: t,
      type: kp,
      modules: i
    })),
    fs: Ix(n, Object.assign({}, e, {
      source: r,
      type: N1,
      modules: i
    })),
    getUniforms: ZR(i)
  };
}
function Ix(n, e) {
  let {
    id: t,
    source: r,
    type: i,
    modules: o,
    defines: c = {},
    hookFunctions: l = [],
    inject: _ = {},
    transpileToGLSL100: b = !1,
    prologue: w = !0,
    log: T
  } = e;
  xa(typeof r == "string", "shader source must be a string");
  const I = i === kp, P = r.split(`
`);
  let k = 100, U = "", G = r;
  P[0].indexOf("#version ") === 0 ? (k = 300, U = P[0], G = P.slice(1).join(`
`)) : U = "#version ".concat(k);
  const H = {};
  o.forEach((Le) => {
    Object.assign(H, Le.getDefines());
  }), Object.assign(H, c);
  let $ = w ? "".concat(U, `
`).concat(YR({
    id: t,
    source: r,
    type: i
  }), `
`).concat(JR({
    type: i
  }), `
`).concat(RR(n), `
`).concat(OR(n), `
`).concat(KR(H), `
`).concat(I ? "" : XR, `
`) : "".concat(U, `
`);
  const ie = e6(l), ge = {}, Se = {}, Re = {};
  for (const Le in _) {
    const _e = typeof _[Le] == "string" ? {
      injection: _[Le],
      order: 0
    } : _[Le], Ge = Le.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (Ge) {
      const ke = Ge[2], oe = Ge[3];
      ke ? oe === "decl" ? Se[Le] = [_e] : Re[Le] = [_e] : ge[Le] = [_e];
    } else
      Re[Le] = [_e];
  }
  for (const Le of o) {
    T && Le.checkDeprecations(G, T);
    const _e = Le.getModuleSource(i, k);
    $ += _e;
    const Ge = Le.injections[i];
    for (const ke in Ge) {
      const oe = ke.match(/^(v|f)s:#([\w-]+)$/);
      if (oe) {
        const Te = oe[2] === "decl" ? Se : Re;
        Te[ke] = Te[ke] || [], Te[ke].push(Ge[ke]);
      } else
        ge[ke] = ge[ke] || [], ge[ke].push(Ge[ke]);
    }
  }
  return $ += WR, $ = Cx($, i, Se), $ += QR(ie[i], ge), $ += G, $ = Cx($, i, Re), $ = VR($, b ? 100 : k, I), $;
}
function ZR(n) {
  return function(t) {
    const r = {};
    for (const i of n) {
      const o = i.getUniforms(t, r);
      Object.assign(r, o);
    }
    return r;
  };
}
function JR(n) {
  let {
    type: e
  } = n;
  return `
#define SHADER_TYPE_`.concat(vS[e].toUpperCase(), `
`);
}
function YR(n) {
  let {
    id: e,
    source: t,
    type: r
  } = n;
  return e && typeof e == "string" && t.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME `.concat(e, "_").concat(vS[r], `

`) : "";
}
function KR() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = 0, t = "";
  for (const r in n) {
    e === 0 && (t += `
// APPLICATION DEFINES
`), e++;
    const i = n[r];
    (i || Number.isFinite(i)) && (t += "#define ".concat(r.toUpperCase(), " ").concat(n[r], `
`));
  }
  return e === 0 && (t += `
`), t;
}
function QR(n, e) {
  let t = "";
  for (const r in n) {
    const i = n[r];
    if (t += "void ".concat(i.signature, ` {
`), i.header && (t += "  ".concat(i.header)), e[r]) {
      const o = e[r];
      o.sort((c, l) => c.order - l.order);
      for (const c of o)
        t += "  ".concat(c.injection, `
`);
    }
    i.footer && (t += "  ".concat(i.footer)), t += `}
`;
  }
  return t;
}
function e6(n) {
  const e = {
    vs: {},
    fs: {}
  };
  return n.forEach((t) => {
    let r;
    typeof t != "string" ? (r = t, t = r.hook) : r = {}, t = t.trim();
    const [i, o] = t.split(":"), c = t.replace(/\(.+/, "");
    e[i][c] = Object.assign(r, {
      signature: o
    });
  }), e;
}
const t6 = "void main() {gl_FragColor = vec4(0);}", xS = `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`, n6 = `#version 300 es
`.concat(xS);
function wS(n, e) {
  e = Array.isArray(e) ? e : [e];
  const t = n.replace(/^\s+/, "").split(/\s+/), [r, i, o] = t;
  if (!e.includes(r) || !i || !o)
    return null;
  const c = o.split(";")[0];
  return {
    qualifier: r,
    type: i,
    name: c
  };
}
function AS() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    version: e = 100,
    input: t,
    inputType: r,
    output: i
  } = n;
  if (!t)
    return e === 300 ? n6 : e > 300 ? "#version ".concat(e, `
`).concat(xS) : t6;
  const o = s6(t, r);
  return e >= 300 ? "#version ".concat(e, " ").concat(e === 300 ? "es" : "", `
in `).concat(r, " ").concat(t, `;
out vec4 `).concat(i, `;
void main() {
  `).concat(i, " = ").concat(o, `;
}`) : "varying ".concat(r, " ").concat(t, `;
void main() {
  gl_FragColor = `).concat(o, `;
}`);
}
function r6(n) {
  switch (n) {
    case "float":
      return "x";
    case "vec2":
      return "xy";
    case "vec3":
      return "xyz";
    case "vec4":
      return "xyzw";
    default:
      return xa(!1), null;
  }
}
function i6(n) {
  switch (n) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
    default:
      return xa(!1), null;
  }
}
function s6(n, e) {
  switch (e) {
    case "float":
      return "vec4(".concat(n, ", 0.0, 0.0, 1.0)");
    case "vec2":
      return "vec4(".concat(n, ", 0.0, 1.0)");
    case "vec3":
      return "vec4(".concat(n, ", 1.0)");
    case "vec4":
      return n;
    default:
      return xa(!1), null;
  }
}
const o6 = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`, a6 = {
  name: "fp32",
  vs: o6,
  fs: null
};
function vl(n, e) {
  if (!n)
    throw new Error("math.gl assertion ".concat(e));
}
const l6 = 1 / Math.PI * 180, c6 = 1 / 180 * Math.PI, ss = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0
};
function u6(n) {
  let {
    precision: e = ss.precision
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return n = p6(n), "".concat(parseFloat(n.toPrecision(e)));
}
function Wu(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function h6(n) {
  return f6(n);
}
function d6(n) {
  return Qc(n);
}
function f6(n, e) {
  return U1(n, (t) => t * c6, e);
}
function Qc(n, e) {
  return U1(n, (t) => t * l6, e);
}
function eu(n, e, t) {
  return U1(n, (r) => Math.max(e, Math.min(t, r)));
}
function bm(n, e, t) {
  return Wu(n) ? n.map((r, i) => bm(r, e[i], t)) : t * e + (1 - t) * n;
}
function Sl(n, e, t) {
  const r = ss.EPSILON;
  t && (ss.EPSILON = t);
  try {
    if (n === e)
      return !0;
    if (Wu(n) && Wu(e)) {
      if (n.length !== e.length)
        return !1;
      for (let i = 0; i < n.length; ++i)
        if (!Sl(n[i], e[i]))
          return !1;
      return !0;
    }
    return n && n.equals ? n.equals(e) : e && e.equals ? e.equals(n) : typeof n == "number" && typeof e == "number" ? Math.abs(n - e) <= ss.EPSILON * Math.max(1, Math.abs(n), Math.abs(e)) : !1;
  } finally {
    ss.EPSILON = r;
  }
}
function p6(n) {
  return Math.round(n / ss.EPSILON) * ss.EPSILON;
}
function g6(n) {
  return n.clone ? n.clone() : new Array(n.length);
}
function U1(n, e, t) {
  if (Wu(n)) {
    const r = n;
    t = t || g6(r);
    for (let i = 0; i < t.length && i < r.length; ++i)
      t[i] = e(n[i], i, t);
    return t;
  }
  return e(n);
}
function m6(n) {
  function e() {
    var t = Reflect.construct(n, Array.from(arguments));
    return Object.setPrototypeOf(t, Object.getPrototypeOf(this)), t;
  }
  return e.prototype = Object.create(n.prototype, {
    constructor: {
      value: n,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), Object.setPrototypeOf ? Object.setPrototypeOf(e, n) : e.__proto__ = n, e;
}
class j1 extends m6(Array) {
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let r = 0; r < this.ELEMENTS; ++r)
      this[r] = e[r + t];
    return this.check();
  }
  toArray() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let r = 0; r < this.ELEMENTS; ++r)
      e[t + r] = this[r];
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : this.fromObject(e);
  }
  to(e) {
    return e === this ? this : Wu(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(ss);
  }
  formatString(e) {
    let t = "";
    for (let r = 0; r < this.ELEMENTS; ++r)
      t += (r > 0 ? ", " : "") + u6(this[r], e);
    return "".concat(e.printTypes ? this.constructor.name : "", "[").concat(t, "]");
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (!Sl(this[t], e[t]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, t, r) {
    if (r === void 0)
      return this.lerp(this, e, t);
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const o = e[i];
      this[i] = o + r * (t[i] - o);
    }
    return this.check();
  }
  min(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.min(e[t], this[t]);
    return this.check();
  }
  max(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.max(e[t], this[t]);
    return this.check();
  }
  clamp(e, t) {
    for (let r = 0; r < this.ELEMENTS; ++r)
      this[r] = Math.min(Math.max(this[r], e[r]), t[r]);
    return this.check();
  }
  add() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    for (const i of t)
      for (let o = 0; o < this.ELEMENTS; ++o)
        this[o] += i[o];
    return this.check();
  }
  subtract() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    for (const i of t)
      for (let o = 0; o < this.ELEMENTS; ++o)
        this[o] -= i[o];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
    else
      for (let t = 0; t < this.ELEMENTS && t < e.length; ++t)
        this[t] *= e[t];
    return this.check();
  }
  multiplyByScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  check() {
    if (ss.debug && !this.validate())
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    return this;
  }
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e = e && Number.isFinite(this[t]);
    return e;
  }
  sub(e) {
    return this.subtract(e);
  }
  setScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = e;
    return this.check();
  }
  addScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] += e;
    return this.check();
  }
  subScalar(e) {
    return this.addScalar(-e);
  }
  multiplyScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  clampScalar(e, t) {
    for (let r = 0; r < this.ELEMENTS; ++r)
      this[r] = Math.min(Math.max(this[r], e), t);
    return this.check();
  }
  get elements() {
    return this;
  }
}
function _6(n, e) {
  if (n.length !== e)
    return !1;
  for (let t = 0; t < n.length; ++t)
    if (!Number.isFinite(n[t]))
      return !1;
  return !0;
}
function Ar(n) {
  if (!Number.isFinite(n))
    throw new Error("Invalid number ".concat(n));
  return n;
}
function cp(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (ss.debug && !_6(n, e))
    throw new Error("math.gl: ".concat(t, " some fields set to invalid numbers'"));
  return n;
}
class G1 extends j1 {
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Ar(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Ar(e);
  }
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  magnitude() {
    return this.len();
  }
  lengthSquared() {
    let e = 0;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e += this[t] * this[t];
    return e;
  }
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let t = 0;
    for (let r = 0; r < this.ELEMENTS; ++r) {
      const i = this[r] - e[r];
      t += i * i;
    }
    return Ar(t);
  }
  dot(e) {
    let t = 0;
    for (let r = 0; r < this.ELEMENTS; ++r)
      t += this[r] * e[r];
    return Ar(t);
  }
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] /= e;
    return this.check();
  }
  multiply() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    for (const i of t)
      for (let o = 0; o < this.ELEMENTS; ++o)
        this[o] *= i[o];
    return this.check();
  }
  divide() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    for (const i of t)
      for (let o = 0; o < this.ELEMENTS; ++o)
        this[o] /= i[o];
    return this.check();
  }
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return vl(e >= 0 && e < this.ELEMENTS, "index is out of range"), Ar(this[e]);
  }
  setComponent(e, t) {
    return vl(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
  }
  addVectors(e, t) {
    return this.copy(e).add(t);
  }
  subVectors(e, t) {
    return this.copy(e).subtract(t);
  }
  multiplyVectors(e, t) {
    return this.copy(e).multiply(t);
  }
  addScaledVector(e, t) {
    return this.add(new this.constructor(e).multiplyScalar(t));
  }
}
var up = 1e-6, El = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var n = 0, e = arguments.length; e--; )
    n += arguments[e] * arguments[e];
  return Math.sqrt(n);
});
function y6() {
  var n = new El(2);
  return El != Float32Array && (n[0] = 0, n[1] = 0), n;
}
function Px(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
}
function b6(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n;
}
function SS(n, e, t, r) {
  var i = e[0], o = e[1];
  return n[0] = i + r * (t[0] - i), n[1] = o + r * (t[1] - o), n;
}
function v6(n, e, t) {
  var r = e[0], i = e[1];
  return n[0] = t[0] * r + t[2] * i, n[1] = t[1] * r + t[3] * i, n;
}
function x6(n, e, t) {
  var r = e[0], i = e[1];
  return n[0] = t[0] * r + t[2] * i + t[4], n[1] = t[1] * r + t[3] * i + t[5], n;
}
function ES(n, e, t) {
  var r = e[0], i = e[1];
  return n[0] = t[0] * r + t[3] * i + t[6], n[1] = t[1] * r + t[4] * i + t[7], n;
}
function TS(n, e, t) {
  var r = e[0], i = e[1];
  return n[0] = t[0] * r + t[4] * i + t[12], n[1] = t[1] * r + t[5] * i + t[13], n;
}
(function() {
  var n = y6();
  return function(e, t, r, i, o, c) {
    var l, _;
    for (t || (t = 2), r || (r = 0), i ? _ = Math.min(i * t + r, e.length) : _ = e.length, l = r; l < _; l += t)
      n[0] = e[l], n[1] = e[l + 1], o(n, n, c), e[l] = n[0], e[l + 1] = n[1];
    return e;
  };
})();
function CS(n, e, t) {
  const r = e[0], i = e[1], o = t[3] * r + t[7] * i || 1;
  return n[0] = (t[0] * r + t[4] * i) / o, n[1] = (t[1] * r + t[5] * i) / o, n;
}
function IS(n, e, t) {
  const r = e[0], i = e[1], o = e[2], c = t[3] * r + t[7] * i + t[11] * o || 1;
  return n[0] = (t[0] * r + t[4] * i + t[8] * o) / c, n[1] = (t[1] * r + t[5] * i + t[9] * o) / c, n[2] = (t[2] * r + t[6] * i + t[10] * o) / c, n;
}
function w6(n, e, t) {
  const r = e[0], i = e[1];
  return n[0] = t[0] * r + t[2] * i, n[1] = t[1] * r + t[3] * i, n[2] = e[2], n;
}
function A6(n, e, t) {
  const r = e[0], i = e[1];
  return n[0] = t[0] * r + t[2] * i, n[1] = t[1] * r + t[3] * i, n[2] = e[2], n[3] = e[3], n;
}
function PS(n, e, t) {
  const r = e[0], i = e[1], o = e[2];
  return n[0] = t[0] * r + t[3] * i + t[6] * o, n[1] = t[1] * r + t[4] * i + t[7] * o, n[2] = t[2] * r + t[5] * i + t[8] * o, n[3] = e[3], n;
}
class V1 extends G1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    super(2), Wu(e) && arguments.length === 1 ? this.copy(e) : (ss.debug && (Ar(e), Ar(t)), this[0] = e, this[1] = t);
  }
  set(e, t) {
    return this[0] = e, this[1] = t, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return ss.debug && (Ar(e.x), Ar(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  get ELEMENTS() {
    return 2;
  }
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  transform(e) {
    return this.transformAsPoint(e);
  }
  transformAsPoint(e) {
    return TS(this, this, e), this.check();
  }
  transformAsVector(e) {
    return CS(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return ES(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return x6(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return v6(this, this, e), this.check();
  }
}
function LS() {
  var n = new El(3);
  return El != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n;
}
function MS(n) {
  var e = n[0], t = n[1], r = n[2];
  return Math.hypot(e, t, r);
}
function Lx(n, e, t) {
  var r = new El(3);
  return r[0] = n, r[1] = e, r[2] = t, r;
}
function S6(n, e, t) {
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n;
}
function E6(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n;
}
function T6(n, e) {
  var t = e[0], r = e[1], i = e[2], o = t * t + r * r + i * i;
  return o > 0 && (o = 1 / Math.sqrt(o)), n[0] = e[0] * o, n[1] = e[1] * o, n[2] = e[2] * o, n;
}
function q1(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
}
function Xg(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = t[0], l = t[1], _ = t[2];
  return n[0] = i * _ - o * l, n[1] = o * c - r * _, n[2] = r * l - i * c, n;
}
function H1(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = t[3] * r + t[7] * i + t[11] * o + t[15];
  return c = c || 1, n[0] = (t[0] * r + t[4] * i + t[8] * o + t[12]) / c, n[1] = (t[1] * r + t[5] * i + t[9] * o + t[13]) / c, n[2] = (t[2] * r + t[6] * i + t[10] * o + t[14]) / c, n;
}
function BS(n, e, t) {
  var r = e[0], i = e[1], o = e[2];
  return n[0] = r * t[0] + i * t[3] + o * t[6], n[1] = r * t[1] + i * t[4] + o * t[7], n[2] = r * t[2] + i * t[5] + o * t[8], n;
}
function RS(n, e, t) {
  var r = t[0], i = t[1], o = t[2], c = t[3], l = e[0], _ = e[1], b = e[2], w = i * b - o * _, T = o * l - r * b, I = r * _ - i * l, P = i * I - o * T, k = o * w - r * I, U = r * T - i * w, G = c * 2;
  return w *= G, T *= G, I *= G, P *= 2, k *= 2, U *= 2, n[0] = l + w + P, n[1] = _ + T + k, n[2] = b + I + U, n;
}
function C6(n, e, t, r) {
  var i = [], o = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], o[0] = i[0], o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), n[0] = o[0] + t[0], n[1] = o[1] + t[1], n[2] = o[2] + t[2], n;
}
function I6(n, e, t, r) {
  var i = [], o = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), o[1] = i[1], o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), n[0] = o[0] + t[0], n[1] = o[1] + t[1], n[2] = o[2] + t[2], n;
}
function P6(n, e, t, r) {
  var i = [], o = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), o[2] = i[2], n[0] = o[0] + t[0], n[1] = o[1] + t[1], n[2] = o[2] + t[2], n;
}
function L6(n, e) {
  var t = n[0], r = n[1], i = n[2], o = e[0], c = e[1], l = e[2], _ = Math.sqrt(t * t + r * r + i * i), b = Math.sqrt(o * o + c * c + l * l), w = _ * b, T = w && q1(n, e) / w;
  return Math.acos(Math.min(Math.max(T, -1), 1));
}
var M6 = S6, B6 = MS;
(function() {
  var n = LS();
  return function(e, t, r, i, o, c) {
    var l, _;
    for (t || (t = 3), r || (r = 0), i ? _ = Math.min(i * t + r, e.length) : _ = e.length, l = r; l < _; l += t)
      n[0] = e[l], n[1] = e[l + 1], n[2] = e[l + 2], o(n, n, c), e[l] = n[0], e[l + 1] = n[1], e[l + 2] = n[2];
    return e;
  };
})();
const u_ = [0, 0, 0];
let vg;
class Ke extends G1 {
  static get ZERO() {
    return vg || (vg = new Ke(0, 0, 0), Object.freeze(vg)), vg;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    super(-0, -0, -0), arguments.length === 1 && Wu(e) ? this.copy(e) : (ss.debug && (Ar(e), Ar(t), Ar(r)), this[0] = e, this[1] = t, this[2] = r);
  }
  set(e, t, r) {
    return this[0] = e, this[1] = t, this[2] = r, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return ss.debug && (Ar(e.x), Ar(e.y), Ar(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ar(e);
  }
  angle(e) {
    return L6(this, e);
  }
  cross(e) {
    return Xg(this, this, e), this.check();
  }
  rotateX(e) {
    let {
      radians: t,
      origin: r = u_
    } = e;
    return C6(this, this, r, t), this.check();
  }
  rotateY(e) {
    let {
      radians: t,
      origin: r = u_
    } = e;
    return I6(this, this, r, t), this.check();
  }
  rotateZ(e) {
    let {
      radians: t,
      origin: r = u_
    } = e;
    return P6(this, this, r, t), this.check();
  }
  transform(e) {
    return this.transformAsPoint(e);
  }
  transformAsPoint(e) {
    return H1(this, this, e), this.check();
  }
  transformAsVector(e) {
    return IS(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return BS(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return w6(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return RS(this, this, e), this.check();
  }
}
let xg;
class W1 extends G1 {
  static get ZERO() {
    return xg || (xg = new W1(0, 0, 0, 0), Object.freeze(xg)), xg;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    super(-0, -0, -0, -0), Wu(e) && arguments.length === 1 ? this.copy(e) : (ss.debug && (Ar(e), Ar(t), Ar(r), Ar(i)), this[0] = e, this[1] = t, this[2] = r, this[3] = i);
  }
  set(e, t, r, i) {
    return this[0] = e, this[1] = t, this[2] = r, this[3] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return ss.debug && (Ar(e.x), Ar(e.y), Ar(e.z), Ar(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ar(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Ar(e);
  }
  transform(e) {
    return H1(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return PS(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return A6(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return RS(this, this, e), this.check();
  }
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class OS extends j1 {
  toString() {
    let e = "[";
    if (ss.printRowMajor) {
      e += "row-major:";
      for (let t = 0; t < this.RANK; ++t)
        for (let r = 0; r < this.RANK; ++r)
          e += " ".concat(this[r * this.RANK + t]);
    } else {
      e += "column-major:";
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += " ".concat(this[t]);
    }
    return e += "]", e;
  }
  getElementIndex(e, t) {
    return t * this.RANK + e;
  }
  getElement(e, t) {
    return this[t * this.RANK + e];
  }
  setElement(e, t, r) {
    return this[t * this.RANK + e] = Ar(r), this;
  }
  getColumn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Array(this.RANK).fill(-0);
    const r = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      t[i] = this[r + i];
    return t;
  }
  setColumn(e, t) {
    const r = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      this[r + i] = t[i];
    return this;
  }
}
function R6() {
  var n = new El(9);
  return El != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n;
}
function O6(n, e) {
  if (n === e) {
    var t = e[1], r = e[2], i = e[5];
    n[1] = e[3], n[2] = e[6], n[3] = t, n[5] = e[7], n[6] = r, n[7] = i;
  } else
    n[0] = e[0], n[1] = e[3], n[2] = e[6], n[3] = e[1], n[4] = e[4], n[5] = e[7], n[6] = e[2], n[7] = e[5], n[8] = e[8];
  return n;
}
function D6(n, e) {
  var t = e[0], r = e[1], i = e[2], o = e[3], c = e[4], l = e[5], _ = e[6], b = e[7], w = e[8], T = w * c - l * b, I = -w * o + l * _, P = b * o - c * _, k = t * T + r * I + i * P;
  return k ? (k = 1 / k, n[0] = T * k, n[1] = (-w * r + i * b) * k, n[2] = (l * r - i * c) * k, n[3] = I * k, n[4] = (w * t - i * _) * k, n[5] = (-l * t + i * o) * k, n[6] = P * k, n[7] = (-b * t + r * _) * k, n[8] = (c * t - r * o) * k, n) : null;
}
function F6(n) {
  var e = n[0], t = n[1], r = n[2], i = n[3], o = n[4], c = n[5], l = n[6], _ = n[7], b = n[8];
  return e * (b * o - c * _) + t * (-b * i + c * l) + r * (_ * i - o * l);
}
function Mx(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = e[3], l = e[4], _ = e[5], b = e[6], w = e[7], T = e[8], I = t[0], P = t[1], k = t[2], U = t[3], G = t[4], H = t[5], $ = t[6], ie = t[7], ge = t[8];
  return n[0] = I * r + P * c + k * b, n[1] = I * i + P * l + k * w, n[2] = I * o + P * _ + k * T, n[3] = U * r + G * c + H * b, n[4] = U * i + G * l + H * w, n[5] = U * o + G * _ + H * T, n[6] = $ * r + ie * c + ge * b, n[7] = $ * i + ie * l + ge * w, n[8] = $ * o + ie * _ + ge * T, n;
}
function k6(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = e[3], l = e[4], _ = e[5], b = e[6], w = e[7], T = e[8], I = t[0], P = t[1];
  return n[0] = r, n[1] = i, n[2] = o, n[3] = c, n[4] = l, n[5] = _, n[6] = I * r + P * c + b, n[7] = I * i + P * l + w, n[8] = I * o + P * _ + T, n;
}
function N6(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = e[3], l = e[4], _ = e[5], b = e[6], w = e[7], T = e[8], I = Math.sin(t), P = Math.cos(t);
  return n[0] = P * r + I * c, n[1] = P * i + I * l, n[2] = P * o + I * _, n[3] = P * c - I * r, n[4] = P * l - I * i, n[5] = P * _ - I * o, n[6] = b, n[7] = w, n[8] = T, n;
}
function Bx(n, e, t) {
  var r = t[0], i = t[1];
  return n[0] = r * e[0], n[1] = r * e[1], n[2] = r * e[2], n[3] = i * e[3], n[4] = i * e[4], n[5] = i * e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n;
}
function z6(n, e) {
  var t = e[0], r = e[1], i = e[2], o = e[3], c = t + t, l = r + r, _ = i + i, b = t * c, w = r * c, T = r * l, I = i * c, P = i * l, k = i * _, U = o * c, G = o * l, H = o * _;
  return n[0] = 1 - T - k, n[3] = w - H, n[6] = I + G, n[1] = w + H, n[4] = 1 - b - k, n[7] = P - U, n[2] = I - G, n[5] = P + U, n[8] = 1 - b - T, n;
}
var wy;
(function(n) {
  n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL1ROW0 = 3] = "COL1ROW0", n[n.COL1ROW1 = 4] = "COL1ROW1", n[n.COL1ROW2 = 5] = "COL1ROW2", n[n.COL2ROW0 = 6] = "COL2ROW0", n[n.COL2ROW1 = 7] = "COL2ROW1", n[n.COL2ROW2 = 8] = "COL2ROW2";
})(wy || (wy = {}));
const U6 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class Ci extends OS {
  static get IDENTITY() {
    return G6();
  }
  static get ZERO() {
    return j6();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return wy;
  }
  constructor(e) {
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : r.length > 0 ? this.copy([e, ...r]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  identity() {
    return this.copy(U6);
  }
  fromObject(e) {
    return this.check();
  }
  fromQuaternion(e) {
    return z6(this, e), this.check();
  }
  set(e, t, r, i, o, c, l, _, b) {
    return this[0] = e, this[1] = t, this[2] = r, this[3] = i, this[4] = o, this[5] = c, this[6] = l, this[7] = _, this[8] = b, this.check();
  }
  setRowMajor(e, t, r, i, o, c, l, _, b) {
    return this[0] = e, this[1] = i, this[2] = l, this[3] = t, this[4] = o, this[5] = _, this[6] = r, this[7] = c, this[8] = b, this.check();
  }
  determinant() {
    return F6(this);
  }
  transpose() {
    return O6(this, this), this.check();
  }
  invert() {
    return D6(this, this), this.check();
  }
  multiplyLeft(e) {
    return Mx(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Mx(this, this, e), this.check();
  }
  rotate(e) {
    return N6(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? Bx(this, this, e) : Bx(this, this, [e, e]), this.check();
  }
  translate(e) {
    return k6(this, this, e), this.check();
  }
  transform(e, t) {
    let r;
    switch (e.length) {
      case 2:
        r = ES(t || [-0, -0], e, this);
        break;
      case 3:
        r = BS(t || [-0, -0, -0], e, this);
        break;
      case 4:
        r = PS(t || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return cp(r, e.length), r;
  }
  transformVector(e, t) {
    return this.transform(e, t);
  }
  transformVector2(e, t) {
    return this.transform(e, t);
  }
  transformVector3(e, t) {
    return this.transform(e, t);
  }
}
let wg, Ag;
function j6() {
  return wg || (wg = new Ci([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(wg)), wg;
}
function G6() {
  return Ag || (Ag = new Ci(), Object.freeze(Ag)), Ag;
}
function V6(n) {
  return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function q6(n, e) {
  if (n === e) {
    var t = e[1], r = e[2], i = e[3], o = e[6], c = e[7], l = e[11];
    n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = t, n[6] = e[9], n[7] = e[13], n[8] = r, n[9] = o, n[11] = e[14], n[12] = i, n[13] = c, n[14] = l;
  } else
    n[0] = e[0], n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = e[1], n[5] = e[5], n[6] = e[9], n[7] = e[13], n[8] = e[2], n[9] = e[6], n[10] = e[10], n[11] = e[14], n[12] = e[3], n[13] = e[7], n[14] = e[11], n[15] = e[15];
  return n;
}
function Ay(n, e) {
  var t = e[0], r = e[1], i = e[2], o = e[3], c = e[4], l = e[5], _ = e[6], b = e[7], w = e[8], T = e[9], I = e[10], P = e[11], k = e[12], U = e[13], G = e[14], H = e[15], $ = t * l - r * c, ie = t * _ - i * c, ge = t * b - o * c, Se = r * _ - i * l, Re = r * b - o * l, Le = i * b - o * _, _e = w * U - T * k, Ge = w * G - I * k, ke = w * H - P * k, oe = T * G - I * U, pe = T * H - P * U, Te = I * H - P * G, xe = $ * Te - ie * pe + ge * oe + Se * ke - Re * Ge + Le * _e;
  return xe ? (xe = 1 / xe, n[0] = (l * Te - _ * pe + b * oe) * xe, n[1] = (i * pe - r * Te - o * oe) * xe, n[2] = (U * Le - G * Re + H * Se) * xe, n[3] = (I * Re - T * Le - P * Se) * xe, n[4] = (_ * ke - c * Te - b * Ge) * xe, n[5] = (t * Te - i * ke + o * Ge) * xe, n[6] = (G * ge - k * Le - H * ie) * xe, n[7] = (w * Le - I * ge + P * ie) * xe, n[8] = (c * pe - l * ke + b * _e) * xe, n[9] = (r * ke - t * pe - o * _e) * xe, n[10] = (k * Re - U * ge + H * $) * xe, n[11] = (T * ge - w * Re - P * $) * xe, n[12] = (l * Ge - c * oe - _ * _e) * xe, n[13] = (t * oe - r * Ge + i * _e) * xe, n[14] = (U * ie - k * Se - G * $) * xe, n[15] = (w * Se - T * ie + I * $) * xe, n) : null;
}
function H6(n) {
  var e = n[0], t = n[1], r = n[2], i = n[3], o = n[4], c = n[5], l = n[6], _ = n[7], b = n[8], w = n[9], T = n[10], I = n[11], P = n[12], k = n[13], U = n[14], G = n[15], H = e * c - t * o, $ = e * l - r * o, ie = e * _ - i * o, ge = t * l - r * c, Se = t * _ - i * c, Re = r * _ - i * l, Le = b * k - w * P, _e = b * U - T * P, Ge = b * G - I * P, ke = w * U - T * k, oe = w * G - I * k, pe = T * G - I * U;
  return H * pe - $ * oe + ie * ke + ge * Ge - Se * _e + Re * Le;
}
function Rh(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = e[3], l = e[4], _ = e[5], b = e[6], w = e[7], T = e[8], I = e[9], P = e[10], k = e[11], U = e[12], G = e[13], H = e[14], $ = e[15], ie = t[0], ge = t[1], Se = t[2], Re = t[3];
  return n[0] = ie * r + ge * l + Se * T + Re * U, n[1] = ie * i + ge * _ + Se * I + Re * G, n[2] = ie * o + ge * b + Se * P + Re * H, n[3] = ie * c + ge * w + Se * k + Re * $, ie = t[4], ge = t[5], Se = t[6], Re = t[7], n[4] = ie * r + ge * l + Se * T + Re * U, n[5] = ie * i + ge * _ + Se * I + Re * G, n[6] = ie * o + ge * b + Se * P + Re * H, n[7] = ie * c + ge * w + Se * k + Re * $, ie = t[8], ge = t[9], Se = t[10], Re = t[11], n[8] = ie * r + ge * l + Se * T + Re * U, n[9] = ie * i + ge * _ + Se * I + Re * G, n[10] = ie * o + ge * b + Se * P + Re * H, n[11] = ie * c + ge * w + Se * k + Re * $, ie = t[12], ge = t[13], Se = t[14], Re = t[15], n[12] = ie * r + ge * l + Se * T + Re * U, n[13] = ie * i + ge * _ + Se * I + Re * G, n[14] = ie * o + ge * b + Se * P + Re * H, n[15] = ie * c + ge * w + Se * k + Re * $, n;
}
function vm(n, e, t) {
  var r = t[0], i = t[1], o = t[2], c, l, _, b, w, T, I, P, k, U, G, H;
  return e === n ? (n[12] = e[0] * r + e[4] * i + e[8] * o + e[12], n[13] = e[1] * r + e[5] * i + e[9] * o + e[13], n[14] = e[2] * r + e[6] * i + e[10] * o + e[14], n[15] = e[3] * r + e[7] * i + e[11] * o + e[15]) : (c = e[0], l = e[1], _ = e[2], b = e[3], w = e[4], T = e[5], I = e[6], P = e[7], k = e[8], U = e[9], G = e[10], H = e[11], n[0] = c, n[1] = l, n[2] = _, n[3] = b, n[4] = w, n[5] = T, n[6] = I, n[7] = P, n[8] = k, n[9] = U, n[10] = G, n[11] = H, n[12] = c * r + w * i + k * o + e[12], n[13] = l * r + T * i + U * o + e[13], n[14] = _ * r + I * i + G * o + e[14], n[15] = b * r + P * i + H * o + e[15]), n;
}
function X1(n, e, t) {
  var r = t[0], i = t[1], o = t[2];
  return n[0] = e[0] * r, n[1] = e[1] * r, n[2] = e[2] * r, n[3] = e[3] * r, n[4] = e[4] * i, n[5] = e[5] * i, n[6] = e[6] * i, n[7] = e[7] * i, n[8] = e[8] * o, n[9] = e[9] * o, n[10] = e[10] * o, n[11] = e[11] * o, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n;
}
function W6(n, e, t, r) {
  var i = r[0], o = r[1], c = r[2], l = Math.hypot(i, o, c), _, b, w, T, I, P, k, U, G, H, $, ie, ge, Se, Re, Le, _e, Ge, ke, oe, pe, Te, xe, et;
  return l < up ? null : (l = 1 / l, i *= l, o *= l, c *= l, _ = Math.sin(t), b = Math.cos(t), w = 1 - b, T = e[0], I = e[1], P = e[2], k = e[3], U = e[4], G = e[5], H = e[6], $ = e[7], ie = e[8], ge = e[9], Se = e[10], Re = e[11], Le = i * i * w + b, _e = o * i * w + c * _, Ge = c * i * w - o * _, ke = i * o * w - c * _, oe = o * o * w + b, pe = c * o * w + i * _, Te = i * c * w + o * _, xe = o * c * w - i * _, et = c * c * w + b, n[0] = T * Le + U * _e + ie * Ge, n[1] = I * Le + G * _e + ge * Ge, n[2] = P * Le + H * _e + Se * Ge, n[3] = k * Le + $ * _e + Re * Ge, n[4] = T * ke + U * oe + ie * pe, n[5] = I * ke + G * oe + ge * pe, n[6] = P * ke + H * oe + Se * pe, n[7] = k * ke + $ * oe + Re * pe, n[8] = T * Te + U * xe + ie * et, n[9] = I * Te + G * xe + ge * et, n[10] = P * Te + H * xe + Se * et, n[11] = k * Te + $ * xe + Re * et, e !== n && (n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n);
}
function DS(n, e, t) {
  var r = Math.sin(t), i = Math.cos(t), o = e[4], c = e[5], l = e[6], _ = e[7], b = e[8], w = e[9], T = e[10], I = e[11];
  return e !== n && (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[4] = o * i + b * r, n[5] = c * i + w * r, n[6] = l * i + T * r, n[7] = _ * i + I * r, n[8] = b * i - o * r, n[9] = w * i - c * r, n[10] = T * i - l * r, n[11] = I * i - _ * r, n;
}
function X6(n, e, t) {
  var r = Math.sin(t), i = Math.cos(t), o = e[0], c = e[1], l = e[2], _ = e[3], b = e[8], w = e[9], T = e[10], I = e[11];
  return e !== n && (n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = o * i - b * r, n[1] = c * i - w * r, n[2] = l * i - T * r, n[3] = _ * i - I * r, n[8] = o * r + b * i, n[9] = c * r + w * i, n[10] = l * r + T * i, n[11] = _ * r + I * i, n;
}
function FS(n, e, t) {
  var r = Math.sin(t), i = Math.cos(t), o = e[0], c = e[1], l = e[2], _ = e[3], b = e[4], w = e[5], T = e[6], I = e[7];
  return e !== n && (n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = o * i + b * r, n[1] = c * i + w * r, n[2] = l * i + T * r, n[3] = _ * i + I * r, n[4] = b * i - o * r, n[5] = w * i - c * r, n[6] = T * i - l * r, n[7] = I * i - _ * r, n;
}
function $6(n, e) {
  var t = e[0], r = e[1], i = e[2], o = e[4], c = e[5], l = e[6], _ = e[8], b = e[9], w = e[10];
  return n[0] = Math.hypot(t, r, i), n[1] = Math.hypot(o, c, l), n[2] = Math.hypot(_, b, w), n;
}
function Z6(n, e) {
  var t = e[0], r = e[1], i = e[2], o = e[3], c = t + t, l = r + r, _ = i + i, b = t * c, w = r * c, T = r * l, I = i * c, P = i * l, k = i * _, U = o * c, G = o * l, H = o * _;
  return n[0] = 1 - T - k, n[1] = w + H, n[2] = I - G, n[3] = 0, n[4] = w - H, n[5] = 1 - b - k, n[6] = P + U, n[7] = 0, n[8] = I + G, n[9] = P - U, n[10] = 1 - b - T, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function J6(n, e, t, r, i, o, c) {
  var l = 1 / (t - e), _ = 1 / (i - r), b = 1 / (o - c);
  return n[0] = o * 2 * l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = o * 2 * _, n[6] = 0, n[7] = 0, n[8] = (t + e) * l, n[9] = (i + r) * _, n[10] = (c + o) * b, n[11] = -1, n[12] = 0, n[13] = 0, n[14] = c * o * 2 * b, n[15] = 0, n;
}
function Y6(n, e, t, r, i) {
  var o = 1 / Math.tan(e / 2), c;
  return n[0] = o / t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = o, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, i != null && i !== 1 / 0 ? (c = 1 / (r - i), n[10] = (i + r) * c, n[14] = 2 * i * r * c) : (n[10] = -1, n[14] = -2 * r), n;
}
var K6 = Y6;
function Q6(n, e, t, r, i, o, c) {
  var l = 1 / (e - t), _ = 1 / (r - i), b = 1 / (o - c);
  return n[0] = -2 * l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * _, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * b, n[11] = 0, n[12] = (e + t) * l, n[13] = (i + r) * _, n[14] = (c + o) * b, n[15] = 1, n;
}
var eO = Q6;
function tO(n, e, t, r) {
  var i, o, c, l, _, b, w, T, I, P, k = e[0], U = e[1], G = e[2], H = r[0], $ = r[1], ie = r[2], ge = t[0], Se = t[1], Re = t[2];
  return Math.abs(k - ge) < up && Math.abs(U - Se) < up && Math.abs(G - Re) < up ? V6(n) : (w = k - ge, T = U - Se, I = G - Re, P = 1 / Math.hypot(w, T, I), w *= P, T *= P, I *= P, i = $ * I - ie * T, o = ie * w - H * I, c = H * T - $ * w, P = Math.hypot(i, o, c), P ? (P = 1 / P, i *= P, o *= P, c *= P) : (i = 0, o = 0, c = 0), l = T * c - I * o, _ = I * i - w * c, b = w * o - T * i, P = Math.hypot(l, _, b), P ? (P = 1 / P, l *= P, _ *= P, b *= P) : (l = 0, _ = 0, b = 0), n[0] = i, n[1] = l, n[2] = w, n[3] = 0, n[4] = o, n[5] = _, n[6] = T, n[7] = 0, n[8] = c, n[9] = b, n[10] = I, n[11] = 0, n[12] = -(i * k + o * U + c * G), n[13] = -(l * k + _ * U + b * G), n[14] = -(w * k + T * U + I * G), n[15] = 1, n);
}
function nO() {
  var n = new El(4);
  return El != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n;
}
function rO(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n;
}
function kS(n, e, t) {
  return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n;
}
function iO(n) {
  var e = n[0], t = n[1], r = n[2], i = n[3];
  return Math.hypot(e, t, r, i);
}
function sO(n) {
  var e = n[0], t = n[1], r = n[2], i = n[3];
  return e * e + t * t + r * r + i * i;
}
function oO(n, e) {
  var t = e[0], r = e[1], i = e[2], o = e[3], c = t * t + r * r + i * i + o * o;
  return c > 0 && (c = 1 / Math.sqrt(c)), n[0] = t * c, n[1] = r * c, n[2] = i * c, n[3] = o * c, n;
}
function aO(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] * e[3];
}
function lO(n, e, t, r) {
  var i = e[0], o = e[1], c = e[2], l = e[3];
  return n[0] = i + r * (t[0] - i), n[1] = o + r * (t[1] - o), n[2] = c + r * (t[2] - c), n[3] = l + r * (t[3] - l), n;
}
function Np(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = e[3];
  return n[0] = t[0] * r + t[4] * i + t[8] * o + t[12] * c, n[1] = t[1] * r + t[5] * i + t[9] * o + t[13] * c, n[2] = t[2] * r + t[6] * i + t[10] * o + t[14] * c, n[3] = t[3] * r + t[7] * i + t[11] * o + t[15] * c, n;
}
function cO(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = t[0], l = t[1], _ = t[2], b = t[3], w = b * r + l * o - _ * i, T = b * i + _ * r - c * o, I = b * o + c * i - l * r, P = -c * r - l * i - _ * o;
  return n[0] = w * b + P * -c + T * -_ - I * -l, n[1] = T * b + P * -l + I * -c - w * -_, n[2] = I * b + P * -_ + w * -l - T * -c, n[3] = e[3], n;
}
(function() {
  var n = nO();
  return function(e, t, r, i, o, c) {
    var l, _;
    for (t || (t = 4), r || (r = 0), i ? _ = Math.min(i * t + r, e.length) : _ = e.length, l = r; l < _; l += t)
      n[0] = e[l], n[1] = e[l + 1], n[2] = e[l + 2], n[3] = e[l + 3], o(n, n, c), e[l] = n[0], e[l + 1] = n[1], e[l + 2] = n[2], e[l + 3] = n[3];
    return e;
  };
})();
var Sy;
(function(n) {
  n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL0ROW3 = 3] = "COL0ROW3", n[n.COL1ROW0 = 4] = "COL1ROW0", n[n.COL1ROW1 = 5] = "COL1ROW1", n[n.COL1ROW2 = 6] = "COL1ROW2", n[n.COL1ROW3 = 7] = "COL1ROW3", n[n.COL2ROW0 = 8] = "COL2ROW0", n[n.COL2ROW1 = 9] = "COL2ROW1", n[n.COL2ROW2 = 10] = "COL2ROW2", n[n.COL2ROW3 = 11] = "COL2ROW3", n[n.COL3ROW0 = 12] = "COL3ROW0", n[n.COL3ROW1 = 13] = "COL3ROW1", n[n.COL3ROW2 = 14] = "COL3ROW2", n[n.COL3ROW3 = 15] = "COL3ROW3";
})(Sy || (Sy = {}));
const uO = 45 * Math.PI / 180, hO = 1, h_ = 0.1, d_ = 500, dO = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class lr extends OS {
  static get IDENTITY() {
    return pO();
  }
  static get ZERO() {
    return fO();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return Sy;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  set(e, t, r, i, o, c, l, _, b, w, T, I, P, k, U, G) {
    return this[0] = e, this[1] = t, this[2] = r, this[3] = i, this[4] = o, this[5] = c, this[6] = l, this[7] = _, this[8] = b, this[9] = w, this[10] = T, this[11] = I, this[12] = P, this[13] = k, this[14] = U, this[15] = G, this.check();
  }
  setRowMajor(e, t, r, i, o, c, l, _, b, w, T, I, P, k, U, G) {
    return this[0] = e, this[1] = o, this[2] = b, this[3] = P, this[4] = t, this[5] = c, this[6] = w, this[7] = k, this[8] = r, this[9] = l, this[10] = T, this[11] = U, this[12] = i, this[13] = _, this[14] = I, this[15] = G, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  identity() {
    return this.copy(dO);
  }
  fromObject(e) {
    return this.check();
  }
  fromQuaternion(e) {
    return Z6(this, e), this.check();
  }
  frustum(e) {
    const {
      left: t,
      right: r,
      bottom: i,
      top: o,
      near: c = h_,
      far: l = d_
    } = e;
    return l === 1 / 0 ? gO(this, t, r, i, o, c) : J6(this, t, r, i, o, c, l), this.check();
  }
  lookAt(e) {
    const {
      eye: t,
      center: r = [0, 0, 0],
      up: i = [0, 1, 0]
    } = e;
    return tO(this, t, r, i), this.check();
  }
  ortho(e) {
    const {
      left: t,
      right: r,
      bottom: i,
      top: o,
      near: c = h_,
      far: l = d_
    } = e;
    return eO(this, t, r, i, o, c, l), this.check();
  }
  orthographic(e) {
    const {
      fovy: t = uO,
      aspect: r = hO,
      focalDistance: i = 1,
      near: o = h_,
      far: c = d_
    } = e;
    Rx(t);
    const l = t / 2, _ = i * Math.tan(l), b = _ * r;
    return this.ortho({
      left: -b,
      right: b,
      bottom: -_,
      top: _,
      near: o,
      far: c
    });
  }
  perspective(e) {
    const {
      fovy: t = 45 * Math.PI / 180,
      aspect: r = 1,
      near: i = 0.1,
      far: o = 500
    } = e;
    return Rx(t), K6(this, t, r, i, o), this.check();
  }
  determinant() {
    return H6(this);
  }
  getScale() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  getTranslation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  getRotation(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const r = this.getScale(t), i = 1 / r[0], o = 1 / r[1], c = 1 / r[2];
    return e[0] = this[0] * i, e[1] = this[1] * o, e[2] = this[2] * c, e[3] = 0, e[4] = this[4] * i, e[5] = this[5] * o, e[6] = this[6] * c, e[7] = 0, e[8] = this[8] * i, e[9] = this[9] * o, e[10] = this[10] * c, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  getRotationMatrix3(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const r = this.getScale(t), i = 1 / r[0], o = 1 / r[1], c = 1 / r[2];
    return e[0] = this[0] * i, e[1] = this[1] * o, e[2] = this[2] * c, e[3] = this[4] * i, e[4] = this[5] * o, e[5] = this[6] * c, e[6] = this[8] * i, e[7] = this[9] * o, e[8] = this[10] * c, e;
  }
  transpose() {
    return q6(this, this), this.check();
  }
  invert() {
    return Ay(this, this), this.check();
  }
  multiplyLeft(e) {
    return Rh(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Rh(this, this, e), this.check();
  }
  rotateX(e) {
    return DS(this, this, e), this.check();
  }
  rotateY(e) {
    return X6(this, this, e), this.check();
  }
  rotateZ(e) {
    return FS(this, this, e), this.check();
  }
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  rotateAxis(e, t) {
    return W6(this, this, e, t), this.check();
  }
  scale(e) {
    return X1(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  translate(e) {
    return vm(this, this, e), this.check();
  }
  transform(e, t) {
    return e.length === 4 ? (t = Np(t || [-0, -0, -0, -0], e, this), cp(t, 4), t) : this.transformAsPoint(e, t);
  }
  transformAsPoint(e, t) {
    const {
      length: r
    } = e;
    let i;
    switch (r) {
      case 2:
        i = TS(t || [-0, -0], e, this);
        break;
      case 3:
        i = H1(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return cp(i, e.length), i;
  }
  transformAsVector(e, t) {
    let r;
    switch (e.length) {
      case 2:
        r = CS(t || [-0, -0], e, this);
        break;
      case 3:
        r = IS(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return cp(r, e.length), r;
  }
  transformPoint(e, t) {
    return this.transformAsPoint(e, t);
  }
  transformVector(e, t) {
    return this.transformAsPoint(e, t);
  }
  transformDirection(e, t) {
    return this.transformAsVector(e, t);
  }
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, t, r) {
    return this.identity().translate([e, t, r]);
  }
}
let Sg, Eg;
function fO() {
  return Sg || (Sg = new lr([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Sg)), Sg;
}
function pO() {
  return Eg || (Eg = new lr(), Object.freeze(Eg)), Eg;
}
function Rx(n) {
  if (n > Math.PI * 2)
    throw Error("expected radians");
}
function gO(n, e, t, r, i, o) {
  const c = 2 * o / (t - e), l = 2 * o / (i - r), _ = (t + e) / (t - e), b = (i + r) / (i - r), w = -1, T = -1, I = -2 * o;
  return n[0] = c, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = l, n[6] = 0, n[7] = 0, n[8] = _, n[9] = b, n[10] = w, n[11] = T, n[12] = 0, n[13] = 0, n[14] = I, n[15] = 0, n;
}
function Ox() {
  var n = new El(4);
  return El != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n;
}
function mO(n) {
  return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n;
}
function NS(n, e, t) {
  t = t * 0.5;
  var r = Math.sin(t);
  return n[0] = r * e[0], n[1] = r * e[1], n[2] = r * e[2], n[3] = Math.cos(t), n;
}
function Dx(n, e, t) {
  var r = e[0], i = e[1], o = e[2], c = e[3], l = t[0], _ = t[1], b = t[2], w = t[3];
  return n[0] = r * w + c * l + i * b - o * _, n[1] = i * w + c * _ + o * l - r * b, n[2] = o * w + c * b + r * _ - i * l, n[3] = c * w - r * l - i * _ - o * b, n;
}
function _O(n, e, t) {
  t *= 0.5;
  var r = e[0], i = e[1], o = e[2], c = e[3], l = Math.sin(t), _ = Math.cos(t);
  return n[0] = r * _ + c * l, n[1] = i * _ + o * l, n[2] = o * _ - i * l, n[3] = c * _ - r * l, n;
}
function yO(n, e, t) {
  t *= 0.5;
  var r = e[0], i = e[1], o = e[2], c = e[3], l = Math.sin(t), _ = Math.cos(t);
  return n[0] = r * _ - o * l, n[1] = i * _ + c * l, n[2] = o * _ + r * l, n[3] = c * _ - i * l, n;
}
function bO(n, e, t) {
  t *= 0.5;
  var r = e[0], i = e[1], o = e[2], c = e[3], l = Math.sin(t), _ = Math.cos(t);
  return n[0] = r * _ + i * l, n[1] = i * _ - r * l, n[2] = o * _ + c * l, n[3] = c * _ - o * l, n;
}
function vO(n, e) {
  var t = e[0], r = e[1], i = e[2];
  return n[0] = t, n[1] = r, n[2] = i, n[3] = Math.sqrt(Math.abs(1 - t * t - r * r - i * i)), n;
}
function $g(n, e, t, r) {
  var i = e[0], o = e[1], c = e[2], l = e[3], _ = t[0], b = t[1], w = t[2], T = t[3], I, P, k, U, G;
  return P = i * _ + o * b + c * w + l * T, P < 0 && (P = -P, _ = -_, b = -b, w = -w, T = -T), 1 - P > up ? (I = Math.acos(P), k = Math.sin(I), U = Math.sin((1 - r) * I) / k, G = Math.sin(r * I) / k) : (U = 1 - r, G = r), n[0] = U * i + G * _, n[1] = U * o + G * b, n[2] = U * c + G * w, n[3] = U * l + G * T, n;
}
function xO(n, e) {
  var t = e[0], r = e[1], i = e[2], o = e[3], c = t * t + r * r + i * i + o * o, l = c ? 1 / c : 0;
  return n[0] = -t * l, n[1] = -r * l, n[2] = -i * l, n[3] = o * l, n;
}
function wO(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n[3] = e[3], n;
}
function zS(n, e) {
  var t = e[0] + e[4] + e[8], r;
  if (t > 0)
    r = Math.sqrt(t + 1), n[3] = 0.5 * r, r = 0.5 / r, n[0] = (e[5] - e[7]) * r, n[1] = (e[6] - e[2]) * r, n[2] = (e[1] - e[3]) * r;
  else {
    var i = 0;
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
    var o = (i + 1) % 3, c = (i + 2) % 3;
    r = Math.sqrt(e[i * 3 + i] - e[o * 3 + o] - e[c * 3 + c] + 1), n[i] = 0.5 * r, r = 0.5 / r, n[3] = (e[o * 3 + c] - e[c * 3 + o]) * r, n[o] = (e[o * 3 + i] + e[i * 3 + o]) * r, n[c] = (e[c * 3 + i] + e[i * 3 + c]) * r;
  }
  return n;
}
var AO = rO, SO = kS, EO = aO, TO = lO, CO = iO, IO = sO, US = oO, PO = function() {
  var n = LS(), e = Lx(1, 0, 0), t = Lx(0, 1, 0);
  return function(r, i, o) {
    var c = q1(i, o);
    return c < -0.999999 ? (Xg(n, e, i), B6(n) < 1e-6 && Xg(n, t, i), T6(n, n), NS(r, n, Math.PI), r) : c > 0.999999 ? (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r) : (Xg(n, i, o), r[0] = n[0], r[1] = n[1], r[2] = n[2], r[3] = 1 + c, US(r, r));
  };
}();
(function() {
  var n = Ox(), e = Ox();
  return function(t, r, i, o, c, l) {
    return $g(n, r, c, l), $g(e, i, o, l), $g(t, n, e, 2 * l * (1 - l)), t;
  };
})();
(function() {
  var n = R6();
  return function(e, t, r, i) {
    return n[0] = r[0], n[3] = r[1], n[6] = r[2], n[1] = i[0], n[4] = i[1], n[7] = i[2], n[2] = -t[0], n[5] = -t[1], n[8] = -t[2], US(e, zS(e, n));
  };
})();
const LO = [0, 0, 0, 1];
class bp extends j1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, t, r, i);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, t, r, i) {
    return this[0] = e, this[1] = t, this[2] = r, this[3] = i, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  fromMatrix3(e) {
    return zS(this, e), this.check();
  }
  fromAxisRotation(e, t) {
    return NS(this, e, t), this.check();
  }
  identity() {
    return mO(this), this.check();
  }
  setAxisAngle(e, t) {
    return this.fromAxisRotation(e, t);
  }
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Ar(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Ar(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ar(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Ar(e);
  }
  len() {
    return CO(this);
  }
  lengthSquared() {
    return IO(this);
  }
  dot(e) {
    return EO(this, e);
  }
  rotationTo(e, t) {
    return PO(this, e, t), this.check();
  }
  add(e) {
    return AO(this, this, e), this.check();
  }
  calculateW() {
    return vO(this, this), this.check();
  }
  conjugate() {
    return wO(this, this), this.check();
  }
  invert() {
    return xO(this, this), this.check();
  }
  lerp(e, t, r) {
    return r === void 0 ? this.lerp(this, e, t) : (TO(this, e, t, r), this.check());
  }
  multiplyRight(e) {
    return Dx(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return Dx(this, e, this), this.check();
  }
  normalize() {
    const e = this.len(), t = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * t, this[1] = this[1] * t, this[2] = this[2] * t, this[3] = this[3] * t, e === 0 && (this[3] = 1), this.check();
  }
  rotateX(e) {
    return _O(this, this, e), this.check();
  }
  rotateY(e) {
    return yO(this, this, e), this.check();
  }
  rotateZ(e) {
    return bO(this, this, e), this.check();
  }
  scale(e) {
    return SO(this, this, e), this.check();
  }
  slerp(e, t, r) {
    let i, o, c;
    switch (arguments.length) {
      case 1:
        ({
          start: i = LO,
          target: o,
          ratio: c
        } = e);
        break;
      case 2:
        i = this, o = e, c = t;
        break;
      default:
        i = e, o = t, c = r;
    }
    return $g(this, i, o, c), this.check();
  }
  transformVector4(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new W1();
    return cO(t, e, this), cp(t, 4);
  }
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, t) {
    return this.setAxisAngle(e, t);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const vp = {
  EPSILON1: 0.1,
  EPSILON2: 0.01,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
}, Fx = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))

struct AmbientLight {
 vec3 color;
};

struct PointLight {
 vec3 color;
 vec3 position;
 vec3 attenuation;
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;

uniform bool lighting_uEnabled;

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

#endif
`, MO = {
  lightSources: {}
};
function f_() {
  let {
    color: n = [0, 0, 0],
    intensity: e = 1
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return n.map((t) => t * e / 255);
}
function BO(n) {
  let {
    ambientLight: e,
    pointLights: t = [],
    directionalLights: r = []
  } = n;
  const i = {};
  return e ? i["lighting_uAmbientLight.color"] = f_(e) : i["lighting_uAmbientLight.color"] = [0, 0, 0], t.forEach((o, c) => {
    i["lighting_uPointLight[".concat(c, "].color")] = f_(o), i["lighting_uPointLight[".concat(c, "].position")] = o.position, i["lighting_uPointLight[".concat(c, "].attenuation")] = o.attenuation || [1, 0, 0];
  }), i.lighting_uPointLightCount = t.length, r.forEach((o, c) => {
    i["lighting_uDirectionalLight[".concat(c, "].color")] = f_(o), i["lighting_uDirectionalLight[".concat(c, "].direction")] = o.direction;
  }), i.lighting_uDirectionalLightCount = r.length, i;
}
function jS() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MO;
  if ("lightSources" in n) {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: r
    } = n.lightSources || {};
    return e || t && t.length > 0 || r && r.length > 0 ? Object.assign({}, BO({
      ambientLight: e,
      pointLights: t,
      directionalLights: r
    }), {
      lighting_uEnabled: !0
    }) : {
      lighting_uEnabled: !1
    };
  }
  if ("lights" in n) {
    const e = {
      pointLights: [],
      directionalLights: []
    };
    for (const t of n.lights || [])
      switch (t.type) {
        case "ambient":
          e.ambientLight = t;
          break;
        case "directional":
          e.directionalLights.push(t);
          break;
        case "point":
          e.pointLights.push(t);
          break;
      }
    return jS({
      lightSources: e
    });
  }
  return {};
}
const $1 = {
  name: "lights",
  vs: Fx,
  fs: Fx,
  getUniforms: jS,
  defines: {
    MAX_LIGHTS: 3
  }
}, RO = new Uint8Array([0, 255, 255, 255]), OO = {
  pickingSelectedColor: null,
  pickingHighlightColor: RO,
  pickingActive: !1,
  pickingAttribute: !1
};
function DO() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OO;
  const e = {};
  if (n.pickingSelectedColor !== void 0)
    if (!n.pickingSelectedColor)
      e.picking_uSelectedColorValid = 0;
    else {
      const t = n.pickingSelectedColor.slice(0, 3);
      e.picking_uSelectedColorValid = 1, e.picking_uSelectedColor = t;
    }
  if (n.pickingHighlightColor) {
    const t = Array.from(n.pickingHighlightColor, (r) => r / 255);
    Number.isFinite(t[3]) || (t[3] = 1), e.picking_uHighlightColor = t;
  }
  return n.pickingActive !== void 0 && (e.picking_uActive = !!n.pickingActive, e.picking_uAttribute = !!n.pickingAttribute), e;
}
const FO = `uniform bool picking_uActive;
uniform bool picking_uAttribute;
uniform vec3 picking_uSelectedColor;
uniform bool picking_uSelectedColorValid;

out vec4 picking_vRGBcolor_Avalid;

const float COLOR_SCALE = 1. / 255.;

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.001;
}

bool isVertexPicked(vec3 vertexColor) {
  return
    picking_uSelectedColorValid &&
    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));
}

void picking_setPickingColor(vec3 pickingColor) {
  if (picking_uActive) {
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!picking_uAttribute) {
      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;
    }
  } else {
    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.r = value;
  }
}
void picking_setPickingAttribute(vec2 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}
void picking_setPickingAttribute(vec3 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`, kO = `uniform bool picking_uActive;
uniform vec3 picking_uSelectedColor;
uniform vec4 picking_uHighlightColor;

in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
  if (picking_uActive) {
    return color;
  }
  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    float highLightAlpha = picking_uHighlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}
vec4 picking_filterPickingColor(vec4 color) {
  if (picking_uActive) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}
vec4 picking_filterColor(vec4 color) {
  vec4 highightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highightColor);
}

`, NO = {
  name: "picking",
  vs: FO,
  fs: kO,
  getUniforms: DO
}, GS = `
uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
    vec3 halfway_direction = normalize(light_direction + view_direction);
    float lambertian = dot(light_direction, normal_worldspace);
    float specular = 0.0;
    if (lambertian > 0.0) {
      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
      specular = pow(specular_angle, lighting_uShininess);
    }
    lambertian = max(lambertian, 0.0);
    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);
    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}

vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = vec3(0, 0, 0);
  vec3 surfaceColor = vec3(0, 0, 0);

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}
`, zO = {};
function UO(n) {
  const {
    ambient: e = 0.35,
    diffuse: t = 0.6,
    shininess: r = 32,
    specularColor: i = [30, 30, 30]
  } = n;
  return {
    lighting_uAmbient: e,
    lighting_uDiffuse: t,
    lighting_uShininess: r,
    lighting_uSpecularColor: i.map((o) => o / 255)
  };
}
function VS() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : zO;
  if (!("material" in n))
    return {};
  const {
    material: e
  } = n;
  return e ? UO(e) : {
    lighting_uEnabled: !1
  };
}
const jO = {
  name: "gouraud-lighting",
  dependencies: [$1],
  vs: GS,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: VS
}, GO = {
  name: "phong-lighting",
  dependencies: [$1],
  fs: GS,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: VS
}, VO = `uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;

varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
# else
varying vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = u_ModelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`, qO = `#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)
# error PBR fragment shader: Texture LOD is not available
#endif

#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)
# error PBR fragment shader: Derivatives are not available
#endif


#if (__VERSION__ < 300)
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)
#else
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)
#endif

precision highp float;

uniform bool pbr_uUnlit;

#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif

#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif

#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif

uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;

uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif

varying vec3 pbr_vPosition;

varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
#else
varying vec3 pbr_vNormal;
#endif
#endif


struct PBRInfo
{
  float NdotL;
  float NdotV;
  float NdotH;
  float LdotH;
  float VdotH;
  float perceptualRoughness;
  float metalness;
  vec3 reflectance0;
  vec3 reflectance90;
  float alphaRoughness;
  vec3 diffuseColor;
  vec3 specularColor;
  vec3 n;
  vec3 v;
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
  return vec4(linOut,srgbIn.w);;
#else
  return srgbIn;
#endif
}

vec3 getNormal()
{
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}


#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
  float mipCount = 9.0;
  float lod = (pbrInputs.perceptualRoughness * mipCount);
  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,
    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
  diffuse *= u_ScaleIBLAmbient.x;
  specular *= u_ScaleIBLAmbient.y;

  return diffuse + specular;
}
#endif


vec3 diffuse(PBRInfo pbrInputs)
{
  return pbrInputs.diffuseColor / M_PI;
}

vec3 specularReflection(PBRInfo pbrInputs)
{
  return pbrInputs.reflectance0 +
    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *
    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}



float geometricOcclusion(PBRInfo pbrInputs)
{
  float NdotL = pbrInputs.NdotL;
  float NdotV = pbrInputs.NdotV;
  float r = pbrInputs.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}





float microfacetDistribution(PBRInfo pbrInputs)
{
  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
  pbrInputs.NdotL = 1.0;
  pbrInputs.NdotH = 0.0;
  pbrInputs.LdotH = 0.0;
  pbrInputs.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
  vec3 n = pbrInputs.n;
  vec3 v = pbrInputs.v;
  vec3 l = normalize(lightDirection);
  vec3 h = normalize(l+v);

  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
  vec3 F = specularReflection(pbrInputs);
  float G = geometricOcclusion(pbrInputs);
  float D = microfacetDistribution(pbrInputs);
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
  vec4 baseColor = u_BaseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < u_AlphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbr_uUnlit){
    color.rgb = baseColor.rgb;
  }
  else{


    float perceptualRoughness = u_MetallicRoughnessValues.y;
    float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP

    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);



    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(u_Camera - pbr_vPosition);

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInputs = PBRInfo(
      0.0,
      NdotV,
      0.0,
      0.0,
      0.0,
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );

#ifdef USE_LIGHTS
    PBRInfo_setAmbientLight(pbrInputs);
    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {
      if (i < lighting_uDirectionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
      }
    }
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {
      if (i < lighting_uPointLightCount) {
        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
      }
    }
#endif
#ifdef USE_IBL
    color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;
    color = mix(color, color * ao, u_OcclusionStrength);
#endif

#ifdef HAS_EMISSIVEMAP
    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
    color += emissive;
#endif

#ifdef PBR_DEBUG





    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`, Z1 = {
  name: "pbr",
  vs: VO,
  fs: qO,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [$1]
}, HO = `attribute float transform_elementID;
vec2 transform_getPixelSizeHalf(vec2 size) {
  return vec2(1.) / (2. * size);
}

vec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {
  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);
  float xIndex = transform_elementID - (yIndex * texSize[0]);
  return vec2(xIndex, yIndex);
}
vec2 transform_getTexCoord(vec2 size) {
  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);
  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);
  vec2 coord = indices / size + pixelSizeHalf;
  return coord;
}
vec2 transform_getPos(vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);
  return pos;
}
vec4 transform_getInput(sampler2D texSampler, vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec4 textureColor = texture2D(texSampler, texCoord);
  return textureColor;
}
`, WO = {
  name: "transform",
  vs: HO,
  fs: null
};
class zp {
  static getDefaultProgramManager(e) {
    return e.luma = e.luma || {}, e.luma.defaultProgramManager = e.luma.defaultProgramManager || new zp(e), e.luma.defaultProgramManager;
  }
  constructor(e) {
    this.gl = e, this._programCache = {}, this._getUniforms = {}, this._registeredModules = {}, this._hookFunctions = [], this._defaultModules = [], this._hashes = {}, this._hashCounter = 0, this.stateHash = 0, this._useCounts = {};
  }
  addDefaultModule(e) {
    this._defaultModules.find((t) => t.name === e.name) || this._defaultModules.push(e), this.stateHash++;
  }
  removeDefaultModule(e) {
    const t = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((r) => r.name !== t), this.stateHash++;
  }
  addShaderHook(e, t) {
    t && (e = Object.assign(t, {
      hook: e
    })), this._hookFunctions.push(e), this.stateHash++;
  }
  get() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      vs: t = "",
      fs: r = "",
      defines: i = {},
      inject: o = {},
      varyings: c = [],
      bufferMode: l = 35981,
      transpileToGLSL100: _ = !1
    } = e, b = this._getModuleList(e.modules), w = this._getHash(t), T = this._getHash(r), I = b.map((ie) => this._getHash(ie.name)).sort(), P = c.map((ie) => this._getHash(ie)), k = Object.keys(i).sort(), U = Object.keys(o).sort(), G = [], H = [];
    for (const ie of k)
      G.push(this._getHash(ie)), G.push(this._getHash(i[ie]));
    for (const ie of U)
      H.push(this._getHash(ie)), H.push(this._getHash(o[ie]));
    const $ = "".concat(w, "/").concat(T, "D").concat(G.join("/"), "M").concat(I.join("/"), "I").concat(H.join("/"), "V").concat(P.join("/"), "H").concat(this.stateHash, "B").concat(l).concat(_ ? "T" : "");
    if (!this._programCache[$]) {
      const ie = $R(this.gl, {
        vs: t,
        fs: r,
        modules: b,
        inject: o,
        defines: i,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100: _
      });
      this._programCache[$] = new pS(this.gl, {
        hash: $,
        vs: ie.vs,
        fs: ie.fs,
        varyings: c,
        bufferMode: l
      }), this._getUniforms[$] = ie.getUniforms || ((ge) => {
      }), this._useCounts[$] = 0;
    }
    return this._useCounts[$]++, this._programCache[$];
  }
  getUniforms(e) {
    return this._getUniforms[e.hash] || null;
  }
  release(e) {
    const t = e.hash;
    this._useCounts[t]--, this._useCounts[t] === 0 && (this._programCache[t].delete(), delete this._programCache[t], delete this._getUniforms[t], delete this._useCounts[t]);
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
  _getModuleList() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = new Array(this._defaultModules.length + e.length), r = {};
    let i = 0;
    for (let o = 0, c = this._defaultModules.length; o < c; ++o) {
      const l = this._defaultModules[o], _ = l.name;
      t[i++] = l, r[_] = !0;
    }
    for (let o = 0, c = e.length; o < c; ++o) {
      const l = e[o], _ = l.name;
      r[_] || (t[i++] = l, r[_] = !0);
    }
    return t.length = i, t;
  }
}
const XO = {
  POSITION: "positions",
  NORMAL: "normals",
  COLOR_0: "colors",
  TEXCOORD_0: "texCoords",
  TEXCOORD_1: "texCoords1",
  TEXCOORD_2: "texCoords2"
};
function $O(n, e, t) {
  const r = {};
  let i = e.indices;
  for (const o in e.attributes) {
    const c = e.attributes[o], l = ZO(o);
    if (o === "indices")
      i = c;
    else if (c.constant)
      r[l] = c.value;
    else {
      const _ = c.value, b = {
        ...c
      };
      delete b.value, r[l] = [new qr(n, _), b], JO(o, b);
    }
  }
  if (i) {
    const o = i.value || i;
    Zt(o instanceof Uint16Array || o instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const c = {
      size: 1,
      isIndexed: i.isIndexed === void 0 ? !0 : i.isIndexed
    };
    r.indices = [new qr(n, {
      data: o,
      target: 34963
    }), c];
  }
  return r;
}
function ZO(n, e) {
  const {
    attributeMap: t = XO
  } = {};
  return t && t[n] || n;
}
function JO(n, e) {
  let t;
  switch (n) {
    case "texCoords":
    case "texCoord1":
    case "texCoord2":
    case "texCoord3":
      t = "uvs";
      break;
    case "vertices":
    case "positions":
    case "normals":
    case "pickingColors":
      t = "vectors";
      break;
  }
  switch (t) {
    case "vectors":
      e.size = e.size || 3;
      break;
    case "uvs":
      e.size = e.size || 2;
      break;
  }
  Zt(Number.isFinite(e.size), "attribute ".concat(n, " needs size"));
}
const _d = 2, YO = 1e4, KO = "Model needs drawMode and vertexCount", kx = () => {
}, QO = {};
class Jd {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      id: r = ou("model")
    } = t;
    Zt(Nm(e)), this.id = r, this.gl = e, this.id = t.id || ou("Model"), this.lastLogTime = 0, this.animated = !1, this.initialize(t);
  }
  initialize(e) {
    this.props = {}, this.programManager = e.programManager || zp.getDefaultProgramManager(this.gl), this._programManagerState = -1, this._managedProgram = !1;
    const {
      program: t = null,
      vs: r,
      fs: i,
      modules: o,
      defines: c,
      inject: l,
      varyings: _,
      bufferMode: b,
      transpileToGLSL100: w
    } = e;
    this.programProps = {
      program: t,
      vs: r,
      fs: i,
      modules: o,
      defines: c,
      inject: l,
      varyings: _,
      bufferMode: b,
      transpileToGLSL100: w
    }, this.program = null, this.vertexArray = null, this._programDirty = !0, this.userData = {}, this.needsRedraw = !0, this._attributes = {}, this.attributes = {}, this.uniforms = {}, this.pickable = !0, this._checkProgram(), this.setUniforms(Object.assign({}, this.getModuleUniforms(e.moduleSettings))), this.drawMode = e.drawMode !== void 0 ? e.drawMode : 4, this.vertexCount = e.vertexCount || 0, this.geometryBuffers = {}, this.isInstanced = e.isInstanced || e.instanced || e.instanceCount > 0, this._setModelProps(e), this.geometry = {}, Zt(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), KO);
  }
  setProps(e) {
    this._setModelProps(e);
  }
  delete() {
    for (const e in this._attributes)
      this._attributes[e] !== this.attributes[e] && this._attributes[e].delete();
    this._managedProgram && (this.programManager.release(this.program), this._managedProgram = !1), this.vertexArray.delete(), this._deleteGeometryBuffers();
  }
  getDrawMode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getProgram() {
    return this.program;
  }
  setProgram(e) {
    const {
      program: t,
      vs: r,
      fs: i,
      modules: o,
      defines: c,
      inject: l,
      varyings: _,
      bufferMode: b,
      transpileToGLSL100: w
    } = e;
    this.programProps = {
      program: t,
      vs: r,
      fs: i,
      modules: o,
      defines: c,
      inject: l,
      varyings: _,
      bufferMode: b,
      transpileToGLSL100: w
    }, this._programDirty = !0;
  }
  getUniforms() {
    return this.uniforms;
  }
  setDrawMode(e) {
    return this.drawMode = e, this;
  }
  setVertexCount(e) {
    return Zt(Number.isFinite(e)), this.vertexCount = e, this;
  }
  setInstanceCount(e) {
    return Zt(Number.isFinite(e)), this.instanceCount = e, this;
  }
  setGeometry(e) {
    return this.drawMode = e.drawMode, this.vertexCount = e.getVertexCount(), this._deleteGeometryBuffers(), this.geometryBuffers = $O(this.gl, e), this.vertexArray.setAttributes(this.geometryBuffers), this;
  }
  setAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (Xd(e))
      return this;
    const t = {};
    for (const r in e) {
      const i = e[r];
      t[r] = i.getValue ? i.getValue() : i;
    }
    return this.vertexArray.setAttributes(t), this;
  }
  setUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.assign(this.uniforms, e), this;
  }
  getModuleUniforms(e) {
    this._checkProgram();
    const t = this.programManager.getUniforms(this.program);
    return t ? t(e) : {};
  }
  updateModuleSettings(e) {
    const t = this.getModuleUniforms(e || {});
    return this.setUniforms(t);
  }
  clear(e) {
    return D1(this.program.gl, e), this;
  }
  draw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._checkProgram();
    const {
      moduleSettings: t = null,
      framebuffer: r,
      uniforms: i = {},
      attributes: o = {},
      transformFeedback: c = this.transformFeedback,
      parameters: l = {},
      vertexArray: _ = this.vertexArray
    } = e;
    this.setAttributes(o), this.updateModuleSettings(t), this.setUniforms(i);
    let b;
    ln.priority >= _d && (b = this._logDrawCallStart(_d));
    const w = this.vertexArray.getDrawParams(), {
      isIndexed: T = w.isIndexed,
      indexType: I = w.indexType,
      indexOffset: P = w.indexOffset,
      vertexArrayInstanced: k = w.isInstanced
    } = this.props;
    k && !this.isInstanced && ln.warn("Found instanced attributes on non-instanced model", this.id)();
    const {
      isInstanced: U,
      instanceCount: G
    } = this, {
      onBeforeRender: H = kx,
      onAfterRender: $ = kx
    } = this.props;
    H(), this.program.setUniforms(this.uniforms);
    const ie = this.program.draw(Object.assign(QO, e, {
      logPriority: b,
      uniforms: null,
      framebuffer: r,
      parameters: l,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray: _,
      transformFeedback: c,
      isIndexed: T,
      indexType: I,
      isInstanced: U,
      instanceCount: G,
      offset: T ? P : 0
    }));
    return $(), ln.priority >= _d && this._logDrawCallEnd(b, _, r), ie;
  }
  transform() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      discard: t = !0,
      feedbackBuffers: r,
      unbindModels: i = []
    } = e;
    let {
      parameters: o
    } = e;
    r && this._setFeedbackBuffers(r), t && (o = Object.assign({}, o, {
      35977: t
    })), i.forEach((c) => c.vertexArray.unbindBuffers());
    try {
      this.draw(Object.assign({}, e, {
        parameters: o
      }));
    } finally {
      i.forEach((c) => c.vertexArray.bindBuffers());
    }
    return this;
  }
  render() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ln.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(), this.setUniforms(e).draw();
  }
  _setModelProps(e) {
    Object.assign(this.props, e), "uniforms" in e && this.setUniforms(e.uniforms), "pickable" in e && (this.pickable = e.pickable), "instanceCount" in e && (this.instanceCount = e.instanceCount), "geometry" in e && this.setGeometry(e.geometry), "attributes" in e && this.setAttributes(e.attributes), "_feedbackBuffers" in e && this._setFeedbackBuffers(e._feedbackBuffers);
  }
  _checkProgram() {
    if (!(this._programDirty || this.programManager.stateHash !== this._programManagerState))
      return;
    let {
      program: t
    } = this.programProps;
    if (t)
      this._managedProgram = !1;
    else {
      const {
        vs: r,
        fs: i,
        modules: o,
        inject: c,
        defines: l,
        varyings: _,
        bufferMode: b,
        transpileToGLSL100: w
      } = this.programProps;
      t = this.programManager.get({
        vs: r,
        fs: i,
        modules: o,
        inject: c,
        defines: l,
        varyings: _,
        bufferMode: b,
        transpileToGLSL100: w
      }), this.program && this._managedProgram && this.programManager.release(this.program), this._programManagerState = this.programManager.stateHash, this._managedProgram = !0;
    }
    Zt(t instanceof pS, "Model needs a program"), this._programDirty = !1, t !== this.program && (this.program = t, this.vertexArray ? this.vertexArray.setProps({
      program: this.program,
      attributes: this.vertexArray.attributes
    }) : this.vertexArray = new cR(this.gl, {
      program: this.program
    }), this.setUniforms(Object.assign({}, this.getModuleUniforms())));
  }
  _deleteGeometryBuffers() {
    for (const e in this.geometryBuffers) {
      const t = this.geometryBuffers[e][0] || this.geometryBuffers[e];
      t instanceof qr && t.delete();
    }
  }
  _setAnimationProps(e) {
    this.animated && Zt(e, "Model.draw(): animated uniforms but no animationProps");
  }
  _setFeedbackBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (Xd(e))
      return this;
    const {
      gl: t
    } = this.program;
    return this.transformFeedback = this.transformFeedback || new gS(t, {
      program: this.program
    }), this.transformFeedback.setBuffers(e), this;
  }
  _logDrawCallStart(e) {
    const t = e > 3 ? 0 : YO;
    if (!(Date.now() - this.lastLogTime < t))
      return this.lastLogTime = Date.now(), ln.group(_d, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: ln.level <= 2
      })(), e;
  }
  _logDrawCallEnd(e, t, r, i) {
    if (e === void 0)
      return;
    const o = dR({
      vertexArray: t,
      header: "".concat(this.id, " attributes"),
      attributes: this._attributes
    }), {
      table: c,
      unusedTable: l,
      unusedCount: _
    } = yx({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, r)
    }), {
      table: b,
      count: w
    } = yx({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, r),
      undefinedOnly: !0
    });
    w > 0 && ln.log("MISSING UNIFORMS", Object.keys(b))(), _ > 0 && ln.log("UNUSED UNIFORMS", Object.keys(l))();
    const T = pR(this.vertexArray.configuration);
    ln.table(e, o)(), ln.table(e, c)(), ln.table(e + 1, T)(), i && i.log({
      logLevel: _d,
      message: "Rendered to ".concat(i.id)
    }), ln.groupEnd(_d)();
  }
}
class eD {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.currentIndex = 0, this.feedbackMap = {}, this.varyings = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
  }
  setupResources(e) {
    for (const t of this.bindings)
      this._setupTransformFeedback(t, e);
  }
  updateModelProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyings: t
    } = this;
    return t.length > 0 && (e = Object.assign({}, e, {
      varyings: t
    })), e;
  }
  getDrawOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.bindings[this.currentIndex], {
      sourceBuffers: r,
      transformFeedback: i
    } = t;
    return {
      attributes: Object.assign({}, r, e.attributes),
      transformFeedback: i
    };
  }
  swap() {
    return this.feedbackMap ? (this.currentIndex = this._getNextIndex(), !0) : !1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(e);
  }
  getBuffer(e) {
    const {
      feedbackBuffers: t
    } = this.bindings[this.currentIndex], r = e ? t[e] : null;
    return r ? r instanceof qr ? r : r.buffer : null;
  }
  getData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyingName: t
    } = e, r = this.getBuffer(t);
    return r ? r.getData() : null;
  }
  delete() {
    for (const e in this.resources)
      this.resources[e].delete();
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(e), this.varyings = e.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers), this.varyings.length > 0 && Zt(tr(this.gl));
  }
  _getFeedbackBuffers(e) {
    const {
      sourceBuffers: t = {}
    } = e, r = {};
    if (this.bindings[this.currentIndex] && Object.assign(r, this.bindings[this.currentIndex].feedbackBuffers), this.feedbackMap)
      for (const i in this.feedbackMap) {
        const o = this.feedbackMap[i];
        i in t && (r[o] = i);
      }
    Object.assign(r, e.feedbackBuffers);
    for (const i in r) {
      const o = r[i];
      if (typeof o == "string") {
        const c = t[o], {
          byteLength: l,
          usage: _,
          accessor: b
        } = c;
        r[i] = this._createNewBuffer(i, {
          byteLength: l,
          usage: _,
          accessor: b
        });
      }
    }
    return r;
  }
  _setupBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t = null
    } = e;
    Object.assign(this.feedbackMap, e.feedbackMap);
    const r = this._getFeedbackBuffers(e);
    this._updateBindings({
      sourceBuffers: t,
      feedbackBuffers: r
    });
  }
  _setupTransformFeedback(e, t) {
    let {
      model: r
    } = t;
    const {
      program: i
    } = r;
    e.transformFeedback = new gS(this.gl, {
      program: i,
      buffers: e.feedbackBuffers
    });
  }
  _updateBindings(e) {
    if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this.feedbackMap) {
      const {
        sourceBuffers: t,
        feedbackBuffers: r
      } = this._swapBuffers(this.bindings[this.currentIndex]), i = this._getNextIndex();
      this.bindings[i] = this._updateBinding(this.bindings[i], {
        sourceBuffers: t,
        feedbackBuffers: r
      });
    }
  }
  _updateBinding(e, t) {
    return e ? (Object.assign(e.sourceBuffers, t.sourceBuffers), Object.assign(e.feedbackBuffers, t.feedbackBuffers), e.transformFeedback && e.transformFeedback.setBuffers(e.feedbackBuffers), e) : {
      sourceBuffers: Object.assign({}, t.sourceBuffers),
      feedbackBuffers: Object.assign({}, t.feedbackBuffers)
    };
  }
  _swapBuffers(e) {
    if (!this.feedbackMap)
      return null;
    const t = Object.assign({}, e.sourceBuffers), r = Object.assign({}, e.feedbackBuffers);
    for (const i in this.feedbackMap) {
      const o = this.feedbackMap[i];
      t[i] = e.feedbackBuffers[o], r[o] = e.sourceBuffers[i], Zt(r[o] instanceof qr);
    }
    return {
      sourceBuffers: t,
      feedbackBuffers: r
    };
  }
  _createNewBuffer(e, t) {
    const r = new qr(this.gl, t);
    return this.resources[e] && this.resources[e].delete(), this.resources[e] = r, r;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
}
const tD = "transform_uSampler_", xm = "transform_uSize_", Nx = "transform_position";
function nD(n) {
  let {
    vs: e,
    sourceTextureMap: t,
    targetTextureVarying: r,
    targetTexture: i
  } = n, c = Object.keys(t).length, l = null;
  const _ = {};
  let b = e, w = {};
  if (c > 0 || r) {
    const T = b.split(`
`), I = T.slice();
    if (T.forEach((P, k, U) => {
      if (c > 0) {
        const G = aD(P, t);
        if (G) {
          const {
            updatedLine: H,
            inject: $
          } = G;
          I[k] = H, w = by([w, $]), Object.assign(_, G.samplerTextureMap), c--;
        }
      }
      r && !l && (l = oD(P, r));
    }), r) {
      Zt(i);
      const P = "".concat(xm).concat(r), k = "uniform vec2 ".concat(P, `;
`), U = "     vec2 ".concat(Nx, " = transform_getPos(").concat(P, `);
     gl_Position = vec4(`).concat(Nx, `, 0, 1.);
`);
      w = by([w, {
        "vs:#decl": k,
        "vs:#main-start": U
      }]);
    }
    b = I.join(`
`);
  }
  return {
    vs: b,
    targetTextureType: l,
    inject: w,
    samplerTextureMap: _
  };
}
function rD(n) {
  let {
    sourceTextureMap: e,
    targetTextureVarying: t,
    targetTexture: r
  } = n;
  const i = {};
  let o, c;
  t && ({
    width: o,
    height: c
  } = r, i["".concat(xm).concat(t)] = [o, c]);
  for (const l in e)
    ({
      width: o,
      height: c
    } = e[l]), i["".concat(xm).concat(l)] = [o, c];
  return i;
}
function iD(n) {
  return wS(n, ["attribute", "in"]);
}
function sD(n) {
  const e = "".concat(tD).concat(n), t = "".concat(xm).concat(n), r = "  uniform sampler2D ".concat(e, `;
  uniform vec2 `).concat(t, ";");
  return {
    samplerName: e,
    sizeName: t,
    uniformDeclerations: r
  };
}
function oD(n, e) {
  const t = wS(n, ["varying", "out"]);
  return t && t.name === e ? t.type : null;
}
function aD(n, e) {
  const t = {}, r = iD(n);
  if (!r)
    return null;
  const {
    type: i,
    name: o
  } = r;
  if (o && e[o]) {
    const c = "// ".concat(n, " => Replaced by Transform with a sampler"), {
      samplerName: l,
      sizeName: _,
      uniformDeclerations: b
    } = sD(o), w = r6(i), T = "  ".concat(i, " ").concat(o, " = transform_getInput(").concat(l, ", ").concat(_, ").").concat(w, `;
`);
    return t[l] = o, {
      updatedLine: c,
      inject: {
        "vs:#decl": b,
        "vs:#main-start": T
      },
      samplerTextureMap: t
    };
  }
  return null;
}
const lD = {
  10241: 9728,
  10240: 9728,
  10242: 33071,
  10243: 33071
}, cD = "transform_output";
class uD {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.id = this.currentIndex = 0, this._swapTexture = null, this.targetTextureVarying = null, this.targetTextureType = null, this.samplerTextureMap = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
  }
  updateModelProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this._processVertexShader(e);
    return Object.assign({}, e, t);
  }
  getDrawOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t,
      sourceTextures: r,
      framebuffer: i,
      targetTexture: o
    } = this.bindings[this.currentIndex], c = Object.assign({}, t, e.attributes), l = Object.assign({}, e.uniforms), _ = Object.assign({}, e.parameters);
    let b = e.discard;
    if (this.hasSourceTextures || this.hasTargetTexture) {
      c.transform_elementID = this.elementIDBuffer;
      for (const T in this.samplerTextureMap) {
        const I = this.samplerTextureMap[T];
        l[T] = r[I];
      }
      this._setSourceTextureParameters();
      const w = rD({
        sourceTextureMap: r,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture: o
      });
      Object.assign(l, w);
    }
    return this.hasTargetTexture && (b = !1, _.viewport = [0, 0, i.width, i.height]), {
      attributes: c,
      framebuffer: i,
      uniforms: l,
      discard: b,
      parameters: _
    };
  }
  swap() {
    return this._swapTexture ? (this.currentIndex = this._getNextIndex(), !0) : !1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupTextures(e);
  }
  getTargetTexture() {
    const {
      targetTexture: e
    } = this.bindings[this.currentIndex];
    return e;
  }
  getData() {
    let {
      packed: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      framebuffer: t
    } = this.bindings[this.currentIndex], r = Um(t);
    if (!e)
      return r;
    const i = r.constructor, o = i6(this.targetTextureType), c = new i(r.length * o / 4);
    let l = 0;
    for (let _ = 0; _ < r.length; _ += 4)
      for (let b = 0; b < o; b++)
        c[l++] = r[_ + b];
    return c;
  }
  getFramebuffer() {
    return this.bindings[this.currentIndex].framebuffer;
  }
  delete() {
    this.ownTexture && this.ownTexture.delete(), this.elementIDBuffer && this.elementIDBuffer.delete();
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      _targetTextureVarying: t,
      _swapTexture: r
    } = e;
    this._swapTexture = r, this.targetTextureVarying = t, this.hasTargetTexture = t, this._setupTextures(e);
  }
  _createTargetTexture(e) {
    const {
      sourceTextures: t,
      textureOrReference: r
    } = e;
    if (r instanceof Aa)
      return r;
    const i = t[r];
    return i ? (this._targetRefTexName = r, this._createNewTexture(i)) : null;
  }
  _setupTextures() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t,
      _sourceTextures: r = {},
      _targetTexture: i
    } = e, o = this._createTargetTexture({
      sourceTextures: r,
      textureOrReference: i
    });
    this.hasSourceTextures = this.hasSourceTextures || r && Object.keys(r).length > 0, this._updateBindings({
      sourceBuffers: t,
      sourceTextures: r,
      targetTexture: o
    }), "elementCount" in e && this._updateElementIDBuffer(e.elementCount);
  }
  _updateElementIDBuffer(e) {
    if (typeof e != "number" || this.elementCount >= e)
      return;
    const t = new Float32Array(e);
    t.forEach((r, i, o) => {
      o[i] = i;
    }), this.elementIDBuffer ? this.elementIDBuffer.setData({
      data: t
    }) : this.elementIDBuffer = new qr(this.gl, {
      data: t,
      accessor: {
        size: 1
      }
    }), this.elementCount = e;
  }
  _updateBindings(e) {
    if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this._swapTexture) {
      const {
        sourceTextures: t,
        targetTexture: r
      } = this._swapTextures(this.bindings[this.currentIndex]), i = this._getNextIndex();
      this.bindings[i] = this._updateBinding(this.bindings[i], {
        sourceTextures: t,
        targetTexture: r
      });
    }
  }
  _updateBinding(e, t) {
    const {
      sourceBuffers: r,
      sourceTextures: i,
      targetTexture: o
    } = t;
    if (e || (e = {
      sourceBuffers: {},
      sourceTextures: {},
      targetTexture: null
    }), Object.assign(e.sourceTextures, i), Object.assign(e.sourceBuffers, r), o) {
      e.targetTexture = o;
      const {
        width: c,
        height: l
      } = o, {
        framebuffer: _
      } = e;
      _ ? (_.update({
        attachments: {
          36064: o
        },
        resizeAttachments: !1
      }), _.resize({
        width: c,
        height: l
      })) : e.framebuffer = new os(this.gl, {
        id: "transform-framebuffer",
        width: c,
        height: l,
        attachments: {
          36064: o
        }
      });
    }
    return e;
  }
  _setSourceTextureParameters() {
    const e = this.currentIndex, {
      sourceTextures: t
    } = this.bindings[e];
    for (const r in t)
      t[r].setParameters(lD);
  }
  _swapTextures(e) {
    if (!this._swapTexture)
      return null;
    const t = Object.assign({}, e.sourceTextures);
    t[this._swapTexture] = e.targetTexture;
    const r = e.sourceTextures[this._swapTexture];
    return {
      sourceTextures: t,
      targetTexture: r
    };
  }
  _createNewTexture(e) {
    const t = K4(e, {
      parameters: {
        10241: 9728,
        10240: 9728,
        10242: 33071,
        10243: 33071
      },
      pixelStore: {
        37440: !1
      }
    });
    return this.ownTexture && this.ownTexture.delete(), this.ownTexture = t, t;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
  _processVertexShader() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceTextures: t,
      targetTexture: r
    } = this.bindings[this.currentIndex], {
      vs: i,
      uniforms: o,
      targetTextureType: c,
      inject: l,
      samplerTextureMap: _
    } = nD({
      vs: e.vs,
      sourceTextureMap: t,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture: r
    }), b = by([e.inject || {}, l]);
    this.targetTextureType = c, this.samplerTextureMap = _;
    const w = e._fs || AS({
      version: dS(i),
      input: this.targetTextureVarying,
      inputType: c,
      output: cD
    }), T = this.hasSourceTextures || this.targetTextureVarying ? [WO].concat(e.modules || []) : e.modules;
    return {
      vs: i,
      fs: w,
      modules: T,
      uniforms: o,
      inject: b
    };
  }
}
class J1 {
  static isSupported(e) {
    return tr(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.model = null, this.elementCount = 0, this.bufferTransform = null, this.textureTransform = null, this.elementIDBuffer = null, this._initialize(t), Object.seal(this);
  }
  delete() {
    const {
      model: e,
      bufferTransform: t,
      textureTransform: r
    } = this;
    e && e.delete(), t && t.delete(), r && r.delete();
  }
  run() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      clearRenderTarget: t = !0
    } = e, r = this._updateDrawOptions(e);
    t && r.framebuffer && r.framebuffer.clear({
      color: !0
    }), this.model.transform(r);
  }
  swap() {
    let e = !1;
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const r of t)
      e = e || r.swap();
    Zt(e, "Nothing to swap");
  }
  getBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return this.bufferTransform && this.bufferTransform.getBuffer(e);
  }
  getData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const r of t) {
      const i = r.getData(e);
      if (i)
        return i;
    }
    return null;
  }
  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    "elementCount" in e && this.model.setVertexCount(e.elementCount);
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const r of t)
      r.update(e);
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      gl: t
    } = this;
    this._buildResourceTransforms(t, e), e = this._updateModelProps(e), this.model = new Jd(t, Object.assign({}, e, {
      fs: e.fs || AS({
        version: dS(e.vs)
      }),
      id: e.id || "transform-model",
      drawMode: e.drawMode || 0,
      vertexCount: e.elementCount
    })), this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }
  _updateModelProps(e) {
    let t = Object.assign({}, e);
    const r = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of r)
      t = i.updateModelProps(t);
    return t;
  }
  _buildResourceTransforms(e, t) {
    hD(t) && (this.bufferTransform = new eD(e, t)), dD(t) && (this.textureTransform = new uD(e, t)), Zt(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
  }
  _updateDrawOptions(e) {
    let t = Object.assign({}, e);
    const r = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of r)
      t = Object.assign(t, i.getDrawOptions(t));
    return t;
  }
}
function hD(n) {
  return !!(!Xd(n.feedbackBuffers) || !Xd(n.feedbackMap) || n.varyings && n.varyings.length > 0);
}
function dD(n) {
  return !!(!Xd(n._sourceTextures) || n._targetTexture || n._targetTextureVarying);
}
const zx = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};
class hp {
  static get DRAW_MODE() {
    return zx;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t = ou("geometry"),
      drawMode: r = zx.TRIANGLES,
      attributes: i = {},
      indices: o = null,
      vertexCount: c = null
    } = e;
    this.id = t, this.drawMode = r | 0, this.attributes = {}, this.userData = {}, this._setAttributes(i, o), this.vertexCount = c || this._calculateVertexCount(this.attributes, this.indices);
  }
  get mode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  _print(e) {
    return "Geometry ".concat(this.id, " attribute ").concat(e);
  }
  _setAttributes(e, t) {
    t && (this.indices = ArrayBuffer.isView(t) ? {
      value: t,
      size: 1
    } : t);
    for (const r in e) {
      let i = e[r];
      i = ArrayBuffer.isView(i) ? {
        value: i
      } : i, Zt(ArrayBuffer.isView(i.value), "".concat(this._print(r), ": must be typed array or object with value as typed array")), (r === "POSITION" || r === "positions") && !i.size && (i.size = 3), r === "indices" ? (Zt(!this.indices), this.indices = i) : this.attributes[r] = i;
    }
    return this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this;
  }
  _calculateVertexCount(e, t) {
    if (t)
      return t.value.length;
    let r = 1 / 0;
    for (const i in e) {
      const o = e[i], {
        value: c,
        size: l,
        constant: _
      } = o;
      !_ && c && l >= 1 && (r = Math.min(r, c.length / l));
    }
    return Zt(Number.isFinite(r)), r;
  }
}
let fD = 1, pD = 1;
class qS {
  constructor() {
    this.time = 0, this.channels = /* @__PURE__ */ new Map(), this.animations = /* @__PURE__ */ new Map(), this.playing = !1, this.lastEngineTime = -1;
  }
  addChannel(e) {
    const {
      delay: t = 0,
      duration: r = Number.POSITIVE_INFINITY,
      rate: i = 1,
      repeat: o = 1
    } = e, c = fD++, l = {
      time: 0,
      delay: t,
      duration: r,
      rate: i,
      repeat: o
    };
    return this._setChannelTime(l, this.time), this.channels.set(c, l), c;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [t, r] of this.animations)
      r.channel === e && this.detachAnimation(t);
  }
  isFinished(e) {
    const t = this.channels.get(e);
    return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const t = this.channels.get(e);
    return t === void 0 ? -1 : t.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const t = this.channels.values();
    for (const i of t)
      this._setChannelTime(i, this.time);
    const r = this.animations.values();
    for (const i of r) {
      const {
        animation: o,
        channel: c
      } = i;
      o.setTime(this.getTime(c));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, t) {
    const r = pD++;
    return this.animations.set(r, {
      animation: e,
      channel: t
    }), e.setTime(this.getTime(t)), r;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, t) {
    const r = t - e.delay, i = e.duration * e.repeat;
    r >= i ? e.time = e.duration * e.rate : (e.time = Math.max(0, r) % e.duration, e.time *= e.rate);
  }
}
const gD = [255, 255, 255], mD = 1;
let _D = 0;
class HS {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    V(this, "id", void 0), V(this, "color", void 0), V(this, "intensity", void 0), V(this, "type", "ambient");
    const {
      color: t = gD
    } = e, {
      intensity: r = mD
    } = e;
    this.id = e.id || "ambient-".concat(_D++), this.color = t, this.intensity = r;
  }
}
const yD = [255, 255, 255], bD = 1, vD = [0, 0, -1];
let xD = 0;
class Ux {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    V(this, "id", void 0), V(this, "color", void 0), V(this, "intensity", void 0), V(this, "type", "directional"), V(this, "direction", void 0), V(this, "shadow", void 0);
    const {
      color: t = yD
    } = e, {
      intensity: r = bD
    } = e, {
      direction: i = vD
    } = e, {
      _shadow: o = !1
    } = e;
    this.id = e.id || "directional-".concat(xD++), this.color = t, this.intensity = r, this.type = "directional", this.direction = new Ke(i).normalize().toArray(), this.shadow = o;
  }
  getProjectedLight(e) {
    return this;
  }
}
class wD {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      id: "pass"
    };
    V(this, "id", void 0), V(this, "gl", void 0), V(this, "props", void 0);
    const {
      id: r
    } = t;
    this.id = r, this.gl = e, this.props = {
      ...t
    };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  cleanup() {
  }
}
class Y1 extends wD {
  constructor() {
    super(...arguments), V(this, "_lastRenderIndex", -1);
  }
  render(e) {
    const t = this.gl;
    return su(t, {
      framebuffer: e.target
    }), this._drawLayers(e);
  }
  _drawLayers(e) {
    const {
      target: t,
      moduleParameters: r,
      viewports: i,
      views: o,
      onViewportActive: c,
      clearStack: l = !0,
      clearCanvas: _ = !0
    } = e;
    e.pass = e.pass || "unknown";
    const b = this.gl;
    _ && SD(b, t), l && (this._lastRenderIndex = -1);
    const w = [];
    for (const T of i) {
      const I = o && o[T.id];
      c == null || c(T);
      const P = this._getDrawLayerParams(T, e), k = T.subViewports || [T];
      for (const U of k) {
        const G = this._drawLayersInViewport(b, {
          target: t,
          moduleParameters: r,
          viewport: U,
          view: I,
          pass: e.pass,
          layers: e.layers
        }, P);
        w.push(G);
      }
    }
    return w;
  }
  _getDrawLayerParams(e, t) {
    let {
      layers: r,
      pass: i,
      isPicking: o = !1,
      layerFilter: c,
      cullRect: l,
      effects: _,
      moduleParameters: b
    } = t, w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const T = [], I = WS(this._lastRenderIndex + 1), P = {
      layer: r[0],
      viewport: e,
      isPicking: o,
      renderPass: i,
      cullRect: l
    }, k = {};
    for (let U = 0; U < r.length; U++) {
      const G = r[U], H = this._shouldDrawLayer(G, P, c, k), $ = {
        shouldDrawLayer: H
      };
      H && !w && ($.layerRenderIndex = I(G, H), $.moduleParameters = this._getModuleParameters(G, _, i, b), $.layerParameters = this.getLayerParameters(G, U, e)), T[U] = $;
    }
    return T;
  }
  _drawLayersInViewport(e, t, r) {
    let {
      layers: i,
      moduleParameters: o,
      pass: c,
      target: l,
      viewport: _,
      view: b
    } = t;
    const w = AD(e, {
      moduleParameters: o,
      target: l,
      viewport: _
    });
    if (b && b.props.clear) {
      const I = b.props.clear === !0 ? {
        color: !0,
        depth: !0
      } : b.props.clear;
      Al(e, {
        scissorTest: !0,
        scissor: w
      }, () => D1(e, I));
    }
    const T = {
      totalCount: i.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    su(e, {
      viewport: w
    });
    for (let I = 0; I < i.length; I++) {
      const P = i[I], {
        shouldDrawLayer: k,
        layerRenderIndex: U,
        moduleParameters: G,
        layerParameters: H
      } = r[I];
      if (k && P.props.pickable && T.pickableCount++, P.isComposite)
        T.compositeCount++;
      else if (k) {
        T.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, U), G.viewport = _;
        try {
          P._drawLayer({
            moduleParameters: G,
            uniforms: {
              layerIndex: U
            },
            parameters: H
          });
        } catch ($) {
          P.raiseError($, "drawing ".concat(P, " to ").concat(c));
        }
      }
    }
    return T;
  }
  shouldDrawLayer(e) {
    return !0;
  }
  getModuleParameters(e, t) {
    return null;
  }
  getLayerParameters(e, t, r) {
    return e.props.parameters;
  }
  _shouldDrawLayer(e, t, r, i) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    t.layer = e;
    let c = e.parent;
    for (; c; ) {
      if (!c.props.visible || !c.filterSubLayer(t))
        return !1;
      t.layer = c, c = c.parent;
    }
    if (r) {
      const l = t.layer.id;
      if (l in i || (i[l] = r(t)), !i[l])
        return !1;
    }
    return e.activateViewport(t.viewport), !0;
  }
  _getModuleParameters(e, t, r, i) {
    var o;
    const c = Object.assign(Object.create(((o = e.internalState) === null || o === void 0 ? void 0 : o.propsInTransition) || e.props), {
      autoWrapLongitude: e.wrapLongitude,
      viewport: e.context.viewport,
      mousePosition: e.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: Wd(this.gl)
    });
    if (t)
      for (const _ of t) {
        var l;
        Object.assign(c, (l = _.getModuleParameters) === null || l === void 0 ? void 0 : l.call(_, e));
      }
    return Object.assign(c, this.getModuleParameters(e, t), i);
  }
}
function WS() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {}, r = (i, o) => {
    const c = i.props._offset, l = i.id, _ = i.parent && i.parent.id;
    let b;
    if (_ && !(_ in e) && r(i.parent, !1), _ in t) {
      const w = t[_] = t[_] || WS(e[_], e);
      b = w(i, o), t[l] = w;
    } else Number.isFinite(c) ? (b = c + (e[_] || 0), t[l] = null) : b = n;
    return o && b >= n && (n = b + 1), e[l] = b, b;
  };
  return r;
}
function AD(n, e) {
  let {
    moduleParameters: t,
    target: r,
    viewport: i
  } = e;
  const o = r && r.id !== "default-framebuffer", c = t && t.devicePixelRatio || Wd(n), l = o ? r.height : n.drawingBufferHeight, _ = i;
  return [_.x * c, l - (_.y + _.height) * c, _.width * c, _.height * c];
}
function SD(n, e) {
  const t = e ? e.width : n.drawingBufferWidth, r = e ? e.height : n.drawingBufferHeight;
  su(n, {
    viewport: [0, 0, t, r]
  }), n.clear(16640);
}
class ED extends Y1 {
  constructor(e, t) {
    super(e, t), V(this, "shadowMap", void 0), V(this, "depthBuffer", void 0), V(this, "fbo", void 0), this.shadowMap = new Aa(e, {
      width: 1,
      height: 1,
      parameters: {
        10241: 9729,
        10240: 9729,
        10242: 33071,
        10243: 33071
      }
    }), this.depthBuffer = new Ld(e, {
      format: 33189,
      width: 1,
      height: 1
    }), this.fbo = new os(e, {
      id: "shadowmap",
      width: 1,
      height: 1,
      attachments: {
        36064: this.shadowMap,
        36096: this.depthBuffer
      }
    });
  }
  render(e) {
    const t = this.fbo;
    Al(this.gl, {
      depthRange: [0, 1],
      depthTest: !0,
      blend: !1,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const r = e.viewports[0], i = Wd(this.gl), o = r.width * i, c = r.height * i;
      (o !== t.width || c !== t.height) && t.resize({
        width: o,
        height: c
      }), super.render({
        ...e,
        target: t,
        pass: "shadow"
      });
    });
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: !0
    };
  }
  delete() {
    this.fbo && (this.fbo.delete(), this.fbo = null), this.shadowMap && (this.shadowMap.delete(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.delete(), this.depthBuffer = null);
  }
}
const XS = "#define SMOOTH_EDGE_RADIUS 0.5", TD = `
`.concat(XS, `

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`), CD = `
`.concat(XS, `

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`), ID = {
  name: "geometry",
  vs: TD,
  fs: CD
}, PD = Object.keys(cr).map((n) => "const int COORDINATE_SYSTEM_".concat(n, " = ").concat(cr[n], ";")).join(""), LD = Object.keys(_c).map((n) => "const int PROJECTION_MODE_".concat(n, " = ").concat(_c[n], ";")).join(""), MD = Object.keys(py).map((n) => "const int UNIT_".concat(n.toUpperCase(), " = ").concat(py[n], ";")).join(""), BD = "".concat(PD, `
`).concat(LD, `
`).concat(MD, `

uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;

const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
  float y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

float project_size() {
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
    project_uPseudoMeters == false) {
    
    if (geometry.position.w == 0.0) {
      return project_size_at_latitude(geometry.worldPosition.y);
    }
  
    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    float y2 = y * y;
    float y4 = y2 * y2;
    float y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

float project_size_at_latitude(float meters, float lat) {
  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
  return meters * project_uCommonUnitsPerMeter.z * project_size();
}

vec2 project_size(vec2 meters) {
  return meters * project_uCommonUnitsPerMeter.xy * project_size();
}

vec3 project_size(vec3 meters) {
  return meters * project_uCommonUnitsPerMeter * project_size();
}

vec4 project_size(vec4 meters) {
  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
  vec3 uz = normalize(up);
  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
  vec3 uy = cross(uz, ux);
  return mat3(ux, uy, uz);
}

bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    transform = project_get_orientation_matrix(commonPosition);
    return true;
  }
  return false;
}
vec3 project_normal(vec3 vector) {
  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
  mat3 rotation;
  if (project_needs_rotation(geometry.position.xyz, rotation)) {
    n = rotation * n;
  }
  return n;
}

vec4 project_offset_(vec4 offset) {
  float dy = offset.y;
  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
  float x = lnglat.x;
  if (project_uWrapLongitude) {
    x = mod(x + 180., 360.0) - 180.;
  }
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

vec3 project_globe_(vec3 lnglatz) {
  float lambda = radians(lnglatz.x);
  float phi = radians(lnglatz.y);
  float cosPhi = cos(phi);
  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;

  return vec3(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
  vec4 position_world = project_uModelMatrix * position;
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_mercator_(position_world.xy),
        project_size_at_latitude(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world.xyz += project_uCoordinateOrigin;
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
        return vec4(
          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
          project_size(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world.xyz -= project_uCoordinateOrigin;
  }
  return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_LOW);
}

vec3 project_position(vec3 position, vec3 position64Low) {
  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
  return projected_position.xyz;
}

vec3 project_position(vec3 position) {
  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

vec2 project_position(vec2 position) {
  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
  return offset * project_uFocalDistance;
}

float project_size_to_pixel(float meters) {
  return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
  if (unit == UNIT_METERS) return project_size_to_pixel(size);
  if (unit == UNIT_COMMON) return size * project_uScale;
  return size;
}
float project_pixel_size(float pixels) {
  return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
  return pixels / project_uScale;
}
`);
function RD(n, e) {
  if (n === e)
    return !0;
  if (Array.isArray(n)) {
    const t = n.length;
    if (!e || e.length !== t)
      return !1;
    for (let r = 0; r < t; r++)
      if (n[r] !== e[r])
        return !1;
    return !0;
  }
  return !1;
}
function Up(n) {
  let e = {}, t;
  return (r) => {
    for (const i in r)
      if (!RD(r[i], e[i])) {
        t = n(r), e = r;
        break;
      }
    return t;
  };
}
const jx = [0, 0, 0, 0], OD = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], $S = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], DD = [0, 0, 0], ZS = [0, 0, 0], FD = Up(zD);
function JS(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ZS;
  t.length < 3 && (t = [t[0], t[1], 0]);
  let r = t, i, o = !0;
  switch (e === cr.LNGLAT_OFFSETS || e === cr.METER_OFFSETS ? i = t : i = n.isGeospatial ? [Math.fround(n.longitude), Math.fround(n.latitude), 0] : null, n.projectionMode) {
    case _c.WEB_MERCATOR:
      (e === cr.LNGLAT || e === cr.CARTESIAN) && (i = [0, 0, 0], o = !1);
      break;
    case _c.WEB_MERCATOR_AUTO_OFFSET:
      e === cr.LNGLAT ? r = i : e === cr.CARTESIAN && (r = [Math.fround(n.center[0]), Math.fround(n.center[1]), 0], i = n.unprojectPosition(r), r[0] -= t[0], r[1] -= t[1], r[2] -= t[2]);
      break;
    case _c.IDENTITY:
      r = n.position.map(Math.fround), r[2] = r[2] || 0;
      break;
    case _c.GLOBE:
      o = !1, i = null;
      break;
    default:
      o = !1;
  }
  return {
    geospatialOrigin: i,
    shaderCoordinateOrigin: r,
    offsetMode: o
  };
}
function kD(n, e, t) {
  const {
    viewMatrixUncentered: r,
    projectionMatrix: i
  } = n;
  let {
    viewMatrix: o,
    viewProjectionMatrix: c
  } = n, l = jx, _ = jx, b = n.cameraPosition;
  const {
    geospatialOrigin: w,
    shaderCoordinateOrigin: T,
    offsetMode: I
  } = JS(n, e, t);
  return I && (_ = n.projectPosition(w || T), b = [b[0] - _[0], b[1] - _[1], b[2] - _[2]], _[3] = 1, l = Np([], _, c), o = r || o, c = Rh([], i, o), c = Rh([], c, OD)), {
    viewMatrix: o,
    viewProjectionMatrix: c,
    projectionCenter: l,
    originCommon: _,
    cameraPosCommon: b,
    shaderCoordinateOrigin: T,
    geospatialOrigin: w
  };
}
function ND(n) {
  let {
    viewport: e,
    devicePixelRatio: t = 1,
    modelMatrix: r = null,
    coordinateSystem: i = cr.DEFAULT,
    coordinateOrigin: o = ZS,
    autoWrapLongitude: c = !1
  } = n;
  i === cr.DEFAULT && (i = e.isGeospatial ? cr.LNGLAT : cr.CARTESIAN);
  const l = FD({
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: i,
    coordinateOrigin: o
  });
  return l.project_uWrapLongitude = c, l.project_uModelMatrix = r || $S, l;
}
function zD(n) {
  let {
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: r,
    coordinateOrigin: i
  } = n;
  const {
    projectionCenter: o,
    viewProjectionMatrix: c,
    originCommon: l,
    cameraPosCommon: _,
    shaderCoordinateOrigin: b,
    geospatialOrigin: w
  } = kD(e, r, i), T = e.getDistanceScales(), I = [e.width * t, e.height * t], P = Np([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, k = {
    project_uCoordinateSystem: r,
    project_uProjectionMode: e.projectionMode,
    project_uCoordinateOrigin: b,
    project_uCommonOrigin: l.slice(0, 3),
    project_uCenter: o,
    project_uPseudoMeters: !!e._pseudoMeters,
    project_uViewportSize: I,
    project_uDevicePixelRatio: t,
    project_uFocalDistance: P,
    project_uCommonUnitsPerMeter: T.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: T.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DD,
    project_uScale: e.scale,
    project_uWrapLongitude: !1,
    project_uViewProjectionMatrix: c,
    project_uModelMatrix: $S,
    project_uCameraPosition: _
  };
  if (w) {
    const U = e.getDistanceScales(w);
    switch (r) {
      case cr.METER_OFFSETS:
        k.project_uCommonUnitsPerWorldUnit = U.unitsPerMeter, k.project_uCommonUnitsPerWorldUnit2 = U.unitsPerMeter2;
        break;
      case cr.LNGLAT:
      case cr.LNGLAT_OFFSETS:
        e._pseudoMeters || (k.project_uCommonUnitsPerMeter = U.unitsPerMeter), k.project_uCommonUnitsPerWorldUnit = U.unitsPerDegree, k.project_uCommonUnitsPerWorldUnit2 = U.unitsPerDegree2;
        break;
      case cr.CARTESIAN:
        k.project_uCommonUnitsPerWorldUnit = [1, 1, U.unitsPerMeter[2]], k.project_uCommonUnitsPerWorldUnit2 = [0, 0, U.unitsPerMeter2[2]];
        break;
    }
  }
  return k;
}
const UD = {};
function jD() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : UD;
  return "viewport" in n ? ND(n) : {};
}
const K1 = {
  name: "project",
  dependencies: [a6, ID],
  vs: BD,
  getUniforms: jD
};
function GD() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Fd(n, e) {
  const t = Np([], e, n);
  return kS(t, t, 1 / t[3]), t;
}
function Gx(n, e) {
  const t = n % e;
  return t < 0 ? e + t : t;
}
function Ey(n, e, t) {
  return n < e ? e : n > t ? t : n;
}
function VD(n) {
  return Math.log(n) * Math.LOG2E;
}
const Q1 = Math.log2 || VD;
function au(n, e) {
  if (!n)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const xl = Math.PI, YS = xl / 4, Ja = xl / 180, Ty = 180 / xl, Yd = 512, wm = 4003e4, Tg = 85.051129, qD = 1.5;
function HD(n) {
  return Q1(n);
}
function xp(n) {
  const [e, t] = n;
  au(Number.isFinite(e)), au(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const r = e * Ja, i = t * Ja, o = Yd * (r + xl) / (2 * xl), c = Yd * (xl + Math.log(Math.tan(YS + i * 0.5))) / (2 * xl);
  return [o, c];
}
function Kd(n) {
  const [e, t] = n, r = e / Yd * (2 * xl) - xl, i = 2 * (Math.atan(Math.exp(t / Yd * (2 * xl) - xl)) - YS);
  return [r * Ty, i * Ty];
}
function WD(n) {
  const {
    latitude: e
  } = n;
  au(Number.isFinite(e));
  const t = Math.cos(e * Ja);
  return HD(wm * t) - 9;
}
function Zg(n) {
  const e = Math.cos(n * Ja);
  return Yd / wm / e;
}
function Cy(n) {
  const {
    latitude: e,
    longitude: t,
    highPrecision: r = !1
  } = n;
  au(Number.isFinite(e) && Number.isFinite(t));
  const i = Yd, o = Math.cos(e * Ja), c = i / 360, l = c / o, _ = i / wm / o, b = {
    unitsPerMeter: [_, _, _],
    metersPerUnit: [1 / _, 1 / _, 1 / _],
    unitsPerDegree: [c, l, _],
    degreesPerUnit: [1 / c, 1 / l, 1 / _]
  };
  if (r) {
    const w = Ja * Math.tan(e * Ja) / o, T = c * w / 2, I = i / wm * w, P = I / l * _;
    b.unitsPerDegree2 = [0, T, I], b.unitsPerMeter2 = [P, 0, P];
  }
  return b;
}
function KS(n, e) {
  const [t, r, i] = n, [o, c, l] = e, {
    unitsPerMeter: _,
    unitsPerMeter2: b
  } = Cy({
    longitude: t,
    latitude: r,
    highPrecision: !0
  }), w = xp(n);
  w[0] += o * (_[0] + b[0] * c), w[1] += c * (_[1] + b[1] * c);
  const T = Kd(w), I = (i || 0) + (l || 0);
  return Number.isFinite(i) || Number.isFinite(l) ? [T[0], T[1], I] : T;
}
function XD(n) {
  const {
    height: e,
    pitch: t,
    bearing: r,
    altitude: i,
    scale: o,
    center: c
  } = n, l = GD();
  vm(l, l, [0, 0, -i]), DS(l, l, -t * Ja), FS(l, l, r * Ja);
  const _ = o / e;
  return X1(l, l, [_, _, _]), c && vm(l, l, E6([], c)), l;
}
function $D(n) {
  const {
    width: e,
    height: t,
    altitude: r,
    pitch: i = 0,
    offset: o,
    center: c,
    scale: l,
    nearZMultiplier: _ = 1,
    farZMultiplier: b = 1
  } = n;
  let {
    fovy: w = Am(qD)
  } = n;
  r !== void 0 && (w = Am(r));
  const T = w * Ja, I = i * Ja, P = QS(w);
  let k = P;
  c && (k += c[2] * l / Math.cos(I) / t);
  const U = T * (0.5 + (o ? o[1] : 0) / t), G = Math.sin(U) * k / Math.sin(Ey(Math.PI / 2 - I - U, 0.01, Math.PI - 0.01)), H = Math.sin(I) * G + k, $ = k * 10, ie = Math.min(H * b, $);
  return {
    fov: T,
    aspect: e / t,
    focalDistance: P,
    near: _,
    far: ie
  };
}
function Am(n) {
  return 2 * Math.atan(0.5 / n) * Ty;
}
function QS(n) {
  return 0.5 / Math.tan(0.5 * n * Ja);
}
function eE(n, e) {
  const [t, r, i = 0] = n;
  return au(Number.isFinite(t) && Number.isFinite(r) && Number.isFinite(i)), Fd(e, [t, r, i, 1]);
}
function eb(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const [r, i, o] = n;
  if (au(Number.isFinite(r) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(o))
    return Fd(e, [r, i, o, 1]);
  const c = Fd(e, [r, i, 0, 1]), l = Fd(e, [r, i, 1, 1]), _ = c[2], b = l[2], w = _ === b ? 0 : ((t || 0) - _) / (b - _);
  return SS([], c, l, w);
}
function ZD(n) {
  const {
    width: e,
    height: t,
    bounds: r,
    minExtent: i = 0,
    maxZoom: o = 24,
    offset: c = [0, 0]
  } = n, [[l, _], [b, w]] = r, T = JD(n.padding), I = xp([l, Ey(w, -Tg, Tg)]), P = xp([b, Ey(_, -Tg, Tg)]), k = [Math.max(Math.abs(P[0] - I[0]), i), Math.max(Math.abs(P[1] - I[1]), i)], U = [e - T.left - T.right - Math.abs(c[0]) * 2, t - T.top - T.bottom - Math.abs(c[1]) * 2];
  au(U[0] > 0 && U[1] > 0);
  const G = U[0] / k[0], H = U[1] / k[1], $ = (T.right - T.left) / 2 / G, ie = (T.top - T.bottom) / 2 / H, ge = [(P[0] + I[0]) / 2 + $, (P[1] + I[1]) / 2 + ie], Se = Kd(ge), Re = Math.min(o, Q1(Math.abs(Math.min(G, H))));
  return au(Number.isFinite(Re)), {
    longitude: Se[0],
    latitude: Se[1],
    zoom: Re
  };
}
function JD() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return typeof n == "number" ? {
    top: n,
    bottom: n,
    left: n,
    right: n
  } : (au(Number.isFinite(n.top) && Number.isFinite(n.bottom) && Number.isFinite(n.left) && Number.isFinite(n.right)), n);
}
const Vx = Math.PI / 180;
function YD(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const {
    width: t,
    height: r,
    unproject: i
  } = n, o = {
    targetZ: e
  }, c = i([0, r], o), l = i([t, r], o);
  let _, b;
  const w = n.fovy ? 0.5 * n.fovy * Vx : Math.atan(0.5 / n.altitude), T = (90 - n.pitch) * Vx;
  return w > T - 0.01 ? (_ = qx(n, 0, e), b = qx(n, t, e)) : (_ = i([0, 0], o), b = i([t, 0], o)), [c, l, b, _];
}
function qx(n, e, t) {
  const {
    pixelUnprojectionMatrix: r
  } = n, i = Fd(r, [e, 0, 1, 1]), o = Fd(r, [e, n.height, 1, 1]), l = (t * n.distanceScales.unitsPerMeter[2] - i[2]) / (o[2] - i[2]), _ = SS([], i, o, l), b = Kd(_);
  return b.push(t), b;
}
const Hx = 512;
function KD(n) {
  const {
    width: e,
    height: t,
    pitch: r = 0
  } = n;
  let {
    longitude: i,
    latitude: o,
    zoom: c,
    bearing: l = 0
  } = n;
  (i < -180 || i > 180) && (i = Gx(i + 180, 360) - 180), (l < -180 || l > 180) && (l = Gx(l + 180, 360) - 180);
  const _ = Q1(t / Hx);
  if (c <= _)
    c = _, o = 0;
  else {
    const b = t / 2 / Math.pow(2, c), w = Kd([0, b])[1];
    if (o < w)
      o = w;
    else {
      const T = Kd([0, Hx - b])[1];
      o > T && (o = T);
    }
  }
  return {
    width: e,
    height: t,
    longitude: i,
    latitude: o,
    zoom: c,
    pitch: r,
    bearing: l
  };
}
const QD = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, eF = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture2D(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, tF = Up(oF), nF = Up(aF), rF = [0, 0, 0, 1], iF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function sF(n, e) {
  const [t, r, i] = n, o = eb([t, r, i], e);
  return Number.isFinite(i) ? o : [o[0], o[1], 0];
}
function oF(n) {
  let {
    viewport: e,
    center: t
  } = n;
  return new lr(e.viewProjectionMatrix).invert().transform(t);
}
function aF(n) {
  let {
    viewport: e,
    shadowMatrices: t
  } = n;
  const r = [], i = e.pixelUnprojectionMatrix, o = e.isGeospatial ? void 0 : 1, c = [[0, 0, o], [e.width, 0, o], [0, e.height, o], [e.width, e.height, o], [0, 0, -1], [e.width, 0, -1], [0, e.height, -1], [e.width, e.height, -1]].map((l) => sF(l, i));
  for (const l of t) {
    const _ = l.clone().translate(new Ke(e.center).negate()), b = c.map((T) => _.transform(T)), w = new lr().ortho({
      left: Math.min(...b.map((T) => T[0])),
      right: Math.max(...b.map((T) => T[0])),
      bottom: Math.min(...b.map((T) => T[1])),
      top: Math.max(...b.map((T) => T[1])),
      near: Math.min(...b.map((T) => -T[2])),
      far: Math.max(...b.map((T) => -T[2]))
    });
    r.push(w.multiplyRight(l));
  }
  return r;
}
function lF(n, e) {
  const {
    shadowEnabled: t = !0
  } = n;
  if (!t || !n.shadowMatrices || !n.shadowMatrices.length)
    return {
      shadow_uDrawShadowMap: !1,
      shadow_uUseShadowMap: !1
    };
  const r = {
    shadow_uDrawShadowMap: !!n.drawToShadowMap,
    shadow_uUseShadowMap: n.shadowMaps ? n.shadowMaps.length > 0 : !1,
    shadow_uColor: n.shadowColor || rF,
    shadow_uLightId: n.shadowLightId || 0,
    shadow_uLightCount: n.shadowMatrices.length
  }, i = tF({
    viewport: n.viewport,
    center: e.project_uCenter
  }), o = [], c = nF({
    shadowMatrices: n.shadowMatrices,
    viewport: n.viewport
  }).slice();
  for (let l = 0; l < n.shadowMatrices.length; l++) {
    const _ = c[l], b = _.clone().translate(new Ke(n.viewport.center).negate());
    e.project_uCoordinateSystem === cr.LNGLAT && e.project_uProjectionMode === _c.WEB_MERCATOR ? (c[l] = b, o[l] = i) : (c[l] = _.clone().multiplyRight(iF), o[l] = b.transform(i));
  }
  for (let l = 0; l < c.length; l++)
    r["shadow_uViewProjectionMatrices[".concat(l, "]")] = c[l], r["shadow_uProjectCenters[".concat(l, "]")] = o[l], n.shadowMaps && n.shadowMaps.length > 0 ? r["shadow_uShadowMap".concat(l)] = n.shadowMaps[l] : r["shadow_uShadowMap".concat(l)] = n.dummyShadowMap;
  return r;
}
const p_ = {
  name: "shadow",
  dependencies: [K1],
  vs: QD,
  fs: eF,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: function() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return "viewport" in n && (n.drawToShadowMap || n.shadowMaps && n.shadowMaps.length > 0) ? lF(n, e) : {};
  }
}, cF = {
  color: [255, 255, 255],
  intensity: 1
}, Wx = [{
  color: [255, 255, 255],
  intensity: 1,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}], uF = [0, 0, 0, 200 / 255];
class tb {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    V(this, "id", "lighting-effect"), V(this, "props", void 0), V(this, "shadowColor", uF), V(this, "shadow", void 0), V(this, "ambientLight", void 0), V(this, "directionalLights", void 0), V(this, "pointLights", void 0), V(this, "shadowPasses", []), V(this, "shadowMaps", []), V(this, "dummyShadowMap", null), V(this, "programManager", void 0), V(this, "shadowMatrices", void 0), this.setProps(e);
  }
  setProps(e) {
    this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
    for (const t in e) {
      const r = e[t];
      switch (r.type) {
        case "ambient":
          this.ambientLight = r;
          break;
        case "directional":
          this.directionalLights.push(r);
          break;
        case "point":
          this.pointLights.push(r);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.props = e;
  }
  preRender(e, t) {
    let {
      layers: r,
      layerFilter: i,
      viewports: o,
      onViewportActive: c,
      views: l
    } = t;
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices(), this.shadowPasses.length === 0 && this._createShadowPasses(e), this.programManager || (this.programManager = zp.getDefaultProgramManager(e), p_ && this.programManager.addDefaultModule(p_)), this.dummyShadowMap || (this.dummyShadowMap = new Aa(e, {
        width: 1,
        height: 1
      }));
      for (let _ = 0; _ < this.shadowPasses.length; _++)
        this.shadowPasses[_].render({
          layers: r,
          layerFilter: i,
          viewports: o,
          onViewportActive: c,
          views: l,
          moduleParameters: {
            shadowLightId: _,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
    }
  }
  getModuleParameters(e) {
    const t = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    return t.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((r) => r.getProjectedLight({
        layer: e
      })),
      pointLights: this.pointLights.map((r) => r.getProjectedLight({
        layer: e
      }))
    }, t;
  }
  cleanup() {
    for (const e of this.shadowPasses)
      e.delete();
    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.delete(), this.dummyShadowMap = null), this.shadow && this.programManager && (this.programManager.removeDefaultModule(p_), this.programManager = null);
  }
  _calculateMatrices() {
    const e = [];
    for (const t of this.directionalLights) {
      const r = new lr().lookAt({
        eye: new Ke(t.direction).negate()
      });
      e.push(r);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let t = 0; t < this.directionalLights.length; t++) {
      const r = new ED(e);
      this.shadowPasses[t] = r, this.shadowMaps[t] = r.shadowMap;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: r
    } = this;
    !e && t.length === 0 && r.length === 0 && (this.ambientLight = new HS(cF), this.directionalLights.push(new Ux(Wx[0]), new Ux(Wx[1])));
  }
}
class hF {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    V(this, "_pool", []), V(this, "opts", {
      overAlloc: 2,
      poolSize: 100
    }), this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, t, r) {
    let {
      size: i = 1,
      type: o,
      padding: c = 0,
      copy: l = !1,
      initialize: _ = !1,
      maxCount: b
    } = r;
    const w = o || e && e.constructor || Float32Array, T = t * i + c;
    if (ArrayBuffer.isView(e)) {
      if (T <= e.length)
        return e;
      if (T * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new w(e.buffer, 0, T);
    }
    let I = 1 / 0;
    b && (I = b * i + c);
    const P = this._allocate(w, T, _, I);
    return e && l ? P.set(e) : _ || P.fill(0, 0, 4), this._release(e), P;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, t, r, i) {
    let o = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
    o > i && (o = i);
    const c = this._pool, l = e.BYTES_PER_ELEMENT * o, _ = c.findIndex((b) => b.byteLength >= l);
    if (_ >= 0) {
      const b = new e(c.splice(_, 1)[0], 0, o);
      return r && b.fill(0), b;
    }
    return new e(o);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const t = this._pool, {
      buffer: r
    } = e, {
      byteLength: i
    } = r, o = t.findIndex((c) => c.byteLength >= i);
    o < 0 ? t.push(r) : (o > 0 || t.length < this.opts.poolSize) && t.splice(o, 0, r), t.length > this.opts.poolSize && t.shift();
  }
}
const wp = new hF();
function np() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function dF(n) {
  return [n[12], n[13], n[14]];
}
function fF(n) {
  return {
    left: yd(n[3] + n[0], n[7] + n[4], n[11] + n[8], n[15] + n[12]),
    right: yd(n[3] - n[0], n[7] - n[4], n[11] - n[8], n[15] - n[12]),
    bottom: yd(n[3] + n[1], n[7] + n[5], n[11] + n[9], n[15] + n[13]),
    top: yd(n[3] - n[1], n[7] - n[5], n[11] - n[9], n[15] - n[13]),
    near: yd(n[3] + n[2], n[7] + n[6], n[11] + n[10], n[15] + n[14]),
    far: yd(n[3] - n[2], n[7] - n[6], n[11] - n[10], n[15] - n[14])
  };
}
const Xx = new Ke();
function yd(n, e, t, r) {
  Xx.set(n, e, t);
  const i = Xx.len();
  return {
    distance: r / i,
    normal: new Ke(-n / i, -e / i, -t / i)
  };
}
function pF(n) {
  return n - Math.fround(n);
}
let Vf;
function g_(n, e) {
  const {
    size: t = 1,
    startIndex: r = 0
  } = e, i = e.endIndex !== void 0 ? e.endIndex : n.length, o = (i - r) / t;
  Vf = wp.allocate(Vf, o, {
    type: Float32Array,
    size: t * 2
  });
  let c = r, l = 0;
  for (; c < i; ) {
    for (let _ = 0; _ < t; _++) {
      const b = n[c++];
      Vf[l + _] = b, Vf[l + _ + t] = pF(b);
    }
    l += t * 2;
  }
  return Vf.subarray(0, o * t * 2);
}
function gF(n) {
  let e = null, t = !1;
  for (const r of n)
    r && (e ? (t || (e = [[e[0][0], e[0][1]], [e[1][0], e[1][1]]], t = !0), e[0][0] = Math.min(e[0][0], r[0][0]), e[0][1] = Math.min(e[0][1], r[0][1]), e[1][0] = Math.max(e[1][0], r[1][0]), e[1][1] = Math.max(e[1][1], r[1][1])) : e = r);
  return e;
}
const mF = Math.PI / 180, _F = np(), $x = [0, 0, 0], yF = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function bF(n) {
  let {
    width: e,
    height: t,
    orthographic: r,
    fovyRadians: i,
    focalDistance: o,
    padding: c,
    near: l,
    far: _
  } = n;
  const b = e / t, w = r ? new lr().orthographic({
    fovy: i,
    aspect: b,
    focalDistance: o,
    near: l,
    far: _
  }) : new lr().perspective({
    fovy: i,
    aspect: b,
    near: l,
    far: _
  });
  if (c) {
    const {
      left: T = 0,
      right: I = 0,
      top: P = 0,
      bottom: k = 0
    } = c, U = eu((T + e - I) / 2, 0, e) - e / 2, G = eu((P + t - k) / 2, 0, t) - t / 2;
    w[8] -= U * 2 / e, w[9] += G * 2 / t;
  }
  return w;
}
class rf {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    V(this, "id", void 0), V(this, "x", void 0), V(this, "y", void 0), V(this, "width", void 0), V(this, "height", void 0), V(this, "padding", void 0), V(this, "isGeospatial", void 0), V(this, "zoom", void 0), V(this, "focalDistance", void 0), V(this, "position", void 0), V(this, "modelMatrix", void 0), V(this, "distanceScales", void 0), V(this, "scale", void 0), V(this, "center", void 0), V(this, "cameraPosition", void 0), V(this, "projectionMatrix", void 0), V(this, "viewMatrix", void 0), V(this, "viewMatrixUncentered", void 0), V(this, "viewMatrixInverse", void 0), V(this, "viewProjectionMatrix", void 0), V(this, "pixelProjectionMatrix", void 0), V(this, "pixelUnprojectionMatrix", void 0), V(this, "resolution", void 0), V(this, "_frustumPlanes", {}), this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || yF, this.focalDistance = e.focalDistance || 1, this.position = e.position || $x, this.modelMatrix = e.modelMatrix || null;
    const {
      longitude: t,
      latitude: r
    } = e;
    this.isGeospatial = Number.isFinite(r) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? _c.WEB_MERCATOR : _c.WEB_MERCATOR_AUTO_OFFSET : _c.IDENTITY;
  }
  equals(e) {
    return e instanceof rf ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && Sl(e.projectionMatrix, this.projectionMatrix) && Sl(e.viewMatrix, this.viewMatrix) : !1;
  }
  project(e) {
    let {
      topLeft: t = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.projectPosition(e), i = eE(r, this.pixelProjectionMatrix), [o, c] = i, l = t ? c : this.height - c;
    return e.length === 2 ? [o, l] : [o, l, i[2]];
  }
  unproject(e) {
    let {
      topLeft: t = !0,
      targetZ: r
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const [i, o, c] = e, l = t ? o : this.height - o, _ = r && r * this.distanceScales.unitsPerMeter[2], b = eb([i, l, c], this.pixelUnprojectionMatrix, _), [w, T, I] = this.unprojectPosition(b);
    return Number.isFinite(c) ? [w, T, I] : Number.isFinite(r) ? [w, T, r] : [w, T];
  }
  projectPosition(e) {
    const [t, r] = this.projectFlat(e), i = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [t, r, i];
  }
  unprojectPosition(e) {
    const [t, r] = this.unprojectFlat(e), i = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [t, r, i];
  }
  projectFlat(e) {
    if (this.isGeospatial) {
      const t = xp(e);
      return t[1] = eu(t[1], -318, 830), t;
    }
    return e;
  }
  unprojectFlat(e) {
    return this.isGeospatial ? Kd(e) : e;
  }
  getBounds() {
    const t = {
      targetZ: (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).z || 0
    }, r = this.unproject([0, 0], t), i = this.unproject([this.width, 0], t), o = this.unproject([0, this.height], t), c = this.unproject([this.width, this.height], t);
    return [Math.min(r[0], i[0], o[0], c[0]), Math.min(r[1], i[1], o[1], c[1]), Math.max(r[0], i[0], o[0], c[0]), Math.max(r[1], i[1], o[1], c[1])];
  }
  getDistanceScales(e) {
    return e ? Cy({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel(e) {
    let {
      x: t,
      y: r,
      width: i = 1,
      height: o = 1
    } = e;
    return t < this.x + this.width && this.x < t + i && r < this.y + this.height && this.y < r + o;
  }
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, fF(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  panByPosition(e, t) {
    return null;
  }
  _initProps(e) {
    const t = e.longitude, r = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = WD({
      latitude: r
    }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || Cy({
      latitude: r,
      longitude: t
    }));
    const i = Math.pow(2, this.zoom);
    this.scale = i;
    const {
      position: o,
      modelMatrix: c
    } = e;
    let l = $x;
    if (o && (l = c ? new lr(c).transformAsVector(o, []) : o), this.isGeospatial) {
      const _ = this.projectPosition([t, r, 0]);
      this.center = new Ke(l).scale(this.distanceScales.unitsPerMeter).add(_);
    } else
      this.center = this.projectPosition(l);
  }
  _initMatrices(e) {
    const {
      viewMatrix: t = _F,
      projectionMatrix: r = null,
      orthographic: i = !1,
      fovyRadians: o,
      fovy: c = 75,
      near: l = 0.1,
      far: _ = 1e3,
      padding: b = null,
      focalDistance: w = 1
    } = e;
    this.viewMatrixUncentered = t, this.viewMatrix = new lr().multiplyRight(t).translate(new Ke(this.center).negate()), this.projectionMatrix = r || bF({
      width: this.width,
      height: this.height,
      orthographic: i,
      fovyRadians: o || c * mF,
      focalDistance: w,
      padding: b,
      near: l,
      far: _
    });
    const T = np();
    Rh(T, T, this.projectionMatrix), Rh(T, T, this.viewMatrix), this.viewProjectionMatrix = T, this.viewMatrixInverse = Ay([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = dF(this.viewMatrixInverse);
    const I = np(), P = np();
    X1(I, I, [this.width / 2, -this.height / 2, 1]), vm(I, I, [1, -1, 0]), Rh(P, I, this.viewProjectionMatrix), this.pixelProjectionMatrix = P, this.pixelUnprojectionMatrix = Ay(np(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || ur.warn("Pixel project matrix not invertible")();
  }
}
V(rf, "displayName", "Viewport");
class kh extends rf {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      latitude: t = 0,
      longitude: r = 0,
      zoom: i = 0,
      pitch: o = 0,
      bearing: c = 0,
      nearZMultiplier: l = 0.1,
      farZMultiplier: _ = 1.01,
      nearZ: b,
      farZ: w,
      orthographic: T = !1,
      projectionMatrix: I,
      repeat: P = !1,
      worldOffset: k = 0,
      position: U,
      padding: G,
      legacyMeterSizes: H = !1
    } = e;
    let {
      width: $,
      height: ie,
      altitude: ge = 1.5
    } = e;
    const Se = Math.pow(2, i);
    $ = $ || 1, ie = ie || 1;
    let Re, Le = null;
    if (I)
      ge = I[5] / 2, Re = Am(ge);
    else {
      e.fovy ? (Re = e.fovy, ge = QS(Re)) : Re = Am(ge);
      let Ge;
      if (G) {
        const {
          top: ke = 0,
          bottom: oe = 0
        } = G;
        Ge = [0, eu((ke + ie - oe) / 2, 0, ie) - ie / 2];
      }
      Le = $D({
        width: $,
        height: ie,
        scale: Se,
        center: U && [0, 0, U[2] * Zg(t)],
        offset: Ge,
        pitch: o,
        fovy: Re,
        nearZMultiplier: l,
        farZMultiplier: _
      }), Number.isFinite(b) && (Le.near = b), Number.isFinite(w) && (Le.far = w);
    }
    let _e = XD({
      height: ie,
      pitch: o,
      bearing: c,
      scale: Se,
      altitude: ge
    });
    k && (_e = new lr().translate([512 * k, 0, 0]).multiplyLeft(_e)), super({
      ...e,
      width: $,
      height: ie,
      viewMatrix: _e,
      longitude: r,
      latitude: t,
      zoom: i,
      ...Le,
      fovy: Re,
      focalDistance: ge
    }), V(this, "longitude", void 0), V(this, "latitude", void 0), V(this, "pitch", void 0), V(this, "bearing", void 0), V(this, "altitude", void 0), V(this, "fovy", void 0), V(this, "orthographic", void 0), V(this, "_subViewports", void 0), V(this, "_pseudoMeters", void 0), this.latitude = t, this.longitude = r, this.zoom = i, this.pitch = o, this.bearing = c, this.altitude = ge, this.fovy = Re, this.orthographic = T, this._subViewports = P ? [] : null, this._pseudoMeters = H, Object.freeze(this);
  }
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), r = Math.ceil((e[2] - 180) / 360);
      for (let i = t; i <= r; i++) {
        const o = i ? new kh({
          ...this,
          worldOffset: i
        }) : this;
        this._subViewports.push(o);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [t, r] = this.projectFlat(e), i = (e[2] || 0) * Zg(e[1]);
    return [t, r, i];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [t, r] = this.unprojectFlat(e), i = (e[2] || 0) / Zg(r);
    return [t, r, i];
  }
  addMetersToLngLat(e, t) {
    return KS(e, t);
  }
  panByPosition(e, t) {
    const r = eb(t, this.pixelUnprojectionMatrix), i = this.projectFlat(e), o = Px([], i, b6([], r)), c = Px([], this.center, o), [l, _] = this.unprojectFlat(c);
    return {
      longitude: l,
      latitude: _
    };
  }
  getBounds() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = YD(this, e.z || 0);
    return [Math.min(t[0][0], t[1][0], t[2][0], t[3][0]), Math.min(t[0][1], t[1][1], t[2][1], t[3][1]), Math.max(t[0][0], t[1][0], t[2][0], t[3][0]), Math.max(t[0][1], t[1][1], t[2][1], t[3][1])];
  }
  fitBounds(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      width: r,
      height: i
    } = this, {
      longitude: o,
      latitude: c,
      zoom: l
    } = ZD({
      width: r,
      height: i,
      bounds: e,
      ...t
    });
    return new kh({
      width: r,
      height: i,
      longitude: o,
      latitude: c,
      zoom: l
    });
  }
}
V(kh, "displayName", "WebMercatorViewport");
const Zx = [0, 0, 0];
function m_(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const r = e.projectPosition(n);
  if (t && e instanceof kh) {
    const [i, o, c = 0] = n, l = e.getDistanceScales([i, o]);
    r[2] = c * l.unitsPerMeter[2];
  }
  return r;
}
function vF(n) {
  const {
    viewport: e,
    modelMatrix: t,
    coordinateOrigin: r
  } = n;
  let {
    coordinateSystem: i,
    fromCoordinateSystem: o,
    fromCoordinateOrigin: c
  } = n;
  return i === cr.DEFAULT && (i = e.isGeospatial ? cr.LNGLAT : cr.CARTESIAN), o === void 0 && (o = i), c === void 0 && (c = r), {
    viewport: e,
    coordinateSystem: i,
    coordinateOrigin: r,
    modelMatrix: t,
    fromCoordinateSystem: o,
    fromCoordinateOrigin: c
  };
}
function tE(n, e) {
  let {
    viewport: t,
    modelMatrix: r,
    coordinateSystem: i,
    coordinateOrigin: o,
    offsetMode: c
  } = e, [l, _, b = 0] = n;
  switch (r && ([l, _, b] = Np([], [l, _, b, 1], r)), i) {
    case cr.LNGLAT:
      return m_([l, _, b], t, c);
    case cr.LNGLAT_OFFSETS:
      return m_([l + o[0], _ + o[1], b + (o[2] || 0)], t, c);
    case cr.METER_OFFSETS:
      return m_(KS(o, [l, _, b]), t, c);
    case cr.CARTESIAN:
    default:
      return t.isGeospatial ? [l + o[0], _ + o[1], b + o[2]] : t.projectPosition([l, _, b]);
  }
}
function xF(n, e) {
  const {
    viewport: t,
    coordinateSystem: r,
    coordinateOrigin: i,
    modelMatrix: o,
    fromCoordinateSystem: c,
    fromCoordinateOrigin: l
  } = vF(e), {
    autoOffset: _ = !0
  } = e, {
    geospatialOrigin: b = Zx,
    shaderCoordinateOrigin: w = Zx,
    offsetMode: T = !1
  } = _ ? JS(t, r, i) : {}, I = tE(n, {
    viewport: t,
    modelMatrix: o,
    coordinateSystem: c,
    coordinateOrigin: l,
    offsetMode: T
  });
  if (T) {
    const P = t.projectPosition(b || w);
    M6(I, I, P);
  }
  return I;
}
const Jx = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
class nE extends Y1 {
  constructor() {
    super(...arguments), V(this, "pickZ", void 0), V(this, "_colorEncoderState", null);
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  _drawPickingBuffer(e) {
    let {
      layers: t,
      layerFilter: r,
      views: i,
      viewports: o,
      onViewportActive: c,
      pickingFBO: l,
      deviceRect: {
        x: _,
        y: b,
        width: w,
        height: T
      },
      cullRect: I,
      effects: P,
      pass: k = "picking",
      pickZ: U,
      moduleParameters: G
    } = e;
    const H = this.gl;
    this.pickZ = U;
    const $ = this._resetColorEncoder(U), ie = Al(H, {
      scissorTest: !0,
      scissor: [_, b, w, T],
      clearColor: [0, 0, 0, 0],
      depthMask: !0,
      depthTest: !0,
      depthRange: [0, 1],
      colorMask: [!0, !0, !0, !0],
      ...Jx,
      blend: !U
    }, () => super.render({
      target: l,
      layers: t,
      layerFilter: r,
      views: i,
      viewports: o,
      onViewportActive: c,
      cullRect: I,
      effects: P == null ? void 0 : P.filter((Se) => Se.useInPicking),
      pass: k,
      isPicking: !0,
      moduleParameters: G
    }));
    return this._colorEncoderState = null, {
      decodePickingColor: $ && AF.bind(null, $),
      stats: ie
    };
  }
  shouldDrawLayer(e) {
    const {
      pickable: t,
      operation: r
    } = e.props;
    return t && r.includes("draw") || r.includes("terrain") || r.includes("mask");
  }
  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }
  getLayerParameters(e, t, r) {
    const i = {
      ...e.props.parameters
    }, {
      pickable: o,
      operation: c
    } = e.props;
    return this._colorEncoderState ? o && c.includes("draw") && (Object.assign(i, Jx), i.blend = !0, i.blendColor = wF(this._colorEncoderState, e, r)) : i.blend = !1, c.includes("terrain") && (i.blend = !1), i;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function wF(n, e, t) {
  const {
    byLayer: r,
    byAlpha: i
  } = n;
  let o, c = r.get(e);
  return c ? (c.viewports.push(t), o = c.a) : (o = r.size + 1, o <= 255 ? (c = {
    a: o,
    layer: e,
    viewports: [t]
  }, r.set(e, c), i[o] = c) : (ur.warn("Too many pickable layers, only picking the first 255")(), o = 0)), [0, 0, 0, o / 255];
}
function AF(n, e) {
  const t = n.byAlpha[e[3]];
  return t && {
    pickedLayer: t.layer,
    pickedViewports: t.viewports,
    pickedObjectIndex: t.layer.decodePickingColor(e)
  };
}
const Ed = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, Sm = Symbol.for("component"), Vu = Symbol.for("propTypes"), __ = Symbol.for("deprecatedProps"), kd = Symbol.for("asyncPropDefaults"), Nh = Symbol.for("asyncPropOriginal"), Uu = Symbol.for("asyncPropResolved");
function jm(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => !0;
  return Array.isArray(n) ? rE(n, e, []) : e(n) ? [n] : [];
}
function rE(n, e, t) {
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    Array.isArray(i) ? rE(i, e, t) : e(i) && t.push(i);
  }
  return t;
}
function SF(n) {
  let {
    target: e,
    source: t,
    start: r = 0,
    count: i = 1
  } = n;
  const o = t.length, c = i * o;
  let l = 0;
  for (let _ = r; l < o; l++)
    e[_++] = t[l];
  for (; l < c; )
    l < c - l ? (e.copyWithin(r + l, r, r + l), l *= 2) : (e.copyWithin(r + l, r, r + c - l), l = c);
  return e;
}
class EF {
  constructor(e, t, r) {
    V(this, "id", void 0), V(this, "context", void 0), V(this, "isLoaded", void 0), V(this, "persistent", void 0), V(this, "_loadCount", 0), V(this, "_subscribers", /* @__PURE__ */ new Set()), V(this, "_data", void 0), V(this, "_loader", void 0), V(this, "_error", void 0), V(this, "_content", void 0), this.id = e, this.context = r, this.setData(t);
  }
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, t) {
    if (e === this._data && !t)
      return;
    this._data = e;
    const r = ++this._loadCount;
    let i = e;
    typeof e == "string" && (i = Hu(e)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then((o) => {
      this._loadCount === r && (this.isLoaded = !0, this._error = void 0, this._content = o);
    }).catch((o) => {
      this._loadCount === r && (this.isLoaded = !0, this._error = o || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const o of this._subscribers)
      o.onChange(this.getData());
  }
}
class TF {
  constructor(e) {
    let {
      gl: t,
      protocol: r
    } = e;
    V(this, "protocol", void 0), V(this, "_context", void 0), V(this, "_resources", void 0), V(this, "_consumers", void 0), V(this, "_pruneRequest", void 0), this.protocol = r || "resource://", this._context = {
      gl: t,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add(e) {
    let {
      resourceId: t,
      data: r,
      forceUpdate: i = !1,
      persistent: o = !0
    } = e, c = this._resources[t];
    c ? c.setData(r, i) : (c = new EF(t, r, this._context), this._resources[t] = c), c.persistent = o;
  }
  remove(e) {
    const t = this._resources[e];
    t && (t.delete(), delete this._resources[e]);
  }
  unsubscribe(e) {
    let {
      consumerId: t
    } = e;
    const r = this._consumers[t];
    if (r) {
      for (const i in r) {
        const o = r[i], c = this._resources[o.resourceId];
        c && c.unsubscribe(o);
      }
      delete this._consumers[t], this.prune();
    }
  }
  subscribe(e) {
    let {
      resourceId: t,
      onChange: r,
      consumerId: i,
      requestId: o = "default"
    } = e;
    const {
      _resources: c,
      protocol: l
    } = this;
    t.startsWith(l) && (t = t.replace(l, ""), c[t] || this.add({
      resourceId: t,
      data: null,
      persistent: !1
    }));
    const _ = c[t];
    if (this._track(i, o, _, r), _)
      return _.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, t, r, i) {
    const o = this._consumers, c = o[e] = o[e] || {}, l = c[t] || {}, _ = l.resourceId && this._resources[l.resourceId];
    _ && (_.unsubscribe(l), this.prune()), r && (c[t] = l, l.onChange = i, l.resourceId = r.id, r.subscribe(l));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const t = this._resources[e];
      !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
    }
  }
}
const CF = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, nb = {
  name: "project32",
  dependencies: [K1],
  vs: CF
}, rb = {
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:#decl": `
uniform bool picking_uAttribute;
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  },
  ...NO
}, IF = [K1], PF = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
function LF(n) {
  const e = zp.getDefaultProgramManager(n);
  for (const t of IF)
    e.addDefaultModule(t);
  for (const t of PF)
    e.addShaderHook(t);
  return e;
}
const MF = "layerManager.setLayers", BF = "layerManager.activateViewport";
class RF {
  constructor(e) {
    let {
      deck: t,
      stats: r,
      viewport: i,
      timeline: o
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    V(this, "layers", void 0), V(this, "context", void 0), V(this, "resourceManager", void 0), V(this, "_lastRenderedLayers", []), V(this, "_needsRedraw", !1), V(this, "_needsUpdate", !1), V(this, "_nextLayers", null), V(this, "_debug", !1), V(this, "activateViewport", (c) => {
      eo(BF, this, c), c && (this.context.viewport = c);
    }), this.layers = [], this.resourceManager = new TF({
      gl: e,
      protocol: "deck://"
    }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      gl: e,
      deck: t,
      programManager: e && LF(e),
      stats: r || new Bp({
        id: "deck.gl"
      }),
      viewport: i || new rf({
        id: "DEFAULT-INITIAL-VIEWPORT"
      }),
      timeline: o || new qS(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    }, t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const r of this.layers) {
      const i = r.getNeedsRedraw(e);
      t = t || i;
    }
    return t;
  }
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._needsUpdate;
  }
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  getLayers() {
    let {
      layerIds: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e ? this.layers.filter((t) => e.find((r) => t.id.indexOf(r) === 0)) : this.layers;
  }
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  setLayers(e, t) {
    eo(MF, this, t, e), this._lastRenderedLayers = e;
    const r = jm(e, Boolean);
    for (const i of r)
      i.context = this.context;
    this._updateLayers(this.layers, r);
  }
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw("updating layers: ".concat(e)), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  _handleError(e, t, r) {
    r.raiseError(t, "".concat(e, " of ").concat(r));
  }
  _updateLayers(e, t) {
    const r = {};
    for (const c of e)
      r[c.id] ? ur.warn("Multiple old layers with same id ".concat(c.id))() : r[c.id] = c;
    const i = [];
    this._updateSublayersRecursively(t, r, i), this._finalizeOldLayers(r);
    let o = !1;
    for (const c of i)
      if (c.hasUniformTransition()) {
        o = "Uniform transition in ".concat(c);
        break;
      }
    this._needsUpdate = o, this.layers = i;
  }
  _updateSublayersRecursively(e, t, r) {
    for (const i of e) {
      i.context = this.context;
      const o = t[i.id];
      o === null && ur.warn("Multiple new layers with same id ".concat(i.id))(), t[i.id] = null;
      let c = null;
      try {
        this._debug && o !== i && i.validateProps(), o ? (this._transferLayerState(o, i), this._updateLayer(i)) : this._initializeLayer(i), r.push(i), c = i.isComposite ? i.getSubLayers() : null;
      } catch (l) {
        this._handleError("matching", l, i);
      }
      c && this._updateSublayersRecursively(c, t, r);
    }
  }
  _finalizeOldLayers(e) {
    for (const t in e) {
      const r = e[t];
      r && this._finalizeLayer(r);
    }
  }
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = Ed.INITIALIZED;
    } catch (t) {
      this._handleError("initialization", t, e);
    }
  }
  _transferLayerState(e, t) {
    t._transferState(e), t.lifecycle = Ed.MATCHED, t !== e && (e.lifecycle = Ed.AWAITING_GC);
  }
  _updateLayer(e) {
    try {
      e._update();
    } catch (t) {
      this._handleError("update", t, e);
    }
  }
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(e), e.lifecycle = Ed.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = Ed.FINALIZED;
    } catch (t) {
      this._handleError("finalization", t, e);
    }
  }
}
function yc(n, e, t) {
  if (n === e)
    return !0;
  if (!t || !n || !e)
    return !1;
  if (Array.isArray(n)) {
    if (!Array.isArray(e) || n.length !== e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!yc(n[r], e[r], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof n == "object" && typeof e == "object") {
    const r = Object.keys(n), i = Object.keys(e);
    if (r.length !== i.length)
      return !1;
    for (const o of r)
      if (!e.hasOwnProperty(o) || !yc(n[o], e[o], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class OF {
  constructor(e) {
    V(this, "width", void 0), V(this, "height", void 0), V(this, "views", void 0), V(this, "viewState", void 0), V(this, "controllers", void 0), V(this, "timeline", void 0), V(this, "_viewports", void 0), V(this, "_viewportMap", void 0), V(this, "_isUpdating", void 0), V(this, "_needsRedraw", void 0), V(this, "_needsUpdate", void 0), V(this, "_eventManager", void 0), V(this, "_eventCallbacks", void 0), this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  finalize() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.finalize();
    }
    this.controllers = {};
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  updateViewStates() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.updateTransition();
    }
  }
  getViewports(e) {
    return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
  }
  getViews() {
    const e = {};
    return this.views.forEach((t) => {
      e[t.id] = t;
    }), e;
  }
  getView(e) {
    return this.views.find((t) => t.id === e);
  }
  getViewState(e) {
    const t = typeof e == "string" ? this.getView(e) : e, r = t && this.viewState[t.getViewStateId()] || this.viewState;
    return t ? t.filterViewState(r) : r;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  unproject(e, t) {
    const r = this.getViewports(), i = {
      x: e[0],
      y: e[1]
    };
    for (let o = r.length - 1; o >= 0; --o) {
      const c = r[o];
      if (c.containsPixel(i)) {
        const l = e.slice();
        return l[0] -= c.x, l[1] -= c.y, c.unproject(l, t);
      }
    }
    return null;
  }
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, t) {
    (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
  }
  _setViews(e) {
    e = jm(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!yc(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : ur.warn("missing `viewState` or `initialViewState`")();
  }
  _onViewStateChange(e, t) {
    this._eventCallbacks.onViewStateChange && this._eventCallbacks.onViewStateChange({
      ...t,
      viewId: e
    });
  }
  _createController(e, t) {
    const r = t.type;
    return new r({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, t.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (o) => {
        var c;
        return (c = this.getView(e.id)) === null || c === void 0 ? void 0 : c.makeViewport({
          viewState: o,
          width: this.width,
          height: this.height
        });
      }
    });
  }
  _updateController(e, t, r, i) {
    const o = e.controller;
    if (o && r) {
      const c = {
        ...t,
        ...o,
        id: e.id,
        x: r.x,
        y: r.y,
        width: r.width,
        height: r.height
      };
      return (!i || i.constructor !== o.type) && (i = this._createController(e, c)), i && i.setProps(c), i;
    }
    return null;
  }
  _rebuildViewports() {
    const {
      views: e
    } = this, t = this.controllers;
    this._viewports = [], this.controllers = {};
    let r = !1;
    for (let i = e.length; i--; ) {
      const o = e[i], c = this.getViewState(o), l = o.makeViewport({
        viewState: c,
        width: this.width,
        height: this.height
      });
      let _ = t[o.id];
      const b = !!o.controller;
      b && !_ && (r = !0), (r || !b) && _ && (_.finalize(), _ = null), this.controllers[o.id] = this._updateController(o, c, l, _), l && this._viewports.unshift(l);
    }
    for (const i in t) {
      const o = t[i];
      o && !this.controllers[i] && o.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  _diffViews(e, t) {
    return e.length !== t.length ? !0 : e.some((r, i) => !e[i].equals(t[i]));
  }
}
const DF = /([0-9]+\.?[0-9]*)(%|px)/;
function Mu(n) {
  switch (typeof n) {
    case "number":
      return {
        position: n,
        relative: !1
      };
    case "string":
      const e = DF.exec(n);
      if (e && e.length >= 3) {
        const t = e[2] === "%", r = parseFloat(e[1]);
        return {
          position: t ? r / 100 : r,
          relative: t
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(n));
  }
}
function Bu(n, e) {
  return n.relative ? Math.round(n.position * e) : n.position;
}
function Rs(n, e) {
  if (!n)
    throw new Error(e || "deck.gl: assertion failed.");
}
class FF {
  constructor(e) {
    V(this, "id", void 0), V(this, "viewportInstance", void 0), V(this, "_x", void 0), V(this, "_y", void 0), V(this, "_width", void 0), V(this, "_height", void 0), V(this, "_padding", void 0), V(this, "props", void 0);
    const {
      id: t,
      x: r = 0,
      y: i = 0,
      width: o = "100%",
      height: c = "100%",
      padding: l = null,
      viewportInstance: _
    } = e || {};
    Rs(!_ || _ instanceof rf), this.viewportInstance = _, this.id = t || this.constructor.displayName || "view", this.props = {
      ...e,
      id: this.id
    }, this._x = Mu(r), this._y = Mu(i), this._width = Mu(o), this._height = Mu(c), this._padding = l && {
      left: Mu(l.left || 0),
      right: Mu(l.right || 0),
      top: Mu(l.top || 0),
      bottom: Mu(l.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.viewportInstance ? e.viewportInstance ? this.viewportInstance.equals(e.viewportInstance) : !1 : this.ViewportType === e.ViewportType && yc(this.props, e.props, 2);
  }
  makeViewport(e) {
    let {
      width: t,
      height: r,
      viewState: i
    } = e;
    if (this.viewportInstance)
      return this.viewportInstance;
    i = this.filterViewState(i);
    const o = this.getDimensions({
      width: t,
      height: r
    });
    return !o.height || !o.width ? null : new this.ViewportType({
      ...i,
      ...this.props,
      ...o
    });
  }
  getViewStateId() {
    const {
      viewState: e
    } = this.props;
    return typeof e == "string" ? e : (e == null ? void 0 : e.id) || this.id;
  }
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const t = {
        ...e
      };
      for (const r in this.props.viewState)
        r !== "id" && (t[r] = this.props.viewState[r]);
      return t;
    }
    return e;
  }
  getDimensions(e) {
    let {
      width: t,
      height: r
    } = e;
    const i = {
      x: Bu(this._x, t),
      y: Bu(this._y, r),
      width: Bu(this._width, t),
      height: Bu(this._height, r)
    };
    return this._padding && (i.padding = {
      left: Bu(this._padding.left, t),
      top: Bu(this._padding.top, r),
      right: Bu(this._padding.right, t),
      bottom: Bu(this._padding.bottom, r)
    }), i;
  }
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? {
      type: this.ControllerType
    } : typeof e == "function" ? {
      type: e
    } : {
      type: this.ControllerType,
      ...e
    } : null;
  }
}
class jp {
  constructor(e) {
    V(this, "_inProgress", void 0), V(this, "_handle", void 0), V(this, "_timeline", void 0), V(this, "time", void 0), V(this, "settings", void 0), this._inProgress = !1, this._handle = null, this._timeline = e, this.time = 0, this.settings = {
      duration: 0
    };
  }
  get inProgress() {
    return this._inProgress;
  }
  start(e) {
    var t, r;
    this.cancel(), this.settings = e, this._inProgress = !0, (t = (r = this.settings).onStart) === null || t === void 0 || t.call(r, this);
  }
  end() {
    if (this._inProgress) {
      var e, t;
      this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, (e = (t = this.settings).onEnd) === null || e === void 0 || e.call(t, this);
    }
  }
  cancel() {
    if (this._inProgress) {
      var e, t;
      (e = (t = this.settings).onInterrupt) === null || e === void 0 || e.call(t, this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1;
    }
  }
  update() {
    var e, t;
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const {
        _timeline: r,
        settings: i
      } = this;
      this._handle = r.addChannel({
        delay: r.getTime(),
        duration: i.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), (e = (t = this.settings).onUpdate) === null || e === void 0 || e.call(t, this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  _onUpdate() {
  }
}
const Yx = () => {
}, Iy = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, kF = (n) => n, NF = Iy.BREAK;
class zF {
  constructor(e) {
    V(this, "getControllerState", void 0), V(this, "props", void 0), V(this, "propsInTransition", void 0), V(this, "transition", void 0), V(this, "onViewStateChange", void 0), V(this, "onStateChange", void 0), V(this, "_onTransitionUpdate", (t) => {
      const {
        time: r,
        settings: {
          interpolator: i,
          startProps: o,
          endProps: c,
          duration: l,
          easing: _
        }
      } = t, b = _(r / l), w = i.interpolateProps(o, c, b);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...w
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }), this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new jp(e.timeline), this.onViewStateChange = e.onViewStateChange || Yx, this.onStateChange = e.onStateChange || Yx;
  }
  finalize() {
    this.transition.cancel();
  }
  getViewportInTransition() {
    return this.propsInTransition;
  }
  processViewStateChange(e) {
    let t = !1;
    const r = this.props;
    if (this.props = e, !r || this._shouldIgnoreViewportChange(r, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let i = r;
      if (this.transition.inProgress) {
        const {
          interruption: o,
          endProps: c
        } = this.transition.settings;
        i = {
          ...r,
          ...o === Iy.SNAP_TO_END ? c : this.propsInTransition || r
        };
      }
      this._triggerTransition(i, e), t = !0;
    } else
      this.transition.cancel();
    return t;
  }
  updateTransition() {
    this.transition.update();
  }
  _isTransitionEnabled(e) {
    const {
      transitionDuration: t,
      transitionInterpolator: r
    } = e;
    return (t > 0 || t === "auto") && !!r;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, t) {
    return this.transition.inProgress ? this.transition.settings.interruption === Iy.IGNORE || this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
  }
  _triggerTransition(e, t) {
    const r = this.getControllerState(e), i = this.getControllerState(t).shortestPathFrom(r), o = t.transitionInterpolator, c = o.getDuration ? o.getDuration(e, t) : t.transitionDuration;
    if (c === 0)
      return;
    const l = o.initializeProps(e, i);
    this.propsInTransition = {};
    const _ = {
      duration: c,
      easing: t.transitionEasing || kF,
      interpolator: o,
      interruption: t.transitionInterruption || NF,
      startProps: l.start,
      endProps: l.end,
      onStart: t.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(t.onTransitionEnd)
    };
    this.transition.start(_), this.onStateChange({
      inTransition: !0
    }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (t) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e == null || e(t);
    };
  }
}
class UF {
  constructor(e) {
    V(this, "_propsToCompare", void 0), V(this, "_propsToExtract", void 0), V(this, "_requiredProps", void 0);
    const {
      compare: t,
      extract: r,
      required: i
    } = e;
    this._propsToCompare = t, this._propsToExtract = r || t, this._requiredProps = i;
  }
  arePropsEqual(e, t) {
    for (const r of this._propsToCompare)
      if (!(r in e) || !(r in t) || !Sl(e[r], t[r]))
        return !1;
    return !0;
  }
  initializeProps(e, t) {
    const r = {}, i = {};
    for (const o of this._propsToExtract)
      (o in e || o in t) && (r[o] = e[o], i[o] = t[o]);
    return this._checkRequiredProps(r), this._checkRequiredProps(i), {
      start: r,
      end: i
    };
  }
  getDuration(e, t) {
    return t.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((t) => {
      const r = e[t];
      Rs(Number.isFinite(r) || Array.isArray(r), "".concat(t, " is required for transition"));
    });
  }
}
const jF = ["longitude", "latitude", "zoom", "bearing", "pitch"], GF = ["longitude", "latitude", "zoom"];
class iE extends UF {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = Array.isArray(e) ? e : e.transitionProps, r = Array.isArray(e) ? {} : e;
    r.transitionProps = Array.isArray(t) ? {
      compare: t,
      required: t
    } : t || {
      compare: jF,
      required: GF
    }, super(r.transitionProps), V(this, "opts", void 0), this.opts = r;
  }
  initializeProps(e, t) {
    const r = super.initializeProps(e, t), {
      makeViewport: i,
      around: o
    } = this.opts;
    if (i && o) {
      const c = i(e), l = i(t), _ = c.unproject(o);
      r.start.around = o, Object.assign(r.end, {
        around: l.project(_),
        aroundPosition: _,
        width: t.width,
        height: t.height
      });
    }
    return r;
  }
  interpolateProps(e, t, r) {
    const i = {};
    for (const o of this._propsToExtract)
      i[o] = bm(e[o] || 0, t[o] || 0, r);
    if (t.aroundPosition && this.opts.makeViewport) {
      const o = this.opts.makeViewport({
        ...t,
        ...i
      });
      Object.assign(i, o.panByPosition(t.aroundPosition, bm(e.around, t.around, r)));
    }
    return i;
  }
}
const Ru = {
  transitionDuration: 0
}, VF = 300, Cg = (n) => 1 - (1 - n) * (1 - n), bd = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
}, yh = {};
class qF {
  constructor(e) {
    V(this, "props", void 0), V(this, "state", {}), V(this, "transitionManager", void 0), V(this, "eventManager", void 0), V(this, "onViewStateChange", void 0), V(this, "onStateChange", void 0), V(this, "makeViewport", void 0), V(this, "_controllerState", void 0), V(this, "_events", {}), V(this, "_interactionState", {
      isDragging: !1
    }), V(this, "_customEvents", []), V(this, "_eventStartBlocked", null), V(this, "_panMove", !1), V(this, "invertPan", !1), V(this, "dragMode", "rotate"), V(this, "inertia", 0), V(this, "scrollZoom", !0), V(this, "dragPan", !0), V(this, "dragRotate", !0), V(this, "doubleClickZoom", !0), V(this, "touchZoom", !0), V(this, "touchRotate", !1), V(this, "keyboard", !0), this.transitionManager = new zF({
      ...e,
      getControllerState: (t) => new this.ControllerState(t),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const t in this._events)
      if (this._events[t]) {
        var e;
        (e = this.eventManager) === null || e === void 0 || e.off(t, this.handleEvent);
      }
    this.transitionManager.finalize();
  }
  handleEvent(e) {
    this._controllerState = void 0;
    const t = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return t ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return t ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "tripanstart":
        return t ? !1 : this._onTriplePanStart(e);
      case "tripanmove":
        return this._onTriplePan(e);
      case "tripanend":
        return this._onTriplePanEnd(e);
      case "doubletap":
        return this._onDoubleTap(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const {
      x: t,
      y: r
    } = this.props, {
      offsetCenter: i
    } = e;
    return [i.x - t, i.y - r];
  }
  isPointInBounds(e, t) {
    const {
      width: r,
      height: i
    } = this.props;
    if (t && t.handled)
      return !1;
    const o = e[0] >= 0 && e[0] <= r && e[1] >= 0 && e[1] <= i;
    return o && t && t.stopPropagation(), o;
  }
  isFunctionKeyPressed(e) {
    const {
      srcEvent: t
    } = e;
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  blockEvents(e) {
    const t = setTimeout(() => {
      this._eventStartBlocked === t && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = t;
  }
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const {
      inertia: t
    } = e;
    this.inertia = Number.isFinite(t) ? t : t === !0 ? VF : 0;
    const {
      scrollZoom: r = !0,
      dragPan: i = !0,
      dragRotate: o = !0,
      doubleClickZoom: c = !0,
      touchZoom: l = !0,
      touchRotate: _ = !1,
      keyboard: b = !0
    } = e, w = !!this.onViewStateChange;
    this.toggleEvents(bd.WHEEL, w && r), this.toggleEvents(bd.PAN, w), this.toggleEvents(bd.PINCH, w && (l || _)), this.toggleEvents(bd.TRIPLE_PAN, w && _), this.toggleEvents(bd.DOUBLE_TAP, w && c), this.toggleEvents(bd.KEYBOARD, w && b), this.scrollZoom = r, this.dragPan = i, this.dragRotate = o, this.doubleClickZoom = c, this.touchZoom = l, this.touchRotate = _, this.keyboard = b;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, t) {
    this.eventManager && e.forEach((r) => {
      this._events[r] !== t && (this._events[r] = t, t ? this.eventManager.on(r, this.handleEvent) : this.eventManager.off(r, this.handleEvent));
    });
  }
  updateViewport(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = {
      ...e.getViewportProps(),
      ...t
    }, o = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(r), o) {
      const c = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({
        viewState: i,
        interactionState: this._interactionState,
        oldViewState: c
      });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({
      ...e,
      interactionState: this._interactionState
    });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  _onPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    let r = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (r = !r);
    const i = this.controllerState[r ? "panStart" : "rotateStart"]({
      pos: t
    });
    return this._panMove = r, this.updateViewport(i, Ru, {
      isDragging: !0
    }), !0;
  }
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const t = this.getCenter(e), r = this.controllerState.pan({
      pos: t
    });
    return this.updateViewport(r, Ru, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragPan && t && e.velocity) {
      const r = this.getCenter(e), i = [r[0] + e.velocityX * t / 2, r[1] + e.velocityY * t / 2], o = this.controllerState.pan({
        pos: i
      }).panEnd();
      this.updateViewport(o, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Cg
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const r = this.controllerState.panEnd();
      this.updateViewport(r, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const t = this.getCenter(e), r = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(r, Ru, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragRotate && t && e.velocity) {
      const r = this.getCenter(e), i = [r[0] + e.velocityX * t / 2, r[1] + e.velocityY * t / 2], o = this.controllerState.rotate({
        pos: i
      }).rotateEnd();
      this.updateViewport(o, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Cg
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const r = this.controllerState.rotateEnd();
      this.updateViewport(r, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    e.srcEvent.preventDefault();
    const {
      speed: r = 0.01,
      smooth: i = !1
    } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
      delta: o
    } = e;
    let c = 2 / (1 + Math.exp(-Math.abs(o * r)));
    o < 0 && c !== 0 && (c = 1 / c);
    const l = this.controllerState.zoom({
      pos: t,
      scale: c
    });
    return this.updateViewport(l, {
      ...this._getTransitionProps({
        around: t
      }),
      transitionDuration: i ? 250 : 1
    }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onTriplePanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const r = this.controllerState.rotateStart({
      pos: t
    });
    return this.updateViewport(r, Ru, {
      isDragging: !0
    }), !0;
  }
  _onTriplePan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const t = this.getCenter(e);
    t[0] -= e.deltaX;
    const r = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(r, Ru, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onTriplePanEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this;
    if (this.touchRotate && t && e.velocityY) {
      const r = this.getCenter(e), i = [r[0], r[1] += e.velocityY * t / 2], o = this.controllerState.rotate({
        pos: i
      });
      this.updateViewport(o, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Cg
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(t);
    } else {
      const r = this.controllerState.rotateEnd();
      this.updateViewport(r, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  _onPinchStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const r = this.controllerState.zoomStart({
      pos: t
    }).rotateStart({
      pos: t
    });
    return yh._startPinchRotation = e.rotation, yh._lastPinchEvent = e, this.updateViewport(r, Ru, {
      isDragging: !0
    }), !0;
  }
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let t = this.controllerState;
    if (this.touchZoom) {
      const {
        scale: r
      } = e, i = this.getCenter(e);
      t = t.zoom({
        pos: i,
        scale: r
      });
    }
    if (this.touchRotate) {
      const {
        rotation: r
      } = e;
      t = t.rotate({
        deltaAngleX: yh._startPinchRotation - r
      });
    }
    return this.updateViewport(t, Ru, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), yh._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this, {
      _lastPinchEvent: r
    } = yh;
    if (this.touchZoom && t && r && e.scale !== r.scale) {
      const i = this.getCenter(e);
      let o = this.controllerState.rotateEnd();
      const c = Math.log2(e.scale), l = (c - Math.log2(r.scale)) / (e.deltaTime - r.deltaTime), _ = Math.pow(2, c + l * t / 2);
      o = o.zoom({
        pos: i,
        scale: _
      }).zoomEnd(), this.updateViewport(o, {
        ...this._getTransitionProps({
          around: i
        }),
        transitionDuration: t,
        transitionEasing: Cg
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(t);
    } else {
      const i = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return yh._startPinchRotation = null, yh._lastPinchEvent = null, !0;
  }
  _onDoubleTap(e) {
    if (!this.doubleClickZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const r = this.isFunctionKeyPressed(e), i = this.controllerState.zoom({
      pos: t,
      scale: r ? 0.5 : 2
    });
    return this.updateViewport(i, this._getTransitionProps({
      around: t
    }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const t = this.isFunctionKeyPressed(e), {
      zoomSpeed: r,
      moveSpeed: i,
      rotateSpeedX: o,
      rotateSpeedY: c
    } = this.keyboard === !0 ? {} : this.keyboard, {
      controllerState: l
    } = this;
    let _;
    const b = {};
    switch (e.srcEvent.code) {
      case "Minus":
        _ = t ? l.zoomOut(r).zoomOut(r) : l.zoomOut(r), b.isZooming = !0;
        break;
      case "Equal":
        _ = t ? l.zoomIn(r).zoomIn(r) : l.zoomIn(r), b.isZooming = !0;
        break;
      case "ArrowLeft":
        t ? (_ = l.rotateLeft(o), b.isRotating = !0) : (_ = l.moveLeft(i), b.isPanning = !0);
        break;
      case "ArrowRight":
        t ? (_ = l.rotateRight(o), b.isRotating = !0) : (_ = l.moveRight(i), b.isPanning = !0);
        break;
      case "ArrowUp":
        t ? (_ = l.rotateUp(c), b.isRotating = !0) : (_ = l.moveUp(i), b.isPanning = !0);
        break;
      case "ArrowDown":
        t ? (_ = l.rotateDown(c), b.isRotating = !0) : (_ = l.moveDown(i), b.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(_, this._getTransitionProps(), b), !0;
  }
  _getTransitionProps(e) {
    const {
      transition: t
    } = this;
    return !t || !t.transitionInterpolator ? Ru : e ? {
      ...t,
      transitionInterpolator: new iE({
        ...e,
        ...t.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : t;
  }
}
class HF {
  constructor(e, t) {
    V(this, "_viewportProps", void 0), V(this, "_state", void 0), this._viewportProps = this.applyConstraints(e), this._state = t;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const Kx = 5, WF = 1.2;
class XF extends HF {
  constructor(e) {
    const {
      width: t,
      height: r,
      latitude: i,
      longitude: o,
      zoom: c,
      bearing: l = 0,
      pitch: _ = 0,
      altitude: b = 1.5,
      position: w = [0, 0, 0],
      maxZoom: T = 20,
      minZoom: I = 0,
      maxPitch: P = 60,
      minPitch: k = 0,
      startPanLngLat: U,
      startZoomLngLat: G,
      startRotatePos: H,
      startBearing: $,
      startPitch: ie,
      startZoom: ge,
      normalize: Se = !0
    } = e;
    Rs(Number.isFinite(o)), Rs(Number.isFinite(i)), Rs(Number.isFinite(c)), super({
      width: t,
      height: r,
      latitude: i,
      longitude: o,
      zoom: c,
      bearing: l,
      pitch: _,
      altitude: b,
      maxZoom: T,
      minZoom: I,
      maxPitch: P,
      minPitch: k,
      normalize: Se,
      position: w
    }, {
      startPanLngLat: U,
      startZoomLngLat: G,
      startRotatePos: H,
      startBearing: $,
      startPitch: ie,
      startZoom: ge
    }), V(this, "makeViewport", void 0), this.makeViewport = e.makeViewport;
  }
  panStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startPanLngLat: this._unproject(t)
    });
  }
  pan(e) {
    let {
      pos: t,
      startPos: r
    } = e;
    const i = this.getState().startPanLngLat || this._unproject(r);
    if (!i)
      return this;
    const c = this.makeViewport(this.getViewportProps()).panByPosition(i, t);
    return this._getUpdatedState(c);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  rotateStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startRotatePos: t,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate(e) {
    let {
      pos: t,
      deltaAngleX: r = 0,
      deltaAngleY: i = 0
    } = e;
    const {
      startRotatePos: o,
      startBearing: c,
      startPitch: l
    } = this.getState();
    if (!o || c === void 0 || l === void 0)
      return this;
    let _;
    return t ? _ = this._getNewRotation(t, o, l, c) : _ = {
      bearing: c + r,
      pitch: l + i
    }, this._getUpdatedState(_);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(t),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom(e) {
    let {
      pos: t,
      startPos: r,
      scale: i
    } = e, {
      startZoom: o,
      startZoomLngLat: c
    } = this.getState();
    if (c || (o = this.getViewportProps().zoom, c = this._unproject(r) || this._unproject(t)), !c)
      return this;
    const {
      maxZoom: l,
      minZoom: _
    } = this.getViewportProps();
    let b = o + Math.log2(i);
    b = eu(b, _, l);
    const w = this.makeViewport({
      ...this.getViewportProps(),
      zoom: b
    });
    return this._getUpdatedState({
      zoom: b,
      ...w.panByPosition(c, t)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(e);
  }
  zoomOut() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(1 / e);
  }
  moveLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([e, 0]);
  }
  moveRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([-e, 0]);
  }
  moveUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, e]);
  }
  moveDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, -e]);
  }
  rotateLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const t = e.getViewportProps(), r = {
      ...this.getViewportProps()
    }, {
      bearing: i,
      longitude: o
    } = r;
    return Math.abs(i - t.bearing) > 180 && (r.bearing = i < 0 ? i + 360 : i - 360), Math.abs(o - t.longitude) > 180 && (r.longitude = o < 0 ? o + 360 : o - 360), r;
  }
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: r,
      zoom: i
    } = e;
    e.zoom = eu(i, r, t);
    const {
      maxPitch: o,
      minPitch: c,
      pitch: l
    } = e;
    e.pitch = eu(l, c, o);
    const {
      normalize: _ = !0
    } = e;
    return _ && Object.assign(e, KD(e)), e;
  }
  _zoomFromCenter(e) {
    const {
      width: t,
      height: r
    } = this.getViewportProps();
    return this.zoom({
      pos: [t / 2, r / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const {
      width: t,
      height: r
    } = this.getViewportProps();
    return this.pan({
      startPos: [t / 2, r / 2],
      pos: [t / 2 + e[0], r / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const t = this.makeViewport(this.getViewportProps());
    return e && t.unproject(e);
  }
  _getNewRotation(e, t, r, i) {
    const o = e[0] - t[0], c = e[1] - t[1], l = e[1], _ = t[1], {
      width: b,
      height: w
    } = this.getViewportProps(), T = o / b;
    let I = 0;
    c > 0 ? Math.abs(w - _) > Kx && (I = c / (_ - w) * WF) : c < 0 && _ > Kx && (I = 1 - l / _), I = eu(I, -1, 1);
    const {
      minPitch: P,
      maxPitch: k
    } = this.getViewportProps(), U = i + 180 * T;
    let G = r;
    return I > 0 ? G = r + I * (k - r) : I < 0 && (G = r - I * (P - r)), {
      pitch: G,
      bearing: U
    };
  }
}
class $F extends qF {
  constructor() {
    super(...arguments), V(this, "ControllerState", XF), V(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new iE({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }), V(this, "dragMode", "pan");
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const t = this.props;
    super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class ib extends FF {
  get ViewportType() {
    return kh;
  }
  get ControllerType() {
    return $F;
  }
}
V(ib, "displayName", "MapView");
const ZF = new tb();
function JF(n, e) {
  var t, r;
  const i = (t = n.order) !== null && t !== void 0 ? t : 1 / 0, o = (r = e.order) !== null && r !== void 0 ? r : 1 / 0;
  return i - o;
}
class YF {
  constructor() {
    V(this, "effects", void 0), V(this, "_resolvedEffects", []), V(this, "_defaultEffects", []), V(this, "_needsRedraw", void 0), this.effects = [], this._needsRedraw = "Initial render", this._setEffects([]);
  }
  addDefaultEffect(e) {
    const t = this._defaultEffects;
    if (!t.find((r) => r.id === e.id)) {
      const r = t.findIndex((i) => JF(i, e) > 0);
      r < 0 ? t.push(e) : t.splice(r, 0, e), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (yc(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const t = {};
    for (const i of this.effects)
      t[i.id] = i;
    const r = [];
    for (const i of e) {
      const o = t[i.id];
      o && o !== i ? o.setProps ? (o.setProps(i.props), r.push(o)) : (o.cleanup(), r.push(i)) : r.push(i), delete t[i.id];
    }
    for (const i in t)
      t[i].cleanup();
    this.effects = r, this._resolvedEffects = r.concat(this._defaultEffects), e.some((i) => i instanceof tb) || this._resolvedEffects.push(ZF), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup();
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class KF extends Y1 {
  shouldDrawLayer(e) {
    const {
      operation: t
    } = e.props;
    return t.includes("draw") || t.includes("terrain");
  }
}
const QF = "deckRenderer.renderLayers";
class ek {
  constructor(e) {
    V(this, "gl", void 0), V(this, "layerFilter", void 0), V(this, "drawPickingColors", void 0), V(this, "drawLayersPass", void 0), V(this, "pickLayersPass", void 0), V(this, "renderCount", void 0), V(this, "_needsRedraw", void 0), V(this, "renderBuffers", void 0), V(this, "lastPostProcessEffect", void 0), this.gl = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new KF(e), this.pickLayersPass = new nE(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, r = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e,
      target: e.target || os.getDefaultFramebuffer(this.gl)
    };
    r.effects && this._preRender(r.effects, r);
    const i = this.lastPostProcessEffect ? this.renderBuffers[0] : r.target, o = t.render({
      ...r,
      target: i
    });
    r.effects && this._postRender(r.effects, r), this.renderCount++, eo(QF, this, o, e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  finalize() {
    const {
      renderBuffers: e
    } = this;
    for (const t of e)
      t.delete();
    e.length = 0;
  }
  _preRender(e, t) {
    this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
    for (const r of e)
      t.preRenderStats[r.id] = r.preRender(this.gl, t), r.postRender && (this.lastPostProcessEffect = r.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers: e
    } = this;
    e.length === 0 && e.push(new os(this.gl), new os(this.gl));
    for (const t of e)
      t.resize();
  }
  _postRender(e, t) {
    const {
      renderBuffers: r
    } = this, i = {
      ...t,
      inputBuffer: r[0],
      swapBuffer: r[1],
      target: null
    };
    for (const o of e)
      if (o.postRender) {
        if (o.id === this.lastPostProcessEffect) {
          i.target = t.target, o.postRender(this.gl, i);
          break;
        }
        const c = o.postRender(this.gl, i);
        i.inputBuffer = c, i.swapBuffer = c === r[0] ? r[1] : r[0];
      }
  }
}
const tk = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function nk(n) {
  let {
    pickedColors: e,
    decodePickingColor: t,
    deviceX: r,
    deviceY: i,
    deviceRadius: o,
    deviceRect: c
  } = n;
  const {
    x: l,
    y: _,
    width: b,
    height: w
  } = c;
  let T = o * o, I = -1, P = 0;
  for (let k = 0; k < w; k++) {
    const U = k + _ - i, G = U * U;
    if (G > T)
      P += 4 * b;
    else
      for (let H = 0; H < b; H++) {
        if (e[P + 3] - 1 >= 0) {
          const ie = H + l - r, ge = ie * ie + G;
          ge <= T && (T = ge, I = P);
        }
        P += 4;
      }
  }
  if (I >= 0) {
    const k = e.slice(I, I + 4), U = t(k);
    if (U) {
      const G = Math.floor(I / 4 / b), H = I / 4 - G * b;
      return {
        ...U,
        pickedColor: k,
        pickedX: l + H,
        pickedY: _ + G
      };
    }
    ur.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return tk;
}
function rk(n) {
  let {
    pickedColors: e,
    decodePickingColor: t
  } = n;
  const r = /* @__PURE__ */ new Map();
  if (e) {
    for (let i = 0; i < e.length; i += 4)
      if (e[i + 3] - 1 >= 0) {
        const c = e.slice(i, i + 4), l = c.join(",");
        if (!r.has(l)) {
          const _ = t(c);
          _ ? r.set(l, {
            ..._,
            color: c
          }) : ur.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(r.values());
}
function sE(n) {
  let {
    pickInfo: e,
    viewports: t,
    pixelRatio: r,
    x: i,
    y: o,
    z: c
  } = n, l = t[0];
  t.length > 1 && (l = sk((e == null ? void 0 : e.pickedViewports) || t, {
    x: i,
    y: o
  }));
  let _;
  if (l) {
    const b = [i - l.x, o - l.y];
    c !== void 0 && (b[2] = c), _ = l.unproject(b);
  }
  return {
    color: null,
    layer: null,
    viewport: l,
    index: -1,
    picked: !1,
    x: i,
    y: o,
    pixel: [i, o],
    coordinate: _,
    devicePixel: e && "pickedX" in e ? [e.pickedX, e.pickedY] : void 0,
    pixelRatio: r
  };
}
function ik(n) {
  const {
    pickInfo: e,
    lastPickedInfo: t,
    mode: r,
    layers: i
  } = n, {
    pickedColor: o,
    pickedLayer: c,
    pickedObjectIndex: l
  } = e, _ = c ? [c] : [];
  if (r === "hover") {
    const T = t.index, I = t.layerId, P = c ? c.props.id : null;
    if (P !== I || l !== T) {
      if (P !== I) {
        const k = i.find((U) => U.props.id === I);
        k && _.unshift(k);
      }
      t.layerId = P, t.index = l, t.info = null;
    }
  }
  const b = sE(n), w = /* @__PURE__ */ new Map();
  return w.set(null, b), _.forEach((T) => {
    let I = {
      ...b
    };
    T === c && (I.color = o, I.index = l, I.picked = !0), I = oE({
      layer: T,
      info: I,
      mode: r
    });
    const P = I.layer;
    T === c && r === "hover" && (t.info = I), w.set(P.id, I), r === "hover" && P.updateAutoHighlight(I);
  }), w;
}
function oE(n) {
  let {
    layer: e,
    info: t,
    mode: r
  } = n;
  for (; e && t; ) {
    const i = t.layer || null;
    t.sourceLayer = i, t.layer = e, t = e.getPickingInfo({
      info: t,
      mode: r,
      sourceLayer: i
    }), e = e.parent;
  }
  return t;
}
function sk(n, e) {
  for (let t = n.length - 1; t >= 0; t--) {
    const r = n[t];
    if (r.containsPixel(e))
      return r;
  }
  return n[0];
}
class ok {
  constructor(e) {
    V(this, "gl", void 0), V(this, "pickingFBO", void 0), V(this, "depthFBO", void 0), V(this, "pickLayersPass", void 0), V(this, "layerFilter", void 0), V(this, "lastPickedInfo", void 0), V(this, "_pickable", !0), this.gl = e, this.pickLayersPass = new nE(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.delete(), this.depthFBO && (this.depthFBO.color.delete(), this.depthFBO.delete());
  }
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  getLastPickedObject(e) {
    let {
      x: t,
      y: r,
      layers: i,
      viewports: o
    } = e, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.lastPickedInfo.info;
    const l = c && c.layer && c.layer.id, _ = c && c.viewport && c.viewport.id, b = l ? i.find((P) => P.id === l) : null, w = _ && o.find((P) => P.id === _) || o[0], T = w && w.unproject([t - w.x, r - w.y]);
    return {
      ...c,
      ...{
        x: t,
        y: r,
        viewport: w,
        coordinate: T,
        layer: b
      }
    };
  }
  _resizeBuffer() {
    var e, t;
    const {
      gl: r
    } = this;
    if (!this.pickingFBO && (this.pickingFBO = new os(r), os.isSupported(r, {
      colorBufferFloat: !0
    }))) {
      const i = new os(r);
      i.attach({
        36064: new Aa(r, {
          format: tr(r) ? 34836 : 6408,
          type: 5126
        })
      }), this.depthFBO = i;
    }
    (e = this.pickingFBO) === null || e === void 0 || e.resize({
      width: r.canvas.width,
      height: r.canvas.height
    }), (t = this.depthFBO) === null || t === void 0 || t.resize({
      width: r.canvas.width,
      height: r.canvas.height
    });
  }
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const t = e.filter((r) => this.pickLayersPass.shouldDrawLayer(r) && !r.isComposite);
    return t.length ? t : null;
  }
  _pickClosestObject(e) {
    let {
      layers: t,
      views: r,
      viewports: i,
      x: o,
      y: c,
      radius: l = 0,
      depth: _ = 1,
      mode: b = "query",
      unproject3D: w,
      onViewportActive: T,
      effects: I
    } = e;
    const P = this._getPickable(t), k = Wd(this.gl);
    if (!P)
      return {
        result: [],
        emptyInfo: sE({
          viewports: i,
          x: o,
          y: c,
          pixelRatio: k
        })
      };
    this._resizeBuffer();
    const U = t_(this.gl, [o, c], !0), G = [U.x + Math.floor(U.width / 2), U.y + Math.floor(U.height / 2)], H = Math.round(l * k), {
      width: $,
      height: ie
    } = this.pickingFBO, ge = this._getPickingRect({
      deviceX: G[0],
      deviceY: G[1],
      deviceRadius: H,
      deviceWidth: $,
      deviceHeight: ie
    }), Se = {
      x: o - l,
      y: c - l,
      width: l * 2 + 1,
      height: l * 2 + 1
    };
    let Re;
    const Le = [], _e = /* @__PURE__ */ new Set();
    for (let Ge = 0; Ge < _; Ge++) {
      let ke;
      if (ge) {
        const pe = this._drawAndSample({
          layers: P,
          views: r,
          viewports: i,
          onViewportActive: T,
          deviceRect: ge,
          cullRect: Se,
          effects: I,
          pass: "picking:".concat(b)
        });
        ke = nk({
          ...pe,
          deviceX: G[0],
          deviceY: G[1],
          deviceRadius: H,
          deviceRect: ge
        });
      } else
        ke = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let oe;
      if (ke.pickedLayer && w && this.depthFBO) {
        const {
          pickedColors: pe
        } = this._drawAndSample({
          layers: [ke.pickedLayer],
          views: r,
          viewports: i,
          onViewportActive: T,
          deviceRect: {
            x: ke.pickedX,
            y: ke.pickedY,
            width: 1,
            height: 1
          },
          cullRect: Se,
          effects: I,
          pass: "picking:".concat(b, ":z")
        }, !0);
        pe[3] && (oe = pe[0]);
      }
      ke.pickedLayer && Ge + 1 < _ && (_e.add(ke.pickedLayer), ke.pickedLayer.disablePickingIndex(ke.pickedObjectIndex)), Re = ik({
        pickInfo: ke,
        lastPickedInfo: this.lastPickedInfo,
        mode: b,
        layers: P,
        viewports: i,
        x: o,
        y: c,
        z: oe,
        pixelRatio: k
      });
      for (const pe of Re.values())
        pe.layer && Le.push(pe);
      if (!ke.pickedColor)
        break;
    }
    for (const Ge of _e)
      Ge.restorePickingColors();
    return {
      result: Le,
      emptyInfo: Re.get(null)
    };
  }
  _pickVisibleObjects(e) {
    let {
      layers: t,
      views: r,
      viewports: i,
      x: o,
      y: c,
      width: l = 1,
      height: _ = 1,
      mode: b = "query",
      maxObjects: w = null,
      onViewportActive: T,
      effects: I
    } = e;
    const P = this._getPickable(t);
    if (!P)
      return [];
    this._resizeBuffer();
    const k = Wd(this.gl), U = t_(this.gl, [o, c], !0), G = U.x, H = U.y + U.height, $ = t_(this.gl, [o + l, c + _], !0), ie = $.x + $.width, ge = $.y, Se = {
      x: G,
      y: ge,
      width: ie - G,
      height: H - ge
    }, Re = this._drawAndSample({
      layers: P,
      views: r,
      viewports: i,
      onViewportActive: T,
      deviceRect: Se,
      cullRect: {
        x: o,
        y: c,
        width: l,
        height: _
      },
      effects: I,
      pass: "picking:".concat(b)
    }), Le = rk(Re), _e = /* @__PURE__ */ new Map(), Ge = Number.isFinite(w);
    for (let oe = 0; oe < Le.length; oe++) {
      var ke;
      if (Ge && w && _e.size >= w)
        break;
      const pe = Le[oe];
      let Te = {
        color: pe.pickedColor,
        layer: null,
        index: pe.pickedObjectIndex,
        picked: !0,
        x: o,
        y: c,
        pixelRatio: k
      };
      Te = oE({
        layer: pe.pickedLayer,
        info: Te,
        mode: b
      });
      const xe = (ke = Te.object) !== null && ke !== void 0 ? ke : "".concat(Te.layer.id, "[").concat(Te.index, "]");
      _e.has(xe) || _e.set(xe, Te);
    }
    return Array.from(_e.values());
  }
  _drawAndSample(e) {
    let {
      layers: t,
      views: r,
      viewports: i,
      onViewportActive: o,
      deviceRect: c,
      cullRect: l,
      effects: _,
      pass: b
    } = e, w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const T = w ? this.depthFBO : this.pickingFBO, I = {
      layers: t,
      layerFilter: this.layerFilter,
      views: r,
      viewports: i,
      onViewportActive: o,
      pickingFBO: T,
      deviceRect: c,
      cullRect: l,
      effects: _,
      pass: b,
      pickZ: w,
      preRenderStats: {}
    };
    for (const ie of _)
      ie.useInPicking && (I.preRenderStats[ie.id] = ie.preRender(this.gl, I));
    const {
      decodePickingColor: P
    } = this.pickLayersPass.render(I), {
      x: k,
      y: U,
      width: G,
      height: H
    } = c, $ = new (w ? Float32Array : Uint8Array)(G * H * 4);
    return Um(T, {
      sourceX: k,
      sourceY: U,
      sourceWidth: G,
      sourceHeight: H,
      target: $
    }), {
      pickedColors: $,
      decodePickingColor: P
    };
  }
  _getPickingRect(e) {
    let {
      deviceX: t,
      deviceY: r,
      deviceRadius: i,
      deviceWidth: o,
      deviceHeight: c
    } = e;
    const l = Math.max(0, t - i), _ = Math.max(0, r - i), b = Math.min(o, t + i + 1) - l, w = Math.min(c, r + i + 1) - _;
    return b <= 0 || w <= 0 ? null : {
      x: l,
      y: _,
      width: b,
      height: w
    };
  }
}
const ak = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class lk {
  constructor(e) {
    V(this, "el", null), V(this, "isVisible", !1);
    const t = e.parentElement;
    t && (this.el = document.createElement("div"), this.el.className = "deck-tooltip", Object.assign(this.el.style, ak), t.appendChild(this.el));
  }
  setTooltip(e, t, r) {
    const i = this.el;
    if (i) {
      if (typeof e == "string")
        i.innerText = e;
      else if (e)
        e.text && (i.innerText = e.text), e.html && (i.innerHTML = e.html), e.className && (i.className = e.className);
      else {
        this.isVisible = !1, i.style.display = "none";
        return;
      }
      this.isVisible = !0, i.style.display = "block", i.style.transform = "translate(".concat(t, "px, ").concat(r, "px)"), e && typeof e == "object" && "style" in e && Object.assign(i.style, e.style);
    }
  }
  remove() {
    this.el && (this.el.remove(), this.el = null);
  }
}
var aE = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(n) {
  (function(e, t, r, i) {
    var o = ["", "webkit", "Moz", "MS", "ms", "o"], c = t.createElement("div"), l = "function", _ = Math.round, b = Math.abs, w = Date.now;
    function T(ae, me, De) {
      return setTimeout(ie(ae, De), me);
    }
    function I(ae, me, De) {
      return Array.isArray(ae) ? (P(ae, De[me], De), !0) : !1;
    }
    function P(ae, me, De) {
      var nt;
      if (ae)
        if (ae.forEach)
          ae.forEach(me, De);
        else if (ae.length !== i)
          for (nt = 0; nt < ae.length; )
            me.call(De, ae[nt], nt, ae), nt++;
        else
          for (nt in ae)
            ae.hasOwnProperty(nt) && me.call(De, ae[nt], nt, ae);
    }
    function k(ae, me, De) {
      var nt = "DEPRECATED METHOD: " + me + `
` + De + ` AT 
`;
      return function() {
        var Tt = new Error("get-stack-trace"), Vt = Tt && Tt.stack ? Tt.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", Pn = e.console && (e.console.warn || e.console.log);
        return Pn && Pn.call(e.console, nt, Vt), ae.apply(this, arguments);
      };
    }
    var U;
    typeof Object.assign != "function" ? U = function(me) {
      if (me === i || me === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var De = Object(me), nt = 1; nt < arguments.length; nt++) {
        var Tt = arguments[nt];
        if (Tt !== i && Tt !== null)
          for (var Vt in Tt)
            Tt.hasOwnProperty(Vt) && (De[Vt] = Tt[Vt]);
      }
      return De;
    } : U = Object.assign;
    var G = k(function(me, De, nt) {
      for (var Tt = Object.keys(De), Vt = 0; Vt < Tt.length; )
        (!nt || nt && me[Tt[Vt]] === i) && (me[Tt[Vt]] = De[Tt[Vt]]), Vt++;
      return me;
    }, "extend", "Use `assign`."), H = k(function(me, De) {
      return G(me, De, !0);
    }, "merge", "Use `assign`.");
    function $(ae, me, De) {
      var nt = me.prototype, Tt;
      Tt = ae.prototype = Object.create(nt), Tt.constructor = ae, Tt._super = nt, De && U(Tt, De);
    }
    function ie(ae, me) {
      return function() {
        return ae.apply(me, arguments);
      };
    }
    function ge(ae, me) {
      return typeof ae == l ? ae.apply(me && me[0] || i, me) : ae;
    }
    function Se(ae, me) {
      return ae === i ? me : ae;
    }
    function Re(ae, me, De) {
      P(ke(me), function(nt) {
        ae.addEventListener(nt, De, !1);
      });
    }
    function Le(ae, me, De) {
      P(ke(me), function(nt) {
        ae.removeEventListener(nt, De, !1);
      });
    }
    function _e(ae, me) {
      for (; ae; ) {
        if (ae == me)
          return !0;
        ae = ae.parentNode;
      }
      return !1;
    }
    function Ge(ae, me) {
      return ae.indexOf(me) > -1;
    }
    function ke(ae) {
      return ae.trim().split(/\s+/g);
    }
    function oe(ae, me, De) {
      if (ae.indexOf && !De)
        return ae.indexOf(me);
      for (var nt = 0; nt < ae.length; ) {
        if (De && ae[nt][De] == me || !De && ae[nt] === me)
          return nt;
        nt++;
      }
      return -1;
    }
    function pe(ae) {
      return Array.prototype.slice.call(ae, 0);
    }
    function Te(ae, me, De) {
      for (var nt = [], Tt = [], Vt = 0; Vt < ae.length; ) {
        var Pn = ae[Vt][me];
        oe(Tt, Pn) < 0 && nt.push(ae[Vt]), Tt[Vt] = Pn, Vt++;
      }
      return nt = nt.sort(function(Rr, ui) {
        return Rr[me] > ui[me];
      }), nt;
    }
    function xe(ae, me) {
      for (var De, nt, Tt = me[0].toUpperCase() + me.slice(1), Vt = 0; Vt < o.length; ) {
        if (De = o[Vt], nt = De ? De + Tt : me, nt in ae)
          return nt;
        Vt++;
      }
      return i;
    }
    var et = 1;
    function rt() {
      return et++;
    }
    function st(ae) {
      var me = ae.ownerDocument || ae;
      return me.defaultView || me.parentWindow || e;
    }
    var Je = /mobile|tablet|ip(ad|hone|od)|android/i, ct = "ontouchstart" in e, ot = xe(e, "PointerEvent") !== i, Mt = ct && Je.test(navigator.userAgent), re = "touch", Ae = "pen", Ce = "mouse", Ue = "kinect", qe = 25, He = 1, Ye = 2, Ze = 4, St = 8, Lt = 1, Dt = 2, Nt = 4, an = 8, at = 16, ne = Dt | Nt, pn = an | at, Qt = ne | pn, dt = ["x", "y"], Et = ["clientX", "clientY"];
    function Bt(ae, me) {
      var De = this;
      this.manager = ae, this.callback = me, this.element = ae.element, this.target = ae.options.inputTarget, this.domHandler = function(nt) {
        ge(ae.options.enable, [ae]) && De.handler(nt);
      }, this.init();
    }
    Bt.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && Re(this.element, this.evEl, this.domHandler), this.evTarget && Re(this.target, this.evTarget, this.domHandler), this.evWin && Re(st(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && Le(this.element, this.evEl, this.domHandler), this.evTarget && Le(this.target, this.evTarget, this.domHandler), this.evWin && Le(st(this.element), this.evWin, this.domHandler);
      }
    };
    function Ft(ae) {
      var me, De = ae.options.inputClass;
      return De ? me = De : ot ? me = be : Mt ? me = Ie : ct ? me = vt : me = zt, new me(ae, nn);
    }
    function nn(ae, me, De) {
      var nt = De.pointers.length, Tt = De.changedPointers.length, Vt = me & He && nt - Tt === 0, Pn = me & (Ze | St) && nt - Tt === 0;
      De.isFirst = !!Vt, De.isFinal = !!Pn, Vt && (ae.session = {}), De.eventType = me, Sn(ae, De), ae.emit("hammer.input", De), ae.recognize(De), ae.session.prevInput = De;
    }
    function Sn(ae, me) {
      var De = ae.session, nt = me.pointers, Tt = nt.length;
      De.firstInput || (De.firstInput = Un(me)), Tt > 1 && !De.firstMultiple ? De.firstMultiple = Un(me) : Tt === 1 && (De.firstMultiple = !1);
      var Vt = De.firstInput, Pn = De.firstMultiple, Br = Pn ? Pn.center : Vt.center, Rr = me.center = gt(nt);
      me.timeStamp = w(), me.deltaTime = me.timeStamp - Vt.timeStamp, me.angle = _r(Br, Rr), me.distance = Ot(Br, Rr), vn(De, me), me.offsetDirection = xn(me.deltaX, me.deltaY);
      var ui = un(me.deltaTime, me.deltaX, me.deltaY);
      me.overallVelocityX = ui.x, me.overallVelocityY = ui.y, me.overallVelocity = b(ui.x) > b(ui.y) ? ui.x : ui.y, me.scale = Pn ? bn(Pn.pointers, nt) : 1, me.rotation = Pn ? mt(Pn.pointers, nt) : 0, me.maxPointers = De.prevInput ? me.pointers.length > De.prevInput.maxPointers ? me.pointers.length : De.prevInput.maxPointers : me.pointers.length, On(De, me);
      var nr = ae.element;
      _e(me.srcEvent.target, nr) && (nr = me.srcEvent.target), me.target = nr;
    }
    function vn(ae, me) {
      var De = me.center, nt = ae.offsetDelta || {}, Tt = ae.prevDelta || {}, Vt = ae.prevInput || {};
      (me.eventType === He || Vt.eventType === Ze) && (Tt = ae.prevDelta = {
        x: Vt.deltaX || 0,
        y: Vt.deltaY || 0
      }, nt = ae.offsetDelta = {
        x: De.x,
        y: De.y
      }), me.deltaX = Tt.x + (De.x - nt.x), me.deltaY = Tt.y + (De.y - nt.y);
    }
    function On(ae, me) {
      var De = ae.lastInterval || me, nt = me.timeStamp - De.timeStamp, Tt, Vt, Pn, Br;
      if (me.eventType != St && (nt > qe || De.velocity === i)) {
        var Rr = me.deltaX - De.deltaX, ui = me.deltaY - De.deltaY, nr = un(nt, Rr, ui);
        Vt = nr.x, Pn = nr.y, Tt = b(nr.x) > b(nr.y) ? nr.x : nr.y, Br = xn(Rr, ui), ae.lastInterval = me;
      } else
        Tt = De.velocity, Vt = De.velocityX, Pn = De.velocityY, Br = De.direction;
      me.velocity = Tt, me.velocityX = Vt, me.velocityY = Pn, me.direction = Br;
    }
    function Un(ae) {
      for (var me = [], De = 0; De < ae.pointers.length; )
        me[De] = {
          clientX: _(ae.pointers[De].clientX),
          clientY: _(ae.pointers[De].clientY)
        }, De++;
      return {
        timeStamp: w(),
        pointers: me,
        center: gt(me),
        deltaX: ae.deltaX,
        deltaY: ae.deltaY
      };
    }
    function gt(ae) {
      var me = ae.length;
      if (me === 1)
        return {
          x: _(ae[0].clientX),
          y: _(ae[0].clientY)
        };
      for (var De = 0, nt = 0, Tt = 0; Tt < me; )
        De += ae[Tt].clientX, nt += ae[Tt].clientY, Tt++;
      return {
        x: _(De / me),
        y: _(nt / me)
      };
    }
    function un(ae, me, De) {
      return {
        x: me / ae || 0,
        y: De / ae || 0
      };
    }
    function xn(ae, me) {
      return ae === me ? Lt : b(ae) >= b(me) ? ae < 0 ? Dt : Nt : me < 0 ? an : at;
    }
    function Ot(ae, me, De) {
      De || (De = dt);
      var nt = me[De[0]] - ae[De[0]], Tt = me[De[1]] - ae[De[1]];
      return Math.sqrt(nt * nt + Tt * Tt);
    }
    function _r(ae, me, De) {
      De || (De = dt);
      var nt = me[De[0]] - ae[De[0]], Tt = me[De[1]] - ae[De[1]];
      return Math.atan2(Tt, nt) * 180 / Math.PI;
    }
    function mt(ae, me) {
      return _r(me[1], me[0], Et) + _r(ae[1], ae[0], Et);
    }
    function bn(ae, me) {
      return Ot(me[0], me[1], Et) / Ot(ae[0], ae[1], Et);
    }
    var jt = {
      mousedown: He,
      mousemove: Ye,
      mouseup: Ze
    }, qn = "mousedown", Jr = "mousemove mouseup";
    function zt() {
      this.evEl = qn, this.evWin = Jr, this.pressed = !1, Bt.apply(this, arguments);
    }
    $(zt, Bt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(me) {
        var De = jt[me.type];
        De & He && me.button === 0 && (this.pressed = !0), De & Ye && me.which !== 1 && (De = Ze), this.pressed && (De & Ze && (this.pressed = !1), this.callback(this.manager, De, {
          pointers: [me],
          changedPointers: [me],
          pointerType: Ce,
          srcEvent: me
        }));
      }
    });
    var yi = {
      pointerdown: He,
      pointermove: Ye,
      pointerup: Ze,
      pointercancel: St,
      pointerout: St
    }, rr = {
      2: re,
      3: Ae,
      4: Ce,
      5: Ue
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, ti = "pointerdown", ni = "pointermove pointerup pointercancel";
    e.MSPointerEvent && !e.PointerEvent && (ti = "MSPointerDown", ni = "MSPointerMove MSPointerUp MSPointerCancel");
    function be() {
      this.evEl = ti, this.evWin = ni, Bt.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    $(be, Bt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(me) {
        var De = this.store, nt = !1, Tt = me.type.toLowerCase().replace("ms", ""), Vt = yi[Tt], Pn = rr[me.pointerType] || me.pointerType, Br = Pn == re, Rr = oe(De, me.pointerId, "pointerId");
        Vt & He && (me.button === 0 || Br) ? Rr < 0 && (De.push(me), Rr = De.length - 1) : Vt & (Ze | St) && (nt = !0), !(Rr < 0) && (De[Rr] = me, this.callback(this.manager, Vt, {
          pointers: De,
          changedPointers: [me],
          pointerType: Pn,
          srcEvent: me
        }), nt && De.splice(Rr, 1));
      }
    });
    var J = {
      touchstart: He,
      touchmove: Ye,
      touchend: Ze,
      touchcancel: St
    }, K = "touchstart", ce = "touchstart touchmove touchend touchcancel";
    function ye() {
      this.evTarget = K, this.evWin = ce, this.started = !1, Bt.apply(this, arguments);
    }
    $(ye, Bt, {
      handler: function(me) {
        var De = J[me.type];
        if (De === He && (this.started = !0), !!this.started) {
          var nt = Fe.call(this, me, De);
          De & (Ze | St) && nt[0].length - nt[1].length === 0 && (this.started = !1), this.callback(this.manager, De, {
            pointers: nt[0],
            changedPointers: nt[1],
            pointerType: re,
            srcEvent: me
          });
        }
      }
    });
    function Fe(ae, me) {
      var De = pe(ae.touches), nt = pe(ae.changedTouches);
      return me & (Ze | St) && (De = Te(De.concat(nt), "identifier")), [De, nt];
    }
    var je = {
      touchstart: He,
      touchmove: Ye,
      touchend: Ze,
      touchcancel: St
    }, Oe = "touchstart touchmove touchend touchcancel";
    function Ie() {
      this.evTarget = Oe, this.targetIds = {}, Bt.apply(this, arguments);
    }
    $(Ie, Bt, {
      handler: function(me) {
        var De = je[me.type], nt = tt.call(this, me, De);
        nt && this.callback(this.manager, De, {
          pointers: nt[0],
          changedPointers: nt[1],
          pointerType: re,
          srcEvent: me
        });
      }
    });
    function tt(ae, me) {
      var De = pe(ae.touches), nt = this.targetIds;
      if (me & (He | Ye) && De.length === 1)
        return nt[De[0].identifier] = !0, [De, De];
      var Tt, Vt, Pn = pe(ae.changedTouches), Br = [], Rr = this.target;
      if (Vt = De.filter(function(ui) {
        return _e(ui.target, Rr);
      }), me === He)
        for (Tt = 0; Tt < Vt.length; )
          nt[Vt[Tt].identifier] = !0, Tt++;
      for (Tt = 0; Tt < Pn.length; )
        nt[Pn[Tt].identifier] && Br.push(Pn[Tt]), me & (Ze | St) && delete nt[Pn[Tt].identifier], Tt++;
      if (Br.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          Te(Vt.concat(Br), "identifier"),
          Br
        ];
    }
    var ut = 2500, We = 25;
    function vt() {
      Bt.apply(this, arguments);
      var ae = ie(this.handler, this);
      this.touch = new Ie(this.manager, ae), this.mouse = new zt(this.manager, ae), this.primaryTouch = null, this.lastTouches = [];
    }
    $(vt, Bt, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(me, De, nt) {
        var Tt = nt.pointerType == re, Vt = nt.pointerType == Ce;
        if (!(Vt && nt.sourceCapabilities && nt.sourceCapabilities.firesTouchEvents)) {
          if (Tt)
            Xt.call(this, De, nt);
          else if (Vt && Mn.call(this, nt))
            return;
          this.callback(me, De, nt);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function Xt(ae, me) {
      ae & He ? (this.primaryTouch = me.changedPointers[0].identifier, Kt.call(this, me)) : ae & (Ze | St) && Kt.call(this, me);
    }
    function Kt(ae) {
      var me = ae.changedPointers[0];
      if (me.identifier === this.primaryTouch) {
        var De = {
          x: me.clientX,
          y: me.clientY
        };
        this.lastTouches.push(De);
        var nt = this.lastTouches, Tt = function() {
          var Vt = nt.indexOf(De);
          Vt > -1 && nt.splice(Vt, 1);
        };
        setTimeout(Tt, ut);
      }
    }
    function Mn(ae) {
      for (var me = ae.srcEvent.clientX, De = ae.srcEvent.clientY, nt = 0; nt < this.lastTouches.length; nt++) {
        var Tt = this.lastTouches[nt], Vt = Math.abs(me - Tt.x), Pn = Math.abs(De - Tt.y);
        if (Vt <= We && Pn <= We)
          return !0;
      }
      return !1;
    }
    var en = xe(c.style, "touchAction"), In = en !== i, wn = "compute", ir = "auto", Wn = "manipulation", hn = "none", Fn = "pan-x", er = "pan-y", fr = so();
    function Sr(ae, me) {
      this.manager = ae, this.set(me);
    }
    Sr.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(ae) {
        ae == wn && (ae = this.compute()), In && this.manager.element.style && fr[ae] && (this.manager.element.style[en] = ae), this.actions = ae.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var ae = [];
        return P(this.manager.recognizers, function(me) {
          ge(me.options.enable, [me]) && (ae = ae.concat(me.getTouchAction()));
        }), Yr(ae.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(ae) {
        var me = ae.srcEvent, De = ae.offsetDirection;
        if (this.manager.session.prevented) {
          me.preventDefault();
          return;
        }
        var nt = this.actions, Tt = Ge(nt, hn) && !fr[hn], Vt = Ge(nt, er) && !fr[er], Pn = Ge(nt, Fn) && !fr[Fn];
        if (Tt) {
          var Br = ae.pointers.length === 1, Rr = ae.distance < 2, ui = ae.deltaTime < 250;
          if (Br && Rr && ui)
            return;
        }
        if (!(Pn && Vt) && (Tt || Vt && De & ne || Pn && De & pn))
          return this.preventSrc(me);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(ae) {
        this.manager.session.prevented = !0, ae.preventDefault();
      }
    };
    function Yr(ae) {
      if (Ge(ae, hn))
        return hn;
      var me = Ge(ae, Fn), De = Ge(ae, er);
      return me && De ? hn : me || De ? me ? Fn : er : Ge(ae, Wn) ? Wn : ir;
    }
    function so() {
      if (!In)
        return !1;
      var ae = {}, me = e.CSS && e.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(De) {
        ae[De] = me ? e.CSS.supports("touch-action", De) : !0;
      }), ae;
    }
    var Jn = 1, bi = 2, Xi = 4, Pr = 8, Lr = Pr, oo = 16, Mr = 32;
    function Er(ae) {
      this.options = U({}, this.defaults, ae || {}), this.id = rt(), this.manager = null, this.options.enable = Se(this.options.enable, !0), this.state = Jn, this.simultaneous = {}, this.requireFail = [];
    }
    Er.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(ae) {
        return U(this.options, ae), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(ae) {
        if (I(ae, "recognizeWith", this))
          return this;
        var me = this.simultaneous;
        return ae = yr(ae, this), me[ae.id] || (me[ae.id] = ae, ae.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(ae) {
        return I(ae, "dropRecognizeWith", this) ? this : (ae = yr(ae, this), delete this.simultaneous[ae.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(ae) {
        if (I(ae, "requireFailure", this))
          return this;
        var me = this.requireFail;
        return ae = yr(ae, this), oe(me, ae) === -1 && (me.push(ae), ae.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(ae) {
        if (I(ae, "dropRequireFailure", this))
          return this;
        ae = yr(ae, this);
        var me = oe(this.requireFail, ae);
        return me > -1 && this.requireFail.splice(me, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(ae) {
        return !!this.simultaneous[ae.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(ae) {
        var me = this, De = this.state;
        function nt(Tt) {
          me.manager.emit(Tt, ae);
        }
        De < Pr && nt(me.options.event + ao(De)), nt(me.options.event), ae.additionalEvent && nt(ae.additionalEvent), De >= Pr && nt(me.options.event + ao(De));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(ae) {
        if (this.canEmit())
          return this.emit(ae);
        this.state = Mr;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var ae = 0; ae < this.requireFail.length; ) {
          if (!(this.requireFail[ae].state & (Mr | Jn)))
            return !1;
          ae++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(ae) {
        var me = U({}, ae);
        if (!ge(this.options.enable, [this, me])) {
          this.reset(), this.state = Mr;
          return;
        }
        this.state & (Lr | oo | Mr) && (this.state = Jn), this.state = this.process(me), this.state & (bi | Xi | Pr | oo) && this.tryEmit(me);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(ae) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function ao(ae) {
      return ae & oo ? "cancel" : ae & Pr ? "end" : ae & Xi ? "move" : ae & bi ? "start" : "";
    }
    function $i(ae) {
      return ae == at ? "down" : ae == an ? "up" : ae == Dt ? "left" : ae == Nt ? "right" : "";
    }
    function yr(ae, me) {
      var De = me.manager;
      return De ? De.get(ae) : ae;
    }
    function Yn() {
      Er.apply(this, arguments);
    }
    $(Yn, Er, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(ae) {
        var me = this.options.pointers;
        return me === 0 || ae.pointers.length === me;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(ae) {
        var me = this.state, De = ae.eventType, nt = me & (bi | Xi), Tt = this.attrTest(ae);
        return nt && (De & St || !Tt) ? me | oo : nt || Tt ? De & Ze ? me | Pr : me & bi ? me | Xi : bi : Mr;
      }
    });
    function fi() {
      Yn.apply(this, arguments), this.pX = null, this.pY = null;
    }
    $(fi, Yn, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: Qt
      },
      getTouchAction: function() {
        var ae = this.options.direction, me = [];
        return ae & ne && me.push(er), ae & pn && me.push(Fn), me;
      },
      directionTest: function(ae) {
        var me = this.options, De = !0, nt = ae.distance, Tt = ae.direction, Vt = ae.deltaX, Pn = ae.deltaY;
        return Tt & me.direction || (me.direction & ne ? (Tt = Vt === 0 ? Lt : Vt < 0 ? Dt : Nt, De = Vt != this.pX, nt = Math.abs(ae.deltaX)) : (Tt = Pn === 0 ? Lt : Pn < 0 ? an : at, De = Pn != this.pY, nt = Math.abs(ae.deltaY))), ae.direction = Tt, De && nt > me.threshold && Tt & me.direction;
      },
      attrTest: function(ae) {
        return Yn.prototype.attrTest.call(this, ae) && (this.state & bi || !(this.state & bi) && this.directionTest(ae));
      },
      emit: function(ae) {
        this.pX = ae.deltaX, this.pY = ae.deltaY;
        var me = $i(ae.direction);
        me && (ae.additionalEvent = this.options.event + me), this._super.emit.call(this, ae);
      }
    });
    function pr() {
      Yn.apply(this, arguments);
    }
    $(pr, Yn, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [hn];
      },
      attrTest: function(ae) {
        return this._super.attrTest.call(this, ae) && (Math.abs(ae.scale - 1) > this.options.threshold || this.state & bi);
      },
      emit: function(ae) {
        if (ae.scale !== 1) {
          var me = ae.scale < 1 ? "in" : "out";
          ae.additionalEvent = this.options.event + me;
        }
        this._super.emit.call(this, ae);
      }
    });
    function lo() {
      Er.apply(this, arguments), this._timer = null, this._input = null;
    }
    $(lo, Er, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [ir];
      },
      process: function(ae) {
        var me = this.options, De = ae.pointers.length === me.pointers, nt = ae.distance < me.threshold, Tt = ae.deltaTime > me.time;
        if (this._input = ae, !nt || !De || ae.eventType & (Ze | St) && !Tt)
          this.reset();
        else if (ae.eventType & He)
          this.reset(), this._timer = T(function() {
            this.state = Lr, this.tryEmit();
          }, me.time, this);
        else if (ae.eventType & Ze)
          return Lr;
        return Mr;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(ae) {
        this.state === Lr && (ae && ae.eventType & Ze ? this.manager.emit(this.options.event + "up", ae) : (this._input.timeStamp = w(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function pi() {
      Yn.apply(this, arguments);
    }
    $(pi, Yn, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [hn];
      },
      attrTest: function(ae) {
        return this._super.attrTest.call(this, ae) && (Math.abs(ae.rotation) > this.options.threshold || this.state & bi);
      }
    });
    function Zo() {
      Yn.apply(this, arguments);
    }
    $(Zo, Yn, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: ne | pn,
        pointers: 1
      },
      getTouchAction: function() {
        return fi.prototype.getTouchAction.call(this);
      },
      attrTest: function(ae) {
        var me = this.options.direction, De;
        return me & (ne | pn) ? De = ae.overallVelocity : me & ne ? De = ae.overallVelocityX : me & pn && (De = ae.overallVelocityY), this._super.attrTest.call(this, ae) && me & ae.offsetDirection && ae.distance > this.options.threshold && ae.maxPointers == this.options.pointers && b(De) > this.options.velocity && ae.eventType & Ze;
      },
      emit: function(ae) {
        var me = $i(ae.offsetDirection);
        me && this.manager.emit(this.options.event + me, ae), this.manager.emit(this.options.event, ae);
      }
    });
    function Tr() {
      Er.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    $(Tr, Er, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [Wn];
      },
      process: function(ae) {
        var me = this.options, De = ae.pointers.length === me.pointers, nt = ae.distance < me.threshold, Tt = ae.deltaTime < me.time;
        if (this.reset(), ae.eventType & He && this.count === 0)
          return this.failTimeout();
        if (nt && Tt && De) {
          if (ae.eventType != Ze)
            return this.failTimeout();
          var Vt = this.pTime ? ae.timeStamp - this.pTime < me.interval : !0, Pn = !this.pCenter || Ot(this.pCenter, ae.center) < me.posThreshold;
          this.pTime = ae.timeStamp, this.pCenter = ae.center, !Pn || !Vt ? this.count = 1 : this.count += 1, this._input = ae;
          var Br = this.count % me.taps;
          if (Br === 0)
            return this.hasRequireFailures() ? (this._timer = T(function() {
              this.state = Lr, this.tryEmit();
            }, me.interval, this), bi) : Lr;
        }
        return Mr;
      },
      failTimeout: function() {
        return this._timer = T(function() {
          this.state = Mr;
        }, this.options.interval, this), Mr;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == Lr && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function Zi(ae, me) {
      return me = me || {}, me.recognizers = Se(me.recognizers, Zi.defaults.preset), new Ji(ae, me);
    }
    Zi.VERSION = "2.0.7", Zi.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: wn,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [pi, {
          enable: !1
        }],
        [pr, {
          enable: !1
        }, ["rotate"]],
        [Zo, {
          direction: ne
        }],
        [fi, {
          direction: ne
        }, ["swipe"]],
        [Tr],
        [Tr, {
          event: "doubletap",
          taps: 2
        }, ["tap"]],
        [lo]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var gi = 1, as = 2;
    function Ji(ae, me) {
      this.options = U({}, Zi.defaults, me || {}), this.options.inputTarget = this.options.inputTarget || ae, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = ae, this.input = Ft(this), this.touchAction = new Sr(this, this.options.touchAction), Xn(this, !0), P(this.options.recognizers, function(De) {
        var nt = this.add(new De[0](De[1]));
        De[2] && nt.recognizeWith(De[2]), De[3] && nt.requireFailure(De[3]);
      }, this);
    }
    Ji.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(ae) {
        return U(this.options, ae), ae.touchAction && this.touchAction.update(), ae.inputTarget && (this.input.destroy(), this.input.target = ae.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(ae) {
        this.session.stopped = ae ? as : gi;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(ae) {
        var me = this.session;
        if (!me.stopped) {
          this.touchAction.preventDefaults(ae);
          var De, nt = this.recognizers, Tt = me.curRecognizer;
          (!Tt || Tt && Tt.state & Lr) && (Tt = me.curRecognizer = null);
          for (var Vt = 0; Vt < nt.length; )
            De = nt[Vt], me.stopped !== as && // 1
            (!Tt || De == Tt || // 2
            De.canRecognizeWith(Tt)) ? De.recognize(ae) : De.reset(), !Tt && De.state & (bi | Xi | Pr) && (Tt = me.curRecognizer = De), Vt++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(ae) {
        if (ae instanceof Er)
          return ae;
        for (var me = this.recognizers, De = 0; De < me.length; De++)
          if (me[De].options.event == ae)
            return me[De];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(ae) {
        if (I(ae, "add", this))
          return this;
        var me = this.get(ae.options.event);
        return me && this.remove(me), this.recognizers.push(ae), ae.manager = this, this.touchAction.update(), ae;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(ae) {
        if (I(ae, "remove", this))
          return this;
        if (ae = this.get(ae), ae) {
          var me = this.recognizers, De = oe(me, ae);
          De !== -1 && (me.splice(De, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(ae, me) {
        if (ae !== i && me !== i) {
          var De = this.handlers;
          return P(ke(ae), function(nt) {
            De[nt] = De[nt] || [], De[nt].push(me);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(ae, me) {
        if (ae !== i) {
          var De = this.handlers;
          return P(ke(ae), function(nt) {
            me ? De[nt] && De[nt].splice(oe(De[nt], me), 1) : delete De[nt];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(ae, me) {
        this.options.domEvents && Sa(ae, me);
        var De = this.handlers[ae] && this.handlers[ae].slice();
        if (!(!De || !De.length)) {
          me.type = ae, me.preventDefault = function() {
            me.srcEvent.preventDefault();
          };
          for (var nt = 0; nt < De.length; )
            De[nt](me), nt++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && Xn(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function Xn(ae, me) {
      var De = ae.element;
      if (De.style) {
        var nt;
        P(ae.options.cssProps, function(Tt, Vt) {
          nt = xe(De.style, Vt), me ? (ae.oldCssProps[nt] = De.style[nt], De.style[nt] = Tt) : De.style[nt] = ae.oldCssProps[nt] || "";
        }), me || (ae.oldCssProps = {});
      }
    }
    function Sa(ae, me) {
      var De = t.createEvent("Event");
      De.initEvent(ae, !0, !0), De.gesture = me, me.target.dispatchEvent(De);
    }
    U(Zi, {
      INPUT_START: He,
      INPUT_MOVE: Ye,
      INPUT_END: Ze,
      INPUT_CANCEL: St,
      STATE_POSSIBLE: Jn,
      STATE_BEGAN: bi,
      STATE_CHANGED: Xi,
      STATE_ENDED: Pr,
      STATE_RECOGNIZED: Lr,
      STATE_CANCELLED: oo,
      STATE_FAILED: Mr,
      DIRECTION_NONE: Lt,
      DIRECTION_LEFT: Dt,
      DIRECTION_RIGHT: Nt,
      DIRECTION_UP: an,
      DIRECTION_DOWN: at,
      DIRECTION_HORIZONTAL: ne,
      DIRECTION_VERTICAL: pn,
      DIRECTION_ALL: Qt,
      Manager: Ji,
      Input: Bt,
      TouchAction: Sr,
      TouchInput: Ie,
      MouseInput: zt,
      PointerEventInput: be,
      TouchMouseInput: vt,
      SingleTouchInput: ye,
      Recognizer: Er,
      AttrRecognizer: Yn,
      Tap: Tr,
      Pan: fi,
      Swipe: Zo,
      Pinch: pr,
      Rotate: pi,
      Press: lo,
      on: Re,
      off: Le,
      each: P,
      merge: H,
      extend: G,
      assign: U,
      inherit: $,
      bindFn: ie,
      prefixed: xe
    });
    var Ya = typeof e < "u" ? e : typeof self < "u" ? self : {};
    Ya.Hammer = Zi, n.exports ? n.exports = Zi : e[r] = Zi;
  })(window, document, "Hammer");
})(aE);
var Gp = aE.exports;
const ck = /* @__PURE__ */ Ip(Gp), uc = /* @__PURE__ */ uI({
  __proto__: null,
  default: ck
}, [Gp]), lE = 1, cE = 2, Py = 4, uk = {
  mousedown: lE,
  mousemove: cE,
  mouseup: Py
};
function hk(n, e) {
  for (let t = 0; t < n.length; t++)
    if (e(n[t]))
      return !0;
  return !1;
}
function dk(n) {
  const e = n.prototype.handler;
  n.prototype.handler = function(r) {
    const i = this.store;
    r.button > 0 && r.type === "pointerdown" && (hk(i, (o) => o.pointerId === r.pointerId) || i.push(r)), e.call(this, r);
  };
}
function fk(n) {
  n.prototype.handler = function(t) {
    let r = uk[t.type];
    r & lE && t.button >= 0 && (this.pressed = !0), r & cE && t.which === 0 && (r = Py), this.pressed && (r & Py && (this.pressed = !1), this.callback(this.manager, r, {
      pointers: [t],
      changedPointers: [t],
      pointerType: "mouse",
      srcEvent: t
    }));
  };
}
dk(Gp.PointerEventInput);
fk(Gp.MouseInput);
const pk = Gp.Manager;
class Gm {
  constructor(e, t, r) {
    this.element = e, this.callback = t, this.options = {
      enable: !0,
      ...r
    };
  }
}
const gk = uc ? [
  [uc.Pan, {
    event: "tripan",
    pointers: 3,
    threshold: 0,
    enable: !1
  }],
  [uc.Rotate, {
    enable: !1
  }],
  [uc.Pinch, {
    enable: !1
  }],
  [uc.Swipe, {
    enable: !1
  }],
  [uc.Pan, {
    threshold: 0,
    enable: !1
  }],
  [uc.Press, {
    enable: !1
  }],
  [uc.Tap, {
    event: "doubletap",
    taps: 2,
    enable: !1
  }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [uc.Tap, {
    event: "anytap",
    enable: !1
  }],
  [uc.Tap, {
    enable: !1
  }]
] : null, Qx = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
}, mk = {
  doubletap: ["tap"]
}, _k = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
}, sb = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
}, yk = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
}, ew = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
}, bk = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", Md = typeof window < "u" ? window : global;
let Ly = !1;
try {
  const n = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      return Ly = !0, !0;
    }
  };
  Md.addEventListener("test", null, n), Md.removeEventListener("test", null);
} catch {
  Ly = !1;
}
const vk = bk.indexOf("firefox") !== -1, {
  WHEEL_EVENTS: xk
} = sb, tw = "wheel", nw = 4.000244140625, wk = 40, Ak = 0.25;
class Sk extends Gm {
  constructor(e, t, r) {
    super(e, t, r), this.handleEvent = (i) => {
      if (!this.options.enable)
        return;
      let o = i.deltaY;
      Md.WheelEvent && (vk && i.deltaMode === Md.WheelEvent.DOM_DELTA_PIXEL && (o /= Md.devicePixelRatio), i.deltaMode === Md.WheelEvent.DOM_DELTA_LINE && (o *= wk)), o !== 0 && o % nw === 0 && (o = Math.floor(o / nw)), i.shiftKey && o && (o = o * Ak), this.callback({
        type: tw,
        center: {
          x: i.clientX,
          y: i.clientY
        },
        delta: -o,
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, this.events = (this.options.events || []).concat(xk), this.events.forEach((i) => e.addEventListener(i, this.handleEvent, Ly ? {
      passive: !1
    } : !1));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === tw && (this.options.enable = t);
  }
}
const {
  MOUSE_EVENTS: Ek
} = sb, rw = "pointermove", iw = "pointerover", sw = "pointerout", ow = "pointerenter", aw = "pointerleave";
class Tk extends Gm {
  constructor(e, t, r) {
    super(e, t, r), this.handleEvent = (o) => {
      this.handleOverEvent(o), this.handleOutEvent(o), this.handleEnterEvent(o), this.handleLeaveEvent(o), this.handleMoveEvent(o);
    }, this.pressed = !1;
    const {
      enable: i
    } = this.options;
    this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, this.events = (this.options.events || []).concat(Ek), this.events.forEach((o) => e.addEventListener(o, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === rw && (this.enableMoveEvent = t), e === iw && (this.enableOverEvent = t), e === sw && (this.enableOutEvent = t), e === ow && (this.enableEnterEvent = t), e === aw && (this.enableLeaveEvent = t);
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit(iw, e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit(sw, e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit(ow, e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit(aw, e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.which === 0 && (this.pressed = !1), this.pressed || this._emit(rw, e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
}
const {
  KEY_EVENTS: Ck
} = sb, lw = "keydown", cw = "keyup";
class Ik extends Gm {
  constructor(e, t, r) {
    super(e, t, r), this.handleEvent = (i) => {
      const o = i.target || i.srcElement;
      o.tagName === "INPUT" && o.type === "text" || o.tagName === "TEXTAREA" || (this.enableDownEvent && i.type === "keydown" && this.callback({
        type: lw,
        srcEvent: i,
        key: i.key,
        target: i.target
      }), this.enableUpEvent && i.type === "keyup" && this.callback({
        type: cw,
        srcEvent: i,
        key: i.key,
        target: i.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(Ck), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach((i) => e.addEventListener(i, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === lw && (this.enableDownEvent = t), e === cw && (this.enableUpEvent = t);
  }
}
const uw = "contextmenu";
class Pk extends Gm {
  constructor(e, t, r) {
    super(e, t, r), this.handleEvent = (i) => {
      this.options.enable && this.callback({
        type: uw,
        center: {
          x: i.clientX,
          y: i.clientY
        },
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === uw && (this.options.enable = t);
  }
}
const My = 1, Em = 2, By = 4, Lk = {
  pointerdown: My,
  pointermove: Em,
  pointerup: By,
  mousedown: My,
  mousemove: Em,
  mouseup: By
}, Mk = 1, Bk = 2, Rk = 3, Ok = 0, Dk = 1, Fk = 2, kk = 1, Nk = 2, zk = 4;
function Uk(n) {
  const e = Lk[n.srcEvent.type];
  if (!e)
    return null;
  const {
    buttons: t,
    button: r,
    which: i
  } = n.srcEvent;
  let o = !1, c = !1, l = !1;
  return /* button is up, need to find out which one was pressed before */ e === By || // moving but does not support `buttons` API
  e === Em && !Number.isFinite(t) ? (o = i === Mk, c = i === Bk, l = i === Rk) : e === Em ? (o = !!(t & kk), c = !!(t & zk), l = !!(t & Nk)) : e === My && (o = r === Ok, c = r === Dk, l = r === Fk), {
    leftButton: o,
    middleButton: c,
    rightButton: l
  };
}
function jk(n, e) {
  const t = n.center;
  if (!t)
    return null;
  const r = e.getBoundingClientRect(), i = r.width / e.offsetWidth || 1, o = r.height / e.offsetHeight || 1, c = {
    x: (t.x - r.left - e.clientLeft) / i,
    y: (t.y - r.top - e.clientTop) / o
  };
  return {
    center: t,
    offsetCenter: c
  };
}
const y_ = {
  srcElement: "root",
  priority: 0
};
class Gk {
  constructor(e) {
    this.handleEvent = (t) => {
      if (this.isEmpty())
        return;
      const r = this._normalizeEvent(t);
      let i = t.srcEvent.target;
      for (; i && i !== r.rootElement; ) {
        if (this._emit(r, i), r.handled)
          return;
        i = i.parentNode;
      }
      this._emit(r, "root");
    }, this.eventManager = e, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    const {
      handlers: c,
      handlersByElement: l
    } = this;
    let _ = y_;
    typeof r == "string" || r && r.addEventListener ? _ = {
      ...y_,
      srcElement: r
    } : r && (_ = {
      ...y_,
      ...r
    });
    let b = l.get(_.srcElement);
    b || (b = [], l.set(_.srcElement, b));
    const w = {
      type: e,
      handler: t,
      srcElement: _.srcElement,
      priority: _.priority
    };
    i && (w.once = !0), o && (w.passive = !0), c.push(w), this._active = this._active || !w.passive;
    let T = b.length - 1;
    for (; T >= 0 && !(b[T].priority >= w.priority); )
      T--;
    b.splice(T + 1, 0, w);
  }
  remove(e, t) {
    const {
      handlers: r,
      handlersByElement: i
    } = this;
    for (let o = r.length - 1; o >= 0; o--) {
      const c = r[o];
      if (c.type === e && c.handler === t) {
        r.splice(o, 1);
        const l = i.get(c.srcElement);
        l.splice(l.indexOf(c), 1), l.length === 0 && i.delete(c.srcElement);
      }
    }
    this._active = r.some((o) => !o.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const r = this.handlersByElement.get(t);
    if (r) {
      let i = !1;
      const o = () => {
        e.handled = !0;
      }, c = () => {
        e.handled = !0, i = !0;
      }, l = [];
      for (let _ = 0; _ < r.length; _++) {
        const {
          type: b,
          handler: w,
          once: T
        } = r[_];
        if (w({
          ...e,
          // @ts-ignore
          type: b,
          stopPropagation: o,
          stopImmediatePropagation: c
        }), T && l.push(r[_]), i)
          break;
      }
      for (let _ = 0; _ < l.length; _++) {
        const {
          type: b,
          handler: w
        } = l[_];
        this.remove(b, w);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ...Uk(e),
      ...jk(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
}
const Vk = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: pk,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class qk {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0;
    this._onBasicInput = (i) => {
      const {
        srcEvent: o
      } = i, c = _k[o.type];
      c && this.manager.emit(c, i);
    }, this._onOtherEvent = (i) => {
      this.manager.emit(i.type, i);
    }, this.options = {
      ...Vk,
      ...t
    }, this.events = /* @__PURE__ */ new Map(), this.setElement(e);
    const {
      events: r
    } = this.options;
    r && this.on(r);
  }
  getElement() {
    return this.element;
  }
  setElement(e) {
    if (this.element && this.destroy(), this.element = e, !e)
      return;
    const {
      options: t
    } = this, r = t.Manager;
    this.manager = new r(e, {
      touchAction: t.touchAction,
      recognizers: t.recognizers || gk
    }).on("hammer.input", this._onBasicInput), t.recognizers || Object.keys(Qx).forEach((i) => {
      const o = this.manager.get(i);
      o && Qx[i].forEach((c) => {
        o.recognizeWith(c);
      });
    });
    for (const i in t.recognizerOptions) {
      const o = this.manager.get(i);
      if (o) {
        const c = t.recognizerOptions[i];
        delete c.enable, o.set(c);
      }
    }
    this.wheelInput = new Sk(e, this._onOtherEvent, {
      enable: !1
    }), this.moveInput = new Tk(e, this._onOtherEvent, {
      enable: !1
    }), this.keyInput = new Ik(e, this._onOtherEvent, {
      enable: !1,
      tabIndex: t.tabIndex
    }), this.contextmenuInput = new Pk(e, this._onOtherEvent, {
      enable: !1
    });
    for (const [i, o] of this.events)
      o.isEmpty() || (this._toggleRecognizer(o.recognizerName, !0), this.manager.on(i, o.handleEvent));
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, r) {
    this._addEventHandler(e, t, r, !1);
  }
  once(e, t, r) {
    this._addEventHandler(e, t, r, !0);
  }
  watch(e, t, r) {
    this._addEventHandler(e, t, r, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    const {
      manager: r
    } = this;
    if (!r)
      return;
    const i = r.get(e);
    if (i && i.options.enable !== t) {
      i.set({
        enable: t
      });
      const o = mk[e];
      o && !this.options.recognizers && o.forEach((c) => {
        const l = r.get(c);
        t ? (l.requireFailure(e), i.dropRequireFailure(c)) : l.dropRequireFailure(e);
      });
    }
    this.wheelInput.enableEventType(e, t), this.moveInput.enableEventType(e, t), this.keyInput.enableEventType(e, t), this.contextmenuInput.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, r, i, o) {
    if (typeof e != "string") {
      r = t;
      for (const w in e)
        this._addEventHandler(w, e[w], r, i, o);
      return;
    }
    const {
      manager: c,
      events: l
    } = this, _ = ew[e] || e;
    let b = l.get(_);
    b || (b = new Gk(this), l.set(_, b), b.recognizerName = yk[_] || _, c && c.on(_, b.handleEvent)), b.add(e, t, r, i, o), b.isEmpty() || this._toggleRecognizer(b.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const c in e)
        this._removeEventHandler(c, e[c]);
      return;
    }
    const {
      events: r
    } = this, i = ew[e] || e, o = r.get(i);
    if (o && (o.remove(e, t), o.isEmpty())) {
      const {
        recognizerName: c
      } = o;
      let l = !1;
      for (const _ of r.values())
        if (_.recognizerName === c && !_.isEmpty()) {
          l = !0;
          break;
        }
      l || this._toggleRecognizer(c, !1);
    }
  }
}
function bh() {
}
const Hk = (n) => {
  let {
    isDragging: e
  } = n;
  return e ? "grabbing" : "grab";
}, uE = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  parameters: {},
  parent: null,
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  onWebGLInitialized: bh,
  onResize: bh,
  onViewStateChange: bh,
  onInteractionStateChange: bh,
  onBeforeRender: bh,
  onAfterRender: bh,
  onLoad: bh,
  onError: (n) => ur.error(n.message, n.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: Hk,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class ob {
  constructor(e) {
    V(this, "props", void 0), V(this, "width", 0), V(this, "height", 0), V(this, "userData", {}), V(this, "canvas", null), V(this, "viewManager", null), V(this, "layerManager", null), V(this, "effectManager", null), V(this, "deckRenderer", null), V(this, "deckPicker", null), V(this, "eventManager", null), V(this, "tooltip", null), V(this, "metrics", void 0), V(this, "animationLoop", void 0), V(this, "stats", void 0), V(this, "viewState", void 0), V(this, "cursorState", void 0), V(this, "_needsRedraw", void 0), V(this, "_pickRequest", void 0), V(this, "_lastPointerDownInfo", null), V(this, "_metricsCounter", void 0), V(this, "_onPointerMove", (t) => {
      const {
        _pickRequest: r
      } = this;
      if (t.type === "pointerleave")
        r.x = -1, r.y = -1, r.radius = 0;
      else {
        if (t.leftButton || t.rightButton)
          return;
        {
          const i = t.offsetCenter;
          if (!i)
            return;
          r.x = i.x, r.y = i.y, r.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = {
        x: r.x,
        y: r.y
      }), r.event = t;
    }), V(this, "_onEvent", (t) => {
      const r = H2[t.type], i = t.offsetCenter;
      if (!r || !i || !this.layerManager)
        return;
      const o = this.layerManager.getLayers(), c = this.deckPicker.getLastPickedObject({
        x: i.x,
        y: i.y,
        layers: o,
        viewports: this.getViewports(i)
      }, this._lastPointerDownInfo), {
        layer: l
      } = c, _ = l && (l[r.handler] || l.props[r.handler]), b = this.props[r.handler];
      let w = !1;
      _ && (w = _.call(l, c, t)), !w && b && b(c, t);
    }), V(this, "_onPointerDown", (t) => {
      const r = t.offsetCenter, i = this._pick("pickObject", "pickObject Time", {
        x: r.x,
        y: r.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = i.result[0] || i.emptyInfo;
    }), this.props = {
      ...uE,
      ...e
    }, e = this.props, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, e.viewState && e.initialViewState && ur.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), F5() === "IE" && ur.warn("IE 11 is not supported")(), this.viewState = e.initialViewState, e.gl || typeof document < "u" && (this.canvas = this._createCanvas(e)), this.animationLoop = this._createAnimationLoop(e), this.stats = new Bp({
      id: "deck.gl"
    }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this.setProps(e), e._typedArrayManagerProps && wp.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  finalize() {
    var e, t, r, i, o, c, l, _;
    if ((e = this.animationLoop) === null || e === void 0 || e.stop(), this.animationLoop = null, this._lastPointerDownInfo = null, (t = this.layerManager) === null || t === void 0 || t.finalize(), this.layerManager = null, (r = this.viewManager) === null || r === void 0 || r.finalize(), this.viewManager = null, (i = this.effectManager) === null || i === void 0 || i.finalize(), this.effectManager = null, (o = this.deckRenderer) === null || o === void 0 || o.finalize(), this.deckRenderer = null, (c = this.deckPicker) === null || c === void 0 || c.finalize(), this.deckPicker = null, (l = this.eventManager) === null || l === void 0 || l.destroy(), this.eventManager = null, (_ = this.tooltip) === null || _ === void 0 || _.remove(), this.tooltip = null, !this.props.canvas && !this.props.gl && this.canvas) {
      var b;
      (b = this.canvas.parentElement) === null || b === void 0 || b.removeChild(this.canvas), this.canvas = null;
    }
  }
  setProps(e) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && ur.removed("onLayerHover", "onHover")(), "onLayerClick" in e && ur.removed("onLayerClick", "onClick")(), e.initialViewState && !yc(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const t = Object.create(this.props);
    Object.assign(t, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), this.animationLoop.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t)), this.stats.get("setProps Time").timeEnd();
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const r = this.viewManager.needsRedraw(e), i = this.layerManager.needsRedraw(e), o = this.effectManager.needsRedraw(e), c = this.deckRenderer.needsRedraw(e);
    return t = t || r || i || o || c, t;
  }
  redraw(e) {
    if (!this.layerManager)
      return;
    let t = this.needsRedraw({
      clearRedrawFlags: !0
    });
    t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
  }
  get isInitialized() {
    return this.viewManager !== null;
  }
  getViews() {
    return Rs(this.viewManager), this.viewManager.views;
  }
  getViewports(e) {
    return Rs(this.viewManager), this.viewManager.getViewports(e);
  }
  getCanvas() {
    return this.canvas;
  }
  pickObject(e) {
    const t = this._pick("pickObject", "pickObject Time", e).result;
    return t.length ? t[0] : null;
  }
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  _addResources(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    for (const r in e)
      this.layerManager.resourceManager.add({
        resourceId: r,
        data: e[r],
        forceUpdate: t
      });
  }
  _removeResources(e) {
    for (const t of e)
      this.layerManager.resourceManager.remove(t);
  }
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _pick(e, t, r) {
    Rs(this.deckPicker);
    const {
      stats: i
    } = this;
    i.get("Pick Count").incrementCount(), i.get(t).timeStart();
    const o = this.deckPicker[e]({
      layers: this.layerManager.getLayers(r),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(r),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...r
    });
    return i.get(t).timeEnd(), o;
  }
  _createCanvas(e) {
    let t = e.canvas;
    return typeof t == "string" && (t = document.getElementById(t), Rs(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
  }
  _setCanvasSize(e) {
    if (!this.canvas)
      return;
    const {
      width: t,
      height: r
    } = e;
    if (t || t === 0) {
      const o = Number.isFinite(t) ? "".concat(t, "px") : t;
      this.canvas.style.width = o;
    }
    if (r || r === 0) {
      var i;
      const o = Number.isFinite(r) ? "".concat(r, "px") : r;
      this.canvas.style.position = ((i = e.style) === null || i === void 0 ? void 0 : i.position) || "absolute", this.canvas.style.height = o;
    }
  }
  _updateCanvasSize() {
    var e, t;
    const {
      canvas: r
    } = this;
    if (!r)
      return;
    const i = (e = r.clientWidth) !== null && e !== void 0 ? e : r.width, o = (t = r.clientHeight) !== null && t !== void 0 ? t : r.height;
    if (i !== this.width || o !== this.height) {
      var c, l;
      this.width = i, this.height = o, (c = this.viewManager) === null || c === void 0 || c.setProps({
        width: i,
        height: o
      }), (l = this.layerManager) === null || l === void 0 || l.activateViewport(this.getViewports()[0]), this.props.onResize({
        width: i,
        height: o
      });
    }
  }
  _createAnimationLoop(e) {
    const {
      width: t,
      height: r,
      gl: i,
      glOptions: o,
      debug: c,
      onError: l,
      onBeforeRender: _,
      onAfterRender: b,
      useDevicePixels: w
    } = e;
    return new mR({
      width: t,
      height: r,
      useDevicePixels: w,
      autoResizeDrawingBuffer: !i,
      autoResizeViewport: !1,
      gl: i,
      onCreateContext: (T) => tS({
        ...o,
        ...T,
        canvas: this.canvas,
        debug: c,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: (T) => this._setGLContext(T.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender: _,
      onAfterRender: b,
      onError: l
    });
  }
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  _getViews() {
    let e = this.props.views || [new ib({
      id: "default-view"
    })];
    return e = Array.isArray(e) ? e : [e], e.length && this.props.controller && (e[0].props.controller = this.props.controller), e;
  }
  _onContextLost() {
    const {
      onError: e
    } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  _pickAndCallback() {
    const {
      _pickRequest: e
    } = this;
    if (e.event) {
      const {
        result: r,
        emptyInfo: i
      } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = r.length > 0;
      let o = i, c = !1;
      for (const l of r) {
        var t;
        o = l, c = ((t = l.layer) === null || t === void 0 ? void 0 : t.onHover(l, e.event)) || c;
      }
      if (!c && this.props.onHover && this.props.onHover(o, e.event), this.props.getTooltip && this.tooltip) {
        const l = this.props.getTooltip(o);
        this.tooltip.setTooltip(l, o.x, o.y);
      }
      e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setGLContext(e) {
    if (this.layerManager)
      return;
    this.canvas || (this.canvas = e.canvas, R1(e, {
      enable: !0,
      copyState: !0
    })), this.tooltip = new lk(this.canvas), su(e, {
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onWebGLInitialized(e);
    const t = new qS();
    t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new qk(this.props.parent || e.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const i in H2)
      this.eventManager.on(i, this._onEvent);
    this.viewManager = new OF({
      timeline: t,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const r = this.viewManager.getViewports()[0];
    this.layerManager = new RF(e, {
      deck: this,
      stats: this.stats,
      viewport: r,
      timeline: t
    }), this.effectManager = new YF(), this.deckRenderer = new ek(e), this.deckPicker = new ok(e), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  _drawLayers(e, t) {
    const {
      gl: r
    } = this.layerManager.context;
    su(r, this.props.parameters), this.props.onBeforeRender({
      gl: r
    }), this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...t
    }), this.props.onAfterRender({
      gl: r
    });
  }
  _onRenderFrame(e) {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), ur.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.tooltip.isVisible && this.viewManager.needsRedraw() && this.tooltip.setTooltip(null), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  _onViewStateChange(e) {
    const t = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = {
      ...this.viewState,
      [e.viewId]: t
    }, this.props.viewState || this.viewManager && this.viewManager.setProps({
      viewState: this.viewState
    }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const {
      stats: e
    } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const t = this.animationLoop.stats;
    e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const {
      metrics: e,
      stats: t
    } = this;
    e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
    const r = Ch.get("Memory Usage");
    e.bufferMemory = r.get("Buffer Memory").count, e.textureMemory = r.get("Texture Memory").count, e.renderbufferMemory = r.get("Renderbuffer Memory").count, e.gpuMemory = r.get("GPU Memory").count;
  }
}
V(ob, "defaultProps", uE);
V(ob, "VERSION", wM);
class b_ {
  constructor(e, t) {
    V(this, "opts", void 0), V(this, "source", void 0), this.opts = t, this.source = e;
  }
  get value() {
    return this.source.value;
  }
  getValue() {
    const e = this.source.getBuffer(), t = this.getAccessor();
    if (e)
      return [e, t];
    const {
      value: r
    } = this.source, {
      size: i
    } = t;
    let o = r;
    if (r && r.length !== i) {
      o = new Float32Array(i);
      const c = t.elementOffset || 0;
      for (let l = 0; l < i; ++l)
        o[l] = r[c + l];
    }
    return o;
  }
  getAccessor() {
    return {
      ...this.source.getAccessor(),
      ...this.opts
    };
  }
}
function Wk(n) {
  switch (n) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Unknown GL type");
  }
}
function Jg(n) {
  return n.stride || n.size * n.bytesPerElement;
}
function hE(n, e) {
  e.offset && ur.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const t = Jg(n), r = e.vertexOffset !== void 0 ? e.vertexOffset : n.vertexOffset || 0, i = e.elementOffset || 0, o = r * t + i * n.bytesPerElement + (n.offset || 0);
  return {
    ...e,
    offset: o,
    stride: t
  };
}
function Xk(n, e) {
  const t = hE(n, e);
  return {
    high: t,
    low: {
      ...t,
      offset: t.offset + n.size * 4
    }
  };
}
class $k {
  constructor(e, t, r) {
    V(this, "gl", void 0), V(this, "id", void 0), V(this, "size", void 0), V(this, "settings", void 0), V(this, "value", void 0), V(this, "doublePrecision", void 0), V(this, "_buffer", void 0), V(this, "state", void 0), this.gl = e, this.id = t.id || "", this.size = t.size || 1;
    const i = t.logicalType || t.type, o = i === 5130;
    let {
      defaultValue: c
    } = t;
    c = Number.isFinite(c) ? [c] : c || new Array(this.size).fill(0);
    let l;
    o ? l = 5126 : !i && t.isIndexed ? l = e && F1(e, ei.ELEMENT_INDEX_UINT32) ? 5125 : 5123 : l = i || 5126;
    let _ = Wk(i || l || 5126);
    this.doublePrecision = o, o && t.fp64 === !1 && (_ = Float32Array), this.value = null, this.settings = {
      ...t,
      defaultType: _,
      defaultValue: c,
      logicalType: i,
      type: l,
      size: this.size,
      bytesPerElement: _.BYTES_PER_ELEMENT
    }, this.state = {
      ...r,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    }, this._buffer = null;
  }
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed: e,
        type: t
      } = this.settings;
      this._buffer = new qr(this.gl, {
        id: this.id,
        target: e ? 34963 : 34962,
        accessor: {
          type: t
        }
      });
    }
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * Jg(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), wp.release(this.state.allocatedValue);
  }
  getShaderAttributes(e, t) {
    if (this.doublePrecision) {
      const r = {}, i = this.value instanceof Float64Array, o = Xk(this.getAccessor(), t || {});
      return r[e] = new b_(this, o.high), r["".concat(e, "64Low")] = i ? new b_(this, o.low) : new Float32Array(this.size), r;
    }
    if (t) {
      const r = hE(this.getAccessor(), t);
      return {
        [e]: new b_(this, r)
      };
    }
    return {
      [e]: this
    };
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue() {
    return this.state.constant ? this.value : [this.getBuffer(), this.getAccessor()];
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const t = Array.from(this.value);
      e = [t, t];
    } else {
      const {
        value: t,
        numInstances: r,
        size: i
      } = this, o = r * i;
      if (t && o && t.length >= o) {
        const c = new Array(i).fill(1 / 0), l = new Array(i).fill(-1 / 0);
        for (let _ = 0; _ < o; )
          for (let b = 0; b < i; b++) {
            const w = t[_++];
            w < c[b] && (c[b] = w), w > l[b] && (l[b] = w);
          }
        e = [c, l];
      }
    }
    return this.state.bounds = e, e;
  }
  setData(e) {
    const {
      state: t
    } = this;
    let r;
    ArrayBuffer.isView(e) ? r = {
      value: e
    } : e instanceof qr ? r = {
      buffer: e
    } : r = e;
    const i = {
      ...this.settings,
      ...r
    };
    if (t.bufferAccessor = i, t.bounds = null, r.constant) {
      let o = r.value;
      if (o = this._normalizeValue(o, [], 0), this.settings.normalized && (o = this.normalizeConstant(o)), !(!t.constant || !this._areValuesEqual(o, this.value)))
        return !1;
      t.externalBuffer = null, t.constant = !0, this.value = o;
    } else if (r.buffer) {
      const o = r.buffer;
      t.externalBuffer = o, t.constant = !1, this.value = r.value || null;
      const c = r.value instanceof Float64Array;
      i.type = r.type || o.accessor.type, i.bytesPerElement = o.accessor.BYTES_PER_ELEMENT * (c ? 2 : 1), i.stride = Jg(i);
    } else if (r.value) {
      this._checkExternalBuffer(r);
      let o = r.value;
      t.externalBuffer = null, t.constant = !1, this.value = o, i.bytesPerElement = o.BYTES_PER_ELEMENT, i.stride = Jg(i);
      const {
        buffer: c,
        byteOffset: l
      } = this;
      this.doublePrecision && o instanceof Float64Array && (o = g_(o, i));
      const _ = o.byteLength + l + i.stride * 2;
      c.byteLength < _ && c.reallocate(_), c.setAccessor(null), c.subData({
        data: o,
        offset: l
      }), i.type = r.type || c.accessor.type;
    }
    return !0;
  }
  updateSubBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.state.bounds = null;
    const t = this.value, {
      startOffset: r = 0,
      endOffset: i
    } = e;
    this.buffer.subData({
      data: this.doublePrecision && t instanceof Float64Array ? g_(t, {
        size: this.size,
        startIndex: r,
        endIndex: i
      }) : t.subarray(r, i),
      offset: r * t.BYTES_PER_ELEMENT + this.byteOffset
    });
  }
  allocate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const {
      state: r
    } = this, i = r.allocatedValue, o = wp.allocate(i, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: t
    });
    this.value = o;
    const {
      buffer: c,
      byteOffset: l
    } = this;
    return c.byteLength < o.byteLength + l && (c.reallocate(o.byteLength + l), t && i && c.subData({
      data: i instanceof Float64Array ? g_(i, this) : i,
      offset: l
    })), r.allocatedValue = o, r.constant = !1, r.externalBuffer = null, r.bufferAccessor = this.settings, !0;
  }
  _checkExternalBuffer(e) {
    const {
      value: t
    } = e;
    if (!ArrayBuffer.isView(t))
      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
    const r = this.settings.defaultType;
    let i = !1;
    if (this.doublePrecision && (i = t.BYTES_PER_ELEMENT < 4), i)
      throw new Error("Attribute ".concat(this.id, " does not support ").concat(t.constructor.name));
    !(t instanceof r) && this.settings.normalized && !("normalized" in e) && ur.warn("Attribute ".concat(this.id, " is normalized"))();
  }
  normalizeConstant(e) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
      case 5122:
        return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
      case 5121:
        return new Float32Array(e).map((t) => t / 255);
      case 5123:
        return new Float32Array(e).map((t) => t / 65535);
      default:
        return e;
    }
  }
  _normalizeValue(e, t, r) {
    const {
      defaultValue: i,
      size: o
    } = this.settings;
    if (Number.isFinite(e))
      return t[r] = e, t;
    if (!e) {
      let c = o;
      for (; --c >= 0; )
        t[r + c] = i[c];
      return t;
    }
    switch (o) {
      case 4:
        t[r + 3] = Number.isFinite(e[3]) ? e[3] : i[3];
      case 3:
        t[r + 2] = Number.isFinite(e[2]) ? e[2] : i[2];
      case 2:
        t[r + 1] = Number.isFinite(e[1]) ? e[1] : i[1];
      case 1:
        t[r + 0] = Number.isFinite(e[0]) ? e[0] : i[0];
        break;
      default:
        let c = o;
        for (; --c >= 0; )
          t[r + c] = Number.isFinite(e[c]) ? e[c] : i[c];
    }
    return t;
  }
  _areValuesEqual(e, t) {
    if (!e || !t)
      return !1;
    const {
      size: r
    } = this;
    for (let i = 0; i < r; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
}
const hw = [], dw = [];
function dE(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0, r = hw;
  const i = {
    index: -1,
    data: n,
    target: []
  };
  return n ? typeof n[Symbol.iterator] == "function" ? r = n : n.length > 0 && (dw.length = n.length, r = dw) : r = hw, (e > 0 || Number.isFinite(t)) && (r = (Array.isArray(r) ? r : Array.from(r)).slice(e, t), i.index = e - 1), {
    iterable: r,
    objectInfo: i
  };
}
function fE(n) {
  return n && n[Symbol.asyncIterator];
}
function Zk(n, e) {
  const {
    size: t,
    stride: r,
    offset: i,
    startIndices: o,
    nested: c
  } = e, l = n.BYTES_PER_ELEMENT, _ = r ? r / l : t, b = i ? i / l : 0, w = Math.floor((n.length - b) / _);
  return (T, I) => {
    let {
      index: P,
      target: k
    } = I;
    if (!o) {
      const $ = P * _ + b;
      for (let ie = 0; ie < t; ie++)
        k[ie] = n[$ + ie];
      return k;
    }
    const U = o[P], G = o[P + 1] || w;
    let H;
    if (c) {
      H = new Array(G - U);
      for (let $ = U; $ < G; $++) {
        const ie = $ * _ + b;
        k = new Array(t);
        for (let ge = 0; ge < t; ge++)
          k[ge] = n[ie + ge];
        H[$ - U] = k;
      }
    } else if (_ === t)
      H = n.subarray(U * t + b, G * t + b);
    else {
      H = new n.constructor((G - U) * t);
      let $ = 0;
      for (let ie = U; ie < G; ie++) {
        const ge = ie * _ + b;
        for (let Se = 0; Se < t; Se++)
          H[$++] = n[ge + Se];
      }
    }
    return H;
  };
}
const Jk = [], Yg = [[0, 1 / 0]];
function Yk(n, e) {
  if (n === Yg || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return n;
  const t = [], r = n.length;
  let i = 0;
  for (let o = 0; o < r; o++) {
    const c = n[o];
    c[1] < e[0] ? (t.push(c), i = o + 1) : c[0] > e[1] ? t.push(c) : e = [Math.min(c[0], e[0]), Math.max(c[1], e[1])];
  }
  return t.splice(i, 0, e), t;
}
function v_(n) {
  const {
    source: e,
    target: t,
    start: r = 0,
    size: i,
    getData: o
  } = n, c = n.end || t.length, l = e.length, _ = c - r;
  if (l > _) {
    t.set(e.subarray(0, _), r);
    return;
  }
  if (t.set(e, r), !o)
    return;
  let b = l;
  for (; b < _; ) {
    const w = o(b, e);
    for (let T = 0; T < i; T++)
      t[r + b] = w[T] || 0, b++;
  }
}
function Kk(n) {
  let {
    source: e,
    target: t,
    size: r,
    getData: i,
    sourceStartIndices: o,
    targetStartIndices: c
  } = n;
  if (!Array.isArray(c))
    return v_({
      source: e,
      target: t,
      size: r,
      getData: i
    }), t;
  let l = 0, _ = 0;
  const b = i && ((T, I) => i(T + _, I)), w = Math.min(o.length, c.length);
  for (let T = 1; T < w; T++) {
    const I = o[T] * r, P = c[T] * r;
    v_({
      source: e.subarray(l, I),
      target: t,
      start: _,
      end: P,
      size: r,
      getData: b
    }), l = I, _ = P;
  }
  return _ < t.length && v_({
    source: [],
    target: t,
    start: _,
    size: r,
    getData: b
  }), t;
}
const Qk = {
  interpolation: {
    duration: 0,
    easing: (n) => n
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function pE(n, e) {
  if (!n)
    return null;
  Number.isFinite(n) && (n = {
    type: "interpolation",
    duration: n
  });
  const t = n.type || "interpolation";
  return {
    ...Qk[t],
    ...e,
    ...n,
    type: t
  };
}
function gE(n, e) {
  const t = e.getBuffer();
  return t ? [t, {
    divisor: 0,
    size: e.size,
    normalized: e.settings.normalized
  }] : e.value;
}
function mE(n) {
  switch (n) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error('No defined attribute type for size "'.concat(n, '"'));
  }
}
function _E(n) {
  n.push(n.shift());
}
function ab(n, e) {
  const {
    doublePrecision: t,
    settings: r,
    value: i,
    size: o
  } = n, c = t && i instanceof Float64Array ? 2 : 1;
  return (r.noAlloc ? i.length : e * o) * c;
}
function yE(n) {
  let {
    buffer: e,
    numInstances: t,
    attribute: r,
    fromLength: i,
    fromStartIndices: o,
    getData: c = ($) => $
  } = n;
  const l = r.doublePrecision && r.value instanceof Float64Array ? 2 : 1, _ = r.size * l, b = r.byteOffset, w = r.startIndices, T = o && w, I = ab(r, t), P = r.isConstant;
  if (!T && i >= I)
    return;
  const k = P ? r.value : r.getBuffer().getData({
    srcByteOffset: b
  });
  if (r.settings.normalized && !P) {
    const $ = c;
    c = (ie, ge) => r.normalizeConstant($(ie, ge));
  }
  const U = P ? ($, ie) => c(k, ie) : ($, ie) => c(k.subarray($, $ + _), ie), G = e.getData({
    length: i
  }), H = new Float32Array(I);
  Kk({
    source: G,
    target: H,
    sourceStartIndices: o,
    targetStartIndices: w,
    size: _,
    getData: U
  }), e.byteLength < H.byteLength + b && e.reallocate(H.byteLength + b), e.subData({
    data: H,
    offset: b
  });
}
class lb extends $k {
  constructor(e, t) {
    super(e, t, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      updateRanges: Yg
    }), V(this, "constant", !1), this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw() {
    let {
      clearChangedFlags: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.state.needsRedraw;
    return this.state.needsRedraw = t && !e, t;
  }
  getUpdateTriggers() {
    const {
      accessor: e
    } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const {
      accessor: t
    } = this.settings, r = this.settings.transition, i = Array.isArray(t) ? e[t.find((o) => e[o])] : e[t];
    return pE(i, r);
  }
  setNeedsUpdate() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 ? arguments[1] : void 0;
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
      const {
        startRow: r = 0,
        endRow: i = 1 / 0
      } = t;
      this.state.updateRanges = Yk(this.state.updateRanges, [r, i]);
    } else
      this.state.updateRanges = Yg;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = Jk;
  }
  setNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const {
      state: t,
      settings: r
    } = this;
    return r.noAlloc ? !1 : r.update ? (super.allocate(e, t.updateRanges !== Yg), !0) : !1;
  }
  updateBuffer(e) {
    let {
      numInstances: t,
      data: r,
      props: i,
      context: o
    } = e;
    if (!this.needsUpdate())
      return !1;
    const {
      state: {
        updateRanges: c
      },
      settings: {
        update: l,
        noAlloc: _
      }
    } = this;
    let b = !0;
    if (l) {
      for (const [w, T] of c)
        l.call(o, this, {
          data: r,
          startRow: w,
          endRow: T,
          props: i,
          numInstances: t
        });
      if (this.value) if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [w, T] of c) {
          const I = Number.isFinite(w) ? this.getVertexOffset(w) : 0, P = Number.isFinite(T) ? this.getVertexOffset(T) : _ || !Number.isFinite(t) ? this.value.length : t * this.size;
          super.updateSubBuffer({
            startOffset: I,
            endOffset: P
          });
        }
      this._checkAttributeArray();
    } else
      b = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), b;
  }
  setConstantValue(e) {
    return e === void 0 || typeof e == "function" ? !1 : (this.setData({
      constant: !0,
      value: e
    }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  setExternalBuffer(e) {
    const {
      state: t
    } = this;
    return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
  }
  setBinaryValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const {
      state: r,
      settings: i
    } = this;
    if (!e)
      return r.binaryValue = null, r.binaryAccessor = null, !1;
    if (i.noAlloc)
      return !1;
    if (r.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (r.binaryValue = e, this.setNeedsRedraw(), i.transform || t !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = {
        value: e
      });
      const c = e;
      Rs(ArrayBuffer.isView(c.value), "invalid ".concat(i.accessor));
      const l = !!c.size && c.size !== this.size;
      return r.binaryAccessor = Zk(c.value, {
        size: c.size || this.size,
        stride: c.stride,
        offset: c.offset,
        startIndices: t,
        nested: l
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const {
      startIndices: t
    } = this;
    return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
  }
  getShaderAttributes() {
    const e = this.settings.shaderAttributes || {
      [this.id]: null
    }, t = {};
    for (const r in e)
      Object.assign(t, super.getShaderAttributes(r, e[r]));
    return t;
  }
  _autoUpdater(e, t) {
    let {
      data: r,
      startRow: i,
      endRow: o,
      props: c,
      numInstances: l
    } = t;
    if (e.constant)
      return;
    const {
      settings: _,
      state: b,
      value: w,
      size: T,
      startIndices: I
    } = e, {
      accessor: P,
      transform: k
    } = _, U = b.binaryAccessor || (typeof P == "function" ? P : c[P]);
    Rs(typeof U == "function", 'accessor "'.concat(P, '" is not a function'));
    let G = e.getVertexOffset(i);
    const {
      iterable: H,
      objectInfo: $
    } = dE(r, i, o);
    for (const ie of H) {
      $.index++;
      let ge = U(ie, $);
      if (k && (ge = k.call(this, ge)), I) {
        const Se = ($.index < I.length - 1 ? I[$.index + 1] : l) - I[$.index];
        if (ge && Array.isArray(ge[0])) {
          let Re = G;
          for (const Le of ge)
            e._normalizeValue(Le, w, Re), Re += T;
        } else ge && ge.length > T ? w.set(ge, G) : (e._normalizeValue(ge, $.target, 0), SF({
          target: w,
          source: $.target,
          start: G,
          count: Se
        }));
        G += Se * T;
      } else
        e._normalizeValue(ge, w, G), G += T;
    }
  }
  _validateAttributeUpdaters() {
    const {
      settings: e
    } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
  }
  _checkAttributeArray() {
    const {
      value: e
    } = this, t = Math.min(4, this.size);
    if (e && e.length >= t) {
      let r = !0;
      switch (t) {
        case 4:
          r = r && Number.isFinite(e[3]);
        case 3:
          r = r && Number.isFinite(e[2]);
        case 2:
          r = r && Number.isFinite(e[1]);
        case 1:
          r = r && Number.isFinite(e[0]);
          break;
        default:
          r = !1;
      }
      if (!r)
        throw new Error("Illegal attribute generated for ".concat(this.id));
    }
  }
}
class eN {
  constructor(e) {
    let {
      gl: t,
      attribute: r,
      timeline: i
    } = e;
    V(this, "gl", void 0), V(this, "type", "interpolation"), V(this, "attributeInTransition", void 0), V(this, "settings", void 0), V(this, "attribute", void 0), V(this, "transition", void 0), V(this, "currentStartIndices", void 0), V(this, "currentLength", void 0), V(this, "transform", void 0), V(this, "buffers", void 0), this.gl = t, this.transition = new jp(i), this.attribute = r, this.attributeInTransition = new lb(t, r.settings), this.currentStartIndices = r.startIndices, this.currentLength = 0, this.transform = nN(t, r);
    const o = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new qr(t, o), new qr(t, o)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    if (e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    this.settings = e;
    const {
      gl: r,
      buffers: i,
      attribute: o
    } = this;
    _E(i);
    const c = {
      numInstances: t,
      attribute: o,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: e.enter
    };
    for (const l of i)
      yE({
        buffer: l,
        ...c
      });
    this.currentStartIndices = o.startIndices, this.currentLength = ab(o, t), this.attributeInTransition.setData({
      buffer: i[1],
      value: o.value
    }), this.transition.start(e), this.transform.update({
      elementCount: Math.floor(this.currentLength / o.size),
      sourceBuffers: {
        aFrom: i[0],
        aTo: gE(r, o)
      },
      feedbackBuffers: {
        vCurrent: i[1]
      }
    });
  }
  update() {
    const e = this.transition.update();
    if (e) {
      const {
        duration: t,
        easing: r
      } = this.settings, {
        time: i
      } = this.transition;
      let o = i / t;
      r && (o = r(o)), this.transform.run({
        uniforms: {
          time: o
        }
      });
    }
    return e;
  }
  cancel() {
    this.transition.cancel(), this.transform.delete();
    for (const e of this.buffers)
      e.delete();
    this.buffers.length = 0;
  }
}
const tN = `
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
attribute ATTRIBUTE_TYPE aFrom;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`;
function nN(n, e) {
  const t = mE(e.size);
  return new J1(n, {
    vs: tN,
    defines: {
      ATTRIBUTE_TYPE: t
    },
    varyings: ["vCurrent"]
  });
}
class rN {
  constructor(e) {
    let {
      gl: t,
      attribute: r,
      timeline: i
    } = e;
    V(this, "gl", void 0), V(this, "type", "spring"), V(this, "attributeInTransition", void 0), V(this, "settings", void 0), V(this, "attribute", void 0), V(this, "transition", void 0), V(this, "currentStartIndices", void 0), V(this, "currentLength", void 0), V(this, "texture", void 0), V(this, "framebuffer", void 0), V(this, "transform", void 0), V(this, "buffers", void 0), this.gl = t, this.type = "spring", this.transition = new jp(i), this.attribute = r, this.attributeInTransition = new lb(t, {
      ...r.settings,
      normalized: !1
    }), this.currentStartIndices = r.startIndices, this.currentLength = 0, this.texture = sN(t), this.framebuffer = oN(t, this.texture), this.transform = iN(t, r, this.framebuffer);
    const o = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new qr(t, o), new qr(t, o), new qr(t, o)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    const {
      gl: r,
      buffers: i,
      attribute: o
    } = this, c = {
      numInstances: t,
      attribute: o,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: e.enter
    };
    for (const l of i)
      yE({
        buffer: l,
        ...c
      });
    this.settings = e, this.currentStartIndices = o.startIndices, this.currentLength = ab(o, t), this.attributeInTransition.setData({
      buffer: i[1],
      value: o.value
    }), this.transition.start({
      ...e,
      duration: 1 / 0
    }), this.transform.update({
      elementCount: Math.floor(this.currentLength / o.size),
      sourceBuffers: {
        aTo: gE(r, o)
      }
    });
  }
  update() {
    const {
      buffers: e,
      transform: t,
      framebuffer: r,
      transition: i
    } = this;
    if (!i.update())
      return !1;
    const c = this.settings;
    return t.update({
      sourceBuffers: {
        aPrev: e[0],
        aCur: e[1]
      },
      feedbackBuffers: {
        vNext: e[2]
      }
    }), t.run({
      framebuffer: r,
      discard: !1,
      clearRenderTarget: !0,
      uniforms: {
        stiffness: c.stiffness,
        damping: c.damping
      },
      parameters: {
        depthTest: !1,
        blend: !0,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    }), _E(e), this.attributeInTransition.setData({
      buffer: e[1],
      value: this.attribute.value
    }), Um(r)[0] > 0 || i.end(), !0;
  }
  cancel() {
    this.transition.cancel(), this.transform.delete();
    for (const e of this.buffers)
      e.delete();
    this.buffers.length = 0, this.texture.delete(), this.framebuffer.delete();
  }
}
function iN(n, e, t) {
  const r = mE(e.size);
  return new J1(n, {
    framebuffer: t,
    vs: `
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
attribute ATTRIBUTE_TYPE aPrev;
attribute ATTRIBUTE_TYPE aCur;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vNext;
varying float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`,
    fs: `
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

varying float vIsTransitioningFlag;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  gl_FragColor = vec4(1.0);
}`,
    defines: {
      ATTRIBUTE_TYPE: r
    },
    varyings: ["vNext"]
  });
}
function sN(n) {
  return new Aa(n, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: !1,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function oN(n, e) {
  return new os(n, {
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    attachments: {
      36064: e
    }
  });
}
const aN = {
  interpolation: eN,
  spring: rN
};
class lN {
  constructor(e, t) {
    let {
      id: r,
      timeline: i
    } = t;
    V(this, "id", void 0), V(this, "isSupported", void 0), V(this, "gl", void 0), V(this, "timeline", void 0), V(this, "transitions", void 0), V(this, "needsRedraw", void 0), V(this, "numInstances", void 0), this.id = r, this.gl = e, this.timeline = i, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1, this.isSupported = J1.isSupported(e);
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  update(e) {
    let {
      attributes: t,
      transitions: r,
      numInstances: i
    } = e;
    this.numInstances = i || 1;
    for (const o in t) {
      const c = t[o], l = c.getTransitionSetting(r);
      l && this._updateAttribute(o, c, l);
    }
    for (const o in this.transitions) {
      const c = t[o];
      (!c || !c.getTransitionSetting(r)) && this._removeTransition(o);
    }
  }
  hasAttribute(e) {
    const t = this.transitions[e];
    return t && t.inProgress;
  }
  getAttributes() {
    const e = {};
    for (const t in this.transitions) {
      const r = this.transitions[t];
      r.inProgress && (e[t] = r.attributeInTransition);
    }
    return e;
  }
  run() {
    if (!this.isSupported || this.numInstances === 0)
      return !1;
    for (const t in this.transitions)
      this.transitions[t].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  _removeTransition(e) {
    this.transitions[e].cancel(), delete this.transitions[e];
  }
  _updateAttribute(e, t, r) {
    const i = this.transitions[e];
    let o = !i || i.type !== r.type;
    if (o) {
      if (!this.isSupported) {
        ur.warn("WebGL2 not supported by this browser. Transition for ".concat(e, " is disabled."))();
        return;
      }
      i && this._removeTransition(e);
      const c = aN[r.type];
      c ? this.transitions[e] = new c({
        attribute: t,
        timeline: this.timeline,
        gl: this.gl
      }) : (ur.error("unsupported transition type '".concat(r.type, "'"))(), o = !1);
    }
    (o || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(r, this.numInstances));
  }
}
const fw = "attributeManager.invalidate", cN = "attributeManager.updateStart", uN = "attributeManager.updateEnd", hN = "attribute.updateStart", dN = "attribute.allocate", fN = "attribute.updateEnd";
class pN {
  constructor(e) {
    let {
      id: t = "attribute-manager",
      stats: r,
      timeline: i
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    V(this, "id", void 0), V(this, "gl", void 0), V(this, "attributes", void 0), V(this, "updateTriggers", void 0), V(this, "needsRedraw", void 0), V(this, "userData", void 0), V(this, "stats", void 0), V(this, "attributeTransitionManager", void 0), V(this, "mergeBoundsMemoized", Up(gF)), this.id = t, this.gl = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = r, this.attributeTransitionManager = new lN(e, {
      id: "".concat(t, "-transitions"),
      timeline: i
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
  }
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  add(e) {
    this._add(e);
  }
  addInstanced(e) {
    this._add(e, {
      instanced: 1
    });
  }
  remove(e) {
    for (const t of e)
      this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
  }
  invalidate(e, t) {
    const r = this._invalidateTrigger(e, t);
    eo(fw, this, e, r);
  }
  invalidateAll(e) {
    for (const t in this.attributes)
      this.attributes[t].setNeedsUpdate(t, e);
    eo(fw, this, "all");
  }
  update(e) {
    let {
      data: t,
      numInstances: r,
      startIndices: i = null,
      transitions: o,
      props: c = {},
      buffers: l = {},
      context: _ = {}
    } = e, b = !1;
    eo(cN, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const w in this.attributes) {
      const T = this.attributes[w], I = T.settings.accessor;
      T.startIndices = i, T.numInstances = r, c[w] && ur.removed("props.".concat(w), "data.attributes.".concat(w))(), T.setExternalBuffer(l[w]) || T.setBinaryValue(typeof I == "string" ? l[I] : void 0, t.startIndices) || typeof I == "string" && !l[I] && T.setConstantValue(c[I]) || T.needsUpdate() && (b = !0, this._updateAttribute({
        attribute: T,
        numInstances: r,
        data: t,
        props: c,
        context: _
      })), this.needsRedraw = this.needsRedraw || T.needsRedraw();
    }
    b && eo(uN, this, r), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: r,
      transitions: o
    });
  }
  updateTransition() {
    const {
      attributeTransitionManager: e
    } = this, t = e.run();
    return this.needsRedraw = this.needsRedraw || t, t;
  }
  getAttributes() {
    return this.attributes;
  }
  getBounds(e) {
    const t = e.map((r) => {
      var i;
      return (i = this.attributes[r]) === null || i === void 0 ? void 0 : i.getBounds();
    });
    return this.mergeBoundsMemoized(t);
  }
  getChangedAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearChangedFlags: !1
    };
    const {
      attributes: t,
      attributeTransitionManager: r
    } = this, i = {
      ...r.getAttributes()
    };
    for (const o in t) {
      const c = t[o];
      c.needsRedraw(e) && !r.hasAttribute(o) && (i[o] = c);
    }
    return i;
  }
  getShaderAttributes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e || (e = this.getAttributes());
    const r = {};
    for (const i in e)
      t[i] || Object.assign(r, e[i].getShaderAttributes());
    return r;
  }
  _add(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (const r in e) {
      const i = e[r];
      this.attributes[r] = this._createAttribute(r, i, t);
    }
    this._mapUpdateTriggersToAttributes();
  }
  _createAttribute(e, t, r) {
    const i = {
      ...t,
      id: e,
      size: t.isIndexed && 1 || t.size || 1,
      divisor: r.instanced ? 1 : t.divisor || 0
    };
    return new lb(this.gl, i);
  }
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const t in this.attributes)
      this.attributes[t].getUpdateTriggers().forEach((i) => {
        e[i] || (e[i] = []), e[i].push(t);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, t) {
    const {
      attributes: r,
      updateTriggers: i
    } = this, o = i[e];
    return o && o.forEach((c) => {
      const l = r[c];
      l && l.setNeedsUpdate(l.id, t);
    }), o;
  }
  _updateAttribute(e) {
    const {
      attribute: t,
      numInstances: r
    } = e;
    if (eo(hN, t), t.constant) {
      t.setConstantValue(t.value);
      return;
    }
    t.allocate(r) && eo(dN, t, r), t.updateBuffer(e) && (this.needsRedraw = !0, eo(fN, t, r));
  }
}
class gN extends jp {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time: e,
      settings: {
        fromValue: t,
        toValue: r,
        duration: i,
        easing: o
      }
    } = this, c = o(e / i);
    this._value = bm(t, r, c);
  }
}
const pw = 1e-5;
function gw(n, e, t, r, i) {
  const o = e - n, l = (t - e) * i, _ = -o * r;
  return l + _ + o + e;
}
function mN(n, e, t, r, i) {
  if (Array.isArray(t)) {
    const o = [];
    for (let c = 0; c < t.length; c++)
      o[c] = gw(n[c], e[c], t[c], r, i);
    return o;
  }
  return gw(n, e, t, r, i);
}
function mw(n, e) {
  if (Array.isArray(n)) {
    let t = 0;
    for (let r = 0; r < n.length; r++) {
      const i = n[r] - e[r];
      t += i * i;
    }
    return Math.sqrt(t);
  }
  return Math.abs(n - e);
}
class _N extends jp {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue: e,
      toValue: t,
      damping: r,
      stiffness: i
    } = this.settings, {
      _prevValue: o = e,
      _currValue: c = e
    } = this;
    let l = mN(o, c, t, r, i);
    const _ = mw(l, t), b = mw(l, c);
    _ < pw && b < pw && (l = t, this.end()), this._prevValue = c, this._currValue = l;
  }
}
const yN = {
  interpolation: gN,
  spring: _N
};
class bN {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, t, r, i) {
    const {
      transitions: o
    } = this;
    if (o.has(e)) {
      const _ = o.get(e), {
        value: b = _.settings.fromValue
      } = _;
      t = b, this.remove(e);
    }
    if (i = pE(i), !i)
      return;
    const c = yN[i.type];
    if (!c) {
      ur.error("unsupported transition type '".concat(i.type, "'"))();
      return;
    }
    const l = new c(this.timeline);
    l.start({
      ...i,
      fromValue: t,
      toValue: r
    }), o.set(e, l);
  }
  remove(e) {
    const {
      transitions: t
    } = this;
    t.has(e) && (t.get(e).cancel(), t.delete(e));
  }
  update() {
    const e = {};
    for (const [t, r] of this.transitions)
      r.update(), e[t] = r.value, r.inProgress || this.remove(t);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function vN(n) {
  const e = n[Vu];
  for (const t in e) {
    const r = e[t], {
      validate: i
    } = r;
    if (i && !i(n[t], r))
      throw new Error("Invalid prop ".concat(t, ": ").concat(n[t]));
  }
}
function xN(n, e) {
  const t = bE({
    newProps: n,
    oldProps: e,
    propTypes: n[Vu],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  }), r = AN(n, e);
  let i = !1;
  return r || (i = SN(n, e)), {
    dataChanged: r,
    propsChanged: t,
    updateTriggersChanged: i,
    extensionsChanged: EN(n, e),
    transitionsChanged: wN(n, e)
  };
}
function wN(n, e) {
  if (!n.transitions)
    return !1;
  const t = {}, r = n[Vu];
  let i = !1;
  for (const o in n.transitions) {
    const c = r[o], l = c && c.type;
    (l === "number" || l === "color" || l === "array") && Ry(n[o], e[o], c) && (t[o] = !0, i = !0);
  }
  return i ? t : !1;
}
function bE(n) {
  let {
    newProps: e,
    oldProps: t,
    ignoreProps: r = {},
    propTypes: i = {},
    triggerName: o = "props"
  } = n;
  if (t === e)
    return !1;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return "".concat(o, " changed shallowly");
  for (const c of Object.keys(e))
    if (!(c in r)) {
      if (!(c in t))
        return "".concat(o, ".").concat(c, " added");
      const l = Ry(e[c], t[c], i[c]);
      if (l)
        return "".concat(o, ".").concat(c, " ").concat(l);
    }
  for (const c of Object.keys(t))
    if (!(c in r)) {
      if (!(c in e))
        return "".concat(o, ".").concat(c, " dropped");
      if (!Object.hasOwnProperty.call(e, c)) {
        const l = Ry(e[c], t[c], i[c]);
        if (l)
          return "".concat(o, ".").concat(c, " ").concat(l);
      }
    }
  return !1;
}
function Ry(n, e, t) {
  let r = t && t.equal;
  return r && !r(n, e, t) || !r && (r = n && e && n.equals, r && !r.call(n, e)) ? "changed deeply" : !r && e !== n ? "changed shallowly" : null;
}
function AN(n, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let t = !1;
  const {
    dataComparator: r,
    _dataDiff: i
  } = n;
  return r ? r(n.data, e.data) || (t = "Data comparator detected a change") : n.data !== e.data && (t = "A new data container was supplied"), t && i && (t = i(n.data, e.data) || t), t;
}
function SN(n, e) {
  if (e === null)
    return {
      all: !0
    };
  if ("all" in n.updateTriggers && _w(n, e, "all"))
    return {
      all: !0
    };
  const t = {};
  let r = !1;
  for (const i in n.updateTriggers)
    i !== "all" && _w(n, e, i) && (t[i] = !0, r = !0);
  return r ? t : !1;
}
function EN(n, e) {
  if (e === null)
    return !0;
  const t = e.extensions, {
    extensions: r
  } = n;
  if (r === t)
    return !1;
  if (!t || !r || r.length !== t.length)
    return !0;
  for (let i = 0; i < r.length; i++)
    if (!r[i].equals(t[i]))
      return !0;
  return !1;
}
function _w(n, e, t) {
  let r = n.updateTriggers[t];
  r = r ?? {};
  let i = e.updateTriggers[t];
  return i = i ?? {}, bE({
    oldProps: i,
    newProps: r,
    triggerName: t
  });
}
const TN = "count(): argument not an object", CN = "count(): argument not a container";
function IN(n) {
  if (!LN(n))
    throw new Error(TN);
  if (typeof n.count == "function")
    return n.count();
  if (Number.isFinite(n.size))
    return n.size;
  if (Number.isFinite(n.length))
    return n.length;
  if (PN(n))
    return Object.keys(n).length;
  throw new Error(CN);
}
function PN(n) {
  return n !== null && typeof n == "object" && n.constructor === Object;
}
function LN(n) {
  return n !== null && typeof n == "object";
}
function MN(n, e) {
  if (!e)
    return n;
  const t = {
    ...n,
    ...e
  };
  if ("defines" in e && (t.defines = {
    ...n.defines,
    ...e.defines
  }), "modules" in e && (t.modules = (n.modules || []).concat(e.modules), e.modules.some((r) => r.name === "project64"))) {
    const r = t.modules.findIndex((i) => i.name === "project32");
    r >= 0 && t.modules.splice(r, 1);
  }
  if ("inject" in e)
    if (!n.inject)
      t.inject = e.inject;
    else {
      const r = {
        ...n.inject
      };
      for (const i in e.inject)
        r[i] = (r[i] || "") + e.inject[i];
      t.inject = r;
    }
  return t;
}
const BN = {
  10241: 9987,
  10240: 9729,
  10242: 33071,
  10243: 33071
}, Oy = {};
function RN(n, e, t, r) {
  if (t instanceof Aa)
    return t;
  t.constructor && t.constructor.name !== "Object" && (t = {
    data: t
  });
  let i = null;
  t.compressed && (i = {
    10241: t.data.length > 1 ? 9985 : 9729
  });
  const o = new Aa(e, {
    ...t,
    parameters: {
      ...BN,
      ...i,
      ...r
    }
  });
  return Oy[o.id] = n, o;
}
function ON(n, e) {
  !e || !(e instanceof Aa) || Oy[e.id] === n && (e.delete(), delete Oy[e.id]);
}
const DN = {
  boolean: {
    validate(n, e) {
      return !0;
    },
    equal(n, e, t) {
      return !!n == !!e;
    }
  },
  number: {
    validate(n, e) {
      return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
    }
  },
  color: {
    validate(n, e) {
      return e.optional && !n || Dy(n) && (n.length === 3 || n.length === 4);
    },
    equal(n, e, t) {
      return yc(n, e, 1);
    }
  },
  accessor: {
    validate(n, e) {
      const t = Tm(n);
      return t === "function" || t === Tm(e.value);
    },
    equal(n, e, t) {
      return typeof e == "function" ? !0 : yc(n, e, 1);
    }
  },
  array: {
    validate(n, e) {
      return e.optional && !n || Dy(n);
    },
    equal(n, e, t) {
      const {
        compare: r
      } = t, i = Number.isInteger(r) ? r : r ? 1 : 0;
      return r ? yc(n, e, i) : n === e;
    }
  },
  object: {
    equal(n, e, t) {
      if (t.ignore)
        return !0;
      const {
        compare: r
      } = t, i = Number.isInteger(r) ? r : r ? 1 : 0;
      return r ? yc(n, e, i) : n === e;
    }
  },
  function: {
    validate(n, e) {
      return e.optional && !n || typeof n == "function";
    },
    equal(n, e, t) {
      return !t.compare && t.ignore !== !1 || n === e;
    }
  },
  data: {
    transform: (n, e, t) => {
      const {
        dataTransform: r
      } = t.props;
      return r && n ? r(n) : n;
    }
  },
  image: {
    transform: (n, e, t) => {
      const r = t.context;
      return !r || !r.gl ? null : RN(t.id, r.gl, n, {
        ...e.parameters,
        ...t.props.textureParameters
      });
    },
    release: (n, e, t) => {
      ON(t.id, n);
    }
  }
};
function FN(n) {
  const e = {}, t = {}, r = {};
  for (const [i, o] of Object.entries(n)) {
    const c = o == null ? void 0 : o.deprecatedFor;
    if (c)
      r[i] = Array.isArray(c) ? c : [c];
    else {
      const l = kN(i, o);
      e[i] = l, t[i] = l.value;
    }
  }
  return {
    propTypes: e,
    defaultProps: t,
    deprecatedProps: r
  };
}
function kN(n, e) {
  switch (Tm(e)) {
    case "object":
      return qf(n, e);
    case "array":
      return qf(n, {
        type: "array",
        value: e,
        compare: !1
      });
    case "boolean":
      return qf(n, {
        type: "boolean",
        value: e
      });
    case "number":
      return qf(n, {
        type: "number",
        value: e
      });
    case "function":
      return qf(n, {
        type: "function",
        value: e,
        compare: !0
      });
    default:
      return {
        name: n,
        type: "unknown",
        value: e
      };
  }
}
function qf(n, e) {
  return "type" in e ? {
    name: n,
    ...DN[e.type],
    ...e
  } : "value" in e ? {
    name: n,
    type: Tm(e.value),
    ...e
  } : {
    name: n,
    type: "object",
    value: e
  };
}
function Dy(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n);
}
function Tm(n) {
  return Dy(n) ? "array" : n === null ? "null" : typeof n;
}
function NN(n, e) {
  let t;
  for (let o = e.length - 1; o >= 0; o--) {
    const c = e[o];
    "extensions" in c && (t = c.extensions);
  }
  const r = Fy(n.constructor, t), i = Object.create(r);
  i[Sm] = n, i[Nh] = {}, i[Uu] = {};
  for (let o = 0; o < e.length; ++o) {
    const c = e[o];
    for (const l in c)
      i[l] = c[l];
  }
  return Object.freeze(i), i;
}
const zN = "_mergedDefaultProps";
function Fy(n, e) {
  let t = zN;
  if (e)
    for (const i of e) {
      const o = i.constructor;
      o && (t += ":".concat(o.extensionName || o.name));
    }
  const r = vE(n, t);
  return r || (n[t] = UN(n, e || []));
}
function UN(n, e) {
  if (!n.prototype)
    return null;
  const r = Object.getPrototypeOf(n), i = Fy(r), o = vE(n, "defaultProps") || {}, c = FN(o), l = Object.assign(/* @__PURE__ */ Object.create(null), i, c.defaultProps), _ = Object.assign(/* @__PURE__ */ Object.create(null), i == null ? void 0 : i[Vu], c.propTypes), b = Object.assign(/* @__PURE__ */ Object.create(null), i == null ? void 0 : i[__], c.deprecatedProps);
  for (const w of e) {
    const T = Fy(w.constructor);
    T && (Object.assign(l, T), Object.assign(_, T[Vu]), Object.assign(b, T[__]));
  }
  return jN(l, n), VN(l, _), GN(l, b), l[Vu] = _, l[__] = b, e.length === 0 && !cb(n, "_propTypes") && (n._propTypes = _), l;
}
function jN(n, e) {
  const t = HN(e);
  Object.defineProperties(n, {
    id: {
      writable: !0,
      value: t
    }
  });
}
function GN(n, e) {
  for (const t in e)
    Object.defineProperty(n, t, {
      enumerable: !1,
      set(r) {
        const i = "".concat(this.id, ": ").concat(t);
        for (const o of e[t])
          cb(this, o) || (this[o] = r);
        ur.deprecated(i, e[t].join("/"))();
      }
    });
}
function VN(n, e) {
  const t = {}, r = {};
  for (const i in e) {
    const o = e[i], {
      name: c,
      value: l
    } = o;
    o.async && (t[c] = l, r[c] = qN(c));
  }
  n[kd] = t, n[Nh] = {}, Object.defineProperties(n, r);
}
function qN(n) {
  return {
    enumerable: !0,
    set(e) {
      typeof e == "string" || e instanceof Promise || fE(e) ? this[Nh][n] = e : this[Uu][n] = e;
    },
    get() {
      if (this[Uu]) {
        if (n in this[Uu])
          return this[Uu][n] || this[kd][n];
        if (n in this[Nh]) {
          const e = this[Sm] && this[Sm].internalState;
          if (e && e.hasAsyncProp(n))
            return e.getAsyncProp(n) || this[kd][n];
        }
      }
      return this[kd][n];
    }
  };
}
function cb(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
function vE(n, e) {
  return cb(n, e) && n[e];
}
function HN(n) {
  const e = n.componentName;
  return e || ur.warn("".concat(n.name, ".componentName not specified"))(), e || n.name;
}
let WN = 0;
class ub {
  constructor() {
    V(this, "id", void 0), V(this, "props", void 0), V(this, "count", void 0);
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    this.props = NN(this, t), this.id = this.props.id, this.count = WN++;
  }
  clone(e) {
    const {
      props: t
    } = this, r = {};
    for (const i in t[kd])
      i in t[Uu] ? r[i] = t[Uu][i] : i in t[Nh] && (r[i] = t[Nh][i]);
    return new this.constructor({
      ...t,
      ...r,
      ...e
    });
  }
}
V(ub, "componentName", "Component");
V(ub, "defaultProps", {});
const XN = Object.freeze({});
class $N {
  constructor(e) {
    V(this, "component", void 0), V(this, "onAsyncPropUpdated", void 0), V(this, "asyncProps", void 0), V(this, "oldProps", void 0), V(this, "oldAsyncProps", void 0), this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const t = this.asyncProps[e];
      t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || XN;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  getAsyncProp(e) {
    const t = this.asyncProps[e];
    return t && t.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const t = this.asyncProps[e];
      return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
    }
    for (const t in this.asyncProps)
      if (this.isAsyncPropLoading(t))
        return !0;
    return !1;
  }
  reloadAsyncProp(e, t) {
    this._watchPromise(e, Promise.resolve(t));
  }
  setAsyncProps(e) {
    this.component = e[Sm] || this.component;
    const t = e[Uu] || {}, r = e[Nh] || e, i = e[kd] || {};
    for (const o in t) {
      const c = t[o];
      this._createAsyncPropData(o, i[o]), this._updateAsyncProp(o, c), t[o] = this.getAsyncProp(o);
    }
    for (const o in r) {
      const c = r[o];
      this._createAsyncPropData(o, i[o]), this._updateAsyncProp(o, c);
    }
  }
  _fetch(e, t) {
    return null;
  }
  _onResolve(e, t) {
  }
  _onError(e, t) {
  }
  _updateAsyncProp(e, t) {
    if (this._didAsyncInputValueChange(e, t)) {
      if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
        this._watchPromise(e, t);
        return;
      }
      if (fE(t)) {
        this._resolveAsyncIterable(e, t);
        return;
      }
      this._setPropValue(e, t);
    }
  }
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  _didAsyncInputValueChange(e, t) {
    const r = this.asyncProps[e];
    return t === r.resolvedValue || t === r.lastValue ? !1 : (r.lastValue = t, !0);
  }
  _setPropValue(e, t) {
    this._freezeAsyncOldProps();
    const r = this.asyncProps[e];
    r && (t = this._postProcessValue(r, t), r.resolvedValue = t, r.pendingLoadCount++, r.resolvedLoadCount = r.pendingLoadCount);
  }
  _setAsyncPropValue(e, t, r) {
    const i = this.asyncProps[e];
    i && r >= i.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), i.resolvedValue = t, i.resolvedLoadCount = r, this.onAsyncPropUpdated(e, t));
  }
  _watchPromise(e, t) {
    const r = this.asyncProps[e];
    if (r) {
      r.pendingLoadCount++;
      const i = r.pendingLoadCount;
      t.then((o) => {
        this.component && (o = this._postProcessValue(r, o), this._setAsyncPropValue(e, o, i), this._onResolve(e, o));
      }).catch((o) => {
        this._onError(e, o);
      });
    }
  }
  async _resolveAsyncIterable(e, t) {
    if (e !== "data") {
      this._setPropValue(e, t);
      return;
    }
    const r = this.asyncProps[e];
    if (!r)
      return;
    r.pendingLoadCount++;
    const i = r.pendingLoadCount;
    let o = [], c = 0;
    for await (const l of t) {
      if (!this.component)
        return;
      const {
        dataTransform: _
      } = this.component.props;
      _ ? o = _(l, o) : o = o.concat(l), Object.defineProperty(o, "__diff", {
        enumerable: !1,
        value: [{
          startRow: c,
          endRow: o.length
        }]
      }), c = o.length, this._setAsyncPropValue(e, o, i);
    }
    this._onResolve(e, o);
  }
  _postProcessValue(e, t) {
    const r = e.type;
    return r && this.component && (r.release && r.release(e.resolvedValue, r, this.component), r.transform) ? r.transform(t, r, this.component) : t;
  }
  _createAsyncPropData(e, t) {
    if (!this.asyncProps[e]) {
      const i = this.component && this.component.props[Vu];
      this.asyncProps[e] = {
        type: i && i[e],
        lastValue: null,
        resolvedValue: t,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class ZN extends $N {
  constructor(e) {
    let {
      attributeManager: t,
      layer: r
    } = e;
    super(r), V(this, "attributeManager", void 0), V(this, "needsRedraw", void 0), V(this, "needsUpdate", void 0), V(this, "subLayers", void 0), V(this, "usesPickingColorCache", void 0), V(this, "hasPickingBuffer", void 0), V(this, "changeFlags", void 0), V(this, "viewport", void 0), V(this, "uniformTransitions", void 0), V(this, "propsInTransition", void 0), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  _fetch(e, t) {
    const r = this.layer, i = r == null ? void 0 : r.props.fetch;
    return i ? i(t, {
      propName: e,
      layer: r
    }) : super._fetch(e, t);
  }
  _onResolve(e, t) {
    const r = this.layer;
    if (r) {
      const i = r.props.onDataLoad;
      e === "data" && i && i(t, {
        propName: e,
        layer: r
      });
    }
  }
  _onError(e, t) {
    const r = this.layer;
    r && r.raiseError(t, "loading ".concat(e, " of ").concat(this.layer));
  }
}
const JN = "layer.changeFlag", YN = "layer.initialize", KN = "layer.update", QN = "layer.finalize", e8 = "layer.matched", yw = 2 ** 24 - 1, t8 = Object.freeze([]), n8 = Up((n) => {
  let {
    oldViewport: e,
    viewport: t
  } = n;
  return e.equals(t);
});
let hc = new Uint8ClampedArray(0);
const r8 = {
  data: {
    type: "data",
    value: t8,
    async: !0
  },
  dataComparator: {
    type: "function",
    value: null,
    optional: !0
  },
  _dataDiff: {
    type: "function",
    value: (n) => n && n.__diff,
    optional: !0
  },
  dataTransform: {
    type: "function",
    value: null,
    optional: !0
  },
  onDataLoad: {
    type: "function",
    value: null,
    optional: !0
  },
  onError: {
    type: "function",
    value: null,
    optional: !0
  },
  fetch: {
    type: "function",
    value: (n, e) => {
      let {
        propName: t,
        layer: r,
        loaders: i,
        loadOptions: o,
        signal: c
      } = e;
      const {
        resourceManager: l
      } = r.context;
      if (o = o || r.getLoadOptions(), i = i || r.props.loaders, c) {
        var _;
        o = {
          ...o,
          fetch: {
            ...(_ = o) === null || _ === void 0 ? void 0 : _.fetch,
            signal: c
          }
        };
      }
      let b = l.contains(n);
      return !b && !o && (l.add({
        resourceId: n,
        data: Hu(n, i),
        persistent: !1
      }), b = !0), b ? l.subscribe({
        resourceId: n,
        onChange: (w) => {
          var T;
          return (T = r.internalState) === null || T === void 0 ? void 0 : T.reloadAsyncProp(t, w);
        },
        consumerId: r.id,
        requestId: t
      }) : Hu(n, i, o);
    }
  },
  updateTriggers: {},
  visible: !0,
  pickable: !1,
  opacity: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  operation: "draw",
  onHover: {
    type: "function",
    value: null,
    optional: !0
  },
  onClick: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragStart: {
    type: "function",
    value: null,
    optional: !0
  },
  onDrag: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragEnd: {
    type: "function",
    value: null,
    optional: !0
  },
  coordinateSystem: cr.DEFAULT,
  coordinateOrigin: {
    type: "array",
    value: [0, 0, 0],
    compare: !0
  },
  modelMatrix: {
    type: "array",
    value: null,
    compare: !0,
    optional: !0
  },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: {
    type: "object",
    value: {},
    optional: !0,
    compare: 2
  },
  loadOptions: {
    type: "object",
    value: null,
    optional: !0,
    ignore: !0
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: "array",
    value: [],
    optional: !0,
    ignore: !0
  },
  getPolygonOffset: {
    type: "function",
    value: (n) => {
      let {
        layerIndex: e
      } = n;
      return [0, -e * 100];
    }
  },
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: {
    type: "accessor",
    value: [0, 0, 128, 128]
  }
};
class sf extends ub {
  constructor() {
    super(...arguments), V(this, "internalState", null), V(this, "lifecycle", Ed.NO_STATE), V(this, "context", void 0), V(this, "state", void 0), V(this, "parent", null);
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    const e = this.constructor.layerName || this.constructor.name;
    return "".concat(e, "({id: '").concat(this.props.id, "'})");
  }
  project(e) {
    Rs(this.internalState);
    const t = this.internalState.viewport || this.context.viewport, r = tE(e, {
      viewport: t,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [i, o, c] = eE(r, t.pixelProjectionMatrix);
    return e.length === 2 ? [i, o] : [i, o, c];
  }
  unproject(e) {
    return Rs(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  projectPosition(e, t) {
    Rs(this.internalState);
    const r = this.internalState.viewport || this.context.viewport;
    return xF(e, {
      viewport: r,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...t
    });
  }
  get isComposite() {
    return !1;
  }
  setState(e) {
    this.setChangeFlags({
      stateChanged: !0
    }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  getModels() {
    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
  }
  setModuleParameters(e) {
    for (const t of this.getModels())
      t.updateModuleSettings(e);
  }
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem: e
    } = this.props;
    return e === cr.DEFAULT || e === cr.LNGLAT || e === cr.CARTESIAN;
  }
  onHover(e, t) {
    return this.props.onHover && this.props.onHover(e, t) || !1;
  }
  onClick(e, t) {
    return this.props.onClick && this.props.onClick(e, t) || !1;
  }
  nullPickingColor() {
    return [0, 0, 0];
  }
  encodePickingColor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
  }
  decodePickingColor(e) {
    Rs(e instanceof Uint8Array);
    const [t, r, i] = e;
    return t + r * 256 + i * 65536 - 1;
  }
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : IN(this.props.data);
  }
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  getBounds() {
    var e;
    return (e = this.getAttributeManager()) === null || e === void 0 ? void 0 : e.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    for (const t of this.props.extensions)
      e = MN(e, t.getShaders.call(this, t));
    return e;
  }
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  updateState(e) {
    const t = this.getAttributeManager(), {
      dataChanged: r
    } = e.changeFlags;
    if (r && t)
      if (Array.isArray(r))
        for (const i of r)
          t.invalidateAll(i);
      else
        t.invalidateAll();
    if (t) {
      const {
        props: i
      } = e, o = this.internalState.hasPickingBuffer, c = Number.isInteger(i.highlightedObjectIndex) || i.pickable || i.extensions.some((l) => l.getNeedsPickingBuffer.call(this, l));
      if (o !== c) {
        this.internalState.hasPickingBuffer = c;
        const {
          pickingColors: l,
          instancePickingColors: _
        } = t.attributes, b = l || _;
        b && (c && b.constant && (b.constant = !1, t.invalidate(b.id)), !b.value && !c && (b.constant = !0, b.value = [0, 0, 0]));
      }
    }
  }
  finalizeState(e) {
    for (const r of this.getModels())
      r.delete();
    const t = this.getAttributeManager();
    t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
      consumerId: this.id
    }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  draw(e) {
    for (const t of this.getModels())
      t.draw(e);
  }
  getPickingInfo(e) {
    let {
      info: t,
      mode: r,
      sourceLayer: i
    } = e;
    const {
      index: o
    } = t;
    return o >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[o]), t;
  }
  raiseError(e, t) {
    var r, i;
    if (t && (e = new Error("".concat(t, ": ").concat(e.message), {
      cause: e
    })), !((r = (i = this.props).onError) !== null && r !== void 0 && r.call(i, e))) {
      var o, c;
      (o = this.context) === null || o === void 0 || (c = o.onError) === null || c === void 0 || c.call(o, e, this);
    }
  }
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    return this._getNeedsRedraw(e);
  }
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  hasUniformTransition() {
    var e;
    return ((e = this.internalState) === null || e === void 0 ? void 0 : e.uniformTransitions.active) || !1;
  }
  activateViewport(e) {
    if (!this.internalState)
      return;
    const t = this.internalState.viewport;
    this.internalState.viewport = e, (!t || !n8({
      oldViewport: t,
      viewport: e
    })) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  invalidateAttribute() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
    const t = this.getAttributeManager();
    t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
  }
  updateAttributes(e) {
    for (const t of this.getModels())
      this._setModelAttributes(t, e);
  }
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const t = this.props, r = this.getNumInstances(), i = this.getStartIndices();
    e.update({
      data: t.data,
      numInstances: r,
      startIndices: i,
      props: t,
      transitions: t.transitions,
      buffers: t.data.attributes,
      context: this
    });
    const o = e.getChangedAttributes({
      clearChangedFlags: !0
    });
    this.updateAttributes(o);
  }
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  _updateUniformTransition() {
    const {
      uniformTransitions: e
    } = this.internalState;
    if (e.active) {
      const t = e.update(), r = Object.create(this.props);
      for (const i in t)
        Object.defineProperty(r, i, {
          value: t[i]
        });
      return r;
    }
    return this.props;
  }
  calculateInstancePickingColors(e, t) {
    let {
      numInstances: r
    } = t;
    if (e.constant)
      return;
    const i = Math.floor(hc.length / 3);
    if (this.internalState.usesPickingColorCache = !0, i < r) {
      r > yw && ur.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), hc = wp.allocate(hc, r, {
        size: 3,
        copy: !0,
        maxCount: Math.max(r, yw)
      });
      const o = Math.floor(hc.length / 3), c = [];
      for (let l = i; l < o; l++)
        this.encodePickingColor(l, c), hc[l * 3 + 0] = c[0], hc[l * 3 + 1] = c[1], hc[l * 3 + 2] = c[2];
    }
    e.value = hc.subarray(0, r * 3);
  }
  _setModelAttributes(e, t) {
    const r = this.getAttributeManager(), i = e.userData.excludeAttributes || {}, o = r.getShaderAttributes(t, i);
    e.setAttributes(o);
  }
  disablePickingIndex(e) {
    const t = this.props.data;
    if (!("attributes" in t)) {
      this._disablePickingIndex(e);
      return;
    }
    const {
      pickingColors: r,
      instancePickingColors: i
    } = this.getAttributeManager().attributes, o = r || i, c = o && t.attributes && t.attributes[o.id];
    if (c && c.value) {
      const l = c.value, _ = this.encodePickingColor(e);
      for (let b = 0; b < t.length; b++) {
        const w = o.getVertexOffset(b);
        l[w] === _[0] && l[w + 1] === _[1] && l[w + 2] === _[2] && this._disablePickingIndex(b);
      }
    } else
      this._disablePickingIndex(e);
  }
  _disablePickingIndex(e) {
    const {
      pickingColors: t,
      instancePickingColors: r
    } = this.getAttributeManager().attributes, i = t || r;
    if (!i)
      return;
    const o = i.getVertexOffset(e), c = i.getVertexOffset(e + 1);
    i.buffer.subData({
      data: new Uint8Array(c - o),
      offset: o
    });
  }
  restorePickingColors() {
    const {
      pickingColors: e,
      instancePickingColors: t
    } = this.getAttributeManager().attributes, r = e || t;
    r && (this.internalState.usesPickingColorCache && r.value.buffer !== hc.buffer && (r.value = hc.subarray(0, r.value.length)), r.updateSubBuffer({
      startOffset: 0
    }));
  }
  _initialize() {
    Rs(!this.internalState), Rs(Number.isFinite(this.props.coordinateSystem)), eo(YN, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: 5121,
        size: 3,
        noAlloc: !0,
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new ZN({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (ur.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new bN(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const t of this.props.extensions)
      t.initializeState.call(this, this.context, t);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  _transferState(e) {
    eo(e8, this, this === e);
    const {
      state: t,
      internalState: r
    } = e;
    this !== e && (this.internalState = r, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  _update() {
    const e = this.needsUpdate();
    if (eo(KN, this, e), !e)
      return;
    const t = this.props, r = this.context, i = this.internalState, o = r.viewport, c = this._updateUniformTransition();
    i.propsInTransition = c, r.viewport = i.viewport || o, this.props = c;
    try {
      const l = this._getUpdateParams(), _ = this.getModels();
      if (r.gl)
        this.updateState(l);
      else
        try {
          this.updateState(l);
        } catch {
        }
      for (const w of this.props.extensions)
        w.updateState.call(this, l, w);
      const b = this.getModels()[0] !== _[0];
      this._postUpdate(l, b);
    } finally {
      r.viewport = o, this.props = t, this._clearChangeFlags(), i.needsUpdate = !1, i.resetOldProps();
    }
  }
  _finalize() {
    eo(QN, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  _drawLayer(e) {
    let {
      moduleParameters: t = null,
      uniforms: r = {},
      parameters: i = {}
    } = e;
    this._updateAttributeTransition();
    const o = this.props, c = this.context;
    this.props = this.internalState.propsInTransition || o;
    const l = this.props.opacity;
    r.opacity = Math.pow(l, 1 / 2.2);
    try {
      t && this.setModuleParameters(t);
      const {
        getPolygonOffset: _
      } = this.props, b = _ && _(r) || [0, 0];
      su(c.gl, {
        polygonOffset: b
      }), Al(c.gl, i, () => {
        const w = {
          moduleParameters: t,
          uniforms: r,
          parameters: i,
          context: c
        };
        for (const T of this.props.extensions)
          T.draw.call(this, w, T);
        this.draw(w);
      });
    } finally {
      this.props = o;
    }
  }
  getChangeFlags() {
    var e;
    return (e = this.internalState) === null || e === void 0 ? void 0 : e.changeFlags;
  }
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const {
      changeFlags: t
    } = this.internalState;
    for (const i in e)
      if (e[i]) {
        let o = !1;
        switch (i) {
          case "dataChanged":
            const c = e[i], l = t[i];
            c && Array.isArray(l) && (t.dataChanged = Array.isArray(c) ? l.concat(c) : c, o = !0);
          default:
            t[i] || (t[i] = e[i], o = !0);
        }
        o && eo(JN, this, i, e);
      }
    const r = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
    t.propsOrDataChanged = r, t.somethingChanged = r || t.viewportChanged || t.stateChanged;
  }
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  _diffProps(e, t) {
    const r = xN(e, t);
    if (r.updateTriggersChanged)
      for (const o in r.updateTriggersChanged)
        r.updateTriggersChanged[o] && this.invalidateAttribute(o);
    if (r.transitionsChanged)
      for (const o in r.transitionsChanged) {
        var i;
        this.internalState.uniformTransitions.add(o, t[o], e[o], (i = e.transitions) === null || i === void 0 ? void 0 : i[o]);
      }
    return this.setChangeFlags(r);
  }
  validateProps() {
    vN(this.props);
  }
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  _updateAutoHighlight(e) {
    const t = {
      pickingSelectedColor: e.picked ? e.color : null
    }, {
      highlightColor: r
    } = this.props;
    e.picked && typeof r == "function" && (t.pickingHighlightColor = r(e)), this.setModuleParameters(t), this.setNeedsRedraw();
  }
  _getAttributeManager() {
    const e = this.context;
    return new pN(e.gl, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  _postUpdate(e, t) {
    const {
      props: r,
      oldProps: i
    } = e;
    this.setNeedsRedraw(), this._updateAttributes();
    const {
      model: o
    } = this.state;
    o == null || o.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight: c,
      highlightedObjectIndex: l,
      highlightColor: _
    } = r;
    if (t || i.autoHighlight !== c || i.highlightedObjectIndex !== l || i.highlightColor !== _) {
      const b = {};
      c || (b.pickingSelectedColor = null), Array.isArray(_) && (b.pickingHighlightColor = _), (t || l !== i.highlightedObjectIndex) && (b.pickingSelectedColor = Number.isFinite(l) && l >= 0 ? this.encodePickingColor(l) : null), this.setModuleParameters(b);
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let t = !1;
    t = t || this.internalState.needsRedraw && this.id;
    const r = this.getAttributeManager(), i = r ? r.getNeedsRedraw(e) : !1;
    if (t = t || i, t)
      for (const o of this.props.extensions)
        o.onNeedsRedraw.call(this, o);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
  }
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
V(sf, "defaultProps", r8);
V(sf, "layerName", "Layer");
const i8 = "compositeLayer.renderLayers";
class xE extends sf {
  get isComposite() {
    return !0;
  }
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  initializeState(e) {
  }
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  getPickingInfo(e) {
    let {
      info: t
    } = e;
    const {
      object: r
    } = t;
    return r && r.__source && r.__source.parent && r.__source.parent.id === this.id && (t.object = r.__source.object, t.index = r.__source.index), t;
  }
  filterSubLayer(e) {
    return !0;
  }
  shouldRenderSubLayer(e, t) {
    return t && t.length;
  }
  getSubLayerClass(e, t) {
    const {
      _subLayerProps: r
    } = this.props;
    return r && r[e] && r[e].type || t;
  }
  getSubLayerRow(e, t, r) {
    return e.__source = {
      parent: this,
      object: t,
      index: r
    }, e;
  }
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const t = {
        index: -1,
        data: this.props.data,
        target: []
      };
      return (r, i) => r && r.__source ? (t.index = r.__source.index, e(r.__source.object, t)) : e(r, i);
    }
    return e;
  }
  getSubLayerProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var t;
    const {
      opacity: r,
      pickable: i,
      visible: o,
      parameters: c,
      getPolygonOffset: l,
      highlightedObjectIndex: _,
      autoHighlight: b,
      highlightColor: w,
      coordinateSystem: T,
      coordinateOrigin: I,
      wrapLongitude: P,
      positionFormat: k,
      modelMatrix: U,
      extensions: G,
      fetch: H,
      operation: $,
      _subLayerProps: ie
    } = this.props, ge = {
      id: "",
      updateTriggers: {},
      opacity: r,
      pickable: i,
      visible: o,
      parameters: c,
      getPolygonOffset: l,
      highlightedObjectIndex: _,
      autoHighlight: b,
      highlightColor: w,
      coordinateSystem: T,
      coordinateOrigin: I,
      wrapLongitude: P,
      positionFormat: k,
      modelMatrix: U,
      extensions: G,
      fetch: H,
      operation: $
    }, Se = ie && e.id && ie[e.id], Re = Se && Se.updateTriggers, Le = e.id || "sublayer";
    if (Se) {
      const _e = this.props[Vu], Ge = e.type ? e.type._propTypes : {};
      for (const ke in Se) {
        const oe = Ge[ke] || _e[ke];
        oe && oe.type === "accessor" && (Se[ke] = this.getSubLayerAccessor(Se[ke]));
      }
    }
    Object.assign(ge, e, Se), ge.id = "".concat(this.props.id, "-").concat(Le), ge.updateTriggers = {
      all: (t = this.props.updateTriggers) === null || t === void 0 ? void 0 : t.all,
      ...e.updateTriggers,
      ...Re
    };
    for (const _e of G) {
      const Ge = _e.getSubLayerProps.call(this, _e);
      Ge && Object.assign(ge, Ge, {
        updateTriggers: Object.assign(ge.updateTriggers, Ge.updateTriggers)
      });
    }
    return ge;
  }
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  _getAttributeManager() {
    return null;
  }
  _postUpdate(e, t) {
    let r = this.internalState.subLayers;
    const i = !r || this.needsUpdate();
    if (i) {
      const o = this.renderLayers();
      r = jm(o, Boolean), this.internalState.subLayers = r;
    }
    eo(i8, this, i, r);
    for (const o of r)
      o.parent = this;
  }
}
V(xE, "layerName", "CompositeLayer");
const x_ = 512, s8 = Math.PI / 180;
function o8(n) {
  let {
    map: e,
    gl: t,
    deck: r
  } = n;
  if (e.__deck)
    return e.__deck;
  const i = r == null ? void 0 : r.props._customRender, o = r == null ? void 0 : r.props.onLoad, c = l8({
    ...r == null ? void 0 : r.props,
    _customRender: () => {
      e.triggerRepaint(), i == null || i("");
    }
  });
  let l;
  return (!r || r.props.gl === t) && (Object.assign(c, {
    gl: t,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: hb(e)
  }), r != null && r.isInitialized ? bw(r, e) : c.onLoad = () => {
    o == null || o(), bw(l, e);
  }), r ? (l = r, r.setProps(c), r.userData.isExternal = !0) : (l = new ob(c), e.on("remove", () => {
    a8(e);
  })), l.userData.mapboxLayers = /* @__PURE__ */ new Set(), e.__deck = l, e.on("render", () => {
    l.isInitialized && p8(l, e);
  }), l;
}
function bw(n, e) {
  const t = () => {
    n.isInitialized ? g8(n, e) : e.off("move", t);
  };
  e.on("move", t);
}
function a8(n) {
  var e;
  (e = n.__deck) === null || e === void 0 || e.finalize(), n.__deck = null;
}
function l8(n) {
  return {
    ...n,
    parameters: {
      depthMask: !0,
      depthTest: !0,
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthFunc: 515,
      blendEquation: 32774,
      ...n.parameters
    },
    views: n.views || [new ib({
      id: "mapbox"
    })]
  };
}
function c8(n, e) {
  n.userData.mapboxLayers.add(e), db(n);
}
function u8(n, e) {
  n.userData.mapboxLayers.delete(e), db(n);
}
function h8(n, e) {
  db(n);
}
function d8(n, e, t) {
  let {
    currentViewport: r
  } = n.userData, i = !1;
  r || (r = wE(n, e, !0), n.userData.currentViewport = r, i = !0), n.isInitialized && n._drawLayers("mapbox-repaint", {
    viewports: [r],
    layerFilter: (o) => {
      let {
        layer: c
      } = o;
      return t.id === c.id || c.props.operation.includes("terrain");
    },
    clearStack: i,
    clearCanvas: !1
  });
}
function hb(n) {
  var e;
  const {
    lng: t,
    lat: r
  } = n.getCenter(), i = {
    longitude: (t + 540) % 360 - 180,
    latitude: r,
    zoom: n.getZoom(),
    bearing: n.getBearing(),
    pitch: n.getPitch(),
    padding: n.getPadding(),
    repeat: n.getRenderWorldCopies()
  };
  return (e = n.getTerrain) !== null && e !== void 0 && e.call(n) && f8(n, i), i;
}
function f8(n, e) {
  if (n.getFreeCameraOptions) {
    const {
      position: t
    } = n.getFreeCameraOptions();
    if (!t || t.z === void 0)
      return;
    const r = n.transform.height, {
      longitude: i,
      latitude: o,
      pitch: c
    } = e, l = t.x * x_, _ = (1 - t.y) * x_, b = t.z * x_, w = xp([i, o]), T = l - w[0], I = _ - w[1], P = Math.sqrt(T * T + I * I), k = c * s8, U = 1.5 * r, G = k < 1e-3 ? U * Math.cos(k) / b : U * Math.sin(k) / P;
    e.zoom = Math.log2(G);
    const H = U * Math.cos(k) / G, $ = b - H;
    e.position = [0, 0, $ / Zg(o)];
  } else typeof n.transform.elevation == "number" && (e.position = [0, 0, n.transform.elevation]);
}
function wE(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return new kh({
    id: "mapbox",
    x: 0,
    y: 0,
    width: n.width,
    height: n.height,
    ...hb(e),
    nearZMultiplier: t ? 0.02 : 0.1,
    nearZ: e.transform._nearZ / e.transform.height,
    farZ: e.transform._farZ / e.transform.height
  });
}
function p8(n, e) {
  const {
    mapboxLayers: t,
    isExternal: r
  } = n.userData;
  if (r) {
    const i = Array.from(t, (w) => w.id), c = jm(n.props.layers, Boolean).some((w) => w && !i.includes(w.id));
    let l = n.getViewports();
    const _ = l.findIndex((w) => w.id === "mapbox"), b = l.length > 1 || _ < 0;
    (c || b) && (_ >= 0 && (l = l.slice(), l[_] = wE(n, e, !1)), n._drawLayers("mapbox-repaint", {
      viewports: l,
      layerFilter: (w) => (!n.props.layerFilter || n.props.layerFilter(w)) && (w.viewport.id !== "mapbox" || !i.includes(w.layer.id)),
      clearCanvas: !1
    }));
  }
  n.userData.currentViewport = null;
}
function g8(n, e) {
  n.setProps({
    viewState: hb(e)
  }), n.needsRedraw({
    clearRedrawFlags: !0
  });
}
function db(n) {
  if (n.userData.isExternal)
    return;
  const e = [];
  n.userData.mapboxLayers.forEach((t) => {
    const r = t.props.type, i = new r(t.props);
    e.push(i);
  }), n.setProps({
    layers: e
  });
}
class m8 {
  constructor(e) {
    if (V(this, "id", void 0), V(this, "type", void 0), V(this, "renderingMode", void 0), V(this, "map", void 0), V(this, "deck", void 0), V(this, "props", void 0), !e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.map = null, this.deck = null, this.props = e;
  }
  onAdd(e, t) {
    this.map = e, this.deck = o8({
      map: e,
      gl: t,
      deck: this.props.deck
    }), c8(this.deck, this);
  }
  onRemove() {
    this.deck && u8(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, {
      id: this.id
    }), this.deck && h8(this.deck);
  }
  render() {
    d8(this.deck, this.map, this);
  }
}
const _8 = `#define SHADER_NAME point-cloud-layer-vertex-shader

attribute vec3 positions;
attribute vec3 instanceNormals;
attribute vec4 instanceColors;
attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.normal = project_normal(instanceNormals);
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;
  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
  DECKGL_FILTER_SIZE(offset, geometry);

  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
  vColor = vec4(lightColor, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, y8 = `#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  }

  gl_FragColor = vColor;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`, AE = [0, 0, 0, 255], SE = [0, 0, 1], b8 = {
  sizeUnits: "pixels",
  pointSize: {
    type: "number",
    min: 0,
    value: 10
  },
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getNormal: {
    type: "accessor",
    value: SE
  },
  getColor: {
    type: "accessor",
    value: AE
  },
  material: !0,
  radiusPixels: {
    deprecatedFor: "pointSize"
  }
};
function v8(n) {
  const {
    header: e,
    attributes: t
  } = n;
  !e || !t || (n.length = e.vertexCount, t.POSITION && (t.instancePositions = t.POSITION), t.NORMAL && (t.instanceNormals = t.NORMAL), t.COLOR_0 && (t.instanceColors = t.COLOR_0));
}
class fb extends sf {
  getShaders() {
    return super.getShaders({
      vs: _8,
      fs: y8,
      modules: [nb, jO, rb]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: SE
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: !0,
        transition: !0,
        accessor: "getColor",
        defaultValue: AE
      }
    });
  }
  updateState(e) {
    const {
      changeFlags: t,
      props: r
    } = e;
    if (super.updateState(e), t.extensionsChanged) {
      var i;
      const {
        gl: o
      } = this.context;
      (i = this.state.model) === null || i === void 0 || i.delete(), this.state.model = this._getModel(o), this.getAttributeManager().invalidateAll();
    }
    t.dataChanged && v8(r.data);
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    const {
      pointSize: r,
      sizeUnits: i
    } = this.props;
    this.state.model.setUniforms(t).setUniforms({
      sizeUnits: py[i],
      radiusPixels: r
    }).draw();
  }
  _getModel(e) {
    const t = [];
    for (let r = 0; r < 3; r++) {
      const i = r / 3 * Math.PI * 2;
      t.push(Math.cos(i) * 2, Math.sin(i) * 2, 0);
    }
    return new Jd(e, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new hp({
        drawMode: 4,
        attributes: {
          positions: new Float32Array(t)
        }
      }),
      isInstanced: !0
    });
  }
}
V(fb, "layerName", "PointCloudLayer");
V(fb, "defaultProps", b8);
const ba = {
  OUTSIDE: -1,
  INTERSECTING: 0,
  INSIDE: 1
};
new Ke();
new Ke();
const Hf = new Ke(), vw = new Ke();
class Vp {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    V(this, "center", void 0), V(this, "radius", void 0), this.radius = -0, this.center = new Ke(), this.fromCenterRadius(e, t);
  }
  fromCenterRadius(e, t) {
    return this.center.from(e), this.radius = t, this;
  }
  fromCornerPoints(e, t) {
    return t = Hf.from(t), this.center = new Ke().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
  }
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  clone() {
    return new Vp(this.center, this.radius);
  }
  union(e) {
    const t = this.center, r = this.radius, i = e.center, o = e.radius, c = Hf.copy(i).subtract(t), l = c.magnitude();
    if (r >= l + o)
      return this.clone();
    if (o >= l + r)
      return e.clone();
    const _ = (r + l + o) * 0.5;
    return vw.copy(c).scale((-r + _) / l).add(t), this.center.copy(vw), this.radius = _, this;
  }
  expand(e) {
    const r = Hf.from(e).subtract(this.center).magnitude();
    return r > this.radius && (this.radius = r), this;
  }
  transform(e) {
    this.center.transform(e);
    const t = $6(Hf, e);
    return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
  }
  distanceSquaredTo(e) {
    const t = this.distanceTo(e);
    return t * t;
  }
  distanceTo(e) {
    const r = Hf.from(e).subtract(this.center);
    return Math.max(0, r.len() - this.radius);
  }
  intersectPlane(e) {
    const t = this.center, r = this.radius, o = e.normal.dot(t) + e.distance;
    return o < -r ? ba.OUTSIDE : o < r ? ba.INTERSECTING : ba.INSIDE;
  }
}
const x8 = new Ke(), w8 = new Ke(), Ig = new Ke(), Pg = new Ke(), Lg = new Ke(), A8 = new Ke(), S8 = new Ke(), $c = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class qp {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    V(this, "center", void 0), V(this, "halfAxes", void 0), this.center = new Ke().from(e), this.halfAxes = new Ci(t);
  }
  get halfSize() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), r = this.halfAxes.getColumn(2);
    return [new Ke(e).len(), new Ke(t).len(), new Ke(r).len()];
  }
  get quaternion() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), r = this.halfAxes.getColumn(2), i = new Ke(e).normalize(), o = new Ke(t).normalize(), c = new Ke(r).normalize();
    return new bp().fromMatrix3(new Ci([...i, ...o, ...c]));
  }
  fromCenterHalfSizeQuaternion(e, t, r) {
    const i = new bp(r), o = new Ci().fromQuaternion(i);
    return o[0] = o[0] * t[0], o[1] = o[1] * t[0], o[2] = o[2] * t[0], o[3] = o[3] * t[1], o[4] = o[4] * t[1], o[5] = o[5] * t[1], o[6] = o[6] * t[2], o[7] = o[7] * t[2], o[8] = o[8] * t[2], this.center = new Ke().from(e), this.halfAxes = o, this;
  }
  clone() {
    return new qp(this.center, this.halfAxes);
  }
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  getBoundingSphere() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Vp();
    const t = this.halfAxes, r = t.getColumn(0, Ig), i = t.getColumn(1, Pg), o = t.getColumn(2, Lg), c = x8.copy(r).add(i).add(o);
    return e.center.copy(this.center), e.radius = c.magnitude(), e;
  }
  intersectPlane(e) {
    const t = this.center, r = e.normal, i = this.halfAxes, o = r.x, c = r.y, l = r.z, _ = Math.abs(o * i[$c.COLUMN0ROW0] + c * i[$c.COLUMN0ROW1] + l * i[$c.COLUMN0ROW2]) + Math.abs(o * i[$c.COLUMN1ROW0] + c * i[$c.COLUMN1ROW1] + l * i[$c.COLUMN1ROW2]) + Math.abs(o * i[$c.COLUMN2ROW0] + c * i[$c.COLUMN2ROW1] + l * i[$c.COLUMN2ROW2]), b = r.dot(t) + e.distance;
    return b <= -_ ? ba.OUTSIDE : b >= _ ? ba.INSIDE : ba.INTERSECTING;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  distanceSquaredTo(e) {
    const t = w8.from(e).subtract(this.center), r = this.halfAxes, i = r.getColumn(0, Ig), o = r.getColumn(1, Pg), c = r.getColumn(2, Lg), l = i.magnitude(), _ = o.magnitude(), b = c.magnitude();
    i.normalize(), o.normalize(), c.normalize();
    let w = 0, T;
    return T = Math.abs(t.dot(i)) - l, T > 0 && (w += T * T), T = Math.abs(t.dot(o)) - _, T > 0 && (w += T * T), T = Math.abs(t.dot(c)) - b, T > 0 && (w += T * T), w;
  }
  computePlaneDistances(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [-0, -0], i = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY;
    const c = this.center, l = this.halfAxes, _ = l.getColumn(0, Ig), b = l.getColumn(1, Pg), w = l.getColumn(2, Lg), T = A8.copy(_).add(b).add(w).add(c), I = S8.copy(T).subtract(e);
    let P = t.dot(I);
    return i = Math.min(P, i), o = Math.max(P, o), T.copy(c).add(_).add(b).subtract(w), I.copy(T).subtract(e), P = t.dot(I), i = Math.min(P, i), o = Math.max(P, o), T.copy(c).add(_).subtract(b).add(w), I.copy(T).subtract(e), P = t.dot(I), i = Math.min(P, i), o = Math.max(P, o), T.copy(c).add(_).subtract(b).subtract(w), I.copy(T).subtract(e), P = t.dot(I), i = Math.min(P, i), o = Math.max(P, o), c.copy(T).subtract(_).add(b).add(w), I.copy(T).subtract(e), P = t.dot(I), i = Math.min(P, i), o = Math.max(P, o), c.copy(T).subtract(_).add(b).subtract(w), I.copy(T).subtract(e), P = t.dot(I), i = Math.min(P, i), o = Math.max(P, o), c.copy(T).subtract(_).subtract(b).add(w), I.copy(T).subtract(e), P = t.dot(I), i = Math.min(P, i), o = Math.max(P, o), c.copy(T).subtract(_).subtract(b).subtract(w), I.copy(T).subtract(e), P = t.dot(I), i = Math.min(P, i), o = Math.max(P, o), r[0] = i, r[1] = o, r;
  }
  transform(e) {
    this.center.transformAsPoint(e);
    const t = this.halfAxes.getColumn(0, Ig);
    t.transformAsPoint(e);
    const r = this.halfAxes.getColumn(1, Pg);
    r.transformAsPoint(e);
    const i = this.halfAxes.getColumn(2, Lg);
    return i.transformAsPoint(e), this.halfAxes = new Ci([...t, ...r, ...i]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const xw = new Ke(), ww = new Ke();
class bl {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 1], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    V(this, "normal", void 0), V(this, "distance", void 0), this.normal = new Ke(), this.distance = -0, this.fromNormalDistance(e, t);
  }
  fromNormalDistance(e, t) {
    return vl(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
  }
  fromPointNormal(e, t) {
    e = xw.from(e), this.normal.from(t).normalize();
    const r = -this.normal.dot(e);
    return this.distance = r, this;
  }
  fromCoefficients(e, t, r, i) {
    return this.normal.set(e, t, r), vl(Sl(this.normal.len(), 1)), this.distance = i, this;
  }
  clone() {
    return new bl(this.normal, this.distance);
  }
  equals(e) {
    return Sl(this.distance, e.distance) && Sl(this.normal, e.normal);
  }
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  transform(e) {
    const t = ww.copy(this.normal).transformAsVector(e).normalize(), r = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(r, t);
  }
  projectPointOntoPlane(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    e = xw.from(e);
    const r = this.getPointDistance(e), i = ww.copy(this.normal).scale(r);
    return e.subtract(i).to(t);
  }
}
const Aw = [new Ke([1, 0, 0]), new Ke([0, 1, 0]), new Ke([0, 0, 1])], Sw = new Ke(), E8 = new Ke();
new bl(new Ke(1, 0, 0), 0);
class Xa {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    V(this, "planes", void 0), this.planes = e;
  }
  fromBoundingSphere(e) {
    this.planes.length = 2 * Aw.length;
    const t = e.center, r = e.radius;
    let i = 0;
    for (const o of Aw) {
      let c = this.planes[i], l = this.planes[i + 1];
      c || (c = this.planes[i] = new bl()), l || (l = this.planes[i + 1] = new bl());
      const _ = Sw.copy(o).scale(-r).add(t);
      -o.dot(_), c.fromPointNormal(_, o);
      const b = Sw.copy(o).scale(r).add(t), w = E8.copy(o).negate();
      -w.dot(b), l.fromPointNormal(b, w), i += 2;
    }
    return this;
  }
  computeVisibility(e) {
    let t = ba.INSIDE;
    for (const r of this.planes)
      switch (e.intersectPlane(r)) {
        case ba.OUTSIDE:
          return ba.OUTSIDE;
        case ba.INTERSECTING:
          t = ba.INTERSECTING;
          break;
      }
    return t;
  }
  computeVisibilityWithPlaneMask(e, t) {
    if (vl(Number.isFinite(t), "parentPlaneMask is required."), t === Xa.MASK_OUTSIDE || t === Xa.MASK_INSIDE)
      return t;
    let r = Xa.MASK_INSIDE;
    const i = this.planes;
    for (let o = 0; o < this.planes.length; ++o) {
      const c = o < 31 ? 1 << o : 0;
      if (o < 31 && !(t & c))
        continue;
      const l = i[o], _ = e.intersectPlane(l);
      if (_ === ba.OUTSIDE)
        return Xa.MASK_OUTSIDE;
      _ === ba.INTERSECTING && (r |= c);
    }
    return r;
  }
}
V(Xa, "MASK_OUTSIDE", 4294967295);
V(Xa, "MASK_INSIDE", 0);
V(Xa, "MASK_INDETERMINATE", 2147483647);
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
new Ke();
const fc = new Ci(), T8 = new Ci(), C8 = new Ci(), Mg = new Ci(), Ew = new Ci();
function I8(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = vp.EPSILON20, r = 10;
  let i = 0, o = 0;
  const c = T8, l = C8;
  c.identity(), l.copy(n);
  const _ = t * P8(l);
  for (; o < r && L8(l) > _; )
    M8(l, Mg), Ew.copy(Mg).transpose(), l.multiplyRight(Mg), l.multiplyLeft(Ew), c.multiplyRight(Mg), ++i > 2 && (++o, i = 0);
  return e.unitary = c.toTarget(e.unitary), e.diagonal = l.toTarget(e.diagonal), e;
}
function P8(n) {
  let e = 0;
  for (let t = 0; t < 9; ++t) {
    const r = n[t];
    e += r * r;
  }
  return Math.sqrt(e);
}
const ky = [1, 0, 0], Ny = [2, 2, 1];
function L8(n) {
  let e = 0;
  for (let t = 0; t < 3; ++t) {
    const r = n[fc.getElementIndex(Ny[t], ky[t])];
    e += 2 * r * r;
  }
  return Math.sqrt(e);
}
function M8(n, e) {
  const t = vp.EPSILON15;
  let r = 0, i = 1;
  for (let b = 0; b < 3; ++b) {
    const w = Math.abs(n[fc.getElementIndex(Ny[b], ky[b])]);
    w > r && (i = b, r = w);
  }
  const o = ky[i], c = Ny[i];
  let l = 1, _ = 0;
  if (Math.abs(n[fc.getElementIndex(c, o)]) > t) {
    const b = n[fc.getElementIndex(c, c)], w = n[fc.getElementIndex(o, o)], T = n[fc.getElementIndex(c, o)], I = (b - w) / 2 / T;
    let P;
    I < 0 ? P = -1 / (-I + Math.sqrt(1 + I * I)) : P = 1 / (I + Math.sqrt(1 + I * I)), l = 1 / Math.sqrt(1 + P * P), _ = P * l;
  }
  return Ci.IDENTITY.to(e), e[fc.getElementIndex(o, o)] = e[fc.getElementIndex(c, c)] = l, e[fc.getElementIndex(c, o)] = _, e[fc.getElementIndex(o, c)] = -_, e;
}
const Ou = new Ke(), B8 = new Ke(), R8 = new Ke(), O8 = new Ke(), D8 = new Ke(), F8 = new Ci(), k8 = {
  diagonal: new Ci(),
  unitary: new Ci()
};
function N8(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new qp();
  if (!n || n.length === 0)
    return e.halfAxes = new Ci([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Ke(), e;
  const t = n.length, r = new Ke(0, 0, 0);
  for (const Ge of n)
    r.add(Ge);
  const i = 1 / t;
  r.multiplyByScalar(i);
  let o = 0, c = 0, l = 0, _ = 0, b = 0, w = 0;
  for (const Ge of n) {
    const ke = Ou.copy(Ge).subtract(r);
    o += ke.x * ke.x, c += ke.x * ke.y, l += ke.x * ke.z, _ += ke.y * ke.y, b += ke.y * ke.z, w += ke.z * ke.z;
  }
  o *= i, c *= i, l *= i, _ *= i, b *= i, w *= i;
  const T = F8;
  T[0] = o, T[1] = c, T[2] = l, T[3] = c, T[4] = _, T[5] = b, T[6] = l, T[7] = b, T[8] = w;
  const {
    unitary: I
  } = I8(T, k8), P = e.halfAxes.copy(I);
  let k = P.getColumn(0, R8), U = P.getColumn(1, O8), G = P.getColumn(2, D8), H = -Number.MAX_VALUE, $ = -Number.MAX_VALUE, ie = -Number.MAX_VALUE, ge = Number.MAX_VALUE, Se = Number.MAX_VALUE, Re = Number.MAX_VALUE;
  for (const Ge of n)
    Ou.copy(Ge), H = Math.max(Ou.dot(k), H), $ = Math.max(Ou.dot(U), $), ie = Math.max(Ou.dot(G), ie), ge = Math.min(Ou.dot(k), ge), Se = Math.min(Ou.dot(U), Se), Re = Math.min(Ou.dot(G), Re);
  k = k.multiplyByScalar(0.5 * (ge + H)), U = U.multiplyByScalar(0.5 * (Se + $)), G = G.multiplyByScalar(0.5 * (Re + ie)), e.center.copy(k).add(U).add(G);
  const Le = B8.set(H - ge, $ - Se, ie - Re).multiplyByScalar(0.5), _e = new Ci([Le[0], 0, 0, 0, Le[1], 0, 0, 0, Le[2]]);
  return e.halfAxes.multiplyRight(_e), e;
}
const w_ = Math.PI / 180, Bg = new Float32Array(16), Tw = new Float32Array(12);
function Cw(n, e, t) {
  const r = e[0] * w_, i = e[1] * w_, o = e[2] * w_, c = Math.sin(o), l = Math.sin(r), _ = Math.sin(i), b = Math.cos(o), w = Math.cos(r), T = Math.cos(i), I = t[0], P = t[1], k = t[2];
  n[0] = I * T * w, n[1] = I * _ * w, n[2] = I * -l, n[3] = P * (-_ * b + T * l * c), n[4] = P * (T * b + _ * l * c), n[5] = P * w * c, n[6] = k * (_ * c + T * l * b), n[7] = k * (-T * c + _ * l * b), n[8] = k * w * b;
}
function Iw(n) {
  return n[0] = n[0], n[1] = n[1], n[2] = n[2], n[3] = n[4], n[4] = n[5], n[5] = n[6], n[6] = n[8], n[7] = n[9], n[8] = n[10], n[9] = n[12], n[10] = n[13], n[11] = n[14], n.subarray(0, 12);
}
const EE = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrix__LOCATION_0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrix__LOCATION_1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrix__LOCATION_2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(n, e) {
    let {
      startRow: t,
      endRow: r
    } = e;
    const {
      data: i,
      getOrientation: o,
      getScale: c,
      getTranslation: l,
      getTransformMatrix: _
    } = this.props, b = Array.isArray(_), w = b && _.length === 16, T = Array.isArray(c), I = Array.isArray(o), P = Array.isArray(l), k = w || !b && !!_(i[0]);
    k ? n.constant = w : n.constant = I && T && P;
    const U = n.value;
    if (n.constant) {
      let G;
      k ? (Bg.set(_), G = Iw(Bg)) : (G = Tw, Cw(G, o, c), G.set(l, 9)), n.value = new Float32Array(G);
    } else {
      let G = t * n.size;
      const {
        iterable: H,
        objectInfo: $
      } = dE(i, t, r);
      for (const ie of H) {
        $.index++;
        let ge;
        if (k)
          Bg.set(w ? _ : _(ie, $)), ge = Iw(Bg);
        else {
          ge = Tw;
          const Se = I ? o : o(ie, $), Re = T ? c : c(ie, $);
          Cw(ge, Se, Re), ge.set(P ? l : l(ie, $), 9);
        }
        U[G++] = ge[0], U[G++] = ge[1], U[G++] = ge[2], U[G++] = ge[3], U[G++] = ge[4], U[G++] = ge[5], U[G++] = ge[6], U[G++] = ge[7], U[G++] = ge[8], U[G++] = ge[9], U[G++] = ge[10], U[G++] = ge[11];
      }
    }
  }
};
function TE(n, e) {
  return e === cr.CARTESIAN || e === cr.METER_OFFSETS || e === cr.DEFAULT && !n.isGeospatial;
}
const z8 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;

  if (composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    normals_commonspace = project_normal(instanceModelMatrix * normals);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
    geometry.position = position_commonspace;
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
    geometry.position = position_commonspace;
    normals_commonspace = project_normal(instanceModelMatrix * normals);
  }

  geometry.normal = normals_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, U8 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  DECKGL_FILTER_COLOR(color, geometry);

  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);
}
`;
function CE(n) {
  let e = 1 / 0, t = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, c = -1 / 0;
  const l = n.POSITION ? n.POSITION.value : [], _ = l && l.length;
  for (let b = 0; b < _; b += 3) {
    const w = l[b], T = l[b + 1], I = l[b + 2];
    e = w < e ? w : e, t = T < t ? T : t, r = I < r ? I : r, i = w > i ? w : i, o = T > o ? T : o, c = I > c ? I : c;
  }
  return [[e, t, r], [i, o, c]];
}
function j8(n, e) {
  if (!n)
    throw new Error("loader assertion failed.");
}
class Bd {
  constructor(e, t) {
    V(this, "fields", void 0), V(this, "metadata", void 0), j8(Array.isArray(e)), G8(e), this.fields = e, this.metadata = t || /* @__PURE__ */ new Map();
  }
  compareTo(e) {
    if (this.metadata !== e.metadata || this.fields.length !== e.fields.length)
      return !1;
    for (let t = 0; t < this.fields.length; ++t)
      if (!this.fields[t].compareTo(e.fields[t]))
        return !1;
    return !0;
  }
  select() {
    const e = /* @__PURE__ */ Object.create(null);
    for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
      r[i] = arguments[i];
    for (const c of r)
      e[c] = !0;
    const o = this.fields.filter((c) => e[c.name]);
    return new Bd(o, this.metadata);
  }
  selectAt() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    const i = t.map((o) => this.fields[o]).filter(Boolean);
    return new Bd(i, this.metadata);
  }
  assign(e) {
    let t, r = this.metadata;
    if (e instanceof Bd) {
      const c = e;
      t = c.fields, r = Pw(Pw(/* @__PURE__ */ new Map(), this.metadata), c.metadata);
    } else
      t = e;
    const i = /* @__PURE__ */ Object.create(null);
    for (const c of this.fields)
      i[c.name] = c;
    for (const c of t)
      i[c.name] = c;
    const o = Object.values(i);
    return new Bd(o, r);
  }
}
function G8(n) {
  const e = {};
  for (const t of n)
    e[t.name] && console.warn("Schema: duplicated field name", t.name, t), e[t.name] = !0;
}
function Pw(n, e) {
  return new Map([...n || /* @__PURE__ */ new Map(), ...e || /* @__PURE__ */ new Map()]);
}
class Cm {
  constructor(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
    V(this, "name", void 0), V(this, "type", void 0), V(this, "nullable", void 0), V(this, "metadata", void 0), this.name = e, this.type = t, this.nullable = r, this.metadata = i;
  }
  get typeId() {
    return this.type && this.type.typeId;
  }
  clone() {
    return new Cm(this.name, this.type, this.nullable, this.metadata);
  }
  compareTo(e) {
    return this.name === e.name && this.type === e.type && this.nullable === e.nullable && this.metadata === e.metadata;
  }
  toString() {
    return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
  }
}
let Ei = function(n) {
  return n[n.NONE = 0] = "NONE", n[n.Null = 1] = "Null", n[n.Int = 2] = "Int", n[n.Float = 3] = "Float", n[n.Binary = 4] = "Binary", n[n.Utf8 = 5] = "Utf8", n[n.Bool = 6] = "Bool", n[n.Decimal = 7] = "Decimal", n[n.Date = 8] = "Date", n[n.Time = 9] = "Time", n[n.Timestamp = 10] = "Timestamp", n[n.Interval = 11] = "Interval", n[n.List = 12] = "List", n[n.Struct = 13] = "Struct", n[n.Union = 14] = "Union", n[n.FixedSizeBinary = 15] = "FixedSizeBinary", n[n.FixedSizeList = 16] = "FixedSizeList", n[n.Map = 17] = "Map", n[n.Dictionary = -1] = "Dictionary", n[n.Int8 = -2] = "Int8", n[n.Int16 = -3] = "Int16", n[n.Int32 = -4] = "Int32", n[n.Int64 = -5] = "Int64", n[n.Uint8 = -6] = "Uint8", n[n.Uint16 = -7] = "Uint16", n[n.Uint32 = -8] = "Uint32", n[n.Uint64 = -9] = "Uint64", n[n.Float16 = -10] = "Float16", n[n.Float32 = -11] = "Float32", n[n.Float64 = -12] = "Float64", n[n.DateDay = -13] = "DateDay", n[n.DateMillisecond = -14] = "DateMillisecond", n[n.TimestampSecond = -15] = "TimestampSecond", n[n.TimestampMillisecond = -16] = "TimestampMillisecond", n[n.TimestampMicrosecond = -17] = "TimestampMicrosecond", n[n.TimestampNanosecond = -18] = "TimestampNanosecond", n[n.TimeSecond = -19] = "TimeSecond", n[n.TimeMillisecond = -20] = "TimeMillisecond", n[n.TimeMicrosecond = -21] = "TimeMicrosecond", n[n.TimeNanosecond = -22] = "TimeNanosecond", n[n.DenseUnion = -23] = "DenseUnion", n[n.SparseUnion = -24] = "SparseUnion", n[n.IntervalDayTime = -25] = "IntervalDayTime", n[n.IntervalYearMonth = -26] = "IntervalYearMonth", n;
}({}), IE, PE, LE;
class pb {
  static isNull(e) {
    return e && e.typeId === Ei.Null;
  }
  static isInt(e) {
    return e && e.typeId === Ei.Int;
  }
  static isFloat(e) {
    return e && e.typeId === Ei.Float;
  }
  static isBinary(e) {
    return e && e.typeId === Ei.Binary;
  }
  static isUtf8(e) {
    return e && e.typeId === Ei.Utf8;
  }
  static isBool(e) {
    return e && e.typeId === Ei.Bool;
  }
  static isDecimal(e) {
    return e && e.typeId === Ei.Decimal;
  }
  static isDate(e) {
    return e && e.typeId === Ei.Date;
  }
  static isTime(e) {
    return e && e.typeId === Ei.Time;
  }
  static isTimestamp(e) {
    return e && e.typeId === Ei.Timestamp;
  }
  static isInterval(e) {
    return e && e.typeId === Ei.Interval;
  }
  static isList(e) {
    return e && e.typeId === Ei.List;
  }
  static isStruct(e) {
    return e && e.typeId === Ei.Struct;
  }
  static isUnion(e) {
    return e && e.typeId === Ei.Union;
  }
  static isFixedSizeBinary(e) {
    return e && e.typeId === Ei.FixedSizeBinary;
  }
  static isFixedSizeList(e) {
    return e && e.typeId === Ei.FixedSizeList;
  }
  static isMap(e) {
    return e && e.typeId === Ei.Map;
  }
  static isDictionary(e) {
    return e && e.typeId === Ei.Dictionary;
  }
  get typeId() {
    return Ei.NONE;
  }
  compareTo(e) {
    return this === e;
  }
}
IE = Symbol.toStringTag;
class of extends pb {
  constructor(e, t) {
    super(), V(this, "isSigned", void 0), V(this, "bitWidth", void 0), this.isSigned = e, this.bitWidth = t;
  }
  get typeId() {
    return Ei.Int;
  }
  get [IE]() {
    return "Int";
  }
  toString() {
    return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
  }
}
class V8 extends of {
  constructor() {
    super(!0, 8);
  }
}
class q8 extends of {
  constructor() {
    super(!0, 16);
  }
}
class H8 extends of {
  constructor() {
    super(!0, 32);
  }
}
class W8 extends of {
  constructor() {
    super(!1, 8);
  }
}
class X8 extends of {
  constructor() {
    super(!1, 16);
  }
}
class $8 extends of {
  constructor() {
    super(!1, 32);
  }
}
const ME = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
PE = Symbol.toStringTag;
class BE extends pb {
  constructor(e) {
    super(), V(this, "precision", void 0), this.precision = e;
  }
  get typeId() {
    return Ei.Float;
  }
  get [PE]() {
    return "Float";
  }
  toString() {
    return "Float".concat(this.precision);
  }
}
class Z8 extends BE {
  constructor() {
    super(ME.SINGLE);
  }
}
class J8 extends BE {
  constructor() {
    super(ME.DOUBLE);
  }
}
LE = Symbol.toStringTag;
class Y8 extends pb {
  constructor(e, t) {
    super(), V(this, "listSize", void 0), V(this, "children", void 0), this.listSize = e, this.children = [t];
  }
  get typeId() {
    return Ei.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get [LE]() {
    return "FixedSizeList";
  }
  toString() {
    return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
  }
}
function K8(n) {
  switch (n.constructor) {
    case Int8Array:
      return new V8();
    case Uint8Array:
      return new W8();
    case Int16Array:
      return new q8();
    case Uint16Array:
      return new X8();
    case Int32Array:
      return new H8();
    case Uint32Array:
      return new $8();
    case Float32Array:
      return new Z8();
    case Float64Array:
      return new J8();
    default:
      throw new Error("array type not supported");
  }
}
function Q8(n, e, t) {
  const r = K8(e.value), i = t || ez(e);
  return new Cm(n, new Y8(e.size, new Cm("value", r)), !1, i);
}
function ez(n) {
  const e = /* @__PURE__ */ new Map();
  return "byteOffset" in n && e.set("byteOffset", n.byteOffset.toString(10)), "byteStride" in n && e.set("byteStride", n.byteStride.toString(10)), "normalized" in n && e.set("normalized", n.normalized.toString()), e;
}
function Lw(n, e) {
  (n.COLOR_0 || n.colors) && e || (n.colors = {
    constant: !0,
    value: new Float32Array([1, 1, 1])
  }), ur.assert(n.positions || n.POSITION, 'no "postions" or "POSITION" attribute in mesh');
}
function Mw(n, e) {
  if (n.attributes)
    return Lw(n.attributes, e), n instanceof hp ? n : new hp(n);
  if (n.positions || n.POSITION)
    return Lw(n, e), new hp({
      attributes: n
    });
  throw Error("Invalid mesh");
}
const tz = [0, 0, 0, 255], nz = {
  mesh: {
    type: "object",
    value: null,
    async: !0
  },
  texture: {
    type: "image",
    value: null,
    async: !0
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  _useMeshColors: {
    type: "boolean",
    value: !1
  },
  _instanced: !0,
  wireframe: !1,
  material: !0,
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getColor: {
    type: "accessor",
    value: tz
  },
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: !0
  }
};
class gb extends sf {
  constructor() {
    super(...arguments), V(this, "state", void 0);
  }
  getShaders() {
    const e = !tr(this.context.gl), t = {};
    return F1(this.context.gl, ei.GLSL_DERIVATIVES) && (t.DERIVATIVES_AVAILABLE = 1), super.getShaders({
      vs: z8,
      fs: U8,
      modules: [nb, GO, rb],
      transpileToGLSL100: e,
      defines: t
    });
  }
  getBounds() {
    var e;
    if (this.props._instanced)
      return super.getBounds();
    let t = this.state.positionBounds;
    if (t)
      return t;
    const {
      mesh: r
    } = this.props;
    if (!r)
      return null;
    if (t = (e = r.header) === null || e === void 0 ? void 0 : e.boundingBox, !t) {
      const {
        attributes: i
      } = Mw(r, this.props._useMeshColors);
      i.POSITION = i.POSITION || i.positions, t = CE(i);
    }
    return this.state.positionBounds = t, t;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: 5130,
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: 5121,
        transition: !0,
        size: this.props.colorFormat.length,
        normalized: !0,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: EE
    }), this.setState({
      emptyTexture: new Aa(this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: r,
      changeFlags: i
    } = e;
    if (t.mesh !== r.mesh || i.extensionsChanged) {
      var o;
      if (this.state.positionBounds = null, (o = this.state.model) === null || o === void 0 || o.delete(), t.mesh) {
        this.state.model = this.getModel(t.mesh);
        const c = t.mesh.attributes || t.mesh;
        this.setState({
          hasNormals: !!(c.NORMAL || c.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    t.texture !== r.texture && this.setTexture(t.texture), this.state.model && this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    if (!this.state.model)
      return;
    const {
      viewport: r
    } = this.context, {
      sizeScale: i,
      coordinateSystem: o,
      _instanced: c
    } = this.props;
    this.state.model.setUniforms(t).setUniforms({
      sizeScale: i,
      composeModelMatrix: !c || TE(r, o),
      flatShading: !this.state.hasNormals
    }).draw();
  }
  get isLoaded() {
    var e;
    return ((e = this.state) === null || e === void 0 ? void 0 : e.model) && super.isLoaded;
  }
  getModel(e) {
    const t = new Jd(this.context.gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: Mw(e, this.props._useMeshColors),
      isInstanced: !0
    }), {
      texture: r
    } = this.props, {
      emptyTexture: i
    } = this.state;
    return t.setUniforms({
      sampler: r || i,
      hasTexture: !!r
    }), t;
  }
  setTexture(e) {
    const {
      emptyTexture: t,
      model: r
    } = this.state;
    r && r.setUniforms({
      sampler: e || t,
      hasTexture: !!e
    });
  }
}
V(gb, "defaultProps", nz);
V(gb, "layerName", "SimpleMeshLayer");
class Nd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t
    } = e;
    this.id = t || ou(this.constructor.name), this.display = !0, this.position = new Ke(), this.rotation = new Ke(), this.scale = new Ke(1, 1, 1), this.matrix = new lr(), this.userData = {}, this.props = {}, this._setScenegraphNodeProps(e);
  }
  delete() {
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
  }
  getBounds() {
    return null;
  }
  setPosition(e) {
    return Zt(e.length === 3, "setPosition requires vector argument"), this.position = e, this;
  }
  setRotation(e) {
    return Zt(e.length === 3, "setRotation requires vector argument"), this.rotation = e, this;
  }
  setScale(e) {
    return Zt(e.length === 3, "setScale requires vector argument"), this.scale = e, this;
  }
  setMatrix(e) {
    (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    let {
      position: t,
      rotation: r,
      scale: i,
      update: o = !0
    } = e;
    return t && this.setPosition(t), r && this.setRotation(r), i && this.setScale(i), o && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, t = this.rotation, r = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(t), this.matrix.scale(r), this;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      position: t,
      rotation: r,
      scale: i
    } = e;
    return t && this.setPosition(t), r && this.setRotation(r), i && this.setScale(i), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, t) {
    Zt(e), t = t || this.matrix;
    const r = new lr(e).multiplyRight(t), i = r.invert(), o = i.transpose();
    return {
      viewMatrix: e,
      modelMatrix: t,
      objectMatrix: t,
      worldMatrix: r,
      worldInverseMatrix: i,
      worldInverseTransposeMatrix: o
    };
  }
  _setScenegraphNodeProps(e) {
    "display" in e && (this.display = e.display), "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class dp extends Nd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e = Array.isArray(e) ? {
      children: e
    } : e;
    const {
      children: t = []
    } = e;
    ln.assert(t.every((r) => r instanceof Nd), "every child must an instance of ScenegraphNode"), super(e), this.children = t;
  }
  add() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    for (const i of t)
      Array.isArray(i) ? this.add(...i) : this.children.push(i);
    return this;
  }
  remove(e) {
    const t = this.children, r = t.indexOf(e);
    return r > -1 && t.splice(r, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  delete() {
    this.children.forEach((e) => e.delete()), this.removeAll(), super.delete();
  }
  getBounds() {
    const e = [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
    return this.traverse((t, r) => {
      let {
        worldMatrix: i
      } = r;
      const o = t.getBounds();
      if (!o)
        return;
      const [c, l] = o, _ = new Ke(c).add(l).divide([2, 2, 2]);
      i.transformAsPoint(_, _);
      const b = new Ke(l).subtract(c).divide([2, 2, 2]);
      i.transformAsVector(b, b);
      for (let w = 0; w < 8; w++) {
        const T = new Ke(w & 1 ? -1 : 1, w & 2 ? -1 : 1, w & 4 ? -1 : 1).multiply(b).add(_);
        for (let I = 0; I < 3; I++)
          e[0][I] = Math.min(e[0][I], T[I]), e[1][I] = Math.max(e[1][I], T[I]);
      }
    }), Number.isFinite(e[0][0]) ? e : null;
  }
  traverse(e) {
    let {
      worldMatrix: t = new lr()
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = new lr(t).multiplyRight(this.matrix);
    for (const i of this.children)
      i instanceof dp ? i.traverse(e, {
        worldMatrix: r
      }) : e(i, {
        worldMatrix: r
      });
  }
}
const rz = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, iz = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function Bw(n) {
  if (!n._animation) {
    const e = iz[n.componentType], t = rz[n.type], r = t * n.count, {
      buffer: i,
      byteOffset: o
    } = n.bufferView.data, c = new e(i, o + (n.byteOffset || 0), r);
    if (t === 1)
      n._animation = Array.from(c);
    else {
      const l = [];
      for (let _ = 0; _ < c.length; _ += t)
        l.push(Array.from(c.slice(_, _ + t)));
      n._animation = l;
    }
  }
  return n._animation;
}
const sz = new lr();
function oz(n, e) {
  if (e.matrix.identity(), n.translation && e.matrix.translate(n.translation), n.rotation) {
    const t = sz.fromQuaternion(n.rotation);
    e.matrix.multiplyRight(t);
  }
  n.scale && e.matrix.scale(n.scale);
}
const A_ = new bp();
function az(n, e, t, r, i) {
  if (e === "rotation") {
    A_.slerp({
      start: t,
      target: r,
      ratio: i
    });
    for (let o = 0; o < A_.length; o++)
      n[e][o] = A_[o];
  } else
    for (let o = 0; o < t.length; o++)
      n[e][o] = i * r[o] + (1 - i) * t[o];
}
function lz(n, e, t) {
  let {
    p0: r,
    outTangent0: i,
    inTangent1: o,
    p1: c,
    tDiff: l,
    ratio: _
  } = t;
  for (let b = 0; b < n[e].length; b++) {
    const w = i[b] * l, T = o[b] * l;
    n[e][b] = (2 * Math.pow(_, 3) - 3 * Math.pow(_, 2) + 1) * r[b] + (Math.pow(_, 3) - 2 * Math.pow(_, 2) + _) * w + (-2 * Math.pow(_, 3) + 3 * Math.pow(_, 2)) * c[b] + (Math.pow(_, 3) - Math.pow(_, 2)) * T;
  }
}
function cz(n, e, t) {
  for (let r = 0; r < t.length; r++)
    n[e][r] = t[r];
}
function uz(n, e, t, r) {
  let {
    input: i,
    interpolation: o,
    output: c
  } = e;
  const l = i[i.length - 1], _ = n % l, b = i.findIndex((P) => P >= _), w = Math.max(0, b - 1);
  if (!Array.isArray(t[r]))
    switch (r) {
      case "translation":
        t[r] = [0, 0, 0];
        break;
      case "rotation":
        t[r] = [0, 0, 0, 1];
        break;
      case "scale":
        t[r] = [1, 1, 1];
        break;
      default:
        ln.warn("Bad animation path ".concat(r))();
    }
  Zt(t[r].length === c[w].length);
  const T = i[w], I = i[b];
  switch (o) {
    case "STEP":
      cz(t, r, c[w]);
      break;
    case "LINEAR":
      if (I > T) {
        const P = (_ - T) / (I - T);
        az(t, r, c[w], c[b], P);
      }
      break;
    case "CUBICSPLINE":
      if (I > T) {
        const P = (_ - T) / (I - T), k = I - T, U = c[3 * w + 1], G = c[3 * w + 2], H = c[3 * b + 0], $ = c[3 * b + 1];
        lz(t, r, {
          p0: U,
          outTangent0: G,
          inTangent1: H,
          p1: $,
          tDiff: k,
          ratio: P
        });
      }
      break;
    default:
      ln.warn("Interpolation ".concat(o, " not supported"))();
      break;
  }
}
class hz {
  constructor(e) {
    this.startTime = 0, this.playing = !0, this.speed = 1, this.channels = [], Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const r = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach((i) => {
      let {
        sampler: o,
        target: c,
        path: l
      } = i;
      uz(r, o, c, l), oz(c, c._node);
    });
  }
}
class dz {
  constructor(e) {
    this.animations = e.animations.map((t, r) => {
      const i = t.name || "Animation-".concat(r), o = t.samplers.map((l) => {
        let {
          input: _,
          interpolation: b = "LINEAR",
          output: w
        } = l;
        return {
          input: Bw(e.accessors[_]),
          interpolation: b,
          output: Bw(e.accessors[w])
        };
      }), c = t.channels.map((l) => {
        let {
          sampler: _,
          target: b
        } = l;
        return {
          sampler: o[_],
          target: e.nodes[b.node],
          path: b.path
        };
      });
      return new hz({
        name: i,
        channels: c
      });
    });
  }
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((t) => t.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
class fz extends Nd {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t), this.onBeforeRender = null, this.AfterRender = null, e instanceof Jd ? (this.model = e, this._setModelNodeProps(t)) : this.model = new Jd(e, t), this.bounds = null, this.managedResources = t.managedResources || [];
  }
  setProps(e) {
    return super.setProps(e), this._setModelNodeProps(e), this;
  }
  getBounds() {
    return this.bounds;
  }
  delete() {
    this.model && (this.model.delete(), this.model = null), this.managedResources.forEach((e) => e.delete()), this.managedResources = [];
  }
  draw() {
    return this.model.draw(...arguments);
  }
  setUniforms() {
    return this.model.setUniforms(...arguments), this;
  }
  setAttributes() {
    return this.model.setAttributes(...arguments), this;
  }
  updateModuleSettings() {
    return this.model.updateModuleSettings(...arguments), this;
  }
  _setModelNodeProps(e) {
    this.model.setProps(e);
  }
}
class RE {
  constructor(e, t) {
    let {
      attributes: r,
      material: i,
      pbrDebug: o,
      imageBasedLightingEnvironment: c,
      lights: l,
      useTangents: _
    } = t;
    this.gl = e, this.defines = {
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    }, F1(e, ei.GLSL_TEXTURE_LOD) && (this.defines.USE_TEX_LOD = 1), this.uniforms = {
      u_Camera: [0, 0, 0],
      u_MetallicRoughnessValues: [1, 1]
    }, this.parameters = {}, this.generatedTextures = [], c && (this.uniforms.u_DiffuseEnvSampler = c.getDiffuseEnvSampler(), this.uniforms.u_SpecularEnvSampler = c.getSpecularEnvSampler(), this.uniforms.u_brdfLUT = c.getBrdfTexture(), this.uniforms.u_ScaleIBLAmbient = [1, 1]), o && (this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0], this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0]), this.defineIfPresent(r.NORMAL, "HAS_NORMALS"), this.defineIfPresent(r.TANGENT && _, "HAS_TANGENTS"), this.defineIfPresent(r.TEXCOORD_0, "HAS_UV"), this.defineIfPresent(c, "USE_IBL"), this.defineIfPresent(l, "USE_LIGHTS"), this.defineIfPresent(o, "PBR_DEBUG"), i && this.parseMaterial(i);
  }
  defineIfPresent(e, t) {
    e && (this.defines[t] = 1);
  }
  parseTexture(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const i = e.texture && e.texture.sampler && e.texture.sampler.parameters || {}, o = e.texture.source.image;
    let c, l = {};
    o.compressed ? (c = o, l = {
      [this.gl.TEXTURE_MIN_FILTER]: o.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
    }) : c = {
      data: o
    };
    const _ = new Aa(this.gl, {
      id: e.name || e.id,
      parameters: {
        ...i,
        ...l
      },
      pixelStore: {
        [this.gl.UNPACK_FLIP_Y_WEBGL]: !1
      },
      ...c
    });
    this.uniforms[t] = _, this.defineIfPresent(r, r), this.generatedTextures.push(_);
  }
  parsePbrMetallicRoughness(e) {
    e.baseColorTexture && this.parseTexture(e.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP"), this.uniforms.u_BaseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && this.parseTexture(e.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
    const {
      metallicFactor: t = 1,
      roughnessFactor: r = 1
    } = e;
    this.uniforms.u_MetallicRoughnessValues = [t, r];
  }
  parseMaterial(e) {
    if (this.uniforms.pbr_uUnlit = !!e.unlit, e.pbrMetallicRoughness && this.parsePbrMetallicRoughness(e.pbrMetallicRoughness), e.normalTexture) {
      this.parseTexture(e.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
      const {
        scale: t = 1
      } = e.normalTexture;
      this.uniforms.u_NormalScale = t;
    }
    if (e.occlusionTexture) {
      this.parseTexture(e.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
      const {
        strength: t = 1
      } = e.occlusionTexture;
      this.uniforms.u_OcclusionStrength = t;
    }
    if (e.emissiveTexture && (this.parseTexture(e.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP"), this.uniforms.u_EmissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode === "MASK") {
      const {
        alphaCutoff: t = 0.5
      } = e;
      this.defines.ALPHA_CUTOFF = 1, this.uniforms.u_AlphaCutoff = t;
    } else e.alphaMode === "BLEND" && (ln.warn("BLEND alphaMode might not work well because it requires mesh sorting")(), Object.assign(this.parameters, {
      blend: !0,
      blendEquation: this.gl.FUNC_ADD,
      blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
    }));
  }
  delete() {
    this.generatedTextures.forEach((e) => e.delete());
  }
}
const pz = `
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  _attr vec4 POSITION;

  #ifdef HAS_NORMALS
    _attr vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    _attr vec2 TEXCOORD_0;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = NORMAL;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = TEXCOORD_0;
    #endif

    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * POSITION;
  }
`, gz = `
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    fragmentColor = pbr_filterColor(vec4(0));
  }
`;
function Rw(n, e) {
  return tr(n) ? `#version 300 es
`.concat(e) : e;
}
function mz(n, e) {
  const {
    id: t,
    drawMode: r,
    vertexCount: i,
    attributes: o,
    modelOptions: c
  } = e, l = new RE(n, e);
  ln.info(4, "createGLTFModel defines: ", l.defines)();
  const _ = [];
  _.push(...l.generatedTextures), _.push(...Object.values(o).map((w) => w.buffer));
  const b = new fz(n, {
    id: t,
    drawMode: r,
    vertexCount: i,
    modules: [Z1],
    parameters: l.parameters,
    vs: Rw(n, pz),
    fs: Rw(n, gz),
    managedResources: _,
    ...c,
    defines: {
      ...l.defines,
      ...c.defines
    }
  });
  return b.setProps({
    attributes: o
  }), b.setUniforms(l.uniforms), b;
}
const _z = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, yz = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class bz {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.options = Object.assign({}, yz, t);
  }
  instantiate(e) {
    return this.gltf = e, (e.scenes || []).map((r) => this.createScene(r));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new dz(this.gltf) : null;
  }
  createScene(e) {
    const r = (e.nodes || []).map((o) => this.createNode(o));
    return new dp({
      id: e.name || e.id,
      children: r
    });
  }
  createNode(e) {
    if (!e._node) {
      const r = (e.children || []).map((o) => this.createNode(o));
      e.mesh && r.push(this.createMesh(e.mesh));
      const i = new dp({
        id: e.name || e.id,
        children: r
      });
      if (e.matrix)
        i.setMatrix(e.matrix);
      else {
        if (i.matrix.identity(), e.translation && i.matrix.translate(e.translation), e.rotation) {
          const o = new lr().fromQuaternion(e.rotation);
          i.matrix.multiplyRight(o);
        }
        e.scale && i.matrix.scale(e.scale);
      }
      e._node = i;
    }
    return e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const r = (e.primitives || []).map((o, c) => this.createPrimitive(o, c, e)), i = new dp({
        id: e.name || e.id,
        children: r
      });
      e._mesh = i;
    }
    return e._mesh;
  }
  getVertexCount(e) {
    ln.warn("getVertexCount() not found")();
  }
  createPrimitive(e, t, r) {
    const i = mz(this.gl, Object.assign({
      id: e.name || "".concat(r.name || r.id, "-primitive-").concat(t),
      drawMode: e.mode || 4,
      vertexCount: e.indices ? e.indices.count : this.getVertexCount(e.attributes),
      attributes: this.createAttributes(e.attributes, e.indices),
      material: e.material
    }, this.options));
    return i.bounds = [e.attributes.POSITION.min, e.attributes.POSITION.max], i;
  }
  createAttributes(e, t) {
    const r = {};
    return Object.keys(e).forEach((i) => {
      r[i] = this.createAccessor(e[i], this.createBuffer(e[i], this.gl.ARRAY_BUFFER));
    }), t && (r.indices = this.createAccessor(t, this.createBuffer(t, this.gl.ELEMENT_ARRAY_BUFFER))), ln.info(4, "glTF Attributes", {
      attributes: e,
      indices: t,
      generated: r
    })(), r;
  }
  createBuffer(e, t) {
    e.bufferView || (e.bufferView = {});
    const {
      bufferView: r
    } = e;
    return r.lumaBuffers || (r.lumaBuffers = {}), r.lumaBuffers[t] || (r.lumaBuffers[t] = new qr(this.gl, {
      id: "from-".concat(r.id),
      data: r.data || e.value,
      target: t
    })), r.lumaBuffers[t];
  }
  createAccessor(e, t) {
    return new Go({
      buffer: t,
      offset: e.byteOffset || 0,
      stride: e.bufferView.byteStride || 0,
      type: e.componentType,
      size: _z[e.type]
    });
  }
  createSampler(e) {
    return e;
  }
  needsPOT() {
    return !1;
  }
}
function vz(n, e, t) {
  const r = new bz(n, t), i = r.instantiate(e), o = r.createAnimator();
  return {
    scenes: i,
    animator: o
  };
}
const xz = "3.4.15", wz = "3.4.15", OE = "3.4.15", Az = "https://unpkg.com/@loaders.gl/textures@".concat(OE, "/dist/libs/basis_encoder.wasm"), Sz = "https://unpkg.com/@loaders.gl/textures@".concat(OE, "/dist/libs/basis_encoder.js");
let S_;
async function Ow(n) {
  const e = n.modules || {};
  return e.basis ? e.basis : (S_ = S_ || Ez(n), await S_);
}
async function Ez(n) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Bh("basis_transcoder.js", "textures", n), await Bh("basis_transcoder.wasm", "textures", n)]), e = e || globalThis.BASIS, await Tz(e, t);
}
function Tz(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((r) => {
    n(t).then((i) => {
      const {
        BasisFile: o,
        initializeBasis: c
      } = i;
      c(), r({
        BasisFile: o
      });
    });
  });
}
let E_;
async function Dw(n) {
  const e = n.modules || {};
  return e.basisEncoder ? e.basisEncoder : (E_ = E_ || Cz(n), await E_);
}
async function Cz(n) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Bh(Sz, "textures", n), await Bh(Az, "textures", n)]), e = e || globalThis.BASIS, await Iz(e, t);
}
function Iz(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((r) => {
    n(t).then((i) => {
      const {
        BasisFile: o,
        KTX2File: c,
        initializeBasis: l,
        BasisEncoder: _
      } = i;
      l(), r({
        BasisFile: o,
        KTX2File: c,
        BasisEncoder: _
      });
    });
  });
}
const vd = {
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
}, Pz = ["", "WEBKIT_", "MOZ_"], Fw = {
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
};
let Rg = null;
function Lz(n) {
  if (!Rg) {
    n = n || Mz() || void 0, Rg = /* @__PURE__ */ new Set();
    for (const e of Pz)
      for (const t in Fw)
        if (n && n.getExtension("".concat(e).concat(t))) {
          const r = Fw[t];
          Rg.add(r);
        }
  }
  return Rg;
}
function Mz() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
var kw, Nw, zw, Uw, jw, Gw, Vw, qw;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.BASISLZ = 1] = "BASISLZ", n[n.ZSTD = 2] = "ZSTD", n[n.ZLIB = 3] = "ZLIB";
})(kw || (kw = {})), function(n) {
  n[n.BASICFORMAT = 0] = "BASICFORMAT";
}(Nw || (Nw = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.ETC1S = 163] = "ETC1S", n[n.UASTC = 166] = "UASTC";
}(zw || (zw = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.SRGB = 1] = "SRGB";
}(Uw || (Uw = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.LINEAR = 1] = "LINEAR", n[n.SRGB = 2] = "SRGB", n[n.ITU = 3] = "ITU", n[n.NTSC = 4] = "NTSC", n[n.SLOG = 5] = "SLOG", n[n.SLOG2 = 6] = "SLOG2";
}(jw || (jw = {})), function(n) {
  n[n.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", n[n.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
}(Gw || (Gw = {})), function(n) {
  n[n.RGB = 0] = "RGB", n[n.RRR = 3] = "RRR", n[n.GGG = 4] = "GGG", n[n.AAA = 15] = "AAA";
}(Vw || (Vw = {})), function(n) {
  n[n.RGB = 0] = "RGB", n[n.RGBA = 3] = "RGBA", n[n.RRR = 4] = "RRR", n[n.RRRG = 5] = "RRRG";
}(qw || (qw = {}));
const ga = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Bz(n) {
  const e = new Uint8Array(n);
  return !(e.byteLength < ga.length || e[0] !== ga[0] || e[1] !== ga[1] || e[2] !== ga[2] || e[3] !== ga[3] || e[4] !== ga[4] || e[5] !== ga[5] || e[6] !== ga[6] || e[7] !== ga[7] || e[8] !== ga[8] || e[9] !== ga[9] || e[10] !== ga[10] || e[11] !== ga[11]);
}
const Rz = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: vd.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: {
    basisFormat: 1,
    compressed: !0
  },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: vd.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: vd.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: {
    basisFormat: 4,
    compressed: !0
  },
  bc5: {
    basisFormat: 5,
    compressed: !0
  },
  "bc7-m6-opaque-only": {
    basisFormat: 6,
    compressed: !0
  },
  "bc7-m5": {
    basisFormat: 7,
    compressed: !0
  },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: vd.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: vd.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: vd.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": {
    basisFormat: 11,
    compressed: !0
  },
  "atc-rgba-interpolated-alpha": {
    basisFormat: 12,
    compressed: !0
  },
  rgba32: {
    basisFormat: 13,
    compressed: !1
  },
  rgb565: {
    basisFormat: 14,
    compressed: !1
  },
  bgr565: {
    basisFormat: 15,
    compressed: !1
  },
  rgba4444: {
    basisFormat: 16,
    compressed: !1
  }
};
async function Oz(n, e) {
  if (e.basis.containerFormat === "auto") {
    if (Bz(n)) {
      const r = await Dw(e);
      return Hw(r.KTX2File, n, e);
    }
    const {
      BasisFile: t
    } = await Ow(e);
    return T_(t, n, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const t = await Dw(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return Hw(t.KTX2File, n, e);
        case "basis":
        default:
          return T_(t.BasisFile, n, e);
      }
    case "transcoder":
    default:
      const {
        BasisFile: r
      } = await Ow(e);
      return T_(r, n, e);
  }
}
function T_(n, e, t) {
  const r = new n(new Uint8Array(e));
  try {
    if (!r.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const i = r.getNumImages(), o = [];
    for (let c = 0; c < i; c++) {
      const l = r.getNumLevels(c), _ = [];
      for (let b = 0; b < l; b++)
        _.push(Dz(r, c, b, t));
      o.push(_);
    }
    return o;
  } finally {
    r.close(), r.delete();
  }
}
function Dz(n, e, t, r) {
  const i = n.getImageWidth(e, t), o = n.getImageHeight(e, t), c = n.getHasAlpha(), {
    compressed: l,
    format: _,
    basisFormat: b
  } = DE(r, c), w = n.getImageTranscodedSizeInBytes(e, t, b), T = new Uint8Array(w);
  if (!n.transcodeImage(T, e, t, b, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    width: i,
    height: o,
    data: T,
    compressed: l,
    format: _,
    hasAlpha: c
  };
}
function Hw(n, e, t) {
  const r = new n(new Uint8Array(e));
  try {
    if (!r.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const i = r.getLevels(), o = [];
    for (let c = 0; c < i; c++) {
      o.push(Fz(r, c, t));
      break;
    }
    return [o];
  } finally {
    r.close(), r.delete();
  }
}
function Fz(n, e, t) {
  const {
    alphaFlag: r,
    height: i,
    width: o
  } = n.getImageLevelInfo(e, 0, 0), {
    compressed: c,
    format: l,
    basisFormat: _
  } = DE(t, r), b = n.getImageTranscodedSizeInBytes(e, 0, 0, _), w = new Uint8Array(b);
  if (!n.transcodeImage(w, e, 0, 0, _, 0, -1, -1))
    throw new Error("Failed to transcode KTX2 image");
  return {
    width: o,
    height: i,
    data: w,
    compressed: c,
    levelSize: b,
    hasAlpha: r,
    format: l
  };
}
function DE(n, e) {
  let t = n && n.basis && n.basis.format;
  return t === "auto" && (t = FE()), typeof t == "object" && (t = e ? t.alpha : t.noAlpha), t = t.toLowerCase(), Rz[t];
}
function FE() {
  const n = Lz();
  return n.has("astc") ? "astc-4x4" : n.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : n.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : n.has("etc1") ? "etc1" : n.has("etc2") ? "etc2" : "rgb565";
}
const kz = {
  name: "Basis",
  id: nu ? "basis" : "basis-nodejs",
  module: "textures",
  version: wz,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, Nz = {
  ...kz,
  parse: Oz
};
function va(n, e) {
  if (!n)
    throw new Error(e || "assert failed: gltf");
}
function kE(n, e) {
  if (n.startsWith("data:") || n.startsWith("http:") || n.startsWith("https:"))
    return n;
  const r = e.baseUri || e.uri;
  if (!r)
    throw new Error("'baseUri' must be provided to resolve relative url ".concat(n));
  return r.substr(0, r.lastIndexOf("/") + 1) + n;
}
function zz(n, e, t) {
  const r = n.bufferViews[t];
  va(r);
  const i = r.buffer, o = e[i];
  va(o);
  const c = (r.byteOffset || 0) + o.byteOffset;
  return new Uint8Array(o.arrayBuffer, c, r.byteLength);
}
const Ww = ["SCALAR", "VEC2", "VEC3", "VEC4"], Uz = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], jz = new Map(Uz), Gz = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Vz = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, qz = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function NE(n) {
  return Ww[n - 1] || Ww[0];
}
function zE(n) {
  const e = jz.get(n.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function mb(n, e) {
  const t = qz[n.componentType], r = Gz[n.type], i = Vz[n.componentType], o = n.count * r, c = n.count * r * i;
  return va(c >= 0 && c <= e.byteLength), {
    ArrayType: t,
    length: o,
    byteLength: c
  };
}
function UE(n) {
  let {
    images: e,
    bufferViews: t
  } = n;
  e = e || [], t = t || [];
  const r = e.map((c) => c.bufferView);
  t = t.filter((c) => !r.includes(c));
  const i = t.reduce((c, l) => c + l.byteLength, 0), o = e.reduce((c, l) => {
    const {
      width: _,
      height: b
    } = l.image;
    return c + _ * b;
  }, 0);
  return i + Math.ceil(4 * o * 1.33);
}
const Hz = {
  asset: {
    version: "2.0",
    generator: "loaders.gl"
  },
  buffers: []
};
class Wo {
  constructor(e) {
    V(this, "gltf", void 0), V(this, "sourceBuffers", void 0), V(this, "byteLength", void 0), this.gltf = e || {
      json: {
        ...Hz
      },
      buffers: []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  getExtension(e) {
    const t = this.getUsedExtensions().find((i) => i === e), r = this.json.extensions || {};
    return t ? r[e] || !0 : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((r) => r === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, t) {
    return (e.extensions || {})[t];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, t) {
    if (typeof t == "object")
      return t;
    const r = this.json[e] && this.json[e][t];
    if (!r)
      throw new Error("glTF file error: Could not find ".concat(e, "[").concat(t, "]"));
    return r;
  }
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const t = e.buffer, r = this.gltf.buffers[t];
    va(r);
    const i = (e.byteOffset || 0) + r.byteOffset;
    return new Uint8Array(r.arrayBuffer, i, e.byteLength);
  }
  getTypedArrayForAccessor(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), i = this.getBuffer(t.buffer).data, {
      ArrayType: o,
      length: c
    } = mb(e, t), l = t.byteOffset + e.byteOffset;
    return new o(i, l, c);
  }
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), i = this.getBuffer(t.buffer).data, o = t.byteOffset || 0;
    return new Uint8Array(i, o, t.byteLength);
  }
  addApplicationData(e, t) {
    return this.json[e] = t, this;
  }
  addExtraData(e, t) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this;
  }
  addObjectExtension(e, t, r) {
    return e.extensions = e.extensions || {}, e.extensions[t] = r, this.registerUsedExtension(t), this;
  }
  setObjectExtension(e, t, r) {
    const i = e.extensions || {};
    i[t] = r;
  }
  removeObjectExtension(e, t) {
    const r = e.extensions || {}, i = r[t];
    return delete r[t], i;
  }
  addExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return va(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t;
  }
  addRequiredExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return va(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
  }
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
  }
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
  }
  removeExtension(e) {
    if (!this.getExtension(e))
      return;
    this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e), this.json.extensions && delete this.json.extensions[e], Array.isArray(this.json.extensionsRemoved) || (this.json.extensionsRemoved = []);
    const t = this.json.extensionsRemoved;
    t.includes(e) || t.push(e);
  }
  setDefaultScene(e) {
    this.json.scene = e;
  }
  addScene(e) {
    const {
      nodeIndices: t
    } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({
      nodes: t
    }), this.json.scenes.length - 1;
  }
  addNode(e) {
    const {
      meshIndex: t,
      matrix: r
    } = e;
    this.json.nodes = this.json.nodes || [];
    const i = {
      mesh: t
    };
    return r && (i.matrix = r), this.json.nodes.push(i), this.json.nodes.length - 1;
  }
  addMesh(e) {
    const {
      attributes: t,
      indices: r,
      material: i,
      mode: o = 4
    } = e, l = {
      primitives: [{
        attributes: this._addAttributes(t),
        mode: o
      }]
    };
    if (r) {
      const _ = this._addIndices(r);
      l.primitives[0].indices = _;
    }
    return Number.isFinite(i) && (l.primitives[0].material = i), this.json.meshes = this.json.meshes || [], this.json.meshes.push(l), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const r = {
      primitives: [{
        attributes: this._addAttributes(e),
        mode: 0
      }]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(r), this.json.meshes.length - 1;
  }
  addImage(e, t) {
    const r = L1(e), i = t || (r == null ? void 0 : r.mimeType), c = {
      bufferView: this.addBufferView(e),
      mimeType: i
    };
    return this.json.images = this.json.images || [], this.json.images.push(c), this.json.images.length - 1;
  }
  addBufferView(e) {
    const t = e.byteLength;
    va(Number.isFinite(t)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const r = {
      buffer: 0,
      byteOffset: this.byteLength,
      byteLength: t
    };
    return this.byteLength += Mp(t, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(r), this.json.bufferViews.length - 1;
  }
  addAccessor(e, t) {
    const r = {
      bufferView: e,
      type: NE(t.size),
      componentType: t.componentType,
      count: t.count,
      max: t.max,
      min: t.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(r), this.json.accessors.length - 1;
  }
  addBinaryBuffer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      size: 3
    };
    const r = this.addBufferView(e);
    let i = {
      min: t.min,
      max: t.max
    };
    (!i.min || !i.max) && (i = this._getAccessorMinMax(e, t.size));
    const o = {
      size: t.size,
      componentType: zE(e),
      count: Math.round(e.length / t.size),
      min: i.min,
      max: i.max
    };
    return this.addAccessor(r, Object.assign(o, t));
  }
  addTexture(e) {
    const {
      imageIndex: t
    } = e, r = {
      source: t
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(r), this.json.textures.length - 1;
  }
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  createBinaryChunk() {
    var e, t;
    this.gltf.buffers = [];
    const r = this.byteLength, i = new ArrayBuffer(r), o = new Uint8Array(i);
    let c = 0;
    for (const l of this.sourceBuffers || [])
      c = fP(l, o, c);
    (e = this.json) !== null && e !== void 0 && (t = e.buffers) !== null && t !== void 0 && t[0] ? this.json.buffers[0].byteLength = r : this.json.buffers = [{
      byteLength: r
    }], this.gltf.binary = i, this.sourceBuffers = [i];
  }
  _removeStringFromArray(e, t) {
    let r = !0;
    for (; r; ) {
      const i = e.indexOf(t);
      i > -1 ? e.splice(i, 1) : r = !1;
    }
  }
  _addAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {};
    for (const r in e) {
      const i = e[r], o = this._getGltfAttributeName(r), c = this.addBinaryBuffer(i.value, i);
      t[o] = c;
    }
    return t;
  }
  _addIndices(e) {
    return this.addBinaryBuffer(e, {
      size: 1
    });
  }
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  _getAccessorMinMax(e, t) {
    const r = {
      min: null,
      max: null
    };
    if (e.length < t)
      return r;
    r.min = [], r.max = [];
    const i = e.subarray(0, t);
    for (const o of i)
      r.min.push(o), r.max.push(o);
    for (let o = t; o < e.length; o += t)
      for (let c = 0; c < t; c++)
        r.min[0 + c] = Math.min(r.min[0 + c], e[o + c]), r.max[0 + c] = Math.max(r.max[0 + c], e[o + c]);
    return r;
  }
}
const Wz = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", Xz = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", $z = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), Zz = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), Jz = {
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, Yz = {
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function Kz(n, e, t, r, i) {
  let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
  const c = await Qz();
  n7(c, c.exports[Yz[i]], n, e, t, r, c.exports[Jz[o || "NONE"]]);
}
let C_;
async function Qz() {
  return C_ || (C_ = e7()), C_;
}
async function e7() {
  let n = Wz;
  WebAssembly.validate($z) && (n = Xz, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(t7(n), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function t7(n) {
  const e = new Uint8Array(n.length);
  for (let r = 0; r < n.length; ++r) {
    const i = n.charCodeAt(r);
    e[r] = i > 96 ? i - 71 : i > 64 ? i - 65 : i > 47 ? i + 4 : i > 46 ? 63 : 62;
  }
  let t = 0;
  for (let r = 0; r < n.length; ++r)
    e[t++] = e[r] < 60 ? Zz[e[r]] : (e[r] - 60) * 64 + e[++r];
  return e.buffer.slice(0, t);
}
function n7(n, e, t, r, i, o, c) {
  const l = n.exports.sbrk, _ = r + 3 & -4, b = l(_ * i), w = l(o.length), T = new Uint8Array(n.exports.memory.buffer);
  T.set(o, w);
  const I = e(b, r, i, w, o.length);
  if (I === 0 && c && c(b, _, i), t.set(T.subarray(b, b + r * i)), l(b - l(0)), I !== 0)
    throw new Error("Malformed buffer data: ".concat(I));
}
const _b = "EXT_meshopt_compression", r7 = _b;
async function i7(n, e) {
  var t;
  const r = new Wo(n);
  if (!(e != null && (t = e.gltf) !== null && t !== void 0 && t.decompressMeshes))
    return;
  const i = [];
  for (const o of n.json.bufferViews || [])
    i.push(s7(r, o));
  await Promise.all(i), r.removeExtension(_b);
}
async function s7(n, e) {
  const t = n.getObjectExtension(e, _b);
  if (t) {
    const {
      byteOffset: r = 0,
      byteLength: i = 0,
      byteStride: o,
      count: c,
      mode: l,
      filter: _ = "NONE",
      buffer: b
    } = t, w = n.gltf.buffers[b], T = new Uint8Array(w.arrayBuffer, w.byteOffset + r, i), I = new Uint8Array(n.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    return await Kz(I, c, o, T, l, _), I;
  }
  return null;
}
const o7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: i7,
  name: r7
}, Symbol.toStringTag, { value: "Module" })), Td = "EXT_texture_webp", a7 = Td;
function l7(n, e) {
  const t = new Wo(n);
  if (!hM("image/webp")) {
    if (t.getRequiredExtensions().includes(Td))
      throw new Error("gltf: Required extension ".concat(Td, " not supported by browser"));
    return;
  }
  const {
    json: r
  } = t;
  for (const i of r.textures || []) {
    const o = t.getObjectExtension(i, Td);
    o && (i.source = o.source), t.removeObjectExtension(i, Td);
  }
  t.removeExtension(Td);
}
const c7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: a7,
  preprocess: l7
}, Symbol.toStringTag, { value: "Module" })), Kg = "KHR_texture_basisu", u7 = Kg;
function h7(n, e) {
  const t = new Wo(n), {
    json: r
  } = t;
  for (const i of r.textures || []) {
    const o = t.getObjectExtension(i, Kg);
    o && (i.source = o.source), t.removeObjectExtension(i, Kg);
  }
  t.removeExtension(Kg);
}
const d7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: u7,
  preprocess: h7
}, Symbol.toStringTag, { value: "Module" })), f7 = "3.4.15", p7 = {
  draco: {
    decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
    libraryPath: "libs/",
    extraAttributes: {},
    attributeNameEntry: void 0
  }
}, g7 = {
  name: "Draco",
  id: nu ? "draco" : "draco-nodejs",
  module: "draco",
  shapes: ["mesh"],
  version: f7,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: p7
};
function m7(n, e, t) {
  const r = jE(e.metadata), i = [], o = _7(e.attributes);
  for (const c in n) {
    const l = n[c], _ = Xw(c, l, o[c]);
    i.push(_);
  }
  if (t) {
    const c = Xw("indices", t);
    i.push(c);
  }
  return new Bd(i, r);
}
function _7(n) {
  const e = {};
  for (const t in n) {
    const r = n[t];
    e[r.name || "undefined"] = r;
  }
  return e;
}
function Xw(n, e, t) {
  const r = t ? jE(t.metadata) : void 0;
  return Q8(n, e, r);
}
function jE(n) {
  const e = /* @__PURE__ */ new Map();
  for (const t in n)
    e.set("".concat(t, ".string"), JSON.stringify(n[t]));
  return e;
}
const $w = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, y7 = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  9: Float32Array
}, b7 = 4;
class v7 {
  constructor(e) {
    V(this, "draco", void 0), V(this, "decoder", void 0), V(this, "metadataQuerier", void 0), this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  parseSync(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = new this.draco.DecoderBuffer();
    r.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t);
    const i = this.decoder.GetEncodedGeometryType(r), o = i === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let c;
      switch (i) {
        case this.draco.TRIANGULAR_MESH:
          c = this.decoder.DecodeBufferToMesh(r, o);
          break;
        case this.draco.POINT_CLOUD:
          c = this.decoder.DecodeBufferToPointCloud(r, o);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!c.ok() || !o.ptr) {
        const I = "DRACO decompression failed: ".concat(c.error_msg());
        throw new Error(I);
      }
      const l = this._getDracoLoaderData(o, i, t), _ = this._getMeshData(o, l, t), b = CE(_.attributes), w = m7(_.attributes, l, _.indices);
      return {
        loader: "draco",
        loaderData: l,
        header: {
          vertexCount: o.num_points(),
          boundingBox: b
        },
        ..._,
        schema: w
      };
    } finally {
      this.draco.destroy(r), o && this.draco.destroy(o);
    }
  }
  _getDracoLoaderData(e, t, r) {
    const i = this._getTopLevelMetadata(e), o = this._getDracoAttributes(e, r);
    return {
      geometry_type: t,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: i,
      attributes: o
    };
  }
  _getDracoAttributes(e, t) {
    const r = {};
    for (let i = 0; i < e.num_attributes(); i++) {
      const o = this.decoder.GetAttribute(e, i), c = this._getAttributeMetadata(e, i);
      r[o.unique_id()] = {
        unique_id: o.unique_id(),
        attribute_type: o.attribute_type(),
        data_type: o.data_type(),
        num_components: o.num_components(),
        byte_offset: o.byte_offset(),
        byte_stride: o.byte_stride(),
        normalized: o.normalized(),
        attribute_index: i,
        metadata: c
      };
      const l = this._getQuantizationTransform(o, t);
      l && (r[o.unique_id()].quantization_transform = l);
      const _ = this._getOctahedronTransform(o, t);
      _ && (r[o.unique_id()].octahedron_transform = _);
    }
    return r;
  }
  _getMeshData(e, t, r) {
    const i = this._getMeshAttributes(t, e, r);
    if (!i.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (r.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            attributes: i,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            attributes: i,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      attributes: i
    };
  }
  _getMeshAttributes(e, t, r) {
    const i = {};
    for (const o of Object.values(e.attributes)) {
      const c = this._deduceAttributeName(o, r);
      o.name = c;
      const {
        value: l,
        size: _
      } = this._getAttributeValues(t, o);
      i[c] = {
        value: l,
        size: _,
        byteOffset: o.byte_offset,
        byteStride: o.byte_stride,
        normalized: o.normalized
      };
    }
    return i;
  }
  _getTriangleListIndices(e) {
    const r = e.num_faces() * 3, i = r * b7, o = this.draco._malloc(i);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, i, o), new Uint32Array(this.draco.HEAPF32.buffer, o, r).slice();
    } finally {
      this.draco._free(o);
    }
  }
  _getTriangleStripIndices(e) {
    const t = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, t), A7(t);
    } finally {
      this.draco.destroy(t);
    }
  }
  _getAttributeValues(e, t) {
    const r = y7[t.data_type], i = t.num_components, c = e.num_points() * i, l = c * r.BYTES_PER_ELEMENT, _ = x7(this.draco, r);
    let b;
    const w = this.draco._malloc(l);
    try {
      const T = this.decoder.GetAttribute(e, t.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, T, _, l, w), b = new r(this.draco.HEAPF32.buffer, w, c).slice();
    } finally {
      this.draco._free(w);
    }
    return {
      value: b,
      size: i
    };
  }
  _deduceAttributeName(e, t) {
    const r = e.unique_id;
    for (const [c, l] of Object.entries(t.extraAttributes || {}))
      if (l === r)
        return c;
    const i = e.attribute_type;
    for (const c in $w)
      if (this.draco[c] === i)
        return $w[c];
    const o = t.attributeNameEntry || "name";
    return e.metadata[o] ? e.metadata[o].string : "CUSTOM_ATTRIBUTE_".concat(r);
  }
  _getTopLevelMetadata(e) {
    const t = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(t);
  }
  _getAttributeMetadata(e, t) {
    const r = this.decoder.GetAttributeMetadata(e, t);
    return this._getDracoMetadata(r);
  }
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const t = {}, r = this.metadataQuerier.NumEntries(e);
    for (let i = 0; i < r; i++) {
      const o = this.metadataQuerier.GetEntryName(e, i);
      t[o] = this._getDracoMetadataField(e, o);
    }
    return t;
  }
  _getDracoMetadataField(e, t) {
    const r = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, t, r);
      const i = w7(r);
      return {
        int: this.metadataQuerier.GetIntEntry(e, t),
        string: this.metadataQuerier.GetStringEntry(e, t),
        double: this.metadataQuerier.GetDoubleEntry(e, t),
        intArray: i
      };
    } finally {
      this.draco.destroy(r);
    }
  }
  _disableAttributeTransforms(e) {
    const {
      quantizedAttributes: t = [],
      octahedronAttributes: r = []
    } = e, i = [...t, ...r];
    for (const o of i)
      this.decoder.SkipAttributeTransform(this.draco[o]);
  }
  _getQuantizationTransform(e, t) {
    const {
      quantizedAttributes: r = []
    } = t, i = e.attribute_type();
    if (r.map((c) => this.decoder[c]).includes(i)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits(),
            range: c.range(),
            min_values: new Float32Array([1, 2, 3]).map((l) => c.min_value(l))
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, t) {
    const {
      octahedronAttributes: r = []
    } = t, i = e.attribute_type();
    if (r.map((c) => this.decoder[c]).includes(i)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits()
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
}
function x7(n, e) {
  switch (e) {
    case Float32Array:
      return n.DT_FLOAT32;
    case Int8Array:
      return n.DT_INT8;
    case Int16Array:
      return n.DT_INT16;
    case Int32Array:
      return n.DT_INT32;
    case Uint8Array:
      return n.DT_UINT8;
    case Uint16Array:
      return n.DT_UINT16;
    case Uint32Array:
      return n.DT_UINT32;
    default:
      return n.DT_INVALID;
  }
}
function w7(n) {
  const e = n.size(), t = new Int32Array(e);
  for (let r = 0; r < e; r++)
    t[r] = n.GetValue(r);
  return t;
}
function A7(n) {
  const e = n.size(), t = new Int32Array(e);
  for (let r = 0; r < e; r++)
    t[r] = n.GetValue(r);
  return t;
}
const S7 = "1.5.5", yb = "https://www.gstatic.com/draco/versioned/decoders/".concat(S7), E7 = "".concat(yb, "/draco_decoder.js"), T7 = "".concat(yb, "/draco_wasm_wrapper.js"), C7 = "".concat(yb, "/draco_decoder.wasm");
let Wf;
async function I7(n) {
  const e = n.modules || {};
  return e.draco3d ? Wf = Wf || e.draco3d.createDecoderModule({}).then((t) => ({
    draco: t
  })) : Wf = Wf || P7(n), await Wf;
}
async function P7(n) {
  let e, t;
  switch (n.draco && n.draco.decoderType) {
    case "js":
      e = await Bh(E7, "draco", n);
      break;
    case "wasm":
    default:
      [e, t] = await Promise.all([await Bh(T7, "draco", n), await Bh(C7, "draco", n)]);
  }
  return e = e || globalThis.DracoDecoderModule, await L7(e, t);
}
function L7(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((r) => {
    n({
      ...t,
      onModuleLoaded: (i) => r({
        draco: i
      })
    });
  });
}
const GE = {
  ...g7,
  parse: M7
};
async function M7(n, e) {
  const {
    draco: t
  } = await I7(e), r = new v7(t);
  try {
    return r.parseSync(n, e == null ? void 0 : e.draco);
  } finally {
    r.destroy();
  }
}
function B7(n) {
  const e = {};
  for (const t in n) {
    const r = n[t];
    if (t !== "indices") {
      const i = VE(r);
      e[t] = i;
    }
  }
  return e;
}
function VE(n) {
  const {
    buffer: e,
    size: t,
    count: r
  } = R7(n);
  return {
    value: e,
    size: t,
    byteOffset: 0,
    count: r,
    type: NE(t),
    componentType: zE(e)
  };
}
function R7(n) {
  let e = n, t = 1, r = 0;
  return n && n.value && (e = n.value, t = n.size || 1), e && (ArrayBuffer.isView(e) || (e = O7(e, Float32Array)), r = e.length / t), {
    buffer: e,
    size: t,
    count: r
  };
}
function O7(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return n ? Array.isArray(n) ? new e(n) : t && !(n instanceof e) ? new e(n) : n : null;
}
const zh = "KHR_draco_mesh_compression", D7 = zh;
function F7(n, e, t) {
  const r = new Wo(n);
  for (const i of qE(r))
    r.getObjectExtension(i, zh);
}
async function k7(n, e, t) {
  var r;
  if (!(e != null && (r = e.gltf) !== null && r !== void 0 && r.decompressMeshes))
    return;
  const i = new Wo(n), o = [];
  for (const c of qE(i))
    i.getObjectExtension(c, zh) && o.push(z7(i, c, e, t));
  await Promise.all(o), i.removeExtension(zh);
}
function N7(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = new Wo(n);
  for (const r of t.json.meshes || [])
    U7(r, e), t.addRequiredExtension(zh);
}
async function z7(n, e, t, r) {
  const i = n.getObjectExtension(e, zh);
  if (!i)
    return;
  const o = n.getTypedArrayForBufferView(i.bufferView), c = w1(o.buffer, o.byteOffset), {
    parse: l
  } = r, _ = {
    ...t
  };
  delete _["3d-tiles"];
  const b = await l(c, GE, _, r), w = B7(b.attributes);
  for (const [T, I] of Object.entries(w))
    if (T in e.attributes) {
      const P = e.attributes[T], k = n.getAccessor(P);
      k != null && k.min && k !== null && k !== void 0 && k.max && (I.min = k.min, I.max = k.max);
    }
  e.attributes = w, b.indices && (e.indices = VE(b.indices)), j7(e);
}
function U7(n, e) {
  var t;
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, i = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0;
  if (!i.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const c = i.DracoWriter.encodeSync({
    attributes: n
  }), l = o == null || (t = o.parseSync) === null || t === void 0 ? void 0 : t.call(o, {
    attributes: n
  }), _ = i._addFauxAttributes(l.attributes), b = i.addBufferView(c);
  return {
    primitives: [{
      attributes: _,
      mode: r,
      extensions: {
        [zh]: {
          bufferView: b,
          attributes: _
        }
      }
    }]
  };
}
function j7(n) {
  if (!n.attributes && Object.keys(n.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* qE(n) {
  for (const e of n.json.meshes || [])
    for (const t of e.primitives)
      yield t;
}
const G7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: k7,
  encode: N7,
  name: D7,
  preprocess: F7
}, Symbol.toStringTag, { value: "Module" })), V7 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, q7 = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, bb = "KHR_texture_transform", H7 = bb, Og = new Ke(), W7 = new Ci(), X7 = new Ci();
async function $7(n, e) {
  if (!new Wo(n).getExtension(bb))
    return;
  const i = n.json.materials || [];
  for (let o = 0; o < i.length; o++)
    Z7(o, n);
}
function Z7(n, e) {
  var t, r, i;
  const o = [], c = (t = e.json.materials) === null || t === void 0 ? void 0 : t[n], l = c == null || (r = c.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.baseColorTexture;
  l && Xf(e, n, l, o);
  const _ = c == null ? void 0 : c.emissiveTexture;
  _ && Xf(e, n, _, o);
  const b = c == null ? void 0 : c.normalTexture;
  b && Xf(e, n, b, o);
  const w = c == null ? void 0 : c.occlusionTexture;
  w && Xf(e, n, w, o);
  const T = c == null || (i = c.pbrMetallicRoughness) === null || i === void 0 ? void 0 : i.metallicRoughnessTexture;
  T && Xf(e, n, T, o);
}
function Xf(n, e, t, r) {
  const i = J7(t, r);
  if (!i)
    return;
  const o = n.json.meshes || [];
  for (const c of o)
    for (const l of c.primitives) {
      const _ = l.material;
      Number.isFinite(_) && e === _ && Y7(n, l, i);
    }
}
function J7(n, e) {
  var t;
  const r = (t = n.extensions) === null || t === void 0 ? void 0 : t[bb], {
    texCoord: i = 0
  } = n, {
    texCoord: o = i
  } = r;
  if (!(e.findIndex((l) => {
    let [_, b] = l;
    return _ === i && b === o;
  }) !== -1)) {
    const l = eU(r);
    return i !== o && (n.texCoord = o), e.push([i, o]), {
      originalTexCoord: i,
      texCoord: o,
      matrix: l
    };
  }
  return null;
}
function Y7(n, e, t) {
  const {
    originalTexCoord: r,
    texCoord: i,
    matrix: o
  } = t, c = e.attributes["TEXCOORD_".concat(r)];
  if (Number.isFinite(c)) {
    var l;
    const b = (l = n.json.accessors) === null || l === void 0 ? void 0 : l[c];
    if (b && b.bufferView) {
      var _;
      const w = (_ = n.json.bufferViews) === null || _ === void 0 ? void 0 : _[b.bufferView];
      if (w) {
        const {
          arrayBuffer: T,
          byteOffset: I
        } = n.buffers[w.buffer], P = (I || 0) + (b.byteOffset || 0) + (w.byteOffset || 0), {
          ArrayType: k,
          length: U
        } = mb(b, w), G = q7[b.componentType], H = V7[b.type], $ = w.byteStride || G * H, ie = new Float32Array(U);
        for (let ge = 0; ge < b.count; ge++) {
          const Se = new k(T, P + ge * $, 2);
          Og.set(Se[0], Se[1], 1), Og.transformByMatrix3(o), ie.set([Og[0], Og[1]], ge * H);
        }
        r === i ? K7(b, w, n.buffers, ie) : Q7(i, b, e, n, ie);
      }
    }
  }
}
function K7(n, e, t, r) {
  n.componentType = 5126, t.push({
    arrayBuffer: r.buffer,
    byteOffset: 0,
    byteLength: r.buffer.byteLength
  }), e.buffer = t.length - 1, e.byteLength = r.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function Q7(n, e, t, r, i) {
  r.buffers.push({
    arrayBuffer: i.buffer,
    byteOffset: 0,
    byteLength: i.buffer.byteLength
  });
  const o = r.json.bufferViews;
  if (!o)
    return;
  o.push({
    buffer: r.buffers.length - 1,
    byteLength: i.buffer.byteLength,
    byteOffset: 0
  });
  const c = r.json.accessors;
  c && (c.push({
    bufferView: (o == null ? void 0 : o.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), t.attributes["TEXCOORD_".concat(n)] = c.length - 1);
}
function eU(n) {
  const {
    offset: e = [0, 0],
    rotation: t = 0,
    scale: r = [1, 1]
  } = n, i = new Ci().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), o = W7.set(Math.cos(t), Math.sin(t), 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 1), c = X7.set(r[0], 0, 0, 0, r[1], 0, 0, 0, 1);
  return i.multiplyRight(o).multiplyRight(c);
}
const tU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: $7,
  name: H7
}, Symbol.toStringTag, { value: "Module" })), Ih = "KHR_lights_punctual", nU = Ih;
async function rU(n) {
  const e = new Wo(n), {
    json: t
  } = e, r = e.getExtension(Ih);
  r && (e.json.lights = r.lights, e.removeExtension(Ih));
  for (const i of t.nodes || []) {
    const o = e.getObjectExtension(i, Ih);
    o && (i.light = o.light), e.removeObjectExtension(i, Ih);
  }
}
async function iU(n) {
  const e = new Wo(n), {
    json: t
  } = e;
  if (t.lights) {
    const r = e.addExtension(Ih);
    va(!r.lights), r.lights = t.lights, delete t.lights;
  }
  if (e.json.lights) {
    for (const r of e.json.lights) {
      const i = r.node;
      e.addObjectExtension(i, Ih, r);
    }
    delete e.json.lights;
  }
}
const sU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: rU,
  encode: iU,
  name: nU
}, Symbol.toStringTag, { value: "Module" })), Ap = "KHR_materials_unlit", oU = Ap;
async function aU(n) {
  const e = new Wo(n), {
    json: t
  } = e;
  for (const r of t.materials || [])
    r.extensions && r.extensions.KHR_materials_unlit && (r.unlit = !0), e.removeObjectExtension(r, Ap);
  e.removeExtension(Ap);
}
function lU(n) {
  const e = new Wo(n), {
    json: t
  } = e;
  if (e.materials)
    for (const r of t.materials || [])
      r.unlit && (delete r.unlit, e.addObjectExtension(r, Ap, {}), e.addExtension(Ap));
}
const cU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: aU,
  encode: lU,
  name: oU
}, Symbol.toStringTag, { value: "Module" })), rp = "KHR_techniques_webgl", uU = rp;
async function hU(n) {
  const e = new Wo(n), {
    json: t
  } = e, r = e.getExtension(rp);
  if (r) {
    const i = fU(r, e);
    for (const o of t.materials || []) {
      const c = e.getObjectExtension(o, rp);
      c && (o.technique = Object.assign({}, c, i[c.technique]), o.technique.values = pU(o.technique, e)), e.removeObjectExtension(o, rp);
    }
    e.removeExtension(rp);
  }
}
async function dU(n, e) {
}
function fU(n, e) {
  const {
    programs: t = [],
    shaders: r = [],
    techniques: i = []
  } = n, o = new TextDecoder();
  return r.forEach((c) => {
    if (Number.isFinite(c.bufferView))
      c.code = o.decode(e.getTypedArrayForBufferView(c.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), t.forEach((c) => {
    c.fragmentShader = r[c.fragmentShader], c.vertexShader = r[c.vertexShader];
  }), i.forEach((c) => {
    c.program = t[c.program];
  }), i;
}
function pU(n, e) {
  const t = Object.assign({}, n.values);
  return Object.keys(n.uniforms || {}).forEach((r) => {
    n.uniforms[r].value && !(r in t) && (t[r] = n.uniforms[r].value);
  }), Object.keys(t).forEach((r) => {
    typeof t[r] == "object" && t[r].index !== void 0 && (t[r].texture = e.getTexture(t[r].index));
  }), t;
}
const gU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: hU,
  encode: dU,
  name: uU
}, Symbol.toStringTag, { value: "Module" })), HE = "EXT_feature_metadata", mU = HE;
async function _U(n) {
  const e = new Wo(n);
  yU(e);
}
function yU(n) {
  var e;
  const t = n.getExtension(HE), r = t == null || (e = t.schema) === null || e === void 0 ? void 0 : e.classes, i = t == null ? void 0 : t.featureTables;
  if ((t == null ? void 0 : t.featureTextures) && console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.'), r && i)
    for (const c in r) {
      const l = r[c], _ = xU(i, c);
      _ && bU(n, _, l);
    }
}
function bU(n, e, t) {
  for (const i in t.properties) {
    var r;
    const o = t.properties[i], c = e == null || (r = e.properties) === null || r === void 0 ? void 0 : r[i], l = e.count;
    if (c) {
      const _ = vU(n, o, l, c);
      c.data = _;
    }
  }
}
function vU(n, e, t, r) {
  const i = r.bufferView;
  let o = n.getTypedArrayForBufferView(i);
  switch (e.type) {
    case "STRING": {
      const c = r.stringOffsetBufferView, l = n.getTypedArrayForBufferView(c);
      o = wU(o, l, t);
      break;
    }
  }
  return o;
}
function xU(n, e) {
  for (const t in n) {
    const r = n[t];
    if (r.class === e)
      return r;
  }
  return null;
}
function wU(n, e, t) {
  const r = [], i = new TextDecoder("utf8");
  let o = 0;
  const c = 4;
  for (let l = 0; l < t; l++) {
    const _ = e[(l + 1) * c] - e[l * c], b = n.subarray(o, _ + o), w = i.decode(b);
    r.push(w), o += _;
  }
  return r;
}
const AU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: _U,
  name: mU
}, Symbol.toStringTag, { value: "Module" })), WE = [o7, c7, d7, G7, sU, cU, gU, tU, AU];
function SU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const r = WE.filter((o) => XE(o.name, e));
  for (const o of r) {
    var i;
    (i = o.preprocess) === null || i === void 0 || i.call(o, n, e, t);
  }
}
async function EU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const r = WE.filter((o) => XE(o.name, e));
  for (const o of r) {
    var i;
    await ((i = o.decode) === null || i === void 0 ? void 0 : i.call(o, n, e, t));
  }
}
function XE(n, e) {
  var t;
  const r = (e == null || (t = e.gltf) === null || t === void 0 ? void 0 : t.excludeExtensions) || {};
  return !(n in r && !r[n]);
}
const I_ = "KHR_binary_glTF";
function TU(n) {
  const e = new Wo(n), {
    json: t
  } = e;
  for (const r of t.images || []) {
    const i = e.getObjectExtension(r, I_);
    i && Object.assign(r, i), e.removeObjectExtension(r, I_);
  }
  t.buffers && t.buffers[0] && delete t.buffers[0].uri, e.removeExtension(I_);
}
const Zw = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, CU = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class IU {
  constructor() {
    V(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    }), V(this, "json", void 0);
  }
  normalize(e, t) {
    this.json = e.json;
    const r = e.json;
    switch (r.asset && r.asset.version) {
      case "2.0":
        return;
      case void 0:
      case "1.0":
        break;
      default:
        console.warn("glTF: Unknown version ".concat(r.asset.version));
        return;
    }
    if (!t.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(r), this._convertTopLevelObjectsToArrays(r), TU(e), this._convertObjectIdsToArrayIndices(r), this._updateObjects(r), this._updateMaterial(r);
  }
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const t in Zw)
      this._convertTopLevelObjectToArray(e, t);
  }
  _convertTopLevelObjectToArray(e, t) {
    const r = e[t];
    if (!(!r || Array.isArray(r))) {
      e[t] = [];
      for (const i in r) {
        const o = r[i];
        o.id = o.id || i;
        const c = e[t].length;
        e[t].push(o), this.idToIndexMap[t][i] = c;
      }
    }
  }
  _convertObjectIdsToArrayIndices(e) {
    for (const t in Zw)
      this._convertIdsToIndices(e, t);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const t of e.textures)
      this._convertTextureIds(t);
    for (const t of e.meshes)
      this._convertMeshIds(t);
    for (const t of e.nodes)
      this._convertNodeIds(t);
    for (const t of e.scenes)
      this._convertSceneIds(t);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const t of e.primitives) {
      const {
        attributes: r,
        indices: i,
        material: o
      } = t;
      for (const c in r)
        r[c] = this._convertIdToIndex(r[c], "accessor");
      i && (t.indices = this._convertIdToIndex(i, "accessor")), o && (t.material = this._convertIdToIndex(o, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((t) => this._convertIdToIndex(t, "node"))), e.meshes && (e.meshes = e.meshes.map((t) => this._convertIdToIndex(t, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((t) => this._convertIdToIndex(t, "node")));
  }
  _convertIdsToIndices(e, t) {
    e[t] || (console.warn("gltf v1: json doesn't contain attribute ".concat(t)), e[t] = []);
    for (const r of e[t])
      for (const i in r) {
        const o = r[i], c = this._convertIdToIndex(o, i);
        r[i] = c;
      }
  }
  _convertIdToIndex(e, t) {
    const r = CU[t];
    if (r in this.idToIndexMap) {
      const i = this.idToIndexMap[r][e];
      if (!Number.isFinite(i))
        throw new Error("gltf v1: failed to resolve ".concat(t, " with id ").concat(e));
      return i;
    }
    return e;
  }
  _updateObjects(e) {
    for (const t of this.json.buffers)
      delete t.type;
  }
  _updateMaterial(e) {
    for (const o of e.materials) {
      var t, r, i;
      o.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const c = ((t = o.values) === null || t === void 0 ? void 0 : t.tex) || ((r = o.values) === null || r === void 0 ? void 0 : r.texture2d_0) || ((i = o.values) === null || i === void 0 ? void 0 : i.diffuseTex), l = e.textures.findIndex((_) => _.id === c);
      l !== -1 && (o.pbrMetallicRoughness.baseColorTexture = {
        index: l
      });
    }
  }
}
function PU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new IU().normalize(n, e);
}
const LU = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, MU = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, Ha = {
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, BU = {
  magFilter: Ha.TEXTURE_MAG_FILTER,
  minFilter: Ha.TEXTURE_MIN_FILTER,
  wrapS: Ha.TEXTURE_WRAP_S,
  wrapT: Ha.TEXTURE_WRAP_T
}, RU = {
  [Ha.TEXTURE_MAG_FILTER]: Ha.LINEAR,
  [Ha.TEXTURE_MIN_FILTER]: Ha.NEAREST_MIPMAP_LINEAR,
  [Ha.TEXTURE_WRAP_S]: Ha.REPEAT,
  [Ha.TEXTURE_WRAP_T]: Ha.REPEAT
};
function OU(n) {
  return MU[n];
}
function DU(n) {
  return LU[n];
}
class FU {
  constructor() {
    V(this, "baseUri", ""), V(this, "json", {}), V(this, "buffers", []), V(this, "images", []);
  }
  postProcess(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      json: r,
      buffers: i = [],
      images: o = [],
      baseUri: c = ""
    } = e;
    return va(r), this.baseUri = c, this.json = r, this.buffers = i, this.images = o, this._resolveTree(this.json, t), this.json;
  }
  _resolveTree(e) {
    e.bufferViews && (e.bufferViews = e.bufferViews.map((t, r) => this._resolveBufferView(t, r))), e.images && (e.images = e.images.map((t, r) => this._resolveImage(t, r))), e.samplers && (e.samplers = e.samplers.map((t, r) => this._resolveSampler(t, r))), e.textures && (e.textures = e.textures.map((t, r) => this._resolveTexture(t, r))), e.accessors && (e.accessors = e.accessors.map((t, r) => this._resolveAccessor(t, r))), e.materials && (e.materials = e.materials.map((t, r) => this._resolveMaterial(t, r))), e.meshes && (e.meshes = e.meshes.map((t, r) => this._resolveMesh(t, r))), e.nodes && (e.nodes = e.nodes.map((t, r) => this._resolveNode(t, r))), e.skins && (e.skins = e.skins.map((t, r) => this._resolveSkin(t, r))), e.scenes && (e.scenes = e.scenes.map((t, r) => this._resolveScene(t, r))), e.scene !== void 0 && (e.scene = e.scenes[this.json.scene]);
  }
  getScene(e) {
    return this._get("scenes", e);
  }
  getNode(e) {
    return this._get("nodes", e);
  }
  getSkin(e) {
    return this._get("skins", e);
  }
  getMesh(e) {
    return this._get("meshes", e);
  }
  getMaterial(e) {
    return this._get("materials", e);
  }
  getAccessor(e) {
    return this._get("accessors", e);
  }
  getCamera(e) {
    return null;
  }
  getTexture(e) {
    return this._get("textures", e);
  }
  getSampler(e) {
    return this._get("samplers", e);
  }
  getImage(e) {
    return this._get("images", e);
  }
  getBufferView(e) {
    return this._get("bufferViews", e);
  }
  getBuffer(e) {
    return this._get("buffers", e);
  }
  _get(e, t) {
    if (typeof t == "object")
      return t;
    const r = this.json[e] && this.json[e][t];
    return r || console.warn("glTF file error: Could not find ".concat(e, "[").concat(t, "]")), r;
  }
  _resolveScene(e, t) {
    return e.id = e.id || "scene-".concat(t), e.nodes = (e.nodes || []).map((r) => this.getNode(r)), e;
  }
  _resolveNode(e, t) {
    return e.id = e.id || "node-".concat(t), e.children && (e.children = e.children.map((r) => this.getNode(r))), e.mesh !== void 0 ? e.mesh = this.getMesh(e.mesh) : e.meshes !== void 0 && e.meshes.length && (e.mesh = e.meshes.reduce((r, i) => {
      const o = this.getMesh(i);
      return r.id = o.id, r.primitives = r.primitives.concat(o.primitives), r;
    }, {
      primitives: []
    })), e.camera !== void 0 && (e.camera = this.getCamera(e.camera)), e.skin !== void 0 && (e.skin = this.getSkin(e.skin)), e;
  }
  _resolveSkin(e, t) {
    return e.id = e.id || "skin-".concat(t), e.inverseBindMatrices = this.getAccessor(e.inverseBindMatrices), e;
  }
  _resolveMesh(e, t) {
    return e.id = e.id || "mesh-".concat(t), e.primitives && (e.primitives = e.primitives.map((r) => {
      r = {
        ...r
      };
      const i = r.attributes;
      r.attributes = {};
      for (const o in i)
        r.attributes[o] = this.getAccessor(i[o]);
      return r.indices !== void 0 && (r.indices = this.getAccessor(r.indices)), r.material !== void 0 && (r.material = this.getMaterial(r.material)), r;
    })), e;
  }
  _resolveMaterial(e, t) {
    if (e.id = e.id || "material-".concat(t), e.normalTexture && (e.normalTexture = {
      ...e.normalTexture
    }, e.normalTexture.texture = this.getTexture(e.normalTexture.index)), e.occlusionTexture && (e.occlustionTexture = {
      ...e.occlustionTexture
    }, e.occlusionTexture.texture = this.getTexture(e.occlusionTexture.index)), e.emissiveTexture && (e.emmisiveTexture = {
      ...e.emmisiveTexture
    }, e.emissiveTexture.texture = this.getTexture(e.emissiveTexture.index)), e.emissiveFactor || (e.emissiveFactor = e.emmisiveTexture ? [1, 1, 1] : [0, 0, 0]), e.pbrMetallicRoughness) {
      e.pbrMetallicRoughness = {
        ...e.pbrMetallicRoughness
      };
      const r = e.pbrMetallicRoughness;
      r.baseColorTexture && (r.baseColorTexture = {
        ...r.baseColorTexture
      }, r.baseColorTexture.texture = this.getTexture(r.baseColorTexture.index)), r.metallicRoughnessTexture && (r.metallicRoughnessTexture = {
        ...r.metallicRoughnessTexture
      }, r.metallicRoughnessTexture.texture = this.getTexture(r.metallicRoughnessTexture.index));
    }
    return e;
  }
  _resolveAccessor(e, t) {
    if (e.id = e.id || "accessor-".concat(t), e.bufferView !== void 0 && (e.bufferView = this.getBufferView(e.bufferView)), e.bytesPerComponent = OU(e.componentType), e.components = DU(e.type), e.bytesPerElement = e.bytesPerComponent * e.components, e.bufferView) {
      const r = e.bufferView.buffer, {
        ArrayType: i,
        byteLength: o
      } = mb(e, e.bufferView), c = (e.bufferView.byteOffset || 0) + (e.byteOffset || 0) + r.byteOffset;
      let l = r.arrayBuffer.slice(c, c + o);
      e.bufferView.byteStride && (l = this._getValueFromInterleavedBuffer(r, c, e.bufferView.byteStride, e.bytesPerElement, e.count)), e.value = new i(l);
    }
    return e;
  }
  _getValueFromInterleavedBuffer(e, t, r, i, o) {
    const c = new Uint8Array(o * i);
    for (let l = 0; l < o; l++) {
      const _ = t + l * r;
      c.set(new Uint8Array(e.arrayBuffer.slice(_, _ + i)), l * i);
    }
    return c.buffer;
  }
  _resolveTexture(e, t) {
    return e.id = e.id || "texture-".concat(t), e.sampler = "sampler" in e ? this.getSampler(e.sampler) : RU, e.source = this.getImage(e.source), e;
  }
  _resolveSampler(e, t) {
    e.id = e.id || "sampler-".concat(t), e.parameters = {};
    for (const r in e) {
      const i = this._enumSamplerParameter(r);
      i !== void 0 && (e.parameters[i] = e[r]);
    }
    return e;
  }
  _enumSamplerParameter(e) {
    return BU[e];
  }
  _resolveImage(e, t) {
    e.id = e.id || "image-".concat(t), e.bufferView !== void 0 && (e.bufferView = this.getBufferView(e.bufferView));
    const r = this.images[t];
    return r && (e.image = r), e;
  }
  _resolveBufferView(e, t) {
    const r = e.buffer, i = {
      id: "bufferView-".concat(t),
      ...e,
      buffer: this.buffers[r]
    }, o = this.buffers[r].arrayBuffer;
    let c = this.buffers[r].byteOffset || 0;
    return "byteOffset" in e && (c += e.byteOffset), i.data = new Uint8Array(o, c, e.byteLength), i;
  }
  _resolveCamera(e, t) {
    return e.id = e.id || "camera-".concat(t), e.perspective, e.orthographic, e;
  }
}
function kU(n, e) {
  return new FU().postProcess(n, e);
}
const Jw = 1735152710, vb = 12, Im = 8, NU = 1313821514, zU = 5130562, UU = 0, jU = 1, GU = 0, Qd = !0;
function VU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return "".concat(String.fromCharCode(n.getUint8(e + 0))).concat(String.fromCharCode(n.getUint8(e + 1))).concat(String.fromCharCode(n.getUint8(e + 2))).concat(String.fromCharCode(n.getUint8(e + 3)));
}
function qU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const r = new DataView(n), {
    magic: i = Jw
  } = t, o = r.getUint32(e, !1);
  return o === i || o === Jw;
}
function HU(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const r = new DataView(e), i = VU(r, t + 0), o = r.getUint32(t + 4, Qd), c = r.getUint32(t + 8, Qd);
  switch (Object.assign(n, {
    header: {
      byteOffset: t,
      byteLength: c,
      hasBinChunk: !1
    },
    type: i,
    version: o,
    json: {},
    binChunks: []
  }), t += vb, n.version) {
    case 1:
      return WU(n, r, t);
    case 2:
      return XU(n, r, t, {});
    default:
      throw new Error("Invalid GLB version ".concat(n.version, ". Only supports v1 and v2."));
  }
}
function WU(n, e, t) {
  Zr(n.header.byteLength > vb + Im);
  const r = e.getUint32(t + 0, Qd), i = e.getUint32(t + 4, Qd);
  return t += Im, Zr(i === GU), zy(n, e, t, r), t += r, t += Uy(n, e, t, n.header.byteLength), t;
}
function XU(n, e, t, r) {
  return Zr(n.header.byteLength > vb + Im), $U(n, e, t, r), t + n.header.byteLength;
}
function $U(n, e, t, r) {
  for (; t + 8 <= n.header.byteLength; ) {
    const i = e.getUint32(t + 0, Qd), o = e.getUint32(t + 4, Qd);
    switch (t += Im, o) {
      case NU:
        zy(n, e, t, i);
        break;
      case zU:
        Uy(n, e, t, i);
        break;
      case UU:
        r.strict || zy(n, e, t, i);
        break;
      case jU:
        r.strict || Uy(n, e, t, i);
        break;
    }
    t += Mp(i, 4);
  }
  return t;
}
function zy(n, e, t, r) {
  const i = new Uint8Array(e.buffer, t, r), c = new TextDecoder("utf8").decode(i);
  return n.json = JSON.parse(c), Mp(r, 4);
}
function Uy(n, e, t, r) {
  return n.header.hasBinChunk = !0, n.binChunks.push({
    byteOffset: t,
    byteLength: r,
    arrayBuffer: e.buffer
  }), Mp(r, 4);
}
async function ZU(n, e) {
  var t, r, i, o;
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, l = arguments.length > 3 ? arguments[3] : void 0, _ = arguments.length > 4 ? arguments[4] : void 0;
  JU(n, e, c, l), PU(n, {
    normalize: l == null || (t = l.gltf) === null || t === void 0 ? void 0 : t.normalize
  }), SU(n, l, _);
  const b = [];
  if (l != null && (r = l.gltf) !== null && r !== void 0 && r.loadBuffers && n.json.buffers && await YU(n, l, _), l != null && (i = l.gltf) !== null && i !== void 0 && i.loadImages) {
    const T = KU(n, l, _);
    b.push(T);
  }
  const w = EU(n, l, _);
  return b.push(w), await Promise.all(b), l != null && (o = l.gltf) !== null && o !== void 0 && o.postProcess ? kU(n, l) : n;
}
function JU(n, e, t, r) {
  if (r.uri && (n.baseUri = r.uri), e instanceof ArrayBuffer && !qU(e, t, r) && (e = new TextDecoder().decode(e)), typeof e == "string")
    n.json = uP(e);
  else if (e instanceof ArrayBuffer) {
    const c = {};
    t = HU(c, e, t, r.glb), va(c.type === "glTF", "Invalid GLB magic string ".concat(c.type)), n._glb = c, n.json = c.json;
  } else
    va(!1, "GLTF: must be ArrayBuffer or string");
  const i = n.json.buffers || [];
  if (n.buffers = new Array(i.length).fill(null), n._glb && n._glb.header.hasBinChunk) {
    const {
      binChunks: c
    } = n._glb;
    n.buffers[0] = {
      arrayBuffer: c[0].arrayBuffer,
      byteOffset: c[0].byteOffset,
      byteLength: c[0].byteLength
    };
  }
  const o = n.json.images || [];
  n.images = new Array(o.length).fill({});
}
async function YU(n, e, t) {
  const r = n.json.buffers || [];
  for (let c = 0; c < r.length; ++c) {
    const l = r[c];
    if (l.uri) {
      var i, o;
      const {
        fetch: _
      } = t;
      va(_);
      const b = kE(l.uri, e), w = await (t == null || (i = t.fetch) === null || i === void 0 ? void 0 : i.call(t, b)), T = await (w == null || (o = w.arrayBuffer) === null || o === void 0 ? void 0 : o.call(w));
      n.buffers[c] = {
        arrayBuffer: T,
        byteOffset: 0,
        byteLength: T.byteLength
      }, delete l.uri;
    } else n.buffers[c] === null && (n.buffers[c] = {
      arrayBuffer: new ArrayBuffer(l.byteLength),
      byteOffset: 0,
      byteLength: l.byteLength
    });
  }
}
async function KU(n, e, t) {
  const r = QU(n), i = n.json.images || [], o = [];
  for (const c of r)
    o.push(e9(n, i[c], c, e, t));
  return await Promise.all(o);
}
function QU(n) {
  const e = /* @__PURE__ */ new Set(), t = n.json.textures || [];
  for (const r of t)
    r.source !== void 0 && e.add(r.source);
  return Array.from(e).sort();
}
async function e9(n, e, t, r, i) {
  const {
    fetch: o,
    parse: c
  } = i;
  let l;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const b = kE(e.uri, r);
    l = await (await o(b)).arrayBuffer(), e.bufferView = {
      data: l
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const b = zz(n.json, n.buffers, e.bufferView);
    l = w1(b.buffer, b.byteOffset, b.byteLength);
  }
  va(l, "glTF image has no data");
  let _ = await c(l, [Z5, Nz], {
    mimeType: e.mimeType,
    basis: r.basis || {
      format: FE()
    }
  }, i);
  _ && _[0] && (_ = {
    compressed: !0,
    mipmaps: !1,
    width: _[0].width,
    height: _[0].height,
    data: _[0]
  }), n.images = n.images || [], n.images[t] = _;
}
const Sp = {
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: xz,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: t9,
  options: {
    gltf: {
      normalize: !0,
      loadBuffers: !0,
      loadImages: !0,
      decompressMeshes: !0,
      postProcess: !0
    },
    log: console
  },
  deprecatedOptions: {
    fetchImages: "gltf.loadImages",
    createImages: "gltf.loadImages",
    decompress: "gltf.decompressMeshes",
    postProcess: "gltf.postProcess",
    gltf: {
      decompress: "gltf.decompressMeshes"
    }
  }
};
async function t9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  e = {
    ...Sp.options,
    ...e
  }, e.gltf = {
    ...Sp.options.gltf,
    ...e.gltf
  };
  const {
    byteOffset: r = 0
  } = e;
  return await ZU({}, n, r, e, t);
}
async function n9(n) {
  const e = [];
  return n.scenes.forEach((t) => {
    t.traverse((r) => {
      Object.values(r.model.getUniforms()).forEach((i) => {
        i.loaded === !1 && e.push(i);
      });
    });
  }), await r9(() => e.some((t) => !t.loaded));
}
async function r9(n) {
  for (; n(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const i9 = `#version 300 es
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;
in vec4 POSITION;

#ifdef HAS_UV
  in vec2 TEXCOORD_0;
#endif

#ifdef MODULE_PBR
  #ifdef HAS_NORMALS
    in vec4 NORMAL;
  #endif
#endif
out vec4 vColor;
#ifndef MODULE_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif
void main(void) {
  #if defined(HAS_UV) && !defined(MODULE_PBR)
    vTEXCOORD_0 = TEXCOORD_0;
    geometry.uv = vTEXCOORD_0;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  vec3 normal = vec3(0.0, 0.0, 1.0);
  #ifdef MODULE_PBR
    #ifdef HAS_NORMALS
      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;
    #endif
  #endif

  float originalSize = project_size_to_pixel(sizeScale);
  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    geometry.normal = project_normal(normal);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
    geometry.normal = project_normal(normal);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = TEXCOORD_0;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, s9 = `#version 300 es
uniform float opacity;
in vec4 vColor;

out vec4 fragmentColor;
#ifndef MODULE_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D u_BaseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef MODULE_PBR
    fragmentColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragmentColor = vColor;
    #endif
  #endif

  fragmentColor.a *= opacity;
  DECKGL_FILTER_COLOR(fragmentColor, geometry);
}
`, $E = [255, 255, 255, 255], o9 = {
  scenegraph: {
    type: "object",
    value: null,
    async: !0
  },
  getScene: (n) => n && n.scenes ? typeof n.scene == "object" ? n.scene : n.scenes[n.scene || 0] : n,
  getAnimator: (n) => n && n.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getColor: {
    type: "accessor",
    value: $E
  },
  _lighting: "flat",
  _imageBasedLightingEnvironment: null,
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [Sp]
};
class xb extends sf {
  constructor() {
    super(...arguments), V(this, "state", void 0);
  }
  getShaders() {
    const e = [nb, rb];
    return this.props._lighting === "pbr" && e.push(Z1), super.getShaders({
      vs: i9,
      fs: s9,
      modules: e
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: 5121,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        normalized: !0,
        defaultValue: $E,
        transition: !0
      },
      instanceModelMatrix: EE
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: r
    } = e;
    t.scenegraph !== r.scenegraph ? this._updateScenegraph() : t._animations !== r._animations && this._applyAnimationsProp(this.state.scenegraph, this.state.animator, t._animations);
  }
  finalizeState(e) {
    super.finalizeState(e), this._deleteScenegraph();
  }
  get isLoaded() {
    var e;
    return ((e = this.state) === null || e === void 0 ? void 0 : e.scenegraph) && super.isLoaded;
  }
  _updateScenegraph() {
    const e = this.props, {
      gl: t
    } = this.context;
    let r = null;
    if (e.scenegraph instanceof Nd)
      r = {
        scenes: [e.scenegraph]
      };
    else if (e.scenegraph && !e.scenegraph.gltf) {
      const l = e.scenegraph, _ = vz(t, l, this._getModelOptions());
      r = {
        gltf: l,
        ..._
      }, n9(_).then(() => this.setNeedsRedraw());
    } else e.scenegraph && (ur.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")(), r = e.scenegraph);
    const i = {
      layer: this,
      gl: t
    }, o = e.getScene(r, i), c = e.getAnimator(r, i);
    o instanceof Nd ? (this._deleteScenegraph(), this._applyAllAttributes(o), this._applyAnimationsProp(o, c, e._animations), this.setState({
      scenegraph: o,
      animator: c
    })) : o !== null && ur.warn("invalid scenegraph:", o)();
  }
  _applyAllAttributes(e) {
    if (this.state.attributesAvailable) {
      const t = this.getAttributeManager().getAttributes();
      e.traverse((r) => {
        this._setModelAttributes(r.model, t);
      });
    }
  }
  _applyAnimationsProp(e, t, r) {
    if (!e || !t || !r)
      return;
    const i = t.getAnimations();
    Object.keys(r).sort().forEach((o) => {
      const c = r[o];
      if (o === "*")
        i.forEach((l) => {
          Object.assign(l, c);
        });
      else if (Number.isFinite(Number(o))) {
        const l = Number(o);
        l >= 0 && l < i.length ? Object.assign(i[l], c) : ur.warn("animation ".concat(o, " not found"))();
      } else {
        const l = i.find((_) => {
          let {
            name: b
          } = _;
          return b === o;
        });
        l ? Object.assign(l, c) : ur.warn("animation ".concat(o, " not found"))();
      }
    });
  }
  _deleteScenegraph() {
    const {
      scenegraph: e
    } = this.state;
    e instanceof Nd && e.delete();
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment: e
    } = this.props;
    let t = null;
    return e && (typeof e == "function" ? t = e({
      gl: this.context.gl,
      layer: this
    }) : t = e), {
      gl: this.context.gl,
      waitForFullLoad: !0,
      imageBasedLightingEnvironment: t,
      modelOptions: {
        isInstanced: !0,
        transpileToGLSL100: !tr(this.context.gl),
        ...this.getShaders()
      },
      useTangents: !1
    };
  }
  updateAttributes(e) {
    this.setState({
      attributesAvailable: !0
    }), this.state.scenegraph && this.state.scenegraph.traverse((t) => {
      this._setModelAttributes(t.model, e);
    });
  }
  draw(e) {
    let {
      moduleParameters: t = null,
      parameters: r = {},
      context: i
    } = e;
    if (!this.state.scenegraph) return;
    this.props._animations && this.state.animator && (this.state.animator.animate(i.timeline.getTime()), this.setNeedsRedraw());
    const {
      viewport: o
    } = this.context, {
      sizeScale: c,
      sizeMinPixels: l,
      sizeMaxPixels: _,
      opacity: b,
      coordinateSystem: w
    } = this.props, T = this.getNumInstances();
    this.state.scenegraph.traverse((I, P) => {
      let {
        worldMatrix: k
      } = P;
      I.model.setInstanceCount(T), I.updateModuleSettings(t), I.draw({
        parameters: r,
        uniforms: {
          sizeScale: c,
          opacity: b,
          sizeMinPixels: l,
          sizeMaxPixels: _,
          composeModelMatrix: TE(o, w),
          sceneModelMatrix: k,
          u_Camera: I.model.getUniforms().project_uCameraPosition
        }
      });
    });
  }
}
V(xb, "defaultProps", o9);
V(xb, "layerName", "ScenegraphLayer");
const a9 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

vec2 applyUVRegion(vec2 uv) {
  #ifdef HAS_UV_REGIONS
    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
  #else
    return uv;
  #endif
}

void main(void) {
  vec2 uv = applyUVRegion(texCoords);
  geometry.uv = uv;

  if (pickFeatureIds) {
    geometry.pickingColor = featureIdsPickingColors;
  } else {
    geometry.pickingColor = instancePickingColors;
  }

  vTexCoord = uv;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale;
  vec3 projectedPosition = project_position(positions);
  position_commonspace = vec4(projectedPosition, 1.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace);

  geometry.position = position_commonspace;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  geometry.normal = normals_commonspace;

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = uv;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, l9 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  
#ifdef MODULE_PBR

  fragColor = vColor * pbr_filterColor(vec4(0));
  geometry.uv = pbr_vUV;
  fragColor.a *= opacity;

#else

  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);

#endif

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function c9(n) {
  n.COLOR_0 || n.colors || (n.colors = {
    constant: !0,
    value: new Float32Array([1, 1, 1])
  });
}
const u9 = {
  pbrMaterial: {
    type: "object",
    value: null
  },
  featureIds: {
    type: "array",
    value: null,
    optional: !0
  }
};
class wb extends gb {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(Z1), {
      ...e,
      vs: a9,
      fs: l9
    };
  }
  initializeState() {
    const {
      featureIds: e
    } = this.props;
    super.initializeState();
    const t = this.getAttributeManager();
    e && t.add({
      featureIdsPickingColors: {
        type: 5121,
        size: 3,
        noAlloc: !0,
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: r
    } = e;
    t.pbrMaterial !== r.pbrMaterial && this.updatePbrMaterialUniforms(t.pbrMaterial);
  }
  draw(e) {
    const {
      featureIds: t
    } = this.props;
    this.state.model && (this.state.model.setUniforms({
      u_Camera: this.state.model.getUniforms().project_uCameraPosition,
      pickFeatureIds: !!t
    }), super.draw(e));
  }
  getModel(e) {
    const {
      id: t,
      pbrMaterial: r
    } = this.props, i = this.parseMaterial(r, e);
    this.setState({
      materialParser: i
    });
    const o = this.getShaders();
    return c9(e.attributes), new Jd(this.context.gl, {
      ...this.getShaders(),
      id: t,
      geometry: e,
      defines: {
        ...o.defines,
        ...i == null ? void 0 : i.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions
      },
      parameters: i == null ? void 0 : i.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const {
      model: t
    } = this.state;
    if (t) {
      const {
        mesh: r
      } = this.props, i = this.parseMaterial(e, r);
      this.setState({
        materialParser: i
      }), t.setUniforms(i.uniforms);
    }
  }
  parseMaterial(e, t) {
    var r;
    const i = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return (r = this.state.materialParser) === null || r === void 0 || r.delete(), new RE(this.context.gl, {
      attributes: {
        NORMAL: t.attributes.normals,
        TEXCOORD_0: t.attributes.texCoords
      },
      material: {
        unlit: i,
        ...e
      },
      pbrDebug: !1,
      imageBasedLightingEnvironment: null,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const t = this.props.featureIds, r = new Uint8ClampedArray(t.length * e.size), i = [];
    for (let o = 0; o < t.length; o++)
      this.encodePickingColor(t[o], i), r[o * 3] = i[0], r[o * 3 + 1] = i[1], r[o * 3 + 2] = i[2];
    e.value = r;
  }
  finalizeState(e) {
    var t;
    super.finalizeState(e), (t = this.state.materialParser) === null || t === void 0 || t.delete(), this.setState({
      materialParser: null
    });
  }
}
V(wb, "layerName", "MeshLayer");
V(wb, "defaultProps", u9);
const h9 = 6378137, d9 = 6378137, f9 = 6356752314245179e-9;
function Vm(n) {
  return n;
}
new Ke();
function p9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Vm;
  return "longitude" in n ? (e[0] = t(n.longitude), e[1] = t(n.latitude), e[2] = n.height) : "x" in n ? (e[0] = t(n.x), e[1] = t(n.y), e[2] = n.z) : (e[0] = t(n[0]), e[1] = t(n[1]), e[2] = n[2]), e;
}
function g9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return p9(n, e, ss._cartographicRadians ? Vm : h6);
}
function m9(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Vm;
  return "longitude" in e ? (e.longitude = t(n[0]), e.latitude = t(n[1]), e.height = n[2]) : "x" in e ? (e.x = t(n[0]), e.y = t(n[1]), e.z = n[2]) : (e[0] = t(n[0]), e[1] = t(n[1]), e[2] = n[2]), e;
}
function _9(n, e) {
  return m9(n, e, ss._cartographicRadians ? Vm : d6);
}
const xd = new Ke(), y9 = new Ke(), b9 = new Ke();
function v9(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const {
    oneOverRadii: r,
    oneOverRadiiSquared: i,
    centerToleranceSquared: o
  } = e;
  xd.from(n);
  const c = xd.x, l = xd.y, _ = xd.z, b = r.x, w = r.y, T = r.z, I = c * c * b * b, P = l * l * w * w, k = _ * _ * T * T, U = I + P + k, G = Math.sqrt(1 / U);
  if (!Number.isFinite(G))
    return;
  const H = y9;
  if (H.copy(n).scale(G), U < o)
    return H.to(t);
  const $ = i.x, ie = i.y, ge = i.z, Se = b9;
  Se.set(H.x * $ * 2, H.y * ie * 2, H.z * ge * 2);
  let Re = (1 - G) * xd.len() / (0.5 * Se.len()), Le = 0, _e, Ge, ke, oe;
  do {
    Re -= Le, _e = 1 / (1 + Re * $), Ge = 1 / (1 + Re * ie), ke = 1 / (1 + Re * ge);
    const pe = _e * _e, Te = Ge * Ge, xe = ke * ke, et = pe * _e, rt = Te * Ge, st = xe * ke;
    oe = I * pe + P * Te + k * xe - 1;
    const ct = -2 * (I * et * $ + P * rt * ie + k * st * ge);
    Le = oe / ct;
  } while (Math.abs(oe) > vp.EPSILON12);
  return xd.scale([_e, Ge, ke]).to(t);
}
const Yw = 1e-14, x9 = new Ke(), Kw = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, P_ = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, $f = {
  east: new Ke(),
  north: new Ke(),
  up: new Ke(),
  west: new Ke(),
  south: new Ke(),
  down: new Ke()
}, w9 = new Ke(), A9 = new Ke(), S9 = new Ke();
function Qw(n, e, t, r, i, o) {
  const c = Kw[e] && Kw[e][t];
  vl(c && (!r || r === c));
  let l, _, b;
  const w = x9.copy(i);
  if (Sl(w.x, 0, Yw) && Sl(w.y, 0, Yw)) {
    const I = Math.sign(w.z);
    l = w9.fromArray(P_[e]), e !== "east" && e !== "west" && l.scale(I), _ = A9.fromArray(P_[t]), t !== "east" && t !== "west" && _.scale(I), b = S9.fromArray(P_[r]), r !== "east" && r !== "west" && b.scale(I);
  } else {
    const {
      up: I,
      east: P,
      north: k
    } = $f;
    P.set(-w.y, w.x, 0).normalize(), n.geodeticSurfaceNormal(w, I), k.copy(I).cross(P);
    const {
      down: U,
      west: G,
      south: H
    } = $f;
    U.copy(I).scale(-1), G.copy(P).scale(-1), H.copy(k).scale(-1), l = $f[e], _ = $f[t], b = $f[r];
  }
  return o[0] = l.x, o[1] = l.y, o[2] = l.z, o[3] = 0, o[4] = _.x, o[5] = _.y, o[6] = _.z, o[7] = 0, o[8] = b.x, o[9] = b.y, o[10] = b.z, o[11] = 0, o[12] = w.x, o[13] = w.y, o[14] = w.z, o[15] = 1, o;
}
const Dg = new Ke(), eA = new Ke(), E9 = new Ke(), pl = new Ke(), T9 = new Ke(), Fg = new Ke();
class _i {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    V(this, "radii", void 0), V(this, "radiiSquared", void 0), V(this, "radiiToTheFourth", void 0), V(this, "oneOverRadii", void 0), V(this, "oneOverRadiiSquared", void 0), V(this, "minimumRadius", void 0), V(this, "maximumRadius", void 0), V(this, "centerToleranceSquared", vp.EPSILON1), V(this, "squaredXOverSquaredZ", void 0), vl(e >= 0), vl(t >= 0), vl(r >= 0), this.radii = new Ke(e, t, r), this.radiiSquared = new Ke(e * e, t * t, r * r), this.radiiToTheFourth = new Ke(e * e * e * e, t * t * t * t, r * r * r * r), this.oneOverRadii = new Ke(e === 0 ? 0 : 1 / e, t === 0 ? 0 : 1 / t, r === 0 ? 0 : 1 / r), this.oneOverRadiiSquared = new Ke(e === 0 ? 0 : 1 / (e * e), t === 0 ? 0 : 1 / (t * t), r === 0 ? 0 : 1 / (r * r)), this.minimumRadius = Math.min(e, t, r), this.maximumRadius = Math.max(e, t, r), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const r = eA, i = E9, [, , o] = e;
    this.geodeticSurfaceNormalCartographic(e, r), i.copy(this.radiiSquared).scale(r);
    const c = Math.sqrt(r.dot(i));
    return i.scale(1 / c), r.scale(o), i.add(r), i.to(t);
  }
  cartesianToCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    Fg.from(e);
    const r = this.scaleToGeodeticSurface(Fg, pl);
    if (!r)
      return;
    const i = this.geodeticSurfaceNormal(r, eA), o = T9;
    o.copy(Fg).subtract(r);
    const c = Math.atan2(i.y, i.x), l = Math.asin(i.z), _ = Math.sign(q1(o, Fg)) * MS(o);
    return _9([c, l, _], t);
  }
  eastNorthUpToFixedFrame(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new lr();
    return Qw(this, "east", "north", "up", e, t);
  }
  localFrameToFixedFrame(e, t, r, i) {
    let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new lr();
    return Qw(this, e, t, r, i, o);
  }
  geocentricSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Dg.from(e).normalize().to(t);
  }
  geodeticSurfaceNormalCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const r = g9(e), i = r[0], o = r[1], c = Math.cos(o);
    return Dg.set(c * Math.cos(i), c * Math.sin(i), Math.sin(o)).normalize(), Dg.to(t);
  }
  geodeticSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Dg.from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
  }
  scaleToGeodeticSurface(e, t) {
    return v9(e, this, t);
  }
  scaleToGeocentricSurface(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    pl.from(e);
    const r = pl.x, i = pl.y, o = pl.z, c = this.oneOverRadiiSquared, l = 1 / Math.sqrt(r * r * c.x + i * i * c.y + o * o * c.z);
    return pl.multiplyScalar(l).to(t);
  }
  transformPositionToScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return pl.from(e).scale(this.oneOverRadii).to(t);
  }
  transformPositionFromScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return pl.from(e).scale(this.radii).to(t);
  }
  getSurfaceNormalIntersectionWithZAxis(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
    vl(Sl(this.radii.x, this.radii.y, vp.EPSILON15)), vl(this.radii.z > 0), pl.from(e);
    const i = pl.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(i) >= this.radii.z - t))
      return pl.set(0, 0, i).to(r);
  }
}
V(_i, "WGS84", new _i(h9, d9, f9));
class C9 {
  constructor(e, t, r) {
    V(this, "item", void 0), V(this, "previous", void 0), V(this, "next", void 0), this.item = e, this.previous = t, this.next = r;
  }
}
class I9 {
  constructor() {
    V(this, "head", null), V(this, "tail", null), V(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  add(e) {
    const t = new C9(e, this.tail, null);
    return this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t;
  }
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  splice(e, t) {
    e !== t && (this.remove(t), this._insert(e, t));
  }
  _insert(e, t) {
    const r = e.next;
    e.next = t, this.tail === e ? this.tail = t : r.previous = t, t.next = r, t.previous = e, ++this._length;
  }
}
class P9 {
  constructor() {
    V(this, "_list", void 0), V(this, "_sentinel", void 0), V(this, "_trimTiles", void 0), this._list = new I9(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const t = e._cacheNode;
    t && this._list.splice(this._sentinel, t);
  }
  add(e, t, r) {
    t._cacheNode || (t._cacheNode = this._list.add(t), r && r(e, t));
  }
  unloadTile(e, t, r) {
    const i = t._cacheNode;
    i && (this._list.remove(i), t._cacheNode = null, r && r(e, t));
  }
  unloadTiles(e, t) {
    const r = this._trimTiles;
    this._trimTiles = !1;
    const i = this._list, o = e.maximumMemoryUsage * 1024 * 1024, c = this._sentinel;
    let l = i.head;
    for (; l !== c && (e.gpuMemoryUsageInBytes > o || r); ) {
      const _ = l.item;
      l = l.next, this.unloadTile(e, _, t);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function L9(n, e) {
  Zr(n), Zr(e);
  const {
    rtcCenter: t,
    gltfUpAxis: r
  } = e, {
    computedTransform: i,
    boundingVolume: {
      center: o
    }
  } = n;
  let c = new lr(i);
  switch (t && c.translate(t), r) {
    case "Z":
      break;
    case "Y":
      const T = new lr().rotateX(Math.PI / 2);
      c = c.multiplyRight(T);
      break;
    case "X":
      const I = new lr().rotateY(-Math.PI / 2);
      c = c.multiplyRight(I);
      break;
  }
  e.isQuantized && c.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const l = new Ke(o);
  e.cartesianModelMatrix = c, e.cartesianOrigin = l;
  const _ = _i.WGS84.cartesianToCartographic(l, new Ke()), w = _i.WGS84.eastNorthUpToFixedFrame(l).invert();
  e.cartographicModelMatrix = w.multiplyRight(c), e.cartographicOrigin = _, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const tA = new Ke(), L_ = new Ke(), jy = new Xa([new bl(), new bl(), new bl(), new bl(), new bl(), new bl()]);
function M9(n, e) {
  const {
    cameraDirection: t,
    cameraUp: r,
    height: i
  } = n, {
    metersPerUnit: o
  } = n.distanceScales, c = Qg(n, n.center), l = _i.WGS84.eastNorthUpToFixedFrame(c), _ = n.unprojectPosition(n.cameraPosition), b = _i.WGS84.cartographicToCartesian(_, new Ke()), w = new Ke(l.transformAsVector(new Ke(t).scale(o))).normalize(), T = new Ke(l.transformAsVector(new Ke(r).scale(o))).normalize();
  R9(n);
  const I = n.constructor, {
    longitude: P,
    latitude: k,
    width: U,
    bearing: G,
    zoom: H
  } = n, $ = new I({
    longitude: P,
    latitude: k,
    height: i,
    width: U,
    bearing: G,
    zoom: H,
    pitch: 0
  });
  return {
    camera: {
      position: b,
      direction: w,
      up: T
    },
    viewport: n,
    topDownViewport: $,
    height: i,
    cullingVolume: jy,
    frameNumber: e,
    sseDenominator: 1.15
  };
}
function B9(n, e, t) {
  if (t === 0 || n.length <= t)
    return [n, []];
  const r = [], {
    longitude: i,
    latitude: o
  } = e.viewport;
  for (const [b, w] of n.entries()) {
    const [T, I] = w.header.mbs, P = Math.abs(i - T), k = Math.abs(o - I), U = Math.sqrt(k * k + P * P);
    r.push([b, U]);
  }
  const c = r.sort((b, w) => b[1] - w[1]), l = [];
  for (let b = 0; b < t; b++)
    l.push(n[c[b][0]]);
  const _ = [];
  for (let b = t; b < c.length; b++)
    _.push(n[c[b][0]]);
  return [l, _];
}
function R9(n) {
  const e = n.getFrustumPlanes(), t = nA(e.near, n.cameraPosition), r = Qg(n, t), i = Qg(n, n.cameraPosition, L_);
  let o = 0;
  jy.planes[o++].fromPointNormal(r, tA.copy(r).subtract(i));
  for (const c in e) {
    if (c === "near")
      continue;
    const l = e[c], _ = nA(l, t, L_), b = Qg(n, _, L_);
    jy.planes[o++].fromPointNormal(b, tA.copy(r).subtract(b));
  }
}
function nA(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Ke();
  const r = n.normal.dot(e);
  return t.copy(n.normal).scale(n.distance - r).add(e), t;
}
function Qg(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Ke();
  const r = n.unprojectPosition(e);
  return _i.WGS84.cartographicToCartesian(r, t);
}
const O9 = 6378137, D9 = 6378137, Gy = 6356752314245179e-9, rA = new Ke();
function F9(n, e) {
  if (n instanceof qp) {
    const {
      halfAxes: t
    } = n, r = N9(t);
    return Math.log2(Gy / (r + e[2]));
  } else if (n instanceof Vp) {
    const {
      radius: t
    } = n;
    return Math.log2(Gy / (t + e[2]));
  } else if (n.width && n.height) {
    const {
      width: t,
      height: r
    } = n, i = Math.log2(O9 / t), o = Math.log2(D9 / r);
    return (i + o) / 2;
  }
  return 1;
}
function ZE(n, e, t) {
  const r = _i.WGS84.cartographicToCartesian([n.xmax, n.ymax, n.zmax], new Ke()), i = Math.sqrt(Math.pow(r[0] - t[0], 2) + Math.pow(r[1] - t[1], 2) + Math.pow(r[2] - t[2], 2));
  return Math.log2(Gy / (i + e[2]));
}
function k9(n, e, t) {
  const [r, i, o, c] = n;
  return ZE({
    xmin: r,
    xmax: o,
    ymin: i,
    ymax: c,
    zmin: 0,
    zmax: 0
  }, e, t);
}
function N9(n) {
  n.getColumn(0, rA);
  const e = n.getColumn(1), t = n.getColumn(2);
  return rA.add(e).add(t).len();
}
const ma = {
  UNLOADED: 0,
  LOADING: 1,
  PROCESSING: 2,
  READY: 3,
  EXPIRED: 4,
  FAILED: 5
}, ru = {
  ADD: 1,
  REPLACE: 2
}, zd = {
  EMPTY: "empty",
  SCENEGRAPH: "scenegraph",
  POINTCLOUD: "pointcloud",
  MESH: "mesh"
}, qa = {
  I3S: "I3S",
  TILES3D: "TILES3D"
}, qm = {
  GEOMETRIC_ERROR: "geometricError",
  MAX_SCREEN_THRESHOLD: "maxScreenThreshold"
}, z9 = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};
function JE(n) {
  return n != null;
}
const to = new Ke(), em = new Ke(), U9 = new Ke(), j9 = new Ke();
function M_(n, e, t) {
  if (Zr(n, "3D Tile: boundingVolume must be defined"), n.box)
    return V9(n.box, e, t);
  if (n.region) {
    const [r, i, o, c, l, _] = n.region, b = _i.WGS84.cartographicToCartesian([Qc(r), Qc(c), l], U9), w = _i.WGS84.cartographicToCartesian([Qc(o), Qc(i), _], j9), T = new Ke().addVectors(b, w).multiplyScalar(0.5), I = new Ke().subVectors(b, w).len() / 2;
    return iA([T[0], T[1], T[2], I], new lr());
  }
  if (n.sphere)
    return iA(n.sphere, e, t);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function G9(n, e) {
  if (n.box)
    return q9(e);
  if (n.region) {
    const [t, r, i, o, c, l] = n.region;
    return [[Qc(t), Qc(r), c], [Qc(i), Qc(o), l]];
  }
  if (n.sphere)
    return H9(e);
  throw new Error("Unkown boundingVolume type");
}
function V9(n, e, t) {
  const r = new Ke(n[0], n[1], n[2]);
  e.transform(r, r);
  let i = [];
  if (n.length === 10) {
    const b = n.slice(3, 6), w = new bp();
    w.fromArray(n, 6);
    const T = new Ke([1, 0, 0]), I = new Ke([0, 1, 0]), P = new Ke([0, 0, 1]);
    T.transformByQuaternion(w), T.scale(b[0]), I.transformByQuaternion(w), I.scale(b[1]), P.transformByQuaternion(w), P.scale(b[2]), i = [...T.toArray(), ...I.toArray(), ...P.toArray()];
  } else
    i = [...n.slice(3, 6), ...n.slice(6, 9), ...n.slice(9, 12)];
  const o = e.transformAsVector(i.slice(0, 3)), c = e.transformAsVector(i.slice(3, 6)), l = e.transformAsVector(i.slice(6, 9)), _ = new Ci([o[0], o[1], o[2], c[0], c[1], c[2], l[0], l[1], l[2]]);
  return JE(t) ? (t.center = r, t.halfAxes = _, t) : new qp(r, _);
}
function iA(n, e, t) {
  const r = new Ke(n[0], n[1], n[2]);
  e.transform(r, r);
  const i = e.getScale(em), o = Math.max(Math.max(i[0], i[1]), i[2]), c = n[3] * o;
  return JE(t) ? (t.center = r, t.radius = c, t) : new Vp(r, c);
}
function q9(n) {
  const e = YE(), {
    halfAxes: t
  } = n, r = new Ke(t.getColumn(0)), i = new Ke(t.getColumn(1)), o = new Ke(t.getColumn(2));
  for (let c = 0; c < 2; c++) {
    for (let l = 0; l < 2; l++) {
      for (let _ = 0; _ < 2; _++)
        to.copy(n.center), to.add(r), to.add(i), to.add(o), KE(e, to), o.negate();
      i.negate();
    }
    r.negate();
  }
  return e;
}
function H9(n) {
  const e = YE(), {
    center: t,
    radius: r
  } = n, i = _i.WGS84.scaleToGeodeticSurface(t, to);
  let o;
  i ? o = _i.WGS84.geodeticSurfaceNormal(i) : o = new Ke(0, 0, 1);
  let c = new Ke(o[2], -o[1], 0);
  c.len() > 0 ? c.normalize() : c = new Ke(0, 1, 0);
  const l = c.clone().cross(o);
  for (const _ of [c, l, o]) {
    em.copy(_).scale(r);
    for (let b = 0; b < 2; b++)
      to.copy(t), to.add(em), KE(e, to), em.negate();
  }
  return e;
}
function YE() {
  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
}
function KE(n, e) {
  _i.WGS84.cartesianToCartographic(e, to), n[0][0] = Math.min(n[0][0], to[0]), n[0][1] = Math.min(n[0][1], to[1]), n[0][2] = Math.min(n[0][2], to[2]), n[1][0] = Math.max(n[1][0], to[0]), n[1][1] = Math.max(n[1][1], to[1]), n[1][2] = Math.max(n[1][2], to[2]);
}
new Ke();
new Ke();
new lr();
new Ke();
new Ke();
new Ke();
function W9(n, e) {
  const t = n * e;
  return 1 - Math.exp(-(t * t));
}
function X9(n, e) {
  if (n.dynamicScreenSpaceError && n.dynamicScreenSpaceErrorComputedDensity) {
    const t = n.dynamicScreenSpaceErrorComputedDensity, r = n.dynamicScreenSpaceErrorFactor;
    return W9(e, t) * r;
  }
  return 0;
}
function $9(n, e, t) {
  const r = n.tileset, i = n.parent && n.parent.lodMetricValue || n.lodMetricValue, o = t ? i : n.lodMetricValue;
  if (o === 0)
    return 0;
  const c = Math.max(n._distanceToCamera, 1e-7), {
    height: l,
    sseDenominator: _
  } = e, {
    viewDistanceScale: b
  } = r.options;
  let w = o * l * (b || 1) / (c * _);
  return w -= X9(r, c), w;
}
const B_ = new Ke(), sA = new Ke(), Du = new Ke(), oA = new Ke(), Z9 = new Ke(), R_ = new lr(), aA = new lr();
function J9(n, e) {
  if (n.lodMetricValue === 0 || isNaN(n.lodMetricValue))
    return "DIG";
  const t = 2 * QE(n, e);
  return t < 2 ? "OUT" : !n.header.children || t <= n.lodMetricValue ? "DRAW" : n.header.children ? "DIG" : "OUT";
}
function QE(n, e) {
  const {
    topDownViewport: t
  } = e, r = n.header.mbs[1], i = n.header.mbs[0], o = n.header.mbs[2], c = n.header.mbs[3], l = [...n.boundingVolume.center], _ = t.unprojectPosition(t.cameraPosition);
  _i.WGS84.cartographicToCartesian(_, B_), sA.copy(B_).subtract(l).normalize(), _i.WGS84.eastNorthUpToFixedFrame(l, R_), aA.copy(R_).invert(), Du.copy(B_).transform(aA);
  const b = Math.sqrt(Du[0] * Du[0] + Du[1] * Du[1]), w = b * b / Du[2];
  oA.copy([Du[0], Du[1], w]);
  const I = oA.transform(R_).subtract(l).normalize(), k = sA.cross(I).normalize().scale(c).add(l), U = _i.WGS84.cartesianToCartographic(k), G = t.project([i, r, o]), H = t.project(U);
  return Z9.copy(G).subtract(H).magnitude();
}
function Y9(n) {
  return {
    assetGltfUpAxis: n.asset && n.asset.gltfUpAxis || "Y"
  };
}
class lA {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    V(this, "_map", /* @__PURE__ */ new Map()), V(this, "_array", void 0), V(this, "_length", void 0), this._array = new Array(e), this._length = e;
  }
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  get values() {
    return this._array;
  }
  get(e) {
    return Zr(e < this._array.length), this._array[e];
  }
  set(e, t) {
    Zr(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = t, this._map.set(t, e);
  }
  delete(e) {
    const t = this._map.get(e);
    t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
  }
  peek() {
    return this._array[this._length - 1];
  }
  push(e) {
    if (!this._map.has(e)) {
      const t = this.length++;
      this._array[t] = e, this._map.set(e, t);
    }
  }
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  reserve(e) {
    Zr(e >= 0), e > this._array.length && (this._array.length = e);
  }
  resize(e) {
    Zr(e >= 0), this.length = e;
  }
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const K9 = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  maximumScreenSpaceError: 2,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class Hm {
  traversalFinished(e) {
    return !0;
  }
  constructor(e) {
    V(this, "options", void 0), V(this, "root", null), V(this, "selectedTiles", {}), V(this, "requestedTiles", {}), V(this, "emptyTiles", {}), V(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime()), V(this, "updateDebounceTime", 1e3), V(this, "_traversalStack", new lA()), V(this, "_emptyTraversalStack", new lA()), V(this, "_frameNumber", null), this.options = {
      ...K9,
      ...e
    };
  }
  traverse(e, t, r) {
    this.root = e, this.options = {
      ...this.options,
      ...r
    }, this.reset(), this.updateTile(e, t), this._frameNumber = t.frameNumber, this.executeTraversal(e, t);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  executeTraversal(e, t) {
    const r = this._traversalStack;
    for (e._selectionDepth = 1, r.push(e); r.length > 0; ) {
      const o = r.pop();
      let c = !1;
      this.canTraverse(o, t) && (this.updateChildTiles(o, t), c = this.updateAndPushChildren(o, t, r, o.hasRenderContent ? o._selectionDepth + 1 : o._selectionDepth));
      const l = o.parent, _ = !!(!l || l._shouldRefine), b = !c;
      o.hasRenderContent ? o.refine === ru.ADD ? (this.loadTile(o, t), this.selectTile(o, t)) : o.refine === ru.REPLACE && (this.loadTile(o, t), b && this.selectTile(o, t)) : (this.emptyTiles[o.id] = o, this.loadTile(o, t), b && this.selectTile(o, t)), this.touchTile(o, t), o._shouldRefine = c && _;
    }
    const i = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(t) || i - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = i, this.options.onTraversalEnd(t));
  }
  updateChildTiles(e, t) {
    const r = e.children;
    for (const i of r)
      this.updateTile(i, t);
  }
  updateAndPushChildren(e, t, r, i) {
    const {
      loadSiblings: o,
      skipLevelOfDetail: c
    } = this.options, l = e.children;
    l.sort(this.compareDistanceToCamera.bind(this));
    const _ = e.refine === ru.REPLACE && e.hasRenderContent && !c;
    let b = !1, w = !0;
    for (const T of l)
      if (T._selectionDepth = i, T.isVisibleAndInRequestVolume ? (r.find(T) && r.delete(T), r.push(T), b = !0) : (_ || o) && (this.loadTile(T, t), this.touchTile(T, t)), _) {
        let I;
        if (T._inRequestVolume ? T.hasRenderContent ? I = T.contentAvailable : I = this.executeEmptyTraversal(T, t) : I = !1, w = w && I, !w)
          return !1;
      }
    return b || (w = !1), w;
  }
  updateTile(e, t) {
    this.updateTileVisibility(e, t);
  }
  selectTile(e, t) {
    this.shouldSelectTile(e) && (e._selectedFrame = t.frameNumber, this.selectedTiles[e.id] = e);
  }
  loadTile(e, t) {
    this.shouldLoadTile(e) && (e._requestedFrame = t.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  touchTile(e, t) {
    e.tileset._cache.touch(e), e._touchedFrame = t.frameNumber;
  }
  canTraverse(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : !i && !e.isVisibleAndInRequestVolume ? !1 : this.shouldRefine(e, t, r) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  shouldRefine(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = e._screenSpaceError;
    return r && (i = e.getScreenSpaceError(t, !0)), i > this.options.maximumScreenSpaceError;
  }
  updateTileVisibility(e, t) {
    const r = [];
    if (this.options.viewportTraversersMap)
      for (const i in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[i] === t.viewport.id && r.push(i);
    else
      r.push(t.viewport.id);
    e.updateVisibility(t, r);
  }
  compareDistanceToCamera(e, t) {
    return e._distanceToCamera - t._distanceToCamera;
  }
  anyChildrenVisible(e, t) {
    let r = !1;
    for (const i of e.children)
      i.updateVisibility(t), r = r || i.isVisibleAndInRequestVolume;
    return r;
  }
  executeEmptyTraversal(e, t) {
    let r = !0;
    const i = this._emptyTraversalStack;
    for (i.push(e); i.length > 0 && r; ) {
      const o = i.pop();
      if (this.updateTile(o, t), o.isVisibleAndInRequestVolume || this.loadTile(o, t), this.touchTile(o, t), !o.hasRenderContent && this.canTraverse(o, t, !1, !0)) {
        const l = o.children;
        for (const _ of l)
          i.find(_) && i.delete(_), i.push(_);
      } else !o.contentAvailable && !o.hasEmptyContent && (r = !1);
    }
    return r;
  }
}
const cA = new Ke();
function Q9(n) {
  return n != null;
}
class Vy {
  constructor(e, t, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
    V(this, "tileset", void 0), V(this, "header", void 0), V(this, "id", void 0), V(this, "url", void 0), V(this, "parent", void 0), V(this, "refine", void 0), V(this, "type", void 0), V(this, "contentUrl", void 0), V(this, "lodMetricType", "geometricError"), V(this, "lodMetricValue", 0), V(this, "boundingVolume", null), V(this, "content", null), V(this, "contentState", ma.UNLOADED), V(this, "gpuMemoryUsageInBytes", 0), V(this, "children", []), V(this, "depth", 0), V(this, "viewportIds", []), V(this, "transform", new lr()), V(this, "extensions", null), V(this, "implicitTiling", null), V(this, "userData", {}), V(this, "computedTransform", void 0), V(this, "hasEmptyContent", !1), V(this, "hasTilesetContent", !1), V(this, "traverser", new Hm({})), V(this, "_cacheNode", null), V(this, "_frameNumber", null), V(this, "_expireDate", null), V(this, "_expiredContent", null), V(this, "_boundingBox", void 0), V(this, "_distanceToCamera", 0), V(this, "_screenSpaceError", 0), V(this, "_visibilityPlaneMask", void 0), V(this, "_visible", void 0), V(this, "_contentBoundingVolume", void 0), V(this, "_viewerRequestVolume", void 0), V(this, "_initialTransform", new lr()), V(this, "_priority", 0), V(this, "_selectedFrame", 0), V(this, "_requestedFrame", 0), V(this, "_selectionDepth", 0), V(this, "_touchedFrame", 0), V(this, "_centerZDepth", 0), V(this, "_shouldRefine", !1), V(this, "_stackLength", 0), V(this, "_visitedFrame", 0), V(this, "_inRequestVolume", !1), V(this, "_lodJudge", null), this.header = t, this.tileset = e, this.id = i || t.id, this.url = t.url, this.parent = r, this.refine = this._getRefine(t.refine), this.type = t.type, this.contentUrl = t.contentUrl, this._initializeLodMetric(t), this._initializeTransforms(t), this._initializeBoundingVolumes(t), this._initializeContent(t), this._initializeRenderingState(t), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  get contentReady() {
    return this.contentState === ma.READY || this.hasEmptyContent;
  }
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  get contentUnloaded() {
    return this.contentState === ma.UNLOADED;
  }
  get contentExpired() {
    return this.contentState === ma.EXPIRED;
  }
  get contentFailed() {
    return this.contentState === ma.FAILED;
  }
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = G9(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  getScreenSpaceError(e, t) {
    switch (this.tileset.type) {
      case qa.I3S:
        return QE(this, e);
      case qa.TILES3D:
        return $9(this, e, t);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  unselect() {
    this._selectedFrame = 0;
  }
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  _getPriority() {
    const e = this.tileset._traverser, {
      skipLevelOfDetail: t
    } = e.options, r = this.refine === ru.ADD || t;
    if (r && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === ma.UNLOADED)
      return -1;
    const i = this.parent, c = i && (!r || this._screenSpaceError === 0 || i.hasTilesetContent) ? i._screenSpaceError : this._screenSpaceError, l = e.root ? e.root._screenSpaceError : 0;
    return Math.max(l - c, 0);
  }
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = ma.LOADING;
    const t = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!t)
      return this.contentState = ma.UNLOADED, !1;
    try {
      const r = this.tileset.getTileUrl(this.contentUrl), i = this.tileset.loader, o = {
        ...this.tileset.loadOptions,
        [i.id]: {
          ...this.tileset.loadOptions[i.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(i.id)
        }
      };
      return this.content = await Hu(r, i, o), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = ma.READY, this._onContentLoaded(), !0;
    } catch (r) {
      throw this.contentState = ma.FAILED, r;
    } finally {
      t.done();
    }
  }
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = ma.UNLOADED, !0;
  }
  updateVisibility(e, t) {
    if (this._frameNumber === e.frameNumber)
      return;
    const r = this.parent, i = r ? r._visibilityPlaneMask : Xa.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const o = r ? r.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(o);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, i), this._visible = this._visibilityPlaneMask !== Xa.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = t;
  }
  visibility(e, t) {
    const {
      cullingVolume: r
    } = e, {
      boundingVolume: i
    } = this;
    return r.computeVisibilityWithPlaneMask(i, t);
  }
  contentVisibility() {
    return !0;
  }
  distanceToTile(e) {
    const t = this.boundingVolume;
    return Math.sqrt(Math.max(t.distanceSquaredTo(e.camera.position), 0));
  }
  cameraSpaceZDepth(e) {
    let {
      camera: t
    } = e;
    const r = this.boundingVolume;
    return cA.subVectors(r.center, t.position), t.direction.dot(cA);
  }
  insideViewerRequestVolume(e) {
    const t = this._viewerRequestVolume;
    return !t || t.distanceSquaredTo(e.camera.position) <= 0;
  }
  updateExpiration() {
    if (Q9(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = ma.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new lr(e.transform) : new lr();
    const t = this.parent, r = this.tileset, i = t && t.computedTransform ? t.computedTransform.clone() : r.modelMatrix.clone();
    this.computedTransform = new lr(i).multiplyRight(this.transform);
    const o = t && t._initialTransform ? t._initialTransform.clone() : new lr();
    this._initialTransform = new lr(o).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = {
      _tileset: this.tileset,
      _tile: this
    }, this.hasEmptyContent = !0, this.contentState = ma.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = Xa.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || ru.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = M_(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const t = e.content;
    t && (t.boundingVolume && (this._contentBoundingVolume = M_(t.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = M_(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  _updateTransform() {
    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new lr()).clone().multiplyRight(this.transform);
    t.equals(this.computedTransform) || (this.computedTransform = t, this._updateBoundingVolume(this.header));
  }
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return Y9(this.tileset.tileset);
    }
  }
}
class ej extends Hm {
  compareDistanceToCamera(e, t) {
    return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, t) {
    if (super.updateTileVisibility(e, t), !e.isVisibleAndInRequestVolume)
      return;
    const r = e.children.length > 0;
    if (e.hasTilesetContent && r) {
      const c = e.children[0];
      this.updateTileVisibility(c, t), e._visible = c._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, t)) {
      e._visible = !1;
      return;
    }
    const i = e.refine === ru.REPLACE, o = e._optimChildrenWithinParent === z9.USE_OPTIMIZATION;
    if (i && o && r && !this.anyChildrenVisible(e, t)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, t) {
    const {
      parent: r
    } = e;
    return !r || r.hasTilesetContent || r.refine !== ru.ADD ? !1 : !this.shouldRefine(e, t, !0);
  }
}
class tj {
  constructor() {
    V(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  register(e, t) {
    const r = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), i = r.get(t) || 0;
    r.set(t, i + 1), this.frameNumberMap.set(e, r);
  }
  deregister(e, t) {
    const r = this.frameNumberMap.get(e);
    if (!r)
      return;
    const i = r.get(t) || 1;
    r.set(t, i - 1);
  }
  isZero(e, t) {
    var r;
    return (((r = this.frameNumberMap.get(e)) === null || r === void 0 ? void 0 : r.get(t)) || 0) === 0;
  }
}
const O_ = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class nj {
  constructor() {
    V(this, "_statusMap", void 0), V(this, "pendingTilesRegister", new tj()), this._statusMap = {};
  }
  add(e, t, r, i) {
    if (!this._statusMap[t]) {
      const {
        frameNumber: o,
        viewport: {
          id: c
        }
      } = i;
      this._statusMap[t] = {
        request: e,
        callback: r,
        key: t,
        frameState: i,
        status: O_.REQUESTED
      }, this.pendingTilesRegister.register(c, o), e().then((l) => {
        this._statusMap[t].status = O_.COMPLETED;
        const {
          frameNumber: _,
          viewport: {
            id: b
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(b, _), this._statusMap[t].callback(l, i);
      }).catch((l) => {
        this._statusMap[t].status = O_.ERROR;
        const {
          frameNumber: _,
          viewport: {
            id: b
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(b, _), r(l);
      });
    }
  }
  update(e, t) {
    if (this._statusMap[e]) {
      const {
        frameNumber: r,
        viewport: {
          id: i
        }
      } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(i, r);
      const {
        frameNumber: o,
        viewport: {
          id: c
        }
      } = t;
      this.pendingTilesRegister.register(c, o), this._statusMap[e].frameState = t;
    }
  }
  find(e) {
    return this._statusMap[e];
  }
  hasPendingTiles(e, t) {
    return !this.pendingTilesRegister.isZero(e, t);
  }
}
class rj extends Hm {
  constructor(e) {
    super(e), V(this, "_tileManager", void 0), this._tileManager = new nj();
  }
  traversalFinished(e) {
    return !this._tileManager.hasPendingTiles(e.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(e, t) {
    return e._lodJudge = J9(e, t), e._lodJudge === "DIG";
  }
  updateChildTiles(e, t) {
    const r = e.header.children || [], i = e.children, o = e.tileset;
    for (const c of r) {
      const l = "".concat(c.id, "-").concat(t.viewport.id), _ = i && i.find((b) => b.id === l);
      if (_)
        _ && this.updateTile(_, t);
      else {
        let b = () => this._loadTile(c.id, o);
        this._tileManager.find(l) ? this._tileManager.update(l, t) : (o.tileset.nodePages && (b = () => o.tileset.nodePagesTile.formTileFromNodePages(c.id)), this._tileManager.add(b, l, (T) => this._onTileLoad(T, e, l), t));
      }
    }
    return !1;
  }
  async _loadTile(e, t) {
    const {
      loader: r
    } = t, i = t.getTileUrl("".concat(t.url, "/nodes/").concat(e)), o = {
      ...t.loadOptions,
      i3s: {
        ...t.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await Hu(i, r, o);
  }
  _onTileLoad(e, t, r) {
    const i = new Vy(t.tileset, e, t, r);
    t.children.push(i);
    const o = this._tileManager.find(i.id).frameState;
    this.updateTile(i, o), this._frameNumber === o.frameNumber && (this.traversalFinished(o) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(i, o);
  }
}
const ij = {
  description: "",
  ellipsoid: _i.WGS84,
  modelMatrix: new lr(),
  throttleRequests: !0,
  maxRequests: 64,
  maximumMemoryUsage: 32,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (n) => n,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: {
    fetch: {}
  },
  attributions: [],
  basePath: "",
  i3s: {}
}, kg = "Tiles In Tileset(s)", D_ = "Tiles In Memory", uA = "Tiles In View", hA = "Tiles To Render", dA = "Tiles Loaded", F_ = "Tiles Loading", fA = "Tiles Unloaded", pA = "Failed Tile Loads", gA = "Points/Vertices", k_ = "Tile Memory Use";
class sj {
  constructor(e, t) {
    V(this, "options", void 0), V(this, "loadOptions", void 0), V(this, "type", void 0), V(this, "tileset", void 0), V(this, "loader", void 0), V(this, "url", void 0), V(this, "basePath", void 0), V(this, "modelMatrix", void 0), V(this, "ellipsoid", void 0), V(this, "lodMetricType", void 0), V(this, "lodMetricValue", void 0), V(this, "refine", void 0), V(this, "root", null), V(this, "roots", {}), V(this, "asset", {}), V(this, "description", ""), V(this, "properties", void 0), V(this, "extras", null), V(this, "attributions", {}), V(this, "credits", {}), V(this, "stats", void 0), V(this, "contentFormats", {
      draco: !1,
      meshopt: !1,
      dds: !1,
      ktx2: !1
    }), V(this, "cartographicCenter", null), V(this, "cartesianCenter", null), V(this, "zoom", 1), V(this, "boundingVolume", null), V(this, "dynamicScreenSpaceErrorComputedDensity", 0), V(this, "maximumMemoryUsage", 32), V(this, "gpuMemoryUsageInBytes", 0), V(this, "_frameNumber", 0), V(this, "_queryParams", {}), V(this, "_extensionsUsed", []), V(this, "_tiles", {}), V(this, "_pendingCount", 0), V(this, "selectedTiles", []), V(this, "traverseCounter", 0), V(this, "geometricError", 0), V(this, "lastUpdatedVieports", null), V(this, "_requestedTiles", []), V(this, "_emptyTiles", []), V(this, "frameStateData", {}), V(this, "_traverser", void 0), V(this, "_cache", new P9()), V(this, "_requestScheduler", void 0), V(this, "updatePromise", null), V(this, "tilesetInitializationPromise", void 0), this.options = {
      ...ij,
      ...t
    }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || A1(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new xP({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.stats = new Bp({
      id: this.url
    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  destroy() {
    this._destroy();
  }
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  setOptions(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  getTileUrl(e) {
    return e.startsWith("data:") ? e : "".concat(e).concat(e.includes("?") ? "&" : "?").concat(this.queryParams);
  }
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  async selectTiles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((t) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), t(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const t = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = t.length;
    const r = [];
    for (const i of t) {
      const o = i.id;
      this._needTraverse(o) ? r.push(o) : this.traverseCounter--;
    }
    for (const i of t) {
      const o = i.id;
      if (this.roots[o] || (this.roots[o] = this._initializeTileHeaders(this.tileset, null)), !r.includes(o))
        continue;
      const c = M9(i, this._frameNumber);
      this._traverser.traverse(this.roots[o], c, this.options);
    }
  }
  _needTraverse(e) {
    let t = e;
    return this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e;
  }
  _onTraversalEnd(e) {
    const t = e.viewport.id;
    this.frameStateData[t] || (this.frameStateData[t] = {
      selectedTiles: [],
      _requestedTiles: [],
      _emptyTiles: []
    });
    const r = this.frameStateData[t], i = Object.values(this._traverser.selectedTiles), [o, c] = B9(i, e, this.options.maximumTilesSelected);
    r.selectedTiles = o;
    for (const l of c)
      l.unselect();
    r._requestedTiles = Object.values(this._traverser.requestedTiles), r._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const t = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(t.selectedTiles), this._requestedTiles = this._requestedTiles.concat(t._requestedTiles), this._emptyTiles = this._emptyTiles.concat(t._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, t) {
    if (e.length !== t.length)
      return !0;
    const r = new Set(e.map((c) => c.id)), i = new Set(t.map((c) => c.id));
    let o = e.filter((c) => !i.has(c.id)).length > 0;
    return o = o || t.filter((c) => !r.has(c.id)).length > 0, o;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
  }
  _updateStats() {
    let e = 0, t = 0;
    for (const r of this.selectedTiles)
      r.contentAvailable && r.content && (e++, r.content.pointCount ? t += r.content.pointCount : t += r.content.vertexCount);
    this.stats.get(uA).count = this.selectedTiles.length, this.stats.get(hA).count = e, this.stats.get(gA).count = t;
  }
  async _initializeTileSet(e) {
    this.type === qa.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === qa.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === qa.I3S && this._initializeI3STileset();
  }
  calculateViewPropsI3S() {
    var e;
    const t = this.tileset.fullExtent;
    if (t) {
      const {
        xmin: i,
        xmax: o,
        ymin: c,
        ymax: l,
        zmin: _,
        zmax: b
      } = t;
      this.cartographicCenter = new Ke(i + (o - i) / 2, c + (l - c) / 2, _ + (b - _) / 2), this.cartesianCenter = _i.WGS84.cartographicToCartesian(this.cartographicCenter, new Ke()), this.zoom = ZE(t, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const r = (e = this.tileset.store) === null || e === void 0 ? void 0 : e.extent;
    if (r) {
      const [i, o, c, l] = r;
      this.cartographicCenter = new Ke(i + (c - i) / 2, o + (l - o) / 2, 0), this.cartesianCenter = _i.WGS84.cartographicToCartesian(this.cartographicCenter, new Ke()), this.zoom = k9(r, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new Ke(), this.zoom = 1;
  }
  calculateViewPropsTiles3D() {
    const e = this.root, {
      center: t
    } = e.boundingVolume;
    if (!t) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new Ke(), this.zoom = 1;
      return;
    }
    t[0] !== 0 || t[1] !== 0 || t[2] !== 0 ? this.cartographicCenter = _i.WGS84.cartesianToCartographic(t, new Ke()) : this.cartographicCenter = new Ke(0, 0, -_i.WGS84.radii[0]), this.cartesianCenter = t, this.zoom = F9(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(kg), this.stats.get(F_), this.stats.get(D_), this.stats.get(uA), this.stats.get(hA), this.stats.get(dA), this.stats.get(fA), this.stats.get(pA), this.stats.get(gA), this.stats.get(k_, "memory");
  }
  _initializeTileHeaders(e, t) {
    const r = new Vy(this, e.root, t);
    if (t && (t.children.push(r), r.depth = t.depth + 1), this.type === qa.TILES3D) {
      const o = [];
      for (o.push(r); o.length > 0; ) {
        const c = o.pop();
        this.stats.get(kg).incrementCount();
        const l = c.header.children || [];
        for (const _ of l) {
          var i;
          const b = new Vy(this, _, c);
          if ((i = b.contentUrl) !== null && i !== void 0 && i.includes("?session=")) {
            const T = new URL(b.contentUrl).searchParams.get("session");
            T && (this._queryParams.session = T);
          }
          c.children.push(b), b.depth = c.depth + 1, o.push(b);
        }
      }
    }
    return r;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case qa.TILES3D:
        e = ej;
        break;
      case qa.I3S:
        e = rj;
        break;
      default:
        e = Hm;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let t;
    try {
      this._onStartTileLoading(), t = await e.loadContent();
    } catch (r) {
      this._onTileLoadError(e, r instanceof Error ? r : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, t);
    }
  }
  _onTileLoadError(e, t) {
    this.stats.get(pA).incrementCount();
    const r = t.message || t.toString(), i = e.url;
    console.error("A 3D tile failed to load: ".concat(e.url, " ").concat(r)), this.options.onTileError(e, r, i);
  }
  _onTileLoad(e, t) {
    if (t) {
      if (this.type === qa.I3S) {
        var r, i;
        const o = ((r = this.tileset) === null || r === void 0 || (i = r.nodePagesTile) === null || i === void 0 ? void 0 : i.nodesInNodePages) || 0;
        this.stats.get(kg).reset(), this.stats.get(kg).addCount(o);
      }
      e && e.content && L9(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  updateContentTypes(e) {
    if (this.type === qa.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === qa.TILES3D) {
      var t;
      const {
        extensionsRemoved: r = []
      } = ((t = e.content) === null || t === void 0 ? void 0 : t.gltf) || {};
      r.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), r.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), r.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(F_).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(F_).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (t) => t._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(dA).incrementCount(), this.stats.get(D_).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(k_).count = this.gpuMemoryUsageInBytes;
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(D_).decrementCount(), this.stats.get(fA).incrementCount(), this.stats.get(k_).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const t = e.pop();
      for (const r of t.children)
        e.push(r);
      this._destroyTile(t);
    }
    this.root = null;
  }
  _destroySubtree(e) {
    const t = e, r = [];
    for (r.push(t); r.length > 0; ) {
      e = r.pop();
      for (const i of e.children)
        r.push(i);
      e !== t && this._destroyTile(e);
    }
    t.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const t = new URLSearchParams(e.queryString), r = Object.fromEntries(t.entries());
      this._queryParams = {
        ...this._queryParams,
        ...r
      };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0")
      throw new Error("The tileset must be 3D Tiles version 0.0 or 1.0.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const eT = "3.4.15", Zf = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GEOMETRY: "geom",
  VECTOR: "vect",
  GLTF: "glTF"
};
function tT(n, e, t) {
  Zr(n instanceof ArrayBuffer);
  const r = new TextDecoder("utf8"), i = new Uint8Array(n, e, t);
  return r.decode(i);
}
function oj(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const t = new DataView(n);
  return "".concat(String.fromCharCode(t.getUint8(e + 0))).concat(String.fromCharCode(t.getUint8(e + 1))).concat(String.fromCharCode(t.getUint8(e + 2))).concat(String.fromCharCode(t.getUint8(e + 3)));
}
const aj = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Hi = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, dr = {
  ...aj,
  ...Hi
}, N_ = {
  [Hi.DOUBLE]: Float64Array,
  [Hi.FLOAT]: Float32Array,
  [Hi.UNSIGNED_SHORT]: Uint16Array,
  [Hi.UNSIGNED_INT]: Uint32Array,
  [Hi.UNSIGNED_BYTE]: Uint8Array,
  [Hi.BYTE]: Int8Array,
  [Hi.SHORT]: Int16Array,
  [Hi.INT]: Int32Array
}, lj = {
  DOUBLE: Hi.DOUBLE,
  FLOAT: Hi.FLOAT,
  UNSIGNED_SHORT: Hi.UNSIGNED_SHORT,
  UNSIGNED_INT: Hi.UNSIGNED_INT,
  UNSIGNED_BYTE: Hi.UNSIGNED_BYTE,
  BYTE: Hi.BYTE,
  SHORT: Hi.SHORT,
  INT: Hi.INT
}, z_ = "Failed to convert GL type";
class bc {
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const t in N_)
      if (N_[t] === e)
        return t;
    throw new Error(z_);
  }
  static fromName(e) {
    const t = lj[e];
    if (!t)
      throw new Error(z_);
    return t;
  }
  static getArrayType(e) {
    switch (e) {
      case Hi.UNSIGNED_SHORT_5_6_5:
      case Hi.UNSIGNED_SHORT_4_4_4_4:
      case Hi.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const t = N_[e];
        if (!t)
          throw new Error(z_);
        return t;
    }
  }
  static getByteSize(e) {
    return bc.getArrayType(e).BYTES_PER_ELEMENT;
  }
  static validate(e) {
    return !!bc.getArrayType(e);
  }
  static createTypedArray(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 ? arguments[3] : void 0;
    i === void 0 && (i = (t.byteLength - r) / bc.getByteSize(e));
    const o = bc.getArrayType(e);
    return new o(t, r, i);
  }
}
function cj(n, e) {
  if (!n)
    throw new Error("math.gl assertion failed. ".concat(e));
}
function uj(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  const t = n >> 11 & 31, r = n >> 5 & 63, i = n & 31;
  return e[0] = t << 3, e[1] = r << 2, e[2] = i << 3, e;
}
new V1();
new Ke();
new V1();
new V1();
function mA(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
  return eu(n, 0, e) / e * 2 - 1;
}
function _A(n) {
  return n < 0 ? -1 : 1;
}
function hj(n, e, t, r) {
  if (cj(r), n < 0 || n > t || e < 0 || e > t)
    throw new Error("x and y must be unsigned normalized integers between 0 and ".concat(t));
  if (r.x = mA(n, t), r.y = mA(e, t), r.z = 1 - (Math.abs(r.x) + Math.abs(r.y)), r.z < 0) {
    const i = r.x;
    r.x = (1 - Math.abs(r.y)) * _A(i), r.y = (1 - Math.abs(i)) * _A(r.y);
  }
  return r.normalize();
}
function dj(n, e, t) {
  return hj(n, e, 255, t);
}
class Ab {
  constructor(e, t) {
    V(this, "json", void 0), V(this, "buffer", void 0), V(this, "featuresLength", 0), V(this, "_cachedTypedArrays", {}), this.json = e, this.buffer = t;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : dr.UNSIGNED_INT, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? this._getTypedArrayFromBinary(e, t, r, 1, i.byteOffset) : i;
  }
  getPropertyArray(e, t, r) {
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? ("componentType" in i && (t = bc.fromName(i.componentType)), this._getTypedArrayFromBinary(e, t, r, this.featuresLength, i.byteOffset)) : this._getTypedArrayFromArray(e, t, i);
  }
  getProperty(e, t, r, i, o) {
    const c = this.json[e];
    if (!c)
      return c;
    const l = this.getPropertyArray(e, t, r);
    if (r === 1)
      return l[i];
    for (let _ = 0; _ < r; ++_)
      o[_] = l[r * i + _];
    return o;
  }
  _getTypedArrayFromBinary(e, t, r, i, o) {
    const c = this._cachedTypedArrays;
    let l = c[e];
    return l || (l = bc.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + o, i * r), c[e] = l), l;
  }
  _getTypedArrayFromArray(e, t, r) {
    const i = this._cachedTypedArrays;
    let o = i[e];
    return o || (o = bc.createTypedArray(t, r), i[e] = o), o;
  }
}
const fj = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, pj = {
  SCALAR: (n, e) => n[e],
  VEC2: (n, e) => [n[2 * e + 0], n[2 * e + 1]],
  VEC3: (n, e) => [n[3 * e + 0], n[3 * e + 1], n[3 * e + 2]],
  VEC4: (n, e) => [n[4 * e + 0], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]],
  MAT2: (n, e) => [n[4 * e + 0], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]],
  MAT3: (n, e) => [n[9 * e + 0], n[9 * e + 1], n[9 * e + 2], n[9 * e + 3], n[9 * e + 4], n[9 * e + 5], n[9 * e + 6], n[9 * e + 7], n[9 * e + 8]],
  MAT4: (n, e) => [n[16 * e + 0], n[16 * e + 1], n[16 * e + 2], n[16 * e + 3], n[16 * e + 4], n[16 * e + 5], n[16 * e + 6], n[16 * e + 7], n[16 * e + 8], n[16 * e + 9], n[16 * e + 10], n[16 * e + 11], n[16 * e + 12], n[16 * e + 13], n[16 * e + 14], n[16 * e + 15]]
}, gj = {
  SCALAR: (n, e, t) => {
    e[t] = n;
  },
  VEC2: (n, e, t) => {
    e[2 * t + 0] = n[0], e[2 * t + 1] = n[1];
  },
  VEC3: (n, e, t) => {
    e[3 * t + 0] = n[0], e[3 * t + 1] = n[1], e[3 * t + 2] = n[2];
  },
  VEC4: (n, e, t) => {
    e[4 * t + 0] = n[0], e[4 * t + 1] = n[1], e[4 * t + 2] = n[2], e[4 * t + 3] = n[3];
  },
  MAT2: (n, e, t) => {
    e[4 * t + 0] = n[0], e[4 * t + 1] = n[1], e[4 * t + 2] = n[2], e[4 * t + 3] = n[3];
  },
  MAT3: (n, e, t) => {
    e[9 * t + 0] = n[0], e[9 * t + 1] = n[1], e[9 * t + 2] = n[2], e[9 * t + 3] = n[3], e[9 * t + 4] = n[4], e[9 * t + 5] = n[5], e[9 * t + 6] = n[6], e[9 * t + 7] = n[7], e[9 * t + 8] = n[8], e[9 * t + 9] = n[9];
  },
  MAT4: (n, e, t) => {
    e[16 * t + 0] = n[0], e[16 * t + 1] = n[1], e[16 * t + 2] = n[2], e[16 * t + 3] = n[3], e[16 * t + 4] = n[4], e[16 * t + 5] = n[5], e[16 * t + 6] = n[6], e[16 * t + 7] = n[7], e[16 * t + 8] = n[8], e[16 * t + 9] = n[9], e[16 * t + 10] = n[10], e[16 * t + 11] = n[11], e[16 * t + 12] = n[12], e[16 * t + 13] = n[13], e[16 * t + 14] = n[14], e[16 * t + 15] = n[15];
  }
};
function mj(n, e, t, r) {
  const {
    componentType: i
  } = n;
  Zr(n.componentType);
  const o = typeof i == "string" ? bc.fromName(i) : i, c = fj[n.type], l = pj[n.type], _ = gj[n.type];
  return t += n.byteOffset, {
    values: bc.createTypedArray(o, e, t, c * r),
    type: o,
    size: c,
    unpacker: l,
    packer: _
  };
}
const mc = (n) => n !== void 0;
function _j(n, e, t) {
  if (!e)
    return null;
  let r = n.getExtension("3DTILES_batch_table_hierarchy");
  const i = e.HIERARCHY;
  return i && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = i, r = i), r ? yj(r, t) : null;
}
function yj(n, e) {
  let t, r, i;
  const o = n.instancesLength, c = n.classes;
  let l = n.classIds, _ = n.parentCounts, b = n.parentIds, w = o;
  mc(l.byteOffset) && (l.componentType = defaultValue(l.componentType, GL.UNSIGNED_SHORT), l.type = AttributeType.SCALAR, i = getBinaryAccessor(l), l = i.createArrayBufferView(e.buffer, e.byteOffset + l.byteOffset, o));
  let T;
  if (mc(_))
    for (mc(_.byteOffset) && (_.componentType = defaultValue(_.componentType, GL.UNSIGNED_SHORT), _.type = AttributeType.SCALAR, i = getBinaryAccessor(_), _ = i.createArrayBufferView(e.buffer, e.byteOffset + _.byteOffset, o)), T = new Uint16Array(o), w = 0, t = 0; t < o; ++t)
      T[t] = w, w += _[t];
  mc(b) && mc(b.byteOffset) && (b.componentType = defaultValue(b.componentType, GL.UNSIGNED_SHORT), b.type = AttributeType.SCALAR, i = getBinaryAccessor(b), b = i.createArrayBufferView(e.buffer, e.byteOffset + b.byteOffset, w));
  const I = c.length;
  for (t = 0; t < I; ++t) {
    const G = c[t].length, H = c[t].instances, $ = getBinaryProperties(G, H, e);
    c[t].instances = combine($, H);
  }
  const P = new Array(I).fill(0), k = new Uint16Array(o);
  for (t = 0; t < o; ++t)
    r = l[t], k[t] = P[r], ++P[r];
  const U = {
    classes: c,
    classIds: l,
    classIndexes: k,
    parentCounts: _,
    parentIndexes: T,
    parentIds: b
  };
  return xj(U), U;
}
function Jf(n, e, t) {
  if (!n)
    return;
  const r = n.parentCounts;
  return n.parentIds ? t(n, e) : r > 0 ? bj(n, e, t) : vj(n, e, t);
}
function bj(n, e, t) {
  const r = n.classIds, i = n.parentCounts, o = n.parentIds, c = n.parentIndexes, l = r.length, _ = scratchVisited;
  _.length = Math.max(_.length, l);
  const b = ++marker, w = scratchStack;
  for (w.length = 0, w.push(e); w.length > 0; ) {
    if (e = w.pop(), _[e] === b)
      continue;
    _[e] = b;
    const T = t(n, e);
    if (mc(T))
      return T;
    const I = i[e], P = c[e];
    for (let k = 0; k < I; ++k) {
      const U = o[P + k];
      U !== e && w.push(U);
    }
  }
  return null;
}
function vj(n, e, t) {
  let r = !0;
  for (; r; ) {
    const i = t(n, e);
    if (mc(i))
      return i;
    const o = n.parentIds[e];
    r = o !== e, e = o;
  }
  throw new Error("traverseHierarchySingleParent");
}
function xj(n) {
  const t = n.classIds.length;
  for (let r = 0; r < t; ++r)
    nT(n, r, stack);
}
function nT(n, e, t) {
  const r = n.parentCounts, i = n.parentIds, o = n.parentIndexes, l = n.classIds.length;
  if (!mc(i))
    return;
  assert(e < l, "Parent index ".concat(e, " exceeds the total number of instances: ").concat(l)), assert(t.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), t.push(e);
  const _ = mc(r) ? r[e] : 1, b = mc(r) ? o[e] : e;
  for (let w = 0; w < _; ++w) {
    const T = i[b + w];
    T !== e && nT(n, T, t);
  }
  t.pop(e);
}
function Uo(n) {
  return n != null;
}
const Ng = (n, e) => n, wj = {
  HIERARCHY: !0,
  extensions: !0,
  extras: !0
};
class rT {
  constructor(e, t, r) {
    var i;
    let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    V(this, "json", void 0), V(this, "binary", void 0), V(this, "featureCount", void 0), V(this, "_extensions", void 0), V(this, "_properties", void 0), V(this, "_binaryProperties", void 0), V(this, "_hierarchy", void 0), Zr(r >= 0), this.json = e || {}, this.binary = t, this.featureCount = r, this._extensions = ((i = this.json) === null || i === void 0 ? void 0 : i.extensions) || {}, this._properties = {};
    for (const c in this.json)
      wj[c] || (this._properties[c] = this.json[c]);
    this._binaryProperties = this._initializeBinaryProperties(), o["3DTILES_batch_table_hierarchy"] && (this._hierarchy = _j(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, t) {
    if (this._checkBatchId(e), Zr(typeof t == "string", t), this._hierarchy) {
      const r = Jf(this._hierarchy, e, (i, o) => {
        const c = i.classIds[o];
        return i.classes[c].name === t;
      });
      return Uo(r);
    }
    return !1;
  }
  isExactClass(e, t) {
    return Zr(typeof t == "string", t), this.getExactClassName(e) === t;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const t = this._hierarchy.classIds[e];
      return this._hierarchy.classes[t].name;
    }
  }
  hasProperty(e, t) {
    return this._checkBatchId(e), Zr(typeof t == "string", t), Uo(this._properties[t]) || this._hasPropertyInHierarchy(e, t);
  }
  getPropertyNames(e, t) {
    this._checkBatchId(e), t = Uo(t) ? t : [], t.length = 0;
    const r = Object.keys(this._properties);
    return t.push(...r), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
  }
  getProperty(e, t) {
    if (this._checkBatchId(e), Zr(typeof t == "string", t), this._binaryProperties) {
      const i = this._binaryProperties[t];
      if (Uo(i))
        return this._getBinaryProperty(i, e);
    }
    const r = this._properties[t];
    if (Uo(r))
      return Ng(r[e]);
    if (this._hierarchy) {
      const i = this._getHierarchyProperty(e, t);
      if (Uo(i))
        return i;
    }
  }
  setProperty(e, t, r) {
    const i = this.featureCount;
    if (this._checkBatchId(e), Zr(typeof t == "string", t), this._binaryProperties) {
      const c = this._binaryProperties[t];
      if (c) {
        this._setBinaryProperty(c, e, r);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, t, r))
      return;
    let o = this._properties[t];
    Uo(o) || (this._properties[t] = new Array(i), o = this._properties[t]), o[e] = Ng(r);
  }
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, t) {
    return e.unpack(e.typedArray, t);
  }
  _setBinaryProperty(e, t, r) {
    e.pack(r, e.typedArray, t);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const t in this._properties) {
      const r = this._properties[t], i = this._initializeBinaryProperty(t, r);
      i && (e = e || {}, e[t] = i);
    }
    return e;
  }
  _initializeBinaryProperty(e, t) {
    if ("byteOffset" in t) {
      const r = t;
      Zr(this.binary, "Property ".concat(e, " requires a batch table binary.")), Zr(r.type, "Property ".concat(e, " requires a type."));
      const i = mj(r, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: i.values,
        componentCount: i.size,
        unpack: i.unpacker,
        pack: i.packer
      };
    }
    return null;
  }
  _hasPropertyInHierarchy(e, t) {
    if (!this._hierarchy)
      return !1;
    const r = Jf(this._hierarchy, e, (i, o) => {
      const c = i.classIds[o], l = i.classes[c].instances;
      return Uo(l[t]);
    });
    return Uo(r);
  }
  _getPropertyNamesInHierarchy(e, t) {
    Jf(this._hierarchy, e, (r, i) => {
      const o = r.classIds[i], c = r.classes[o].instances;
      for (const l in c)
        c.hasOwnProperty(l) && t.indexOf(l) === -1 && t.push(l);
    });
  }
  _getHierarchyProperty(e, t) {
    return Jf(this._hierarchy, e, (r, i) => {
      const o = r.classIds[i], c = r.classes[o], l = r.classIndexes[i], _ = c.instances[t];
      return Uo(_) ? Uo(_.typedArray) ? this._getBinaryProperty(_, l) : Ng(_[l]) : null;
    });
  }
  _setHierarchyProperty(e, t, r, i) {
    const o = Jf(this._hierarchy, t, (c, l) => {
      const _ = c.classIds[l], b = c.classes[_], w = c.classIndexes[l], T = b.instances[r];
      return Uo(T) ? (Zr(l === t, 'Inherited property "'.concat(r, '" is read-only.')), Uo(T.typedArray) ? this._setBinaryProperty(T, w, i) : T[w] = Ng(i), !0) : !1;
    });
    return Uo(o);
  }
}
const U_ = 4;
function Wm(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const r = new DataView(e);
  if (n.magic = r.getUint32(t, !0), t += U_, n.version = r.getUint32(t, !0), t += U_, n.byteLength = r.getUint32(t, !0), t += U_, n.version !== 1)
    throw new Error("3D Tile Version ".concat(n.version, " not supported"));
  return t;
}
const wd = 4, yA = "b3dm tile in legacy format.";
function Sb(n, e, t) {
  const r = new DataView(e);
  let i;
  n.header = n.header || {};
  let o = r.getUint32(t, !0);
  t += wd;
  let c = r.getUint32(t, !0);
  t += wd;
  let l = r.getUint32(t, !0);
  t += wd;
  let _ = r.getUint32(t, !0);
  return t += wd, l >= 570425344 ? (t -= wd * 2, i = o, l = c, _ = 0, o = 0, c = 0, console.warn(yA)) : _ >= 570425344 && (t -= wd, i = l, l = o, _ = c, o = 0, c = 0, console.warn(yA)), n.header.featureTableJsonByteLength = o, n.header.featureTableBinaryByteLength = c, n.header.batchTableJsonByteLength = l, n.header.batchTableBinaryByteLength = _, n.header.batchLength = i, t;
}
function Eb(n, e, t, r) {
  return t = Aj(n, e, t), t = Sj(n, e, t), t;
}
function Aj(n, e, t, r) {
  const {
    featureTableJsonByteLength: i,
    featureTableBinaryByteLength: o,
    batchLength: c
  } = n.header;
  if (n.featureTableJson = {
    BATCH_LENGTH: c || 0
  }, i > 0) {
    const l = tT(e, t, i);
    n.featureTableJson = JSON.parse(l);
  }
  return t += i, n.featureTableBinary = new Uint8Array(e, t, o), t += o, t;
}
function Sj(n, e, t, r) {
  const {
    batchTableJsonByteLength: i,
    batchTableBinaryByteLength: o
  } = n.header;
  if (i > 0) {
    const c = tT(e, t, i);
    n.batchTableJson = JSON.parse(c), t += i, o > 0 && (n.batchTableBinary = new Uint8Array(e, t, o), n.batchTableBinary = new Uint8Array(n.batchTableBinary), t += o);
  }
  return t;
}
function iT(n, e, t) {
  if (!e && (!n || !n.batchIds || !t))
    return null;
  const {
    batchIds: r,
    isRGB565: i,
    pointCount: o
  } = n;
  if (r && t) {
    const c = new Uint8ClampedArray(o * 3);
    for (let l = 0; l < o; l++) {
      const _ = r[l], w = t.getProperty(_, "dimensions").map((T) => T * 255);
      c[l * 3] = w[0], c[l * 3 + 1] = w[1], c[l * 3 + 2] = w[2];
    }
    return {
      type: dr.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  if (i) {
    const c = new Uint8ClampedArray(o * 3);
    for (let l = 0; l < o; l++) {
      const _ = uj(e[l]);
      c[l * 3] = _[0], c[l * 3 + 1] = _[1], c[l * 3 + 2] = _[2];
    }
    return {
      type: dr.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === o * 3 ? {
    type: dr.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: dr.UNSIGNED_BYTE,
    value: e,
    size: 4,
    normalized: !0
  };
}
const bA = new Ke();
function Ej(n, e) {
  if (!e)
    return null;
  if (n.isOctEncoded16P) {
    const t = new Float32Array(n.pointsLength * 3);
    for (let r = 0; r < n.pointsLength; r++)
      dj(e[r * 2], e[r * 2 + 1], bA), bA.toArray(t, r * 3);
    return {
      type: dr.FLOAT,
      size: 2,
      value: t
    };
  }
  return {
    type: dr.FLOAT,
    size: 2,
    value: e
  };
}
function Tj(n, e, t) {
  return n.isQuantized ? t["3d-tiles"] && t["3d-tiles"].decodeQuantizedPositions ? (n.isQuantized = !1, Cj(n, e)) : {
    type: dr.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function Cj(n, e) {
  const t = new Ke(), r = new Float32Array(n.pointCount * 3);
  for (let i = 0; i < n.pointCount; i++)
    t.set(e[i * 3], e[i * 3 + 1], e[i * 3 + 2]).scale(1 / n.quantizedRange).multiply(n.quantizedVolumeScale).add(n.quantizedVolumeOffset).toArray(r, i * 3);
  return r;
}
async function Ij(n, e, t, r, i) {
  t = Wm(n, e, t), t = Sb(n, e, t), t = Eb(n, e, t), Pj(n);
  const {
    featureTable: o,
    batchTable: c
  } = Lj(n);
  return await Dj(n, o, c, r, i), Mj(n, o, r), Bj(n, o, c), Rj(n, o), t;
}
function Pj(n) {
  n.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, n.isQuantized = !1, n.isTranslucent = !1, n.isRGB565 = !1, n.isOctEncoded16P = !1;
}
function Lj(n) {
  const e = new Ab(n.featureTableJson, n.featureTableBinary), t = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(t))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = t, n.featuresLength = t, n.pointsLength = t, n.pointCount = t, n.rtcCenter = e.getGlobalProperty("RTC_CENTER", dr.FLOAT, 3);
  const r = Oj(n, e);
  return {
    featureTable: e,
    batchTable: r
  };
}
function Mj(n, e, t) {
  if (!n.attributes.positions) {
    if (e.hasProperty("POSITION"))
      n.attributes.positions = e.getPropertyArray("POSITION", dr.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const r = e.getPropertyArray("POSITION_QUANTIZED", dr.UNSIGNED_SHORT, 3);
      if (n.isQuantized = !0, n.quantizedRange = 65535, n.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", dr.FLOAT, 3), !n.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (n.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", dr.FLOAT, 3), !n.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      n.attributes.positions = Tj(n, r, t);
    }
  }
  if (!n.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function Bj(n, e, t) {
  if (!n.attributes.colors) {
    let r = null;
    e.hasProperty("RGBA") ? (r = e.getPropertyArray("RGBA", dr.UNSIGNED_BYTE, 4), n.isTranslucent = !0) : e.hasProperty("RGB") ? r = e.getPropertyArray("RGB", dr.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (r = e.getPropertyArray("RGB565", dr.UNSIGNED_SHORT, 1), n.isRGB565 = !0), n.attributes.colors = iT(n, r, t);
  }
  e.hasProperty("CONSTANT_RGBA") && (n.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", dr.UNSIGNED_BYTE, 4));
}
function Rj(n, e) {
  if (!n.attributes.normals) {
    let t = null;
    e.hasProperty("NORMAL") ? t = e.getPropertyArray("NORMAL", dr.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (t = e.getPropertyArray("NORMAL_OCT16P", dr.UNSIGNED_BYTE, 2), n.isOctEncoded16P = !0), n.attributes.normals = Ej(n, t);
  }
}
function Oj(n, e) {
  let t = null;
  if (!n.batchIds && e.hasProperty("BATCH_ID") && (n.batchIds = e.getPropertyArray("BATCH_ID", dr.UNSIGNED_SHORT, 1), n.batchIds)) {
    const r = e.getGlobalProperty("BATCH_LENGTH");
    if (!r)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const {
      batchTableJson: i,
      batchTableBinary: o
    } = n;
    t = new rT(i, o, r);
  }
  return t;
}
async function Dj(n, e, t, r, i) {
  let o, c, l;
  const _ = n.batchTableJson && n.batchTableJson.extensions && n.batchTableJson.extensions["3DTILES_draco_point_compression"];
  _ && (l = _.properties);
  const b = e.getExtension("3DTILES_draco_point_compression");
  if (b) {
    c = b.properties;
    const T = b.byteOffset, I = b.byteLength;
    if (!c || !Number.isFinite(T) || !I)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    o = n.featureTableBinary.slice(T, T + I), n.hasPositions = Number.isFinite(c.POSITION), n.hasColors = Number.isFinite(c.RGB) || Number.isFinite(c.RGBA), n.hasNormals = Number.isFinite(c.NORMAL), n.hasBatchIds = Number.isFinite(c.BATCH_ID), n.isTranslucent = Number.isFinite(c.RGBA);
  }
  if (!o)
    return !0;
  const w = {
    buffer: o,
    properties: {
      ...c,
      ...l
    },
    featureTableProperties: c,
    batchTableProperties: l,
    dequantizeInShader: !1
  };
  return await Fj(n, w, r, i);
}
async function Fj(n, e, t, r) {
  const {
    parse: i
  } = r, o = {
    ...t,
    draco: {
      ...t.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete o["3d-tiles"];
  const c = await i(e.buffer, GE, o), l = c.attributes.POSITION && c.attributes.POSITION.value, _ = c.attributes.COLOR_0 && c.attributes.COLOR_0.value, b = c.attributes.NORMAL && c.attributes.NORMAL.value, w = c.attributes.BATCH_ID && c.attributes.BATCH_ID.value, T = l && c.attributes.POSITION.value.quantization, I = b && c.attributes.NORMAL.value.quantization;
  if (T) {
    const k = c.POSITION.data.quantization, U = k.range;
    n.quantizedVolumeScale = new Ke(U, U, U), n.quantizedVolumeOffset = new Ke(k.minValues), n.quantizedRange = (1 << k.quantizationBits) - 1, n.isQuantizedDraco = !0;
  }
  I && (n.octEncodedRange = (1 << c.NORMAL.data.quantization.quantizationBits) - 1, n.isOctEncodedDraco = !0);
  const P = {};
  if (e.batchTableProperties)
    for (const k of Object.keys(e.batchTableProperties))
      c.attributes[k] && c.attributes[k].value && (P[k.toLowerCase()] = c.attributes[k].value);
  n.attributes = {
    positions: l,
    colors: iT(n, _, void 0),
    normals: b,
    batchIds: w,
    ...P
  };
}
const qy = {
  URI: 0,
  EMBEDDED: 1
};
function sT(n, e, t, r) {
  n.rotateYtoZ = !0;
  const i = n.byteOffset + n.byteLength - t;
  if (i === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return n.gltfUpAxis = r["3d-tiles"] && r["3d-tiles"].assetGltfUpAxis ? r["3d-tiles"].assetGltfUpAxis : "Y", n.gltfArrayBuffer = w1(e, t, i), n.gltfByteOffset = 0, n.gltfByteLength = i, t % 4 === 0 || console.warn("".concat(n.type, ": embedded glb is not aligned to a 4-byte boundary.")), n.byteOffset + n.byteLength;
}
async function oT(n, e, t, r) {
  const i = t["3d-tiles"] || {};
  if (kj(n, e), i.loadGLTF) {
    const {
      parse: o,
      fetch: c
    } = r;
    n.gltfUrl && (n.gltfArrayBuffer = await c(n.gltfUrl, t), n.gltfByteOffset = 0), n.gltfArrayBuffer && (n.gltf = await o(n.gltfArrayBuffer, Sp, t, r), n.gpuMemoryUsageInBytes = UE(n.gltf), delete n.gltfArrayBuffer, delete n.gltfByteOffset, delete n.gltfByteLength);
  }
}
function kj(n, e, t) {
  switch (e) {
    case qy.URI:
      const r = new Uint8Array(n.gltfArrayBuffer, n.gltfByteOffset), o = new TextDecoder().decode(r);
      n.gltfUrl = o.replace(/[\s\0]+$/, ""), delete n.gltfArrayBuffer, delete n.gltfByteOffset, delete n.gltfByteLength;
      break;
    case qy.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function Nj(n, e, t, r, i) {
  var o;
  t = zj(n, e, t, r), await oT(n, qy.EMBEDDED, r, i);
  const c = n == null || (o = n.gltf) === null || o === void 0 ? void 0 : o.extensions;
  return c && c.CESIUM_RTC && (n.rtcCenter = c.CESIUM_RTC.center), t;
}
function zj(n, e, t, r, i) {
  t = Wm(n, e, t), t = Sb(n, e, t), t = Eb(n, e, t), t = sT(n, e, t, r);
  const o = new Ab(n.featureTableJson, n.featureTableBinary);
  return n.rtcCenter = o.getGlobalProperty("RTC_CENTER", dr.FLOAT, 3), t;
}
async function Uj(n, e, t, r, i) {
  return t = jj(n, e, t, r), await oT(n, n.gltfFormat, r, i), t;
}
function jj(n, e, t, r, i) {
  if (t = Wm(n, e, t), n.version !== 1)
    throw new Error("Instanced 3D Model version ".concat(n.version, " is not supported"));
  t = Sb(n, e, t);
  const o = new DataView(e);
  if (n.gltfFormat = o.getUint32(t, !0), t += 4, t = Eb(n, e, t), t = sT(n, e, t, r), n.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const c = new Ab(n.featureTableJson, n.featureTableBinary), l = c.getGlobalProperty("INSTANCES_LENGTH");
  if (c.featuresLength = l, !Number.isFinite(l))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  n.eastNorthUp = c.getGlobalProperty("EAST_NORTH_UP"), n.rtcCenter = c.getGlobalProperty("RTC_CENTER", dr.FLOAT, 3);
  const _ = new rT(n.batchTableJson, n.batchTableBinary, l);
  return Gj(n, c, _, l), t;
}
function Gj(n, e, t, r) {
  const o = {
    instances: new Array(r),
    batchTable: n._batchTable,
    cull: !1,
    url: void 0,
    gltf: void 0,
    basePath: void 0,
    incrementallyLoadTextures: !1,
    forwardAxis: [1, 0, 0]
  }.instances, c = new Ke();
  new Ke(), new Ke(), new Ke();
  const l = new Ci(), _ = new bp(), b = new Ke(), w = {}, T = new lr(), I = [], P = [], k = new Ke(), U = new Ke();
  for (let G = 0; G < r; G++) {
    let H;
    if (e.hasProperty("POSITION"))
      H = e.getProperty("POSITION", dr.FLOAT, 3, G, c);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      H = e.getProperty("POSITION_QUANTIZED", dr.UNSIGNED_SHORT, 3, G, c);
      const Le = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", dr.FLOAT, 3, k);
      if (!Le)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const _e = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", dr.FLOAT, 3, U);
      if (!_e)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const Ge = 65535;
      for (let ke = 0; ke < 3; ke++)
        H[ke] = H[ke] / Ge * _e[ke] + Le[ke];
    }
    if (!H)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (c.copy(H), w.translation = c, n.normalUp = e.getProperty("NORMAL_UP", dr.FLOAT, 3, G, I), n.normalRight = e.getProperty("NORMAL_RIGHT", dr.FLOAT, 3, G, P), n.normalUp) {
      if (!n.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      n.hasCustomOrientation = !0;
    } else {
      if (n.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", dr.UNSIGNED_SHORT, 2, I), n.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", dr.UNSIGNED_SHORT, 2, P), n.octNormalUp)
        throw n.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      n.eastNorthUp ? (_i.WGS84.eastNorthUpToFixedFrame(c, T), T.getRotationMatrix3(l)) : l.identity();
    }
    _.fromMatrix3(l), w.rotation = _, b.set(1, 1, 1);
    const $ = e.getProperty("SCALE", dr.FLOAT, 1, G);
    Number.isFinite($) && b.multiplyByScalar($);
    const ie = e.getProperty("SCALE_NON_UNIFORM", dr.FLOAT, 3, G, I);
    ie && b.scale(ie), w.scale = b;
    let ge = e.getProperty("BATCH_ID", dr.UNSIGNED_SHORT, 1, G);
    ge === void 0 && (ge = G);
    const Se = new lr().fromQuaternion(w.rotation);
    T.identity(), T.translate(w.translation), T.multiplyRight(Se), T.scale(w.scale);
    const Re = T.clone();
    o[G] = {
      modelMatrix: Re,
      batchId: ge
    };
  }
  n.instances = o;
}
async function Vj(n, e, t, r, i, o) {
  t = Wm(n, e, t);
  const c = new DataView(e);
  for (n.tilesLength = c.getUint32(t, !0), t += 4, n.tiles = []; n.tiles.length < n.tilesLength && n.byteLength - t > 12; ) {
    const l = {};
    n.tiles.push(l), t = await o(e, t, r, i, l);
  }
  return t;
}
async function qj(n, e, t, r) {
  n.rotateYtoZ = !0, n.gltfUpAxis = t["3d-tiles"] && t["3d-tiles"].assetGltfUpAxis ? t["3d-tiles"].assetGltfUpAxis : "Y";
  const {
    parse: i
  } = r;
  n.gltf = await i(e, Sp, t, r), n.gpuMemoryUsageInBytes = UE(n.gltf);
}
async function aT(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 ? arguments[2] : void 0, r = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  switch (i.byteOffset = e, i.type = oj(n, e), i.type) {
    case Zf.COMPOSITE:
      return await Vj(i, n, e, t, r, aT);
    case Zf.BATCHED_3D_MODEL:
      return await Nj(i, n, e, t, r);
    case Zf.GLTF:
      return await qj(i, n, t, r);
    case Zf.INSTANCED_3D_MODEL:
      return await Uj(i, n, e, t, r);
    case Zf.POINT_CLOUD:
      return await Ij(i, n, e, t, r);
    default:
      throw new Error("3DTileLoader: unknown type ".concat(i.type));
  }
}
const Hj = 1952609651, Wj = 1;
async function Xj(n, e, t) {
  if (new Uint32Array(n.slice(0, 4))[0] !== Hj)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(n.slice(4, 8))[0] !== Wj)
    throw new Error("Wrong subtree file verson, must be 1");
  const o = vA(n.slice(8, 16)), c = new Uint8Array(n, 24, o), _ = new TextDecoder("utf8").decode(c), b = JSON.parse(_), w = vA(n.slice(16, 24));
  let T = new ArrayBuffer(0);
  return w && (T = n.slice(24 + o)), "bufferView" in b.tileAvailability && (b.tileAvailability.explicitBitstream = await j_(b, "tileAvailability", T, t)), "bufferView" in b.contentAvailability && (b.contentAvailability.explicitBitstream = await j_(b, "contentAvailability", T, t)), "bufferView" in b.childSubtreeAvailability && (b.childSubtreeAvailability.explicitBitstream = await j_(b, "childSubtreeAvailability", T, t)), b;
}
function $j(n, e) {
  if (e.startsWith("http")) {
    const o = new URL(n, e);
    return decodeURI(o.toString());
  }
  const r = "http://".concat(e), i = new URL(n, r);
  return "/".concat(i.host).concat(i.pathname);
}
async function j_(n, e, t, r) {
  const i = n[e].bufferView, o = n.bufferViews[i], c = n.buffers[o.buffer];
  if (!(r != null && r.url) || !r.fetch)
    throw new Error("Url is not provided");
  if (!r.fetch)
    throw new Error("fetch is not provided");
  if (c.uri) {
    const l = $j(c.uri, r == null ? void 0 : r.url), b = await (await r.fetch(l)).arrayBuffer();
    return new Uint8Array(b, o.byteOffset, o.byteLength);
  }
  return new Uint8Array(t, o.byteOffset, o.byteLength);
}
function vA(n) {
  const e = new DataView(n), t = e.getUint32(0, !0), r = e.getUint32(4, !0);
  return t + 2 ** 32 * r;
}
const lT = {
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: eT,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: Xj,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var $a = null;
try {
  $a = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
function Ur(n, e, t) {
  this.low = n | 0, this.high = e | 0, this.unsigned = !!t;
}
Ur.prototype.__isLong__;
Object.defineProperty(Ur.prototype, "__isLong__", {
  value: !0
});
function ro(n) {
  return (n && n.__isLong__) === !0;
}
function xA(n) {
  var e = Math.clz32(n & -n);
  return n ? 31 - e : e;
}
Ur.isLong = ro;
var wA = {}, AA = {};
function qh(n, e) {
  var t, r, i;
  return e ? (n >>>= 0, (i = 0 <= n && n < 256) && (r = AA[n], r) ? r : (t = mr(n, 0, !0), i && (AA[n] = t), t)) : (n |= 0, (i = -128 <= n && n < 128) && (r = wA[n], r) ? r : (t = mr(n, n < 0 ? -1 : 0, !1), i && (wA[n] = t), t));
}
Ur.fromInt = qh;
function Za(n, e) {
  if (isNaN(n)) return e ? tu : wl;
  if (e) {
    if (n < 0) return tu;
    if (n >= cT) return dT;
  } else {
    if (n <= -EA) return Vo;
    if (n + 1 >= EA) return hT;
  }
  return n < 0 ? Za(-n, e).neg() : mr(n % ef | 0, n / ef | 0, e);
}
Ur.fromNumber = Za;
function mr(n, e, t) {
  return new Ur(n, e, t);
}
Ur.fromBits = mr;
var Pm = Math.pow;
function Tb(n, e, t) {
  if (n.length === 0) throw Error("empty string");
  if (typeof e == "number" ? (t = e, e = !1) : e = !!e, n === "NaN" || n === "Infinity" || n === "+Infinity" || n === "-Infinity") return e ? tu : wl;
  if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix");
  var r;
  if ((r = n.indexOf("-")) > 0) throw Error("interior hyphen");
  if (r === 0)
    return Tb(n.substring(1), e, t).neg();
  for (var i = Za(Pm(t, 8)), o = wl, c = 0; c < n.length; c += 8) {
    var l = Math.min(8, n.length - c), _ = parseInt(n.substring(c, c + l), t);
    if (l < 8) {
      var b = Za(Pm(t, l));
      o = o.mul(b).add(Za(_));
    } else
      o = o.mul(i), o = o.add(Za(_));
  }
  return o.unsigned = e, o;
}
Ur.fromString = Tb;
function Tl(n, e) {
  return typeof n == "number" ? Za(n, e) : typeof n == "string" ? Tb(n, e) : mr(n.low, n.high, typeof e == "boolean" ? e : n.unsigned);
}
Ur.fromValue = Tl;
var SA = 65536, Zj = 1 << 24, ef = SA * SA, cT = ef * ef, EA = cT / 2, TA = qh(Zj), wl = qh(0);
Ur.ZERO = wl;
var tu = qh(0, !0);
Ur.UZERO = tu;
var Rd = qh(1);
Ur.ONE = Rd;
var uT = qh(1, !0);
Ur.UONE = uT;
var Hy = qh(-1);
Ur.NEG_ONE = Hy;
var hT = mr(-1, 2147483647, !1);
Ur.MAX_VALUE = hT;
var dT = mr(-1, -1, !0);
Ur.MAX_UNSIGNED_VALUE = dT;
var Vo = mr(0, -2147483648, !1);
Ur.MIN_VALUE = Vo;
var Rt = Ur.prototype;
Rt.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
Rt.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * ef + (this.low >>> 0) : this.high * ef + (this.low >>> 0);
};
Rt.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative())
    if (this.eq(Vo)) {
      var t = Za(e), r = this.div(t), i = r.mul(t).sub(this);
      return r.toString(e) + i.toInt().toString(e);
    } else return "-" + this.neg().toString(e);
  for (var o = Za(Pm(e, 6), this.unsigned), c = this, l = ""; ; ) {
    var _ = c.div(o), b = c.sub(_.mul(o)).toInt() >>> 0, w = b.toString(e);
    if (c = _, c.isZero()) return w + l;
    for (; w.length < 6; ) w = "0" + w;
    l = "" + w + l;
  }
};
Rt.getHighBits = function() {
  return this.high;
};
Rt.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
Rt.getLowBits = function() {
  return this.low;
};
Rt.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
Rt.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Vo) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && !(e & 1 << t); t--) ;
  return this.high != 0 ? t + 33 : t + 1;
};
Rt.isZero = function() {
  return this.high === 0 && this.low === 0;
};
Rt.eqz = Rt.isZero;
Rt.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
Rt.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
Rt.isOdd = function() {
  return (this.low & 1) === 1;
};
Rt.isEven = function() {
  return (this.low & 1) === 0;
};
Rt.equals = function(e) {
  return ro(e) || (e = Tl(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
Rt.eq = Rt.equals;
Rt.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
Rt.neq = Rt.notEquals;
Rt.ne = Rt.notEquals;
Rt.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
Rt.lt = Rt.lessThan;
Rt.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
Rt.lte = Rt.lessThanOrEqual;
Rt.le = Rt.lessThanOrEqual;
Rt.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
Rt.gt = Rt.greaterThan;
Rt.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
Rt.gte = Rt.greaterThanOrEqual;
Rt.ge = Rt.greaterThanOrEqual;
Rt.compare = function(e) {
  if (ro(e) || (e = Tl(e)), this.eq(e)) return 0;
  var t = this.isNegative(), r = e.isNegative();
  return t && !r ? -1 : !t && r ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
Rt.comp = Rt.compare;
Rt.negate = function() {
  return !this.unsigned && this.eq(Vo) ? Vo : this.not().add(Rd);
};
Rt.neg = Rt.negate;
Rt.add = function(e) {
  ro(e) || (e = Tl(e));
  var t = this.high >>> 16, r = this.high & 65535, i = this.low >>> 16, o = this.low & 65535, c = e.high >>> 16, l = e.high & 65535, _ = e.low >>> 16, b = e.low & 65535, w = 0, T = 0, I = 0, P = 0;
  return P += o + b, I += P >>> 16, P &= 65535, I += i + _, T += I >>> 16, I &= 65535, T += r + l, w += T >>> 16, T &= 65535, w += t + c, w &= 65535, mr(I << 16 | P, w << 16 | T, this.unsigned);
};
Rt.subtract = function(e) {
  return ro(e) || (e = Tl(e)), this.add(e.neg());
};
Rt.sub = Rt.subtract;
Rt.multiply = function(e) {
  if (this.isZero()) return this;
  if (ro(e) || (e = Tl(e)), $a) {
    var t = $a.mul(this.low, this.high, e.low, e.high);
    return mr(t, $a.get_high(), this.unsigned);
  }
  if (e.isZero()) return this.unsigned ? tu : wl;
  if (this.eq(Vo)) return e.isOdd() ? Vo : wl;
  if (e.eq(Vo)) return this.isOdd() ? Vo : wl;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(TA) && e.lt(TA)) return Za(this.toNumber() * e.toNumber(), this.unsigned);
  var r = this.high >>> 16, i = this.high & 65535, o = this.low >>> 16, c = this.low & 65535, l = e.high >>> 16, _ = e.high & 65535, b = e.low >>> 16, w = e.low & 65535, T = 0, I = 0, P = 0, k = 0;
  return k += c * w, P += k >>> 16, k &= 65535, P += o * w, I += P >>> 16, P &= 65535, P += c * b, I += P >>> 16, P &= 65535, I += i * w, T += I >>> 16, I &= 65535, I += o * b, T += I >>> 16, I &= 65535, I += c * _, T += I >>> 16, I &= 65535, T += r * w + i * b + o * _ + c * l, T &= 65535, mr(P << 16 | k, T << 16 | I, this.unsigned);
};
Rt.mul = Rt.multiply;
Rt.divide = function(e) {
  if (ro(e) || (e = Tl(e)), e.isZero()) throw Error("division by zero");
  if ($a) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var t = (this.unsigned ? $a.div_u : $a.div_s)(this.low, this.high, e.low, e.high);
    return mr(t, $a.get_high(), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? tu : wl;
  var r, i, o;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return tu;
    if (e.gt(this.shru(1)))
      return uT;
    o = tu;
  } else {
    if (this.eq(Vo)) {
      if (e.eq(Rd) || e.eq(Hy)) return Vo;
      if (e.eq(Vo)) return Rd;
      var c = this.shr(1);
      return r = c.div(e).shl(1), r.eq(wl) ? e.isNegative() ? Rd : Hy : (i = this.sub(e.mul(r)), o = r.add(i.div(e)), o);
    } else if (e.eq(Vo)) return this.unsigned ? tu : wl;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    o = wl;
  }
  for (i = this; i.gte(e); ) {
    r = Math.max(1, Math.floor(i.toNumber() / e.toNumber()));
    for (var l = Math.ceil(Math.log(r) / Math.LN2), _ = l <= 48 ? 1 : Pm(2, l - 48), b = Za(r), w = b.mul(e); w.isNegative() || w.gt(i); )
      r -= _, b = Za(r, this.unsigned), w = b.mul(e);
    b.isZero() && (b = Rd), o = o.add(b), i = i.sub(w);
  }
  return o;
};
Rt.div = Rt.divide;
Rt.modulo = function(e) {
  if (ro(e) || (e = Tl(e)), $a) {
    var t = (this.unsigned ? $a.rem_u : $a.rem_s)(this.low, this.high, e.low, e.high);
    return mr(t, $a.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
Rt.mod = Rt.modulo;
Rt.rem = Rt.modulo;
Rt.not = function() {
  return mr(~this.low, ~this.high, this.unsigned);
};
Rt.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
Rt.clz = Rt.countLeadingZeros;
Rt.countTrailingZeros = function() {
  return this.low ? xA(this.low) : xA(this.high) + 32;
};
Rt.ctz = Rt.countTrailingZeros;
Rt.and = function(e) {
  return ro(e) || (e = Tl(e)), mr(this.low & e.low, this.high & e.high, this.unsigned);
};
Rt.or = function(e) {
  return ro(e) || (e = Tl(e)), mr(this.low | e.low, this.high | e.high, this.unsigned);
};
Rt.xor = function(e) {
  return ro(e) || (e = Tl(e)), mr(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
Rt.shiftLeft = function(e) {
  return ro(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? mr(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : mr(0, this.low << e - 32, this.unsigned);
};
Rt.shl = Rt.shiftLeft;
Rt.shiftRight = function(e) {
  return ro(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? mr(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : mr(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
Rt.shr = Rt.shiftRight;
Rt.shiftRightUnsigned = function(e) {
  return ro(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? mr(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? mr(this.high, 0, this.unsigned) : mr(this.high >>> e - 32, 0, this.unsigned);
};
Rt.shru = Rt.shiftRightUnsigned;
Rt.shr_u = Rt.shiftRightUnsigned;
Rt.rotateLeft = function(e) {
  var t;
  return ro(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? mr(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, mr(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)) : (e -= 32, t = 32 - e, mr(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned));
};
Rt.rotl = Rt.rotateLeft;
Rt.rotateRight = function(e) {
  var t;
  return ro(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? mr(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, mr(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)) : (e -= 32, t = 32 - e, mr(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned));
};
Rt.rotr = Rt.rotateRight;
Rt.toSigned = function() {
  return this.unsigned ? mr(this.low, this.high, !1) : this;
};
Rt.toUnsigned = function() {
  return this.unsigned ? this : mr(this.low, this.high, !0);
};
Rt.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
Rt.toBytesLE = function() {
  var e = this.high, t = this.low;
  return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
};
Rt.toBytesBE = function() {
  var e = this.high, t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
};
Ur.fromBytes = function(e, t, r) {
  return r ? Ur.fromBytesLE(e, t) : Ur.fromBytesBE(e, t);
};
Ur.fromBytesLE = function(e, t) {
  return new Ur(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
};
Ur.fromBytesBE = function(e, t) {
  return new Ur(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
const Jj = 16;
function fT(n) {
  n === "X" && (n = "");
  const e = n.padEnd(Jj, "0");
  return Ur.fromString(e, !0, 16);
}
function Yj(n) {
  if (n.isZero())
    return "X";
  let e = n.countTrailingZeros();
  const t = e % 4;
  e = (e - t) / 4;
  const r = e;
  e *= 4;
  const o = n.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - r - o.length).join("0") + o;
}
function Kj(n, e) {
  const t = Qj(n).shiftRightUnsigned(2);
  return n.add(Ur.fromNumber(2 * e + 1 - 4).multiply(t));
}
function Qj(n) {
  return n.and(n.not().add(1));
}
const eG = 3, tG = 30, nG = 2 * tG + 1, CA = 180 / Math.PI;
function rG(n) {
  if (n.length === 0)
    throw new Error("Invalid Hilbert quad key ".concat(n));
  const e = n.split("/"), t = parseInt(e[0], 10), r = e[1], i = r.length;
  let o = 0;
  const c = [0, 0];
  for (let l = i - 1; l >= 0; l--) {
    o = i - l;
    const _ = r[l];
    let b = 0, w = 0;
    _ === "1" ? w = 1 : _ === "2" ? (b = 1, w = 1) : _ === "3" && (b = 1);
    const T = Math.pow(2, o - 1);
    sG(T, c, b, w), c[0] += T * b, c[1] += T * w;
  }
  if (t % 2 === 1) {
    const l = c[0];
    c[0] = c[1], c[1] = l;
  }
  return {
    face: t,
    ij: c,
    level: o
  };
}
function iG(n) {
  if (n.isZero())
    return "";
  let e = n.toString(2);
  for (; e.length < eG + nG; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), r = e.substring(0, 3), i = e.substring(3, t), o = i.length / 2, c = Ur.fromString(r, !0, 2).toString(10);
  let l = "";
  if (o !== 0)
    for (l = Ur.fromString(i, !0, 2).toString(4); l.length < o; )
      l = "0" + l;
  return "".concat(c, "/").concat(l);
}
function pT(n, e, t) {
  const r = 1 << e;
  return [(n[0] + t[0]) / r, (n[1] + t[1]) / r];
}
function IA(n) {
  return n >= 0.5 ? 1 / 3 * (4 * n * n - 1) : 1 / 3 * (1 - 4 * (1 - n) * (1 - n));
}
function gT(n) {
  return [IA(n[0]), IA(n[1])];
}
function mT(n, e) {
  let [t, r] = e;
  switch (n) {
    case 0:
      return [1, t, r];
    case 1:
      return [-t, 1, r];
    case 2:
      return [-t, -r, 1];
    case 3:
      return [-1, -r, -t];
    case 4:
      return [r, -1, -t];
    case 5:
      return [r, t, -1];
    default:
      throw new Error("Invalid face");
  }
}
function _T(n) {
  let [e, t, r] = n;
  const i = Math.atan2(r, Math.sqrt(e * e + t * t));
  return [Math.atan2(t, e) * CA, i * CA];
}
function sG(n, e, t, r) {
  if (r === 0) {
    t === 1 && (e[0] = n - 1 - e[0], e[1] = n - 1 - e[1]);
    const i = e[0];
    e[0] = e[1], e[1] = i;
  }
}
function oG(n) {
  const e = pT(n.ij, n.level, [0.5, 0.5]), t = gT(e), r = mT(n.face, t);
  return _T(r);
}
const aG = 100;
function PA(n) {
  const {
    face: e,
    ij: t,
    level: r
  } = n, i = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], o = Math.max(1, Math.ceil(aG * Math.pow(2, -r))), c = new Float64Array(4 * o * 2 + 2);
  let l = 0, _ = 0;
  for (let b = 0; b < 4; b++) {
    const w = i[b].slice(0), T = i[b + 1], I = (T[0] - w[0]) / o, P = (T[1] - w[1]) / o;
    for (let k = 0; k < o; k++) {
      w[0] += I, w[1] += P;
      const U = pT(t, r, w), G = gT(U), H = mT(e, G), $ = _T(H);
      Math.abs($[1]) > 89.999 && ($[0] = _);
      const ie = $[0] - _;
      $[0] += ie > 180 ? -360 : ie < -180 ? 360 : 0, c[l++] = $[0], c[l++] = $[1], _ = $[0];
    }
  }
  return c[l++] = c[0], c[l++] = c[1], c;
}
function Cb(n) {
  const e = lG(n);
  return rG(e);
}
function lG(n) {
  if (n.indexOf("/") > 0)
    return n;
  const e = fT(n);
  return iG(e);
}
function cG(n) {
  const e = Cb(n);
  return oG(e);
}
function uG(n) {
  let e;
  if (n.face === 2 || n.face === 5) {
    let t = null, r = 0;
    for (let i = 0; i < 4; i++) {
      const o = "".concat(n.face, "/").concat(i), c = Cb(o), l = PA(c);
      (typeof t > "u" || t === null) && (t = new Float64Array(4 * l.length)), t.set(l, r), r += l.length;
    }
    e = LA(t);
  } else {
    const t = PA(n);
    e = LA(t);
  }
  return e;
}
function LA(n) {
  if (n.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], t = [];
  for (let r = 0; r < n.length; r += 2)
    e.push(n[r]), t.push(n[r + 1]);
  return e.sort((r, i) => r - i), t.sort((r, i) => r - i), {
    west: e[0],
    east: e[e.length - 1],
    north: t[t.length - 1],
    south: t[0]
  };
}
function hG(n, e) {
  const t = (e == null ? void 0 : e.minimumHeight) || 0, r = (e == null ? void 0 : e.maximumHeight) || 0, i = Cb(n), o = uG(i), c = o.west, l = o.south, _ = o.east, b = o.north, w = [];
  return w.push(new Ke(c, b, t)), w.push(new Ke(_, b, t)), w.push(new Ke(_, l, t)), w.push(new Ke(c, l, t)), w.push(new Ke(c, b, r)), w.push(new Ke(_, b, r)), w.push(new Ke(_, l, r)), w.push(new Ke(c, l, r)), w;
}
function yT(n) {
  const e = n.token, t = {
    minimumHeight: n.minimumHeight,
    maximumHeight: n.maximumHeight
  }, r = hG(e, t), i = cG(e), o = i[0], c = i[1], l = _i.WGS84.cartographicToCartesian([o, c, t.maximumHeight]), _ = new Ke(l[0], l[1], l[2]);
  r.push(_);
  const b = N8(r);
  return [...b.center, ...b.halfAxes];
}
const dG = 4, fG = 8, pG = {
  QUADTREE: dG,
  OCTREE: fG
};
function gG(n, e, t) {
  if (n != null && n.box) {
    const r = fT(n.s2VolumeInfo.token), i = Kj(r, e), o = Yj(i), c = {
      ...n.s2VolumeInfo
    };
    switch (c.token = o, t) {
      case "OCTREE":
        const b = n.s2VolumeInfo, w = b.maximumHeight - b.minimumHeight, T = w / 2, I = b.minimumHeight + w / 2;
        b.minimumHeight = I - T, b.maximumHeight = I + T;
        break;
    }
    return {
      box: yT(c),
      s2VolumeInfo: c
    };
  }
}
async function bT(n) {
  const {
    options: e,
    parentData: t = {
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    },
    childIndex: r = 0,
    globalData: i = {
      level: 0,
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    },
    s2VolumeBox: o
  } = n;
  let {
    subtree: c,
    level: l = 0
  } = n;
  const {
    subdivisionScheme: _,
    subtreeLevels: b,
    maximumLevel: w,
    contentUrlTemplate: T,
    subtreesUriTemplate: I,
    basePath: P
  } = e, k = {
    children: [],
    lodMetricValue: 0,
    contentUrl: ""
  }, U = pG[_], G = r & 1, H = r >> 1 & 1, $ = r >> 2 & 1, ie = (U ** l - 1) / (U - 1);
  let ge = vh(t.mortonIndex, r), Se = ie + ge, Re = vh(t.x, G), Le = vh(t.y, H), _e = vh(t.z, $), Ge = !1;
  l + 1 > b && (Ge = G_(c.childSubtreeAvailability, ge));
  const ke = vh(i.x, Re), oe = vh(i.y, Le), pe = vh(i.z, _e), Te = l + i.level;
  if (Ge) {
    const Je = "".concat(P, "/").concat(I), ct = Wy(Je, Te, ke, oe, pe);
    c = await Hu(ct, lT), i.mortonIndex = ge, i.x = Re, i.y = Le, i.z = _e, i.level = l, ge = 0, Se = 0, Re = 0, Le = 0, _e = 0, l = 0;
  }
  if (!G_(c.tileAvailability, Se) || l > w)
    return k;
  G_(c.contentAvailability, Se) && (k.contentUrl = Wy(T, Te, ke, oe, pe));
  const rt = l + 1, st = {
    mortonIndex: ge,
    x: Re,
    y: Le,
    z: _e
  };
  for (let Je = 0; Je < U; Je++) {
    const ct = gG(o, Je, _), ot = await bT({
      subtree: c,
      options: e,
      parentData: st,
      childIndex: Je,
      level: rt,
      globalData: i,
      s2VolumeBox: ct
    });
    if (ot.contentUrl || ot.children.length) {
      const Mt = Te + 1, Ae = mG(ot, Mt, {
        childTileX: Re,
        childTileY: Le,
        childTileZ: _e
      }, e, o);
      k.children.push(Ae);
    }
  }
  return k;
}
function G_(n, e) {
  return "constant" in n ? !!n.constant : n.explicitBitstream ? bG(e, n.explicitBitstream) : !1;
}
function mG(n, e, t, r, i) {
  const {
    basePath: o,
    refine: c,
    getRefine: l,
    lodMetricType: _,
    getTileType: b,
    rootLodMetricValue: w,
    rootBoundingVolume: T
  } = r, I = n.contentUrl && n.contentUrl.replace("".concat(o, "/"), ""), P = w / 2 ** e, k = i != null && i.box ? {
    box: i.box
  } : T, U = _G(e, k, t);
  return {
    children: n.children,
    contentUrl: n.contentUrl,
    content: {
      uri: I
    },
    id: n.contentUrl,
    refine: l(c),
    type: b(n),
    lodMetricType: _,
    lodMetricValue: P,
    geometricError: P,
    transform: n.transform,
    boundingVolume: U
  };
}
function _G(n, e, t) {
  if (e.region) {
    const {
      childTileX: r,
      childTileY: i,
      childTileZ: o
    } = t, [c, l, _, b, w, T] = e.region, I = 2 ** n, P = (_ - c) / I, k = (b - l) / I, U = (T - w) / I, [G, H] = [c + P * r, c + P * (r + 1)], [$, ie] = [l + k * i, l + k * (i + 1)], [ge, Se] = [w + U * o, w + U * (o + 1)];
    return {
      region: [G, $, H, ie, ge, Se]
    };
  }
  if (e.box)
    return e;
  throw new Error("Unsupported bounding volume type ".concat(e));
}
function vh(n, e) {
  return parseInt(n.toString(2) + e.toString(2), 2);
}
function Wy(n, e, t, r, i) {
  const o = yG({
    level: e,
    x: t,
    y: r,
    z: i
  });
  return n.replace(/{level}|{x}|{y}|{z}/gi, (c) => o[c]);
}
function yG(n) {
  const e = {};
  for (const t in n)
    e["{".concat(t, "}")] = n[t];
  return e;
}
function bG(n, e) {
  const t = Math.floor(n / 8), r = n % 8;
  return (e[t] >> r & 1) === 1;
}
function Ib(n) {
  if (!n.contentUrl)
    return zd.EMPTY;
  const t = n.contentUrl.split("?")[0].split(".").pop();
  switch (t) {
    case "pnts":
      return zd.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return zd.SCENEGRAPH;
    default:
      return t;
  }
}
function Pb(n) {
  switch (n) {
    case "REPLACE":
    case "replace":
      return ru.REPLACE;
    case "ADD":
    case "add":
      return ru.ADD;
    default:
      return n;
  }
}
function Xy(n, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const r = new URL(n, "".concat(e, "/"));
    return decodeURI(r.toString());
  } else if (n.startsWith("/"))
    return n;
  return "".concat(e, "/").concat(n);
}
function MA(n, e) {
  if (!n)
    return null;
  if (n.content) {
    const t = n.content.uri || n.content.url;
    n.contentUrl = Xy(t, e.basePath);
  }
  return n.id = n.contentUrl, n.lodMetricType = qm.GEOMETRIC_ERROR, n.lodMetricValue = n.geometricError, n.transformMatrix = n.transform, n.type = Ib(n), n.refine = Pb(n.refine), n;
}
async function vG(n, e) {
  const t = n.basePath;
  let r;
  const i = RA(n == null ? void 0 : n.root);
  i && n.root ? r = await BA(n.root, n, i, e) : r = MA(n.root, n);
  const o = [];
  for (o.push(r); o.length > 0; ) {
    const l = (o.pop() || {}).children || [];
    for (let _ of l) {
      const b = RA(_);
      b ? _ = await BA(_, n, b, e) : MA(_, {
        basePath: t
      }), o.push(_);
    }
  }
  return r;
}
async function BA(n, e, t, r) {
  var i, o;
  const c = e.basePath, {
    subdivisionScheme: l,
    maximumLevel: _,
    subtreeLevels: b,
    subtrees: {
      uri: w
    }
  } = t, T = Wy(w, 0, 0, 0, 0), I = Xy(T, c), P = await Hu(I, lT, r), k = Xy(n.content.uri, c), U = e == null || (i = e.root) === null || i === void 0 ? void 0 : i.refine, G = n.geometricError, H = (o = n.boundingVolume.extensions) === null || o === void 0 ? void 0 : o["3DTILES_bounding_volume_S2"];
  if (H) {
    const Se = {
      box: yT(H),
      s2VolumeInfo: H
    };
    n.boundingVolume = Se;
  }
  const $ = n.boundingVolume, ie = {
    contentUrlTemplate: k,
    subtreesUriTemplate: w,
    subdivisionScheme: l,
    subtreeLevels: b,
    maximumLevel: _,
    refine: U,
    basePath: c,
    lodMetricType: qm.GEOMETRIC_ERROR,
    rootLodMetricValue: G,
    rootBoundingVolume: $,
    getTileType: Ib,
    getRefine: Pb
  };
  return await xG(n, P, ie);
}
async function xG(n, e, t) {
  if (!n)
    return null;
  n.lodMetricType = qm.GEOMETRIC_ERROR, n.lodMetricValue = n.geometricError, n.transformMatrix = n.transform;
  const {
    children: r,
    contentUrl: i
  } = await bT({
    subtree: e,
    options: t,
    s2VolumeBox: n
  });
  return i && (n.contentUrl = i, n.content = {
    uri: i.replace("".concat(t.basePath, "/"), "")
  }), n.refine = Pb(n.refine), n.type = Ib(n), n.children = r, n.id = n.contentUrl, n;
}
function RA(n) {
  var e;
  return (n == null || (e = n.extensions) === null || e === void 0 ? void 0 : e["3DTILES_implicit_tiling"]) || (n == null ? void 0 : n.implicitTiling);
}
const Lb = {
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: eT,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: EG,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
function wG(n) {
  return A1(n.url);
}
async function AG(n, e, t) {
  const r = {
    content: {
      featureIds: null
    }
  };
  return await aT(n, 0, e, t, r.content), r.content;
}
async function SG(n, e, t) {
  var r;
  const i = JSON.parse(new TextDecoder().decode(n));
  return i.loader = e.loader || Lb, i.url = t.url, i.queryString = t.queryString, i.basePath = wG(i), i.root = await vG(i, e), i.type = qa.TILES3D, i.lodMetricType = qm.GEOMETRIC_ERROR, i.lodMetricValue = ((r = i.root) === null || r === void 0 ? void 0 : r.lodMetricValue) || 0, i;
}
async function EG(n, e, t) {
  const r = e["3d-tiles"] || {};
  let i;
  return r.isTileset === "auto" ? i = t.url && t.url.indexOf(".json") !== -1 : i = r.isTileset, i ? n = await SG(n, e, t) : n = await AG(n, e, t), n;
}
const OA = [0], TG = {
  getPointColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  pointSize: 1,
  data: "",
  loader: Lb,
  onTilesetLoad: {
    type: "function",
    value: (n) => {
    }
  },
  onTileLoad: {
    type: "function",
    value: (n) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (n) => {
    }
  },
  onTileError: {
    type: "function",
    value: (n, e, t) => {
    }
  },
  _getMeshColor: {
    type: "function",
    value: (n) => [255, 255, 255]
  }
};
class Mb extends xE {
  constructor() {
    super(...arguments), V(this, "state", void 0);
  }
  initializeState() {
    "onTileLoadFail" in this.props && ur.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var e, t;
    return !!(!((e = this.state) === null || e === void 0 || (t = e.tileset3d) === null || t === void 0) && t.isLoaded() && super.isLoaded);
  }
  shouldUpdateState(e) {
    let {
      changeFlags: t
    } = e;
    return t.somethingChanged;
  }
  updateState(e) {
    let {
      props: t,
      oldProps: r,
      changeFlags: i
    } = e;
    if (t.data && t.data !== r.data && this._loadTileset(t.data), i.viewportChanged) {
      const {
        activeViewports: o
      } = this.state;
      Object.keys(o).length && (this._updateTileset(o), this.state.lastUpdatedViewports = o, this.state.activeViewports = {});
    }
    if (i.propsChanged) {
      const {
        layerMap: o
      } = this.state;
      for (const c in o)
        o[c].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const {
      activeViewports: t,
      lastUpdatedViewports: r
    } = this.state;
    this.internalState.viewport = e, t[e.id] = e;
    const i = r == null ? void 0 : r[e.id];
    (!i || !e.equals(i)) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.setNeedsUpdate());
  }
  getPickingInfo(e) {
    let {
      info: t,
      sourceLayer: r
    } = e;
    const i = r && r.props.tile;
    return t.picked && (t.object = i), t.sourceTile = i, t;
  }
  filterSubLayer(e) {
    let {
      layer: t,
      viewport: r
    } = e;
    const {
      tile: i
    } = t.props, {
      id: o
    } = r;
    return i.selected && i.viewportIds.includes(o);
  }
  _updateAutoHighlight(e) {
    const t = e.sourceTile, r = this.state.layerMap[t == null ? void 0 : t.id];
    r && r.layer && r.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const {
      loadOptions: t = {}
    } = this.props;
    let r = this.props.loader || this.props.loaders;
    Array.isArray(r) && (r = r[0]);
    const i = {
      loadOptions: {
        ...t
      }
    };
    let o = e;
    if (r.preload) {
      const _ = await r.preload(e, t);
      _.url && (o = _.url), _.headers && (i.loadOptions.fetch = {
        ...i.loadOptions.fetch,
        headers: _.headers
      }), Object.assign(i, _);
    }
    const c = await Hu(o, r, i.loadOptions), l = new sj(c, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...i
    });
    this.setState({
      tileset3d: l,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(l);
  }
  _onTileLoad(e) {
    const {
      lastUpdatedViewports: t
    } = this.state;
    this.props.onTileLoad(e), this._updateTileset(t), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const {
      tileset3d: t
    } = this.state, {
      timeline: r
    } = this.context, i = Object.keys(e).length;
    !r || !i || !t || t.selectTiles(Object.values(e)).then((o) => {
      this.state.frameNumber !== o && this.setState({
        frameNumber: o
      });
    });
  }
  _getSubLayer(e, t) {
    if (!e.content)
      return null;
    switch (e.type) {
      case zd.POINTCLOUD:
        return this._makePointCloudLayer(e, t);
      case zd.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case zd.MESH:
        return this._makeSimpleMeshLayer(e, t);
      default:
        throw new Error("Tile3DLayer: Failed to render layer of type ".concat(e.content.type));
    }
  }
  _makePointCloudLayer(e, t) {
    const {
      attributes: r,
      pointCount: i,
      constantRGBA: o,
      cartographicOrigin: c,
      modelMatrix: l
    } = e.content, {
      positions: _,
      normals: b,
      colors: w
    } = r;
    if (!_)
      return null;
    const T = t && t.props.data || {
      header: {
        vertexCount: i
      },
      attributes: {
        POSITION: _,
        NORMAL: b,
        COLOR_0: w
      }
    }, {
      pointSize: I,
      getPointColor: P
    } = this.props, k = this.getSubLayerClass("pointcloud", fb);
    return new k({
      pointSize: I
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: "".concat(this.id, "-pointcloud-").concat(e.id),
      tile: e,
      data: T,
      coordinateSystem: cr.METER_OFFSETS,
      coordinateOrigin: c,
      modelMatrix: l,
      getColor: o || P,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const {
      gltf: t,
      instances: r,
      cartographicOrigin: i,
      modelMatrix: o
    } = e.content, c = this.getSubLayerClass("scenegraph", xb);
    return new c({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: "".concat(this.id, "-scenegraph-").concat(e.id),
      tile: e,
      data: r || OA,
      scenegraph: t,
      coordinateSystem: cr.METER_OFFSETS,
      coordinateOrigin: i,
      modelMatrix: o,
      getTransformMatrix: (l) => l.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, t) {
    const r = e.content, {
      attributes: i,
      indices: o,
      modelMatrix: c,
      cartographicOrigin: l,
      coordinateSystem: _ = cr.METER_OFFSETS,
      material: b,
      featureIds: w
    } = r, {
      _getMeshColor: T
    } = this.props, I = t && t.props.mesh || new hp({
      drawMode: 4,
      attributes: CG(i),
      indices: o
    }), P = this.getSubLayerClass("mesh", wb);
    return new P(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: "".concat(this.id, "-mesh-").concat(e.id),
      tile: e,
      mesh: I,
      data: OA,
      getColor: T(e),
      pbrMaterial: b,
      modelMatrix: c,
      coordinateOrigin: l,
      coordinateSystem: _,
      featureIds: w,
      _offset: 0
    });
  }
  renderLayers() {
    const {
      tileset3d: e,
      layerMap: t
    } = this.state;
    return e ? e.tiles.map((r) => {
      const i = t[r.id] = t[r.id] || {
        tile: r
      };
      let {
        layer: o
      } = i;
      return r.selected && (o ? i.needsUpdate && (o = this._getSubLayer(r, o), i.needsUpdate = !1) : o = this._getSubLayer(r)), i.layer = o, o;
    }).filter(Boolean) : null;
  }
}
V(Mb, "defaultProps", TG);
V(Mb, "layerName", "Tile3DLayer");
function CG(n) {
  const e = {};
  return e.positions = {
    ...n.positions,
    value: new Float32Array(n.positions.value)
  }, n.normals && (e.normals = n.normals), n.texCoords && (e.texCoords = n.texCoords), n.colors && (e.colors = n.colors), n.uvRegions && (e.uvRegions = n.uvRegions), e;
}
var IG = Object.defineProperty, PG = (n, e, t) => e in n ? IG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, gr = (n, e, t) => (PG(n, typeof e != "symbol" ? e + "" : e, t), t);
class LG {
  constructor(e) {
    gr(this, "map"), gr(this, "width"), gr(this, "height"), gr(this, "svgCanvas"), gr(this, "xLine"), gr(this, "yLine"), gr(this, "color", "#535353"), this.map = e, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var e, t;
    this.width = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, this.height = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const e = this.width / 2, t = this.height / 2;
      this.yLine.setAttribute("x1", `${e}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${e}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${t}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${t}px`);
    } else console.error("element value is null");
  }
  createCanvas(e) {
    if (this.width !== void 0 && this.height !== void 0) {
      const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t.style.position = "relative", t.setAttribute("width", `${this.width}px`), t.setAttribute("height", `${this.height}px`);
      const r = this.width / 2, i = this.height / 2;
      this.yLine = t.appendChild(this.createLine(r, 0, r, this.height, this.color, "2px")), this.xLine = t.appendChild(this.createLine(0, i, this.width, i, this.color, "2px")), e == null || e.appendChild(t), this.svgCanvas = t;
    }
  }
  createLine(e, t, r, i, o, c) {
    const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return l.setAttribute("x1", e), l.setAttribute("y1", t), l.setAttribute("x2", r), l.setAttribute("y2", i), l.setAttribute("stroke-dasharray", "5,5"), l.setAttribute("stroke", o), l.setAttribute("stroke-width", c), l;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const $y = { 72: 72, 96: 96, 200: 200, 300: 300, 400: 400 }, Yc = { JPEG: "jpg", PNG: "png", PDF: "pdf", SVG: "svg" }, ip = { Landscape: "landscape", Portrait: "portrait" }, Ph = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, tf = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class MG {
  constructor(e) {
    gr(this, "map"), gr(this, "width"), gr(this, "height"), gr(this, "unit"), gr(this, "svgCanvas"), gr(this, "svgPath");
    var t, r, i;
    if (this.map = e, this.map === void 0) return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const o = (t = this.map) == null ? void 0 : t.getCanvas().clientWidth, c = (r = this.map) == null ? void 0 : r.getCanvas().clientHeight, l = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    l.style.position = "absolute", l.style.top = "0px", l.style.left = "0px", l.setAttribute("width", `${o}px`), l.setAttribute("height", `${c}px`);
    const _ = document.createElementNS("http://www.w3.org/2000/svg", "path");
    _.setAttribute("style", "fill:#888888;stroke-width:0"), _.setAttribute("fill-opacity", "0.5"), l.append(_), (i = this.map) == null || i.getCanvasContainer().appendChild(l), this.svgCanvas = l, this.svgPath = _;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(e, t) {
    this.width = e, this.height = t, this.unit = tf.mm, this.generateCutOut();
  }
  generateCutOut() {
    var e, t;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0) return;
    const r = this.toPixels(this.width), i = this.toPixels(this.height), o = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, c = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight, l = o / 2 - r / 2, _ = l + r, b = c / 2 - i / 2, w = b + i;
    this.svgCanvas.setAttribute("width", `${o}px`), this.svgCanvas.setAttribute("height", `${c}px`), this.svgPath.setAttribute("d", `M 0 0 L ${o} 0 L ${o} ${c} L 0 ${c} M ${l} ${b} L ${l} ${w} L ${_} ${w} L ${_} ${b}`);
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === tf.mm && (t /= 25.4), t * e;
  }
}
const vT = { PageSize: "Page Size", PageOrientation: "Page Orientation", Format: "Format", DPI: "DPI", Generate: "Generate", LanguageName: "English", LanguageCode: "en" }, BG = { PageSize: "Taille de page", PageOrientation: "Orientation de la page", Format: "Format", DPI: "DPI", Generate: "Générer", LanguageName: "Français", LanguageCode: "fr" }, RG = { PageSize: "Sivukoko", PageOrientation: "Sivun suunta", Format: "Muoto", DPI: "DPI", Generate: "Generoi", LanguageName: "Suomalainen", LanguageCode: "fi" }, OG = { PageSize: "Papierformat", PageOrientation: "Papierausrichtung", Format: "Dateiformat", DPI: "Druckauflösung", Generate: "Erstellen", LanguageName: "Deutsch", LanguageCode: "de" }, DG = { PageSize: "Sidstorlek", PageOrientation: "Sidorientering", Format: "Format", DPI: "DPI", Generate: "Generera", LanguageName: "Svenska", LanguageCode: "sv" }, FG = { PageSize: "Tamaño de página", PageOrientation: "Orientación de página", Format: "Formato", DPI: "DPI", Generate: "Generar", LanguageName: "Española", LanguageCode: "es" }, kG = { PageSize: "Mida", PageOrientation: "Orientació", Format: "Format", DPI: "DPI", Generate: "Genera", LanguageName: "Catalan", LanguageCode: "ca" }, NG = { PageSize: "Kích thước trang", PageOrientation: "Loại trang", Format: "Định dạng", DPI: "Mật độ điểm ảnh (DPI)", Generate: "Tạo", LanguageName: "Tiếng Việt", LanguageCode: "vi" }, zG = { PageSize: "Розмір сторінки", PageOrientation: "Орієнтація сторінки", Format: "Формат", DPI: "DPI", Generate: "Згенерувати", LanguageName: "українська", LanguageCode: "uk" }, UG = { PageSize: "页面大小", PageOrientation: "页面方向", Format: "格式", DPI: "像素", Generate: "导出", LanguageName: "简体字", LanguageCode: "zhHans" }, jG = { PageSize: "頁面大小", PageOrientation: "頁面方向", Format: "格式", DPI: "像素", Generate: "導出", LanguageName: "繁体字", LanguageCode: "zhHant" }, GG = { PageSize: "ページサイズ", PageOrientation: "ページ方向", Format: "フォーマット", DPI: "DPI（解像度）", Generate: "出力", LanguageName: "日本語", LanguageCode: "ja" }, VG = { PageSize: "Tamanho da página", PageOrientation: "Orientação da página", Format: "Formato", DPI: "DPI", Generate: "Gerar", LanguageName: "Português", LanguageCode: "pt" }, qG = [vT, BG, RG, OG, DG, FG, kG, NG, zG, UG, jG, GG, VG], HG = (n) => qG.find((e) => e.LanguageCode === n) ?? vT;
(function(n) {
  var e = {};
  function t(r) {
    if (e[r]) return e[r].exports;
    var i = e[r] = { i: r, l: !1, exports: {} };
    return n[r].call(i.exports, i, i.exports, t), i.l = !0, i.exports;
  }
  t.m = n, t.c = e, t.d = function(r, i, o) {
    t.o(r, i) || Object.defineProperty(r, i, { enumerable: !0, get: o });
  }, t.r = function(r) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(r, "__esModule", { value: !0 });
  }, t.t = function(r, i) {
    if (1 & i && (r = t(r)), 8 & i || 4 & i && typeof r == "object" && r && r.__esModule) return r;
    var o = /* @__PURE__ */ Object.create(null);
    if (t.r(o), Object.defineProperty(o, "default", { enumerable: !0, value: r }), 2 & i && typeof r != "string") for (var c in r) t.d(o, c, (function(l) {
      return r[l];
    }).bind(null, c));
    return o;
  }, t.n = function(r) {
    var i = r && r.__esModule ? function() {
      return r.default;
    } : function() {
      return r;
    };
    return t.d(i, "a", i), i;
  }, t.o = function(r, i) {
    return Object.prototype.hasOwnProperty.call(r, i);
  }, t.p = "", t(t.s = 0);
})([function(n, e, t) {
  n.exports = t(1);
}, function(n, e) {
  function t(i, o) {
    for (var c = 0; c < o.length; c++) {
      var l = o[c];
      l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(i, l.key, l);
    }
  }
  var r = function() {
    function i() {
      (function(l, _) {
        if (!(l instanceof _)) throw new TypeError("Cannot call a class as a function");
      })(this, i), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var o, c;
    return o = i, (c = [{ key: "show", value: function(l) {
      this.setOptions(l), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var l = document.getElementById("loading-overlay-stylesheet");
      l && (l.disabled = !0, l.parentNode.removeChild(l), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(l) {
      if (l !== void 0) for (var _ in l) this.options[_] = l[_];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var l = "50%";
      this.options.offsetX !== 0 && (l = "calc(50% + " + this.options.offsetX + ")");
      var _ = "50%";
      if (this.options.offsetY !== 0 && (_ = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var b = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(_, "; left: ").concat(l, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), w = document.getElementById(this.options.containerID);
        return w.style.position = "relative", void w.insertAdjacentHTML("beforeend", b);
      }
      var T = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(_, "; left: ").concat(l, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", T);
    } }, { key: "generateSpinnerElement", value: function() {
      var l = this, _ = Object.keys(this.numberOfEmptyDivForSpinner).find(function(w) {
        return w === l.options.spinnerIcon;
      }), b = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[_]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(b, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var l = document.createElement("link");
      l.setAttribute("id", "loading-overlay-stylesheet"), l.setAttribute("rel", "stylesheet"), l.setAttribute("type", "text/css"), l.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(l);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(l) {
      for (var _ = "", b = 1; b <= l; b++) _ += "<div></div>";
      return _;
    } }]) && t(o.prototype, c), i;
  }();
  window.JsLoadingOverlay = new r(), n.exports = JsLoadingOverlay;
}]);
function zr(n) {
  "@babel/helpers - typeof";
  return zr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, zr(n);
}
var qo = Uint8Array, Eo = Uint16Array, Ep = Uint32Array, Xm = new qo([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), $m = new qo([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Zy = new qo([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), xT = function(n, e) {
  for (var t = new Eo(31), r = 0; r < 31; ++r) t[r] = e += 1 << n[r - 1];
  for (var i = new Ep(t[30]), r = 1; r < 30; ++r) for (var o = t[r]; o < t[r + 1]; ++o) i[o] = o - t[r] << 5 | r;
  return [t, i];
}, wT = xT(Xm, 2), AT = wT[0], Jy = wT[1];
AT[28] = 258, Jy[258] = 28;
var ST = xT($m, 0), WG = ST[0], DA = ST[1], Yy = new Eo(32768);
for (var ci = 0; ci < 32768; ++ci) {
  var Fu = (ci & 43690) >>> 1 | (ci & 21845) << 1;
  Fu = (Fu & 52428) >>> 2 | (Fu & 13107) << 2, Fu = (Fu & 61680) >>> 4 | (Fu & 3855) << 4, Yy[ci] = ((Fu & 65280) >>> 8 | (Fu & 255) << 8) >>> 1;
}
var xc = function(n, e, t) {
  for (var r = n.length, i = 0, o = new Eo(e); i < r; ++i) ++o[n[i] - 1];
  var c = new Eo(e);
  for (i = 0; i < e; ++i) c[i] = c[i - 1] + o[i - 1] << 1;
  var l;
  if (t) {
    l = new Eo(1 << e);
    var _ = 15 - e;
    for (i = 0; i < r; ++i) if (n[i]) for (var b = i << 4 | n[i], w = e - n[i], T = c[n[i] - 1]++ << w, I = T | (1 << w) - 1; T <= I; ++T) l[Yy[T] >>> _] = b;
  } else for (l = new Eo(r), i = 0; i < r; ++i) l[i] = Yy[c[n[i] - 1]++] >>> 15 - n[i];
  return l;
}, Xu = new qo(288);
for (var ci = 0; ci < 144; ++ci) Xu[ci] = 8;
for (var ci = 144; ci < 256; ++ci) Xu[ci] = 9;
for (var ci = 256; ci < 280; ++ci) Xu[ci] = 7;
for (var ci = 280; ci < 288; ++ci) Xu[ci] = 8;
var Tp = new qo(32);
for (var ci = 0; ci < 32; ++ci) Tp[ci] = 5;
var XG = /* @__PURE__ */ xc(Xu, 9, 0), $G = /* @__PURE__ */ xc(Xu, 9, 1), ZG = /* @__PURE__ */ xc(Tp, 5, 0), JG = /* @__PURE__ */ xc(Tp, 5, 1), V_ = function(n) {
  for (var e = n[0], t = 1; t < n.length; ++t) n[t] > e && (e = n[t]);
  return e;
}, gl = function(n, e, t) {
  var r = e / 8 >> 0;
  return (n[r] | n[r + 1] << 8) >>> (e & 7) & t;
}, q_ = function(n, e) {
  var t = e / 8 >> 0;
  return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >>> (e & 7);
}, Bb = function(n) {
  return (n / 8 >> 0) + (n & 7 && 1);
}, ET = function(n, e, t) {
  (t == null || t > n.length) && (t = n.length);
  var r = new (n instanceof Eo ? Eo : n instanceof Ep ? Ep : qo)(t - e);
  return r.set(n.subarray(e, t)), r;
}, YG = function(n, e, t) {
  var r = n.length, i = !e || t, o = !t || t.i;
  t || (t = {}), e || (e = new qo(r * 3));
  var c = function(qe) {
    var He = e.length;
    if (qe > He) {
      var Ye = new qo(Math.max(He * 2, qe));
      Ye.set(e), e = Ye;
    }
  }, l = t.f || 0, _ = t.p || 0, b = t.b || 0, w = t.l, T = t.d, I = t.m, P = t.n, k = r * 8;
  do {
    if (!w) {
      t.f = l = gl(n, _, 1);
      var U = gl(n, _ + 1, 3);
      if (_ += 3, U)
        if (U == 1) w = $G, T = JG, I = 9, P = 5;
        else if (U == 2) {
          var G = gl(n, _, 31) + 257, H = gl(n, _ + 10, 15) + 4, $ = G + gl(n, _ + 5, 31) + 1;
          _ += 14;
          for (var ie = new qo($), ge = new qo(19), Se = 0; Se < H; ++Se) ge[Zy[Se]] = gl(n, _ + Se * 3, 7);
          _ += H * 3;
          var Re = V_(ge), Le = (1 << Re) - 1;
          if (!o && _ + $ * (Re + 7) > k) break;
          for (var _e = xc(ge, Re, 1), Se = 0; Se < $; ) {
            var Ge = _e[gl(n, _, Le)];
            _ += Ge & 15;
            var ke = Ge >>> 4;
            if (ke < 16) ie[Se++] = ke;
            else {
              var oe = 0, pe = 0;
              for (ke == 16 ? (pe = 3 + gl(n, _, 3), _ += 2, oe = ie[Se - 1]) : ke == 17 ? (pe = 3 + gl(n, _, 7), _ += 3) : ke == 18 && (pe = 11 + gl(n, _, 127), _ += 7); pe--; ) ie[Se++] = oe;
            }
          }
          var Te = ie.subarray(0, G), xe = ie.subarray(G);
          I = V_(Te), P = V_(xe), w = xc(Te, I, 1), T = xc(xe, P, 1);
        } else throw "invalid block type";
      else {
        var ke = Bb(_) + 4, et = n[ke - 4] | n[ke - 3] << 8, rt = ke + et;
        if (rt > r) {
          if (o) throw "unexpected EOF";
          break;
        }
        i && c(b + et), e.set(n.subarray(ke, rt), b), t.b = b += et, t.p = _ = rt * 8;
        continue;
      }
      if (_ > k) throw "unexpected EOF";
    }
    i && c(b + 131072);
    for (var st = (1 << I) - 1, Je = (1 << P) - 1, ct = I + P + 18; o || _ + ct < k; ) {
      var oe = w[q_(n, _) & st], ot = oe >>> 4;
      if (_ += oe & 15, _ > k) throw "unexpected EOF";
      if (!oe) throw "invalid length/literal";
      if (ot < 256) e[b++] = ot;
      else if (ot == 256) {
        w = null;
        break;
      } else {
        var Mt = ot - 254;
        if (ot > 264) {
          var Se = ot - 257, re = Xm[Se];
          Mt = gl(n, _, (1 << re) - 1) + AT[Se], _ += re;
        }
        var Ae = T[q_(n, _) & Je], Ce = Ae >>> 4;
        if (!Ae) throw "invalid distance";
        _ += Ae & 15;
        var xe = WG[Ce];
        if (Ce > 3) {
          var re = $m[Ce];
          xe += q_(n, _) & (1 << re) - 1, _ += re;
        }
        if (_ > k) throw "unexpected EOF";
        i && c(b + 131072);
        for (var Ue = b + Mt; b < Ue; b += 4) e[b] = e[b - xe], e[b + 1] = e[b + 1 - xe], e[b + 2] = e[b + 2 - xe], e[b + 3] = e[b + 3 - xe];
        b = Ue;
      }
    }
    t.l = w, t.p = _, t.b = b, w && (l = 1, t.m = I, t.d = T, t.n = P);
  } while (!l);
  return b == e.length ? e : ET(e, 0, b);
}, Zc = function(n, e, t) {
  t <<= e & 7;
  var r = e / 8 >> 0;
  n[r] |= t, n[r + 1] |= t >>> 8;
}, Yf = function(n, e, t) {
  t <<= e & 7;
  var r = e / 8 >> 0;
  n[r] |= t, n[r + 1] |= t >>> 8, n[r + 2] |= t >>> 16;
}, H_ = function(n, e) {
  for (var t = [], r = 0; r < n.length; ++r) n[r] && t.push({ s: r, f: n[r] });
  var i = t.length, o = t.slice();
  if (!i) return [new qo(0), 0];
  if (i == 1) {
    var c = new qo(t[0].s + 1);
    return c[t[0].s] = 1, [c, 1];
  }
  t.sort(function(Se, Re) {
    return Se.f - Re.f;
  }), t.push({ s: -1, f: 25001 });
  var l = t[0], _ = t[1], b = 0, w = 1, T = 2;
  for (t[0] = { s: -1, f: l.f + _.f, l, r: _ }; w != i - 1; ) l = t[t[b].f < t[T].f ? b++ : T++], _ = t[b != w && t[b].f < t[T].f ? b++ : T++], t[w++] = { s: -1, f: l.f + _.f, l, r: _ };
  for (var I = o[0].s, r = 1; r < i; ++r) o[r].s > I && (I = o[r].s);
  var P = new Eo(I + 1), k = Ky(t[w - 1], P, 0);
  if (k > e) {
    var r = 0, U = 0, G = k - e, H = 1 << G;
    for (o.sort(function(Re, Le) {
      return P[Le.s] - P[Re.s] || Re.f - Le.f;
    }); r < i; ++r) {
      var $ = o[r].s;
      if (P[$] > e) U += H - (1 << k - P[$]), P[$] = e;
      else break;
    }
    for (U >>>= G; U > 0; ) {
      var ie = o[r].s;
      P[ie] < e ? U -= 1 << e - P[ie]++ - 1 : ++r;
    }
    for (; r >= 0 && U; --r) {
      var ge = o[r].s;
      P[ge] == e && (--P[ge], ++U);
    }
    k = e;
  }
  return [new qo(P), k];
}, Ky = function(n, e, t) {
  return n.s == -1 ? Math.max(Ky(n.l, e, t + 1), Ky(n.r, e, t + 1)) : e[n.s] = t;
}, FA = function(n) {
  for (var e = n.length; e && !n[--e]; ) ;
  for (var t = new Eo(++e), r = 0, i = n[0], o = 1, c = function(_) {
    t[r++] = _;
  }, l = 1; l <= e; ++l) if (n[l] == i && l != e) ++o;
  else {
    if (!i && o > 2) {
      for (; o > 138; o -= 138) c(32754);
      o > 2 && (c(o > 10 ? o - 11 << 5 | 28690 : o - 3 << 5 | 12305), o = 0);
    } else if (o > 3) {
      for (c(i), --o; o > 6; o -= 6) c(8304);
      o > 2 && (c(o - 3 << 5 | 8208), o = 0);
    }
    for (; o--; ) c(i);
    o = 1, i = n[l];
  }
  return [t.subarray(0, r), e];
}, Kf = function(n, e) {
  for (var t = 0, r = 0; r < e.length; ++r) t += n[r] * e[r];
  return t;
}, Qy = function(n, e, t) {
  var r = t.length, i = Bb(e + 2);
  n[i] = r & 255, n[i + 1] = r >>> 8, n[i + 2] = n[i] ^ 255, n[i + 3] = n[i + 1] ^ 255;
  for (var o = 0; o < r; ++o) n[i + o + 4] = t[o];
  return (i + 4 + r) * 8;
}, kA = function(n, e, t, r, i, o, c, l, _, b, w) {
  Zc(e, w++, t), ++i[256];
  for (var T = H_(i, 15), I = T[0], P = T[1], k = H_(o, 15), U = k[0], G = k[1], H = FA(I), $ = H[0], ie = H[1], ge = FA(U), Se = ge[0], Re = ge[1], Le = new Eo(19), _e = 0; _e < $.length; ++_e) Le[$[_e] & 31]++;
  for (var _e = 0; _e < Se.length; ++_e) Le[Se[_e] & 31]++;
  for (var Ge = H_(Le, 7), ke = Ge[0], oe = Ge[1], pe = 19; pe > 4 && !ke[Zy[pe - 1]]; --pe) ;
  var Te = b + 5 << 3, xe = Kf(i, Xu) + Kf(o, Tp) + c, et = Kf(i, I) + Kf(o, U) + c + 14 + 3 * pe + Kf(Le, ke) + (2 * Le[16] + 3 * Le[17] + 7 * Le[18]);
  if (Te <= xe && Te <= et) return Qy(e, w, n.subarray(_, _ + b));
  var rt, st, Je, ct;
  if (Zc(e, w, 1 + (et < xe)), w += 2, et < xe) {
    rt = xc(I, P, 0), st = I, Je = xc(U, G, 0), ct = U;
    var ot = xc(ke, oe, 0);
    Zc(e, w, ie - 257), Zc(e, w + 5, Re - 1), Zc(e, w + 10, pe - 4), w += 14;
    for (var _e = 0; _e < pe; ++_e) Zc(e, w + 3 * _e, ke[Zy[_e]]);
    w += 3 * pe;
    for (var Mt = [$, Se], re = 0; re < 2; ++re) for (var Ae = Mt[re], _e = 0; _e < Ae.length; ++_e) {
      var Ce = Ae[_e] & 31;
      Zc(e, w, ot[Ce]), w += ke[Ce], Ce > 15 && (Zc(e, w, Ae[_e] >>> 5 & 127), w += Ae[_e] >>> 12);
    }
  } else rt = XG, st = Xu, Je = ZG, ct = Tp;
  for (var _e = 0; _e < l; ++_e) if (r[_e] > 255) {
    var Ce = r[_e] >>> 18 & 31;
    Yf(e, w, rt[Ce + 257]), w += st[Ce + 257], Ce > 7 && (Zc(e, w, r[_e] >>> 23 & 31), w += Xm[Ce]);
    var Ue = r[_e] & 31;
    Yf(e, w, Je[Ue]), w += ct[Ue], Ue > 3 && (Yf(e, w, r[_e] >>> 5 & 8191), w += $m[Ue]);
  } else Yf(e, w, rt[r[_e]]), w += st[r[_e]];
  return Yf(e, w, rt[256]), w + st[256];
}, KG = /* @__PURE__ */ new Ep([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), QG = function(n, e, t, r, i, o) {
  var c = n.length, l = new qo(r + c + 5 * (1 + Math.floor(c / 7e3)) + i), _ = l.subarray(r, l.length - i), b = 0;
  if (!e || c < 8) for (var w = 0; w <= c; w += 65535) {
    var T = w + 65535;
    T < c ? b = Qy(_, b, n.subarray(w, T)) : (_[w] = o, b = Qy(_, b, n.subarray(w, c)));
  }
  else {
    for (var I = KG[e - 1], P = I >>> 13, k = I & 8191, U = (1 << t) - 1, G = new Eo(32768), H = new Eo(U + 1), $ = Math.ceil(t / 3), ie = 2 * $, ge = function(an) {
      return (n[an] ^ n[an + 1] << $ ^ n[an + 2] << ie) & U;
    }, Se = new Ep(25e3), Re = new Eo(288), Le = new Eo(32), _e = 0, Ge = 0, w = 0, ke = 0, oe = 0, pe = 0; w < c; ++w) {
      var Te = ge(w), xe = w & 32767, et = H[Te];
      if (G[xe] = et, H[Te] = xe, oe <= w) {
        var rt = c - w;
        if ((_e > 7e3 || ke > 24576) && rt > 423) {
          b = kA(n, _, 0, Se, Re, Le, Ge, ke, pe, w - pe, b), ke = _e = Ge = 0, pe = w;
          for (var st = 0; st < 286; ++st) Re[st] = 0;
          for (var st = 0; st < 30; ++st) Le[st] = 0;
        }
        var Je = 2, ct = 0, ot = k, Mt = xe - et & 32767;
        if (rt > 2 && Te == ge(w - Mt)) for (var re = Math.min(P, rt) - 1, Ae = Math.min(32767, w), Ce = Math.min(258, rt); Mt <= Ae && --ot && xe != et; ) {
          if (n[w + Je] == n[w + Je - Mt]) {
            for (var Ue = 0; Ue < Ce && n[w + Ue] == n[w + Ue - Mt]; ++Ue) ;
            if (Ue > Je) {
              if (Je = Ue, ct = Mt, Ue > re) break;
              for (var qe = Math.min(Mt, Ue - 2), He = 0, st = 0; st < qe; ++st) {
                var Ye = w - Mt + st + 32768 & 32767, Ze = G[Ye], St = Ye - Ze + 32768 & 32767;
                St > He && (He = St, et = Ye);
              }
            }
          }
          xe = et, et = G[xe], Mt += xe - et + 32768 & 32767;
        }
        if (ct) {
          Se[ke++] = 268435456 | Jy[Je] << 18 | DA[ct];
          var Lt = Jy[Je] & 31, Dt = DA[ct] & 31;
          Ge += Xm[Lt] + $m[Dt], ++Re[257 + Lt], ++Le[Dt], oe = w + Je, ++_e;
        } else Se[ke++] = n[w], ++Re[n[w]];
      }
    }
    b = kA(n, _, o, Se, Re, Le, Ge, ke, pe, w - pe, b);
  }
  return ET(l, 0, r + Bb(b) + i);
}, eV = function() {
  var n = 1, e = 0;
  return { p: function(t) {
    for (var r = n, i = e, o = t.length, c = 0; c != o; ) {
      for (var l = Math.min(c + 5552, o); c < l; ++c) r += t[c], i += r;
      r %= 65521, i %= 65521;
    }
    n = r, e = i;
  }, d: function() {
    return (n >>> 8 << 16 | (e & 255) << 8 | e >>> 8) + ((n & 255) << 23) * 2;
  } };
}, tV = function(n, e, t, r, i) {
  return QG(n, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 12 + e.mem, t, r, !i);
}, nV = function(n, e, t) {
  for (; t; ++e) n[e] = t, t >>>= 8;
}, rV = function(n, e) {
  var t = e.level, r = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  n[0] = 120, n[1] = r << 6 | (r ? 32 - 2 * r : 1);
}, iV = function(n) {
  if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || (n[0] << 8 | n[1]) % 31) throw "invalid zlib data";
  if (n[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
};
function e1(n, e) {
  e === void 0 && (e = {});
  var t = eV();
  t.p(n);
  var r = tV(n, e, 2, 4);
  return rV(r, e), nV(r, r.length - 4, t.d()), r;
}
function sV(n, e) {
  return YG((iV(n), n.subarray(2, -4)), e);
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var Rn = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function W_() {
  Rn.console && typeof Rn.console.log == "function" && Rn.console.log.apply(Rn.console, arguments);
}
var $r = { log: W_, warn: function(n) {
  Rn.console && (typeof Rn.console.warn == "function" ? Rn.console.warn.apply(Rn.console, arguments) : W_.call(null, arguments));
}, error: function(n) {
  Rn.console && (typeof Rn.console.error == "function" ? Rn.console.error.apply(Rn.console, arguments) : W_(n));
} };
function X_(n, e, t) {
  var r = new XMLHttpRequest();
  r.open("GET", n), r.responseType = "blob", r.onload = function() {
    Ah(r.response, e, t);
  }, r.onerror = function() {
    $r.error("could not download file");
  }, r.send();
}
function NA(n) {
  var e = new XMLHttpRequest();
  e.open("HEAD", n, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function zg(n) {
  try {
    n.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), n.dispatchEvent(e);
  }
}
var fp, t1, Ah = Rn.saveAs || ((typeof window > "u" ? "undefined" : zr(window)) !== "object" || window !== Rn ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(n, e, t) {
  var r = Rn.URL || Rn.webkitURL, i = document.createElement("a");
  e = e || n.name || "download", i.download = e, i.rel = "noopener", typeof n == "string" ? (i.href = n, i.origin !== location.origin ? NA(i.href) ? X_(n, e, t) : zg(i, i.target = "_blank") : zg(i)) : (i.href = r.createObjectURL(n), setTimeout(function() {
    r.revokeObjectURL(i.href);
  }, 4e4), setTimeout(function() {
    zg(i);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(n, e, t) {
  if (e = e || n.name || "download", typeof n == "string")
    if (NA(n)) X_(n, e, t);
    else {
      var r = document.createElement("a");
      r.href = n, r.target = "_blank", setTimeout(function() {
        zg(r);
      });
    }
  else navigator.msSaveOrOpenBlob(function(i, o) {
    return o === void 0 ? o = { autoBom: !1 } : zr(o) !== "object" && ($r.warn("Deprecated: Expected third argument to be a object"), o = { autoBom: !o }), o.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(i.type) ? new Blob(["\uFEFF", i], { type: i.type }) : i;
  }(n, t), e);
} : function(n, e, t, r) {
  if ((r = r || open("", "_blank")) && (r.document.title = r.document.body.innerText = "downloading..."), typeof n == "string") return X_(n, e, t);
  var i = n.type === "application/octet-stream", o = /constructor/i.test(Rn.HTMLElement) || Rn.safari, c = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((c || i && o) && (typeof FileReader > "u" ? "undefined" : zr(FileReader)) === "object") {
    var l = new FileReader();
    l.onloadend = function() {
      var w = l.result;
      w = c ? w : w.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = w : location = w, r = null;
    }, l.readAsDataURL(n);
  } else {
    var _ = Rn.URL || Rn.webkitURL, b = _.createObjectURL(n);
    r ? r.location = b : location.href = b, r = null, setTimeout(function() {
      _.revokeObjectURL(b);
    }, 4e4);
  }
});
/**
* A class to parse color values
* @author Stoyan Stefanov <sstoo@gmail.com>
* {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
* @license Use it if you like it
*/
function TT(n) {
  var e;
  n = n || "", this.ok = !1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[n = (n = n.replace(/ /g, "")).toLowerCase()] || n;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(l) {
    return [parseInt(l[1]), parseInt(l[2]), parseInt(l[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(l) {
    return [parseInt(l[1], 16), parseInt(l[2], 16), parseInt(l[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(l) {
    return [parseInt(l[1] + l[1], 16), parseInt(l[2] + l[2], 16), parseInt(l[3] + l[3], 16)];
  } }], r = 0; r < t.length; r++) {
    var i = t[r].re, o = t[r].process, c = i.exec(n);
    c && (e = o(c), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var l = this.r.toString(16), _ = this.g.toString(16), b = this.b.toString(16);
    return l.length == 1 && (l = "0" + l), _.length == 1 && (_ = "0" + _), b.length == 1 && (b = "0" + b), "#" + l + _ + b;
  };
}
/**
* @license
* Joseph Myers does not specify a particular license for his work.
*
* Author: Joseph Myers
* Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
*
* Modified by: Owen Leong
*/
function $_(n, e) {
  var t = n[0], r = n[1], i = n[2], o = n[3];
  t = Js(t, r, i, o, e[0], 7, -680876936), o = Js(o, t, r, i, e[1], 12, -389564586), i = Js(i, o, t, r, e[2], 17, 606105819), r = Js(r, i, o, t, e[3], 22, -1044525330), t = Js(t, r, i, o, e[4], 7, -176418897), o = Js(o, t, r, i, e[5], 12, 1200080426), i = Js(i, o, t, r, e[6], 17, -1473231341), r = Js(r, i, o, t, e[7], 22, -45705983), t = Js(t, r, i, o, e[8], 7, 1770035416), o = Js(o, t, r, i, e[9], 12, -1958414417), i = Js(i, o, t, r, e[10], 17, -42063), r = Js(r, i, o, t, e[11], 22, -1990404162), t = Js(t, r, i, o, e[12], 7, 1804603682), o = Js(o, t, r, i, e[13], 12, -40341101), i = Js(i, o, t, r, e[14], 17, -1502002290), t = Ys(t, r = Js(r, i, o, t, e[15], 22, 1236535329), i, o, e[1], 5, -165796510), o = Ys(o, t, r, i, e[6], 9, -1069501632), i = Ys(i, o, t, r, e[11], 14, 643717713), r = Ys(r, i, o, t, e[0], 20, -373897302), t = Ys(t, r, i, o, e[5], 5, -701558691), o = Ys(o, t, r, i, e[10], 9, 38016083), i = Ys(i, o, t, r, e[15], 14, -660478335), r = Ys(r, i, o, t, e[4], 20, -405537848), t = Ys(t, r, i, o, e[9], 5, 568446438), o = Ys(o, t, r, i, e[14], 9, -1019803690), i = Ys(i, o, t, r, e[3], 14, -187363961), r = Ys(r, i, o, t, e[8], 20, 1163531501), t = Ys(t, r, i, o, e[13], 5, -1444681467), o = Ys(o, t, r, i, e[2], 9, -51403784), i = Ys(i, o, t, r, e[7], 14, 1735328473), t = Ks(t, r = Ys(r, i, o, t, e[12], 20, -1926607734), i, o, e[5], 4, -378558), o = Ks(o, t, r, i, e[8], 11, -2022574463), i = Ks(i, o, t, r, e[11], 16, 1839030562), r = Ks(r, i, o, t, e[14], 23, -35309556), t = Ks(t, r, i, o, e[1], 4, -1530992060), o = Ks(o, t, r, i, e[4], 11, 1272893353), i = Ks(i, o, t, r, e[7], 16, -155497632), r = Ks(r, i, o, t, e[10], 23, -1094730640), t = Ks(t, r, i, o, e[13], 4, 681279174), o = Ks(o, t, r, i, e[0], 11, -358537222), i = Ks(i, o, t, r, e[3], 16, -722521979), r = Ks(r, i, o, t, e[6], 23, 76029189), t = Ks(t, r, i, o, e[9], 4, -640364487), o = Ks(o, t, r, i, e[12], 11, -421815835), i = Ks(i, o, t, r, e[15], 16, 530742520), t = Qs(t, r = Ks(r, i, o, t, e[2], 23, -995338651), i, o, e[0], 6, -198630844), o = Qs(o, t, r, i, e[7], 10, 1126891415), i = Qs(i, o, t, r, e[14], 15, -1416354905), r = Qs(r, i, o, t, e[5], 21, -57434055), t = Qs(t, r, i, o, e[12], 6, 1700485571), o = Qs(o, t, r, i, e[3], 10, -1894986606), i = Qs(i, o, t, r, e[10], 15, -1051523), r = Qs(r, i, o, t, e[1], 21, -2054922799), t = Qs(t, r, i, o, e[8], 6, 1873313359), o = Qs(o, t, r, i, e[15], 10, -30611744), i = Qs(i, o, t, r, e[6], 15, -1560198380), r = Qs(r, i, o, t, e[13], 21, 1309151649), t = Qs(t, r, i, o, e[4], 6, -145523070), o = Qs(o, t, r, i, e[11], 10, -1120210379), i = Qs(i, o, t, r, e[2], 15, 718787259), r = Qs(r, i, o, t, e[9], 21, -343485551), n[0] = ju(t, n[0]), n[1] = ju(r, n[1]), n[2] = ju(i, n[2]), n[3] = ju(o, n[3]);
}
function Zm(n, e, t, r, i, o) {
  return e = ju(ju(e, n), ju(r, o)), ju(e << i | e >>> 32 - i, t);
}
function Js(n, e, t, r, i, o, c) {
  return Zm(e & t | ~e & r, n, e, i, o, c);
}
function Ys(n, e, t, r, i, o, c) {
  return Zm(e & r | t & ~r, n, e, i, o, c);
}
function Ks(n, e, t, r, i, o, c) {
  return Zm(e ^ t ^ r, n, e, i, o, c);
}
function Qs(n, e, t, r, i, o, c) {
  return Zm(t ^ (e | ~r), n, e, i, o, c);
}
function CT(n) {
  var e, t = n.length, r = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= n.length; e += 64) $_(r, oV(n.substring(e - 64, e)));
  n = n.substring(e - 64);
  var i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < n.length; e++) i[e >> 2] |= n.charCodeAt(e) << (e % 4 << 3);
  if (i[e >> 2] |= 128 << (e % 4 << 3), e > 55) for ($_(r, i), e = 0; e < 16; e++) i[e] = 0;
  return i[14] = 8 * t, $_(r, i), r;
}
function oV(n) {
  var e, t = [];
  for (e = 0; e < 64; e += 4) t[e >> 2] = n.charCodeAt(e) + (n.charCodeAt(e + 1) << 8) + (n.charCodeAt(e + 2) << 16) + (n.charCodeAt(e + 3) << 24);
  return t;
}
fp = Rn.atob.bind(Rn), t1 = Rn.btoa.bind(Rn);
var zA = "0123456789abcdef".split("");
function aV(n) {
  for (var e = "", t = 0; t < 4; t++) e += zA[n >> 8 * t + 4 & 15] + zA[n >> 8 * t & 15];
  return e;
}
function lV(n) {
  return String.fromCharCode((255 & n) >> 0, (65280 & n) >> 8, (16711680 & n) >> 16, (4278190080 & n) >> 24);
}
function n1(n) {
  return CT(n).map(lV).join("");
}
var cV = function(n) {
  for (var e = 0; e < n.length; e++) n[e] = aV(n[e]);
  return n.join("");
}(CT("hello")) != "5d41402abc4b2a76b9719d911017c592";
function ju(n, e) {
  if (cV) {
    var t = (65535 & n) + (65535 & e);
    return (n >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return n + e & 4294967295;
}
/**
* @license
* FPDF is released under a permissive license: there is no usage restriction.
* You may embed it freely in your application (commercial or not), with or
* without modifications.
*
* Reference: http://www.fpdf.org/en/script/script37.php
*/
function r1(n, e) {
  var t, r, i, o;
  if (n !== t) {
    for (var c = (i = n, o = 1 + (256 / n.length >> 0), new Array(o + 1).join(i)), l = [], _ = 0; _ < 256; _++) l[_] = _;
    var b = 0;
    for (_ = 0; _ < 256; _++) {
      var w = l[_];
      b = (b + w + c.charCodeAt(_)) % 256, l[_] = l[b], l[b] = w;
    }
    t = n, r = l;
  } else l = r;
  var T = e.length, I = 0, P = 0, k = "";
  for (_ = 0; _ < T; _++) P = (P + (w = l[I = (I + 1) % 256])) % 256, l[I] = l[P], l[P] = w, c = l[(l[I] + l[P]) % 256], k += String.fromCharCode(e.charCodeAt(_) ^ c);
  return k;
}
/**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
* Author: Owen Leong (@owenl131)
* Date: 15 Oct 2020
* References:
* https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
* https://github.com/foliojs/pdfkit/blob/master/lib/security.js
* http://www.fpdf.org/en/script/script37.php
*/
var UA = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Cd(n, e, t, r) {
  this.v = 1, this.r = 2;
  var i = 192;
  n.forEach(function(l) {
    if (UA.perm !== void 0) throw new Error("Invalid permission: " + l);
    i += UA[l];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var o = (e + this.padding).substr(0, 32), c = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(o, c), this.P = -(1 + (255 ^ i)), this.encryptionKey = n1(o + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(r)).substr(0, 5), this.U = r1(this.encryptionKey, this.padding);
}
function Id(n) {
  if (/[^\u0000-\u00ff]/.test(n)) throw new Error("Invalid PDF Name Object: " + n + ", Only accept ASCII characters.");
  for (var e = "", t = n.length, r = 0; r < t; r++) {
    var i = n.charCodeAt(r);
    i < 33 || i === 35 || i === 37 || i === 40 || i === 41 || i === 47 || i === 60 || i === 62 || i === 91 || i === 93 || i === 123 || i === 125 || i > 126 ? e += "#" + ("0" + i.toString(16)).slice(-2) : e += n[r];
  }
  return e;
}
function jA(n) {
  if (zr(n) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, r, i) {
    if (i = i || !1, typeof t != "string" || typeof r != "function" || typeof i != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var o = Math.random().toString(35);
    return e[t][o] = [r, !!i], o;
  }, this.unsubscribe = function(t) {
    for (var r in e) if (e[r][t]) return delete e[r][t], Object.keys(e[r]).length === 0 && delete e[r], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var r = Array.prototype.slice.call(arguments, 1), i = [];
      for (var o in e[t]) {
        var c = e[t][o];
        try {
          c[0].apply(n, r);
        } catch (l) {
          Rn.console && $r.error("jsPDF PubSub Error", l.message, l);
        }
        c[1] && i.push(o);
      }
      i.length && i.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function Lm(n) {
  if (!(this instanceof Lm)) return new Lm(n);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in n) n.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = n[t]);
  this.id = "", this.objectNumber = -1;
}
function IT(n, e) {
  this.gState = n, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function Th(n, e, t, r, i) {
  if (!(this instanceof Th)) return new Th(n, e, t, r, i);
  this.type = n === "axial" ? 2 : 3, this.coords = e, this.colors = t, IT.call(this, r, i);
}
function Od(n, e, t, r, i) {
  if (!(this instanceof Od)) return new Od(n, e, t, r, i);
  this.boundingBox = n, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, IT.call(this, r, i);
}
function Bn(n) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", r = arguments[1], i = arguments[2], o = arguments[3], c = [], l = 1, _ = 16, b = "S", w = null;
  zr(n = n || {}) === "object" && (t = n.orientation, r = n.unit || r, i = n.format || i, o = n.compress || n.compressPdf || o, (w = n.encryption || null) !== null && (w.userPassword = w.userPassword || "", w.ownerPassword = w.ownerPassword || "", w.userPermissions = w.userPermissions || []), l = typeof n.userUnit == "number" ? Math.abs(n.userUnit) : 1, n.precision !== void 0 && (e = n.precision), n.floatPrecision !== void 0 && (_ = n.floatPrecision), b = n.defaultPathOperation || "S"), c = n.filters || (o === !0 ? ["FlateEncode"] : c), r = r || "mm", t = ("" + (t || "P")).toLowerCase();
  var T = n.putOnlyUsedFonts || !1, I = {}, P = { internal: {}, __private__: {} };
  P.__private__.PubSub = jA;
  var k = "1.3", U = P.__private__.getPdfVersion = function() {
    return k;
  };
  P.__private__.setPdfVersion = function(O) {
    k = O;
  };
  var G = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  P.__private__.getPageFormats = function() {
    return G;
  };
  var H = P.__private__.getPageFormat = function(O) {
    return G[O];
  };
  i = i || "a4";
  var $ = { COMPAT: "compat", ADVANCED: "advanced" }, ie = $.COMPAT;
  function ge() {
    this.saveGraphicsState(), ne(new Oe(Ot, 0, 0, -Ot, 0, Ta() * Ot).toString() + " cm"), this.setFontSize(this.getFontSize() / Ot), b = "n", ie = $.ADVANCED;
  }
  function Se() {
    this.restoreGraphicsState(), b = "S", ie = $.COMPAT;
  }
  var Re = P.__private__.combineFontStyleAndFontWeight = function(O, te) {
    if (O == "bold" && te == "normal" || O == "bold" && te == 400 || O == "normal" && te == "italic" || O == "bold" && te == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return te && (O = te == 400 || te === "normal" ? O === "italic" ? "italic" : "normal" : te != 700 && te !== "bold" || O !== "normal" ? (te == 700 ? "bold" : te) + "" + O : "bold"), O;
  };
  P.advancedAPI = function(O) {
    var te = ie === $.COMPAT;
    return te && ge.call(this), typeof O != "function" || (O(this), te && Se.call(this)), this;
  }, P.compatAPI = function(O) {
    var te = ie === $.ADVANCED;
    return te && Se.call(this), typeof O != "function" || (O(this), te && ge.call(this)), this;
  }, P.isAdvancedAPI = function() {
    return ie === $.ADVANCED;
  };
  var Le, _e = function(O) {
    if (ie !== $.ADVANCED) throw new Error(O + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, Ge = P.roundToPrecision = P.__private__.roundToPrecision = function(O, te) {
    var Ee = e || te;
    if (isNaN(O) || isNaN(Ee)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return O.toFixed(Ee).replace(/0+$/, "");
  };
  Le = P.hpf = P.__private__.hpf = typeof _ == "number" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ge(O, _);
  } : _ === "smart" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ge(O, O > -1 && O < 1 ? 16 : 5);
  } : function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ge(O, 16);
  };
  var ke = P.f2 = P.__private__.f2 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f2");
    return Ge(O, 2);
  }, oe = P.__private__.f3 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f3");
    return Ge(O, 3);
  }, pe = P.scale = P.__private__.scale = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.scale");
    return ie === $.COMPAT ? O * Ot : ie === $.ADVANCED ? O : void 0;
  }, Te = function(O) {
    return ie === $.COMPAT ? Ta() - O : ie === $.ADVANCED ? O : void 0;
  }, xe = function(O) {
    return pe(Te(O));
  };
  P.__private__.setPrecision = P.setPrecision = function(O) {
    typeof parseInt(O, 10) == "number" && (e = parseInt(O, 10));
  };
  var et, rt = "00000000000000000000000000000000", st = P.__private__.getFileId = function() {
    return rt;
  }, Je = P.__private__.setFileId = function(O) {
    return rt = O !== void 0 && /^[a-fA-F0-9]{32}$/.test(O) ? O.toUpperCase() : rt.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), w !== null && (nr = new Cd(w.userPermissions, w.userPassword, w.ownerPassword, rt)), rt;
  };
  P.setFileId = function(O) {
    return Je(O), this;
  }, P.getFileId = function() {
    return st();
  };
  var ct = P.__private__.convertDateToPDFDate = function(O) {
    var te = O.getTimezoneOffset(), Ee = te < 0 ? "+" : "-", ze = Math.floor(Math.abs(te / 60)), Xe = Math.abs(te % 60), lt = [Ee, Ce(ze), "'", Ce(Xe), "'"].join("");
    return ["D:", O.getFullYear(), Ce(O.getMonth() + 1), Ce(O.getDate()), Ce(O.getHours()), Ce(O.getMinutes()), Ce(O.getSeconds()), lt].join("");
  }, ot = P.__private__.convertPDFDateToDate = function(O) {
    var te = parseInt(O.substr(2, 4), 10), Ee = parseInt(O.substr(6, 2), 10) - 1, ze = parseInt(O.substr(8, 2), 10), Xe = parseInt(O.substr(10, 2), 10), lt = parseInt(O.substr(12, 2), 10), Pt = parseInt(O.substr(14, 2), 10);
    return new Date(te, Ee, ze, Xe, lt, Pt, 0);
  }, Mt = P.__private__.setCreationDate = function(O) {
    var te;
    if (O === void 0 && (O = /* @__PURE__ */ new Date()), O instanceof Date) te = ct(O);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(O)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      te = O;
    }
    return et = te;
  }, re = P.__private__.getCreationDate = function(O) {
    var te = et;
    return O === "jsDate" && (te = ot(et)), te;
  };
  P.setCreationDate = function(O) {
    return Mt(O), this;
  }, P.getCreationDate = function(O) {
    return re(O);
  };
  var Ae, Ce = P.__private__.padd2 = function(O) {
    return ("0" + parseInt(O)).slice(-2);
  }, Ue = P.__private__.padd2Hex = function(O) {
    return ("00" + (O = O.toString())).substr(O.length);
  }, qe = 0, He = [], Ye = [], Ze = 0, St = [], Lt = [], Dt = !1, Nt = Ye, an = function() {
    qe = 0, Ze = 0, Ye = [], He = [], St = [], Mn = vt(), en = vt();
  };
  P.__private__.setCustomOutputDestination = function(O) {
    Dt = !0, Nt = O;
  };
  var at = function(O) {
    Dt || (Nt = O);
  };
  P.__private__.resetCustomOutputDestination = function() {
    Dt = !1, Nt = Ye;
  };
  var ne = P.__private__.out = function(O) {
    return O = O.toString(), Ze += O.length + 1, Nt.push(O), Nt;
  }, pn = P.__private__.write = function(O) {
    return ne(arguments.length === 1 ? O.toString() : Array.prototype.join.call(arguments, " "));
  }, Qt = P.__private__.getArrayBuffer = function(O) {
    for (var te = O.length, Ee = new ArrayBuffer(te), ze = new Uint8Array(Ee); te--; ) ze[te] = O.charCodeAt(te);
    return Ee;
  }, dt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  P.__private__.getStandardFonts = function() {
    return dt;
  };
  var Et = n.fontSize || 16;
  P.__private__.setFontSize = P.setFontSize = function(O) {
    return Et = ie === $.ADVANCED ? O / Ot : O, this;
  };
  var Bt, Ft = P.__private__.getFontSize = P.getFontSize = function() {
    return ie === $.COMPAT ? Et : Et * Ot;
  }, nn = n.R2L || !1;
  P.__private__.setR2L = P.setR2L = function(O) {
    return nn = O, this;
  }, P.__private__.getR2L = P.getR2L = function() {
    return nn;
  };
  var Sn, vn = P.__private__.setZoomMode = function(O) {
    var te = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(O)) Bt = O;
    else if (isNaN(O)) {
      if (te.indexOf(O) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + O + '" is not recognized.');
      Bt = O;
    } else Bt = parseInt(O, 10);
  };
  P.__private__.getZoomMode = function() {
    return Bt;
  };
  var On, Un = P.__private__.setPageMode = function(O) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(O) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + O + '" is not recognized.');
    Sn = O;
  };
  P.__private__.getPageMode = function() {
    return Sn;
  };
  var gt = P.__private__.setLayoutMode = function(O) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(O) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + O + '" is not recognized.');
    On = O;
  };
  P.__private__.getLayoutMode = function() {
    return On;
  }, P.__private__.setDisplayMode = P.setDisplayMode = function(O, te, Ee) {
    return vn(O), gt(te), Un(Ee), this;
  };
  var un = { title: "", subject: "", author: "", keywords: "", creator: "" };
  P.__private__.getDocumentProperty = function(O) {
    if (Object.keys(un).indexOf(O) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return un[O];
  }, P.__private__.getDocumentProperties = function() {
    return un;
  }, P.__private__.setDocumentProperties = P.setProperties = P.setDocumentProperties = function(O) {
    for (var te in un) un.hasOwnProperty(te) && O[te] && (un[te] = O[te]);
    return this;
  }, P.__private__.setDocumentProperty = function(O, te) {
    if (Object.keys(un).indexOf(O) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return un[O] = te;
  };
  var xn, Ot, _r, mt, bn, jt = {}, qn = {}, Jr = [], zt = {}, yi = {}, rr = {}, ti = {}, ni = null, be = 0, J = [], K = new jA(P), ce = n.hotfixes || [], ye = {}, Fe = {}, je = [], Oe = function O(te, Ee, ze, Xe, lt, Pt) {
    if (!(this instanceof O)) return new O(te, Ee, ze, Xe, lt, Pt);
    isNaN(te) && (te = 1), isNaN(Ee) && (Ee = 0), isNaN(ze) && (ze = 0), isNaN(Xe) && (Xe = 1), isNaN(lt) && (lt = 0), isNaN(Pt) && (Pt = 0), this._matrix = [te, Ee, ze, Xe, lt, Pt];
  };
  Object.defineProperty(Oe.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(Oe.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(Oe.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(Oe.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(Oe.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(Oe.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(Oe.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(Oe.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(Oe.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(Oe.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(Oe.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(Oe.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(Oe.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Oe.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Oe.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Oe.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Oe.prototype.join = function(O) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(Le).join(O);
  }, Oe.prototype.multiply = function(O) {
    var te = O.sx * this.sx + O.shy * this.shx, Ee = O.sx * this.shy + O.shy * this.sy, ze = O.shx * this.sx + O.sy * this.shx, Xe = O.shx * this.shy + O.sy * this.sy, lt = O.tx * this.sx + O.ty * this.shx + this.tx, Pt = O.tx * this.shy + O.ty * this.sy + this.ty;
    return new Oe(te, Ee, ze, Xe, lt, Pt);
  }, Oe.prototype.decompose = function() {
    var O = this.sx, te = this.shy, Ee = this.shx, ze = this.sy, Xe = this.tx, lt = this.ty, Pt = Math.sqrt(O * O + te * te), Wt = (O /= Pt) * Ee + (te /= Pt) * ze;
    Ee -= O * Wt, ze -= te * Wt;
    var _n = Math.sqrt(Ee * Ee + ze * ze);
    return Wt /= _n, O * (ze /= _n) < te * (Ee /= _n) && (O = -O, te = -te, Wt = -Wt, Pt = -Pt), { scale: new Oe(Pt, 0, 0, _n, 0, 0), translate: new Oe(1, 0, 0, 1, Xe, lt), rotate: new Oe(O, te, -te, O, 0, 0), skew: new Oe(1, 0, Wt, 1, 0, 0) };
  }, Oe.prototype.toString = function(O) {
    return this.join(" ");
  }, Oe.prototype.inversed = function() {
    var O = this.sx, te = this.shy, Ee = this.shx, ze = this.sy, Xe = this.tx, lt = this.ty, Pt = 1 / (O * ze - te * Ee), Wt = ze * Pt, _n = -te * Pt, Ln = -Ee * Pt, kn = O * Pt;
    return new Oe(Wt, _n, Ln, kn, -Wt * Xe - Ln * lt, -_n * Xe - kn * lt);
  }, Oe.prototype.applyToPoint = function(O) {
    var te = O.x * this.sx + O.y * this.shx + this.tx, Ee = O.x * this.shy + O.y * this.sy + this.ty;
    return new Os(te, Ee);
  }, Oe.prototype.applyToRectangle = function(O) {
    var te = this.applyToPoint(O), Ee = this.applyToPoint(new Os(O.x + O.w, O.y + O.h));
    return new Ul(te.x, te.y, Ee.x - te.x, Ee.y - te.y);
  }, Oe.prototype.clone = function() {
    var O = this.sx, te = this.shy, Ee = this.shx, ze = this.sy, Xe = this.tx, lt = this.ty;
    return new Oe(O, te, Ee, ze, Xe, lt);
  }, P.Matrix = Oe;
  var Ie = P.matrixMult = function(O, te) {
    return te.multiply(O);
  }, tt = new Oe(1, 0, 0, 1, 0, 0);
  P.unitMatrix = P.identityMatrix = tt;
  var ut = function(O, te) {
    if (!yi[O]) {
      var Ee = (te instanceof Th ? "Sh" : "P") + (Object.keys(zt).length + 1).toString(10);
      te.id = Ee, yi[O] = Ee, zt[Ee] = te, K.publish("addPattern", te);
    }
  };
  P.ShadingPattern = Th, P.TilingPattern = Od, P.addShadingPattern = function(O, te) {
    return _e("addShadingPattern()"), ut(O, te), this;
  }, P.beginTilingPattern = function(O) {
    _e("beginTilingPattern()"), Cc(O.boundingBox[0], O.boundingBox[1], O.boundingBox[2] - O.boundingBox[0], O.boundingBox[3] - O.boundingBox[1], O.matrix);
  }, P.endTilingPattern = function(O, te) {
    _e("endTilingPattern()"), te.stream = Lt[Ae].join(`
`), ut(O, te), K.publish("endTilingPattern", te), je.pop().restore();
  };
  var We = P.__private__.newObject = function() {
    var O = vt();
    return Xt(O, !0), O;
  }, vt = P.__private__.newObjectDeferred = function() {
    return qe++, He[qe] = function() {
      return Ze;
    }, qe;
  }, Xt = function(O, te) {
    return te = typeof te == "boolean" && te, He[O] = Ze, te && ne(O + " 0 obj"), O;
  }, Kt = P.__private__.newAdditionalObject = function() {
    var O = { objId: vt(), content: "" };
    return St.push(O), O;
  }, Mn = vt(), en = vt(), In = P.__private__.decodeColorString = function(O) {
    var te = O.split(" ");
    if (te.length !== 2 || te[1] !== "g" && te[1] !== "G") te.length === 5 && (te[4] === "k" || te[4] === "K") && (te = [(1 - te[0]) * (1 - te[3]), (1 - te[1]) * (1 - te[3]), (1 - te[2]) * (1 - te[3]), "r"]);
    else {
      var Ee = parseFloat(te[0]);
      te = [Ee, Ee, Ee, "r"];
    }
    for (var ze = "#", Xe = 0; Xe < 3; Xe++) ze += ("0" + Math.floor(255 * parseFloat(te[Xe])).toString(16)).slice(-2);
    return ze;
  }, wn = P.__private__.encodeColorString = function(O) {
    var te;
    typeof O == "string" && (O = { ch1: O });
    var Ee = O.ch1, ze = O.ch2, Xe = O.ch3, lt = O.ch4, Pt = O.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof Ee == "string" && Ee.charAt(0) !== "#") {
      var Wt = new TT(Ee);
      if (Wt.ok) Ee = Wt.toHex();
      else if (!/^\d*\.?\d*$/.test(Ee)) throw new Error('Invalid color "' + Ee + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof Ee == "string" && /^#[0-9A-Fa-f]{3}$/.test(Ee) && (Ee = "#" + Ee[1] + Ee[1] + Ee[2] + Ee[2] + Ee[3] + Ee[3]), typeof Ee == "string" && /^#[0-9A-Fa-f]{6}$/.test(Ee)) {
      var _n = parseInt(Ee.substr(1), 16);
      Ee = _n >> 16 & 255, ze = _n >> 8 & 255, Xe = 255 & _n;
    }
    if (ze === void 0 || lt === void 0 && Ee === ze && ze === Xe)
      if (typeof Ee == "string") te = Ee + " " + Pt[0];
      else switch (O.precision) {
        case 2:
          te = ke(Ee / 255) + " " + Pt[0];
          break;
        case 3:
        default:
          te = oe(Ee / 255) + " " + Pt[0];
      }
    else if (lt === void 0 || zr(lt) === "object") {
      if (lt && !isNaN(lt.a) && lt.a === 0) return te = ["1.", "1.", "1.", Pt[1]].join(" ");
      if (typeof Ee == "string") te = [Ee, ze, Xe, Pt[1]].join(" ");
      else switch (O.precision) {
        case 2:
          te = [ke(Ee / 255), ke(ze / 255), ke(Xe / 255), Pt[1]].join(" ");
          break;
        default:
        case 3:
          te = [oe(Ee / 255), oe(ze / 255), oe(Xe / 255), Pt[1]].join(" ");
      }
    } else if (typeof Ee == "string") te = [Ee, ze, Xe, lt, Pt[2]].join(" ");
    else switch (O.precision) {
      case 2:
        te = [ke(Ee), ke(ze), ke(Xe), ke(lt), Pt[2]].join(" ");
        break;
      case 3:
      default:
        te = [oe(Ee), oe(ze), oe(Xe), oe(lt), Pt[2]].join(" ");
    }
    return te;
  }, ir = P.__private__.getFilters = function() {
    return c;
  }, Wn = P.__private__.putStream = function(O) {
    var te = (O = O || {}).data || "", Ee = O.filters || ir(), ze = O.alreadyAppliedFilters || [], Xe = O.addLength1 || !1, lt = te.length, Pt = O.objectId, Wt = function(Di) {
      return Di;
    };
    if (w !== null && Pt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    w !== null && (Wt = nr.encryptor(Pt, 0));
    var _n = {};
    Ee === !0 && (Ee = ["FlateEncode"]);
    var Ln = O.additionalKeyValues || [], kn = (_n = Bn.API.processDataByFilters !== void 0 ? Bn.API.processDataByFilters(te, Ee) : { data: te, reverseChain: [] }).reverseChain + (Array.isArray(ze) ? ze.join(" ") : ze.toString());
    if (_n.data.length !== 0 && (Ln.push({ key: "Length", value: _n.data.length }), Xe === !0 && Ln.push({ key: "Length1", value: lt })), kn.length != 0) if (kn.split("/").length - 1 == 1) Ln.push({ key: "Filter", value: kn });
    else {
      Ln.push({ key: "Filter", value: "[" + kn + "]" });
      for (var Gn = 0; Gn < Ln.length; Gn += 1) if (Ln[Gn].key === "DecodeParms") {
        for (var Or = [], ri = 0; ri < _n.reverseChain.split("/").length - 1; ri += 1) Or.push("null");
        Or.push(Ln[Gn].value), Ln[Gn].value = "[" + Or.join(" ") + "]";
      }
    }
    ne("<<");
    for (var Nn = 0; Nn < Ln.length; Nn++) ne("/" + Ln[Nn].key + " " + Ln[Nn].value);
    ne(">>"), _n.data.length !== 0 && (ne("stream"), ne(Wt(_n.data)), ne("endstream"));
  }, hn = P.__private__.putPage = function(O) {
    var te = O.number, Ee = O.data, ze = O.objId, Xe = O.contentsObjId;
    Xt(ze, !0), ne("<</Type /Page"), ne("/Parent " + O.rootDictionaryObjId + " 0 R"), ne("/Resources " + O.resourceDictionaryObjId + " 0 R"), ne("/MediaBox [" + parseFloat(Le(O.mediaBox.bottomLeftX)) + " " + parseFloat(Le(O.mediaBox.bottomLeftY)) + " " + Le(O.mediaBox.topRightX) + " " + Le(O.mediaBox.topRightY) + "]"), O.cropBox !== null && ne("/CropBox [" + Le(O.cropBox.bottomLeftX) + " " + Le(O.cropBox.bottomLeftY) + " " + Le(O.cropBox.topRightX) + " " + Le(O.cropBox.topRightY) + "]"), O.bleedBox !== null && ne("/BleedBox [" + Le(O.bleedBox.bottomLeftX) + " " + Le(O.bleedBox.bottomLeftY) + " " + Le(O.bleedBox.topRightX) + " " + Le(O.bleedBox.topRightY) + "]"), O.trimBox !== null && ne("/TrimBox [" + Le(O.trimBox.bottomLeftX) + " " + Le(O.trimBox.bottomLeftY) + " " + Le(O.trimBox.topRightX) + " " + Le(O.trimBox.topRightY) + "]"), O.artBox !== null && ne("/ArtBox [" + Le(O.artBox.bottomLeftX) + " " + Le(O.artBox.bottomLeftY) + " " + Le(O.artBox.topRightX) + " " + Le(O.artBox.topRightY) + "]"), typeof O.userUnit == "number" && O.userUnit !== 1 && ne("/UserUnit " + O.userUnit), K.publish("putPage", { objId: ze, pageContext: J[te], pageNumber: te, page: Ee }), ne("/Contents " + Xe + " 0 R"), ne(">>"), ne("endobj");
    var lt = Ee.join(`
`);
    return ie === $.ADVANCED && (lt += `
Q`), Xt(Xe, !0), Wn({ data: lt, filters: ir(), objectId: Xe }), ne("endobj"), ze;
  }, Fn = P.__private__.putPages = function() {
    var O, te, Ee = [];
    for (O = 1; O <= be; O++) J[O].objId = vt(), J[O].contentsObjId = vt();
    for (O = 1; O <= be; O++) Ee.push(hn({ number: O, data: Lt[O], objId: J[O].objId, contentsObjId: J[O].contentsObjId, mediaBox: J[O].mediaBox, cropBox: J[O].cropBox, bleedBox: J[O].bleedBox, trimBox: J[O].trimBox, artBox: J[O].artBox, userUnit: J[O].userUnit, rootDictionaryObjId: Mn, resourceDictionaryObjId: en }));
    Xt(Mn, !0), ne("<</Type /Pages");
    var ze = "/Kids [";
    for (te = 0; te < be; te++) ze += Ee[te] + " 0 R ";
    ne(ze + "]"), ne("/Count " + be), ne(">>"), ne("endobj"), K.publish("postPutPages");
  }, er = function(O) {
    K.publish("putFont", { font: O, out: ne, newObject: We, putStream: Wn }), O.isAlreadyPutted !== !0 && (O.objectNumber = We(), ne("<<"), ne("/Type /Font"), ne("/BaseFont /" + Id(O.postScriptName)), ne("/Subtype /Type1"), typeof O.encoding == "string" && ne("/Encoding /" + O.encoding), ne("/FirstChar 32"), ne("/LastChar 255"), ne(">>"), ne("endobj"));
  }, fr = function() {
    for (var O in jt) jt.hasOwnProperty(O) && (T === !1 || T === !0 && I.hasOwnProperty(O)) && er(jt[O]);
  }, Sr = function(O) {
    O.objectNumber = We();
    var te = [];
    te.push({ key: "Type", value: "/XObject" }), te.push({ key: "Subtype", value: "/Form" }), te.push({ key: "BBox", value: "[" + [Le(O.x), Le(O.y), Le(O.x + O.width), Le(O.y + O.height)].join(" ") + "]" }), te.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" });
    var Ee = O.pages[1].join(`
`);
    Wn({ data: Ee, additionalKeyValues: te, objectId: O.objectNumber }), ne("endobj");
  }, Yr = function() {
    for (var O in ye) ye.hasOwnProperty(O) && Sr(ye[O]);
  }, so = function(O, te) {
    var Ee, ze = [], Xe = 1 / (te - 1);
    for (Ee = 0; Ee < 1; Ee += Xe) ze.push(Ee);
    if (ze.push(1), O[0].offset != 0) {
      var lt = { offset: 0, color: O[0].color };
      O.unshift(lt);
    }
    if (O[O.length - 1].offset != 1) {
      var Pt = { offset: 1, color: O[O.length - 1].color };
      O.push(Pt);
    }
    for (var Wt = "", _n = 0, Ln = 0; Ln < ze.length; Ln++) {
      for (Ee = ze[Ln]; Ee > O[_n + 1].offset; ) _n++;
      var kn = O[_n].offset, Gn = (Ee - kn) / (O[_n + 1].offset - kn), Or = O[_n].color, ri = O[_n + 1].color;
      Wt += Ue(Math.round((1 - Gn) * Or[0] + Gn * ri[0]).toString(16)) + Ue(Math.round((1 - Gn) * Or[1] + Gn * ri[1]).toString(16)) + Ue(Math.round((1 - Gn) * Or[2] + Gn * ri[2]).toString(16));
    }
    return Wt.trim();
  }, Jn = function(O, te) {
    te || (te = 21);
    var Ee = We(), ze = so(O.colors, te), Xe = [];
    Xe.push({ key: "FunctionType", value: "0" }), Xe.push({ key: "Domain", value: "[0.0 1.0]" }), Xe.push({ key: "Size", value: "[" + te + "]" }), Xe.push({ key: "BitsPerSample", value: "8" }), Xe.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Xe.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Wn({ data: ze, additionalKeyValues: Xe, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Ee }), ne("endobj"), O.objectNumber = We(), ne("<< /ShadingType " + O.type), ne("/ColorSpace /DeviceRGB");
    var lt = "/Coords [" + Le(parseFloat(O.coords[0])) + " " + Le(parseFloat(O.coords[1])) + " ";
    O.type === 2 ? lt += Le(parseFloat(O.coords[2])) + " " + Le(parseFloat(O.coords[3])) : lt += Le(parseFloat(O.coords[2])) + " " + Le(parseFloat(O.coords[3])) + " " + Le(parseFloat(O.coords[4])) + " " + Le(parseFloat(O.coords[5])), ne(lt += "]"), O.matrix && ne("/Matrix [" + O.matrix.toString() + "]"), ne("/Function " + Ee + " 0 R"), ne("/Extend [true true]"), ne(">>"), ne("endobj");
  }, bi = function(O, te) {
    var Ee = vt(), ze = We();
    te.push({ resourcesOid: Ee, objectOid: ze }), O.objectNumber = ze;
    var Xe = [];
    Xe.push({ key: "Type", value: "/Pattern" }), Xe.push({ key: "PatternType", value: "1" }), Xe.push({ key: "PaintType", value: "1" }), Xe.push({ key: "TilingType", value: "1" }), Xe.push({ key: "BBox", value: "[" + O.boundingBox.map(Le).join(" ") + "]" }), Xe.push({ key: "XStep", value: Le(O.xStep) }), Xe.push({ key: "YStep", value: Le(O.yStep) }), Xe.push({ key: "Resources", value: Ee + " 0 R" }), O.matrix && Xe.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" }), Wn({ data: O.stream, additionalKeyValues: Xe, objectId: O.objectNumber }), ne("endobj");
  }, Xi = function(O) {
    var te;
    for (te in zt) zt.hasOwnProperty(te) && (zt[te] instanceof Th ? Jn(zt[te]) : zt[te] instanceof Od && bi(zt[te], O));
  }, Pr = function(O) {
    for (var te in O.objectNumber = We(), ne("<<"), O) switch (te) {
      case "opacity":
        ne("/ca " + ke(O[te]));
        break;
      case "stroke-opacity":
        ne("/CA " + ke(O[te]));
    }
    ne(">>"), ne("endobj");
  }, Lr = function() {
    var O;
    for (O in rr) rr.hasOwnProperty(O) && Pr(rr[O]);
  }, oo = function() {
    for (var O in ne("/XObject <<"), ye) ye.hasOwnProperty(O) && ye[O].objectNumber >= 0 && ne("/" + O + " " + ye[O].objectNumber + " 0 R");
    K.publish("putXobjectDict"), ne(">>");
  }, Mr = function() {
    nr.oid = We(), ne("<<"), ne("/Filter /Standard"), ne("/V " + nr.v), ne("/R " + nr.r), ne("/U <" + nr.toHexString(nr.U) + ">"), ne("/O <" + nr.toHexString(nr.O) + ">"), ne("/P " + nr.P), ne(">>"), ne("endobj");
  }, Er = function() {
    for (var O in ne("/Font <<"), jt) jt.hasOwnProperty(O) && (T === !1 || T === !0 && I.hasOwnProperty(O)) && ne("/" + O + " " + jt[O].objectNumber + " 0 R");
    ne(">>");
  }, ao = function() {
    if (Object.keys(zt).length > 0) {
      for (var O in ne("/Shading <<"), zt) zt.hasOwnProperty(O) && zt[O] instanceof Th && zt[O].objectNumber >= 0 && ne("/" + O + " " + zt[O].objectNumber + " 0 R");
      K.publish("putShadingPatternDict"), ne(">>");
    }
  }, $i = function(O) {
    if (Object.keys(zt).length > 0) {
      for (var te in ne("/Pattern <<"), zt) zt.hasOwnProperty(te) && zt[te] instanceof P.TilingPattern && zt[te].objectNumber >= 0 && zt[te].objectNumber < O && ne("/" + te + " " + zt[te].objectNumber + " 0 R");
      K.publish("putTilingPatternDict"), ne(">>");
    }
  }, yr = function() {
    if (Object.keys(rr).length > 0) {
      var O;
      for (O in ne("/ExtGState <<"), rr) rr.hasOwnProperty(O) && rr[O].objectNumber >= 0 && ne("/" + O + " " + rr[O].objectNumber + " 0 R");
      K.publish("putGStateDict"), ne(">>");
    }
  }, Yn = function(O) {
    Xt(O.resourcesOid, !0), ne("<<"), ne("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), Er(), ao(), $i(O.objectOid), yr(), oo(), ne(">>"), ne("endobj");
  }, fi = function() {
    var O = [];
    fr(), Lr(), Yr(), Xi(O), K.publish("putResources"), O.forEach(Yn), Yn({ resourcesOid: en, objectOid: Number.MAX_SAFE_INTEGER }), K.publish("postPutResources");
  }, pr = function() {
    K.publish("putAdditionalObjects");
    for (var O = 0; O < St.length; O++) {
      var te = St[O];
      Xt(te.objId, !0), ne(te.content), ne("endobj");
    }
    K.publish("postPutAdditionalObjects");
  }, lo = function(O) {
    qn[O.fontName] = qn[O.fontName] || {}, qn[O.fontName][O.fontStyle] = O.id;
  }, pi = function(O, te, Ee, ze, Xe) {
    var lt = { id: "F" + (Object.keys(jt).length + 1).toString(10), postScriptName: O, fontName: te, fontStyle: Ee, encoding: ze, isStandardFont: Xe || !1, metadata: {} };
    return K.publish("addFont", { font: lt, instance: this }), jt[lt.id] = lt, lo(lt), lt.id;
  }, Zo = function(O) {
    for (var te = 0, Ee = dt.length; te < Ee; te++) {
      var ze = pi.call(this, O[te][0], O[te][1], O[te][2], dt[te][3], !0);
      T === !1 && (I[ze] = !0);
      var Xe = O[te][0].split("-");
      lo({ id: ze, fontName: Xe[0], fontStyle: Xe[1] || "" });
    }
    K.publish("addFonts", { fonts: jt, dictionary: qn });
  }, Tr = function(O) {
    return O.foo = function() {
      try {
        return O.apply(this, arguments);
      } catch (ze) {
        var te = ze.stack || "";
        ~te.indexOf(" at ") && (te = te.split(" at ")[1]);
        var Ee = "Error in function " + te.split(`
`)[0].split("<")[0] + ": " + ze.message;
        if (!Rn.console) throw new Error(Ee);
        Rn.console.error(Ee, ze), Rn.alert && alert(Ee);
      }
    }, O.foo.bar = O, O.foo;
  }, Zi = function(O, te) {
    var Ee, ze, Xe, lt, Pt, Wt, _n, Ln, kn;
    if (Xe = (te = te || {}).sourceEncoding || "Unicode", Pt = te.outputEncoding, (te.autoencode || Pt) && jt[xn].metadata && jt[xn].metadata[Xe] && jt[xn].metadata[Xe].encoding && (lt = jt[xn].metadata[Xe].encoding, !Pt && jt[xn].encoding && (Pt = jt[xn].encoding), !Pt && lt.codePages && (Pt = lt.codePages[0]), typeof Pt == "string" && (Pt = lt[Pt]), Pt)) {
      for (_n = !1, Wt = [], Ee = 0, ze = O.length; Ee < ze; Ee++) (Ln = Pt[O.charCodeAt(Ee)]) ? Wt.push(String.fromCharCode(Ln)) : Wt.push(O[Ee]), Wt[Ee].charCodeAt(0) >> 8 && (_n = !0);
      O = Wt.join("");
    }
    for (Ee = O.length; _n === void 0 && Ee !== 0; ) O.charCodeAt(Ee - 1) >> 8 && (_n = !0), Ee--;
    if (!_n) return O;
    for (Wt = te.noBOM ? [] : [254, 255], Ee = 0, ze = O.length; Ee < ze; Ee++) {
      if ((kn = (Ln = O.charCodeAt(Ee)) >> 8) >> 8) throw new Error("Character at position " + Ee + " of string '" + O + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Wt.push(kn), Wt.push(Ln - (kn << 8));
    }
    return String.fromCharCode.apply(void 0, Wt);
  }, gi = P.__private__.pdfEscape = P.pdfEscape = function(O, te) {
    return Zi(O, te).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, as = P.__private__.beginPage = function(O) {
    Lt[++be] = [], J[be] = { objId: 0, contentsObjId: 0, userUnit: Number(l), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(O[0]), topRightY: Number(O[1]) } }, Sa(be), at(Lt[Ae]);
  }, Ji = function(O, te) {
    var Ee, ze, Xe;
    switch (t = te || t, typeof O == "string" && (Ee = H(O.toLowerCase()), Array.isArray(Ee) && (ze = Ee[0], Xe = Ee[1])), Array.isArray(O) && (ze = O[0] * Ot, Xe = O[1] * Ot), isNaN(ze) && (ze = i[0], Xe = i[1]), (ze > 14400 || Xe > 14400) && ($r.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), ze = Math.min(14400, ze), Xe = Math.min(14400, Xe)), i = [ze, Xe], t.substr(0, 1)) {
      case "l":
        Xe > ze && (i = [Xe, ze]);
        break;
      case "p":
        ze > Xe && (i = [Xe, ze]);
    }
    as(i), hu(Qa), ne(fo), Nl !== 0 && ne(Nl + " J"), zl !== 0 && ne(zl + " j"), K.publish("addPage", { pageNumber: be });
  }, Xn = function(O) {
    O > 0 && O <= be && (Lt.splice(O, 1), J.splice(O, 1), be--, Ae > be && (Ae = be), this.setPage(Ae));
  }, Sa = function(O) {
    O > 0 && O <= be && (Ae = O);
  }, Ya = P.__private__.getNumberOfPages = P.getNumberOfPages = function() {
    return Lt.length - 1;
  }, ae = function(O, te, Ee) {
    var ze, Xe = void 0;
    return Ee = Ee || {}, O = O !== void 0 ? O : jt[xn].fontName, te = te !== void 0 ? te : jt[xn].fontStyle, ze = O.toLowerCase(), qn[ze] !== void 0 && qn[ze][te] !== void 0 ? Xe = qn[ze][te] : qn[O] !== void 0 && qn[O][te] !== void 0 ? Xe = qn[O][te] : Ee.disableWarning === !1 && $r.warn("Unable to look up font label for font '" + O + "', '" + te + "'. Refer to getFontList() for available fonts."), Xe || Ee.noFallback || (Xe = qn.times[te]) == null && (Xe = qn.times.normal), Xe;
  }, me = P.__private__.putInfo = function() {
    var O = We(), te = function(ze) {
      return ze;
    };
    for (var Ee in w !== null && (te = nr.encryptor(O, 0)), ne("<<"), ne("/Producer (" + gi(te("jsPDF " + Bn.version)) + ")"), un) un.hasOwnProperty(Ee) && un[Ee] && ne("/" + Ee.substr(0, 1).toUpperCase() + Ee.substr(1) + " (" + gi(te(un[Ee])) + ")");
    ne("/CreationDate (" + gi(te(et)) + ")"), ne(">>"), ne("endobj");
  }, De = P.__private__.putCatalog = function(O) {
    var te = (O = O || {}).rootDictionaryObjId || Mn;
    switch (We(), ne("<<"), ne("/Type /Catalog"), ne("/Pages " + te + " 0 R"), Bt || (Bt = "fullwidth"), Bt) {
      case "fullwidth":
        ne("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        ne("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        ne("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        ne("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var Ee = "" + Bt;
        Ee.substr(Ee.length - 1) === "%" && (Bt = parseInt(Bt) / 100), typeof Bt == "number" && ne("/OpenAction [3 0 R /XYZ null null " + ke(Bt) + "]");
    }
    switch (On || (On = "continuous"), On) {
      case "continuous":
        ne("/PageLayout /OneColumn");
        break;
      case "single":
        ne("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        ne("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        ne("/PageLayout /TwoColumnRight");
    }
    Sn && ne("/PageMode /" + Sn), K.publish("putCatalog"), ne(">>"), ne("endobj");
  }, nt = P.__private__.putTrailer = function() {
    ne("trailer"), ne("<<"), ne("/Size " + (qe + 1)), ne("/Root " + qe + " 0 R"), ne("/Info " + (qe - 1) + " 0 R"), w !== null && ne("/Encrypt " + nr.oid + " 0 R"), ne("/ID [ <" + rt + "> <" + rt + "> ]"), ne(">>");
  }, Tt = P.__private__.putHeader = function() {
    ne("%PDF-" + k), ne("%ºß¬à");
  }, Vt = P.__private__.putXRef = function() {
    var O = "0000000000";
    ne("xref"), ne("0 " + (qe + 1)), ne("0000000000 65535 f ");
    for (var te = 1; te <= qe; te++) typeof He[te] == "function" ? ne((O + He[te]()).slice(-10) + " 00000 n ") : He[te] !== void 0 ? ne((O + He[te]).slice(-10) + " 00000 n ") : ne("0000000000 00000 n ");
  }, Pn = P.__private__.buildDocument = function() {
    an(), at(Ye), K.publish("buildDocument"), Tt(), Fn(), pr(), fi(), w !== null && Mr(), me(), De();
    var O = Ze;
    return Vt(), nt(), ne("startxref"), ne("" + O), ne("%%EOF"), at(Lt[Ae]), Ye.join(`
`);
  }, Br = P.__private__.getBlob = function(O) {
    return new Blob([Qt(O)], { type: "application/pdf" });
  }, Rr = P.output = P.__private__.output = Tr(function(O, te) {
    switch (typeof (te = te || {}) == "string" ? te = { filename: te } : te.filename = te.filename || "generated.pdf", O) {
      case void 0:
        return Pn();
      case "save":
        P.save(te.filename);
        break;
      case "arraybuffer":
        return Qt(Pn());
      case "blob":
        return Br(Pn());
      case "bloburi":
      case "bloburl":
        if (Rn.URL !== void 0 && typeof Rn.URL.createObjectURL == "function") return Rn.URL && Rn.URL.createObjectURL(Br(Pn())) || void 0;
        $r.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var Ee = "", ze = Pn();
        try {
          Ee = t1(ze);
        } catch {
          Ee = t1(unescape(encodeURIComponent(ze)));
        }
        return "data:application/pdf;filename=" + te.filename + ";base64," + Ee;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Rn) === "[object Window]") {
          var Xe = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", lt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          te.pdfObjectUrl && (Xe = te.pdfObjectUrl, lt = "");
          var Pt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Xe + '"' + lt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(te) + ");<\/script></body></html>", Wt = Rn.open();
          return Wt !== null && Wt.document.write(Pt), Wt;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Rn) === "[object Window]") {
          var _n = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (te.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + te.filename + '" width="500px" height="400px" /></body></html>', Ln = Rn.open();
          if (Ln !== null) {
            Ln.document.write(_n);
            var kn = this;
            Ln.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Ln.document.title = te.filename, Ln.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(kn.output("bloburl"));
            };
          }
          return Ln;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Rn) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var Gn = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", te) + '"></iframe></body></html>', Or = Rn.open();
        if (Or !== null && (Or.document.write(Gn), Or.document.title = te.filename), Or || typeof safari > "u") return Or;
        break;
      case "datauri":
      case "dataurl":
        return Rn.document.location.href = this.output("datauristring", te);
      default:
        return null;
    }
  }), ui = function(O) {
    return Array.isArray(ce) === !0 && ce.indexOf(O) > -1;
  };
  switch (r) {
    case "pt":
      Ot = 1;
      break;
    case "mm":
      Ot = 72 / 25.4;
      break;
    case "cm":
      Ot = 72 / 2.54;
      break;
    case "in":
      Ot = 72;
      break;
    case "px":
      Ot = ui("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Ot = 12;
      break;
    case "ex":
      Ot = 6;
      break;
    default:
      if (typeof r != "number") throw new Error("Invalid unit: " + r);
      Ot = r;
  }
  var nr = null;
  Mt(), Je();
  var Ka = function(O) {
    return w !== null ? nr.encryptor(O, 0) : function(te) {
      return te;
    };
  }, Ii = P.__private__.getPageInfo = P.getPageInfo = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: J[O].objId, pageNumber: O, pageContext: J[O] };
  }, dn = P.__private__.getPageInfoByObjId = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var te in J) if (J[te].objId === O) break;
    return Ii(te);
  }, Ll = P.__private__.getCurrentPageInfo = P.getCurrentPageInfo = function() {
    return { objId: J[Ae].objId, pageNumber: Ae, pageContext: J[Ae] };
  };
  P.addPage = function() {
    return Ji.apply(this, arguments), this;
  }, P.setPage = function() {
    return Sa.apply(this, arguments), at.call(this, Lt[Ae]), this;
  }, P.insertPage = function(O) {
    return this.addPage(), this.movePage(Ae, O), this;
  }, P.movePage = function(O, te) {
    var Ee, ze;
    if (O > te) {
      Ee = Lt[O], ze = J[O];
      for (var Xe = O; Xe > te; Xe--) Lt[Xe] = Lt[Xe - 1], J[Xe] = J[Xe - 1];
      Lt[te] = Ee, J[te] = ze, this.setPage(te);
    } else if (O < te) {
      Ee = Lt[O], ze = J[O];
      for (var lt = O; lt < te; lt++) Lt[lt] = Lt[lt + 1], J[lt] = J[lt + 1];
      Lt[te] = Ee, J[te] = ze, this.setPage(te);
    }
    return this;
  }, P.deletePage = function() {
    return Xn.apply(this, arguments), this;
  }, P.__private__.text = P.text = function(O, te, Ee, ze, Xe) {
    var lt, Pt, Wt, _n, Ln, kn, Gn, Or, ri, Nn = (ze = ze || {}).scope || this;
    if (typeof O == "number" && typeof te == "number" && (typeof Ee == "string" || Array.isArray(Ee))) {
      var Di = Ee;
      Ee = te, te = O, O = Di;
    }
    if (arguments[3] instanceof Oe ? (_e("The transform parameter of text() with a Matrix value"), ri = Xe) : (Wt = arguments[4], _n = arguments[5], zr(Gn = arguments[3]) === "object" && Gn !== null || (typeof Wt == "string" && (_n = Wt, Wt = null), typeof Gn == "string" && (_n = Gn, Gn = null), typeof Gn == "number" && (Wt = Gn, Gn = null), ze = { flags: Gn, angle: Wt, align: _n })), isNaN(te) || isNaN(Ee) || O == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (O.length === 0) return Nn;
    var fn = "", ls = !1, $n = typeof ze.lineHeightFactor == "number" ? ze.lineHeightFactor : Yo, Kn = Nn.internal.scaleFactor;
    function Po(Cr) {
      return Cr = Cr.split("	").join(Array(ze.TabLen || 9).join(" ")), gi(Cr, Gn);
    }
    function Ko(Cr) {
      for (var br, jr = Cr.concat(), ii = [], As = jr.length; As--; ) typeof (br = jr.shift()) == "string" ? ii.push(br) : Array.isArray(Cr) && (br.length === 1 || br[1] === void 0 && br[2] === void 0) ? ii.push(br[0]) : ii.push([br[0], br[1], br[2]]);
      return ii;
    }
    function Qo(Cr, br) {
      var jr;
      if (typeof Cr == "string") jr = br(Cr)[0];
      else if (Array.isArray(Cr)) {
        for (var ii, As, Us = Cr.concat(), si = [], Ro = Us.length; Ro--; ) typeof (ii = Us.shift()) == "string" ? si.push(br(ii)[0]) : Array.isArray(ii) && typeof ii[0] == "string" && (As = br(ii[0], ii[1], ii[2]), si.push([As[0], As[1], As[2]]));
        jr = si;
      }
      return jr;
    }
    var Ca = !1, po = !0;
    if (typeof O == "string") Ca = !0;
    else if (Array.isArray(O)) {
      var Lo = O.concat();
      Pt = [];
      for (var Pi, Fi = Lo.length; Fi--; ) (typeof (Pi = Lo.shift()) != "string" || Array.isArray(Pi) && typeof Pi[0] != "string") && (po = !1);
      Ca = po;
    }
    if (Ca === !1) throw new Error('Type of text must be string or Array. "' + O + '" is not recognized.');
    typeof O == "string" && (O = O.match(/[\r?\n]/) ? O.split(/\r\n|\r|\n/g) : [O]);
    var Ia = Et / Nn.internal.scaleFactor, Pa = Ia * ($n - 1);
    switch (ze.baseline) {
      case "bottom":
        Ee -= Pa;
        break;
      case "top":
        Ee += Ia - Pa;
        break;
      case "hanging":
        Ee += Ia - 2 * Pa;
        break;
      case "middle":
        Ee += Ia / 2 - Pa;
    }
    if ((kn = ze.maxWidth || 0) > 0 && (typeof O == "string" ? O = Nn.splitTextToSize(O, kn) : Object.prototype.toString.call(O) === "[object Array]" && (O = O.reduce(function(Cr, br) {
      return Cr.concat(Nn.splitTextToSize(br, kn));
    }, []))), lt = { text: O, x: te, y: Ee, options: ze, mutex: { pdfEscape: gi, activeFontKey: xn, fonts: jt, activeFontSize: Et } }, K.publish("preProcessText", lt), O = lt.text, Wt = (ze = lt.options).angle, !(ri instanceof Oe) && Wt && typeof Wt == "number") {
      Wt *= Math.PI / 180, ze.rotationDirection === 0 && (Wt = -Wt), ie === $.ADVANCED && (Wt = -Wt);
      var Ds = Math.cos(Wt), ea = Math.sin(Wt);
      ri = new Oe(Ds, ea, -ea, Ds, 0, 0);
    } else Wt && Wt instanceof Oe && (ri = Wt);
    ie !== $.ADVANCED || ri || (ri = tt), (Ln = ze.charSpace || Ea) !== void 0 && (fn += Le(pe(Ln)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (Or = ze.horizontalScale) !== void 0 && (fn += Le(100 * Or) + ` Tz
`), ze.lang;
    var vi = -1, La = ze.renderingMode !== void 0 ? ze.renderingMode : ze.stroke, ta = Nn.internal.getCurrentPageInfo().pageContext;
    switch (La) {
      case 0:
      case !1:
      case "fill":
        vi = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        vi = 1;
        break;
      case 2:
      case "fillThenStroke":
        vi = 2;
        break;
      case 3:
      case "invisible":
        vi = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        vi = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        vi = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        vi = 6;
        break;
      case 7:
      case "addToPathForClipping":
        vi = 7;
    }
    var nl = ta.usedRenderingMode !== void 0 ? ta.usedRenderingMode : -1;
    vi !== -1 ? fn += vi + ` Tr
` : nl !== -1 && (fn += `0 Tr
`), vi !== -1 && (ta.usedRenderingMode = vi), _n = ze.align || "left";
    var ki, Mo = Et * $n, pu = Nn.internal.pageSize.getWidth(), Pc = jt[xn];
    Ln = ze.charSpace || Ea, kn = ze.maxWidth || 0, Gn = Object.assign({ autoencode: !0, noBOM: !0 }, ze.flags);
    var zn = [];
    if (Object.prototype.toString.call(O) === "[object Array]") {
      var Ki;
      Pt = Ko(O), _n !== "left" && (ki = Pt.map(function(Cr) {
        return Nn.getStringUnitWidth(Cr, { font: Pc, charSpace: Ln, fontSize: Et, doKerning: !1 }) * Et / Kn;
      }));
      var go, na = 0;
      if (_n === "right") {
        te -= ki[0], O = [], Fi = Pt.length;
        for (var Qi = 0; Qi < Fi; Qi++) Qi === 0 ? (go = jn(te), Ki = ho(Ee)) : (go = pe(na - ki[Qi]), Ki = -Mo), O.push([Pt[Qi], go, Ki]), na = ki[Qi];
      } else if (_n === "center") {
        te -= ki[0] / 2, O = [], Fi = Pt.length;
        for (var Bo = 0; Bo < Fi; Bo++) Bo === 0 ? (go = jn(te), Ki = ho(Ee)) : (go = pe((na - ki[Bo]) / 2), Ki = -Mo), O.push([Pt[Bo], go, Ki]), na = ki[Bo];
      } else if (_n === "left") {
        O = [], Fi = Pt.length;
        for (var ra = 0; ra < Fi; ra++) O.push(Pt[ra]);
      } else {
        if (_n !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        O = [], Fi = Pt.length, kn = kn !== 0 ? kn : pu;
        for (var Fs = 0; Fs < Fi; Fs++) Ki = Fs === 0 ? ho(Ee) : -Mo, go = Fs === 0 ? jn(te) : 0, Fs < Fi - 1 ? zn.push(Le(pe((kn - ki[Fs]) / (Pt[Fs].split(" ").length - 1)))) : zn.push(0), O.push([Pt[Fs], go, Ki]);
      }
    }
    var rl = typeof ze.R2L == "boolean" ? ze.R2L : nn;
    rl === !0 && (O = Qo(O, function(Cr, br, jr) {
      return [Cr.split("").reverse().join(""), br, jr];
    })), lt = { text: O, x: te, y: Ee, options: ze, mutex: { pdfEscape: gi, activeFontKey: xn, fonts: jt, activeFontSize: Et } }, K.publish("postProcessText", lt), O = lt.text, ls = lt.mutex.isHex || !1;
    var Ma = jt[xn].encoding;
    Ma !== "WinAnsiEncoding" && Ma !== "StandardEncoding" || (O = Qo(O, function(Cr, br, jr) {
      return [Po(Cr), br, jr];
    })), Pt = Ko(O), O = [];
    for (var mo, Ni, cs, ks = 0, Ba = 1, Ns = Array.isArray(Pt[0]) ? Ba : ks, zs = "", Ra = function(Cr, br, jr) {
      var ii = "";
      return jr instanceof Oe ? (jr = typeof ze.angle == "number" ? Ie(jr, new Oe(1, 0, 0, 1, Cr, br)) : Ie(new Oe(1, 0, 0, 1, Cr, br), jr), ie === $.ADVANCED && (jr = Ie(new Oe(1, 0, 0, -1, 0, 0), jr)), ii = jr.join(" ") + ` Tm
`) : ii = Le(Cr) + " " + Le(br) + ` Td
`, ii;
    }, es = 0; es < Pt.length; es++) {
      switch (zs = "", Ns) {
        case Ba:
          cs = (ls ? "<" : "(") + Pt[es][0] + (ls ? ">" : ")"), mo = parseFloat(Pt[es][1]), Ni = parseFloat(Pt[es][2]);
          break;
        case ks:
          cs = (ls ? "<" : "(") + Pt[es] + (ls ? ">" : ")"), mo = jn(te), Ni = ho(Ee);
      }
      zn !== void 0 && zn[es] !== void 0 && (zs = zn[es] + ` Tw
`), es === 0 ? O.push(zs + Ra(mo, Ni, ri) + cs) : Ns === ks ? O.push(zs + cs) : Ns === Ba && O.push(zs + Ra(mo, Ni, ri) + cs);
    }
    O = Ns === ks ? O.join(` Tj
T* `) : O.join(` Tj
`), O += ` Tj
`;
    var _o = `BT
/`;
    return _o += xn + " " + Et + ` Tf
`, _o += Le(Et * $n) + ` TL
`, _o += el + `
`, _o += fn, _o += O, ne(_o += "ET"), I[xn] = !0, Nn;
  };
  var Ml = P.__private__.clip = P.clip = function(O) {
    return ne(O === "evenodd" ? "W*" : "W"), this;
  };
  P.clipEvenOdd = function() {
    return Ml("evenodd");
  }, P.__private__.discardPath = P.discardPath = function() {
    return ne("n"), this;
  };
  var xs = P.__private__.isValidStyle = function(O) {
    var te = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(O) !== -1 && (te = !0), te;
  };
  P.__private__.setDefaultPathOperation = P.setDefaultPathOperation = function(O) {
    return xs(O) && (b = O), this;
  };
  var Sc = P.__private__.getStyle = P.getStyle = function(O) {
    var te = b;
    switch (O) {
      case "D":
      case "S":
        te = "S";
        break;
      case "F":
        te = "f";
        break;
      case "FD":
      case "DF":
        te = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        te = O;
    }
    return te;
  }, Jo = P.close = function() {
    return ne("h"), this;
  };
  P.stroke = function() {
    return ne("S"), this;
  }, P.fill = function(O) {
    return Bl("f", O), this;
  }, P.fillEvenOdd = function(O) {
    return Bl("f*", O), this;
  }, P.fillStroke = function(O) {
    return Bl("B", O), this;
  }, P.fillStrokeEvenOdd = function(O) {
    return Bl("B*", O), this;
  };
  var Bl = function(O, te) {
    zr(te) === "object" ? Zu(te, O) : ne(O);
  }, Rl = function(O) {
    O === null || ie === $.ADVANCED && O === void 0 || (O = Sc(O), ne(O));
  };
  function uu(O, te, Ee, ze, Xe) {
    var lt = new Od(te || this.boundingBox, Ee || this.xStep, ze || this.yStep, this.gState, Xe || this.matrix);
    lt.stream = this.stream;
    var Pt = O + "$$" + this.cloneIndex++ + "$$";
    return ut(Pt, lt), lt;
  }
  var Zu = function(O, te) {
    var Ee = yi[O.key], ze = zt[Ee];
    if (ze instanceof Th) ne("q"), ne(Ju(te)), ze.gState && P.setGState(ze.gState), ne(O.matrix.toString() + " cm"), ne("/" + Ee + " sh"), ne("Q");
    else if (ze instanceof Od) {
      var Xe = new Oe(1, 0, 0, -1, 0, Ta());
      O.matrix && (Xe = Xe.multiply(O.matrix || tt), Ee = uu.call(ze, O.key, O.boundingBox, O.xStep, O.yStep, Xe).id), ne("q"), ne("/Pattern cs"), ne("/" + Ee + " scn"), ze.gState && P.setGState(ze.gState), ne(te), ne("Q");
    }
  }, Ju = function(O) {
    switch (O) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Ol = P.moveTo = function(O, te) {
    return ne(Le(pe(O)) + " " + Le(xe(te)) + " m"), this;
  }, co = P.lineTo = function(O, te) {
    return ne(Le(pe(O)) + " " + Le(xe(te)) + " l"), this;
  }, To = P.curveTo = function(O, te, Ee, ze, Xe, lt) {
    return ne([Le(pe(O)), Le(xe(te)), Le(pe(Ee)), Le(xe(ze)), Le(pe(Xe)), Le(xe(lt)), "c"].join(" ")), this;
  };
  P.__private__.line = P.line = function(O, te, Ee, ze, Xe) {
    if (isNaN(O) || isNaN(te) || isNaN(Ee) || isNaN(ze) || !xs(Xe)) throw new Error("Invalid arguments passed to jsPDF.line");
    return ie === $.COMPAT ? this.lines([[Ee - O, ze - te]], O, te, [1, 1], Xe || "S") : this.lines([[Ee - O, ze - te]], O, te, [1, 1]).stroke();
  }, P.__private__.lines = P.lines = function(O, te, Ee, ze, Xe, lt) {
    var Pt, Wt, _n, Ln, kn, Gn, Or, ri, Nn, Di, fn, ls;
    if (typeof O == "number" && (ls = Ee, Ee = te, te = O, O = ls), ze = ze || [1, 1], lt = lt || !1, isNaN(te) || isNaN(Ee) || !Array.isArray(O) || !Array.isArray(ze) || !xs(Xe) || typeof lt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Ol(te, Ee), Pt = ze[0], Wt = ze[1], Ln = O.length, Di = te, fn = Ee, _n = 0; _n < Ln; _n++) (kn = O[_n]).length === 2 ? (Di = kn[0] * Pt + Di, fn = kn[1] * Wt + fn, co(Di, fn)) : (Gn = kn[0] * Pt + Di, Or = kn[1] * Wt + fn, ri = kn[2] * Pt + Di, Nn = kn[3] * Wt + fn, Di = kn[4] * Pt + Di, fn = kn[5] * Wt + fn, To(Gn, Or, ri, Nn, Di, fn));
    return lt && Jo(), Rl(Xe), this;
  }, P.path = function(O) {
    for (var te = 0; te < O.length; te++) {
      var Ee = O[te], ze = Ee.c;
      switch (Ee.op) {
        case "m":
          Ol(ze[0], ze[1]);
          break;
        case "l":
          co(ze[0], ze[1]);
          break;
        case "c":
          To.apply(this, ze);
          break;
        case "h":
          Jo();
      }
    }
    return this;
  }, P.__private__.rect = P.rect = function(O, te, Ee, ze, Xe) {
    if (isNaN(O) || isNaN(te) || isNaN(Ee) || isNaN(ze) || !xs(Xe)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return ie === $.COMPAT && (ze = -ze), ne([Le(pe(O)), Le(xe(te)), Le(pe(Ee)), Le(pe(ze)), "re"].join(" ")), Rl(Xe), this;
  }, P.__private__.triangle = P.triangle = function(O, te, Ee, ze, Xe, lt, Pt) {
    if (isNaN(O) || isNaN(te) || isNaN(Ee) || isNaN(ze) || isNaN(Xe) || isNaN(lt) || !xs(Pt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[Ee - O, ze - te], [Xe - Ee, lt - ze], [O - Xe, te - lt]], O, te, [1, 1], Pt, !0), this;
  }, P.__private__.roundedRect = P.roundedRect = function(O, te, Ee, ze, Xe, lt, Pt) {
    if (isNaN(O) || isNaN(te) || isNaN(Ee) || isNaN(ze) || isNaN(Xe) || isNaN(lt) || !xs(Pt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Wt = 4 / 3 * (Math.SQRT2 - 1);
    return Xe = Math.min(Xe, 0.5 * Ee), lt = Math.min(lt, 0.5 * ze), this.lines([[Ee - 2 * Xe, 0], [Xe * Wt, 0, Xe, lt - lt * Wt, Xe, lt], [0, ze - 2 * lt], [0, lt * Wt, -Xe * Wt, lt, -Xe, lt], [2 * Xe - Ee, 0], [-Xe * Wt, 0, -Xe, -lt * Wt, -Xe, -lt], [0, 2 * lt - ze], [0, -lt * Wt, Xe * Wt, -lt, Xe, -lt]], O + Xe, te, [1, 1], Pt, !0), this;
  }, P.__private__.ellipse = P.ellipse = function(O, te, Ee, ze, Xe) {
    if (isNaN(O) || isNaN(te) || isNaN(Ee) || isNaN(ze) || !xs(Xe)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var lt = 4 / 3 * (Math.SQRT2 - 1) * Ee, Pt = 4 / 3 * (Math.SQRT2 - 1) * ze;
    return Ol(O + Ee, te), To(O + Ee, te - Pt, O + lt, te - ze, O, te - ze), To(O - lt, te - ze, O - Ee, te - Pt, O - Ee, te), To(O - Ee, te + Pt, O - lt, te + ze, O, te + ze), To(O + lt, te + ze, O + Ee, te + Pt, O + Ee, te), Rl(Xe), this;
  }, P.__private__.circle = P.circle = function(O, te, Ee, ze) {
    if (isNaN(O) || isNaN(te) || isNaN(Ee) || !xs(ze)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(O, te, Ee, Ee, ze);
  }, P.setFont = function(O, te, Ee) {
    return Ee && (te = Re(te, Ee)), xn = ae(O, te, { disableWarning: !1 }), this;
  };
  var Dl = P.__private__.getFont = P.getFont = function() {
    return jt[ae.apply(P, arguments)];
  };
  P.__private__.getFontList = P.getFontList = function() {
    var O, te, Ee = {};
    for (O in qn) if (qn.hasOwnProperty(O)) for (te in Ee[O] = [], qn[O]) qn[O].hasOwnProperty(te) && Ee[O].push(te);
    return Ee;
  }, P.addFont = function(O, te, Ee, ze, Xe) {
    var lt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && lt.indexOf(arguments[3]) !== -1 ? Xe = arguments[3] : arguments[3] && lt.indexOf(arguments[3]) == -1 && (Ee = Re(Ee, ze)), Xe = Xe || "Identity-H", pi.call(this, O, te, Ee, Xe);
  };
  var Yo, Qa = n.lineWidth || 0.200025, Yi = P.__private__.getLineWidth = P.getLineWidth = function() {
    return Qa;
  }, hu = P.__private__.setLineWidth = P.setLineWidth = function(O) {
    return Qa = O, ne(Le(pe(O)) + " w"), this;
  };
  P.__private__.setLineDash = Bn.API.setLineDash = Bn.API.setLineDashPattern = function(O, te) {
    if (O = O || [], te = te || 0, isNaN(te) || !Array.isArray(O)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return O = O.map(function(Ee) {
      return Le(pe(Ee));
    }).join(" "), te = Le(pe(te)), ne("[" + O + "] " + te + " d"), this;
  };
  var Fl = P.__private__.getLineHeight = P.getLineHeight = function() {
    return Et * Yo;
  };
  P.__private__.getLineHeight = P.getLineHeight = function() {
    return Et * Yo;
  };
  var Co = P.__private__.setLineHeightFactor = P.setLineHeightFactor = function(O) {
    return typeof (O = O || 1.15) == "number" && (Yo = O), this;
  }, uo = P.__private__.getLineHeightFactor = P.getLineHeightFactor = function() {
    return Yo;
  };
  Co(n.lineHeight);
  var jn = P.__private__.getHorizontalCoordinate = function(O) {
    return pe(O);
  }, ho = P.__private__.getVerticalCoordinate = function(O) {
    return ie === $.ADVANCED ? O : J[Ae].mediaBox.topRightY - J[Ae].mediaBox.bottomLeftY - pe(O);
  }, Yu = P.__private__.getHorizontalCoordinateString = P.getHorizontalCoordinateString = function(O) {
    return Le(jn(O));
  }, ws = P.__private__.getVerticalCoordinateString = P.getVerticalCoordinateString = function(O) {
    return Le(ho(O));
  }, fo = n.strokeColor || "0 G";
  P.__private__.getStrokeColor = P.getDrawColor = function() {
    return In(fo);
  }, P.__private__.setStrokeColor = P.setDrawColor = function(O, te, Ee, ze) {
    return fo = wn({ ch1: O, ch2: te, ch3: Ee, ch4: ze, pdfColorType: "draw", precision: 2 }), ne(fo), this;
  };
  var kl = n.fillColor || "0 g";
  P.__private__.getFillColor = P.getFillColor = function() {
    return In(kl);
  }, P.__private__.setFillColor = P.setFillColor = function(O, te, Ee, ze) {
    return kl = wn({ ch1: O, ch2: te, ch3: Ee, ch4: ze, pdfColorType: "fill", precision: 2 }), ne(kl), this;
  };
  var el = n.textColor || "0 g", du = P.__private__.getTextColor = P.getTextColor = function() {
    return In(el);
  };
  P.__private__.setTextColor = P.setTextColor = function(O, te, Ee, ze) {
    return el = wn({ ch1: O, ch2: te, ch3: Ee, ch4: ze, pdfColorType: "text", precision: 3 }), this;
  };
  var Ea = n.charSpace, fu = P.__private__.getCharSpace = P.getCharSpace = function() {
    return parseFloat(Ea || 0);
  };
  P.__private__.setCharSpace = P.setCharSpace = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Ea = O, this;
  };
  var Nl = 0;
  P.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, P.__private__.setLineCap = P.setLineCap = function(O) {
    var te = P.CapJoinStyles[O];
    if (te === void 0) throw new Error("Line cap style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Nl = te, ne(te + " J"), this;
  };
  var zl = 0;
  P.__private__.setLineJoin = P.setLineJoin = function(O) {
    var te = P.CapJoinStyles[O];
    if (te === void 0) throw new Error("Line join style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return zl = te, ne(te + " j"), this;
  }, P.__private__.setLineMiterLimit = P.__private__.setMiterLimit = P.setLineMiterLimit = P.setMiterLimit = function(O) {
    if (O = O || 0, isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return ne(Le(pe(O)) + " M"), this;
  }, P.GState = Lm, P.setGState = function(O) {
    (O = typeof O == "string" ? rr[ti[O]] : Ec(null, O)).equals(ni) || (ne("/" + O.id + " gs"), ni = O);
  };
  var Ec = function(O, te) {
    if (!O || !ti[O]) {
      var Ee = !1;
      for (var ze in rr) if (rr.hasOwnProperty(ze) && rr[ze].equals(te)) {
        Ee = !0;
        break;
      }
      if (Ee) te = rr[ze];
      else {
        var Xe = "GS" + (Object.keys(rr).length + 1).toString(10);
        rr[Xe] = te, te.id = Xe;
      }
      return O && (ti[O] = te.id), K.publish("addGState", te), te;
    }
  };
  P.addGState = function(O, te) {
    return Ec(O, te), this;
  }, P.saveGraphicsState = function() {
    return ne("q"), Jr.push({ key: xn, size: Et, color: el }), this;
  }, P.restoreGraphicsState = function() {
    ne("Q");
    var O = Jr.pop();
    return xn = O.key, Et = O.size, el = O.color, ni = null, this;
  }, P.setCurrentTransformationMatrix = function(O) {
    return ne(O.toString() + " cm"), this;
  }, P.comment = function(O) {
    return ne("#" + O), this;
  };
  var Os = function(O, te) {
    var Ee = O || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return Ee;
    }, set: function(lt) {
      isNaN(lt) || (Ee = parseFloat(lt));
    } });
    var ze = te || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return ze;
    }, set: function(lt) {
      isNaN(lt) || (ze = parseFloat(lt));
    } });
    var Xe = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Xe;
    }, set: function(lt) {
      Xe = lt.toString();
    } }), this;
  }, Ul = function(O, te, Ee, ze) {
    Os.call(this, O, te), this.type = "rect";
    var Xe = Ee || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Xe;
    }, set: function(Pt) {
      isNaN(Pt) || (Xe = parseFloat(Pt));
    } });
    var lt = ze || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return lt;
    }, set: function(Pt) {
      isNaN(Pt) || (lt = parseFloat(Pt));
    } }), this;
  }, Tc = function() {
    this.page = be, this.currentPage = Ae, this.pages = Lt.slice(0), this.pagesContext = J.slice(0), this.x = _r, this.y = mt, this.matrix = bn, this.width = Io(Ae), this.height = Ta(Ae), this.outputDestination = Nt, this.id = "", this.objectNumber = -1;
  };
  Tc.prototype.restore = function() {
    be = this.page, Ae = this.currentPage, J = this.pagesContext, Lt = this.pages, _r = this.x, mt = this.y, bn = this.matrix, Ic(Ae, this.width), Gl(Ae, this.height), Nt = this.outputDestination;
  };
  var Cc = function(O, te, Ee, ze, Xe) {
    je.push(new Tc()), be = Ae = 0, Lt = [], _r = O, mt = te, bn = Xe, as([Ee, ze]);
  }, tl = function(O) {
    if (Fe[O]) je.pop().restore();
    else {
      var te = new Tc(), Ee = "Xo" + (Object.keys(ye).length + 1).toString(10);
      te.id = Ee, Fe[O] = Ee, ye[Ee] = te, K.publish("addFormObject", te), je.pop().restore();
    }
  };
  for (var jl in P.beginFormObject = function(O, te, Ee, ze, Xe) {
    return Cc(O, te, Ee, ze, Xe), this;
  }, P.endFormObject = function(O) {
    return tl(O), this;
  }, P.doFormObject = function(O, te) {
    var Ee = ye[Fe[O]];
    return ne("q"), ne(te.toString() + " cm"), ne("/" + Ee.id + " Do"), ne("Q"), this;
  }, P.getFormObject = function(O) {
    var te = ye[Fe[O]];
    return { x: te.x, y: te.y, width: te.width, height: te.height, matrix: te.matrix };
  }, P.save = function(O, te) {
    return O = O || "generated.pdf", (te = te || {}).returnPromise = te.returnPromise || !1, te.returnPromise === !1 ? (Ah(Br(Pn()), O), typeof Ah.unload == "function" && Rn.setTimeout && setTimeout(Ah.unload, 911), this) : new Promise(function(Ee, ze) {
      try {
        var Xe = Ah(Br(Pn()), O);
        typeof Ah.unload == "function" && Rn.setTimeout && setTimeout(Ah.unload, 911), Ee(Xe);
      } catch (lt) {
        ze(lt.message);
      }
    });
  }, Bn.API) Bn.API.hasOwnProperty(jl) && (jl === "events" && Bn.API.events.length ? function(O, te) {
    var Ee, ze, Xe;
    for (Xe = te.length - 1; Xe !== -1; Xe--) Ee = te[Xe][0], ze = te[Xe][1], O.subscribe.apply(O, [Ee].concat(typeof ze == "function" ? [ze] : ze));
  }(K, Bn.API.events) : P[jl] = Bn.API[jl]);
  var Io = P.getPageWidth = function(O) {
    return (J[O = O || Ae].mediaBox.topRightX - J[O].mediaBox.bottomLeftX) / Ot;
  }, Ic = P.setPageWidth = function(O, te) {
    J[O].mediaBox.topRightX = te * Ot + J[O].mediaBox.bottomLeftX;
  }, Ta = P.getPageHeight = function(O) {
    return (J[O = O || Ae].mediaBox.topRightY - J[O].mediaBox.bottomLeftY) / Ot;
  }, Gl = P.setPageHeight = function(O, te) {
    J[O].mediaBox.topRightY = te * Ot + J[O].mediaBox.bottomLeftY;
  };
  return P.internal = { pdfEscape: gi, getStyle: Sc, getFont: Dl, getFontSize: Ft, getCharSpace: fu, getTextColor: du, getLineHeight: Fl, getLineHeightFactor: uo, getLineWidth: Yi, write: pn, getHorizontalCoordinate: jn, getVerticalCoordinate: ho, getCoordinateString: Yu, getVerticalCoordinateString: ws, collections: {}, newObject: We, newAdditionalObject: Kt, newObjectDeferred: vt, newObjectDeferredBegin: Xt, getFilters: ir, putStream: Wn, events: K, scaleFactor: Ot, pageSize: { getWidth: function() {
    return Io(Ae);
  }, setWidth: function(O) {
    Ic(Ae, O);
  }, getHeight: function() {
    return Ta(Ae);
  }, setHeight: function(O) {
    Gl(Ae, O);
  } }, encryptionOptions: w, encryption: nr, getEncryptor: Ka, output: Rr, getNumberOfPages: Ya, pages: Lt, out: ne, f2: ke, f3: oe, getPageInfo: Ii, getPageInfoByObjId: dn, getCurrentPageInfo: Ll, getPDFVersion: U, Point: Os, Rectangle: Ul, Matrix: Oe, hasHotfix: ui }, Object.defineProperty(P.internal.pageSize, "width", { get: function() {
    return Io(Ae);
  }, set: function(O) {
    Ic(Ae, O);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(P.internal.pageSize, "height", { get: function() {
    return Ta(Ae);
  }, set: function(O) {
    Gl(Ae, O);
  }, enumerable: !0, configurable: !0 }), Zo.call(P, dt), xn = "F1", Ji(i, t), K.publish("initialized"), P;
}
Cd.prototype.lsbFirstWord = function(n) {
  return String.fromCharCode(n >> 0 & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255);
}, Cd.prototype.toHexString = function(n) {
  return n.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Cd.prototype.hexToBytes = function(n) {
  for (var e = [], t = 0; t < n.length; t += 2) e.push(String.fromCharCode(parseInt(n.substr(t, 2), 16)));
  return e.join("");
}, Cd.prototype.processOwnerPassword = function(n, e) {
  return r1(n1(e).substr(0, 5), n);
}, Cd.prototype.encryptor = function(n, e) {
  var t = n1(this.encryptionKey + String.fromCharCode(255 & n, n >> 8 & 255, n >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(r) {
    return r1(t, r);
  };
}, Lm.prototype.equals = function(n) {
  var e, t = "id,objectNumber,equals";
  if (!n || zr(n) !== zr(this)) return !1;
  var r = 0;
  for (e in this) if (!(t.indexOf(e) >= 0)) {
    if (this.hasOwnProperty(e) && !n.hasOwnProperty(e) || this[e] !== n[e]) return !1;
    r++;
  }
  for (e in n) n.hasOwnProperty(e) && t.indexOf(e) < 0 && r--;
  return r === 0;
}, Bn.API = { events: [] }, Bn.version = "2.5.1";
var Ti = Bn.API, Rb = 1, Hh = function(n) {
  return n.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Ad = function(n) {
  return n.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Vn = function(n) {
  return n.toFixed(2);
}, ku = function(n) {
  return n.toFixed(5);
};
Ti.__acroform__ = {};
var Xo = function(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n;
}, GA = function(n) {
  return n * Rb;
}, pc = function(n) {
  var e = new LT(), t = cn.internal.getHeight(n) || 0, r = cn.internal.getWidth(n) || 0;
  return e.BBox = [0, 0, Number(Vn(r)), Number(Vn(t))], e;
}, uV = Ti.__acroform__.setBit = function(n, e) {
  if (n = n || 0, e = e || 0, isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return n |= 1 << e;
}, hV = Ti.__acroform__.clearBit = function(n, e) {
  if (n = n || 0, e = e || 0, isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return n &= ~(1 << e);
}, dV = Ti.__acroform__.getBit = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return n & 1 << e ? 1 : 0;
}, Bi = Ti.__acroform__.getBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return dV(n, e - 1);
}, Ri = Ti.__acroform__.setBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return uV(n, e - 1);
}, Oi = Ti.__acroform__.clearBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return hV(n, e - 1);
}, fV = Ti.__acroform__.calculateCoordinates = function(n, e) {
  var t = e.internal.getHorizontalCoordinate, r = e.internal.getVerticalCoordinate, i = n[0], o = n[1], c = n[2], l = n[3], _ = {};
  return _.lowerLeft_X = t(i) || 0, _.lowerLeft_Y = r(o + l) || 0, _.upperRight_X = t(i + c) || 0, _.upperRight_Y = r(o) || 0, [Number(Vn(_.lowerLeft_X)), Number(Vn(_.lowerLeft_Y)), Number(Vn(_.upperRight_X)), Number(Vn(_.upperRight_Y))];
}, pV = function(n) {
  if (n.appearanceStreamContent) return n.appearanceStreamContent;
  if (n.V || n.DV) {
    var e = [], t = n._V || n.DV, r = i1(n, t), i = n.scope.internal.getFont(n.fontName, n.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(n.scope.__private__.encodeColorString(n.color)), e.push("/" + i + " " + Vn(r.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(r.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var o = pc(n);
    return o.scope = n.scope, o.stream = e.join(`
`), o;
  }
}, i1 = function(n, e) {
  var t = n.fontSize === 0 ? n.maxFontSize : n.fontSize, r = { text: "", fontSize: "" }, i = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  i = n.multiline ? i.map(function(oe) {
    return oe.split(`
`);
  }) : i.map(function(oe) {
    return [oe];
  });
  var o = t, c = cn.internal.getHeight(n) || 0;
  c = c < 0 ? -c : c;
  var l = cn.internal.getWidth(n) || 0;
  l = l < 0 ? -l : l;
  var _ = function(oe, pe, Te) {
    if (oe + 1 < i.length) {
      var xe = pe + " " + i[oe + 1][0];
      return Ug(xe, n, Te).width <= l - 4;
    }
    return !1;
  };
  o++;
  e: for (; o > 0; ) {
    e = "", o--;
    var b, w, T = Ug("3", n, o).height, I = n.multiline ? c - o : (c - T) / 2, P = I += 2, k = 0, U = 0, G = 0;
    if (o <= 0) {
      e = `(...) Tj
`, e += "% Width of Text: " + Ug(e, n, o = 12).width + ", FieldWidth:" + l + `
`;
      break;
    }
    for (var H = "", $ = 0, ie = 0; ie < i.length; ie++) if (i.hasOwnProperty(ie)) {
      var ge = !1;
      if (i[ie].length !== 1 && G !== i[ie].length - 1) {
        if ((T + 2) * ($ + 2) + 2 > c) continue e;
        H += i[ie][G], ge = !0, U = ie, ie--;
      } else {
        H = (H += i[ie][G] + " ").substr(H.length - 1) == " " ? H.substr(0, H.length - 1) : H;
        var Se = parseInt(ie), Re = _(Se, H, o), Le = ie >= i.length - 1;
        if (Re && !Le) {
          H += " ", G = 0;
          continue;
        }
        if (Re || Le) {
          if (Le) U = Se;
          else if (n.multiline && (T + 2) * ($ + 2) + 2 > c) continue e;
        } else {
          if (!n.multiline || (T + 2) * ($ + 2) + 2 > c) continue e;
          U = Se;
        }
      }
      for (var _e = "", Ge = k; Ge <= U; Ge++) {
        var ke = i[Ge];
        if (n.multiline) {
          if (Ge === U) {
            _e += ke[G] + " ", G = (G + 1) % ke.length;
            continue;
          }
          if (Ge === k) {
            _e += ke[ke.length - 1] + " ";
            continue;
          }
        }
        _e += ke[0] + " ";
      }
      switch (_e = _e.substr(_e.length - 1) == " " ? _e.substr(0, _e.length - 1) : _e, w = Ug(_e, n, o).width, n.textAlign) {
        case "right":
          b = l - w - 2;
          break;
        case "center":
          b = (l - w) / 2;
          break;
        case "left":
        default:
          b = 2;
      }
      e += Vn(b) + " " + Vn(P) + ` Td
`, e += "(" + Hh(_e) + `) Tj
`, e += -Vn(b) + ` 0 Td
`, P = -(o + 2), w = 0, k = ge ? U : U + 1, $++, H = "";
    }
    break;
  }
  return r.text = e, r.fontSize = o, r;
}, Ug = function(n, e, t) {
  var r = e.scope.internal.getFont(e.fontName, e.fontStyle), i = e.scope.getStringUnitWidth(n, { font: r, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: r, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: i };
}, gV = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, mV = function(n, e) {
  var t = { type: "reference", object: n };
  e.internal.getPageInfo(n.page).pageContext.annotations.find(function(r) {
    return r.type === t.type && r.object === t.object;
  }) === void 0 && e.internal.getPageInfo(n.page).pageContext.annotations.push(t);
}, _V = function(n, e) {
  for (var t in n) if (n.hasOwnProperty(t)) {
    var r = t, i = n[t];
    e.internal.newObjectDeferredBegin(i.objId, !0), zr(i) === "object" && typeof i.putStream == "function" && i.putStream(), delete n[r];
  }
}, yV = function(n, e) {
  if (e.scope = n, n.internal !== void 0 && (n.internal.acroformPlugin === void 0 || n.internal.acroformPlugin.isInitialized === !1)) {
    if (Cl.FieldNum = 0, n.internal.acroformPlugin = JSON.parse(JSON.stringify(gV)), n.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    Rb = n.internal.scaleFactor, n.internal.acroformPlugin.acroFormDictionaryRoot = new MT(), n.internal.acroformPlugin.acroFormDictionaryRoot.scope = n, n.internal.acroformPlugin.acroFormDictionaryRoot._eventID = n.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(n);
    }), n.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var r = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var i in r) if (r.hasOwnProperty(i)) {
          var o = r[i];
          o.objId = void 0, o.hasAnnotation && mV(o, t);
        }
      })(n);
    }), n.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(n);
    }), n.internal.events.subscribe("postPutPages", function(t) {
      (function(r, i) {
        var o = !r;
        for (var c in r || (i.internal.newObjectDeferredBegin(i.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), i.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), r = r || i.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (r.hasOwnProperty(c)) {
          var l = r[c], _ = [], b = l.Rect;
          if (l.Rect && (l.Rect = fV(l.Rect, i)), i.internal.newObjectDeferredBegin(l.objId, !0), l.DA = cn.createDefaultAppearanceStream(l), zr(l) === "object" && typeof l.getKeyValueListForStream == "function" && (_ = l.getKeyValueListForStream()), l.Rect = b, l.hasAppearanceStream && !l.appearanceStreamContent) {
            var w = pV(l);
            _.push({ key: "AP", value: "<</N " + w + ">>" }), i.internal.acroformPlugin.xForms.push(w);
          }
          if (l.appearanceStreamContent) {
            var T = "";
            for (var I in l.appearanceStreamContent) if (l.appearanceStreamContent.hasOwnProperty(I)) {
              var P = l.appearanceStreamContent[I];
              if (T += "/" + I + " ", T += "<<", Object.keys(P).length >= 1 || Array.isArray(P)) {
                for (var c in P) if (P.hasOwnProperty(c)) {
                  var k = P[c];
                  typeof k == "function" && (k = k.call(i, l)), T += "/" + c + " " + k + " ", i.internal.acroformPlugin.xForms.indexOf(k) >= 0 || i.internal.acroformPlugin.xForms.push(k);
                }
              } else typeof (k = P) == "function" && (k = k.call(i, l)), T += "/" + c + " " + k, i.internal.acroformPlugin.xForms.indexOf(k) >= 0 || i.internal.acroformPlugin.xForms.push(k);
              T += ">>";
            }
            _.push({ key: "AP", value: `<<
` + T + ">>" });
          }
          i.internal.putStream({ additionalKeyValues: _, objectId: l.objId }), i.internal.out("endobj");
        }
        o && _V(i.internal.acroformPlugin.xForms, i);
      })(t, n);
    }), n.internal.acroformPlugin.isInitialized = !0;
  }
}, PT = Ti.__acroform__.arrayToPdfArray = function(n, e, t) {
  var r = function(c) {
    return c;
  };
  if (Array.isArray(n)) {
    for (var i = "[", o = 0; o < n.length; o++) switch (o !== 0 && (i += " "), zr(n[o])) {
      case "boolean":
      case "number":
      case "object":
        i += n[o].toString();
        break;
      case "string":
        n[o].substr(0, 1) !== "/" ? (e !== void 0 && t && (r = t.internal.getEncryptor(e)), i += "(" + Hh(r(n[o].toString())) + ")") : i += n[o].toString();
    }
    return i += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Z_ = function(n, e, t) {
  var r = function(i) {
    return i;
  };
  return e !== void 0 && t && (r = t.internal.getEncryptor(e)), (n = n || "").toString(), n = "(" + Hh(r(n)) + ")";
}, vc = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(n) {
    this._objId = n;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
vc.prototype.toString = function() {
  return this.objId + " 0 R";
}, vc.prototype.putStream = function() {
  var n = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: n, objectId: this.objId }), this.scope.internal.out("endobj");
}, vc.prototype.getKeyValueListForStream = function() {
  var n = [], e = Object.getOwnPropertyNames(this).filter(function(o) {
    return o != "content" && o != "appearanceStreamContent" && o != "scope" && o != "objId" && o.substring(0, 1) != "_";
  });
  for (var t in e) if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
    var r = e[t], i = this[r];
    i && (Array.isArray(i) ? n.push({ key: r, value: PT(i, this.objId, this.scope) }) : i instanceof vc ? (i.scope = this.scope, n.push({ key: r, value: i.objId + " 0 R" })) : typeof i != "function" && n.push({ key: r, value: i }));
  }
  return n;
};
var LT = function() {
  vc.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var n, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    n = t.trim();
  }, get: function() {
    return n || null;
  } });
};
Xo(LT, vc);
var MT = function() {
  vc.call(this);
  var n, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (n) {
      var t = function(r) {
        return r;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + Hh(t(n)) + ")";
    }
  }, set: function(t) {
    n = t;
  } });
};
Xo(MT, vc);
var Cl = function n() {
  vc.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(H) {
    if (isNaN(H)) throw new Error('Invalid value "' + H + '" for attribute F supplied.');
    e = H;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(e, 3);
  }, set: function(H) {
    H ? this.F = Ri(e, 3) : this.F = Oi(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(H) {
    if (isNaN(H)) throw new Error('Invalid value "' + H + '" for attribute Ff supplied.');
    t = H;
  } });
  var r = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (r.length !== 0) return r;
  }, set: function(H) {
    r = H !== void 0 ? H : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[0]) ? 0 : r[0];
  }, set: function(H) {
    r[0] = H;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[1]) ? 0 : r[1];
  }, set: function(H) {
    r[1] = H;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[2]) ? 0 : r[2];
  }, set: function(H) {
    r[2] = H;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[3]) ? 0 : r[3];
  }, set: function(H) {
    r[3] = H;
  } });
  var i = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(H) {
    switch (H) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i = H;
        break;
      default:
        throw new Error('Invalid value "' + H + '" for attribute FT supplied.');
    }
  } });
  var o = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!o || o.length < 1) {
      if (this instanceof Mm) return;
      o = "FieldObject" + n.FieldNum++;
    }
    var H = function($) {
      return $;
    };
    return this.scope && (H = this.scope.internal.getEncryptor(this.objId)), "(" + Hh(H(o)) + ")";
  }, set: function(H) {
    o = H.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return o;
  }, set: function(H) {
    o = H;
  } });
  var c = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return c;
  }, set: function(H) {
    c = H;
  } });
  var l = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(H) {
    l = H;
  } });
  var _ = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return _;
  }, set: function(H) {
    _ = H;
  } });
  var b = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return b === void 0 ? 50 / Rb : b;
  }, set: function(H) {
    b = H;
  } });
  var w = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return w;
  }, set: function(H) {
    w = H;
  } });
  var T = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!T || this instanceof Mm || this instanceof Oh)) return Z_(T, this.objId, this.scope);
  }, set: function(H) {
    H = H.toString(), T = H;
  } });
  var I = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (I) return this instanceof ys ? I : Z_(I, this.objId, this.scope);
  }, set: function(H) {
    H = H.toString(), I = this instanceof ys ? H : H.substr(0, 1) === "(" ? Ad(H.substr(1, H.length - 2)) : Ad(H);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ys ? Ad(I.substr(1, I.length - 1)) : I;
  }, set: function(H) {
    H = H.toString(), I = this instanceof ys ? "/" + H : H;
  } });
  var P = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (P) return P;
  }, set: function(H) {
    this.V = H;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (P) return this instanceof ys ? P : Z_(P, this.objId, this.scope);
  }, set: function(H) {
    H = H.toString(), P = this instanceof ys ? H : H.substr(0, 1) === "(" ? Ad(H.substr(1, H.length - 2)) : Ad(H);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ys ? Ad(P.substr(1, P.length - 1)) : P;
  }, set: function(H) {
    H = H.toString(), P = this instanceof ys ? "/" + H : H;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var k, U = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return U;
  }, set: function(H) {
    H = !!H, U = H;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (k) return k;
  }, set: function(H) {
    k = H;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 1);
  }, set: function(H) {
    H ? this.Ff = Ri(this.Ff, 1) : this.Ff = Oi(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 2);
  }, set: function(H) {
    H ? this.Ff = Ri(this.Ff, 2) : this.Ff = Oi(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 3);
  }, set: function(H) {
    H ? this.Ff = Ri(this.Ff, 3) : this.Ff = Oi(this.Ff, 3);
  } });
  var G = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (G !== null) return G;
  }, set: function(H) {
    if ([0, 1, 2].indexOf(H) === -1) throw new Error('Invalid value "' + H + '" for attribute Q supplied.');
    G = H;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var H;
    switch (G) {
      case 0:
      default:
        H = "left";
        break;
      case 1:
        H = "center";
        break;
      case 2:
        H = "right";
    }
    return H;
  }, configurable: !0, enumerable: !0, set: function(H) {
    switch (H) {
      case "right":
      case 2:
        G = 2;
        break;
      case "center":
      case 1:
        G = 1;
        break;
      case "left":
      case 0:
      default:
        G = 0;
    }
  } });
};
Xo(Cl, vc);
var Ud = function() {
  Cl.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var n = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return PT(e, this.objId, this.scope);
  }, set: function(t) {
    var r, i;
    i = [], typeof (r = t) == "string" && (i = function(o, c, l) {
      l || (l = 1);
      for (var _, b = []; _ = c.exec(o); ) b.push(_[l]);
      return b;
    }(r, /\((.*?)\)/g)), e = i;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, r) {
    for (r = r || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), r !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 18) : this.Ff = Oi(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = Ri(this.Ff, 19) : this.Ff = Oi(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = Ri(this.Ff, 20), e.sort()) : this.Ff = Oi(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 22) : this.Ff = Oi(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 23) : this.Ff = Oi(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 27) : this.Ff = Oi(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Xo(Ud, Cl);
var jd = function() {
  Ud.call(this), this.fontName = "helvetica", this.combo = !1;
};
Xo(jd, Ud);
var Gd = function() {
  jd.call(this), this.combo = !0;
};
Xo(Gd, jd);
var tm = function() {
  Gd.call(this), this.edit = !0;
};
Xo(tm, Gd);
var ys = function() {
  Cl.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 15) : this.Ff = Oi(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 16) : this.Ff = Oi(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 17) : this.Ff = Oi(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = Ri(this.Ff, 26) : this.Ff = Oi(this.Ff, 26);
  } });
  var n, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(o) {
      return o;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var r, i = [];
      for (r in i.push("<<"), e) i.push("/" + r + " (" + Hh(t(e[r])) + ")");
      return i.push(">>"), i.join(`
`);
    }
  }, set: function(t) {
    zr(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(t) {
    n = "/" + t;
  } });
};
Xo(ys, Cl);
var nm = function() {
  ys.call(this), this.pushButton = !0;
};
Xo(nm, ys);
var Vd = function() {
  ys.call(this), this.radio = !0, this.pushButton = !1;
  var n = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e !== void 0 ? e : [];
  } });
};
Xo(Vd, ys);
var Mm = function() {
  var n, e;
  Cl.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(i) {
    n = i;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(i) {
    e = i;
  } });
  var t, r = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var i = function(l) {
      return l;
    };
    this.scope && (i = this.scope.internal.getEncryptor(this.objId));
    var o, c = [];
    for (o in c.push("<<"), r) c.push("/" + o + " (" + Hh(i(r[o])) + ")");
    return c.push(">>"), c.join(`
`);
  }, set: function(i) {
    zr(i) === "object" && (r = i);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return r.CA || "";
  }, set: function(i) {
    typeof i == "string" && (r.CA = i);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(i) {
    t = i;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(i) {
    t = "/" + i;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = cn.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Xo(Mm, Cl), Vd.prototype.setAppearance = function(n) {
  if (!("createAppearanceStream" in n) || !("getCA" in n)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var t = this.Kids[e];
    t.appearanceStreamContent = n.createAppearanceStream(t.optionName), t.caption = n.getCA();
  }
}, Vd.prototype.createOption = function(n) {
  var e = new Mm();
  return e.Parent = this, e.optionName = n, this.Kids.push(e), bV.call(this.scope, e), e;
};
var rm = function() {
  ys.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = cn.CheckBox.createAppearanceStream();
};
Xo(rm, ys);
var Oh = function() {
  Cl.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = Ri(this.Ff, 13) : this.Ff = Oi(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = Ri(this.Ff, 21) : this.Ff = Oi(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = Ri(this.Ff, 23) : this.Ff = Oi(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = Ri(this.Ff, 24) : this.Ff = Oi(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = Ri(this.Ff, 25) : this.Ff = Oi(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = Ri(this.Ff, 26) : this.Ff = Oi(this.Ff, 26);
  } });
  var n = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(e) {
    Number.isInteger(e) && (n = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Xo(Oh, Cl);
var im = function() {
  Oh.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Bi(this.Ff, 14);
  }, set: function(n) {
    n ? this.Ff = Ri(this.Ff, 14) : this.Ff = Oi(this.Ff, 14);
  } }), this.password = !0;
};
Xo(im, Oh);
var cn = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: cn.CheckBox.YesNormal }, D: { On: cn.CheckBox.YesPushDown, Off: cn.CheckBox.OffPushDown } };
}, YesPushDown: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = [], r = n.scope.internal.getFont(n.fontName, n.fontStyle).id, i = n.scope.__private__.encodeColorString(n.color), o = i1(n, n.caption);
  return t.push("0.749023 g"), t.push("0 0 " + Vn(cn.internal.getWidth(n)) + " " + Vn(cn.internal.getHeight(n)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + r + " " + Vn(o.fontSize) + " Tf " + i), t.push("BT"), t.push(o.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = n.scope.internal.getFont(n.fontName, n.fontStyle).id, r = n.scope.__private__.encodeColorString(n.color), i = [], o = cn.internal.getHeight(n), c = cn.internal.getWidth(n), l = i1(n, n.caption);
  return i.push("1 g"), i.push("0 0 " + Vn(c) + " " + Vn(o) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + Vn(c - 1) + " " + Vn(o - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + t + " " + Vn(l.fontSize) + " Tf " + r), i.push(l.text), i.push("ET"), i.push("Q"), e.stream = i.join(`
`), e;
}, OffPushDown: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + Vn(cn.internal.getWidth(n)) + " " + Vn(cn.internal.getHeight(n)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(n) {
  var e = { D: { Off: cn.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[n] = cn.RadioButton.Circle.YesNormal, e.D[n] = cn.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = [], r = cn.internal.getWidth(n) <= cn.internal.getHeight(n) ? cn.internal.getWidth(n) / 4 : cn.internal.getHeight(n) / 4;
  r = Number((0.9 * r).toFixed(5));
  var i = cn.internal.Bezier_C, o = Number((r * i).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + ku(cn.internal.getWidth(n) / 2) + " " + ku(cn.internal.getHeight(n) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + o + " " + o + " " + r + " 0 " + r + " c"), t.push("-" + o + " " + r + " -" + r + " " + o + " -" + r + " 0 c"), t.push("-" + r + " -" + o + " -" + o + " -" + r + " 0 -" + r + " c"), t.push(o + " -" + r + " " + r + " -" + o + " " + r + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = [], r = cn.internal.getWidth(n) <= cn.internal.getHeight(n) ? cn.internal.getWidth(n) / 4 : cn.internal.getHeight(n) / 4;
  r = Number((0.9 * r).toFixed(5));
  var i = Number((2 * r).toFixed(5)), o = Number((i * cn.internal.Bezier_C).toFixed(5)), c = Number((r * cn.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + ku(cn.internal.getWidth(n) / 2) + " " + ku(cn.internal.getHeight(n) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), t.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), t.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), t.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + ku(cn.internal.getWidth(n) / 2) + " " + ku(cn.internal.getHeight(n) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + c + " " + c + " " + r + " 0 " + r + " c"), t.push("-" + c + " " + r + " -" + r + " " + c + " -" + r + " 0 c"), t.push("-" + r + " -" + c + " -" + c + " -" + r + " 0 -" + r + " c"), t.push(c + " -" + r + " " + r + " -" + c + " " + r + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = [], r = cn.internal.getWidth(n) <= cn.internal.getHeight(n) ? cn.internal.getWidth(n) / 4 : cn.internal.getHeight(n) / 4;
  r = Number((0.9 * r).toFixed(5));
  var i = Number((2 * r).toFixed(5)), o = Number((i * cn.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + ku(cn.internal.getWidth(n) / 2) + " " + ku(cn.internal.getHeight(n) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), t.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), t.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), t.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(n) {
  var e = { D: { Off: cn.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[n] = cn.RadioButton.Cross.YesNormal, e.D[n] = cn.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = [], r = cn.internal.calculateCross(n);
  return t.push("q"), t.push("1 1 " + Vn(cn.internal.getWidth(n) - 2) + " " + Vn(cn.internal.getHeight(n) - 2) + " re"), t.push("W"), t.push("n"), t.push(Vn(r.x1.x) + " " + Vn(r.x1.y) + " m"), t.push(Vn(r.x2.x) + " " + Vn(r.x2.y) + " l"), t.push(Vn(r.x4.x) + " " + Vn(r.x4.y) + " m"), t.push(Vn(r.x3.x) + " " + Vn(r.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = cn.internal.calculateCross(n), r = [];
  return r.push("0.749023 g"), r.push("0 0 " + Vn(cn.internal.getWidth(n)) + " " + Vn(cn.internal.getHeight(n)) + " re"), r.push("f"), r.push("q"), r.push("1 1 " + Vn(cn.internal.getWidth(n) - 2) + " " + Vn(cn.internal.getHeight(n) - 2) + " re"), r.push("W"), r.push("n"), r.push(Vn(t.x1.x) + " " + Vn(t.x1.y) + " m"), r.push(Vn(t.x2.x) + " " + Vn(t.x2.y) + " l"), r.push(Vn(t.x4.x) + " " + Vn(t.x4.y) + " m"), r.push(Vn(t.x3.x) + " " + Vn(t.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join(`
`), e;
}, OffPushDown: function(n) {
  var e = pc(n);
  e.scope = n.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + Vn(cn.internal.getWidth(n)) + " " + Vn(cn.internal.getHeight(n)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(n) {
  var e = n.scope.internal.getFont(n.fontName, n.fontStyle).id, t = n.scope.__private__.encodeColorString(n.color);
  return "/" + e + " " + n.fontSize + " Tf " + t;
} };
cn.internal = { Bezier_C: 0.551915024494, calculateCross: function(n) {
  var e = cn.internal.getWidth(n), t = cn.internal.getHeight(n), r = Math.min(e, t);
  return { x1: { x: (e - r) / 2, y: (t - r) / 2 + r }, x2: { x: (e - r) / 2 + r, y: (t - r) / 2 }, x3: { x: (e - r) / 2, y: (t - r) / 2 }, x4: { x: (e - r) / 2 + r, y: (t - r) / 2 + r } };
} }, cn.internal.getWidth = function(n) {
  var e = 0;
  return zr(n) === "object" && (e = GA(n.Rect[2])), e;
}, cn.internal.getHeight = function(n) {
  var e = 0;
  return zr(n) === "object" && (e = GA(n.Rect[3])), e;
};
var bV = Ti.addField = function(n) {
  if (yV(this, n), !(n instanceof Cl)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = n).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), n.page = n.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Ti.AcroFormChoiceField = Ud, Ti.AcroFormListBox = jd, Ti.AcroFormComboBox = Gd, Ti.AcroFormEditBox = tm, Ti.AcroFormButton = ys, Ti.AcroFormPushButton = nm, Ti.AcroFormRadioButton = Vd, Ti.AcroFormCheckBox = rm, Ti.AcroFormTextField = Oh, Ti.AcroFormPasswordField = im, Ti.AcroFormAppearance = cn, Ti.AcroForm = { ChoiceField: Ud, ListBox: jd, ComboBox: Gd, EditBox: tm, Button: ys, PushButton: nm, RadioButton: Vd, CheckBox: rm, TextField: Oh, PasswordField: im, Appearance: cn }, Bn.AcroForm = { ChoiceField: Ud, ListBox: jd, ComboBox: Gd, EditBox: tm, Button: ys, PushButton: nm, RadioButton: Vd, CheckBox: rm, TextField: Oh, PasswordField: im, Appearance: cn };
function BT(n) {
  return n.reduce(function(e, t, r) {
    return e[t] = r, e;
  }, {});
}
(function(n) {
  n.__addimage__ = {};
  var e = "UNKNOWN", t = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, r = n.__addimage__.getImageFileTypeByImageData = function(oe, pe) {
    var Te, xe, et, rt, st, Je = e;
    if ((pe = pe || e) === "RGBA" || oe.data !== void 0 && oe.data instanceof Uint8ClampedArray && "height" in oe && "width" in oe) return "RGBA";
    if (Re(oe)) for (st in t) for (et = t[st], Te = 0; Te < et.length; Te += 1) {
      for (rt = !0, xe = 0; xe < et[Te].length; xe += 1) if (et[Te][xe] !== void 0 && et[Te][xe] !== oe[xe]) {
        rt = !1;
        break;
      }
      if (rt === !0) {
        Je = st;
        break;
      }
    }
    else for (st in t) for (et = t[st], Te = 0; Te < et.length; Te += 1) {
      for (rt = !0, xe = 0; xe < et[Te].length; xe += 1) if (et[Te][xe] !== void 0 && et[Te][xe] !== oe.charCodeAt(xe)) {
        rt = !1;
        break;
      }
      if (rt === !0) {
        Je = st;
        break;
      }
    }
    return Je === e && pe !== e && (Je = pe), Je;
  }, i = function oe(pe) {
    for (var Te = this.internal.write, xe = this.internal.putStream, et = (0, this.internal.getFilters)(); et.indexOf("FlateEncode") !== -1; ) et.splice(et.indexOf("FlateEncode"), 1);
    pe.objectId = this.internal.newObject();
    var rt = [];
    if (rt.push({ key: "Type", value: "/XObject" }), rt.push({ key: "Subtype", value: "/Image" }), rt.push({ key: "Width", value: pe.width }), rt.push({ key: "Height", value: pe.height }), pe.colorSpace === G.INDEXED ? rt.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (pe.palette.length / 3 - 1) + " " + ("sMask" in pe && pe.sMask !== void 0 ? pe.objectId + 2 : pe.objectId + 1) + " 0 R]" }) : (rt.push({ key: "ColorSpace", value: "/" + pe.colorSpace }), pe.colorSpace === G.DEVICE_CMYK && rt.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), rt.push({ key: "BitsPerComponent", value: pe.bitsPerComponent }), "decodeParameters" in pe && pe.decodeParameters !== void 0 && rt.push({ key: "DecodeParms", value: "<<" + pe.decodeParameters + ">>" }), "transparency" in pe && Array.isArray(pe.transparency)) {
      for (var st = "", Je = 0, ct = pe.transparency.length; Je < ct; Je++) st += pe.transparency[Je] + " " + pe.transparency[Je] + " ";
      rt.push({ key: "Mask", value: "[" + st + "]" });
    }
    pe.sMask !== void 0 && rt.push({ key: "SMask", value: pe.objectId + 1 + " 0 R" });
    var ot = pe.filter !== void 0 ? ["/" + pe.filter] : void 0;
    if (xe({ data: pe.data, additionalKeyValues: rt, alreadyAppliedFilters: ot, objectId: pe.objectId }), Te("endobj"), "sMask" in pe && pe.sMask !== void 0) {
      var Mt = "/Predictor " + pe.predictor + " /Colors 1 /BitsPerComponent " + pe.bitsPerComponent + " /Columns " + pe.width, re = { width: pe.width, height: pe.height, colorSpace: "DeviceGray", bitsPerComponent: pe.bitsPerComponent, decodeParameters: Mt, data: pe.sMask };
      "filter" in pe && (re.filter = pe.filter), oe.call(this, re);
    }
    if (pe.colorSpace === G.INDEXED) {
      var Ae = this.internal.newObject();
      xe({ data: _e(new Uint8Array(pe.palette)), objectId: Ae }), Te("endobj");
    }
  }, o = function() {
    var oe = this.internal.collections.addImage_images;
    for (var pe in oe) i.call(this, oe[pe]);
  }, c = function() {
    var oe, pe = this.internal.collections.addImage_images, Te = this.internal.write;
    for (var xe in pe) Te("/I" + (oe = pe[xe]).index, oe.objectId, "0", "R");
  }, l = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o), this.internal.events.subscribe("putXobjectDict", c));
  }, _ = function() {
    var oe = this.internal.collections.addImage_images;
    return l.call(this), oe;
  }, b = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, w = function(oe) {
    return typeof n["process" + oe.toUpperCase()] == "function";
  }, T = function(oe) {
    return zr(oe) === "object" && oe.nodeType === 1;
  }, I = function(oe, pe) {
    if (oe.nodeName === "IMG" && oe.hasAttribute("src")) {
      var Te = "" + oe.getAttribute("src");
      if (Te.indexOf("data:image/") === 0) return fp(unescape(Te).split("base64,").pop());
      var xe = n.loadFile(Te, !0);
      if (xe !== void 0) return xe;
    }
    if (oe.nodeName === "CANVAS") {
      if (oe.width === 0 || oe.height === 0) throw new Error("Given canvas must have data. Canvas width: " + oe.width + ", height: " + oe.height);
      var et;
      switch (pe) {
        case "PNG":
          et = "image/png";
          break;
        case "WEBP":
          et = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          et = "image/jpeg";
      }
      return fp(oe.toDataURL(et, 1).split("base64,").pop());
    }
  }, P = function(oe) {
    var pe = this.internal.collections.addImage_images;
    if (pe) {
      for (var Te in pe) if (oe === pe[Te].alias) return pe[Te];
    }
  }, k = function(oe, pe, Te) {
    return oe || pe || (oe = -96, pe = -96), oe < 0 && (oe = -1 * Te.width * 72 / oe / this.internal.scaleFactor), pe < 0 && (pe = -1 * Te.height * 72 / pe / this.internal.scaleFactor), oe === 0 && (oe = pe * Te.width / Te.height), pe === 0 && (pe = oe * Te.height / Te.width), [oe, pe];
  }, U = function(oe, pe, Te, xe, et, rt) {
    var st = k.call(this, Te, xe, et), Je = this.internal.getCoordinateString, ct = this.internal.getVerticalCoordinateString, ot = _.call(this);
    if (Te = st[0], xe = st[1], ot[et.index] = et, rt) {
      rt *= Math.PI / 180;
      var Mt = Math.cos(rt), re = Math.sin(rt), Ae = function(Ue) {
        return Ue.toFixed(4);
      }, Ce = [Ae(Mt), Ae(re), Ae(-1 * re), Ae(Mt), 0, 0, "cm"];
    }
    this.internal.write("q"), rt ? (this.internal.write([1, "0", "0", 1, Je(oe), ct(pe + xe), "cm"].join(" ")), this.internal.write(Ce.join(" ")), this.internal.write([Je(Te), "0", "0", Je(xe), "0", "0", "cm"].join(" "))) : this.internal.write([Je(Te), "0", "0", Je(xe), Je(oe), ct(pe + xe), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + et.index + " Do"), this.internal.write("Q");
  }, G = n.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  n.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var H = n.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, $ = n.__addimage__.sHashCode = function(oe) {
    var pe, Te, xe = 0;
    if (typeof oe == "string") for (Te = oe.length, pe = 0; pe < Te; pe++) xe = (xe << 5) - xe + oe.charCodeAt(pe), xe |= 0;
    else if (Re(oe)) for (Te = oe.byteLength / 2, pe = 0; pe < Te; pe++) xe = (xe << 5) - xe + oe[pe], xe |= 0;
    return xe;
  }, ie = n.__addimage__.validateStringAsBase64 = function(oe) {
    (oe = oe || "").toString().trim();
    var pe = !0;
    return oe.length === 0 && (pe = !1), oe.length % 4 != 0 && (pe = !1), /^[A-Za-z0-9+/]+$/.test(oe.substr(0, oe.length - 2)) === !1 && (pe = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(oe.substr(-2)) === !1 && (pe = !1), pe;
  }, ge = n.__addimage__.extractImageFromDataUrl = function(oe) {
    var pe = (oe = oe || "").split("base64,"), Te = null;
    if (pe.length === 2) {
      var xe = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(pe[0]);
      Array.isArray(xe) && (Te = { mimeType: xe[1], charset: xe[2], data: pe[1] });
    }
    return Te;
  }, Se = n.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  n.__addimage__.isArrayBuffer = function(oe) {
    return Se() && oe instanceof ArrayBuffer;
  };
  var Re = n.__addimage__.isArrayBufferView = function(oe) {
    return Se() && typeof Uint32Array < "u" && (oe instanceof Int8Array || oe instanceof Uint8Array || typeof Uint8ClampedArray < "u" && oe instanceof Uint8ClampedArray || oe instanceof Int16Array || oe instanceof Uint16Array || oe instanceof Int32Array || oe instanceof Uint32Array || oe instanceof Float32Array || oe instanceof Float64Array);
  }, Le = n.__addimage__.binaryStringToUint8Array = function(oe) {
    for (var pe = oe.length, Te = new Uint8Array(pe), xe = 0; xe < pe; xe++) Te[xe] = oe.charCodeAt(xe);
    return Te;
  }, _e = n.__addimage__.arrayBufferToBinaryString = function(oe) {
    for (var pe = "", Te = Re(oe) ? oe : new Uint8Array(oe), xe = 0; xe < Te.length; xe += 8192) pe += String.fromCharCode.apply(null, Te.subarray(xe, xe + 8192));
    return pe;
  };
  n.addImage = function() {
    var oe, pe, Te, xe, et, rt, st, Je, ct;
    if (typeof arguments[1] == "number" ? (pe = e, Te = arguments[1], xe = arguments[2], et = arguments[3], rt = arguments[4], st = arguments[5], Je = arguments[6], ct = arguments[7]) : (pe = arguments[1], Te = arguments[2], xe = arguments[3], et = arguments[4], rt = arguments[5], st = arguments[6], Je = arguments[7], ct = arguments[8]), zr(oe = arguments[0]) === "object" && !T(oe) && "imageData" in oe) {
      var ot = oe;
      oe = ot.imageData, pe = ot.format || pe || e, Te = ot.x || Te || 0, xe = ot.y || xe || 0, et = ot.w || ot.width || et, rt = ot.h || ot.height || rt, st = ot.alias || st, Je = ot.compression || Je, ct = ot.rotation || ot.angle || ct;
    }
    var Mt = this.internal.getFilters();
    if (Je === void 0 && Mt.indexOf("FlateEncode") !== -1 && (Je = "SLOW"), isNaN(Te) || isNaN(xe)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    l.call(this);
    var re = Ge.call(this, oe, pe, st, Je);
    return U.call(this, Te, xe, et, rt, re, ct), this;
  };
  var Ge = function(oe, pe, Te, xe) {
    var et, rt, st;
    if (typeof oe == "string" && r(oe) === e) {
      oe = unescape(oe);
      var Je = ke(oe, !1);
      (Je !== "" || (Je = n.loadFile(oe, !0)) !== void 0) && (oe = Je);
    }
    if (T(oe) && (oe = I(oe, pe)), pe = r(oe, pe), !w(pe)) throw new Error("addImage does not support files of type '" + pe + "', please ensure that a plugin for '" + pe + "' support is added.");
    if (((st = Te) == null || st.length === 0) && (Te = function(ct) {
      return typeof ct == "string" || Re(ct) ? $(ct) : Re(ct.data) ? $(ct.data) : null;
    }(oe)), (et = P.call(this, Te)) || (Se() && (oe instanceof Uint8Array || pe === "RGBA" || (rt = oe, oe = Le(oe))), et = this["process" + pe.toUpperCase()](oe, b.call(this), Te, function(ct) {
      return ct && typeof ct == "string" && (ct = ct.toUpperCase()), ct in n.image_compression ? ct : H.NONE;
    }(xe), rt)), !et) throw new Error("An unknown error occurred whilst processing the image.");
    return et;
  }, ke = n.__addimage__.convertBase64ToBinaryString = function(oe, pe) {
    var Te;
    pe = typeof pe != "boolean" || pe;
    var xe, et = "";
    if (typeof oe == "string") {
      xe = (Te = ge(oe)) !== null ? Te.data : oe;
      try {
        et = fp(xe);
      } catch (rt) {
        if (pe) throw ie(xe) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + rt.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return et;
  };
  n.getImageProperties = function(oe) {
    var pe, Te, xe = "";
    if (T(oe) && (oe = I(oe)), typeof oe == "string" && r(oe) === e && ((xe = ke(oe, !1)) === "" && (xe = n.loadFile(oe) || ""), oe = xe), Te = r(oe), !w(Te)) throw new Error("addImage does not support files of type '" + Te + "', please ensure that a plugin for '" + Te + "' support is added.");
    if (!Se() || oe instanceof Uint8Array || (oe = Le(oe)), !(pe = this["process" + Te.toUpperCase()](oe))) throw new Error("An unknown error occurred whilst processing the image");
    return pe.fileType = Te, pe;
  };
})(Bn.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(t) {
    if (t !== void 0 && t != "") return !0;
  };
  Bn.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), n.events.push(["putPage", function(t) {
    for (var r, i, o, c = this.internal.getCoordinateString, l = this.internal.getVerticalCoordinateString, _ = this.internal.getPageInfoByObjId(t.objId), b = t.pageContext.annotations, w = !1, T = 0; T < b.length && !w; T++) switch ((r = b[T]).type) {
      case "link":
        (e(r.options.url) || e(r.options.pageNumber)) && (w = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        w = !0;
    }
    if (w != 0) {
      this.internal.write("/Annots [");
      for (var I = 0; I < b.length; I++) {
        r = b[I];
        var P = this.internal.pdfEscape, k = this.internal.getEncryptor(t.objId);
        switch (r.type) {
          case "reference":
            this.internal.write(" " + r.object.objId + " 0 R ");
            break;
          case "text":
            var U = this.internal.newAdditionalObject(), G = this.internal.newAdditionalObject(), H = this.internal.getEncryptor(U.objId), $ = r.title || "Note";
            o = "<</Type /Annot /Subtype /Text " + (i = "/Rect [" + c(r.bounds.x) + " " + l(r.bounds.y + r.bounds.h) + " " + c(r.bounds.x + r.bounds.w) + " " + l(r.bounds.y) + "] ") + "/Contents (" + P(H(r.contents)) + ")", o += " /Popup " + G.objId + " 0 R", o += " /P " + _.objId + " 0 R", o += " /T (" + P(H($)) + ") >>", U.content = o;
            var ie = U.objId + " 0 R";
            o = "<</Type /Annot /Subtype /Popup " + (i = "/Rect [" + c(r.bounds.x + 30) + " " + l(r.bounds.y + r.bounds.h) + " " + c(r.bounds.x + r.bounds.w + 30) + " " + l(r.bounds.y) + "] ") + " /Parent " + ie, r.open && (o += " /Open true"), o += " >>", G.content = o, this.internal.write(U.objId, "0 R", G.objId, "0 R");
            break;
          case "freetext":
            i = "/Rect [" + c(r.bounds.x) + " " + l(r.bounds.y) + " " + c(r.bounds.x + r.bounds.w) + " " + l(r.bounds.y + r.bounds.h) + "] ";
            var ge = r.color || "#000000";
            o = "<</Type /Annot /Subtype /FreeText " + i + "/Contents (" + P(k(r.contents)) + ")", o += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + ge + ")", o += " /Border [0 0 0]", o += " >>", this.internal.write(o);
            break;
          case "link":
            if (r.options.name) {
              var Se = this.annotations._nameMap[r.options.name];
              r.options.pageNumber = Se.page, r.options.top = Se.y;
            } else r.options.top || (r.options.top = 0);
            if (i = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", o = "", r.options.url) o = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /A <</S /URI /URI (" + P(k(r.options.url)) + ") >>";
            else if (r.options.pageNumber) switch (o = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
              case "Fit":
                o += " /Fit]";
                break;
              case "FitH":
                o += " /FitH " + r.options.top + "]";
                break;
              case "FitV":
                r.options.left = r.options.left || 0, o += " /FitV " + r.options.left + "]";
                break;
              case "XYZ":
              default:
                var Re = l(r.options.top);
                r.options.left = r.options.left || 0, r.options.zoom === void 0 && (r.options.zoom = 0), o += " /XYZ " + r.options.left + " " + Re + " " + r.options.zoom + "]";
            }
            o != "" && (o += " >>", this.internal.write(o));
        }
      }
      this.internal.write("]");
    }
  }]), n.createAnnotation = function(t) {
    var r = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        r.pageContext.annotations.push(t);
    }
  }, n.link = function(t, r, i, o, c) {
    var l = this.internal.getCurrentPageInfo(), _ = this.internal.getCoordinateString, b = this.internal.getVerticalCoordinateString;
    l.pageContext.annotations.push({ finalBounds: { x: _(t), y: b(r), w: _(t + i), h: b(r + o) }, options: c, type: "link" });
  }, n.textWithLink = function(t, r, i, o) {
    var c, l, _ = this.getTextWidth(t), b = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (o.maxWidth !== void 0) {
      l = o.maxWidth;
      var w = this.splitTextToSize(t, l).length;
      c = Math.ceil(b * w);
    } else l = _, c = b;
    return this.text(t, r, i, o), i += 0.2 * b, o.align === "center" && (r -= _ / 2), o.align === "right" && (r -= _), this.link(r, i - b, l, c, o), _;
  }, n.getTextWidth = function(t) {
    var r = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * r / this.internal.scaleFactor;
  };
}(Bn.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, r = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i = [1570, 1571, 1573, 1575];
  n.__arabicParser__ = {};
  var o = n.__arabicParser__.isInArabicSubstitutionA = function(U) {
    return e[U.charCodeAt(0)] !== void 0;
  }, c = n.__arabicParser__.isArabicLetter = function(U) {
    return typeof U == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(U);
  }, l = n.__arabicParser__.isArabicEndLetter = function(U) {
    return c(U) && o(U) && e[U.charCodeAt(0)].length <= 2;
  }, _ = n.__arabicParser__.isArabicAlfLetter = function(U) {
    return c(U) && i.indexOf(U.charCodeAt(0)) >= 0;
  };
  n.__arabicParser__.arabicLetterHasIsolatedForm = function(U) {
    return c(U) && o(U) && e[U.charCodeAt(0)].length >= 1;
  };
  var b = n.__arabicParser__.arabicLetterHasFinalForm = function(U) {
    return c(U) && o(U) && e[U.charCodeAt(0)].length >= 2;
  };
  n.__arabicParser__.arabicLetterHasInitialForm = function(U) {
    return c(U) && o(U) && e[U.charCodeAt(0)].length >= 3;
  };
  var w = n.__arabicParser__.arabicLetterHasMedialForm = function(U) {
    return c(U) && o(U) && e[U.charCodeAt(0)].length == 4;
  }, T = n.__arabicParser__.resolveLigatures = function(U) {
    var G = 0, H = t, $ = "", ie = 0;
    for (G = 0; G < U.length; G += 1) H[U.charCodeAt(G)] !== void 0 ? (ie++, typeof (H = H[U.charCodeAt(G)]) == "number" && ($ += String.fromCharCode(H), H = t, ie = 0), G === U.length - 1 && (H = t, $ += U.charAt(G - (ie - 1)), G -= ie - 1, ie = 0)) : (H = t, $ += U.charAt(G - ie), G -= ie, ie = 0);
    return $;
  };
  n.__arabicParser__.isArabicDiacritic = function(U) {
    return U !== void 0 && r[U.charCodeAt(0)] !== void 0;
  };
  var I = n.__arabicParser__.getCorrectForm = function(U, G, H) {
    return c(U) ? o(U) === !1 ? -1 : !b(U) || !c(G) && !c(H) || !c(H) && l(G) || l(U) && !c(G) || l(U) && _(G) || l(U) && l(G) ? 0 : w(U) && c(G) && !l(G) && c(H) && b(H) ? 3 : l(U) || !c(H) ? 1 : 2 : -1;
  }, P = function(U) {
    var G = 0, H = 0, $ = 0, ie = "", ge = "", Se = "", Re = (U = U || "").split("\\s+"), Le = [];
    for (G = 0; G < Re.length; G += 1) {
      for (Le.push(""), H = 0; H < Re[G].length; H += 1) ie = Re[G][H], ge = Re[G][H - 1], Se = Re[G][H + 1], c(ie) ? ($ = I(ie, ge, Se), Le[G] += $ !== -1 ? String.fromCharCode(e[ie.charCodeAt(0)][$]) : ie) : Le[G] += ie;
      Le[G] = T(Le[G]);
    }
    return Le.join(" ");
  }, k = n.__arabicParser__.processArabic = n.processArabic = function() {
    var U, G = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, H = [];
    if (Array.isArray(G)) {
      var $ = 0;
      for (H = [], $ = 0; $ < G.length; $ += 1) Array.isArray(G[$]) ? H.push([P(G[$][0]), G[$][1], G[$][2]]) : H.push([P(G[$])]);
      U = H;
    } else U = P(G);
    return typeof arguments[0] == "string" ? U : (arguments[0].text = U, arguments[0]);
  };
  n.events.push(["preProcessText", k]);
}(Bn.API), Bn.API.autoPrint = function(n) {
  var e;
  switch ((n = n || {}).variant = n.variant || "non-conform", n.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(l) {
      t = l;
    } });
    var r = 150;
    Object.defineProperty(this, "width", { get: function() {
      return r;
    }, set: function(l) {
      r = isNaN(l) || Number.isInteger(l) === !1 || l < 0 ? 150 : l, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = r + 1);
    } });
    var i = 300;
    Object.defineProperty(this, "height", { get: function() {
      return i;
    }, set: function(l) {
      i = isNaN(l) || Number.isInteger(l) === !1 || l < 0 ? 300 : l, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = i + 1);
    } });
    var o = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return o;
    }, set: function(l) {
      o = l;
    } });
    var c = {};
    Object.defineProperty(this, "style", { get: function() {
      return c;
    }, set: function(l) {
      c = l;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, r) {
    var i;
    if ((t = t || "2d") !== "2d") return null;
    for (i in r) this.pdf.context2d.hasOwnProperty(i) && (this.pdf.context2d[i] = r[i]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, n.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(Bn.API), function(n) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, r = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), i.call(this));
  }, i = function() {
    this.internal.__cell__.lastCell = new o(), this.internal.__cell__.pages = 1;
  }, o = function() {
    var _ = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return _;
    }, set: function(U) {
      _ = U;
    } });
    var b = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return b;
    }, set: function(U) {
      b = U;
    } });
    var w = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return w;
    }, set: function(U) {
      w = U;
    } });
    var T = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return T;
    }, set: function(U) {
      T = U;
    } });
    var I = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return I;
    }, set: function(U) {
      I = U;
    } });
    var P = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return P;
    }, set: function(U) {
      P = U;
    } });
    var k = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return k;
    }, set: function(U) {
      k = U;
    } }), this;
  };
  o.prototype.clone = function() {
    return new o(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, n.setHeaderFunction = function(_) {
    return r.call(this), this.internal.__cell__.headerFunction = typeof _ == "function" ? _ : void 0, this;
  }, n.getTextDimensions = function(_, b) {
    r.call(this);
    var w = (b = b || {}).fontSize || this.getFontSize(), T = b.font || this.getFont(), I = b.scaleFactor || this.internal.scaleFactor, P = 0, k = 0, U = 0, G = this;
    if (!Array.isArray(_) && typeof _ != "string") {
      if (typeof _ != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      _ = String(_);
    }
    var H = b.maxWidth;
    H > 0 ? typeof _ == "string" ? _ = this.splitTextToSize(_, H) : Object.prototype.toString.call(_) === "[object Array]" && (_ = _.reduce(function(ie, ge) {
      return ie.concat(G.splitTextToSize(ge, H));
    }, [])) : _ = Array.isArray(_) ? _ : [_];
    for (var $ = 0; $ < _.length; $++) P < (U = this.getStringUnitWidth(_[$], { font: T }) * w) && (P = U);
    return P !== 0 && (k = _.length), { w: P /= I, h: Math.max((k * w * this.getLineHeightFactor() - w * (this.getLineHeightFactor() - 1)) / I, 0) };
  }, n.cellAddPage = function() {
    r.call(this), this.addPage();
    var _ = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new o(_.left, _.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var c = n.cell = function() {
    var _;
    _ = arguments[0] instanceof o ? arguments[0] : new o(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), r.call(this);
    var b = this.internal.__cell__.lastCell, w = this.internal.__cell__.padding, T = this.internal.__cell__.margins || e, I = this.internal.__cell__.tableHeaderRow, P = this.internal.__cell__.printHeaders;
    return b.lineNumber !== void 0 && (b.lineNumber === _.lineNumber ? (_.x = (b.x || 0) + (b.width || 0), _.y = b.y || 0) : b.y + b.height + _.height + T.bottom > this.getPageHeight() ? (this.cellAddPage(), _.y = T.top, P && I && (this.printHeaderRow(_.lineNumber, !0), _.y += I[0].height)) : _.y = b.y + b.height || _.y), _.text[0] !== void 0 && (this.rect(_.x, _.y, _.width, _.height, t === !0 ? "FD" : void 0), _.align === "right" ? this.text(_.text, _.x + _.width - w, _.y + w, { align: "right", baseline: "top" }) : _.align === "center" ? this.text(_.text, _.x + _.width / 2, _.y + w, { align: "center", baseline: "top", maxWidth: _.width - w - w }) : this.text(_.text, _.x + w, _.y + w, { align: "left", baseline: "top", maxWidth: _.width - w - w })), this.internal.__cell__.lastCell = _, this;
  };
  n.table = function(_, b, w, T, I) {
    if (r.call(this), !w) throw new Error("No data for PDF table.");
    var P, k, U, G, H = [], $ = [], ie = [], ge = {}, Se = {}, Re = [], Le = [], _e = (I = I || {}).autoSize || !1, Ge = I.printHeaders !== !1, ke = I.css && I.css["font-size"] !== void 0 ? 16 * I.css["font-size"] : I.fontSize || 12, oe = I.margins || Object.assign({ width: this.getPageWidth() }, e), pe = typeof I.padding == "number" ? I.padding : 3, Te = I.headerBackgroundColor || "#c8c8c8", xe = I.headerTextColor || "#000";
    if (i.call(this), this.internal.__cell__.printHeaders = Ge, this.internal.__cell__.margins = oe, this.internal.__cell__.table_font_size = ke, this.internal.__cell__.padding = pe, this.internal.__cell__.headerBackgroundColor = Te, this.internal.__cell__.headerTextColor = xe, this.setFontSize(ke), T == null) $ = H = Object.keys(w[0]), ie = H.map(function() {
      return "left";
    });
    else if (Array.isArray(T) && zr(T[0]) === "object") for (H = T.map(function(ot) {
      return ot.name;
    }), $ = T.map(function(ot) {
      return ot.prompt || ot.name || "";
    }), ie = T.map(function(ot) {
      return ot.align || "left";
    }), P = 0; P < T.length; P += 1) Se[T[P].name] = T[P].width * (19.049976 / 25.4);
    else Array.isArray(T) && typeof T[0] == "string" && ($ = H = T, ie = H.map(function() {
      return "left";
    }));
    if (_e || Array.isArray(T) && typeof T[0] == "string") for (P = 0; P < H.length; P += 1) {
      for (ge[G = H[P]] = w.map(function(ot) {
        return ot[G];
      }), this.setFont(void 0, "bold"), Re.push(this.getTextDimensions($[P], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), k = ge[G], this.setFont(void 0, "normal"), U = 0; U < k.length; U += 1) Re.push(this.getTextDimensions(k[U], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      Se[G] = Math.max.apply(null, Re) + pe + pe, Re = [];
    }
    if (Ge) {
      var et = {};
      for (P = 0; P < H.length; P += 1) et[H[P]] = {}, et[H[P]].text = $[P], et[H[P]].align = ie[P];
      var rt = l.call(this, et, Se);
      Le = H.map(function(ot) {
        return new o(_, b, Se[ot], rt, et[ot].text, void 0, et[ot].align);
      }), this.setTableHeaderRow(Le), this.printHeaderRow(1, !1);
    }
    var st = T.reduce(function(ot, Mt) {
      return ot[Mt.name] = Mt.align, ot;
    }, {});
    for (P = 0; P < w.length; P += 1) {
      "rowStart" in I && I.rowStart instanceof Function && I.rowStart({ row: P, data: w[P] }, this);
      var Je = l.call(this, w[P], Se);
      for (U = 0; U < H.length; U += 1) {
        var ct = w[P][H[U]];
        "cellStart" in I && I.cellStart instanceof Function && I.cellStart({ row: P, col: U, data: ct }, this), c.call(this, new o(_, b, Se[H[U]], Je, ct, P + 2, st[H[U]]));
      }
    }
    return this.internal.__cell__.table_x = _, this.internal.__cell__.table_y = b, this;
  };
  var l = function(_, b) {
    var w = this.internal.__cell__.padding, T = this.internal.__cell__.table_font_size, I = this.internal.scaleFactor;
    return Object.keys(_).map(function(P) {
      var k = _[P];
      return this.splitTextToSize(k.hasOwnProperty("text") ? k.text : k, b[P] - w - w);
    }, this).map(function(P) {
      return this.getLineHeightFactor() * P.length * T / I + w + w;
    }, this).reduce(function(P, k) {
      return Math.max(P, k);
    }, 0);
  };
  n.setTableHeaderRow = function(_) {
    r.call(this), this.internal.__cell__.tableHeaderRow = _;
  }, n.printHeaderRow = function(_, b) {
    if (r.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var w;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var T = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o(T[0], T[1], T[2], T[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var I = [], P = 0; P < this.internal.__cell__.tableHeaderRow.length; P += 1) {
      w = this.internal.__cell__.tableHeaderRow[P].clone(), b && (w.y = this.internal.__cell__.margins.top || 0, I.push(w)), w.lineNumber = _;
      var k = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), c.call(this, w), this.setTextColor(k);
    }
    I.length > 0 && this.setTableHeaderRow(I), this.setFont(void 0, "normal"), t = !1;
  };
}(Bn.API);
var RT = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, OT = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], s1 = BT(OT), DT = [100, 200, 300, 400, 500, 600, 700, 800, 900], vV = BT(DT);
function o1(n) {
  var e = n.family.replace(/"|'/g, "").toLowerCase(), t = function(o) {
    return RT[o = o || "normal"] ? o : "normal";
  }(n.style), r = function(o) {
    if (!o) return 400;
    if (typeof o == "number") return o >= 100 && o <= 900 && o % 100 == 0 ? o : 400;
    if (/^\d00$/.test(o)) return parseInt(o);
    switch (o) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(n.weight), i = function(o) {
    return typeof s1[o = o || "normal"] == "number" ? o : "normal";
  }(n.stretch);
  return { family: e, style: t, weight: r, stretch: i, src: n.src || [], ref: n.ref || { name: e, style: [i, t, r].join(" ") } };
}
function VA(n, e, t, r) {
  var i;
  for (i = t; i >= 0 && i < e.length; i += r) if (n[e[i]]) return n[e[i]];
  for (i = t; i >= 0 && i < e.length; i -= r) if (n[e[i]]) return n[e[i]];
}
var xV = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, qA = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function HA(n) {
  return [n.stretch, n.style, n.weight, n.family].join(" ");
}
function wV(n, e, t) {
  for (var r = (t = t || {}).defaultFontFamily || "times", i = Object.assign({}, xV, t.genericFontFamilies || {}), o = null, c = null, l = 0; l < e.length; ++l) if (i[(o = o1(e[l])).family] && (o.family = i[o.family]), n.hasOwnProperty(o.family)) {
    c = n[o.family];
    break;
  }
  if (!(c = c || n[r])) throw new Error("Could not find a font-family for the rule '" + HA(o) + "' and default family '" + r + "'.");
  if (c = function(_, b) {
    if (b[_]) return b[_];
    var w = s1[_], T = w <= s1.normal ? -1 : 1, I = VA(b, OT, w, T);
    if (!I) throw new Error("Could not find a matching font-stretch value for " + _);
    return I;
  }(o.stretch, c), c = function(_, b) {
    if (b[_]) return b[_];
    for (var w = RT[_], T = 0; T < w.length; ++T) if (b[w[T]]) return b[w[T]];
    throw new Error("Could not find a matching font-style for " + _);
  }(o.style, c), !(c = function(_, b) {
    if (b[_]) return b[_];
    if (_ === 400 && b[500]) return b[500];
    if (_ === 500 && b[400]) return b[400];
    var w = vV[_], T = VA(b, DT, w, _ < 400 ? -1 : 1);
    if (!T) throw new Error("Could not find a matching font-weight for value " + _);
    return T;
  }(o.weight, c))) throw new Error("Failed to resolve a font for the rule '" + HA(o) + "'.");
  return c;
}
function WA(n) {
  return n.trimLeft();
}
function AV(n, e) {
  for (var t = 0; t < n.length; ) {
    if (n.charAt(t) === e) return [n.substring(0, t), n.substring(t + 1)];
    t += 1;
  }
  return null;
}
function SV(n) {
  var e = n.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], n.substring(e[0].length)];
}
var jg, XA, $A, ZA = ["times"];
(function(n) {
  var e, t, r, i, o, c, l, _, b, w = function(re) {
    return re = re || {}, this.isStrokeTransparent = re.isStrokeTransparent || !1, this.strokeOpacity = re.strokeOpacity || 1, this.strokeStyle = re.strokeStyle || "#000000", this.fillStyle = re.fillStyle || "#000000", this.isFillTransparent = re.isFillTransparent || !1, this.fillOpacity = re.fillOpacity || 1, this.font = re.font || "10px sans-serif", this.textBaseline = re.textBaseline || "alphabetic", this.textAlign = re.textAlign || "left", this.lineWidth = re.lineWidth || 1, this.lineJoin = re.lineJoin || "miter", this.lineCap = re.lineCap || "butt", this.path = re.path || [], this.transform = re.transform !== void 0 ? re.transform.clone() : new _(), this.globalCompositeOperation = re.globalCompositeOperation || "normal", this.globalAlpha = re.globalAlpha || 1, this.clip_path = re.clip_path || [], this.currentPoint = re.currentPoint || new c(), this.miterLimit = re.miterLimit || 10, this.lastPoint = re.lastPoint || new c(), this.lineDashOffset = re.lineDashOffset || 0, this.lineDash = re.lineDash || [], this.margin = re.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = re.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof re.ignoreClearRect != "boolean" || re.ignoreClearRect, this;
  };
  n.events.push(["initialized", function() {
    this.context2d = new T(this), e = this.internal.f2, t = this.internal.getCoordinateString, r = this.internal.getVerticalCoordinateString, i = this.internal.getHorizontalCoordinate, o = this.internal.getVerticalCoordinate, c = this.internal.Point, l = this.internal.Rectangle, _ = this.internal.Matrix, b = new w();
  }]);
  var T = function(re) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var Ae = re;
    Object.defineProperty(this, "pdf", { get: function() {
      return Ae;
    } });
    var Ce = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return Ce;
    }, set: function(at) {
      Ce = !!at;
    } });
    var Ue = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Ue;
    }, set: function(at) {
      Ue = !!at;
    } });
    var qe = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return qe;
    }, set: function(at) {
      isNaN(at) || (qe = at);
    } });
    var He = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return He;
    }, set: function(at) {
      isNaN(at) || (He = at);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return b.margin;
    }, set: function(at) {
      var ne;
      typeof at == "number" ? ne = [at, at, at, at] : ((ne = new Array(4))[0] = at[0], ne[1] = at.length >= 2 ? at[1] : ne[0], ne[2] = at.length >= 3 ? at[2] : ne[0], ne[3] = at.length >= 4 ? at[3] : ne[1]), b.margin = ne;
    } });
    var Ye = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return Ye;
    }, set: function(at) {
      Ye = at;
    } });
    var Ze = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Ze;
    }, set: function(at) {
      Ze = at;
    } });
    var St = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return St;
    }, set: function(at) {
      St = at;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return b;
    }, set: function(at) {
      at instanceof w && (b = at);
    } }), Object.defineProperty(this, "path", { get: function() {
      return b.path;
    }, set: function(at) {
      b.path = at;
    } });
    var Lt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Lt;
    }, set: function(at) {
      Lt = at;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(at) {
      var ne;
      ne = I(at), this.ctx.fillStyle = ne.style, this.ctx.isFillTransparent = ne.a === 0, this.ctx.fillOpacity = ne.a, this.pdf.setFillColor(ne.r, ne.g, ne.b, { a: ne.a }), this.pdf.setTextColor(ne.r, ne.g, ne.b, { a: ne.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(at) {
      var ne = I(at);
      this.ctx.strokeStyle = ne.style, this.ctx.isStrokeTransparent = ne.a === 0, this.ctx.strokeOpacity = ne.a, ne.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (ne.a, this.pdf.setDrawColor(ne.r, ne.g, ne.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(at) {
      ["butt", "round", "square"].indexOf(at) !== -1 && (this.ctx.lineCap = at, this.pdf.setLineCap(at));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(at) {
      isNaN(at) || (this.ctx.lineWidth = at, this.pdf.setLineWidth(at));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(at) {
      ["bevel", "round", "miter"].indexOf(at) !== -1 && (this.ctx.lineJoin = at, this.pdf.setLineJoin(at));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(at) {
      isNaN(at) || (this.ctx.miterLimit = at, this.pdf.setMiterLimit(at));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(at) {
      this.ctx.textBaseline = at;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(at) {
      ["right", "end", "center", "left", "start"].indexOf(at) !== -1 && (this.ctx.textAlign = at);
    } });
    var Dt = null;
    function Nt(at, ne) {
      if (Dt === null) {
        var pn = function(Qt) {
          var dt = [];
          return Object.keys(Qt).forEach(function(Et) {
            Qt[Et].forEach(function(Bt) {
              var Ft = null;
              switch (Bt) {
                case "bold":
                  Ft = { family: Et, weight: "bold" };
                  break;
                case "italic":
                  Ft = { family: Et, style: "italic" };
                  break;
                case "bolditalic":
                  Ft = { family: Et, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Ft = { family: Et };
              }
              Ft !== null && (Ft.ref = { name: Et, style: Bt }, dt.push(Ft));
            });
          }), dt;
        }(at.getFontList());
        Dt = function(Qt) {
          for (var dt = {}, Et = 0; Et < Qt.length; ++Et) {
            var Bt = o1(Qt[Et]), Ft = Bt.family, nn = Bt.stretch, Sn = Bt.style, vn = Bt.weight;
            dt[Ft] = dt[Ft] || {}, dt[Ft][nn] = dt[Ft][nn] || {}, dt[Ft][nn][Sn] = dt[Ft][nn][Sn] || {}, dt[Ft][nn][Sn][vn] = Bt;
          }
          return dt;
        }(pn.concat(ne));
      }
      return Dt;
    }
    var an = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return an;
    }, set: function(at) {
      Dt = null, an = at;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(at) {
      var ne;
      if (this.ctx.font = at, (ne = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(at)) !== null) {
        var pn = ne[1], Qt = (ne[2], ne[3]), dt = ne[4], Et = (ne[5], ne[6]), Bt = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(dt)[2];
        dt = Math.floor(Bt === "px" ? parseFloat(dt) * this.pdf.internal.scaleFactor : Bt === "em" ? parseFloat(dt) * this.pdf.getFontSize() : parseFloat(dt) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(dt);
        var Ft = function(un) {
          var xn, Ot, _r = [], mt = un.trim();
          if (mt === "") return ZA;
          if (mt in qA) return [qA[mt]];
          for (; mt !== ""; ) {
            switch (Ot = null, xn = (mt = WA(mt)).charAt(0)) {
              case '"':
              case "'":
                Ot = AV(mt.substring(1), xn);
                break;
              default:
                Ot = SV(mt);
            }
            if (Ot === null || (_r.push(Ot[0]), (mt = WA(Ot[1])) !== "" && mt.charAt(0) !== ",")) return ZA;
            mt = mt.replace(/^,/, "");
          }
          return _r;
        }(Et);
        if (this.fontFaces) {
          var nn = wV(Nt(this.pdf, this.fontFaces), Ft.map(function(un) {
            return { family: un, stretch: "normal", weight: Qt, style: pn };
          }));
          this.pdf.setFont(nn.ref.name, nn.ref.style);
        } else {
          var Sn = "";
          (Qt === "bold" || parseInt(Qt, 10) >= 700 || pn === "bold") && (Sn = "bold"), pn === "italic" && (Sn += "italic"), Sn.length === 0 && (Sn = "normal");
          for (var vn = "", On = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Un = 0; Un < Ft.length; Un++) {
            if (this.pdf.internal.getFont(Ft[Un], Sn, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              vn = Ft[Un];
              break;
            }
            if (Sn === "bolditalic" && this.pdf.internal.getFont(Ft[Un], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) vn = Ft[Un], Sn = "bold";
            else if (this.pdf.internal.getFont(Ft[Un], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              vn = Ft[Un], Sn = "normal";
              break;
            }
          }
          if (vn === "") {
            for (var gt = 0; gt < Ft.length; gt++) if (On[Ft[gt]]) {
              vn = On[Ft[gt]];
              break;
            }
          }
          vn = vn === "" ? "Times" : vn, this.pdf.setFont(vn, Sn);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(at) {
      this.ctx.globalCompositeOperation = at;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(at) {
      this.ctx.globalAlpha = at;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(at) {
      this.ctx.lineDashOffset = at, Mt.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(at) {
      this.ctx.lineDash = at, Mt.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(at) {
      this.ctx.ignoreClearRect = !!at;
    } });
  };
  T.prototype.setLineDash = function(re) {
    this.lineDash = re;
  }, T.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, T.prototype.fill = function() {
    ge.call(this, "fill", !1);
  }, T.prototype.stroke = function() {
    ge.call(this, "stroke", !1);
  }, T.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, T.prototype.moveTo = function(re, Ae) {
    if (isNaN(re) || isNaN(Ae)) throw $r.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var Ce = this.ctx.transform.applyToPoint(new c(re, Ae));
    this.path.push({ type: "mt", x: Ce.x, y: Ce.y }), this.ctx.lastPoint = new c(re, Ae);
  }, T.prototype.closePath = function() {
    var re = new c(0, 0), Ae = 0;
    for (Ae = this.path.length - 1; Ae !== -1; Ae--) if (this.path[Ae].type === "begin" && zr(this.path[Ae + 1]) === "object" && typeof this.path[Ae + 1].x == "number") {
      re = new c(this.path[Ae + 1].x, this.path[Ae + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c(re.x, re.y);
  }, T.prototype.lineTo = function(re, Ae) {
    if (isNaN(re) || isNaN(Ae)) throw $r.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var Ce = this.ctx.transform.applyToPoint(new c(re, Ae));
    this.path.push({ type: "lt", x: Ce.x, y: Ce.y }), this.ctx.lastPoint = new c(Ce.x, Ce.y);
  }, T.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), ge.call(this, null, !0);
  }, T.prototype.quadraticCurveTo = function(re, Ae, Ce, Ue) {
    if (isNaN(Ce) || isNaN(Ue) || isNaN(re) || isNaN(Ae)) throw $r.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var qe = this.ctx.transform.applyToPoint(new c(Ce, Ue)), He = this.ctx.transform.applyToPoint(new c(re, Ae));
    this.path.push({ type: "qct", x1: He.x, y1: He.y, x: qe.x, y: qe.y }), this.ctx.lastPoint = new c(qe.x, qe.y);
  }, T.prototype.bezierCurveTo = function(re, Ae, Ce, Ue, qe, He) {
    if (isNaN(qe) || isNaN(He) || isNaN(re) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue)) throw $r.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var Ye = this.ctx.transform.applyToPoint(new c(qe, He)), Ze = this.ctx.transform.applyToPoint(new c(re, Ae)), St = this.ctx.transform.applyToPoint(new c(Ce, Ue));
    this.path.push({ type: "bct", x1: Ze.x, y1: Ze.y, x2: St.x, y2: St.y, x: Ye.x, y: Ye.y }), this.ctx.lastPoint = new c(Ye.x, Ye.y);
  }, T.prototype.arc = function(re, Ae, Ce, Ue, qe, He) {
    if (isNaN(re) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue) || isNaN(qe)) throw $r.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (He = !!He, !this.ctx.transform.isIdentity) {
      var Ye = this.ctx.transform.applyToPoint(new c(re, Ae));
      re = Ye.x, Ae = Ye.y;
      var Ze = this.ctx.transform.applyToPoint(new c(0, Ce)), St = this.ctx.transform.applyToPoint(new c(0, 0));
      Ce = Math.sqrt(Math.pow(Ze.x - St.x, 2) + Math.pow(Ze.y - St.y, 2));
    }
    Math.abs(qe - Ue) >= 2 * Math.PI && (Ue = 0, qe = 2 * Math.PI), this.path.push({ type: "arc", x: re, y: Ae, radius: Ce, startAngle: Ue, endAngle: qe, counterclockwise: He });
  }, T.prototype.arcTo = function(re, Ae, Ce, Ue, qe) {
    throw new Error("arcTo not implemented.");
  }, T.prototype.rect = function(re, Ae, Ce, Ue) {
    if (isNaN(re) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue)) throw $r.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(re, Ae), this.lineTo(re + Ce, Ae), this.lineTo(re + Ce, Ae + Ue), this.lineTo(re, Ae + Ue), this.lineTo(re, Ae), this.lineTo(re + Ce, Ae), this.lineTo(re, Ae);
  }, T.prototype.fillRect = function(re, Ae, Ce, Ue) {
    if (isNaN(re) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue)) throw $r.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!P.call(this)) {
      var qe = {};
      this.lineCap !== "butt" && (qe.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (qe.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(re, Ae, Ce, Ue), this.fill(), qe.hasOwnProperty("lineCap") && (this.lineCap = qe.lineCap), qe.hasOwnProperty("lineJoin") && (this.lineJoin = qe.lineJoin);
    }
  }, T.prototype.strokeRect = function(re, Ae, Ce, Ue) {
    if (isNaN(re) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue)) throw $r.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    k.call(this) || (this.beginPath(), this.rect(re, Ae, Ce, Ue), this.stroke());
  }, T.prototype.clearRect = function(re, Ae, Ce, Ue) {
    if (isNaN(re) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue)) throw $r.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(re, Ae, Ce, Ue));
  }, T.prototype.save = function(re) {
    re = typeof re != "boolean" || re;
    for (var Ae = this.pdf.internal.getCurrentPageInfo().pageNumber, Ce = 0; Ce < this.pdf.internal.getNumberOfPages(); Ce++) this.pdf.setPage(Ce + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(Ae), re) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Ue = new w(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Ue;
    }
  }, T.prototype.restore = function(re) {
    re = typeof re != "boolean" || re;
    for (var Ae = this.pdf.internal.getCurrentPageInfo().pageNumber, Ce = 0; Ce < this.pdf.internal.getNumberOfPages(); Ce++) this.pdf.setPage(Ce + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(Ae), re && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, T.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var I = function(re) {
    var Ae, Ce, Ue, qe;
    if (re.isCanvasGradient === !0 && (re = re.getColor()), !re) return { r: 0, g: 0, b: 0, a: 0, style: re };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(re)) Ae = 0, Ce = 0, Ue = 0, qe = 0;
    else {
      var He = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(re);
      if (He !== null) Ae = parseInt(He[1]), Ce = parseInt(He[2]), Ue = parseInt(He[3]), qe = 1;
      else if ((He = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(re)) !== null) Ae = parseInt(He[1]), Ce = parseInt(He[2]), Ue = parseInt(He[3]), qe = parseFloat(He[4]);
      else {
        if (qe = 1, typeof re == "string" && re.charAt(0) !== "#") {
          var Ye = new TT(re);
          re = Ye.ok ? Ye.toHex() : "#000000";
        }
        re.length === 4 ? (Ae = re.substring(1, 2), Ae += Ae, Ce = re.substring(2, 3), Ce += Ce, Ue = re.substring(3, 4), Ue += Ue) : (Ae = re.substring(1, 3), Ce = re.substring(3, 5), Ue = re.substring(5, 7)), Ae = parseInt(Ae, 16), Ce = parseInt(Ce, 16), Ue = parseInt(Ue, 16);
      }
    }
    return { r: Ae, g: Ce, b: Ue, a: qe, style: re };
  }, P = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, k = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  T.prototype.fillText = function(re, Ae, Ce, Ue) {
    if (isNaN(Ae) || isNaN(Ce) || typeof re != "string") throw $r.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Ue = isNaN(Ue) ? void 0 : Ue, !P.call(this)) {
      var qe = Je(this.ctx.transform.rotation), He = this.ctx.transform.scaleX;
      pe.call(this, { text: re, x: Ae, y: Ce, scale: He, angle: qe, align: this.textAlign, maxWidth: Ue });
    }
  }, T.prototype.strokeText = function(re, Ae, Ce, Ue) {
    if (isNaN(Ae) || isNaN(Ce) || typeof re != "string") throw $r.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!k.call(this)) {
      Ue = isNaN(Ue) ? void 0 : Ue;
      var qe = Je(this.ctx.transform.rotation), He = this.ctx.transform.scaleX;
      pe.call(this, { text: re, x: Ae, y: Ce, scale: He, renderingMode: "stroke", angle: qe, align: this.textAlign, maxWidth: Ue });
    }
  }, T.prototype.measureText = function(re) {
    if (typeof re != "string") throw $r.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var Ae = this.pdf, Ce = this.pdf.internal.scaleFactor, Ue = Ae.internal.getFontSize(), qe = Ae.getStringUnitWidth(re) * Ue / Ae.internal.scaleFactor, He = function(Ye) {
      var Ze = (Ye = Ye || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Ze;
      } }), this;
    };
    return new He({ width: qe *= Math.round(96 * Ce / 72 * 1e4) / 1e4 });
  }, T.prototype.scale = function(re, Ae) {
    if (isNaN(re) || isNaN(Ae)) throw $r.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var Ce = new _(re, 0, 0, Ae, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Ce);
  }, T.prototype.rotate = function(re) {
    if (isNaN(re)) throw $r.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var Ae = new _(Math.cos(re), Math.sin(re), -Math.sin(re), Math.cos(re), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Ae);
  }, T.prototype.translate = function(re, Ae) {
    if (isNaN(re) || isNaN(Ae)) throw $r.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var Ce = new _(1, 0, 0, 1, re, Ae);
    this.ctx.transform = this.ctx.transform.multiply(Ce);
  }, T.prototype.transform = function(re, Ae, Ce, Ue, qe, He) {
    if (isNaN(re) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue) || isNaN(qe) || isNaN(He)) throw $r.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var Ye = new _(re, Ae, Ce, Ue, qe, He);
    this.ctx.transform = this.ctx.transform.multiply(Ye);
  }, T.prototype.setTransform = function(re, Ae, Ce, Ue, qe, He) {
    re = isNaN(re) ? 1 : re, Ae = isNaN(Ae) ? 0 : Ae, Ce = isNaN(Ce) ? 0 : Ce, Ue = isNaN(Ue) ? 1 : Ue, qe = isNaN(qe) ? 0 : qe, He = isNaN(He) ? 0 : He, this.ctx.transform = new _(re, Ae, Ce, Ue, qe, He);
  };
  var U = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  T.prototype.drawImage = function(re, Ae, Ce, Ue, qe, He, Ye, Ze, St) {
    var Lt = this.pdf.getImageProperties(re), Dt = 1, Nt = 1, an = 1, at = 1;
    Ue !== void 0 && Ze !== void 0 && (an = Ze / Ue, at = St / qe, Dt = Lt.width / Ue * Ze / Ue, Nt = Lt.height / qe * St / qe), He === void 0 && (He = Ae, Ye = Ce, Ae = 0, Ce = 0), Ue !== void 0 && Ze === void 0 && (Ze = Ue, St = qe), Ue === void 0 && Ze === void 0 && (Ze = Lt.width, St = Lt.height);
    for (var ne, pn = this.ctx.transform.decompose(), Qt = Je(pn.rotate.shx), dt = new _(), Et = (dt = (dt = (dt = dt.multiply(pn.translate)).multiply(pn.skew)).multiply(pn.scale)).applyToRectangle(new l(He - Ae * an, Ye - Ce * at, Ue * Dt, qe * Nt)), Bt = G.call(this, Et), Ft = [], nn = 0; nn < Bt.length; nn += 1) Ft.indexOf(Bt[nn]) === -1 && Ft.push(Bt[nn]);
    if (ie(Ft), this.autoPaging) for (var Sn = Ft[0], vn = Ft[Ft.length - 1], On = Sn; On < vn + 1; On++) {
      this.pdf.setPage(On);
      var Un = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], gt = On === 1 ? this.posY + this.margin[0] : this.margin[0], un = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], xn = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Ot = On === 1 ? 0 : un + (On - 2) * xn;
      if (this.ctx.clip_path.length !== 0) {
        var _r = this.path;
        ne = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = $(ne, this.posX + this.margin[3], -Ot + gt + this.ctx.prevPageLastElemOffset), Se.call(this, "fill", !0), this.path = _r;
      }
      var mt = JSON.parse(JSON.stringify(Et));
      mt = $([mt], this.posX + this.margin[3], -Ot + gt + this.ctx.prevPageLastElemOffset)[0];
      var bn = (On > Sn || On < vn) && U.call(this);
      bn && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Un, xn, null).clip().discardPath()), this.pdf.addImage(re, "JPEG", mt.x, mt.y, mt.w, mt.h, null, null, Qt), bn && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(re, "JPEG", Et.x, Et.y, Et.w, Et.h, null, null, Qt);
  };
  var G = function(re, Ae, Ce) {
    var Ue = [];
    Ae = Ae || this.pdf.internal.pageSize.width, Ce = Ce || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var qe = this.posY + this.ctx.prevPageLastElemOffset;
    switch (re.type) {
      default:
      case "mt":
      case "lt":
        Ue.push(Math.floor((re.y + qe) / Ce) + 1);
        break;
      case "arc":
        Ue.push(Math.floor((re.y + qe - re.radius) / Ce) + 1), Ue.push(Math.floor((re.y + qe + re.radius) / Ce) + 1);
        break;
      case "qct":
        var He = ct(this.ctx.lastPoint.x, this.ctx.lastPoint.y, re.x1, re.y1, re.x, re.y);
        Ue.push(Math.floor((He.y + qe) / Ce) + 1), Ue.push(Math.floor((He.y + He.h + qe) / Ce) + 1);
        break;
      case "bct":
        var Ye = ot(this.ctx.lastPoint.x, this.ctx.lastPoint.y, re.x1, re.y1, re.x2, re.y2, re.x, re.y);
        Ue.push(Math.floor((Ye.y + qe) / Ce) + 1), Ue.push(Math.floor((Ye.y + Ye.h + qe) / Ce) + 1);
        break;
      case "rect":
        Ue.push(Math.floor((re.y + qe) / Ce) + 1), Ue.push(Math.floor((re.y + re.h + qe) / Ce) + 1);
    }
    for (var Ze = 0; Ze < Ue.length; Ze += 1) for (; this.pdf.internal.getNumberOfPages() < Ue[Ze]; ) H.call(this);
    return Ue;
  }, H = function() {
    var re = this.fillStyle, Ae = this.strokeStyle, Ce = this.font, Ue = this.lineCap, qe = this.lineWidth, He = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = re, this.strokeStyle = Ae, this.font = Ce, this.lineCap = Ue, this.lineWidth = qe, this.lineJoin = He;
  }, $ = function(re, Ae, Ce) {
    for (var Ue = 0; Ue < re.length; Ue++) switch (re[Ue].type) {
      case "bct":
        re[Ue].x2 += Ae, re[Ue].y2 += Ce;
      case "qct":
        re[Ue].x1 += Ae, re[Ue].y1 += Ce;
      case "mt":
      case "lt":
      case "arc":
      default:
        re[Ue].x += Ae, re[Ue].y += Ce;
    }
    return re;
  }, ie = function(re) {
    return re.sort(function(Ae, Ce) {
      return Ae - Ce;
    });
  }, ge = function(re, Ae) {
    for (var Ce, Ue, qe = this.fillStyle, He = this.strokeStyle, Ye = this.lineCap, Ze = this.lineWidth, St = Math.abs(Ze * this.ctx.transform.scaleX), Lt = this.lineJoin, Dt = JSON.parse(JSON.stringify(this.path)), Nt = JSON.parse(JSON.stringify(this.path)), an = [], at = 0; at < Nt.length; at++) if (Nt[at].x !== void 0) for (var ne = G.call(this, Nt[at]), pn = 0; pn < ne.length; pn += 1) an.indexOf(ne[pn]) === -1 && an.push(ne[pn]);
    for (var Qt = 0; Qt < an.length; Qt++) for (; this.pdf.internal.getNumberOfPages() < an[Qt]; ) H.call(this);
    if (ie(an), this.autoPaging) for (var dt = an[0], Et = an[an.length - 1], Bt = dt; Bt < Et + 1; Bt++) {
      this.pdf.setPage(Bt), this.fillStyle = qe, this.strokeStyle = He, this.lineCap = Ye, this.lineWidth = St, this.lineJoin = Lt;
      var Ft = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], nn = Bt === 1 ? this.posY + this.margin[0] : this.margin[0], Sn = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], vn = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], On = Bt === 1 ? 0 : Sn + (Bt - 2) * vn;
      if (this.ctx.clip_path.length !== 0) {
        var Un = this.path;
        Ce = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = $(Ce, this.posX + this.margin[3], -On + nn + this.ctx.prevPageLastElemOffset), Se.call(this, re, !0), this.path = Un;
      }
      if (Ue = JSON.parse(JSON.stringify(Dt)), this.path = $(Ue, this.posX + this.margin[3], -On + nn + this.ctx.prevPageLastElemOffset), Ae === !1 || Bt === 0) {
        var gt = (Bt > dt || Bt < Et) && U.call(this);
        gt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ft, vn, null).clip().discardPath()), Se.call(this, re, Ae), gt && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Ze;
    }
    else this.lineWidth = St, Se.call(this, re, Ae), this.lineWidth = Ze;
    this.path = Dt;
  }, Se = function(re, Ae) {
    if ((re !== "stroke" || Ae || !k.call(this)) && (re === "stroke" || Ae || !P.call(this))) {
      for (var Ce, Ue, qe = [], He = this.path, Ye = 0; Ye < He.length; Ye++) {
        var Ze = He[Ye];
        switch (Ze.type) {
          case "begin":
            qe.push({ begin: !0 });
            break;
          case "close":
            qe.push({ close: !0 });
            break;
          case "mt":
            qe.push({ start: Ze, deltas: [], abs: [] });
            break;
          case "lt":
            var St = qe.length;
            if (He[Ye - 1] && !isNaN(He[Ye - 1].x) && (Ce = [Ze.x - He[Ye - 1].x, Ze.y - He[Ye - 1].y], St > 0)) {
              for (; St >= 0; St--) if (qe[St - 1].close !== !0 && qe[St - 1].begin !== !0) {
                qe[St - 1].deltas.push(Ce), qe[St - 1].abs.push(Ze);
                break;
              }
            }
            break;
          case "bct":
            Ce = [Ze.x1 - He[Ye - 1].x, Ze.y1 - He[Ye - 1].y, Ze.x2 - He[Ye - 1].x, Ze.y2 - He[Ye - 1].y, Ze.x - He[Ye - 1].x, Ze.y - He[Ye - 1].y], qe[qe.length - 1].deltas.push(Ce);
            break;
          case "qct":
            var Lt = He[Ye - 1].x + 2 / 3 * (Ze.x1 - He[Ye - 1].x), Dt = He[Ye - 1].y + 2 / 3 * (Ze.y1 - He[Ye - 1].y), Nt = Ze.x + 2 / 3 * (Ze.x1 - Ze.x), an = Ze.y + 2 / 3 * (Ze.y1 - Ze.y), at = Ze.x, ne = Ze.y;
            Ce = [Lt - He[Ye - 1].x, Dt - He[Ye - 1].y, Nt - He[Ye - 1].x, an - He[Ye - 1].y, at - He[Ye - 1].x, ne - He[Ye - 1].y], qe[qe.length - 1].deltas.push(Ce);
            break;
          case "arc":
            qe.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(qe[qe.length - 1].abs) && qe[qe.length - 1].abs.push(Ze);
        }
      }
      Ue = Ae ? null : re === "stroke" ? "stroke" : "fill";
      for (var pn = !1, Qt = 0; Qt < qe.length; Qt++) if (qe[Qt].arc) for (var dt = qe[Qt].abs, Et = 0; Et < dt.length; Et++) {
        var Bt = dt[Et];
        Bt.type === "arc" ? _e.call(this, Bt.x, Bt.y, Bt.radius, Bt.startAngle, Bt.endAngle, Bt.counterclockwise, void 0, Ae, !pn) : Te.call(this, Bt.x, Bt.y), pn = !0;
      }
      else if (qe[Qt].close === !0) this.pdf.internal.out("h"), pn = !1;
      else if (qe[Qt].begin !== !0) {
        var Ft = qe[Qt].start.x, nn = qe[Qt].start.y;
        xe.call(this, qe[Qt].deltas, Ft, nn), pn = !0;
      }
      Ue && Ge.call(this, Ue), Ae && ke.call(this);
    }
  }, Re = function(re) {
    var Ae = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, Ce = Ae * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return re - Ce;
      case "top":
        return re + Ae - Ce;
      case "hanging":
        return re + Ae - 2 * Ce;
      case "middle":
        return re + Ae / 2 - Ce;
      case "ideographic":
        return re;
      case "alphabetic":
      default:
        return re;
    }
  }, Le = function(re) {
    return re + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  T.prototype.createLinearGradient = function() {
    var re = function() {
    };
    return re.colorStops = [], re.addColorStop = function(Ae, Ce) {
      this.colorStops.push([Ae, Ce]);
    }, re.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, re.isCanvasGradient = !0, re;
  }, T.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, T.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var _e = function(re, Ae, Ce, Ue, qe, He, Ye, Ze, St) {
    for (var Lt = rt.call(this, Ce, Ue, qe, He), Dt = 0; Dt < Lt.length; Dt++) {
      var Nt = Lt[Dt];
      Dt === 0 && (St ? oe.call(this, Nt.x1 + re, Nt.y1 + Ae) : Te.call(this, Nt.x1 + re, Nt.y1 + Ae)), et.call(this, re, Ae, Nt.x2, Nt.y2, Nt.x3, Nt.y3, Nt.x4, Nt.y4);
    }
    Ze ? ke.call(this) : Ge.call(this, Ye);
  }, Ge = function(re) {
    switch (re) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ke = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, oe = function(re, Ae) {
    this.pdf.internal.out(t(re) + " " + r(Ae) + " m");
  }, pe = function(re) {
    var Ae;
    switch (re.align) {
      case "right":
      case "end":
        Ae = "right";
        break;
      case "center":
        Ae = "center";
        break;
      case "left":
      case "start":
      default:
        Ae = "left";
    }
    var Ce = this.pdf.getTextDimensions(re.text), Ue = Re.call(this, re.y), qe = Le.call(this, Ue) - Ce.h, He = this.ctx.transform.applyToPoint(new c(re.x, Ue)), Ye = this.ctx.transform.decompose(), Ze = new _();
    Ze = (Ze = (Ze = Ze.multiply(Ye.translate)).multiply(Ye.skew)).multiply(Ye.scale);
    for (var St, Lt, Dt, Nt = this.ctx.transform.applyToRectangle(new l(re.x, Ue, Ce.w, Ce.h)), an = Ze.applyToRectangle(new l(re.x, qe, Ce.w, Ce.h)), at = G.call(this, an), ne = [], pn = 0; pn < at.length; pn += 1) ne.indexOf(at[pn]) === -1 && ne.push(at[pn]);
    if (ie(ne), this.autoPaging) for (var Qt = ne[0], dt = ne[ne.length - 1], Et = Qt; Et < dt + 1; Et++) {
      this.pdf.setPage(Et);
      var Bt = Et === 1 ? this.posY + this.margin[0] : this.margin[0], Ft = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], nn = this.pdf.internal.pageSize.height - this.margin[2], Sn = nn - this.margin[0], vn = this.pdf.internal.pageSize.width - this.margin[1], On = vn - this.margin[3], Un = Et === 1 ? 0 : Ft + (Et - 2) * Sn;
      if (this.ctx.clip_path.length !== 0) {
        var gt = this.path;
        St = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = $(St, this.posX + this.margin[3], -1 * Un + Bt), Se.call(this, "fill", !0), this.path = gt;
      }
      var un = $([JSON.parse(JSON.stringify(an))], this.posX + this.margin[3], -Un + Bt + this.ctx.prevPageLastElemOffset)[0];
      re.scale >= 0.01 && (Lt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Lt * re.scale), Dt = this.lineWidth, this.lineWidth = Dt * re.scale);
      var xn = this.autoPaging !== "text";
      if (xn || un.y + un.h <= nn) {
        if (xn || un.y >= Bt && un.x <= vn) {
          var Ot = xn ? re.text : this.pdf.splitTextToSize(re.text, re.maxWidth || vn - un.x)[0], _r = $([JSON.parse(JSON.stringify(Nt))], this.posX + this.margin[3], -Un + Bt + this.ctx.prevPageLastElemOffset)[0], mt = xn && (Et > Qt || Et < dt) && U.call(this);
          mt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], On, Sn, null).clip().discardPath()), this.pdf.text(Ot, _r.x, _r.y, { angle: re.angle, align: Ae, renderingMode: re.renderingMode }), mt && this.pdf.restoreGraphicsState();
        }
      } else un.y < nn && (this.ctx.prevPageLastElemOffset += nn - un.y);
      re.scale >= 0.01 && (this.pdf.setFontSize(Lt), this.lineWidth = Dt);
    }
    else re.scale >= 0.01 && (Lt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Lt * re.scale), Dt = this.lineWidth, this.lineWidth = Dt * re.scale), this.pdf.text(re.text, He.x + this.posX, He.y + this.posY, { angle: re.angle, align: Ae, renderingMode: re.renderingMode, maxWidth: re.maxWidth }), re.scale >= 0.01 && (this.pdf.setFontSize(Lt), this.lineWidth = Dt);
  }, Te = function(re, Ae, Ce, Ue) {
    Ce = Ce || 0, Ue = Ue || 0, this.pdf.internal.out(t(re + Ce) + " " + r(Ae + Ue) + " l");
  }, xe = function(re, Ae, Ce) {
    return this.pdf.lines(re, Ae, Ce, null, null);
  }, et = function(re, Ae, Ce, Ue, qe, He, Ye, Ze) {
    this.pdf.internal.out([e(i(Ce + re)), e(o(Ue + Ae)), e(i(qe + re)), e(o(He + Ae)), e(i(Ye + re)), e(o(Ze + Ae)), "c"].join(" "));
  }, rt = function(re, Ae, Ce, Ue) {
    for (var qe = 2 * Math.PI, He = Math.PI / 2; Ae > Ce; ) Ae -= qe;
    var Ye = Math.abs(Ce - Ae);
    Ye < qe && Ue && (Ye = qe - Ye);
    for (var Ze = [], St = Ue ? -1 : 1, Lt = Ae; Ye > 1e-5; ) {
      var Dt = Lt + St * Math.min(Ye, He);
      Ze.push(st.call(this, re, Lt, Dt)), Ye -= Math.abs(Dt - Lt), Lt = Dt;
    }
    return Ze;
  }, st = function(re, Ae, Ce) {
    var Ue = (Ce - Ae) / 2, qe = re * Math.cos(Ue), He = re * Math.sin(Ue), Ye = qe, Ze = -He, St = Ye * Ye + Ze * Ze, Lt = St + Ye * qe + Ze * He, Dt = 4 / 3 * (Math.sqrt(2 * St * Lt) - Lt) / (Ye * He - Ze * qe), Nt = Ye - Dt * Ze, an = Ze + Dt * Ye, at = Nt, ne = -an, pn = Ue + Ae, Qt = Math.cos(pn), dt = Math.sin(pn);
    return { x1: re * Math.cos(Ae), y1: re * Math.sin(Ae), x2: Nt * Qt - an * dt, y2: Nt * dt + an * Qt, x3: at * Qt - ne * dt, y3: at * dt + ne * Qt, x4: re * Math.cos(Ce), y4: re * Math.sin(Ce) };
  }, Je = function(re) {
    return 180 * re / Math.PI;
  }, ct = function(re, Ae, Ce, Ue, qe, He) {
    var Ye = re + 0.5 * (Ce - re), Ze = Ae + 0.5 * (Ue - Ae), St = qe + 0.5 * (Ce - qe), Lt = He + 0.5 * (Ue - He), Dt = Math.min(re, qe, Ye, St), Nt = Math.max(re, qe, Ye, St), an = Math.min(Ae, He, Ze, Lt), at = Math.max(Ae, He, Ze, Lt);
    return new l(Dt, an, Nt - Dt, at - an);
  }, ot = function(re, Ae, Ce, Ue, qe, He, Ye, Ze) {
    var St, Lt, Dt, Nt, an, at, ne, pn, Qt, dt, Et, Bt, Ft, nn, Sn = Ce - re, vn = Ue - Ae, On = qe - Ce, Un = He - Ue, gt = Ye - qe, un = Ze - He;
    for (Lt = 0; Lt < 41; Lt++) Qt = (ne = (Dt = re + (St = Lt / 40) * Sn) + St * ((an = Ce + St * On) - Dt)) + St * (an + St * (qe + St * gt - an) - ne), dt = (pn = (Nt = Ae + St * vn) + St * ((at = Ue + St * Un) - Nt)) + St * (at + St * (He + St * un - at) - pn), Lt == 0 ? (Et = Qt, Bt = dt, Ft = Qt, nn = dt) : (Et = Math.min(Et, Qt), Bt = Math.min(Bt, dt), Ft = Math.max(Ft, Qt), nn = Math.max(nn, dt));
    return new l(Math.round(Et), Math.round(Bt), Math.round(Ft - Et), Math.round(nn - Bt));
  }, Mt = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var re, Ae, Ce = (re = this.ctx.lineDash, Ae = this.ctx.lineDashOffset, JSON.stringify({ lineDash: re, lineDashOffset: Ae }));
      this.prevLineDash !== Ce && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = Ce);
    }
  };
})(Bn.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(o) {
    var c, l, _, b, w, T, I, P, k, U;
    for (l = [], _ = 0, b = (o += c = "\0\0\0\0".slice(o.length % 4 || 4)).length; b > _; _ += 4) (w = (o.charCodeAt(_) << 24) + (o.charCodeAt(_ + 1) << 16) + (o.charCodeAt(_ + 2) << 8) + o.charCodeAt(_ + 3)) !== 0 ? (T = (w = ((w = ((w = ((w = (w - (U = w % 85)) / 85) - (k = w % 85)) / 85) - (P = w % 85)) / 85) - (I = w % 85)) / 85) % 85, l.push(T + 33, I + 33, P + 33, k + 33, U + 33)) : l.push(122);
    return function(G, H) {
      for (var $ = H; $ > 0; $--) G.pop();
    }(l, c.length), String.fromCharCode.apply(String, l) + "~>";
  }, t = function(o) {
    var c, l, _, b, w, T = String, I = "length", P = 255, k = "charCodeAt", U = "slice", G = "replace";
    for (o[U](-2), o = o[U](0, -2)[G](/\s/g, "")[G]("z", "!!!!!"), _ = [], b = 0, w = (o += c = "uuuuu"[U](o[I] % 5 || 5))[I]; w > b; b += 5) l = 52200625 * (o[k](b) - 33) + 614125 * (o[k](b + 1) - 33) + 7225 * (o[k](b + 2) - 33) + 85 * (o[k](b + 3) - 33) + (o[k](b + 4) - 33), _.push(P & l >> 24, P & l >> 16, P & l >> 8, P & l);
    return function(H, $) {
      for (var ie = $; ie > 0; ie--) H.pop();
    }(_, c[I]), T.fromCharCode.apply(T, _);
  }, r = function(o) {
    var c = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((o = o.replace(/\s/g, "")).indexOf(">") !== -1 && (o = o.substr(0, o.indexOf(">"))), o.length % 2 && (o += "0"), c.test(o) === !1) return "";
    for (var l = "", _ = 0; _ < o.length; _ += 2) l += String.fromCharCode("0x" + (o[_] + o[_ + 1]));
    return l;
  }, i = function(o) {
    for (var c = new Uint8Array(o.length), l = o.length; l--; ) c[l] = o.charCodeAt(l);
    return o = (c = e1(c)).reduce(function(_, b) {
      return _ + String.fromCharCode(b);
    }, "");
  };
  n.processDataByFilters = function(o, c) {
    var l = 0, _ = o || "", b = [];
    for (typeof (c = c || []) == "string" && (c = [c]), l = 0; l < c.length; l += 1) switch (c[l]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        _ = t(_), b.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        _ = e(_), b.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        _ = r(_), b.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        _ = _.split("").map(function(w) {
          return ("0" + w.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", b.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        _ = i(_), b.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + c[l] + '" is not implemented');
    }
    return { data: _, reverseChain: b.reverse().join(" ") };
  };
}(Bn.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.loadFile = function(e, t, r) {
    return function(i, o, c) {
      o = o !== !1, c = typeof c == "function" ? c : function() {
      };
      var l = void 0;
      try {
        l = function(_, b, w) {
          var T = new XMLHttpRequest(), I = 0, P = function(k) {
            var U = k.length, G = [], H = String.fromCharCode;
            for (I = 0; I < U; I += 1) G.push(H(255 & k.charCodeAt(I)));
            return G.join("");
          };
          if (T.open("GET", _, !b), T.overrideMimeType("text/plain; charset=x-user-defined"), b === !1 && (T.onload = function() {
            T.status === 200 ? w(P(this.responseText)) : w(void 0);
          }), T.send(null), b && T.status === 200) return P(T.responseText);
        }(i, o, c);
      } catch {
      }
      return l;
    }(e, t, r);
  }, n.loadImageFile = n.loadFile;
}(Bn.API), function(n) {
  function e() {
    return (Rn.html2canvas ? Promise.resolve(Rn.html2canvas) : import("./html2canvas.esm-CKxSAI8P-DLLJDLZD.mjs")).catch(function(c) {
      return Promise.reject(new Error("Could not load html2canvas: " + c));
    }).then(function(c) {
      return c.default ? c.default : c;
    });
  }
  function t() {
    return (Rn.DOMPurify ? Promise.resolve(Rn.DOMPurify) : import("./purify.es-CLxMp-4V-DQ4yGNUw.mjs")).catch(function(c) {
      return Promise.reject(new Error("Could not load dompurify: " + c));
    }).then(function(c) {
      return c.default ? c.default : c;
    });
  }
  var r = function(c) {
    var l = zr(c);
    return l === "undefined" ? "undefined" : l === "string" || c instanceof String ? "string" : l === "number" || c instanceof Number ? "number" : l === "function" || c instanceof Function ? "function" : c && c.constructor === Array ? "array" : c && c.nodeType === 1 ? "element" : l === "object" ? "object" : "unknown";
  }, i = function(c, l) {
    var _ = document.createElement(c);
    for (var b in l.className && (_.className = l.className), l.innerHTML && l.dompurify && (_.innerHTML = l.dompurify.sanitize(l.innerHTML)), l.style) _.style[b] = l.style[b];
    return _;
  }, o = function c(l) {
    var _ = Object.assign(c.convert(Promise.resolve()), JSON.parse(JSON.stringify(c.template))), b = c.convert(Promise.resolve(), _);
    return b = (b = b.setProgress(1, c, 1, [c])).set(l);
  };
  (o.prototype = Object.create(Promise.prototype)).constructor = o, o.convert = function(c, l) {
    return c.__proto__ = l || o.prototype, c;
  }, o.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, o.prototype.from = function(c, l) {
    return this.then(function() {
      switch (l = l || function(_) {
        switch (r(_)) {
          case "string":
            return "string";
          case "element":
            return _.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(c)) {
        case "string":
          return this.then(t).then(function(_) {
            return this.set({ src: i("div", { innerHTML: c, dompurify: _ }) });
          });
        case "element":
          return this.set({ src: c });
        case "canvas":
          return this.set({ canvas: c });
        case "img":
          return this.set({ img: c });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, o.prototype.to = function(c) {
    switch (c) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, o.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var c = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, l = function _(b, w) {
        for (var T = b.nodeType === 3 ? document.createTextNode(b.nodeValue) : b.cloneNode(!1), I = b.firstChild; I; I = I.nextSibling) w !== !0 && I.nodeType === 1 && I.nodeName === "SCRIPT" || T.appendChild(_(I, w));
        return b.nodeType === 1 && (b.nodeName === "CANVAS" ? (T.width = b.width, T.height = b.height, T.getContext("2d").drawImage(b, 0, 0)) : b.nodeName !== "TEXTAREA" && b.nodeName !== "SELECT" || (T.value = b.value), T.addEventListener("load", function() {
          T.scrollTop = b.scrollTop, T.scrollLeft = b.scrollLeft;
        }, !0)), T;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      l.tagName === "BODY" && (c.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = i("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = i("div", { className: "html2pdf__container", style: c }), this.prop.container.appendChild(l), this.prop.container.firstChild.appendChild(i("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, o.prototype.toCanvas = function() {
    var c = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(c).then(e).then(function(l) {
      var _ = Object.assign({}, this.opt.html2canvas);
      return delete _.onrendered, l(this.prop.container, _);
    }).then(function(l) {
      (this.opt.html2canvas.onrendered || function() {
      })(l), this.prop.canvas = l, document.body.removeChild(this.prop.overlay);
    });
  }, o.prototype.toContext2d = function() {
    var c = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(c).then(e).then(function(l) {
      var _ = this.opt.jsPDF, b = this.opt.fontFaces, w = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, T = Object.assign({ async: !0, allowTaint: !0, scale: w, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete T.onrendered, _.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, _.context2d.posX = this.opt.x, _.context2d.posY = this.opt.y, _.context2d.margin = this.opt.margin, _.context2d.fontFaces = b, b) for (var I = 0; I < b.length; ++I) {
        var P = b[I], k = P.src.find(function(U) {
          return U.format === "truetype";
        });
        k && _.addFont(k.url, P.ref.name, P.ref.style);
      }
      return T.windowHeight = T.windowHeight || 0, T.windowHeight = T.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : T.windowHeight, _.context2d.save(!0), l(this.prop.container, T);
    }).then(function(l) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(l), this.prop.canvas = l, document.body.removeChild(this.prop.overlay);
    });
  }, o.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var c = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = c;
    });
  }, o.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, o.prototype.output = function(c, l, _) {
    return (_ = _ || "pdf").toLowerCase() === "img" || _.toLowerCase() === "image" ? this.outputImg(c, l) : this.outputPdf(c, l);
  }, o.prototype.outputPdf = function(c, l) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(c, l);
    });
  }, o.prototype.outputImg = function(c) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (c) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + c + '" is not supported.';
      }
    });
  }, o.prototype.save = function(c) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(c ? { filename: c } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, o.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, o.prototype.set = function(c) {
    if (r(c) !== "object") return this;
    var l = Object.keys(c || {}).map(function(_) {
      if (_ in o.template.prop) return function() {
        this.prop[_] = c[_];
      };
      switch (_) {
        case "margin":
          return this.setMargin.bind(this, c.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = c.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, c.pageSize);
        default:
          return function() {
            this.opt[_] = c[_];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(l);
    });
  }, o.prototype.get = function(c, l) {
    return this.then(function() {
      var _ = c in o.template.prop ? this.prop[c] : this.opt[c];
      return l ? l(_) : _;
    });
  }, o.prototype.setMargin = function(c) {
    return this.then(function() {
      switch (r(c)) {
        case "number":
          c = [c, c, c, c];
        case "array":
          if (c.length === 2 && (c = [c[0], c[1], c[0], c[1]]), c.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = c;
    }).then(this.setPageSize);
  }, o.prototype.setPageSize = function(c) {
    function l(_, b) {
      return Math.floor(_ * b / 72 * 96);
    }
    return this.then(function() {
      (c = c || Bn.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (c.inner = { width: c.width - this.opt.margin[1] - this.opt.margin[3], height: c.height - this.opt.margin[0] - this.opt.margin[2] }, c.inner.px = { width: l(c.inner.width, c.k), height: l(c.inner.height, c.k) }, c.inner.ratio = c.inner.height / c.inner.width), this.prop.pageSize = c;
    });
  }, o.prototype.setProgress = function(c, l, _, b) {
    return c != null && (this.progress.val = c), l != null && (this.progress.state = l), _ != null && (this.progress.n = _), b != null && (this.progress.stack = b), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, o.prototype.updateProgress = function(c, l, _, b) {
    return this.setProgress(c ? this.progress.val + c : null, l || null, _ ? this.progress.n + _ : null, b ? this.progress.stack.concat(b) : null);
  }, o.prototype.then = function(c, l) {
    var _ = this;
    return this.thenCore(c, l, function(b, w) {
      return _.updateProgress(null, null, 1, [b]), Promise.prototype.then.call(this, function(T) {
        return _.updateProgress(null, b), T;
      }).then(b, w).then(function(T) {
        return _.updateProgress(1), T;
      });
    });
  }, o.prototype.thenCore = function(c, l, _) {
    _ = _ || Promise.prototype.then, c && (c = c.bind(this)), l && (l = l.bind(this));
    var b = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : o.convert(Object.assign({}, this), Promise.prototype), w = _.call(b, c, l);
    return o.convert(w, this.__proto__);
  }, o.prototype.thenExternal = function(c, l) {
    return Promise.prototype.then.call(this, c, l);
  }, o.prototype.thenList = function(c) {
    var l = this;
    return c.forEach(function(_) {
      l = l.thenCore(_);
    }), l;
  }, o.prototype.catch = function(c) {
    c && (c = c.bind(this));
    var l = Promise.prototype.catch.call(this, c);
    return o.convert(l, this);
  }, o.prototype.catchExternal = function(c) {
    return Promise.prototype.catch.call(this, c);
  }, o.prototype.error = function(c) {
    return this.then(function() {
      throw new Error(c);
    });
  }, o.prototype.using = o.prototype.set, o.prototype.saveAs = o.prototype.save, o.prototype.export = o.prototype.output, o.prototype.run = o.prototype.then, Bn.getPageSize = function(c, l, _) {
    if (zr(c) === "object") {
      var b = c;
      c = b.orientation, l = b.unit || l, _ = b.format || _;
    }
    l = l || "mm", _ = _ || "a4", c = ("" + (c || "P")).toLowerCase();
    var w, T = ("" + _).toLowerCase(), I = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (l) {
      case "pt":
        w = 1;
        break;
      case "mm":
        w = 72 / 25.4;
        break;
      case "cm":
        w = 72 / 2.54;
        break;
      case "in":
        w = 72;
        break;
      case "px":
        w = 0.75;
        break;
      case "pc":
      case "em":
        w = 12;
        break;
      case "ex":
        w = 6;
        break;
      default:
        throw "Invalid unit: " + l;
    }
    var P, k = 0, U = 0;
    if (I.hasOwnProperty(T)) k = I[T][1] / w, U = I[T][0] / w;
    else try {
      k = _[1], U = _[0];
    } catch {
      throw new Error("Invalid format: " + _);
    }
    if (c === "p" || c === "portrait") c = "p", U > k && (P = U, U = k, k = P);
    else {
      if (c !== "l" && c !== "landscape") throw "Invalid orientation: " + c;
      c = "l", k > U && (P = U, U = k, k = P);
    }
    return { width: U, height: k, unit: l, k: w, orientation: c };
  }, n.html = function(c, l) {
    (l = l || {}).callback = l.callback || function() {
    }, l.html2canvas = l.html2canvas || {}, l.html2canvas.canvas = l.html2canvas.canvas || this.canvas, l.jsPDF = l.jsPDF || this, l.fontFaces = l.fontFaces ? l.fontFaces.map(o1) : null;
    var _ = new o(l);
    return l.worker ? _ : _.from(c).doCallback();
  };
}(Bn.API), Bn.API.addJS = function(n) {
  return $A = n, this.internal.events.subscribe("postPutResources", function() {
    jg = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (jg + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), XA = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + $A + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    jg !== void 0 && XA !== void 0 && this.internal.out("/Names <</JavaScript " + jg + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e;
  n.events.push(["postPutResources", function() {
    var t = this, r = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var i = t.outline.render().split(/\r\n/), o = 0; o < i.length; o++) {
      var c = i[o], l = r.exec(c);
      if (l != null) {
        var _ = l[1];
        t.internal.newObjectDeferredBegin(_, !1);
      }
      t.internal.write(c);
    }
    if (this.outline.createNamedDestinations) {
      var b = this.internal.pages.length, w = [];
      for (o = 0; o < b; o++) {
        var T = t.internal.newObject();
        w.push(T);
        var I = t.internal.getPageInfo(o + 1);
        t.internal.write("<< /D[" + I.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var P = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), o = 0; o < w.length; o++) t.internal.write("(page_" + (o + 1) + ")" + w[o] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + P + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), n.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), n.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(r, i, o) {
      var c = { title: i, options: o, children: [] };
      return r == null && (r = this.root), r.children.push(c), c;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(r) {
      r.id = t.internal.newObjectDeferred();
      for (var i = 0; i < r.children.length; i++) this.genIds_r(r.children[i]);
    }, t.outline.renderRoot = function(r) {
      this.objStart(r), this.line("/Type /Outlines"), r.children.length > 0 && (this.line("/First " + this.makeRef(r.children[0])), this.line("/Last " + this.makeRef(r.children[r.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, r)), this.objEnd();
    }, t.outline.renderItems = function(r) {
      for (var i = this.ctx.pdf.internal.getVerticalCoordinateString, o = 0; o < r.children.length; o++) {
        var c = r.children[o];
        this.objStart(c), this.line("/Title " + this.makeString(c.title)), this.line("/Parent " + this.makeRef(r)), o > 0 && this.line("/Prev " + this.makeRef(r.children[o - 1])), o < r.children.length - 1 && this.line("/Next " + this.makeRef(r.children[o + 1])), c.children.length > 0 && (this.line("/First " + this.makeRef(c.children[0])), this.line("/Last " + this.makeRef(c.children[c.children.length - 1])));
        var l = this.count = this.count_r({ count: 0 }, c);
        if (l > 0 && this.line("/Count " + l), c.options && c.options.pageNumber) {
          var _ = t.internal.getPageInfo(c.options.pageNumber);
          this.line("/Dest [" + _.objId + " 0 R /XYZ 0 " + i(0) + " 0]");
        }
        this.objEnd();
      }
      for (var b = 0; b < r.children.length; b++) this.renderItems(r.children[b]);
    }, t.outline.line = function(r) {
      this.ctx.val += r + `\r
`;
    }, t.outline.makeRef = function(r) {
      return r.id + " 0 R";
    }, t.outline.makeString = function(r) {
      return "(" + t.internal.pdfEscape(r) + ")";
    }, t.outline.objStart = function(r) {
      this.ctx.val += `\r
` + r.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(r, i) {
      for (var o = 0; o < i.children.length; o++) r.count++, this.count_r(r, i.children[o]);
      return r.count;
    };
  }]);
}(Bn.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  n.processJPEG = function(t, r, i, o, c, l) {
    var _, b = this.decode.DCT_DECODE, w = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = c || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (_ = function(T) {
        for (var I, P = 256 * T.charCodeAt(4) + T.charCodeAt(5), k = T.length, U = { width: 0, height: 0, numcomponents: 1 }, G = 4; G < k; G += 2) {
          if (G += P, e.indexOf(T.charCodeAt(G + 1)) !== -1) {
            I = 256 * T.charCodeAt(G + 5) + T.charCodeAt(G + 6), U = { width: 256 * T.charCodeAt(G + 7) + T.charCodeAt(G + 8), height: I, numcomponents: T.charCodeAt(G + 9) };
            break;
          }
          P = 256 * T.charCodeAt(G + 2) + T.charCodeAt(G + 3);
        }
        return U;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          l = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          l = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          l = this.color_spaces.DEVICE_RGB;
      }
      w = { data: t, width: _.width, height: _.height, colorSpace: l, bitsPerComponent: 8, filter: b, index: r, alias: i };
    }
    return w;
  };
}(Bn.API);
var Sd, Gg, JA, YA, KA, EV = function() {
  var n, e, t;
  function r(o) {
    var c, l, _, b, w, T, I, P, k, U, G, H, $, ie;
    for (this.data = o, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, T = null; ; ) {
      switch (c = this.readUInt32(), k = (function() {
        var ge, Se;
        for (Se = [], ge = 0; ge < 4; ++ge) Se.push(String.fromCharCode(this.data[this.pos++]));
        return Se;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(c);
          break;
        case "fcTL":
          T && this.animation.frames.push(T), this.pos += 4, T = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, w = this.readUInt16(), b = this.readUInt16() || 100, T.delay = 1e3 * w / b, T.disposeOp = this.data[this.pos++], T.blendOp = this.data[this.pos++], T.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (k === "fdAT" && (this.pos += 4, c -= 4), o = (T != null ? T.data : void 0) || this.imgData, H = 0; 0 <= c ? H < c : H > c; 0 <= c ? ++H : --H) o.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (_ = this.palette.length / 3, this.transparency.indexed = this.read(c), this.transparency.indexed.length > _) throw new Error("More transparent colors than palette size");
              if ((U = _ - this.transparency.indexed.length) > 0) for ($ = 0; 0 <= U ? $ < U : $ > U; 0 <= U ? ++$ : --$) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(c)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(c);
          }
          break;
        case "tEXt":
          I = (G = this.read(c)).indexOf(0), P = String.fromCharCode.apply(String, G.slice(0, I)), this.text[P] = String.fromCharCode.apply(String, G.slice(I + 1));
          break;
        case "IEND":
          return T && this.animation.frames.push(T), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (ie = this.colorType) === 4 || ie === 6, l = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * l, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += c;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  r.prototype.read = function(o) {
    var c, l;
    for (l = [], c = 0; 0 <= o ? c < o : c > o; 0 <= o ? ++c : --c) l.push(this.data[this.pos++]);
    return l;
  }, r.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, r.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, r.prototype.decodePixels = function(o) {
    var c = this.pixelBitlength / 8, l = new Uint8Array(this.width * this.height * c), _ = 0, b = this;
    if (o == null && (o = this.imgData), o.length === 0) return new Uint8Array(0);
    function w(T, I, P, k) {
      var U, G, H, $, ie, ge, Se, Re, Le, _e, Ge, ke, oe, pe, Te, xe, et, rt, st, Je, ct, ot = Math.ceil((b.width - T) / P), Mt = Math.ceil((b.height - I) / k), re = b.width == ot && b.height == Mt;
      for (pe = c * ot, ke = re ? l : new Uint8Array(pe * Mt), ge = o.length, oe = 0, G = 0; oe < Mt && _ < ge; ) {
        switch (o[_++]) {
          case 0:
            for ($ = et = 0; et < pe; $ = et += 1) ke[G++] = o[_++];
            break;
          case 1:
            for ($ = rt = 0; rt < pe; $ = rt += 1) U = o[_++], ie = $ < c ? 0 : ke[G - c], ke[G++] = (U + ie) % 256;
            break;
          case 2:
            for ($ = st = 0; st < pe; $ = st += 1) U = o[_++], H = ($ - $ % c) / c, Te = oe && ke[(oe - 1) * pe + H * c + $ % c], ke[G++] = (Te + U) % 256;
            break;
          case 3:
            for ($ = Je = 0; Je < pe; $ = Je += 1) U = o[_++], H = ($ - $ % c) / c, ie = $ < c ? 0 : ke[G - c], Te = oe && ke[(oe - 1) * pe + H * c + $ % c], ke[G++] = (U + Math.floor((ie + Te) / 2)) % 256;
            break;
          case 4:
            for ($ = ct = 0; ct < pe; $ = ct += 1) U = o[_++], H = ($ - $ % c) / c, ie = $ < c ? 0 : ke[G - c], oe === 0 ? Te = xe = 0 : (Te = ke[(oe - 1) * pe + H * c + $ % c], xe = H && ke[(oe - 1) * pe + (H - 1) * c + $ % c]), Se = ie + Te - xe, Re = Math.abs(Se - ie), _e = Math.abs(Se - Te), Ge = Math.abs(Se - xe), Le = Re <= _e && Re <= Ge ? ie : _e <= Ge ? Te : xe, ke[G++] = (U + Le) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + o[_ - 1]);
        }
        if (!re) {
          var Ae = ((I + oe * k) * b.width + T) * c, Ce = oe * pe;
          for ($ = 0; $ < ot; $ += 1) {
            for (var Ue = 0; Ue < c; Ue += 1) l[Ae++] = ke[Ce++];
            Ae += (P - 1) * c;
          }
        }
        oe++;
      }
    }
    return o = sV(o), b.interlaceMethod == 1 ? (w(0, 0, 8, 8), w(4, 0, 8, 8), w(0, 4, 4, 8), w(2, 0, 4, 4), w(0, 2, 2, 4), w(1, 0, 2, 2), w(0, 1, 1, 2)) : w(0, 0, 1, 1), l;
  }, r.prototype.decodePalette = function() {
    var o, c, l, _, b, w, T, I, P;
    for (l = this.palette, w = this.transparency.indexed || [], b = new Uint8Array((w.length || 0) + l.length), _ = 0, o = 0, c = T = 0, I = l.length; T < I; c = T += 3) b[_++] = l[c], b[_++] = l[c + 1], b[_++] = l[c + 2], b[_++] = (P = w[o++]) != null ? P : 255;
    return b;
  }, r.prototype.copyToImageData = function(o, c) {
    var l, _, b, w, T, I, P, k, U, G, H;
    if (_ = this.colors, U = null, l = this.hasAlphaChannel, this.palette.length && (U = (H = this._decodedPalette) != null ? H : this._decodedPalette = this.decodePalette(), _ = 4, l = !0), k = (b = o.data || o).length, T = U || c, w = I = 0, _ === 1) for (; w < k; ) P = U ? 4 * c[w / 4] : I, G = T[P++], b[w++] = G, b[w++] = G, b[w++] = G, b[w++] = l ? T[P++] : 255, I = P;
    else for (; w < k; ) P = U ? 4 * c[w / 4] : I, b[w++] = T[P++], b[w++] = T[P++], b[w++] = T[P++], b[w++] = l ? T[P++] : 255, I = P;
  }, r.prototype.decode = function() {
    var o;
    return o = new Uint8Array(this.width * this.height * 4), this.copyToImageData(o, this.decodePixels()), o;
  };
  var i = function() {
    if (Object.prototype.toString.call(Rn) === "[object Window]") {
      try {
        e = Rn.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return i(), n = function(o) {
    var c;
    if (i() === !0) return t.width = o.width, t.height = o.height, t.clearRect(0, 0, o.width, o.height), t.putImageData(o, 0, 0), (c = new Image()).src = e.toDataURL(), c;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, r.prototype.decodeFrames = function(o) {
    var c, l, _, b, w, T, I, P;
    if (this.animation) {
      for (P = [], l = w = 0, T = (I = this.animation.frames).length; w < T; l = ++w) c = I[l], _ = o.createImageData(c.width, c.height), b = this.decodePixels(new Uint8Array(c.data)), this.copyToImageData(_, b), c.imageData = _, P.push(c.image = n(_));
      return P;
    }
  }, r.prototype.renderFrame = function(o, c) {
    var l, _, b;
    return l = (_ = this.animation.frames)[c], b = _[c - 1], c === 0 && o.clearRect(0, 0, this.width, this.height), (b != null ? b.disposeOp : void 0) === 1 ? o.clearRect(b.xOffset, b.yOffset, b.width, b.height) : (b != null ? b.disposeOp : void 0) === 2 && o.putImageData(b.imageData, b.xOffset, b.yOffset), l.blendOp === 0 && o.clearRect(l.xOffset, l.yOffset, l.width, l.height), o.drawImage(l.image, l.xOffset, l.yOffset);
  }, r.prototype.animate = function(o) {
    var c, l, _, b, w, T, I = this;
    return l = 0, T = this.animation, b = T.numFrames, _ = T.frames, w = T.numPlays, (c = function() {
      var P, k;
      if (P = l++ % b, k = _[P], I.renderFrame(o, P), b > 1 && l / b < w) return I.animation._timeout = setTimeout(c, k.delay);
    })();
  }, r.prototype.stopAnimation = function() {
    var o;
    return clearTimeout((o = this.animation) != null ? o._timeout : void 0);
  }, r.prototype.render = function(o) {
    var c, l;
    return o._png && o._png.stopAnimation(), o._png = this, o.width = this.width, o.height = this.height, c = o.getContext("2d"), this.animation ? (this.decodeFrames(c), this.animate(c)) : (l = c.createImageData(this.width, this.height), this.copyToImageData(l, this.decodePixels()), c.putImageData(l, 0, 0));
  }, r;
}();
/**
* @license
*
* Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
/**
* @license
* (c) Dean McNamee <dean@gmail.com>, 2013.
*
* https://github.com/deanm/omggif
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
* including animation and compression.  It does not rely on any specific
* underlying system, so should run in the browser, Node, or Plask.
*/
function TV(n) {
  var e = 0;
  if (n[e++] !== 71 || n[e++] !== 73 || n[e++] !== 70 || n[e++] !== 56 || (n[e++] + 1 & 253) != 56 || n[e++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var t = n[e++] | n[e++] << 8, r = n[e++] | n[e++] << 8, i = n[e++], o = i >> 7, c = 1 << (7 & i) + 1;
  n[e++], n[e++];
  var l = null, _ = null;
  o && (l = e, _ = c, e += 3 * c);
  var b = !0, w = [], T = 0, I = null, P = 0, k = null;
  for (this.width = t, this.height = r; b && e < n.length; ) switch (n[e++]) {
    case 33:
      switch (n[e++]) {
        case 255:
          if (n[e] !== 11 || n[e + 1] == 78 && n[e + 2] == 69 && n[e + 3] == 84 && n[e + 4] == 83 && n[e + 5] == 67 && n[e + 6] == 65 && n[e + 7] == 80 && n[e + 8] == 69 && n[e + 9] == 50 && n[e + 10] == 46 && n[e + 11] == 48 && n[e + 12] == 3 && n[e + 13] == 1 && n[e + 16] == 0) e += 14, k = n[e++] | n[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((oe = n[e++]) >= 0)) throw Error("Invalid block size");
            if (oe === 0) break;
            e += oe;
          }
          break;
        case 249:
          if (n[e++] !== 4 || n[e + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var U = n[e++];
          T = n[e++] | n[e++] << 8, I = n[e++], !(1 & U) && (I = null), P = U >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((oe = n[e++]) >= 0)) throw Error("Invalid block size");
            if (oe === 0) break;
            e += oe;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + n[e - 1].toString(16));
      }
      break;
    case 44:
      var G = n[e++] | n[e++] << 8, H = n[e++] | n[e++] << 8, $ = n[e++] | n[e++] << 8, ie = n[e++] | n[e++] << 8, ge = n[e++], Se = ge >> 6 & 1, Re = 1 << (7 & ge) + 1, Le = l, _e = _, Ge = !1;
      ge >> 7 && (Ge = !0, Le = e, _e = Re, e += 3 * Re);
      var ke = e;
      for (e++; ; ) {
        var oe;
        if (!((oe = n[e++]) >= 0)) throw Error("Invalid block size");
        if (oe === 0) break;
        e += oe;
      }
      w.push({ x: G, y: H, width: $, height: ie, has_local_palette: Ge, palette_offset: Le, palette_size: _e, data_offset: ke, data_length: e - ke, transparent_index: I, interlaced: !!Se, delay: T, disposal: P });
      break;
    case 59:
      b = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + n[e - 1].toString(16));
  }
  this.numFrames = function() {
    return w.length;
  }, this.loopCount = function() {
    return k;
  }, this.frameInfo = function(pe) {
    if (pe < 0 || pe >= w.length) throw new Error("Frame index out of range.");
    return w[pe];
  }, this.decodeAndBlitFrameBGRA = function(pe, Te) {
    var xe = this.frameInfo(pe), et = xe.width * xe.height, rt = new Uint8Array(et);
    QA(n, xe.data_offset, rt, et);
    var st = xe.palette_offset, Je = xe.transparent_index;
    Je === null && (Je = 256);
    var ct = xe.width, ot = t - ct, Mt = ct, re = 4 * (xe.y * t + xe.x), Ae = 4 * ((xe.y + xe.height) * t + xe.x), Ce = re, Ue = 4 * ot;
    xe.interlaced === !0 && (Ue += 4 * t * 7);
    for (var qe = 8, He = 0, Ye = rt.length; He < Ye; ++He) {
      var Ze = rt[He];
      if (Mt === 0 && (Mt = ct, (Ce += Ue) >= Ae && (Ue = 4 * ot + 4 * t * (qe - 1), Ce = re + (ct + ot) * (qe << 1), qe >>= 1)), Ze === Je) Ce += 4;
      else {
        var St = n[st + 3 * Ze], Lt = n[st + 3 * Ze + 1], Dt = n[st + 3 * Ze + 2];
        Te[Ce++] = Dt, Te[Ce++] = Lt, Te[Ce++] = St, Te[Ce++] = 255;
      }
      --Mt;
    }
  }, this.decodeAndBlitFrameRGBA = function(pe, Te) {
    var xe = this.frameInfo(pe), et = xe.width * xe.height, rt = new Uint8Array(et);
    QA(n, xe.data_offset, rt, et);
    var st = xe.palette_offset, Je = xe.transparent_index;
    Je === null && (Je = 256);
    var ct = xe.width, ot = t - ct, Mt = ct, re = 4 * (xe.y * t + xe.x), Ae = 4 * ((xe.y + xe.height) * t + xe.x), Ce = re, Ue = 4 * ot;
    xe.interlaced === !0 && (Ue += 4 * t * 7);
    for (var qe = 8, He = 0, Ye = rt.length; He < Ye; ++He) {
      var Ze = rt[He];
      if (Mt === 0 && (Mt = ct, (Ce += Ue) >= Ae && (Ue = 4 * ot + 4 * t * (qe - 1), Ce = re + (ct + ot) * (qe << 1), qe >>= 1)), Ze === Je) Ce += 4;
      else {
        var St = n[st + 3 * Ze], Lt = n[st + 3 * Ze + 1], Dt = n[st + 3 * Ze + 2];
        Te[Ce++] = St, Te[Ce++] = Lt, Te[Ce++] = Dt, Te[Ce++] = 255;
      }
      --Mt;
    }
  };
}
function QA(n, e, t, r) {
  for (var i = n[e++], o = 1 << i, c = o + 1, l = c + 1, _ = i + 1, b = (1 << _) - 1, w = 0, T = 0, I = 0, P = n[e++], k = new Int32Array(4096), U = null; ; ) {
    for (; w < 16 && P !== 0; ) T |= n[e++] << w, w += 8, P === 1 ? P = n[e++] : --P;
    if (w < _) break;
    var G = T & b;
    if (T >>= _, w -= _, G !== o) {
      if (G === c) break;
      for (var H = G < l ? G : U, $ = 0, ie = H; ie > o; ) ie = k[ie] >> 8, ++$;
      var ge = ie;
      if (I + $ + (H !== G ? 1 : 0) > r) return void $r.log("Warning, gif stream longer than expected.");
      t[I++] = ge;
      var Se = I += $;
      for (H !== G && (t[I++] = ge), ie = H; $--; ) ie = k[ie], t[--Se] = 255 & ie, ie >>= 8;
      U !== null && l < 4096 && (k[l++] = U << 8 | ge, l >= b + 1 && _ < 12 && (++_, b = b << 1 | 1)), U = G;
    } else l = c + 1, b = (1 << (_ = i + 1)) - 1, U = null;
  }
  return I !== r && $r.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function J_(n) {
  var e, t, r, i, o, c = Math.floor, l = new Array(64), _ = new Array(64), b = new Array(64), w = new Array(64), T = new Array(65535), I = new Array(65535), P = new Array(64), k = new Array(64), U = [], G = 0, H = 7, $ = new Array(64), ie = new Array(64), ge = new Array(64), Se = new Array(256), Re = new Array(2048), Le = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], _e = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], Ge = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ke = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], oe = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], pe = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Te = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], xe = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], et = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function rt(re, Ae) {
    for (var Ce = 0, Ue = 0, qe = new Array(), He = 1; He <= 16; He++) {
      for (var Ye = 1; Ye <= re[He]; Ye++) qe[Ae[Ue]] = [], qe[Ae[Ue]][0] = Ce, qe[Ae[Ue]][1] = He, Ue++, Ce++;
      Ce *= 2;
    }
    return qe;
  }
  function st(re) {
    for (var Ae = re[0], Ce = re[1] - 1; Ce >= 0; ) Ae & 1 << Ce && (G |= 1 << H), Ce--, --H < 0 && (G == 255 ? (Je(255), Je(0)) : Je(G), H = 7, G = 0);
  }
  function Je(re) {
    U.push(re);
  }
  function ct(re) {
    Je(re >> 8 & 255), Je(255 & re);
  }
  function ot(re, Ae, Ce, Ue, qe) {
    for (var He, Ye = qe[0], Ze = qe[240], St = function(dt, Et) {
      var Bt, Ft, nn, Sn, vn, On, Un, gt, un, xn, Ot = 0;
      for (un = 0; un < 8; ++un) {
        Bt = dt[Ot], Ft = dt[Ot + 1], nn = dt[Ot + 2], Sn = dt[Ot + 3], vn = dt[Ot + 4], On = dt[Ot + 5], Un = dt[Ot + 6];
        var _r = Bt + (gt = dt[Ot + 7]), mt = Bt - gt, bn = Ft + Un, jt = Ft - Un, qn = nn + On, Jr = nn - On, zt = Sn + vn, yi = Sn - vn, rr = _r + zt, ti = _r - zt, ni = bn + qn, be = bn - qn;
        dt[Ot] = rr + ni, dt[Ot + 4] = rr - ni;
        var J = 0.707106781 * (be + ti);
        dt[Ot + 2] = ti + J, dt[Ot + 6] = ti - J;
        var K = 0.382683433 * ((rr = yi + Jr) - (be = jt + mt)), ce = 0.5411961 * rr + K, ye = 1.306562965 * be + K, Fe = 0.707106781 * (ni = Jr + jt), je = mt + Fe, Oe = mt - Fe;
        dt[Ot + 5] = Oe + ce, dt[Ot + 3] = Oe - ce, dt[Ot + 1] = je + ye, dt[Ot + 7] = je - ye, Ot += 8;
      }
      for (Ot = 0, un = 0; un < 8; ++un) {
        Bt = dt[Ot], Ft = dt[Ot + 8], nn = dt[Ot + 16], Sn = dt[Ot + 24], vn = dt[Ot + 32], On = dt[Ot + 40], Un = dt[Ot + 48];
        var Ie = Bt + (gt = dt[Ot + 56]), tt = Bt - gt, ut = Ft + Un, We = Ft - Un, vt = nn + On, Xt = nn - On, Kt = Sn + vn, Mn = Sn - vn, en = Ie + Kt, In = Ie - Kt, wn = ut + vt, ir = ut - vt;
        dt[Ot] = en + wn, dt[Ot + 32] = en - wn;
        var Wn = 0.707106781 * (ir + In);
        dt[Ot + 16] = In + Wn, dt[Ot + 48] = In - Wn;
        var hn = 0.382683433 * ((en = Mn + Xt) - (ir = We + tt)), Fn = 0.5411961 * en + hn, er = 1.306562965 * ir + hn, fr = 0.707106781 * (wn = Xt + We), Sr = tt + fr, Yr = tt - fr;
        dt[Ot + 40] = Yr + Fn, dt[Ot + 24] = Yr - Fn, dt[Ot + 8] = Sr + er, dt[Ot + 56] = Sr - er, Ot++;
      }
      for (un = 0; un < 64; ++un) xn = dt[un] * Et[un], P[un] = xn > 0 ? xn + 0.5 | 0 : xn - 0.5 | 0;
      return P;
    }(re, Ae), Lt = 0; Lt < 64; ++Lt) k[Le[Lt]] = St[Lt];
    var Dt = k[0] - Ce;
    Ce = k[0], Dt == 0 ? st(Ue[0]) : (st(Ue[I[He = 32767 + Dt]]), st(T[He]));
    for (var Nt = 63; Nt > 0 && k[Nt] == 0; ) Nt--;
    if (Nt == 0) return st(Ye), Ce;
    for (var an, at = 1; at <= Nt; ) {
      for (var ne = at; k[at] == 0 && at <= Nt; ) ++at;
      var pn = at - ne;
      if (pn >= 16) {
        an = pn >> 4;
        for (var Qt = 1; Qt <= an; ++Qt) st(Ze);
        pn &= 15;
      }
      He = 32767 + k[at], st(qe[(pn << 4) + I[He]]), st(T[He]), at++;
    }
    return Nt != 63 && st(Ye), Ce;
  }
  function Mt(re) {
    re = Math.min(Math.max(re, 1), 100), o != re && (function(Ae) {
      for (var Ce = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Ue = 0; Ue < 64; Ue++) {
        var qe = c((Ce[Ue] * Ae + 50) / 100);
        qe = Math.min(Math.max(qe, 1), 255), l[Le[Ue]] = qe;
      }
      for (var He = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], Ye = 0; Ye < 64; Ye++) {
        var Ze = c((He[Ye] * Ae + 50) / 100);
        Ze = Math.min(Math.max(Ze, 1), 255), _[Le[Ye]] = Ze;
      }
      for (var St = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Lt = 0, Dt = 0; Dt < 8; Dt++) for (var Nt = 0; Nt < 8; Nt++) b[Lt] = 1 / (l[Le[Lt]] * St[Dt] * St[Nt] * 8), w[Lt] = 1 / (_[Le[Lt]] * St[Dt] * St[Nt] * 8), Lt++;
    }(re < 50 ? Math.floor(5e3 / re) : Math.floor(200 - 2 * re)), o = re);
  }
  this.encode = function(re, Ae) {
    Ae && Mt(Ae), U = new Array(), G = 0, H = 7, ct(65496), ct(65504), ct(16), Je(74), Je(70), Je(73), Je(70), Je(0), Je(1), Je(1), Je(0), ct(1), ct(1), Je(0), Je(0), function() {
      ct(65499), ct(132), Je(0);
      for (var Ft = 0; Ft < 64; Ft++) Je(l[Ft]);
      Je(1);
      for (var nn = 0; nn < 64; nn++) Je(_[nn]);
    }(), function(Ft, nn) {
      ct(65472), ct(17), Je(8), ct(nn), ct(Ft), Je(3), Je(1), Je(17), Je(0), Je(2), Je(17), Je(1), Je(3), Je(17), Je(1);
    }(re.width, re.height), function() {
      ct(65476), ct(418), Je(0);
      for (var Ft = 0; Ft < 16; Ft++) Je(_e[Ft + 1]);
      for (var nn = 0; nn <= 11; nn++) Je(Ge[nn]);
      Je(16);
      for (var Sn = 0; Sn < 16; Sn++) Je(ke[Sn + 1]);
      for (var vn = 0; vn <= 161; vn++) Je(oe[vn]);
      Je(1);
      for (var On = 0; On < 16; On++) Je(pe[On + 1]);
      for (var Un = 0; Un <= 11; Un++) Je(Te[Un]);
      Je(17);
      for (var gt = 0; gt < 16; gt++) Je(xe[gt + 1]);
      for (var un = 0; un <= 161; un++) Je(et[un]);
    }(), ct(65498), ct(12), Je(3), Je(1), Je(0), Je(2), Je(17), Je(3), Je(17), Je(0), Je(63), Je(0);
    var Ce = 0, Ue = 0, qe = 0;
    G = 0, H = 7, this.encode.displayName = "_encode_";
    for (var He, Ye, Ze, St, Lt, Dt, Nt, an, at, ne = re.data, pn = re.width, Qt = re.height, dt = 4 * pn, Et = 0; Et < Qt; ) {
      for (He = 0; He < dt; ) {
        for (Lt = dt * Et + He, Nt = -1, an = 0, at = 0; at < 64; at++) Dt = Lt + (an = at >> 3) * dt + (Nt = 4 * (7 & at)), Et + an >= Qt && (Dt -= dt * (Et + 1 + an - Qt)), He + Nt >= dt && (Dt -= He + Nt - dt + 4), Ye = ne[Dt++], Ze = ne[Dt++], St = ne[Dt++], $[at] = (Re[Ye] + Re[Ze + 256 >> 0] + Re[St + 512 >> 0] >> 16) - 128, ie[at] = (Re[Ye + 768 >> 0] + Re[Ze + 1024 >> 0] + Re[St + 1280 >> 0] >> 16) - 128, ge[at] = (Re[Ye + 1280 >> 0] + Re[Ze + 1536 >> 0] + Re[St + 1792 >> 0] >> 16) - 128;
        Ce = ot($, b, Ce, e, r), Ue = ot(ie, w, Ue, t, i), qe = ot(ge, w, qe, t, i), He += 32;
      }
      Et += 8;
    }
    if (H >= 0) {
      var Bt = [];
      Bt[1] = H + 1, Bt[0] = (1 << H + 1) - 1, st(Bt);
    }
    return ct(65497), new Uint8Array(U);
  }, n = n || 50, function() {
    for (var re = String.fromCharCode, Ae = 0; Ae < 256; Ae++) Se[Ae] = re(Ae);
  }(), e = rt(_e, Ge), t = rt(pe, Te), r = rt(ke, oe), i = rt(xe, et), function() {
    for (var re = 1, Ae = 2, Ce = 1; Ce <= 15; Ce++) {
      for (var Ue = re; Ue < Ae; Ue++) I[32767 + Ue] = Ce, T[32767 + Ue] = [], T[32767 + Ue][1] = Ce, T[32767 + Ue][0] = Ue;
      for (var qe = -(Ae - 1); qe <= -re; qe++) I[32767 + qe] = Ce, T[32767 + qe] = [], T[32767 + qe][1] = Ce, T[32767 + qe][0] = Ae - 1 + qe;
      re <<= 1, Ae <<= 1;
    }
  }(), function() {
    for (var re = 0; re < 256; re++) Re[re] = 19595 * re, Re[re + 256 >> 0] = 38470 * re, Re[re + 512 >> 0] = 7471 * re + 32768, Re[re + 768 >> 0] = -11059 * re, Re[re + 1024 >> 0] = -21709 * re, Re[re + 1280 >> 0] = 32768 * re + 8421375, Re[re + 1536 >> 0] = -27439 * re, Re[re + 1792 >> 0] = -5329 * re;
  }(), Mt(n);
}
/**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function ml(n, e) {
  if (this.pos = 0, this.buffer = n, this.datav = new DataView(n.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function e5(n) {
  function e(_e) {
    if (!_e) throw Error("assert :P");
  }
  function t(_e, Ge, ke) {
    for (var oe = 0; 4 > oe; oe++) if (_e[Ge + oe] != ke.charCodeAt(oe)) return !0;
    return !1;
  }
  function r(_e, Ge, ke, oe, pe) {
    for (var Te = 0; Te < pe; Te++) _e[Ge + Te] = ke[oe + Te];
  }
  function i(_e, Ge, ke, oe) {
    for (var pe = 0; pe < oe; pe++) _e[Ge + pe] = ke;
  }
  function o(_e) {
    return new Int32Array(_e);
  }
  function c(_e, Ge) {
    for (var ke = [], oe = 0; oe < _e; oe++) ke.push(new Ge());
    return ke;
  }
  function l(_e, Ge) {
    var ke = [];
    return function oe(pe, Te, xe) {
      for (var et = xe[Te], rt = 0; rt < et && (pe.push(xe.length > Te + 1 ? [] : new Ge()), !(xe.length < Te + 1)); rt++) oe(pe[rt], Te + 1, xe);
    }(ke, 0, _e), ke;
  }
  var _ = function() {
    var _e = this;
    function Ge(A, M) {
      for (var g = 1 << M - 1 >>> 0; A & g; ) g >>>= 1;
      return g ? (A & g - 1) + g : A;
    }
    function ke(A, M, g, s, h) {
      e(!(s % g));
      do
        A[M + (s -= g)] = h;
      while (0 < s);
    }
    function oe(A, M, g, s, h) {
      if (e(2328 >= h), 512 >= h) var f = o(512);
      else if ((f = o(h)) == null) return 0;
      return function(m, y, S, C, B, D) {
        var z, N, X = y, Z = 1 << S, W = o(16), Q = o(16);
        for (e(B != 0), e(C != null), e(m != null), e(0 < S), N = 0; N < B; ++N) {
          if (15 < C[N]) return 0;
          ++W[C[N]];
        }
        if (W[0] == B) return 0;
        for (Q[1] = 0, z = 1; 15 > z; ++z) {
          if (W[z] > 1 << z) return 0;
          Q[z + 1] = Q[z] + W[z];
        }
        for (N = 0; N < B; ++N) z = C[N], 0 < C[N] && (D[Q[z]++] = N);
        if (Q[15] == 1) return (C = new pe()).g = 0, C.value = D[0], ke(m, X, 1, Z, C), Z;
        var le, ue = -1, fe = Z - 1, he = 0, ve = 1, Be = 1, Pe = 1 << S;
        for (N = 0, z = 1, B = 2; z <= S; ++z, B <<= 1) {
          if (ve += Be <<= 1, 0 > (Be -= W[z])) return 0;
          for (; 0 < W[z]; --W[z]) (C = new pe()).g = z, C.value = D[N++], ke(m, X + he, B, Pe, C), he = Ge(he, z);
        }
        for (z = S + 1, B = 2; 15 >= z; ++z, B <<= 1) {
          if (ve += Be <<= 1, 0 > (Be -= W[z])) return 0;
          for (; 0 < W[z]; --W[z]) {
            if (C = new pe(), (he & fe) != ue) {
              for (X += Pe, le = 1 << (ue = z) - S; 15 > ue && !(0 >= (le -= W[ue])); ) ++ue, le <<= 1;
              Z += Pe = 1 << (le = ue - S), m[y + (ue = he & fe)].g = le + S, m[y + ue].value = X - y - ue;
            }
            C.g = z - S, C.value = D[N++], ke(m, X + (he >> S), B, Pe, C), he = Ge(he, z);
          }
        }
        return ve != 2 * Q[15] - 1 ? 0 : Z;
      }(A, M, g, s, h, f);
    }
    function pe() {
      this.value = this.g = 0;
    }
    function Te() {
      this.value = this.g = 0;
    }
    function xe() {
      this.G = c(5, pe), this.H = o(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = c(Fi, Te);
    }
    function et(A, M, g, s) {
      e(A != null), e(M != null), e(2147483648 > s), A.Ca = 254, A.I = 0, A.b = -8, A.Ka = 0, A.oa = M, A.pa = g, A.Jd = M, A.Yc = g + s, A.Zc = 4 <= s ? g + s - 4 + 1 : g, He(A);
    }
    function rt(A, M) {
      for (var g = 0; 0 < M--; ) g |= Ze(A, 128) << M;
      return g;
    }
    function st(A, M) {
      var g = rt(A, M);
      return Ye(A) ? -g : g;
    }
    function Je(A, M, g, s) {
      var h, f = 0;
      for (e(A != null), e(M != null), e(4294967288 > s), A.Sb = s, A.Ra = 0, A.u = 0, A.h = 0, 4 < s && (s = 4), h = 0; h < s; ++h) f += M[g + h] << 8 * h;
      A.Ra = f, A.bb = s, A.oa = M, A.pa = g;
    }
    function ct(A) {
      for (; 8 <= A.u && A.bb < A.Sb; ) A.Ra >>>= 8, A.Ra += A.oa[A.pa + A.bb] << Ds - 8 >>> 0, ++A.bb, A.u -= 8;
      Ce(A) && (A.h = 1, A.u = 0);
    }
    function ot(A, M) {
      if (e(0 <= M), !A.h && M <= Pa) {
        var g = Ae(A) & Ia[M];
        return A.u += M, ct(A), g;
      }
      return A.h = 1, A.u = 0;
    }
    function Mt() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function re() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function Ae(A) {
      return A.Ra >>> (A.u & Ds - 1) >>> 0;
    }
    function Ce(A) {
      return e(A.bb <= A.Sb), A.h || A.bb == A.Sb && A.u > Ds;
    }
    function Ue(A, M) {
      A.u = M, A.h = Ce(A);
    }
    function qe(A) {
      A.u >= ea && (e(A.u >= ea), ct(A));
    }
    function He(A) {
      e(A != null && A.oa != null), A.pa < A.Zc ? (A.I = (A.oa[A.pa++] | A.I << 8) >>> 0, A.b += 8) : (e(A != null && A.oa != null), A.pa < A.Yc ? (A.b += 8, A.I = A.oa[A.pa++] | A.I << 8) : A.Ka ? A.b = 0 : (A.I <<= 8, A.b += 8, A.Ka = 1));
    }
    function Ye(A) {
      return rt(A, 1);
    }
    function Ze(A, M) {
      var g = A.Ca;
      0 > A.b && He(A);
      var s = A.b, h = g * M >>> 8, f = (A.I >>> s > h) + 0;
      for (f ? (g -= h, A.I -= h + 1 << s >>> 0) : g = h + 1, s = g, h = 0; 256 <= s; ) h += 8, s >>= 8;
      return s = 7 ^ h + vi[s], A.b -= s, A.Ca = (g << s) - 1, f;
    }
    function St(A, M, g) {
      A[M + 0] = g >> 24 & 255, A[M + 1] = g >> 16 & 255, A[M + 2] = g >> 8 & 255, A[M + 3] = g >> 0 & 255;
    }
    function Lt(A, M) {
      return A[M + 0] << 0 | A[M + 1] << 8;
    }
    function Dt(A, M) {
      return Lt(A, M) | A[M + 2] << 16;
    }
    function Nt(A, M) {
      return Lt(A, M) | Lt(A, M + 2) << 16;
    }
    function an(A, M) {
      var g = 1 << M;
      return e(A != null), e(0 < M), A.X = o(g), A.X == null ? 0 : (A.Mb = 32 - M, A.Xa = M, 1);
    }
    function at(A, M) {
      e(A != null), e(M != null), e(A.Xa == M.Xa), r(M.X, 0, A.X, 0, 1 << M.Xa);
    }
    function ne() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function pn(A, M, g, s) {
      e(g != null), e(s != null);
      var h = g[0], f = s[0];
      return h == 0 && (h = (A * f + M / 2) / M), f == 0 && (f = (M * h + A / 2) / A), 0 >= h || 0 >= f ? 0 : (g[0] = h, s[0] = f, 1);
    }
    function Qt(A, M) {
      return A + (1 << M) - 1 >>> M;
    }
    function dt(A, M) {
      return ((4278255360 & A) + (4278255360 & M) >>> 0 & 4278255360) + ((16711935 & A) + (16711935 & M) >>> 0 & 16711935) >>> 0;
    }
    function Et(A, M) {
      _e[M] = function(g, s, h, f, m, y, S) {
        var C;
        for (C = 0; C < m; ++C) {
          var B = _e[A](y[S + C - 1], h, f + C);
          y[S + C] = dt(g[s + C], B);
        }
      };
    }
    function Bt() {
      this.ud = this.hd = this.jd = 0;
    }
    function Ft(A, M) {
      return ((4278124286 & (A ^ M)) >>> 1) + (A & M) >>> 0;
    }
    function nn(A) {
      return 0 <= A && 256 > A ? A : 0 > A ? 0 : 255 < A ? 255 : void 0;
    }
    function Sn(A, M) {
      return nn(A + (A - M + 0.5 >> 1));
    }
    function vn(A, M, g) {
      return Math.abs(M - g) - Math.abs(A - g);
    }
    function On(A, M, g, s, h, f, m) {
      for (s = f[m - 1], g = 0; g < h; ++g) f[m + g] = s = dt(A[M + g], s);
    }
    function Un(A, M, g, s, h) {
      var f;
      for (f = 0; f < g; ++f) {
        var m = A[M + f], y = m >> 8 & 255, S = 16711935 & (S = (S = 16711935 & m) + ((y << 16) + y));
        s[h + f] = (4278255360 & m) + S >>> 0;
      }
    }
    function gt(A, M) {
      M.jd = A >> 0 & 255, M.hd = A >> 8 & 255, M.ud = A >> 16 & 255;
    }
    function un(A, M, g, s, h, f) {
      var m;
      for (m = 0; m < s; ++m) {
        var y = M[g + m], S = y >>> 8, C = y, B = 255 & (B = (B = y >>> 16) + ((A.jd << 24 >> 24) * (S << 24 >> 24) >>> 5));
        C = 255 & (C = (C = C + ((A.hd << 24 >> 24) * (S << 24 >> 24) >>> 5)) + ((A.ud << 24 >> 24) * (B << 24 >> 24) >>> 5)), h[f + m] = (4278255360 & y) + (B << 16) + C;
      }
    }
    function xn(A, M, g, s, h) {
      _e[M] = function(f, m, y, S, C, B, D, z, N) {
        for (S = D; S < z; ++S) for (D = 0; D < N; ++D) C[B++] = h(y[s(f[m++])]);
      }, _e[A] = function(f, m, y, S, C, B, D) {
        var z = 8 >> f.b, N = f.Ea, X = f.K[0], Z = f.w;
        if (8 > z) for (f = (1 << f.b) - 1, Z = (1 << z) - 1; m < y; ++m) {
          var W, Q = 0;
          for (W = 0; W < N; ++W) W & f || (Q = s(S[C++])), B[D++] = h(X[Q & Z]), Q >>= z;
        }
        else _e["VP8LMapColor" + g](S, C, X, Z, B, D, m, y, N);
      };
    }
    function Ot(A, M, g, s, h) {
      for (g = M + g; M < g; ) {
        var f = A[M++];
        s[h++] = f >> 16 & 255, s[h++] = f >> 8 & 255, s[h++] = f >> 0 & 255;
      }
    }
    function _r(A, M, g, s, h) {
      for (g = M + g; M < g; ) {
        var f = A[M++];
        s[h++] = f >> 16 & 255, s[h++] = f >> 8 & 255, s[h++] = f >> 0 & 255, s[h++] = f >> 24 & 255;
      }
    }
    function mt(A, M, g, s, h) {
      for (g = M + g; M < g; ) {
        var f = (m = A[M++]) >> 16 & 240 | m >> 12 & 15, m = m >> 0 & 240 | m >> 28 & 15;
        s[h++] = f, s[h++] = m;
      }
    }
    function bn(A, M, g, s, h) {
      for (g = M + g; M < g; ) {
        var f = (m = A[M++]) >> 16 & 248 | m >> 13 & 7, m = m >> 5 & 224 | m >> 3 & 31;
        s[h++] = f, s[h++] = m;
      }
    }
    function jt(A, M, g, s, h) {
      for (g = M + g; M < g; ) {
        var f = A[M++];
        s[h++] = f >> 0 & 255, s[h++] = f >> 8 & 255, s[h++] = f >> 16 & 255;
      }
    }
    function qn(A, M, g, s, h, f) {
      if (f == 0) for (g = M + g; M < g; ) St(s, ((f = A[M++])[0] >> 24 | f[1] >> 8 & 65280 | f[2] << 8 & 16711680 | f[3] << 24) >>> 0), h += 32;
      else r(s, h, A, M, g);
    }
    function Jr(A, M) {
      _e[M][0] = _e[A + "0"], _e[M][1] = _e[A + "1"], _e[M][2] = _e[A + "2"], _e[M][3] = _e[A + "3"], _e[M][4] = _e[A + "4"], _e[M][5] = _e[A + "5"], _e[M][6] = _e[A + "6"], _e[M][7] = _e[A + "7"], _e[M][8] = _e[A + "8"], _e[M][9] = _e[A + "9"], _e[M][10] = _e[A + "10"], _e[M][11] = _e[A + "11"], _e[M][12] = _e[A + "12"], _e[M][13] = _e[A + "13"], _e[M][14] = _e[A + "0"], _e[M][15] = _e[A + "0"];
    }
    function zt(A) {
      return A == Wl || A == al || A == Xl || A == Bc;
    }
    function yi() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function rr() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ti() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new yi(), this.f.kb = new rr(), this.sd = null;
    }
    function ni() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function be() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function J(A) {
      return alert("todo:WebPSamplerProcessPlane"), A.T;
    }
    function K(A, M) {
      var g = A.T, s = M.ba.f.RGBA, h = s.eb, f = s.fb + A.ka * s.A, m = Cn[M.ba.S], y = A.y, S = A.O, C = A.f, B = A.N, D = A.ea, z = A.W, N = M.cc, X = M.dc, Z = M.Mc, W = M.Nc, Q = A.ka, le = A.ka + A.T, ue = A.U, fe = ue + 1 >> 1;
      for (Q == 0 ? m(y, S, null, null, C, B, D, z, C, B, D, z, h, f, null, null, ue) : (m(M.ec, M.fc, y, S, N, X, Z, W, C, B, D, z, h, f - s.A, h, f, ue), ++g); Q + 2 < le; Q += 2) N = C, X = B, Z = D, W = z, B += A.Rc, z += A.Rc, f += 2 * s.A, m(y, (S += 2 * A.fa) - A.fa, y, S, N, X, Z, W, C, B, D, z, h, f - s.A, h, f, ue);
      return S += A.fa, A.j + le < A.o ? (r(M.ec, M.fc, y, S, ue), r(M.cc, M.dc, C, B, fe), r(M.Mc, M.Nc, D, z, fe), g--) : 1 & le || m(y, S, null, null, C, B, D, z, C, B, D, z, h, f + s.A, null, null, ue), g;
    }
    function ce(A, M, g) {
      var s = A.F, h = [A.J];
      if (s != null) {
        var f = A.U, m = M.ba.S, y = m == Hl || m == Xl;
        M = M.ba.f.RGBA;
        var S = [0], C = A.ka;
        S[0] = A.T, A.Kb && (C == 0 ? --S[0] : (--C, h[0] -= A.width), A.j + A.ka + A.T == A.o && (S[0] = A.o - A.j - C));
        var B = M.eb;
        C = M.fb + C * M.A, A = Ro(s, h[0], A.width, f, S, B, C + (y ? 0 : 3), M.A), e(g == S), A && zt(m) && Us(B, C, y, f, S, M.A);
      }
      return 0;
    }
    function ye(A) {
      var M = A.ma, g = M.ba.S, s = 11 > g, h = g == sl || g == ol || g == Hl || g == Mc || g == 12 || zt(g);
      if (M.memory = null, M.Ib = null, M.Jb = null, M.Nd = null, !po(M.Oa, A, h ? 11 : 12)) return 0;
      if (h && zt(g) && Pt(), A.da) alert("todo:use_scaling");
      else {
        if (s) {
          if (M.Ib = J, A.Kb) {
            if (g = A.U + 1 >> 1, M.memory = o(A.U + 2 * g), M.memory == null) return 0;
            M.ec = M.memory, M.fc = 0, M.cc = M.ec, M.dc = M.fc + A.U, M.Mc = M.cc, M.Nc = M.dc + g, M.Ib = K, Pt();
          }
        } else alert("todo:EmitYUV");
        h && (M.Jb = ce, s && Xe());
      }
      if (s && !vr) {
        for (A = 0; 256 > A; ++A) Yl[A] = 89858 * (A - 128) + _u >> Dc, Jh[A] = -22014 * (A - 128) + _u, bu[A] = -45773 * (A - 128), yu[A] = 113618 * (A - 128) + _u >> Dc;
        for (A = ul; A < lh; ++A) M = 76283 * (A - 16) + _u >> Dc, Fc[A - ul] = $n(M, 255), kc[A - ul] = $n(M + 8 >> 4, 15);
        vr = 1;
      }
      return 1;
    }
    function Fe(A) {
      var M = A.ma, g = A.U, s = A.T;
      return e(!(1 & A.ka)), 0 >= g || 0 >= s ? 0 : (g = M.Ib(A, M), M.Jb != null && M.Jb(A, M, g), M.Dc += g, 1);
    }
    function je(A) {
      A.ma.memory = null;
    }
    function Oe(A, M, g, s) {
      return ot(A, 8) != 47 ? 0 : (M[0] = ot(A, 14) + 1, g[0] = ot(A, 14) + 1, s[0] = ot(A, 1), ot(A, 3) != 0 ? 0 : !A.h);
    }
    function Ie(A, M) {
      if (4 > A) return A + 1;
      var g = A - 2 >> 1;
      return (2 + (1 & A) << g) + ot(M, g) + 1;
    }
    function tt(A, M) {
      return 120 < M ? M - 120 : 1 <= (g = ((g = Gs[M - 1]) >> 4) * A + (8 - (15 & g))) ? g : 1;
      var g;
    }
    function ut(A, M, g) {
      var s = Ae(g), h = A[M += 255 & s].g - 8;
      return 0 < h && (Ue(g, g.u + 8), s = Ae(g), M += A[M].value, M += s & (1 << h) - 1), Ue(g, g.u + A[M].g), A[M].value;
    }
    function We(A, M, g) {
      return g.g += A.g, g.value += A.value << M >>> 0, e(8 >= g.g), A.g;
    }
    function vt(A, M, g) {
      var s = A.xc;
      return e((M = s == 0 ? 0 : A.vc[A.md * (g >> s) + (M >> s)]) < A.Wb), A.Ya[M];
    }
    function Xt(A, M, g, s) {
      var h = A.ab, f = A.c * M, m = A.C;
      M = m + M;
      var y = g, S = s;
      for (s = A.Ta, g = A.Ua; 0 < h--; ) {
        var C = A.gc[h], B = m, D = M, z = y, N = S, X = (S = s, y = g, C.Ea);
        switch (e(B < D), e(D <= C.nc), C.hc) {
          case 2:
            nl(z, N, (D - B) * X, S, y);
            break;
          case 0:
            var Z = B, W = D, Q = S, le = y, ue = (Pe = C).Ea;
            Z == 0 && (La(z, N, null, null, 1, Q, le), On(z, N + 1, 0, 0, ue - 1, Q, le + 1), N += ue, le += ue, ++Z);
            for (var fe = 1 << Pe.b, he = fe - 1, ve = Qt(ue, Pe.b), Be = Pe.K, Pe = Pe.w + (Z >> Pe.b) * ve; Z < W; ) {
              var Qe = Be, ft = Pe, _t = 1;
              for (ta(z, N, Q, le - ue, 1, Q, le); _t < ue; ) {
                var xt = (_t & ~he) + fe;
                xt > ue && (xt = ue), (0, zn[Qe[ft++] >> 8 & 15])(z, N + +_t, Q, le + _t - ue, xt - _t, Q, le + _t), _t = xt;
              }
              N += ue, le += ue, ++Z & he || (Pe += ve);
            }
            D != C.nc && r(S, y - X, S, y + (D - B - 1) * X, X);
            break;
          case 1:
            for (X = z, W = N, ue = (z = C.Ea) - (le = z & ~(Q = (N = 1 << C.b) - 1)), Z = Qt(z, C.b), fe = C.K, C = C.w + (B >> C.b) * Z; B < D; ) {
              for (he = fe, ve = C, Be = new Bt(), Pe = W + le, Qe = W + z; W < Pe; ) gt(he[ve++], Be), Ki(Be, X, W, N, S, y), W += N, y += N;
              W < Qe && (gt(he[ve++], Be), Ki(Be, X, W, ue, S, y), W += ue, y += ue), ++B & Q || (C += Z);
            }
            break;
          case 3:
            if (z == S && N == y && 0 < C.b) {
              for (W = S, z = X = y + (D - B) * X - (le = (D - B) * Qt(C.Ea, C.b)), N = S, Q = y, Z = [], le = (ue = le) - 1; 0 <= le; --le) Z[le] = N[Q + le];
              for (le = ue - 1; 0 <= le; --le) W[z + le] = Z[le];
              ki(C, B, D, S, X, S, y);
            } else ki(C, B, D, z, N, S, y);
        }
        y = s, S = g;
      }
      S != g && r(s, g, y, S, f);
    }
    function Kt(A, M) {
      var g = A.V, s = A.Ba + A.c * A.C, h = M - A.C;
      if (e(M <= A.l.o), e(16 >= h), 0 < h) {
        var f = A.l, m = A.Ta, y = A.Ua, S = f.width;
        if (Xt(A, h, g, s), h = y = [y], e((g = A.C) < (s = M)), e(f.v < f.va), s > f.o && (s = f.o), g < f.j) {
          var C = f.j - g;
          g = f.j, h[0] += C * S;
        }
        if (g >= s ? g = 0 : (h[0] += 4 * f.v, f.ka = g - f.j, f.U = f.va - f.v, f.T = s - g, g = 1), g) {
          if (y = y[0], 11 > (g = A.ca).S) {
            var B = g.f.RGBA, D = (s = g.S, h = f.U, f = f.T, C = B.eb, B.A), z = f;
            for (B = B.fb + A.Ma * B.A; 0 < z--; ) {
              var N = m, X = y, Z = h, W = C, Q = B;
              switch (s) {
                case ql:
                  go(N, X, Z, W, Q);
                  break;
                case sl:
                  na(N, X, Z, W, Q);
                  break;
                case Wl:
                  na(N, X, Z, W, Q), Us(W, Q, 0, Z, 1, 0);
                  break;
                case gu:
                  ra(N, X, Z, W, Q);
                  break;
                case ol:
                  qn(N, X, Z, W, Q, 1);
                  break;
                case al:
                  qn(N, X, Z, W, Q, 1), Us(W, Q, 0, Z, 1, 0);
                  break;
                case Hl:
                  qn(N, X, Z, W, Q, 0);
                  break;
                case Xl:
                  qn(N, X, Z, W, Q, 0), Us(W, Q, 1, Z, 1, 0);
                  break;
                case Mc:
                  Qi(N, X, Z, W, Q);
                  break;
                case Bc:
                  Qi(N, X, Z, W, Q), si(W, Q, Z, 1, 0);
                  break;
                case Oa:
                  Bo(N, X, Z, W, Q);
                  break;
                default:
                  e(0);
              }
              y += S, B += D;
            }
            A.Ma += f;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(A.Ma <= g.height);
        }
      }
      A.C = M, e(A.C <= A.i);
    }
    function Mn(A) {
      var M;
      if (0 < A.ua) return 0;
      for (M = 0; M < A.Wb; ++M) {
        var g = A.Ya[M].G, s = A.Ya[M].H;
        if (0 < g[1][s[1] + 0].g || 0 < g[2][s[2] + 0].g || 0 < g[3][s[3] + 0].g) return 0;
      }
      return 1;
    }
    function en(A, M, g, s, h, f) {
      if (A.Z != 0) {
        var m = A.qd, y = A.rd;
        for (e(Fo[A.Z] != null); M < g; ++M) Fo[A.Z](m, y, s, h, s, h, f), m = s, y = h, h += f;
        A.qd = m, A.rd = y;
      }
    }
    function In(A, M) {
      var g = A.l.ma, s = g.Z == 0 || g.Z == 1 ? A.l.j : A.C;
      if (s = A.C < s ? s : A.C, e(M <= A.l.o), M > s) {
        var h = A.l.width, f = g.ca, m = g.tb + h * s, y = A.V, S = A.Ba + A.c * s, C = A.gc;
        e(A.ab == 1), e(C[0].hc == 3), pu(C[0], s, M, y, S, f, m), en(g, s, M, f, m, h);
      }
      A.C = A.Ma = M;
    }
    function wn(A, M, g, s, h, f, m) {
      var y = A.$ / s, S = A.$ % s, C = A.m, B = A.s, D = g + A.$, z = D;
      h = g + s * h;
      var N = g + s * f, X = 280 + B.ua, Z = A.Pb ? y : 16777216, W = 0 < B.ua ? B.Wa : null, Q = B.wc, le = D < N ? vt(B, S, y) : null;
      e(A.C < f), e(N <= h);
      var ue = !1;
      e: for (; ; ) {
        for (; ue || D < N; ) {
          var fe = 0;
          if (y >= Z) {
            var he = D - g;
            e((Z = A).Pb), Z.wd = Z.m, Z.xd = he, 0 < Z.s.ua && at(Z.s.Wa, Z.s.vb), Z = y + nh;
          }
          if (S & Q || (le = vt(B, S, y)), e(le != null), le.Qb && (M[D] = le.qb, ue = !0), !ue) if (qe(C), le.jc) {
            fe = C, he = M;
            var ve = D, Be = le.pd[Ae(fe) & Fi - 1];
            e(le.jc), 256 > Be.g ? (Ue(fe, fe.u + Be.g), he[ve] = Be.value, fe = 0) : (Ue(fe, fe.u + Be.g - 256), e(256 <= Be.value), fe = Be.value), fe == 0 && (ue = !0);
          } else fe = ut(le.G[0], le.H[0], C);
          if (C.h) break;
          if (ue || 256 > fe) {
            if (!ue) if (le.nd) M[D] = (le.qb | fe << 8) >>> 0;
            else {
              if (qe(C), ue = ut(le.G[1], le.H[1], C), qe(C), he = ut(le.G[2], le.H[2], C), ve = ut(le.G[3], le.H[3], C), C.h) break;
              M[D] = (ve << 24 | ue << 16 | fe << 8 | he) >>> 0;
            }
            if (ue = !1, ++D, ++S >= s && (S = 0, ++y, m != null && y <= f && !(y % 16) && m(A, y), W != null)) for (; z < D; ) fe = M[z++], W.X[(506832829 * fe & 4294967295) >>> W.Mb] = fe;
          } else if (280 > fe) {
            if (fe = Ie(fe - 256, C), he = ut(le.G[4], le.H[4], C), qe(C), he = tt(s, he = Ie(he, C)), C.h) break;
            if (D - g < he || h - D < fe) break e;
            for (ve = 0; ve < fe; ++ve) M[D + ve] = M[D + ve - he];
            for (D += fe, S += fe; S >= s; ) S -= s, ++y, m != null && y <= f && !(y % 16) && m(A, y);
            if (e(D <= h), S & Q && (le = vt(B, S, y)), W != null) for (; z < D; ) fe = M[z++], W.X[(506832829 * fe & 4294967295) >>> W.Mb] = fe;
          } else {
            if (!(fe < X)) break e;
            for (ue = fe - 280, e(W != null); z < D; ) fe = M[z++], W.X[(506832829 * fe & 4294967295) >>> W.Mb] = fe;
            fe = D, e(!(ue >>> (he = W).Xa)), M[fe] = he.X[ue], ue = !0;
          }
          ue || e(C.h == Ce(C));
        }
        if (A.Pb && C.h && D < h) e(A.m.h), A.a = 5, A.m = A.wd, A.$ = A.xd, 0 < A.s.ua && at(A.s.vb, A.s.Wa);
        else {
          if (C.h) break e;
          m != null && m(A, y > f ? f : y), A.a = 0, A.$ = D - g;
        }
        return 1;
      }
      return A.a = 3, 0;
    }
    function ir(A) {
      e(A != null), A.vc = null, A.yc = null, A.Ya = null;
      var M = A.Wa;
      M != null && (M.X = null), A.vb = null, e(A != null);
    }
    function Wn() {
      var A = new tl();
      return A == null ? null : (A.a = 0, A.xb = ll, Jr("Predictor", "VP8LPredictors"), Jr("Predictor", "VP8LPredictors_C"), Jr("PredictorAdd", "VP8LPredictorsAdd"), Jr("PredictorAdd", "VP8LPredictorsAdd_C"), nl = Un, Ki = un, go = Ot, na = _r, Qi = mt, Bo = bn, ra = jt, _e.VP8LMapColor32b = Mo, _e.VP8LMapColor8b = Pc, A);
    }
    function hn(A, M, g, s, h) {
      var f = 1, m = [A], y = [M], S = s.m, C = s.s, B = null, D = 0;
      e: for (; ; ) {
        if (g) for (; f && ot(S, 1); ) {
          var z = m, N = y, X = s, Z = 1, W = X.m, Q = X.gc[X.ab], le = ot(W, 2);
          if (X.Oc & 1 << le) f = 0;
          else {
            switch (X.Oc |= 1 << le, Q.hc = le, Q.Ea = z[0], Q.nc = N[0], Q.K = [null], ++X.ab, e(4 >= X.ab), le) {
              case 0:
              case 1:
                Q.b = ot(W, 3) + 2, Z = hn(Qt(Q.Ea, Q.b), Qt(Q.nc, Q.b), 0, X, Q.K), Q.K = Q.K[0];
                break;
              case 3:
                var ue, fe = ot(W, 8) + 1, he = 16 < fe ? 0 : 4 < fe ? 1 : 2 < fe ? 2 : 3;
                if (z[0] = Qt(Q.Ea, he), Q.b = he, ue = Z = hn(fe, 1, 0, X, Q.K)) {
                  var ve, Be = fe, Pe = Q, Qe = 1 << (8 >> Pe.b), ft = o(Qe);
                  if (ft == null) ue = 0;
                  else {
                    var _t = Pe.K[0], xt = Pe.w;
                    for (ft[0] = Pe.K[0][0], ve = 1; ve < 1 * Be; ++ve) ft[ve] = dt(_t[xt + ve], ft[ve - 1]);
                    for (; ve < 4 * Qe; ++ve) ft[ve] = 0;
                    Pe.K[0] = null, Pe.K[0] = ft, ue = 1;
                  }
                }
                Z = ue;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            f = Z;
          }
        }
        if (m = m[0], y = y[0], f && ot(S, 1) && !(f = 1 <= (D = ot(S, 4)) && 11 >= D)) {
          s.a = 3;
          break e;
        }
        var bt;
        if (bt = f) t: {
          var yt, wt, Jt, Ct = s, It = m, rn = y, An = D, yn = g, En = Ct.m, Dn = Ct.s, sr = [null], Dr = 1, Qn = 0, Xr = Oo[An];
          n: for (; ; ) {
            if (yn && ot(En, 1)) {
              var or = ot(En, 3) + 2, Gr = Qt(It, or), oi = Qt(rn, or), ts = Gr * oi;
              if (!hn(Gr, oi, 0, Ct, sr)) break n;
              for (sr = sr[0], Dn.xc = or, yt = 0; yt < ts; ++yt) {
                var Cs = sr[yt] >> 8 & 65535;
                sr[yt] = Cs, Cs >= Dr && (Dr = Cs + 1);
              }
            }
            if (En.h) break n;
            for (wt = 0; 5 > wt; ++wt) {
              var Fr = Rc[wt];
              !wt && 0 < An && (Fr += 1 << An), Qn < Fr && (Qn = Fr);
            }
            var Fa = c(Dr * Xr, pe), Is = Dr, zc = c(Is, xe);
            if (zc == null) var Kl = null;
            else e(65536 >= Is), Kl = zc;
            var zi = o(Qn);
            if (Kl == null || zi == null || Fa == null) {
              Ct.a = 1;
              break n;
            }
            var ns = Fa;
            for (yt = Jt = 0; yt < Dr; ++yt) {
              var wi = Kl[yt], Ui = wi.G, Kr = wi.H, Li = 0, ji = 1, Hn = 0;
              for (wt = 0; 5 > wt; ++wt) {
                Fr = Rc[wt], Ui[wt] = ns, Kr[wt] = Jt, !wt && 0 < An && (Fr += 1 << An);
                i: {
                  var ko, ka = Fr, sa = Ct, Ql = zi, df = ns, Yh = Jt, No = 0, oa = sa.m, vu = ot(oa, 1);
                  if (i(Ql, 0, 0, ka), vu) {
                    var Uc = ot(oa, 1) + 1, xu = ot(oa, 1), jc = ot(oa, xu == 0 ? 1 : 8);
                    Ql[jc] = 1, Uc == 2 && (Ql[jc = ot(oa, 8)] = 1);
                    var aa = 1;
                  } else {
                    var ec = o(19), ch = ot(oa, 4) + 4;
                    if (19 < ch) {
                      sa.a = 3;
                      var uh = 0;
                      break i;
                    }
                    for (ko = 0; ko < ch; ++ko) ec[Wh[ko]] = ot(oa, 3);
                    var Kh = void 0, hh = void 0, Qh = sa, dh = ec, hl = ka, Na = Ql, vo = 0, Ps = Qh.m, ff = 8, tc = c(128, pe);
                    r: for (; oe(tc, 0, 7, dh, 19); ) {
                      if (ot(Ps, 1)) {
                        var r0 = 2 + 2 * ot(Ps, 3);
                        if ((Kh = 2 + ot(Ps, r0)) > hl) break r;
                      } else Kh = hl;
                      for (hh = 0; hh < hl && Kh--; ) {
                        qe(Ps);
                        var pf = tc[0 + (127 & Ae(Ps))];
                        Ue(Ps, Ps.u + pf.g);
                        var kr = pf.value;
                        if (16 > kr) Na[hh++] = kr, kr != 0 && (ff = kr);
                        else {
                          var gf = kr == 16, mf = kr - 16, Gc = th[mf], nc = ot(Ps, eh[mf]) + Gc;
                          if (hh + nc > hl) break r;
                          for (var ed = gf ? ff : 0; 0 < nc--; ) Na[hh++] = ed;
                        }
                      }
                      vo = 1;
                      break r;
                    }
                    vo || (Qh.a = 3), aa = vo;
                  }
                  (aa = aa && !oa.h) && (No = oe(df, Yh, 8, Ql, ka)), aa && No != 0 ? uh = No : (sa.a = 3, uh = 0);
                }
                if (uh == 0) break n;
                if (ji && $l[wt] == 1 && (ji = ns[Jt].g == 0), Li += ns[Jt].g, Jt += uh, 3 >= wt) {
                  var Vc, td = zi[0];
                  for (Vc = 1; Vc < Fr; ++Vc) zi[Vc] > td && (td = zi[Vc]);
                  Hn += td;
                }
              }
              if (wi.nd = ji, wi.Qb = 0, ji && (wi.qb = (Ui[3][Kr[3] + 0].value << 24 | Ui[1][Kr[1] + 0].value << 16 | Ui[2][Kr[2] + 0].value) >>> 0, Li == 0 && 256 > Ui[0][Kr[0] + 0].value && (wi.Qb = 1, wi.qb += Ui[0][Kr[0] + 0].value << 8)), wi.jc = !wi.Qb && 6 > Hn, wi.jc) {
                var nd, za = wi;
                for (nd = 0; nd < Fi; ++nd) {
                  var rc = nd, Ua = za.pd[rc], rd = za.G[0][za.H[0] + rc];
                  256 <= rd.value ? (Ua.g = rd.g + 256, Ua.value = rd.value) : (Ua.g = 0, Ua.value = 0, rc >>= We(rd, 8, Ua), rc >>= We(za.G[1][za.H[1] + rc], 16, Ua), rc >>= We(za.G[2][za.H[2] + rc], 0, Ua), We(za.G[3][za.H[3] + rc], 24, Ua));
                }
              }
            }
            Dn.vc = sr, Dn.Wb = Dr, Dn.Ya = Kl, Dn.yc = Fa, bt = 1;
            break t;
          }
          bt = 0;
        }
        if (!(f = bt)) {
          s.a = 3;
          break e;
        }
        if (0 < D) {
          if (C.ua = 1 << D, !an(C.Wa, D)) {
            s.a = 1, f = 0;
            break e;
          }
        } else C.ua = 0;
        var fh = s, _f = m, Xp = y, ic = fh.s, yf = ic.xc;
        if (fh.c = _f, fh.i = Xp, ic.md = Qt(_f, yf), ic.wc = yf == 0 ? -1 : (1 << yf) - 1, g) {
          s.xb = Jl;
          break e;
        }
        if ((B = o(m * y)) == null) {
          s.a = 1, f = 0;
          break e;
        }
        f = (f = wn(s, B, 0, m, y, y, null)) && !S.h;
        break e;
      }
      return f ? (h != null ? h[0] = B : (e(B == null), e(g)), s.$ = 0, g || ir(C)) : ir(C), f;
    }
    function Fn(A, M) {
      var g = A.c * A.i, s = g + M + 16 * M;
      return e(A.c <= M), A.V = o(s), A.V == null ? (A.Ta = null, A.Ua = 0, A.a = 1, 0) : (A.Ta = A.V, A.Ua = A.Ba + g + M, 1);
    }
    function er(A, M) {
      var g = A.C, s = M - g, h = A.V, f = A.Ba + A.c * g;
      for (e(M <= A.l.o); 0 < s; ) {
        var m = 16 < s ? 16 : s, y = A.l.ma, S = A.l.width, C = S * m, B = y.ca, D = y.tb + S * g, z = A.Ta, N = A.Ua;
        Xt(A, m, h, f), Ku(z, N, B, D, C), en(y, g, g + m, B, D, S), s -= m, h += m * A.c, g += m;
      }
      e(g == M), A.C = A.Ma = M;
    }
    function fr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Sr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Yr() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = o(4), this.Lb = o(4);
    }
    function so() {
      this.Yb = function() {
        var A = [];
        return function M(g, s, h) {
          for (var f = h[s], m = 0; m < f && (g.push(h.length > s + 1 ? [] : 0), !(h.length < s + 1)); m++) M(g[m], s + 1, h);
        }(A, 0, [3, 11]), A;
      }();
    }
    function Jn() {
      this.jb = o(3), this.Wc = l([4, 8], so), this.Xc = l([4, 17], so);
    }
    function bi() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new o(4), this.od = new o(4);
    }
    function Xi() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Pr() {
      this.Na = this.la = 0;
    }
    function Lr() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function oo() {
      this.ad = o(384), this.Za = 0, this.Ob = o(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Mr() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Xi()), this.Y = 0, this.ya = Array(new oo()), this.aa = 0, this.l = new $i();
    }
    function Er() {
      this.y = o(16), this.f = o(8), this.ea = o(8);
    }
    function ao() {
      this.cb = this.a = 0, this.sc = "", this.m = new Mt(), this.Od = new fr(), this.Kc = new Sr(), this.ed = new bi(), this.Qa = new Yr(), this.Ic = this.$c = this.Aa = 0, this.D = new Mr(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = c(8, Mt), this.ia = 0, this.pb = c(4, Lr), this.Pa = new Jn(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Er()), this.Hd = 0, this.rb = Array(new Pr()), this.sb = 0, this.wa = Array(new Xi()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new oo()), this.L = this.aa = 0, this.gd = l([4, 2], Xi), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function $i() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function yr() {
      var A = new ao();
      return A != null && (A.a = 0, A.sc = "OK", A.cb = 0, A.Xb = 0, Oc || (Oc = lo)), A;
    }
    function Yn(A, M, g) {
      return A.a == 0 && (A.a = M, A.sc = g, A.cb = 0), 0;
    }
    function fi(A, M, g) {
      return 3 <= g && A[M + 0] == 157 && A[M + 1] == 1 && A[M + 2] == 42;
    }
    function pr(A, M) {
      if (A == null) return 0;
      if (A.a = 0, A.sc = "OK", M == null) return Yn(A, 2, "null VP8Io passed to VP8GetHeaders()");
      var g = M.data, s = M.w, h = M.ha;
      if (4 > h) return Yn(A, 7, "Truncated header.");
      var f = g[s + 0] | g[s + 1] << 8 | g[s + 2] << 16, m = A.Od;
      if (m.Rb = !(1 & f), m.td = f >> 1 & 7, m.yd = f >> 4 & 1, m.ub = f >> 5, 3 < m.td) return Yn(A, 3, "Incorrect keyframe parameters.");
      if (!m.yd) return Yn(A, 4, "Frame not displayable.");
      s += 3, h -= 3;
      var y = A.Kc;
      if (m.Rb) {
        if (7 > h) return Yn(A, 7, "cannot parse picture header");
        if (!fi(g, s, h)) return Yn(A, 3, "Bad code word");
        y.c = 16383 & (g[s + 4] << 8 | g[s + 3]), y.Td = g[s + 4] >> 6, y.i = 16383 & (g[s + 6] << 8 | g[s + 5]), y.Ud = g[s + 6] >> 6, s += 7, h -= 7, A.za = y.c + 15 >> 4, A.Ub = y.i + 15 >> 4, M.width = y.c, M.height = y.i, M.Da = 0, M.j = 0, M.v = 0, M.va = M.width, M.o = M.height, M.da = 0, M.ib = M.width, M.hb = M.height, M.U = M.width, M.T = M.height, i((f = A.Pa).jb, 0, 255, f.jb.length), e((f = A.Qa) != null), f.Cb = 0, f.Bb = 0, f.Fb = 1, i(f.Zb, 0, 0, f.Zb.length), i(f.Lb, 0, 0, f.Lb);
      }
      if (m.ub > h) return Yn(A, 7, "bad partition length");
      et(f = A.m, g, s, m.ub), s += m.ub, h -= m.ub, m.Rb && (y.Ld = Ye(f), y.Kd = Ye(f)), y = A.Qa;
      var S, C = A.Pa;
      if (e(f != null), e(y != null), y.Cb = Ye(f), y.Cb) {
        if (y.Bb = Ye(f), Ye(f)) {
          for (y.Fb = Ye(f), S = 0; 4 > S; ++S) y.Zb[S] = Ye(f) ? st(f, 7) : 0;
          for (S = 0; 4 > S; ++S) y.Lb[S] = Ye(f) ? st(f, 6) : 0;
        }
        if (y.Bb) for (S = 0; 3 > S; ++S) C.jb[S] = Ye(f) ? rt(f, 8) : 255;
      } else y.Bb = 0;
      if (f.Ka) return Yn(A, 3, "cannot parse segment header");
      if ((y = A.ed).zd = Ye(f), y.Tb = rt(f, 6), y.wb = rt(f, 3), y.Pc = Ye(f), y.Pc && Ye(f)) {
        for (C = 0; 4 > C; ++C) Ye(f) && (y.vd[C] = st(f, 6));
        for (C = 0; 4 > C; ++C) Ye(f) && (y.od[C] = st(f, 6));
      }
      if (A.L = y.Tb == 0 ? 0 : y.zd ? 1 : 2, f.Ka) return Yn(A, 3, "cannot parse filter header");
      var B = h;
      if (h = S = s, s = S + B, y = B, A.Xb = (1 << rt(A.m, 2)) - 1, B < 3 * (C = A.Xb)) g = 7;
      else {
        for (S += 3 * C, y -= 3 * C, B = 0; B < C; ++B) {
          var D = g[h + 0] | g[h + 1] << 8 | g[h + 2] << 16;
          D > y && (D = y), et(A.Jc[+B], g, S, D), S += D, y -= D, h += 3;
        }
        et(A.Jc[+C], g, S, y), g = S < s ? 0 : 5;
      }
      if (g != 0) return Yn(A, g, "cannot parse partitions");
      for (g = rt(S = A.m, 7), h = Ye(S) ? st(S, 4) : 0, s = Ye(S) ? st(S, 4) : 0, y = Ye(S) ? st(S, 4) : 0, C = Ye(S) ? st(S, 4) : 0, S = Ye(S) ? st(S, 4) : 0, B = A.Qa, D = 0; 4 > D; ++D) {
        if (B.Cb) {
          var z = B.Zb[D];
          B.Fb || (z += g);
        } else {
          if (0 < D) {
            A.pb[D] = A.pb[0];
            continue;
          }
          z = g;
        }
        var N = A.pb[D];
        N.Sc[0] = Ss[$n(z + h, 127)], N.Sc[1] = ia[$n(z + 0, 127)], N.Eb[0] = 2 * Ss[$n(z + s, 127)], N.Eb[1] = 101581 * ia[$n(z + y, 127)] >> 16, 8 > N.Eb[1] && (N.Eb[1] = 8), N.Qc[0] = Ss[$n(z + C, 117)], N.Qc[1] = ia[$n(z + S, 127)], N.lc = z + S;
      }
      if (!m.Rb) return Yn(A, 4, "Not a key frame.");
      for (Ye(f), m = A.Pa, g = 0; 4 > g; ++g) {
        for (h = 0; 8 > h; ++h) for (s = 0; 3 > s; ++s) for (y = 0; 11 > y; ++y) C = Ze(f, Vs[g][h][s][y]) ? rt(f, 8) : ih[g][h][s][y], m.Wc[g][h].Yb[s][y] = C;
        for (h = 0; 17 > h; ++h) m.Xc[g][h] = m.Wc[g][qt[h]];
      }
      return A.kc = Ye(f), A.kc && (A.Bd = rt(f, 8)), A.cb = 1;
    }
    function lo(A, M, g, s, h, f, m) {
      var y = M[h].Yb[g];
      for (g = 0; 16 > h; ++h) {
        if (!Ze(A, y[g + 0])) return h;
        for (; !Ze(A, y[g + 1]); ) if (y = M[++h].Yb[0], g = 0, h == 16) return 16;
        var S = M[h + 1].Yb;
        if (Ze(A, y[g + 2])) {
          var C = A, B = 0;
          if (Ze(C, (z = y)[(D = g) + 3]))
            if (Ze(C, z[D + 6])) {
              for (y = 0, D = 2 * (B = Ze(C, z[D + 8])) + (z = Ze(C, z[D + 9 + B])), B = 0, z = uf[D]; z[y]; ++y) B += B + Ze(C, z[y]);
              B += 3 + (8 << D);
            } else Ze(C, z[D + 7]) ? (B = 7 + 2 * Ze(C, 165), B += Ze(C, 145)) : B = 5 + Ze(C, 159);
          else B = Ze(C, z[D + 4]) ? 3 + Ze(C, z[D + 5]) : 2;
          y = S[2];
        } else B = 1, y = S[1];
        S = m + Xh[h], 0 > (C = A).b && He(C);
        var D, z = C.b, N = (D = C.Ca >> 1) - (C.I >> z) >> 31;
        --C.b, C.Ca += N, C.Ca |= 1, C.I -= (D + 1 & N) << z, f[S] = ((B ^ N) - N) * s[(0 < h) + 0];
      }
      return 16;
    }
    function pi(A) {
      var M = A.rb[A.sb - 1];
      M.la = 0, M.Na = 0, i(A.zc, 0, 0, A.zc.length), A.ja = 0;
    }
    function Zo(A, M) {
      if (A == null) return 0;
      if (M == null) return Yn(A, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!A.cb && !pr(A, M)) return 0;
      if (e(A.cb), M.ac == null || M.ac(M)) {
        M.ob && (A.L = 0);
        var g = Da[A.L];
        if (A.L == 2 ? (A.yb = 0, A.zb = 0) : (A.yb = M.v - g >> 4, A.zb = M.j - g >> 4, 0 > A.yb && (A.yb = 0), 0 > A.zb && (A.zb = 0)), A.Va = M.o + 15 + g >> 4, A.Hb = M.va + 15 + g >> 4, A.Hb > A.za && (A.Hb = A.za), A.Va > A.Ub && (A.Va = A.Ub), 0 < A.L) {
          var s = A.ed;
          for (g = 0; 4 > g; ++g) {
            var h;
            if (A.Qa.Cb) {
              var f = A.Qa.Lb[g];
              A.Qa.Fb || (f += s.Tb);
            } else f = s.Tb;
            for (h = 0; 1 >= h; ++h) {
              var m = A.gd[g][h], y = f;
              if (s.Pc && (y += s.vd[0], h && (y += s.od[0])), 0 < (y = 0 > y ? 0 : 63 < y ? 63 : y)) {
                var S = y;
                0 < s.wb && (S = 4 < s.wb ? S >> 2 : S >> 1) > 9 - s.wb && (S = 9 - s.wb), 1 > S && (S = 1), m.dd = S, m.tc = 2 * y + S, m.ld = 40 <= y ? 2 : 15 <= y ? 1 : 0;
              } else m.tc = 0;
              m.La = h;
            }
          }
        }
        g = 0;
      } else Yn(A, 6, "Frame setup failed"), g = A.a;
      if (g = g == 0) {
        if (g) {
          A.$c = 0, 0 < A.Aa || (A.Ic = gn);
          e: {
            g = A.Ic, s = 4 * (S = A.za);
            var C = 32 * S, B = S + 1, D = 0 < A.L ? S * (0 < A.Aa ? 2 : 1) : 0, z = (A.Aa == 2 ? 2 : 1) * S;
            if ((m = s + 832 + (h = 3 * (16 * g + Da[A.L]) / 2 * C) + (f = A.Fa != null && 0 < A.Fa.length ? A.Kc.c * A.Kc.i : 0)) != m) g = 0;
            else {
              if (m > A.Vb) {
                if (A.Vb = 0, A.Ec = o(m), A.Fc = 0, A.Ec == null) {
                  g = Yn(A, 1, "no memory during frame initialization.");
                  break e;
                }
                A.Vb = m;
              }
              m = A.Ec, y = A.Fc, A.Ac = m, A.Bc = y, y += s, A.Gd = c(C, Er), A.Hd = 0, A.rb = c(B + 1, Pr), A.sb = 1, A.wa = D ? c(D, Xi) : null, A.Y = 0, A.D.Nb = 0, A.D.wa = A.wa, A.D.Y = A.Y, 0 < A.Aa && (A.D.Y += S), e(!0), A.oc = m, A.pc = y, y += 832, A.ya = c(z, oo), A.aa = 0, A.D.ya = A.ya, A.D.aa = A.aa, A.Aa == 2 && (A.D.aa += S), A.R = 16 * S, A.B = 8 * S, S = (C = Da[A.L]) * A.R, C = C / 2 * A.B, A.sa = m, A.ta = y + S, A.qa = A.sa, A.ra = A.ta + 16 * g * A.R + C, A.Ha = A.qa, A.Ia = A.ra + 8 * g * A.B + C, A.$c = 0, y += h, A.mb = f ? m : null, A.nb = f ? y : null, e(y + f <= A.Fc + A.Vb), pi(A), i(A.Ac, A.Bc, 0, s), g = 1;
            }
          }
          if (g) {
            if (M.ka = 0, M.y = A.sa, M.O = A.ta, M.f = A.qa, M.N = A.ra, M.ea = A.Ha, M.Vd = A.Ia, M.fa = A.R, M.Rc = A.B, M.F = null, M.J = 0, !Vl) {
              for (g = -255; 255 >= g; ++g) Qu[255 + g] = 0 > g ? -g : g;
              for (g = -1020; 1020 >= g; ++g) Wr[1020 + g] = -128 > g ? -128 : 127 < g ? 127 : g;
              for (g = -112; 112 >= g; ++g) js[112 + g] = -16 > g ? -16 : 15 < g ? 15 : g;
              for (g = -255; 510 >= g; ++g) us[255 + g] = 0 > g ? 0 : 255 < g ? 255 : g;
              Vl = 1;
            }
            Fs = me, rl = Xn, mo = Sa, Ni = Ya, cs = ae, Ma = Ji, ks = kl, Ba = el, Ns = fu, zs = Nl, Ra = du, es = Ea, _o = zl, Cr = Ec, br = uo, jr = jn, ii = ho, As = Yu, Es[0] = xs, Es[1] = nt, Es[2] = Ll, Es[3] = Ml, Es[4] = Sc, Es[5] = Bl, Es[6] = Jo, Es[7] = Rl, Es[8] = Zu, Es[9] = uu, yo[0] = ui, yo[1] = Vt, yo[2] = Pn, yo[3] = Br, yo[4] = nr, yo[5] = Ka, yo[6] = Ii, Do[0] = To, Do[1] = Tt, Do[2] = Ju, Do[3] = Ol, Do[4] = Yo, Do[5] = Dl, Do[6] = Qa, g = 1;
          } else g = 0;
        }
        g && (g = function(N, X) {
          for (N.M = 0; N.M < N.Va; ++N.M) {
            var Z, W = N.Jc[N.M & N.Xb], Q = N.m, le = N;
            for (Z = 0; Z < le.za; ++Z) {
              var ue = Q, fe = le, he = fe.Ac, ve = fe.Bc + 4 * Z, Be = fe.zc, Pe = fe.ya[fe.aa + Z];
              if (fe.Qa.Bb ? Pe.$b = Ze(ue, fe.Pa.jb[0]) ? 2 + Ze(ue, fe.Pa.jb[2]) : Ze(ue, fe.Pa.jb[1]) : Pe.$b = 0, fe.kc && (Pe.Ad = Ze(ue, fe.Bd)), Pe.Za = !Ze(ue, 145) + 0, Pe.Za) {
                var Qe = Pe.Ob, ft = 0;
                for (fe = 0; 4 > fe; ++fe) {
                  var _t, xt = Be[0 + fe];
                  for (_t = 0; 4 > _t; ++_t) {
                    xt = Zl[he[ve + _t]][xt];
                    for (var bt = rh[Ze(ue, xt[0])]; 0 < bt; ) bt = rh[2 * bt + Ze(ue, xt[bt])];
                    xt = -bt, he[ve + _t] = xt;
                  }
                  r(Qe, ft, he, ve, 4), ft += 4, Be[0 + fe] = xt;
                }
              } else xt = Ze(ue, 156) ? Ze(ue, 128) ? 1 : 3 : Ze(ue, 163) ? 2 : 0, Pe.Ob[0] = xt, i(he, ve, xt, 4), i(Be, 0, xt, 4);
              Pe.Dd = Ze(ue, 142) ? Ze(ue, 114) ? Ze(ue, 183) ? 1 : 3 : 2 : 0;
            }
            if (le.m.Ka) return Yn(N, 7, "Premature end-of-partition0 encountered.");
            for (; N.ja < N.za; ++N.ja) {
              if (le = W, ue = (Q = N).rb[Q.sb - 1], he = Q.rb[Q.sb + Q.ja], Z = Q.ya[Q.aa + Q.ja], ve = Q.kc ? Z.Ad : 0) ue.la = he.la = 0, Z.Za || (ue.Na = he.Na = 0), Z.Hc = 0, Z.Gc = 0, Z.ia = 0;
              else {
                var yt, wt;
                if (ue = he, he = le, ve = Q.Pa.Xc, Be = Q.ya[Q.aa + Q.ja], Pe = Q.pb[Be.$b], fe = Be.ad, Qe = 0, ft = Q.rb[Q.sb - 1], xt = _t = 0, i(fe, Qe, 0, 384), Be.Za) var Jt = 0, Ct = ve[3];
                else {
                  bt = o(16);
                  var It = ue.Na + ft.Na;
                  if (It = Oc(he, ve[1], It, Pe.Eb, 0, bt, 0), ue.Na = ft.Na = (0 < It) + 0, 1 < It) Fs(bt, 0, fe, Qe);
                  else {
                    var rn = bt[0] + 3 >> 3;
                    for (bt = 0; 256 > bt; bt += 16) fe[Qe + bt] = rn;
                  }
                  Jt = 1, Ct = ve[0];
                }
                var An = 15 & ue.la, yn = 15 & ft.la;
                for (bt = 0; 4 > bt; ++bt) {
                  var En = 1 & yn;
                  for (rn = wt = 0; 4 > rn; ++rn) An = An >> 1 | (En = (It = Oc(he, Ct, It = En + (1 & An), Pe.Sc, Jt, fe, Qe)) > Jt) << 7, wt = wt << 2 | (3 < It ? 3 : 1 < It ? 2 : fe[Qe + 0] != 0), Qe += 16;
                  An >>= 4, yn = yn >> 1 | En << 7, _t = (_t << 8 | wt) >>> 0;
                }
                for (Ct = An, Jt = yn >> 4, yt = 0; 4 > yt; yt += 2) {
                  for (wt = 0, An = ue.la >> 4 + yt, yn = ft.la >> 4 + yt, bt = 0; 2 > bt; ++bt) {
                    for (En = 1 & yn, rn = 0; 2 > rn; ++rn) It = En + (1 & An), An = An >> 1 | (En = 0 < (It = Oc(he, ve[2], It, Pe.Qc, 0, fe, Qe))) << 3, wt = wt << 2 | (3 < It ? 3 : 1 < It ? 2 : fe[Qe + 0] != 0), Qe += 16;
                    An >>= 2, yn = yn >> 1 | En << 5;
                  }
                  xt |= wt << 4 * yt, Ct |= An << 4 << yt, Jt |= (240 & yn) << yt;
                }
                ue.la = Ct, ft.la = Jt, Be.Hc = _t, Be.Gc = xt, Be.ia = 43690 & xt ? 0 : Pe.ia, ve = !(_t | xt);
              }
              if (0 < Q.L && (Q.wa[Q.Y + Q.ja] = Q.gd[Z.$b][Z.Za], Q.wa[Q.Y + Q.ja].La |= !ve), le.Ka) return Yn(N, 7, "Premature end-of-file encountered.");
            }
            if (pi(N), Q = X, le = 1, Z = (W = N).D, ue = 0 < W.L && W.M >= W.zb && W.M <= W.Va, W.Aa == 0) e: {
              if (Z.M = W.M, Z.uc = ue, Qo(W, Z), le = 1, Z = (wt = W.D).Nb, ue = (xt = Da[W.L]) * W.R, he = xt / 2 * W.B, bt = 16 * Z * W.R, rn = 8 * Z * W.B, ve = W.sa, Be = W.ta - ue + bt, Pe = W.qa, fe = W.ra - he + rn, Qe = W.Ha, ft = W.Ia - he + rn, yn = (An = wt.M) == 0, _t = An >= W.Va - 1, W.Aa == 2 && Qo(W, wt), wt.uc) for (En = (It = W).D.M, e(It.D.uc), wt = It.yb; wt < It.Hb; ++wt) {
                Jt = wt, Ct = En;
                var Dn = (sr = (Fr = It).D).Nb;
                yt = Fr.R;
                var sr = sr.wa[sr.Y + Jt], Dr = Fr.sa, Qn = Fr.ta + 16 * Dn * yt + 16 * Jt, Xr = sr.dd, or = sr.tc;
                if (or != 0) if (e(3 <= or), Fr.L == 1) 0 < Jt && jr(Dr, Qn, yt, or + 4), sr.La && As(Dr, Qn, yt, or), 0 < Ct && br(Dr, Qn, yt, or + 4), sr.La && ii(Dr, Qn, yt, or);
                else {
                  var Gr = Fr.B, oi = Fr.qa, ts = Fr.ra + 8 * Dn * Gr + 8 * Jt, Cs = Fr.Ha, Fr = Fr.Ia + 8 * Dn * Gr + 8 * Jt;
                  Dn = sr.ld, 0 < Jt && (Ba(Dr, Qn, yt, or + 4, Xr, Dn), zs(oi, ts, Cs, Fr, Gr, or + 4, Xr, Dn)), sr.La && (es(Dr, Qn, yt, or, Xr, Dn), Cr(oi, ts, Cs, Fr, Gr, or, Xr, Dn)), 0 < Ct && (ks(Dr, Qn, yt, or + 4, Xr, Dn), Ns(oi, ts, Cs, Fr, Gr, or + 4, Xr, Dn)), sr.La && (Ra(Dr, Qn, yt, or, Xr, Dn), _o(oi, ts, Cs, Fr, Gr, or, Xr, Dn));
                }
              }
              if (W.ia && alert("todo:DitherRow"), Q.put != null) {
                if (wt = 16 * An, An = 16 * (An + 1), yn ? (Q.y = W.sa, Q.O = W.ta + bt, Q.f = W.qa, Q.N = W.ra + rn, Q.ea = W.Ha, Q.W = W.Ia + rn) : (wt -= xt, Q.y = ve, Q.O = Be, Q.f = Pe, Q.N = fe, Q.ea = Qe, Q.W = ft), _t || (An -= xt), An > Q.o && (An = Q.o), Q.F = null, Q.J = null, W.Fa != null && 0 < W.Fa.length && wt < An && (Q.J = Gl(W, Q, wt, An - wt), Q.F = W.mb, Q.F == null && Q.F.length == 0)) {
                  le = Yn(W, 3, "Could not decode alpha data.");
                  break e;
                }
                wt < Q.j && (xt = Q.j - wt, wt = Q.j, e(!(1 & xt)), Q.O += W.R * xt, Q.N += W.B * (xt >> 1), Q.W += W.B * (xt >> 1), Q.F != null && (Q.J += Q.width * xt)), wt < An && (Q.O += Q.v, Q.N += Q.v >> 1, Q.W += Q.v >> 1, Q.F != null && (Q.J += Q.v), Q.ka = wt - Q.j, Q.U = Q.va - Q.v, Q.T = An - wt, le = Q.put(Q));
              }
              Z + 1 != W.Ic || _t || (r(W.sa, W.ta - ue, ve, Be + 16 * W.R, ue), r(W.qa, W.ra - he, Pe, fe + 8 * W.B, he), r(W.Ha, W.Ia - he, Qe, ft + 8 * W.B, he));
            }
            if (!le) return Yn(N, 6, "Output aborted.");
          }
          return 1;
        }(A, M)), M.bc != null && M.bc(M), g &= 1;
      }
      return g ? (A.cb = 0, g) : 0;
    }
    function Tr(A, M, g, s, h) {
      h = A[M + g + 32 * s] + (h >> 3), A[M + g + 32 * s] = -256 & h ? 0 > h ? 0 : 255 : h;
    }
    function Zi(A, M, g, s, h, f) {
      Tr(A, M, 0, g, s + h), Tr(A, M, 1, g, s + f), Tr(A, M, 2, g, s - f), Tr(A, M, 3, g, s - h);
    }
    function gi(A) {
      return (20091 * A >> 16) + A;
    }
    function as(A, M, g, s) {
      var h, f = 0, m = o(16);
      for (h = 0; 4 > h; ++h) {
        var y = A[M + 0] + A[M + 8], S = A[M + 0] - A[M + 8], C = (35468 * A[M + 4] >> 16) - gi(A[M + 12]), B = gi(A[M + 4]) + (35468 * A[M + 12] >> 16);
        m[f + 0] = y + B, m[f + 1] = S + C, m[f + 2] = S - C, m[f + 3] = y - B, f += 4, M++;
      }
      for (h = f = 0; 4 > h; ++h) y = (A = m[f + 0] + 4) + m[f + 8], S = A - m[f + 8], C = (35468 * m[f + 4] >> 16) - gi(m[f + 12]), Tr(g, s, 0, 0, y + (B = gi(m[f + 4]) + (35468 * m[f + 12] >> 16))), Tr(g, s, 1, 0, S + C), Tr(g, s, 2, 0, S - C), Tr(g, s, 3, 0, y - B), f++, s += 32;
    }
    function Ji(A, M, g, s) {
      var h = A[M + 0] + 4, f = 35468 * A[M + 4] >> 16, m = gi(A[M + 4]), y = 35468 * A[M + 1] >> 16;
      Zi(g, s, 0, h + m, A = gi(A[M + 1]), y), Zi(g, s, 1, h + f, A, y), Zi(g, s, 2, h - f, A, y), Zi(g, s, 3, h - m, A, y);
    }
    function Xn(A, M, g, s, h) {
      as(A, M, g, s), h && as(A, M + 16, g, s + 4);
    }
    function Sa(A, M, g, s) {
      rl(A, M + 0, g, s, 1), rl(A, M + 32, g, s + 128, 1);
    }
    function Ya(A, M, g, s) {
      var h;
      for (A = A[M + 0] + 4, h = 0; 4 > h; ++h) for (M = 0; 4 > M; ++M) Tr(g, s, M, h, A);
    }
    function ae(A, M, g, s) {
      A[M + 0] && Ni(A, M + 0, g, s), A[M + 16] && Ni(A, M + 16, g, s + 4), A[M + 32] && Ni(A, M + 32, g, s + 128), A[M + 48] && Ni(A, M + 48, g, s + 128 + 4);
    }
    function me(A, M, g, s) {
      var h, f = o(16);
      for (h = 0; 4 > h; ++h) {
        var m = A[M + 0 + h] + A[M + 12 + h], y = A[M + 4 + h] + A[M + 8 + h], S = A[M + 4 + h] - A[M + 8 + h], C = A[M + 0 + h] - A[M + 12 + h];
        f[0 + h] = m + y, f[8 + h] = m - y, f[4 + h] = C + S, f[12 + h] = C - S;
      }
      for (h = 0; 4 > h; ++h) m = (A = f[0 + 4 * h] + 3) + f[3 + 4 * h], y = f[1 + 4 * h] + f[2 + 4 * h], S = f[1 + 4 * h] - f[2 + 4 * h], C = A - f[3 + 4 * h], g[s + 0] = m + y >> 3, g[s + 16] = C + S >> 3, g[s + 32] = m - y >> 3, g[s + 48] = C - S >> 3, s += 64;
    }
    function De(A, M, g) {
      var s, h = M - 32, f = xi, m = 255 - A[h - 1];
      for (s = 0; s < g; ++s) {
        var y, S = f, C = m + A[M - 1];
        for (y = 0; y < g; ++y) A[M + y] = S[C + A[h + y]];
        M += 32;
      }
    }
    function nt(A, M) {
      De(A, M, 4);
    }
    function Tt(A, M) {
      De(A, M, 8);
    }
    function Vt(A, M) {
      De(A, M, 16);
    }
    function Pn(A, M) {
      var g;
      for (g = 0; 16 > g; ++g) r(A, M + 32 * g, A, M - 32, 16);
    }
    function Br(A, M) {
      var g;
      for (g = 16; 0 < g; --g) i(A, M, A[M - 1], 16), M += 32;
    }
    function Rr(A, M, g) {
      var s;
      for (s = 0; 16 > s; ++s) i(M, g + 32 * s, A, 16);
    }
    function ui(A, M) {
      var g, s = 16;
      for (g = 0; 16 > g; ++g) s += A[M - 1 + 32 * g] + A[M + g - 32];
      Rr(s >> 5, A, M);
    }
    function nr(A, M) {
      var g, s = 8;
      for (g = 0; 16 > g; ++g) s += A[M - 1 + 32 * g];
      Rr(s >> 4, A, M);
    }
    function Ka(A, M) {
      var g, s = 8;
      for (g = 0; 16 > g; ++g) s += A[M + g - 32];
      Rr(s >> 4, A, M);
    }
    function Ii(A, M) {
      Rr(128, A, M);
    }
    function dn(A, M, g) {
      return A + 2 * M + g + 2 >> 2;
    }
    function Ll(A, M) {
      var g, s = M - 32;
      for (s = new Uint8Array([dn(A[s - 1], A[s + 0], A[s + 1]), dn(A[s + 0], A[s + 1], A[s + 2]), dn(A[s + 1], A[s + 2], A[s + 3]), dn(A[s + 2], A[s + 3], A[s + 4])]), g = 0; 4 > g; ++g) r(A, M + 32 * g, s, 0, s.length);
    }
    function Ml(A, M) {
      var g = A[M - 1], s = A[M - 1 + 32], h = A[M - 1 + 64], f = A[M - 1 + 96];
      St(A, M + 0, 16843009 * dn(A[M - 1 - 32], g, s)), St(A, M + 32, 16843009 * dn(g, s, h)), St(A, M + 64, 16843009 * dn(s, h, f)), St(A, M + 96, 16843009 * dn(h, f, f));
    }
    function xs(A, M) {
      var g, s = 4;
      for (g = 0; 4 > g; ++g) s += A[M + g - 32] + A[M - 1 + 32 * g];
      for (s >>= 3, g = 0; 4 > g; ++g) i(A, M + 32 * g, s, 4);
    }
    function Sc(A, M) {
      var g = A[M - 1 + 0], s = A[M - 1 + 32], h = A[M - 1 + 64], f = A[M - 1 - 32], m = A[M + 0 - 32], y = A[M + 1 - 32], S = A[M + 2 - 32], C = A[M + 3 - 32];
      A[M + 0 + 96] = dn(s, h, A[M - 1 + 96]), A[M + 1 + 96] = A[M + 0 + 64] = dn(g, s, h), A[M + 2 + 96] = A[M + 1 + 64] = A[M + 0 + 32] = dn(f, g, s), A[M + 3 + 96] = A[M + 2 + 64] = A[M + 1 + 32] = A[M + 0 + 0] = dn(m, f, g), A[M + 3 + 64] = A[M + 2 + 32] = A[M + 1 + 0] = dn(y, m, f), A[M + 3 + 32] = A[M + 2 + 0] = dn(S, y, m), A[M + 3 + 0] = dn(C, S, y);
    }
    function Jo(A, M) {
      var g = A[M + 1 - 32], s = A[M + 2 - 32], h = A[M + 3 - 32], f = A[M + 4 - 32], m = A[M + 5 - 32], y = A[M + 6 - 32], S = A[M + 7 - 32];
      A[M + 0 + 0] = dn(A[M + 0 - 32], g, s), A[M + 1 + 0] = A[M + 0 + 32] = dn(g, s, h), A[M + 2 + 0] = A[M + 1 + 32] = A[M + 0 + 64] = dn(s, h, f), A[M + 3 + 0] = A[M + 2 + 32] = A[M + 1 + 64] = A[M + 0 + 96] = dn(h, f, m), A[M + 3 + 32] = A[M + 2 + 64] = A[M + 1 + 96] = dn(f, m, y), A[M + 3 + 64] = A[M + 2 + 96] = dn(m, y, S), A[M + 3 + 96] = dn(y, S, S);
    }
    function Bl(A, M) {
      var g = A[M - 1 + 0], s = A[M - 1 + 32], h = A[M - 1 + 64], f = A[M - 1 - 32], m = A[M + 0 - 32], y = A[M + 1 - 32], S = A[M + 2 - 32], C = A[M + 3 - 32];
      A[M + 0 + 0] = A[M + 1 + 64] = f + m + 1 >> 1, A[M + 1 + 0] = A[M + 2 + 64] = m + y + 1 >> 1, A[M + 2 + 0] = A[M + 3 + 64] = y + S + 1 >> 1, A[M + 3 + 0] = S + C + 1 >> 1, A[M + 0 + 96] = dn(h, s, g), A[M + 0 + 64] = dn(s, g, f), A[M + 0 + 32] = A[M + 1 + 96] = dn(g, f, m), A[M + 1 + 32] = A[M + 2 + 96] = dn(f, m, y), A[M + 2 + 32] = A[M + 3 + 96] = dn(m, y, S), A[M + 3 + 32] = dn(y, S, C);
    }
    function Rl(A, M) {
      var g = A[M + 0 - 32], s = A[M + 1 - 32], h = A[M + 2 - 32], f = A[M + 3 - 32], m = A[M + 4 - 32], y = A[M + 5 - 32], S = A[M + 6 - 32], C = A[M + 7 - 32];
      A[M + 0 + 0] = g + s + 1 >> 1, A[M + 1 + 0] = A[M + 0 + 64] = s + h + 1 >> 1, A[M + 2 + 0] = A[M + 1 + 64] = h + f + 1 >> 1, A[M + 3 + 0] = A[M + 2 + 64] = f + m + 1 >> 1, A[M + 0 + 32] = dn(g, s, h), A[M + 1 + 32] = A[M + 0 + 96] = dn(s, h, f), A[M + 2 + 32] = A[M + 1 + 96] = dn(h, f, m), A[M + 3 + 32] = A[M + 2 + 96] = dn(f, m, y), A[M + 3 + 64] = dn(m, y, S), A[M + 3 + 96] = dn(y, S, C);
    }
    function uu(A, M) {
      var g = A[M - 1 + 0], s = A[M - 1 + 32], h = A[M - 1 + 64], f = A[M - 1 + 96];
      A[M + 0 + 0] = g + s + 1 >> 1, A[M + 2 + 0] = A[M + 0 + 32] = s + h + 1 >> 1, A[M + 2 + 32] = A[M + 0 + 64] = h + f + 1 >> 1, A[M + 1 + 0] = dn(g, s, h), A[M + 3 + 0] = A[M + 1 + 32] = dn(s, h, f), A[M + 3 + 32] = A[M + 1 + 64] = dn(h, f, f), A[M + 3 + 64] = A[M + 2 + 64] = A[M + 0 + 96] = A[M + 1 + 96] = A[M + 2 + 96] = A[M + 3 + 96] = f;
    }
    function Zu(A, M) {
      var g = A[M - 1 + 0], s = A[M - 1 + 32], h = A[M - 1 + 64], f = A[M - 1 + 96], m = A[M - 1 - 32], y = A[M + 0 - 32], S = A[M + 1 - 32], C = A[M + 2 - 32];
      A[M + 0 + 0] = A[M + 2 + 32] = g + m + 1 >> 1, A[M + 0 + 32] = A[M + 2 + 64] = s + g + 1 >> 1, A[M + 0 + 64] = A[M + 2 + 96] = h + s + 1 >> 1, A[M + 0 + 96] = f + h + 1 >> 1, A[M + 3 + 0] = dn(y, S, C), A[M + 2 + 0] = dn(m, y, S), A[M + 1 + 0] = A[M + 3 + 32] = dn(g, m, y), A[M + 1 + 32] = A[M + 3 + 64] = dn(s, g, m), A[M + 1 + 64] = A[M + 3 + 96] = dn(h, s, g), A[M + 1 + 96] = dn(f, h, s);
    }
    function Ju(A, M) {
      var g;
      for (g = 0; 8 > g; ++g) r(A, M + 32 * g, A, M - 32, 8);
    }
    function Ol(A, M) {
      var g;
      for (g = 0; 8 > g; ++g) i(A, M, A[M - 1], 8), M += 32;
    }
    function co(A, M, g) {
      var s;
      for (s = 0; 8 > s; ++s) i(M, g + 32 * s, A, 8);
    }
    function To(A, M) {
      var g, s = 8;
      for (g = 0; 8 > g; ++g) s += A[M + g - 32] + A[M - 1 + 32 * g];
      co(s >> 4, A, M);
    }
    function Dl(A, M) {
      var g, s = 4;
      for (g = 0; 8 > g; ++g) s += A[M + g - 32];
      co(s >> 3, A, M);
    }
    function Yo(A, M) {
      var g, s = 4;
      for (g = 0; 8 > g; ++g) s += A[M - 1 + 32 * g];
      co(s >> 3, A, M);
    }
    function Qa(A, M) {
      co(128, A, M);
    }
    function Yi(A, M, g) {
      var s = A[M - g], h = A[M + 0], f = 3 * (h - s) + Lc[1020 + A[M - 2 * g] - A[M + g]], m = il[112 + (f + 4 >> 3)];
      A[M - g] = xi[255 + s + il[112 + (f + 3 >> 3)]], A[M + 0] = xi[255 + h - m];
    }
    function hu(A, M, g, s) {
      var h = A[M + 0], f = A[M + g];
      return hi[255 + A[M - 2 * g] - A[M - g]] > s || hi[255 + f - h] > s;
    }
    function Fl(A, M, g, s) {
      return 4 * hi[255 + A[M - g] - A[M + 0]] + hi[255 + A[M - 2 * g] - A[M + g]] <= s;
    }
    function Co(A, M, g, s, h) {
      var f = A[M - 3 * g], m = A[M - 2 * g], y = A[M - g], S = A[M + 0], C = A[M + g], B = A[M + 2 * g], D = A[M + 3 * g];
      return 4 * hi[255 + y - S] + hi[255 + m - C] > s ? 0 : hi[255 + A[M - 4 * g] - f] <= h && hi[255 + f - m] <= h && hi[255 + m - y] <= h && hi[255 + D - B] <= h && hi[255 + B - C] <= h && hi[255 + C - S] <= h;
    }
    function uo(A, M, g, s) {
      var h = 2 * s + 1;
      for (s = 0; 16 > s; ++s) Fl(A, M + s, g, h) && Yi(A, M + s, g);
    }
    function jn(A, M, g, s) {
      var h = 2 * s + 1;
      for (s = 0; 16 > s; ++s) Fl(A, M + s * g, 1, h) && Yi(A, M + s * g, 1);
    }
    function ho(A, M, g, s) {
      var h;
      for (h = 3; 0 < h; --h) uo(A, M += 4 * g, g, s);
    }
    function Yu(A, M, g, s) {
      var h;
      for (h = 3; 0 < h; --h) jn(A, M += 4, g, s);
    }
    function ws(A, M, g, s, h, f, m, y) {
      for (f = 2 * f + 1; 0 < h--; ) {
        if (Co(A, M, g, f, m)) if (hu(A, M, g, y)) Yi(A, M, g);
        else {
          var S = A, C = M, B = g, D = S[C - 2 * B], z = S[C - B], N = S[C + 0], X = S[C + B], Z = S[C + 2 * B], W = 27 * (le = Lc[1020 + 3 * (N - z) + Lc[1020 + D - X]]) + 63 >> 7, Q = 18 * le + 63 >> 7, le = 9 * le + 63 >> 7;
          S[C - 3 * B] = xi[255 + S[C - 3 * B] + le], S[C - 2 * B] = xi[255 + D + Q], S[C - B] = xi[255 + z + W], S[C + 0] = xi[255 + N - W], S[C + B] = xi[255 + X - Q], S[C + 2 * B] = xi[255 + Z - le];
        }
        M += s;
      }
    }
    function fo(A, M, g, s, h, f, m, y) {
      for (f = 2 * f + 1; 0 < h--; ) {
        if (Co(A, M, g, f, m)) if (hu(A, M, g, y)) Yi(A, M, g);
        else {
          var S = A, C = M, B = g, D = S[C - B], z = S[C + 0], N = S[C + B], X = il[112 + ((Z = 3 * (z - D)) + 4 >> 3)], Z = il[112 + (Z + 3 >> 3)], W = X + 1 >> 1;
          S[C - 2 * B] = xi[255 + S[C - 2 * B] + W], S[C - B] = xi[255 + D + Z], S[C + 0] = xi[255 + z - X], S[C + B] = xi[255 + N - W];
        }
        M += s;
      }
    }
    function kl(A, M, g, s, h, f) {
      ws(A, M, g, 1, 16, s, h, f);
    }
    function el(A, M, g, s, h, f) {
      ws(A, M, 1, g, 16, s, h, f);
    }
    function du(A, M, g, s, h, f) {
      var m;
      for (m = 3; 0 < m; --m) fo(A, M += 4 * g, g, 1, 16, s, h, f);
    }
    function Ea(A, M, g, s, h, f) {
      var m;
      for (m = 3; 0 < m; --m) fo(A, M += 4, 1, g, 16, s, h, f);
    }
    function fu(A, M, g, s, h, f, m, y) {
      ws(A, M, h, 1, 8, f, m, y), ws(g, s, h, 1, 8, f, m, y);
    }
    function Nl(A, M, g, s, h, f, m, y) {
      ws(A, M, 1, h, 8, f, m, y), ws(g, s, 1, h, 8, f, m, y);
    }
    function zl(A, M, g, s, h, f, m, y) {
      fo(A, M + 4 * h, h, 1, 8, f, m, y), fo(g, s + 4 * h, h, 1, 8, f, m, y);
    }
    function Ec(A, M, g, s, h, f, m, y) {
      fo(A, M + 4, 1, h, 8, f, m, y), fo(g, s + 4, 1, h, 8, f, m, y);
    }
    function Os() {
      this.ba = new ti(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new be(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function Ul() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Tc() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Cc() {
      this.ua = 0, this.Wa = new ne(), this.vb = new ne(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new xe(), this.yc = new pe();
    }
    function tl() {
      this.xb = this.a = 0, this.l = new $i(), this.ca = new ti(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new re(), this.Pb = 0, this.wd = new re(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Cc(), this.ab = 0, this.gc = c(4, Tc), this.Oc = 0;
    }
    function jl() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new $i(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Io(A, M, g, s, h, f, m) {
      for (A = A == null ? 0 : A[M + 0], M = 0; M < m; ++M) h[f + M] = A + g[s + M] & 255, A = h[f + M];
    }
    function Ic(A, M, g, s, h, f, m) {
      var y;
      if (A == null) Io(null, null, g, s, h, f, m);
      else for (y = 0; y < m; ++y) h[f + y] = A[M + y] + g[s + y] & 255;
    }
    function Ta(A, M, g, s, h, f, m) {
      if (A == null) Io(null, null, g, s, h, f, m);
      else {
        var y, S = A[M + 0], C = S, B = S;
        for (y = 0; y < m; ++y) C = B + (S = A[M + y]) - C, B = g[s + y] + (-256 & C ? 0 > C ? 0 : 255 : C) & 255, C = S, h[f + y] = B;
      }
    }
    function Gl(A, M, g, s) {
      var h = M.width, f = M.o;
      if (e(A != null && M != null), 0 > g || 0 >= s || g + s > f) return null;
      if (!A.Cc) {
        if (A.ga == null) {
          var m;
          if (A.ga = new jl(), (m = A.ga == null) || (m = M.width * M.o, e(A.Gb.length == 0), A.Gb = o(m), A.Uc = 0, A.Gb == null ? m = 0 : (A.mb = A.Gb, A.nb = A.Uc, A.rc = null, m = 1), m = !m), !m) {
            m = A.ga;
            var y = A.Fa, S = A.P, C = A.qc, B = A.mb, D = A.nb, z = S + 1, N = C - 1, X = m.l;
            if (e(y != null && B != null && M != null), Fo[0] = null, Fo[1] = Io, Fo[2] = Ic, Fo[3] = Ta, m.ca = B, m.tb = D, m.c = M.width, m.i = M.height, e(0 < m.c && 0 < m.i), 1 >= C) M = 0;
            else if (m.$a = y[S + 0] >> 0 & 3, m.Z = y[S + 0] >> 2 & 3, m.Lc = y[S + 0] >> 4 & 3, S = y[S + 0] >> 6 & 3, 0 > m.$a || 1 < m.$a || 4 <= m.Z || 1 < m.Lc || S) M = 0;
            else if (X.put = Fe, X.ac = ye, X.bc = je, X.ma = m, X.width = M.width, X.height = M.height, X.Da = M.Da, X.v = M.v, X.va = M.va, X.j = M.j, X.o = M.o, m.$a) e: {
              e(m.$a == 1), M = Wn();
              t: for (; ; ) {
                if (M == null) {
                  M = 0;
                  break e;
                }
                if (e(m != null), m.mc = M, M.c = m.c, M.i = m.i, M.l = m.l, M.l.ma = m, M.l.width = m.c, M.l.height = m.i, M.a = 0, Je(M.m, y, z, N), !hn(m.c, m.i, 1, M, null) || (M.ab == 1 && M.gc[0].hc == 3 && Mn(M.s) ? (m.ic = 1, y = M.c * M.i, M.Ta = null, M.Ua = 0, M.V = o(y), M.Ba = 0, M.V == null ? (M.a = 1, M = 0) : M = 1) : (m.ic = 0, M = Fn(M, m.c)), !M)) break t;
                M = 1;
                break e;
              }
              m.mc = null, M = 0;
            }
            else M = N >= m.c * m.i;
            m = !M;
          }
          if (m) return null;
          A.ga.Lc != 1 ? A.Ga = 0 : s = f - g;
        }
        e(A.ga != null), e(g + s <= f);
        e: {
          if (M = (y = A.ga).c, f = y.l.o, y.$a == 0) {
            if (z = A.rc, N = A.Vc, X = A.Fa, S = A.P + 1 + g * M, C = A.mb, B = A.nb + g * M, e(S <= A.P + A.qc), y.Z != 0) for (e(Fo[y.Z] != null), m = 0; m < s; ++m) Fo[y.Z](z, N, X, S, C, B, M), z = C, N = B, B += M, S += M;
            else for (m = 0; m < s; ++m) r(C, B, X, S, M), z = C, N = B, B += M, S += M;
            A.rc = z, A.Vc = N;
          } else {
            if (e(y.mc != null), M = g + s, e((m = y.mc) != null), e(M <= m.i), m.C >= M) M = 1;
            else if (y.ic || Xe(), y.ic) {
              y = m.V, z = m.Ba, N = m.c;
              var Z = m.i, W = (X = 1, S = m.$ / N, C = m.$ % N, B = m.m, D = m.s, m.$), Q = N * Z, le = N * M, ue = D.wc, fe = W < le ? vt(D, C, S) : null;
              e(W <= Q), e(M <= Z), e(Mn(D));
              t: for (; ; ) {
                for (; !B.h && W < le; ) {
                  if (C & ue || (fe = vt(D, C, S)), e(fe != null), qe(B), 256 > (Z = ut(fe.G[0], fe.H[0], B))) y[z + W] = Z, ++W, ++C >= N && (C = 0, ++S <= M && !(S % 16) && In(m, S));
                  else {
                    if (!(280 > Z)) {
                      X = 0;
                      break t;
                    }
                    Z = Ie(Z - 256, B);
                    var he, ve = ut(fe.G[4], fe.H[4], B);
                    if (qe(B), !(W >= (ve = tt(N, ve = Ie(ve, B))) && Q - W >= Z)) {
                      X = 0;
                      break t;
                    }
                    for (he = 0; he < Z; ++he) y[z + W + he] = y[z + W + he - ve];
                    for (W += Z, C += Z; C >= N; ) C -= N, ++S <= M && !(S % 16) && In(m, S);
                    W < le && C & ue && (fe = vt(D, C, S));
                  }
                  e(B.h == Ce(B));
                }
                In(m, S > M ? M : S);
                break t;
              }
              !X || B.h && W < Q ? (X = 0, m.a = B.h ? 5 : 3) : m.$ = W, M = X;
            } else M = wn(m, m.V, m.Ba, m.c, m.i, M, er);
            if (!M) {
              s = 0;
              break e;
            }
          }
          g + s >= f && (A.Cc = 1), s = 1;
        }
        if (!s) return null;
        if (A.Cc && ((s = A.ga) != null && (s.mc = null), A.ga = null, 0 < A.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return A.nb + g * h;
    }
    function O(A, M, g, s, h, f) {
      for (; 0 < h--; ) {
        var m, y = A, S = M + (g ? 1 : 0), C = A, B = M + (g ? 0 : 3);
        for (m = 0; m < s; ++m) {
          var D = C[B + 4 * m];
          D != 255 && (D *= 32897, y[S + 4 * m + 0] = y[S + 4 * m + 0] * D >> 23, y[S + 4 * m + 1] = y[S + 4 * m + 1] * D >> 23, y[S + 4 * m + 2] = y[S + 4 * m + 2] * D >> 23);
        }
        M += f;
      }
    }
    function te(A, M, g, s, h) {
      for (; 0 < s--; ) {
        var f;
        for (f = 0; f < g; ++f) {
          var m = A[M + 2 * f + 0], y = 15 & (C = A[M + 2 * f + 1]), S = 4369 * y, C = (240 & C | C >> 4) * S >> 16;
          A[M + 2 * f + 0] = (240 & m | m >> 4) * S >> 16 & 240 | (15 & m | m << 4) * S >> 16 >> 4 & 15, A[M + 2 * f + 1] = 240 & C | y;
        }
        M += h;
      }
    }
    function Ee(A, M, g, s, h, f, m, y) {
      var S, C, B = 255;
      for (C = 0; C < h; ++C) {
        for (S = 0; S < s; ++S) {
          var D = A[M + S];
          f[m + 4 * S] = D, B &= D;
        }
        M += g, m += y;
      }
      return B != 255;
    }
    function ze(A, M, g, s, h) {
      var f;
      for (f = 0; f < h; ++f) g[s + f] = A[M + f] >> 8;
    }
    function Xe() {
      Us = O, si = te, Ro = Ee, Ku = ze;
    }
    function lt(A, M, g) {
      _e[A] = function(s, h, f, m, y, S, C, B, D, z, N, X, Z, W, Q, le, ue) {
        var fe, he = ue - 1 >> 1, ve = y[S + 0] | C[B + 0] << 16, Be = D[z + 0] | N[X + 0] << 16;
        e(s != null);
        var Pe = 3 * ve + Be + 131074 >> 2;
        for (M(s[h + 0], 255 & Pe, Pe >> 16, Z, W), f != null && (Pe = 3 * Be + ve + 131074 >> 2, M(f[m + 0], 255 & Pe, Pe >> 16, Q, le)), fe = 1; fe <= he; ++fe) {
          var Qe = y[S + fe] | C[B + fe] << 16, ft = D[z + fe] | N[X + fe] << 16, _t = ve + Qe + Be + ft + 524296, xt = _t + 2 * (Qe + Be) >> 3;
          Pe = xt + ve >> 1, ve = (_t = _t + 2 * (ve + ft) >> 3) + Qe >> 1, M(s[h + 2 * fe - 1], 255 & Pe, Pe >> 16, Z, W + (2 * fe - 1) * g), M(s[h + 2 * fe - 0], 255 & ve, ve >> 16, Z, W + (2 * fe - 0) * g), f != null && (Pe = _t + Be >> 1, ve = xt + ft >> 1, M(f[m + 2 * fe - 1], 255 & Pe, Pe >> 16, Q, le + (2 * fe - 1) * g), M(f[m + 2 * fe + 0], 255 & ve, ve >> 16, Q, le + (2 * fe + 0) * g)), ve = Qe, Be = ft;
        }
        1 & ue || (Pe = 3 * ve + Be + 131074 >> 2, M(s[h + ue - 1], 255 & Pe, Pe >> 16, Z, W + (ue - 1) * g), f != null && (Pe = 3 * Be + ve + 131074 >> 2, M(f[m + ue - 1], 255 & Pe, Pe >> 16, Q, le + (ue - 1) * g)));
      };
    }
    function Pt() {
      Cn[ql] = sh, Cn[sl] = mu, Cn[gu] = hf, Cn[ol] = $h, Cn[Hl] = cl, Cn[Mc] = oh, Cn[Oa] = ah, Cn[Wl] = mu, Cn[al] = $h, Cn[Xl] = cl, Cn[Bc] = oh;
    }
    function Wt(A) {
      return A & ~Ts ? 0 > A ? 0 : 255 : A >> Zh;
    }
    function _n(A, M) {
      return Wt((19077 * A >> 8) + (26149 * M >> 8) - 14234);
    }
    function Ln(A, M, g) {
      return Wt((19077 * A >> 8) - (6419 * M >> 8) - (13320 * g >> 8) + 8708);
    }
    function kn(A, M) {
      return Wt((19077 * A >> 8) + (33050 * M >> 8) - 17685);
    }
    function Gn(A, M, g, s, h) {
      s[h + 0] = _n(A, g), s[h + 1] = Ln(A, M, g), s[h + 2] = kn(A, M);
    }
    function Or(A, M, g, s, h) {
      s[h + 0] = kn(A, M), s[h + 1] = Ln(A, M, g), s[h + 2] = _n(A, g);
    }
    function ri(A, M, g, s, h) {
      var f = Ln(A, M, g);
      M = f << 3 & 224 | kn(A, M) >> 3, s[h + 0] = 248 & _n(A, g) | f >> 5, s[h + 1] = M;
    }
    function Nn(A, M, g, s, h) {
      var f = 240 & kn(A, M) | 15;
      s[h + 0] = 240 & _n(A, g) | Ln(A, M, g) >> 4, s[h + 1] = f;
    }
    function Di(A, M, g, s, h) {
      s[h + 0] = 255, Gn(A, M, g, s, h + 1);
    }
    function fn(A, M, g, s, h) {
      Or(A, M, g, s, h), s[h + 3] = 255;
    }
    function ls(A, M, g, s, h) {
      Gn(A, M, g, s, h), s[h + 3] = 255;
    }
    function $n(A, M) {
      return 0 > A ? 0 : A > M ? M : A;
    }
    function Kn(A, M, g) {
      _e[A] = function(s, h, f, m, y, S, C, B, D) {
        for (var z = B + (-2 & D) * g; B != z; ) M(s[h + 0], f[m + 0], y[S + 0], C, B), M(s[h + 1], f[m + 0], y[S + 0], C, B + g), h += 2, ++m, ++S, B += 2 * g;
        1 & D && M(s[h + 0], f[m + 0], y[S + 0], C, B);
      };
    }
    function Po(A, M, g) {
      return g == 0 ? A == 0 ? M == 0 ? 6 : 5 : M == 0 ? 4 : 0 : g;
    }
    function Ko(A, M, g, s, h) {
      switch (A >>> 30) {
        case 3:
          rl(M, g, s, h, 0);
          break;
        case 2:
          Ma(M, g, s, h);
          break;
        case 1:
          Ni(M, g, s, h);
      }
    }
    function Qo(A, M) {
      var g, s, h = M.M, f = M.Nb, m = A.oc, y = A.pc + 40, S = A.oc, C = A.pc + 584, B = A.oc, D = A.pc + 600;
      for (g = 0; 16 > g; ++g) m[y + 32 * g - 1] = 129;
      for (g = 0; 8 > g; ++g) S[C + 32 * g - 1] = 129, B[D + 32 * g - 1] = 129;
      for (0 < h ? m[y - 1 - 32] = S[C - 1 - 32] = B[D - 1 - 32] = 129 : (i(m, y - 32 - 1, 127, 21), i(S, C - 32 - 1, 127, 9), i(B, D - 32 - 1, 127, 9)), s = 0; s < A.za; ++s) {
        var z = M.ya[M.aa + s];
        if (0 < s) {
          for (g = -1; 16 > g; ++g) r(m, y + 32 * g - 4, m, y + 32 * g + 12, 4);
          for (g = -1; 8 > g; ++g) r(S, C + 32 * g - 4, S, C + 32 * g + 4, 4), r(B, D + 32 * g - 4, B, D + 32 * g + 4, 4);
        }
        var N = A.Gd, X = A.Hd + s, Z = z.ad, W = z.Hc;
        if (0 < h && (r(m, y - 32, N[X].y, 0, 16), r(S, C - 32, N[X].f, 0, 8), r(B, D - 32, N[X].ea, 0, 8)), z.Za) {
          var Q = m, le = y - 32 + 16;
          for (0 < h && (s >= A.za - 1 ? i(Q, le, N[X].y[15], 4) : r(Q, le, N[X + 1].y, 0, 4)), g = 0; 4 > g; g++) Q[le + 128 + g] = Q[le + 256 + g] = Q[le + 384 + g] = Q[le + 0 + g];
          for (g = 0; 16 > g; ++g, W <<= 2) Q = m, le = y + bo[g], Es[z.Ob[g]](Q, le), Ko(W, Z, 16 * +g, Q, le);
        } else if (Q = Po(s, h, z.Ob[0]), yo[Q](m, y), W != 0) for (g = 0; 16 > g; ++g, W <<= 2) Ko(W, Z, 16 * +g, m, y + bo[g]);
        for (g = z.Gc, Q = Po(s, h, z.Dd), Do[Q](S, C), Do[Q](B, D), W = Z, Q = S, le = C, 255 & (z = g >> 0) && (170 & z ? mo(W, 256, Q, le) : cs(W, 256, Q, le)), z = B, W = D, 255 & (g >>= 8) && (170 & g ? mo(Z, 320, z, W) : cs(Z, 320, z, W)), h < A.Ub - 1 && (r(N[X].y, 0, m, y + 480, 16), r(N[X].f, 0, S, C + 224, 8), r(N[X].ea, 0, B, D + 224, 8)), g = 8 * f * A.B, N = A.sa, X = A.ta + 16 * s + 16 * f * A.R, Z = A.qa, z = A.ra + 8 * s + g, W = A.Ha, Q = A.Ia + 8 * s + g, g = 0; 16 > g; ++g) r(N, X + g * A.R, m, y + 32 * g, 16);
        for (g = 0; 8 > g; ++g) r(Z, z + g * A.B, S, C + 32 * g, 8), r(W, Q + g * A.B, B, D + 32 * g, 8);
      }
    }
    function Ca(A, M, g, s, h, f, m, y, S) {
      var C = [0], B = [0], D = 0, z = S != null ? S.kd : 0, N = S ?? new Ul();
      if (A == null || 12 > g) return 7;
      N.data = A, N.w = M, N.ha = g, M = [M], g = [g], N.gb = [N.gb];
      e: {
        var X = M, Z = g, W = N.gb;
        if (e(A != null), e(Z != null), e(W != null), W[0] = 0, 12 <= Z[0] && !t(A, X[0], "RIFF")) {
          if (t(A, X[0] + 8, "WEBP")) {
            W = 3;
            break e;
          }
          var Q = Nt(A, X[0] + 4);
          if (12 > Q || 4294967286 < Q) {
            W = 3;
            break e;
          }
          if (z && Q > Z[0] - 8) {
            W = 7;
            break e;
          }
          W[0] = Q, X[0] += 12, Z[0] -= 12;
        }
        W = 0;
      }
      if (W != 0) return W;
      for (Q = 0 < N.gb[0], g = g[0]; ; ) {
        e: {
          var le = A;
          Z = M, W = g;
          var ue = C, fe = B, he = X = [0];
          if ((Pe = D = [D])[0] = 0, 8 > W[0]) W = 7;
          else {
            if (!t(le, Z[0], "VP8X")) {
              if (Nt(le, Z[0] + 4) != 10) {
                W = 3;
                break e;
              }
              if (18 > W[0]) {
                W = 7;
                break e;
              }
              var ve = Nt(le, Z[0] + 8), Be = 1 + Dt(le, Z[0] + 12);
              if (2147483648 <= Be * (le = 1 + Dt(le, Z[0] + 15))) {
                W = 3;
                break e;
              }
              he != null && (he[0] = ve), ue != null && (ue[0] = Be), fe != null && (fe[0] = le), Z[0] += 18, W[0] -= 18, Pe[0] = 1;
            }
            W = 0;
          }
        }
        if (D = D[0], X = X[0], W != 0) return W;
        if (Z = !!(2 & X), !Q && D) return 3;
        if (f != null && (f[0] = !!(16 & X)), m != null && (m[0] = Z), y != null && (y[0] = 0), m = C[0], X = B[0], D && Z && S == null) {
          W = 0;
          break;
        }
        if (4 > g) {
          W = 7;
          break;
        }
        if (Q && D || !Q && !D && !t(A, M[0], "ALPH")) {
          g = [g], N.na = [N.na], N.P = [N.P], N.Sa = [N.Sa];
          e: {
            ve = A, W = M, Q = g;
            var Pe = N.gb;
            ue = N.na, fe = N.P, he = N.Sa, Be = 22, e(ve != null), e(Q != null), le = W[0];
            var Qe = Q[0];
            for (e(ue != null), e(he != null), ue[0] = null, fe[0] = null, he[0] = 0; ; ) {
              if (W[0] = le, Q[0] = Qe, 8 > Qe) {
                W = 7;
                break e;
              }
              var ft = Nt(ve, le + 4);
              if (4294967286 < ft) {
                W = 3;
                break e;
              }
              var _t = 8 + ft + 1 & -2;
              if (Be += _t, 0 < Pe && Be > Pe) {
                W = 3;
                break e;
              }
              if (!t(ve, le, "VP8 ") || !t(ve, le, "VP8L")) {
                W = 0;
                break e;
              }
              if (Qe[0] < _t) {
                W = 7;
                break e;
              }
              t(ve, le, "ALPH") || (ue[0] = ve, fe[0] = le + 8, he[0] = ft), le += _t, Qe -= _t;
            }
          }
          if (g = g[0], N.na = N.na[0], N.P = N.P[0], N.Sa = N.Sa[0], W != 0) break;
        }
        g = [g], N.Ja = [N.Ja], N.xa = [N.xa];
        e: if (Pe = A, W = M, Q = g, ue = N.gb[0], fe = N.Ja, he = N.xa, ve = W[0], le = !t(Pe, ve, "VP8 "), Be = !t(Pe, ve, "VP8L"), e(Pe != null), e(Q != null), e(fe != null), e(he != null), 8 > Q[0]) W = 7;
        else {
          if (le || Be) {
            if (Pe = Nt(Pe, ve + 4), 12 <= ue && Pe > ue - 12) {
              W = 3;
              break e;
            }
            if (z && Pe > Q[0] - 8) {
              W = 7;
              break e;
            }
            fe[0] = Pe, W[0] += 8, Q[0] -= 8, he[0] = Be;
          } else he[0] = 5 <= Q[0] && Pe[ve + 0] == 47 && !(Pe[ve + 4] >> 5), fe[0] = Q[0];
          W = 0;
        }
        if (g = g[0], N.Ja = N.Ja[0], N.xa = N.xa[0], M = M[0], W != 0) break;
        if (4294967286 < N.Ja) return 3;
        if (y == null || Z || (y[0] = N.xa ? 2 : 1), m = [m], X = [X], N.xa) {
          if (5 > g) {
            W = 7;
            break;
          }
          y = m, z = X, Z = f, A == null || 5 > g ? A = 0 : 5 <= g && A[M + 0] == 47 && !(A[M + 4] >> 5) ? (Q = [0], Pe = [0], ue = [0], Je(fe = new re(), A, M, g), Oe(fe, Q, Pe, ue) ? (y != null && (y[0] = Q[0]), z != null && (z[0] = Pe[0]), Z != null && (Z[0] = ue[0]), A = 1) : A = 0) : A = 0;
        } else {
          if (10 > g) {
            W = 7;
            break;
          }
          y = X, A == null || 10 > g || !fi(A, M + 3, g - 3) ? A = 0 : (z = A[M + 0] | A[M + 1] << 8 | A[M + 2] << 16, Z = 16383 & (A[M + 7] << 8 | A[M + 6]), A = 16383 & (A[M + 9] << 8 | A[M + 8]), 1 & z || 3 < (z >> 1 & 7) || !(z >> 4 & 1) || z >> 5 >= N.Ja || !Z || !A ? A = 0 : (m && (m[0] = Z), y && (y[0] = A), A = 1));
        }
        if (!A || (m = m[0], X = X[0], D && (C[0] != m || B[0] != X))) return 3;
        S != null && (S[0] = N, S.offset = M - S.w, e(4294967286 > M - S.w), e(S.offset == S.ha - g));
        break;
      }
      return W == 0 || W == 7 && D && S == null ? (f != null && (f[0] |= N.na != null && 0 < N.na.length), s != null && (s[0] = m), h != null && (h[0] = X), 0) : W;
    }
    function po(A, M, g) {
      var s = M.width, h = M.height, f = 0, m = 0, y = s, S = h;
      if (M.Da = A != null && 0 < A.Da, M.Da && (y = A.cd, S = A.bd, f = A.v, m = A.j, 11 > g || (f &= -2, m &= -2), 0 > f || 0 > m || 0 >= y || 0 >= S || f + y > s || m + S > h)) return 0;
      if (M.v = f, M.j = m, M.va = f + y, M.o = m + S, M.U = y, M.T = S, M.da = A != null && 0 < A.da, M.da) {
        if (!pn(y, S, g = [A.ib], f = [A.hb])) return 0;
        M.ib = g[0], M.hb = f[0];
      }
      return M.ob = A != null && A.ob, M.Kb = A == null || !A.Sd, M.da && (M.ob = M.ib < 3 * s / 4 && M.hb < 3 * h / 4, M.Kb = 0), 1;
    }
    function Lo(A) {
      if (A == null) return 2;
      if (11 > A.S) {
        var M = A.f.RGBA;
        M.fb += (A.height - 1) * M.A, M.A = -M.A;
      } else M = A.f.kb, A = A.height, M.O += (A - 1) * M.fa, M.fa = -M.fa, M.N += (A - 1 >> 1) * M.Ab, M.Ab = -M.Ab, M.W += (A - 1 >> 1) * M.Db, M.Db = -M.Db, M.F != null && (M.J += (A - 1) * M.lb, M.lb = -M.lb);
      return 0;
    }
    function Pi(A, M, g, s) {
      if (s == null || 0 >= A || 0 >= M) return 2;
      if (g != null) {
        if (g.Da) {
          var h = g.cd, f = g.bd, m = -2 & g.v, y = -2 & g.j;
          if (0 > m || 0 > y || 0 >= h || 0 >= f || m + h > A || y + f > M) return 2;
          A = h, M = f;
        }
        if (g.da) {
          if (!pn(A, M, h = [g.ib], f = [g.hb])) return 2;
          A = h[0], M = f[0];
        }
      }
      s.width = A, s.height = M;
      e: {
        var S = s.width, C = s.height;
        if (A = s.S, 0 >= S || 0 >= C || !(A >= ql && 13 > A)) A = 2;
        else {
          if (0 >= s.Rd && s.sd == null) {
            m = f = h = M = 0;
            var B = (y = S * Nc[A]) * C;
            if (11 > A || (f = (C + 1) / 2 * (M = (S + 1) / 2), A == 12 && (m = (h = S) * C)), (C = o(B + 2 * f + m)) == null) {
              A = 1;
              break e;
            }
            s.sd = C, 11 > A ? ((S = s.f.RGBA).eb = C, S.fb = 0, S.A = y, S.size = B) : ((S = s.f.kb).y = C, S.O = 0, S.fa = y, S.Fd = B, S.f = C, S.N = 0 + B, S.Ab = M, S.Cd = f, S.ea = C, S.W = 0 + B + f, S.Db = M, S.Ed = f, A == 12 && (S.F = C, S.J = 0 + B + 2 * f), S.Tc = m, S.lb = h);
          }
          if (M = 1, h = s.S, f = s.width, m = s.height, h >= ql && 13 > h)
            if (11 > h) A = s.f.RGBA, M &= (y = Math.abs(A.A)) * (m - 1) + f <= A.size, M &= y >= f * Nc[h], M &= A.eb != null;
            else {
              A = s.f.kb, y = (f + 1) / 2, B = (m + 1) / 2, S = Math.abs(A.fa), C = Math.abs(A.Ab);
              var D = Math.abs(A.Db), z = Math.abs(A.lb), N = z * (m - 1) + f;
              M &= S * (m - 1) + f <= A.Fd, M &= C * (B - 1) + y <= A.Cd, M = (M &= D * (B - 1) + y <= A.Ed) & S >= f & C >= y & D >= y, M &= A.y != null, M &= A.f != null, M &= A.ea != null, h == 12 && (M &= z >= f, M &= N <= A.Tc, M &= A.F != null);
            }
          else M = 0;
          A = M ? 0 : 2;
        }
      }
      return A != 0 || g != null && g.fd && (A = Lo(s)), A;
    }
    var Fi = 64, Ia = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Pa = 24, Ds = 32, ea = 8, vi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    Et("Predictor0", "PredictorAdd0"), _e.Predictor0 = function() {
      return 4278190080;
    }, _e.Predictor1 = function(A) {
      return A;
    }, _e.Predictor2 = function(A, M, g) {
      return M[g + 0];
    }, _e.Predictor3 = function(A, M, g) {
      return M[g + 1];
    }, _e.Predictor4 = function(A, M, g) {
      return M[g - 1];
    }, _e.Predictor5 = function(A, M, g) {
      return Ft(Ft(A, M[g + 1]), M[g + 0]);
    }, _e.Predictor6 = function(A, M, g) {
      return Ft(A, M[g - 1]);
    }, _e.Predictor7 = function(A, M, g) {
      return Ft(A, M[g + 0]);
    }, _e.Predictor8 = function(A, M, g) {
      return Ft(M[g - 1], M[g + 0]);
    }, _e.Predictor9 = function(A, M, g) {
      return Ft(M[g + 0], M[g + 1]);
    }, _e.Predictor10 = function(A, M, g) {
      return Ft(Ft(A, M[g - 1]), Ft(M[g + 0], M[g + 1]));
    }, _e.Predictor11 = function(A, M, g) {
      var s = M[g + 0];
      return 0 >= vn(s >> 24 & 255, A >> 24 & 255, (M = M[g - 1]) >> 24 & 255) + vn(s >> 16 & 255, A >> 16 & 255, M >> 16 & 255) + vn(s >> 8 & 255, A >> 8 & 255, M >> 8 & 255) + vn(255 & s, 255 & A, 255 & M) ? s : A;
    }, _e.Predictor12 = function(A, M, g) {
      var s = M[g + 0];
      return (nn((A >> 24 & 255) + (s >> 24 & 255) - ((M = M[g - 1]) >> 24 & 255)) << 24 | nn((A >> 16 & 255) + (s >> 16 & 255) - (M >> 16 & 255)) << 16 | nn((A >> 8 & 255) + (s >> 8 & 255) - (M >> 8 & 255)) << 8 | nn((255 & A) + (255 & s) - (255 & M))) >>> 0;
    }, _e.Predictor13 = function(A, M, g) {
      var s = M[g - 1];
      return (Sn((A = Ft(A, M[g + 0])) >> 24 & 255, s >> 24 & 255) << 24 | Sn(A >> 16 & 255, s >> 16 & 255) << 16 | Sn(A >> 8 & 255, s >> 8 & 255) << 8 | Sn(A >> 0 & 255, s >> 0 & 255)) >>> 0;
    };
    var La = _e.PredictorAdd0;
    _e.PredictorAdd1 = On, Et("Predictor2", "PredictorAdd2"), Et("Predictor3", "PredictorAdd3"), Et("Predictor4", "PredictorAdd4"), Et("Predictor5", "PredictorAdd5"), Et("Predictor6", "PredictorAdd6"), Et("Predictor7", "PredictorAdd7"), Et("Predictor8", "PredictorAdd8"), Et("Predictor9", "PredictorAdd9"), Et("Predictor10", "PredictorAdd10"), Et("Predictor11", "PredictorAdd11"), Et("Predictor12", "PredictorAdd12"), Et("Predictor13", "PredictorAdd13");
    var ta = _e.PredictorAdd2;
    xn("ColorIndexInverseTransform", "MapARGB", "32b", function(A) {
      return A >> 8 & 255;
    }, function(A) {
      return A;
    }), xn("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(A) {
      return A;
    }, function(A) {
      return A >> 8 & 255;
    });
    var nl, ki = _e.ColorIndexInverseTransform, Mo = _e.MapARGB, pu = _e.VP8LColorIndexInverseTransformAlpha, Pc = _e.MapAlpha, zn = _e.VP8LPredictorsAdd = [];
    zn.length = 16, (_e.VP8LPredictors = []).length = 16, (_e.VP8LPredictorsAdd_C = []).length = 16, (_e.VP8LPredictors_C = []).length = 16;
    var Ki, go, na, Qi, Bo, ra, Fs, rl, Ma, mo, Ni, cs, ks, Ba, Ns, zs, Ra, es, _o, Cr, br, jr, ii, As, Us, si, Ro, Ku, Qu = o(511), Wr = o(2041), js = o(225), us = o(767), Vl = 0, Lc = Wr, il = js, xi = us, hi = Qu, ql = 0, sl = 1, gu = 2, ol = 3, Hl = 4, Mc = 5, Oa = 6, Wl = 7, al = 8, Xl = 9, Bc = 10, eh = [2, 3, 7], th = [3, 3, 11], Rc = [280, 256, 256, 256, 40], $l = [0, 1, 1, 1, 0], Wh = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Gs = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Oo = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], nh = 8, Ss = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ia = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], Oc = null, uf = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Xh = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], rh = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], ih = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Zl = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Vs = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], qt = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], yo = [], Es = [], Do = [], Jl = 1, ll = 2, Fo = [], Cn = [];
    lt("UpsampleRgbLinePair", Gn, 3), lt("UpsampleBgrLinePair", Or, 3), lt("UpsampleRgbaLinePair", ls, 4), lt("UpsampleBgraLinePair", fn, 4), lt("UpsampleArgbLinePair", Di, 4), lt("UpsampleRgba4444LinePair", Nn, 2), lt("UpsampleRgb565LinePair", ri, 2);
    var sh = _e.UpsampleRgbLinePair, hf = _e.UpsampleBgrLinePair, mu = _e.UpsampleRgbaLinePair, $h = _e.UpsampleBgraLinePair, cl = _e.UpsampleArgbLinePair, oh = _e.UpsampleRgba4444LinePair, ah = _e.UpsampleRgb565LinePair, Dc = 16, _u = 1 << Dc - 1, ul = -227, lh = 482, Zh = 6, Ts = (256 << Zh) - 1, vr = 0, Yl = o(256), yu = o(256), bu = o(256), Jh = o(256), Fc = o(lh - ul), kc = o(lh - ul);
    Kn("YuvToRgbRow", Gn, 3), Kn("YuvToBgrRow", Or, 3), Kn("YuvToRgbaRow", ls, 4), Kn("YuvToBgraRow", fn, 4), Kn("YuvToArgbRow", Di, 4), Kn("YuvToRgba4444Row", Nn, 2), Kn("YuvToRgb565Row", ri, 2);
    var bo = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Da = [0, 2, 8], Yt = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], gn = 1;
    this.WebPDecodeRGBA = function(A, M, g, s, h) {
      var f = sl, m = new Os(), y = new ti();
      m.ba = y, y.S = f, y.width = [y.width], y.height = [y.height];
      var S = y.width, C = y.height, B = new ni();
      if (B == null || A == null) var D = 2;
      else e(B != null), D = Ca(A, M, g, B.width, B.height, B.Pd, B.Qd, B.format, null);
      if (D != 0 ? S = 0 : (S != null && (S[0] = B.width[0]), C != null && (C[0] = B.height[0]), S = 1), S) {
        y.width = y.width[0], y.height = y.height[0], s != null && (s[0] = y.width), h != null && (h[0] = y.height);
        e: {
          if (s = new $i(), (h = new Ul()).data = A, h.w = M, h.ha = g, h.kd = 1, M = [0], e(h != null), ((A = Ca(h.data, h.w, h.ha, null, null, null, M, null, h)) == 0 || A == 7) && M[0] && (A = 4), (M = A) == 0) {
            if (e(m != null), s.data = h.data, s.w = h.w + h.offset, s.ha = h.ha - h.offset, s.put = Fe, s.ac = ye, s.bc = je, s.ma = m, h.xa) {
              if ((A = Wn()) == null) {
                m = 1;
                break e;
              }
              if (function(z, N) {
                var X = [0], Z = [0], W = [0];
                t: for (; ; ) {
                  if (z == null) return 0;
                  if (N == null) return z.a = 2, 0;
                  if (z.l = N, z.a = 0, Je(z.m, N.data, N.w, N.ha), !Oe(z.m, X, Z, W)) {
                    z.a = 3;
                    break t;
                  }
                  if (z.xb = ll, N.width = X[0], N.height = Z[0], !hn(X[0], Z[0], 1, z, null)) break t;
                  return 1;
                }
                return e(z.a != 0), 0;
              }(A, s)) {
                if (s = (M = Pi(s.width, s.height, m.Oa, m.ba)) == 0) {
                  t: {
                    s = A;
                    n: for (; ; ) {
                      if (s == null) {
                        s = 0;
                        break t;
                      }
                      if (e(s.s.yc != null), e(s.s.Ya != null), e(0 < s.s.Wb), e((g = s.l) != null), e((h = g.ma) != null), s.xb != 0) {
                        if (s.ca = h.ba, s.tb = h.tb, e(s.ca != null), !po(h.Oa, g, ol)) {
                          s.a = 2;
                          break n;
                        }
                        if (!Fn(s, g.width) || g.da) break n;
                        if ((g.da || zt(s.ca.S)) && Xe(), 11 > s.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), s.ca.f.kb.F != null && Xe()), s.Pb && 0 < s.s.ua && s.s.vb.X == null && !an(s.s.vb, s.s.Wa.Xa)) {
                          s.a = 1;
                          break n;
                        }
                        s.xb = 0;
                      }
                      if (!wn(s, s.V, s.Ba, s.c, s.i, g.o, Kt)) break n;
                      h.Dc = s.Ma, s = 1;
                      break t;
                    }
                    e(s.a != 0), s = 0;
                  }
                  s = !s;
                }
                s && (M = A.a);
              } else M = A.a;
            } else {
              if ((A = new yr()) == null) {
                m = 1;
                break e;
              }
              if (A.Fa = h.na, A.P = h.P, A.qc = h.Sa, pr(A, s)) {
                if ((M = Pi(s.width, s.height, m.Oa, m.ba)) == 0) {
                  if (A.Aa = 0, g = m.Oa, e((h = A) != null), g != null) {
                    if (0 < (S = 0 > (S = g.Md) ? 0 : 100 < S ? 255 : 255 * S / 100)) {
                      for (C = B = 0; 4 > C; ++C) 12 > (D = h.pb[C]).lc && (D.ia = S * Yt[0 > D.lc ? 0 : D.lc] >> 3), B |= D.ia;
                      B && (alert("todo:VP8InitRandom"), h.ia = 1);
                    }
                    h.Ga = g.Id, 100 < h.Ga ? h.Ga = 100 : 0 > h.Ga && (h.Ga = 0);
                  }
                  Zo(A, s) || (M = A.a);
                }
              } else M = A.a;
            }
            M == 0 && m.Oa != null && m.Oa.fd && (M = Lo(m.ba));
          }
          m = M;
        }
        f = m != 0 ? null : 11 > f ? y.f.RGBA.eb : y.f.kb.y;
      } else f = null;
      return f;
    };
    var Nc = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function b(_e, Ge) {
    for (var ke = "", oe = 0; oe < 4; oe++) ke += String.fromCharCode(_e[Ge++]);
    return ke;
  }
  function w(_e, Ge) {
    return (_e[Ge + 0] << 0 | _e[Ge + 1] << 8 | _e[Ge + 2] << 16) >>> 0;
  }
  function T(_e, Ge) {
    return (_e[Ge + 0] << 0 | _e[Ge + 1] << 8 | _e[Ge + 2] << 16 | _e[Ge + 3] << 24) >>> 0;
  }
  new _();
  var I = [0], P = [0], k = [], U = new _(), G = n, H = function(_e, Ge) {
    var ke = {}, oe = 0, pe = !1, Te = 0, xe = 0;
    if (ke.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(Ae, Ce, Ue, qe) {
      for (var He = 0; He < qe; He++) if (Ae[Ce + He] != Ue.charCodeAt(He)) return !0;
      return !1;
    }(_e, Ge, "RIFF", 4)) {
      var et, rt;
      for (T(_e, Ge += 4), Ge += 8; Ge < _e.length; ) {
        var st = b(_e, Ge), Je = T(_e, Ge += 4);
        Ge += 4;
        var ct = Je + (1 & Je);
        switch (st) {
          case "VP8 ":
          case "VP8L":
            ke.frames[oe] === void 0 && (ke.frames[oe] = {}), (re = ke.frames[oe]).src_off = pe ? xe : Ge - 8, re.src_size = Te + Je + 8, oe++, pe && (pe = !1, Te = 0, xe = 0);
            break;
          case "VP8X":
            (re = ke.header = {}).feature_flags = _e[Ge];
            var ot = Ge + 4;
            re.canvas_width = 1 + w(_e, ot), ot += 3, re.canvas_height = 1 + w(_e, ot), ot += 3;
            break;
          case "ALPH":
            pe = !0, Te = ct + 8, xe = Ge - 8;
            break;
          case "ANIM":
            (re = ke.header).bgcolor = T(_e, Ge), ot = Ge + 4, re.loop_count = (et = _e)[(rt = ot) + 0] << 0 | et[rt + 1] << 8, ot += 2;
            break;
          case "ANMF":
            var Mt, re;
            (re = ke.frames[oe] = {}).offset_x = 2 * w(_e, Ge), Ge += 3, re.offset_y = 2 * w(_e, Ge), Ge += 3, re.width = 1 + w(_e, Ge), Ge += 3, re.height = 1 + w(_e, Ge), Ge += 3, re.duration = w(_e, Ge), Ge += 3, Mt = _e[Ge++], re.dispose = 1 & Mt, re.blend = Mt >> 1 & 1;
        }
        st != "ANMF" && (Ge += ct);
      }
      return ke;
    }
  }(G, 0);
  H.response = G, H.rgbaoutput = !0, H.dataurl = !1;
  var $ = H.header ? H.header : null, ie = H.frames ? H.frames : null;
  if ($) {
    $.loop_counter = $.loop_count, I = [$.canvas_height], P = [$.canvas_width];
    for (var ge = 0; ge < ie.length && ie[ge].blend != 0; ge++) ;
  }
  var Se = ie[0], Re = U.WebPDecodeRGBA(G, Se.src_off, Se.src_size, P, I);
  Se.rgba = Re, Se.imgwidth = P[0], Se.imgheight = I[0];
  for (var Le = 0; Le < P[0] * I[0] * 4; Le++) k[Le] = Re[Le];
  return this.width = P, this.height = I, this.data = k, this;
}
(function(n) {
  var e = function() {
    return typeof e1 == "function";
  }, t = function(I, P, k, U) {
    var G = 4, H = c;
    switch (U) {
      case n.image_compression.FAST:
        G = 1, H = o;
        break;
      case n.image_compression.MEDIUM:
        G = 6, H = l;
        break;
      case n.image_compression.SLOW:
        G = 9, H = _;
    }
    I = r(I, P, k, H);
    var $ = e1(I, { level: G });
    return n.__addimage__.arrayBufferToBinaryString($);
  }, r = function(I, P, k, U) {
    for (var G, H, $, ie = I.length / P, ge = new Uint8Array(I.length + ie), Se = w(), Re = 0; Re < ie; Re += 1) {
      if ($ = Re * P, G = I.subarray($, $ + P), U) ge.set(U(G, k, H), $ + Re);
      else {
        for (var Le, _e = Se.length, Ge = []; Le < _e; Le += 1) Ge[Le] = Se[Le](G, k, H);
        var ke = T(Ge.concat());
        ge.set(Ge[ke], $ + Re);
      }
      H = G;
    }
    return ge;
  }, i = function(I) {
    var P = Array.apply([], I);
    return P.unshift(0), P;
  }, o = function(I, P) {
    var k, U = [], G = I.length;
    U[0] = 1;
    for (var H = 0; H < G; H += 1) k = I[H - P] || 0, U[H + 1] = I[H] - k + 256 & 255;
    return U;
  }, c = function(I, P, k) {
    var U, G = [], H = I.length;
    G[0] = 2;
    for (var $ = 0; $ < H; $ += 1) U = k && k[$] || 0, G[$ + 1] = I[$] - U + 256 & 255;
    return G;
  }, l = function(I, P, k) {
    var U, G, H = [], $ = I.length;
    H[0] = 3;
    for (var ie = 0; ie < $; ie += 1) U = I[ie - P] || 0, G = k && k[ie] || 0, H[ie + 1] = I[ie] + 256 - (U + G >>> 1) & 255;
    return H;
  }, _ = function(I, P, k) {
    var U, G, H, $, ie = [], ge = I.length;
    ie[0] = 4;
    for (var Se = 0; Se < ge; Se += 1) U = I[Se - P] || 0, G = k && k[Se] || 0, H = k && k[Se - P] || 0, $ = b(U, G, H), ie[Se + 1] = I[Se] - $ + 256 & 255;
    return ie;
  }, b = function(I, P, k) {
    if (I === P && P === k) return I;
    var U = Math.abs(P - k), G = Math.abs(I - k), H = Math.abs(I + P - k - k);
    return U <= G && U <= H ? I : G <= H ? P : k;
  }, w = function() {
    return [i, o, c, l, _];
  }, T = function(I) {
    var P = I.map(function(k) {
      return k.reduce(function(U, G) {
        return U + Math.abs(G);
      }, 0);
    });
    return P.indexOf(Math.min.apply(null, P));
  };
  n.processPNG = function(I, P, k, U) {
    var G, H, $, ie, ge, Se, Re, Le, _e, Ge, ke, oe, pe, Te, xe, et = this.decode.FLATE_DECODE, rt = "";
    if (this.__addimage__.isArrayBuffer(I) && (I = new Uint8Array(I)), this.__addimage__.isArrayBufferView(I)) {
      if (I = ($ = new EV(I)).imgData, H = $.bits, G = $.colorSpace, ge = $.colors, [4, 6].indexOf($.colorType) !== -1) {
        if ($.bits === 8) {
          _e = (Le = $.pixelBitlength == 32 ? new Uint32Array($.decodePixels().buffer) : $.pixelBitlength == 16 ? new Uint16Array($.decodePixels().buffer) : new Uint8Array($.decodePixels().buffer)).length, ke = new Uint8Array(_e * $.colors), Ge = new Uint8Array(_e);
          var st, Je = $.pixelBitlength - $.bits;
          for (Te = 0, xe = 0; Te < _e; Te++) {
            for (pe = Le[Te], st = 0; st < Je; ) ke[xe++] = pe >>> st & 255, st += $.bits;
            Ge[Te] = pe >>> st & 255;
          }
        }
        if ($.bits === 16) {
          _e = (Le = new Uint32Array($.decodePixels().buffer)).length, ke = new Uint8Array(_e * (32 / $.pixelBitlength) * $.colors), Ge = new Uint8Array(_e * (32 / $.pixelBitlength)), oe = $.colors > 1, Te = 0, xe = 0;
          for (var ct = 0; Te < _e; ) pe = Le[Te++], ke[xe++] = pe >>> 0 & 255, oe && (ke[xe++] = pe >>> 16 & 255, pe = Le[Te++], ke[xe++] = pe >>> 0 & 255), Ge[ct++] = pe >>> 16 & 255;
          H = 8;
        }
        U !== n.image_compression.NONE && e() ? (I = t(ke, $.width * $.colors, $.colors, U), Re = t(Ge, $.width, 1, U)) : (I = ke, Re = Ge, et = void 0);
      }
      if ($.colorType === 3 && (G = this.color_spaces.INDEXED, Se = $.palette, $.transparency.indexed)) {
        var ot = $.transparency.indexed, Mt = 0;
        for (Te = 0, _e = ot.length; Te < _e; ++Te) Mt += ot[Te];
        if ((Mt /= 255) === _e - 1 && ot.indexOf(0) !== -1) ie = [ot.indexOf(0)];
        else if (Mt !== _e) {
          for (Le = $.decodePixels(), Ge = new Uint8Array(Le.length), Te = 0, _e = Le.length; Te < _e; Te++) Ge[Te] = ot[Le[Te]];
          Re = t(Ge, $.width, 1);
        }
      }
      var re = function(Ae) {
        var Ce;
        switch (Ae) {
          case n.image_compression.FAST:
            Ce = 11;
            break;
          case n.image_compression.MEDIUM:
            Ce = 13;
            break;
          case n.image_compression.SLOW:
            Ce = 14;
            break;
          default:
            Ce = 12;
        }
        return Ce;
      }(U);
      return et === this.decode.FLATE_DECODE && (rt = "/Predictor " + re + " "), rt += "/Colors " + ge + " /BitsPerComponent " + H + " /Columns " + $.width, (this.__addimage__.isArrayBuffer(I) || this.__addimage__.isArrayBufferView(I)) && (I = this.__addimage__.arrayBufferToBinaryString(I)), (Re && this.__addimage__.isArrayBuffer(Re) || this.__addimage__.isArrayBufferView(Re)) && (Re = this.__addimage__.arrayBufferToBinaryString(Re)), { alias: k, data: I, index: P, filter: et, decodeParameters: rt, transparency: ie, palette: Se, sMask: Re, predictor: re, width: $.width, height: $.height, bitsPerComponent: H, colorSpace: G };
    }
  };
})(Bn.API), function(n) {
  n.processGIF89A = function(e, t, r, i) {
    var o = new TV(e), c = o.width, l = o.height, _ = [];
    o.decodeAndBlitFrameRGBA(0, _);
    var b = { data: _, width: c, height: l }, w = new J_(100).encode(b, 100);
    return n.processJPEG.call(this, w, t, r, i);
  }, n.processGIF87A = n.processGIF89A;
}(Bn.API), ml.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var n = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(n);
    for (var e = 0; e < n; e++) {
      var t = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: i, green: r, blue: t, quad: o };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, ml.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var n = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[n]();
  } catch (t) {
    $r.log("bit decode error:" + t);
  }
}, ml.prototype.bit1 = function() {
  var n, e = Math.ceil(this.width / 8), t = e % 4;
  for (n = this.height - 1; n >= 0; n--) {
    for (var r = this.bottom_up ? n : this.height - 1 - n, i = 0; i < e; i++) for (var o = this.datav.getUint8(this.pos++, !0), c = r * this.width * 4 + 8 * i * 4, l = 0; l < 8 && 8 * i + l < this.width; l++) {
      var _ = this.palette[o >> 7 - l & 1];
      this.data[c + 4 * l] = _.blue, this.data[c + 4 * l + 1] = _.green, this.data[c + 4 * l + 2] = _.red, this.data[c + 4 * l + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, ml.prototype.bit4 = function() {
  for (var n = Math.ceil(this.width / 2), e = n % 4, t = this.height - 1; t >= 0; t--) {
    for (var r = this.bottom_up ? t : this.height - 1 - t, i = 0; i < n; i++) {
      var o = this.datav.getUint8(this.pos++, !0), c = r * this.width * 4 + 2 * i * 4, l = o >> 4, _ = 15 & o, b = this.palette[l];
      if (this.data[c] = b.blue, this.data[c + 1] = b.green, this.data[c + 2] = b.red, this.data[c + 3] = 255, 2 * i + 1 >= this.width) break;
      b = this.palette[_], this.data[c + 4] = b.blue, this.data[c + 4 + 1] = b.green, this.data[c + 4 + 2] = b.red, this.data[c + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, ml.prototype.bit8 = function() {
  for (var n = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
      var i = this.datav.getUint8(this.pos++, !0), o = t * this.width * 4 + 4 * r;
      if (i < this.palette.length) {
        var c = this.palette[i];
        this.data[o] = c.red, this.data[o + 1] = c.green, this.data[o + 2] = c.blue, this.data[o + 3] = 255;
      } else this.data[o] = 255, this.data[o + 1] = 255, this.data[o + 2] = 255, this.data[o + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, ml.prototype.bit15 = function() {
  for (var n = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var r = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var o = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var c = (o & e) / e * 255 | 0, l = (o >> 5 & e) / e * 255 | 0, _ = (o >> 10 & e) / e * 255 | 0, b = o >> 15 ? 255 : 0, w = r * this.width * 4 + 4 * i;
      this.data[w] = _, this.data[w + 1] = l, this.data[w + 2] = c, this.data[w + 3] = b;
    }
    this.pos += n;
  }
}, ml.prototype.bit16 = function() {
  for (var n = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), r = this.height - 1; r >= 0; r--) {
    for (var i = this.bottom_up ? r : this.height - 1 - r, o = 0; o < this.width; o++) {
      var c = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var l = (c & e) / e * 255 | 0, _ = (c >> 5 & t) / t * 255 | 0, b = (c >> 11) / e * 255 | 0, w = i * this.width * 4 + 4 * o;
      this.data[w] = b, this.data[w + 1] = _, this.data[w + 2] = l, this.data[w + 3] = 255;
    }
    this.pos += n;
  }
}, ml.prototype.bit24 = function() {
  for (var n = this.height - 1; n >= 0; n--) {
    for (var e = this.bottom_up ? n : this.height - 1 - n, t = 0; t < this.width; t++) {
      var r = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0), c = e * this.width * 4 + 4 * t;
      this.data[c] = o, this.data[c + 1] = i, this.data[c + 2] = r, this.data[c + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, ml.prototype.bit32 = function() {
  for (var n = this.height - 1; n >= 0; n--) for (var e = this.bottom_up ? n : this.height - 1 - n, t = 0; t < this.width; t++) {
    var r = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0), c = this.datav.getUint8(this.pos++, !0), l = e * this.width * 4 + 4 * t;
    this.data[l] = o, this.data[l + 1] = i, this.data[l + 2] = r, this.data[l + 3] = c;
  }
}, ml.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.processBMP = function(e, t, r, i) {
    var o = new ml(e, !1), c = o.width, l = o.height, _ = { data: o.getData(), width: c, height: l }, b = new J_(100).encode(_, 100);
    return n.processJPEG.call(this, b, t, r, i);
  };
}(Bn.API), e5.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.processWEBP = function(e, t, r, i) {
    var o = new e5(e), c = o.width, l = o.height, _ = { data: o.getData(), width: c, height: l }, b = new J_(100).encode(_, 100);
    return n.processJPEG.call(this, b, t, r, i);
  };
}(Bn.API), Bn.API.processRGBA = function(n, e, t) {
  for (var r = n.data, i = r.length, o = new Uint8Array(i / 4 * 3), c = new Uint8Array(i / 4), l = 0, _ = 0, b = 0; b < i; b += 4) {
    var w = r[b], T = r[b + 1], I = r[b + 2], P = r[b + 3];
    o[l++] = w, o[l++] = T, o[l++] = I, c[_++] = P;
  }
  var k = this.__addimage__.arrayBufferToBinaryString(o);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(c), data: k, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: n.width, height: n.height };
}, Bn.API.setLanguage = function(n) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[n] !== void 0 && (this.internal.languageSettings.languageCode = n, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Sd = Bn.API, Gg = Sd.getCharWidthsArray = function(n, e) {
  var t, r, i = (e = e || {}).font || this.internal.getFont(), o = e.fontSize || this.internal.getFontSize(), c = e.charSpace || this.internal.getCharSpace(), l = e.widths ? e.widths : i.metadata.Unicode.widths, _ = l.fof ? l.fof : 1, b = e.kerning ? e.kerning : i.metadata.Unicode.kerning, w = b.fof ? b.fof : 1, T = e.doKerning !== !1, I = 0, P = n.length, k = 0, U = l[0] || _, G = [];
  for (t = 0; t < P; t++) r = n.charCodeAt(t), typeof i.metadata.widthOfString == "function" ? G.push((i.metadata.widthOfGlyph(i.metadata.characterToGlyph(r)) + c * (1e3 / o) || 0) / 1e3) : (I = T && zr(b[r]) === "object" && !isNaN(parseInt(b[r][k], 10)) ? b[r][k] / w : 0, G.push((l[r] || U) / _ + I)), k = r;
  return G;
}, JA = Sd.getStringUnitWidth = function(n, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), r = e.font || this.internal.getFont(), i = e.charSpace || this.internal.getCharSpace();
  return Sd.processArabic && (n = Sd.processArabic(n)), typeof r.metadata.widthOfString == "function" ? r.metadata.widthOfString(n, t, i) / t : Gg.apply(this, arguments).reduce(function(o, c) {
    return o + c;
  }, 0);
}, YA = function(n, e, t, r) {
  for (var i = [], o = 0, c = n.length, l = 0; o !== c && l + e[o] < t; ) l += e[o], o++;
  i.push(n.slice(0, o));
  var _ = o;
  for (l = 0; o !== c; ) l + e[o] > r && (i.push(n.slice(_, o)), l = 0, _ = o), l += e[o], o++;
  return _ !== o && i.push(n.slice(_, o)), i;
}, KA = function(n, e, t) {
  t || (t = {});
  var r, i, o, c, l, _, b, w = [], T = [w], I = t.textIndent || 0, P = 0, k = 0, U = n.split(" "), G = Gg.apply(this, [" ", t])[0];
  if (_ = t.lineIndent === -1 ? U[0].length + 2 : t.lineIndent || 0) {
    var H = Array(_).join(" "), $ = [];
    U.map(function(ge) {
      (ge = ge.split(/\s*\n/)).length > 1 ? $ = $.concat(ge.map(function(Se, Re) {
        return (Re && Se.length ? `
` : "") + Se;
      })) : $.push(ge[0]);
    }), U = $, _ = JA.apply(this, [H, t]);
  }
  for (o = 0, c = U.length; o < c; o++) {
    var ie = 0;
    if (r = U[o], _ && r[0] == `
` && (r = r.substr(1), ie = 1), I + P + (k = (i = Gg.apply(this, [r, t])).reduce(function(ge, Se) {
      return ge + Se;
    }, 0)) > e || ie) {
      if (k > e) {
        for (l = YA.apply(this, [r, i, e - (I + P), e]), w.push(l.shift()), w = [l.pop()]; l.length; ) T.push([l.shift()]);
        k = i.slice(r.length - (w[0] ? w[0].length : 0)).reduce(function(ge, Se) {
          return ge + Se;
        }, 0);
      } else w = [r];
      T.push(w), I = k + _, P = G;
    } else w.push(r), I += P + k, P = G;
  }
  return b = _ ? function(ge, Se) {
    return (Se ? H : "") + ge.join(" ");
  } : function(ge) {
    return ge.join(" ");
  }, T.map(b);
}, Sd.splitTextToSize = function(n, e, t) {
  var r, i = (t = t || {}).fontSize || this.internal.getFontSize(), o = (function(w) {
    if (w.widths && w.kerning) return { widths: w.widths, kerning: w.kerning };
    var T = this.internal.getFont(w.fontName, w.fontStyle);
    return T.metadata.Unicode ? { widths: T.metadata.Unicode.widths || { 0: 1 }, kerning: T.metadata.Unicode.kerning || {} } : { font: T.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, t);
  r = Array.isArray(n) ? n : String(n).split(/\r?\n/);
  var c = 1 * this.internal.scaleFactor * e / i;
  o.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / i : 0, o.lineIndent = t.lineIndent;
  var l, _, b = [];
  for (l = 0, _ = r.length; l < _; l++) b = b.concat(KA.apply(this, [r[l], c, o]));
  return b;
}, function(n) {
  n.__fontmetrics__ = n.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, r = {}, i = 0; i < e.length; i++) t[e[i]] = "0123456789abcdef"[i], r["0123456789abcdef"[i]] = e[i];
  var o = function(T) {
    return "0x" + parseInt(T, 10).toString(16);
  }, c = n.__fontmetrics__.compress = function(T) {
    var I, P, k, U, G = ["{"];
    for (var H in T) {
      if (I = T[H], isNaN(parseInt(H, 10)) ? P = "'" + H + "'" : (H = parseInt(H, 10), P = (P = o(H).slice(2)).slice(0, -1) + r[P.slice(-1)]), typeof I == "number") I < 0 ? (k = o(I).slice(3), U = "-") : (k = o(I).slice(2), U = ""), k = U + k.slice(0, -1) + r[k.slice(-1)];
      else {
        if (zr(I) !== "object") throw new Error("Don't know what to do with value type " + zr(I) + ".");
        k = c(I);
      }
      G.push(P + k);
    }
    return G.push("}"), G.join("");
  }, l = n.__fontmetrics__.uncompress = function(T) {
    if (typeof T != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var I, P, k, U, G = {}, H = 1, $ = G, ie = [], ge = "", Se = "", Re = T.length - 1, Le = 1; Le < Re; Le += 1) (U = T[Le]) == "'" ? I ? (k = I.join(""), I = void 0) : I = [] : I ? I.push(U) : U == "{" ? (ie.push([$, k]), $ = {}, k = void 0) : U == "}" ? ((P = ie.pop())[0][P[1]] = $, k = void 0, $ = P[0]) : U == "-" ? H = -1 : k === void 0 ? t.hasOwnProperty(U) ? (ge += t[U], k = parseInt(ge, 16) * H, H = 1, ge = "") : ge += U : t.hasOwnProperty(U) ? (Se += t[U], $[k] = parseInt(Se, 16) * H, H = 1, k = void 0, Se = "") : Se += U;
    return G;
  }, _ = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: l("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, b = { Unicode: { Courier: _, "Courier-Bold": _, "Courier-BoldOblique": _, "Courier-Oblique": _, Helvetica: _, "Helvetica-Bold": _, "Helvetica-BoldOblique": _, "Helvetica-Oblique": _, "Times-Roman": _, "Times-Bold": _, "Times-BoldItalic": _, "Times-Italic": _ } }, w = { Unicode: { "Courier-Oblique": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": l("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": l("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": l("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: l("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: l("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": l("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: l("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": l("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": l("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": l("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  n.events.push(["addFont", function(T) {
    var I = T.font, P = w.Unicode[I.postScriptName];
    P && (I.metadata.Unicode = {}, I.metadata.Unicode.widths = P.widths, I.metadata.Unicode.kerning = P.kerning);
    var k = b.Unicode[I.postScriptName];
    k && (I.metadata.Unicode.encoding = k, I.encoding = k.codePages[0]);
  }]);
}(Bn.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(t) {
    for (var r = t.length, i = new Uint8Array(r), o = 0; o < r; o++) i[o] = t.charCodeAt(o);
    return i;
  };
  n.API.events.push(["addFont", function(t) {
    var r = void 0, i = t.font, o = t.instance;
    if (!i.isStandardFont) {
      if (o === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      if (typeof (r = o.existsFileInVFS(i.postScriptName) === !1 ? o.loadFile(i.postScriptName) : o.getFileFromVFS(i.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      (function(c, l) {
        l = /^\x00\x01\x00\x00/.test(l) ? e(l) : e(fp(l)), c.metadata = n.API.TTFFont.open(l), c.metadata.Unicode = c.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, c.metadata.glyIdsUsed = [0];
      })(i, r);
    }
  }]);
}(Bn), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(n) {
  function e() {
    return (Rn.canvg ? Promise.resolve(Rn.canvg) : import("./index.es-BWyxJuJN-HCk0JDTR.mjs")).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  Bn.API.addSvgAsImage = function(t, r, i, o, c, l, _, b) {
    if (isNaN(r) || isNaN(i)) throw $r.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(o) || isNaN(c)) throw $r.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var w = document.createElement("canvas");
    w.width = o, w.height = c;
    var T = w.getContext("2d");
    T.fillStyle = "#fff", T.fillRect(0, 0, w.width, w.height);
    var I = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, P = this;
    return e().then(function(k) {
      return k.fromString(T, t, I);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(k) {
      return k.render(I);
    }).then(function() {
      P.addImage(w.toDataURL("image/jpeg", 1), r, i, o, c, _, b);
    });
  };
}(), Bn.API.putTotalPages = function(n) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(n, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(n, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var r = 1; r <= this.internal.getNumberOfPages(); r++) for (var i = 0; i < this.internal.pages[r].length; i++) this.internal.pages[r][i] = this.internal.pages[r][i].replace(e, t);
  return this;
}, Bn.API.viewerPreferences = function(n, e) {
  var t;
  n = n || {}, e = e || !1;
  var r, i, o, c = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, l = Object.keys(c), _ = [], b = 0, w = 0, T = 0;
  function I(k, U) {
    var G, H = !1;
    for (G = 0; G < k.length; G += 1) k[G] === U && (H = !0);
    return H;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(c)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, n === "reset" || e === !0) {
    var P = l.length;
    for (T = 0; T < P; T += 1) t[l[T]].value = t[l[T]].defaultValue, t[l[T]].explicitSet = !1;
  }
  if (zr(n) === "object") {
    for (i in n) if (o = n[i], I(l, i) && o !== void 0) {
      if (t[i].type === "boolean" && typeof o == "boolean") t[i].value = o;
      else if (t[i].type === "name" && I(t[i].valueSet, o)) t[i].value = o;
      else if (t[i].type === "integer" && Number.isInteger(o)) t[i].value = o;
      else if (t[i].type === "array") {
        for (b = 0; b < o.length; b += 1) if (r = !0, o[b].length === 1 && typeof o[b][0] == "number") _.push(String(o[b] - 1));
        else if (o[b].length > 1) {
          for (w = 0; w < o[b].length; w += 1) typeof o[b][w] != "number" && (r = !1);
          r === !0 && _.push([o[b][0] - 1, o[b][1] - 1].join(" "));
        }
        t[i].value = "[" + _.join(" ") + "]";
      } else t[i].value = t[i].defaultValue;
      t[i].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var k, U = [];
    for (k in t) t[k].explicitSet === !0 && (t[k].type === "name" ? U.push("/" + k + " /" + t[k].value) : U.push("/" + k + " " + t[k].value));
    U.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + U.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(n) {
  var e = function() {
    var r = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', i = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), o = unescape(encodeURIComponent(r)), c = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), l = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), _ = unescape(encodeURIComponent("</x:xmpmeta>")), b = o.length + c.length + l.length + i.length + _.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + b + " >>"), this.internal.write("stream"), this.internal.write(i + o + c + l + _), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  n.addMetadata = function(r, i) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: r, namespaceuri: i || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(Bn.API), function(n) {
  var e = n.API, t = e.pdfEscape16 = function(o, c) {
    for (var l, _ = c.metadata.Unicode.widths, b = ["", "0", "00", "000", "0000"], w = [""], T = 0, I = o.length; T < I; ++T) {
      if (l = c.metadata.characterToGlyph(o.charCodeAt(T)), c.metadata.glyIdsUsed.push(l), c.metadata.toUnicode[l] = o.charCodeAt(T), _.indexOf(l) == -1 && (_.push(l), _.push([parseInt(c.metadata.widthOfGlyph(l), 10)])), l == "0") return w.join("");
      l = l.toString(16), w.push(b[4 - l.length], l);
    }
    return w.join("");
  }, r = function(o) {
    var c, l, _, b, w, T, I;
    for (w = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, _ = [], T = 0, I = (l = Object.keys(o).sort(function(P, k) {
      return P - k;
    })).length; T < I; T++) c = l[T], _.length >= 100 && (w += `
` + _.length + ` beginbfchar
` + _.join(`
`) + `
endbfchar`, _ = []), o[c] !== void 0 && o[c] !== null && typeof o[c].toString == "function" && (b = ("0000" + o[c].toString(16)).slice(-4), c = ("0000" + (+c).toString(16)).slice(-4), _.push("<" + c + "><" + b + ">"));
    return _.length && (w += `
` + _.length + ` beginbfchar
` + _.join(`
`) + `
endbfchar
`), w += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(o) {
    (function(c) {
      var l = c.font, _ = c.out, b = c.newObject, w = c.putStream;
      if (l.metadata instanceof n.API.TTFFont && l.encoding === "Identity-H") {
        for (var T = l.metadata.Unicode.widths, I = l.metadata.subset.encode(l.metadata.glyIdsUsed, 1), P = "", k = 0; k < I.length; k++) P += String.fromCharCode(I[k]);
        var U = b();
        w({ data: P, addLength1: !0, objectId: U }), _("endobj");
        var G = b();
        w({ data: r(l.metadata.toUnicode), addLength1: !0, objectId: G }), _("endobj");
        var H = b();
        _("<<"), _("/Type /FontDescriptor"), _("/FontName /" + Id(l.fontName)), _("/FontFile2 " + U + " 0 R"), _("/FontBBox " + n.API.PDFObject.convert(l.metadata.bbox)), _("/Flags " + l.metadata.flags), _("/StemV " + l.metadata.stemV), _("/ItalicAngle " + l.metadata.italicAngle), _("/Ascent " + l.metadata.ascender), _("/Descent " + l.metadata.decender), _("/CapHeight " + l.metadata.capHeight), _(">>"), _("endobj");
        var $ = b();
        _("<<"), _("/Type /Font"), _("/BaseFont /" + Id(l.fontName)), _("/FontDescriptor " + H + " 0 R"), _("/W " + n.API.PDFObject.convert(T)), _("/CIDToGIDMap /Identity"), _("/DW 1000"), _("/Subtype /CIDFontType2"), _("/CIDSystemInfo"), _("<<"), _("/Supplement 0"), _("/Registry (Adobe)"), _("/Ordering (" + l.encoding + ")"), _(">>"), _(">>"), _("endobj"), l.objectNumber = b(), _("<<"), _("/Type /Font"), _("/Subtype /Type0"), _("/ToUnicode " + G + " 0 R"), _("/BaseFont /" + Id(l.fontName)), _("/Encoding /" + l.encoding), _("/DescendantFonts [" + $ + " 0 R]"), _(">>"), _("endobj"), l.isAlreadyPutted = !0;
      }
    })(o);
  }]), e.events.push(["putFont", function(o) {
    (function(c) {
      var l = c.font, _ = c.out, b = c.newObject, w = c.putStream;
      if (l.metadata instanceof n.API.TTFFont && l.encoding === "WinAnsiEncoding") {
        for (var T = l.metadata.rawData, I = "", P = 0; P < T.length; P++) I += String.fromCharCode(T[P]);
        var k = b();
        w({ data: I, addLength1: !0, objectId: k }), _("endobj");
        var U = b();
        w({ data: r(l.metadata.toUnicode), addLength1: !0, objectId: U }), _("endobj");
        var G = b();
        _("<<"), _("/Descent " + l.metadata.decender), _("/CapHeight " + l.metadata.capHeight), _("/StemV " + l.metadata.stemV), _("/Type /FontDescriptor"), _("/FontFile2 " + k + " 0 R"), _("/Flags 96"), _("/FontBBox " + n.API.PDFObject.convert(l.metadata.bbox)), _("/FontName /" + Id(l.fontName)), _("/ItalicAngle " + l.metadata.italicAngle), _("/Ascent " + l.metadata.ascender), _(">>"), _("endobj"), l.objectNumber = b();
        for (var H = 0; H < l.metadata.hmtx.widths.length; H++) l.metadata.hmtx.widths[H] = parseInt(l.metadata.hmtx.widths[H] * (1e3 / l.metadata.head.unitsPerEm));
        _("<</Subtype/TrueType/Type/Font/ToUnicode " + U + " 0 R/BaseFont/" + Id(l.fontName) + "/FontDescriptor " + G + " 0 R/Encoding/" + l.encoding + " /FirstChar 29 /LastChar 255 /Widths " + n.API.PDFObject.convert(l.metadata.hmtx.widths) + ">>"), _("endobj"), l.isAlreadyPutted = !0;
      }
    })(o);
  }]);
  var i = function(o) {
    var c, l = o.text || "", _ = o.x, b = o.y, w = o.options || {}, T = o.mutex || {}, I = T.pdfEscape, P = T.activeFontKey, k = T.fonts, U = P, G = "", H = 0, $ = "", ie = k[U].encoding;
    if (k[U].encoding !== "Identity-H") return { text: l, x: _, y: b, options: w, mutex: T };
    for ($ = l, U = P, Array.isArray(l) && ($ = l[0]), H = 0; H < $.length; H += 1) k[U].metadata.hasOwnProperty("cmap") && (c = k[U].metadata.cmap.unicode.codeMap[$[H].charCodeAt(0)]), c || $[H].charCodeAt(0) < 256 && k[U].metadata.hasOwnProperty("Unicode") ? G += $[H] : G += "";
    var ge = "";
    return parseInt(U.slice(1)) < 14 || ie === "WinAnsiEncoding" ? ge = I(G, U).split("").map(function(Se) {
      return Se.charCodeAt(0).toString(16);
    }).join("") : ie === "Identity-H" && (ge = t(G, k[U])), T.isHex = !0, { text: ge, x: _, y: b, options: w, mutex: T };
  };
  e.events.push(["postProcessText", function(o) {
    var c = o.text || "", l = [], _ = { text: c, x: o.x, y: o.y, options: o.options, mutex: o.mutex };
    if (Array.isArray(c)) {
      var b = 0;
      for (b = 0; b < c.length; b += 1) Array.isArray(c[b]) && c[b].length === 3 ? l.push([i(Object.assign({}, _, { text: c[b][0] })).text, c[b][1], c[b][2]]) : l.push(i(Object.assign({}, _, { text: c[b] })).text);
      o.text = l;
    } else o.text = i(Object.assign({}, _, { text: c })).text;
  }]);
}(Bn), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  n.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, n.addFileToVFS = function(t, r) {
    return e.call(this), this.internal.vFS[t] = r, this;
  }, n.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(Bn.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(n) {
  n.__bidiEngine__ = n.prototype.__bidiEngine__ = function(r) {
    var i, o, c, l, _, b, w, T = e, I = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], P = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], k = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, U = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, G = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], H = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), $ = !1, ie = 0;
    this.__bidiEngine__ = {};
    var ge = function(oe) {
      var pe = oe.charCodeAt(), Te = pe >> 8, xe = U[Te];
      return xe !== void 0 ? T[256 * xe + (255 & pe)] : Te === 252 || Te === 253 ? "AL" : H.test(Te) ? "L" : Te === 8 ? "R" : "N";
    }, Se = function(oe) {
      for (var pe, Te = 0; Te < oe.length; Te++) {
        if ((pe = ge(oe.charAt(Te))) === "L") return !1;
        if (pe === "R") return !0;
      }
      return !1;
    }, Re = function(oe, pe, Te, xe) {
      var et, rt, st, Je, ct = pe[xe];
      switch (ct) {
        case "L":
        case "R":
          $ = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          $ && (ct = "AN");
          break;
        case "AL":
          $ = !0, ct = "R";
          break;
        case "WS":
          ct = "N";
          break;
        case "CS":
          xe < 1 || xe + 1 >= pe.length || (et = Te[xe - 1]) !== "EN" && et !== "AN" || (rt = pe[xe + 1]) !== "EN" && rt !== "AN" ? ct = "N" : $ && (rt = "AN"), ct = rt === et ? rt : "N";
          break;
        case "ES":
          ct = (et = xe > 0 ? Te[xe - 1] : "B") === "EN" && xe + 1 < pe.length && pe[xe + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (xe > 0 && Te[xe - 1] === "EN") {
            ct = "EN";
            break;
          }
          if ($) {
            ct = "N";
            break;
          }
          for (st = xe + 1, Je = pe.length; st < Je && pe[st] === "ET"; ) st++;
          ct = st < Je && pe[st] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (c && !l) {
            for (Je = pe.length, st = xe + 1; st < Je && pe[st] === "NSM"; ) st++;
            if (st < Je) {
              var ot = oe[xe], Mt = ot >= 1425 && ot <= 2303 || ot === 64286;
              if (et = pe[st], Mt && (et === "R" || et === "AL")) {
                ct = "R";
                break;
              }
            }
          }
          ct = xe < 1 || (et = pe[xe - 1]) === "B" ? "N" : Te[xe - 1];
          break;
        case "B":
          $ = !1, i = !0, ct = ie;
          break;
        case "S":
          o = !0, ct = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          $ = !1;
          break;
        case "BN":
          ct = "N";
      }
      return ct;
    }, Le = function(oe, pe, Te) {
      var xe = oe.split("");
      return Te && _e(xe, Te, { hiLevel: ie }), xe.reverse(), pe && pe.reverse(), xe.join("");
    }, _e = function(oe, pe, Te) {
      var xe, et, rt, st, Je, ct = -1, ot = oe.length, Mt = 0, re = [], Ae = ie ? P : I, Ce = [];
      for ($ = !1, i = !1, o = !1, et = 0; et < ot; et++) Ce[et] = ge(oe[et]);
      for (rt = 0; rt < ot; rt++) {
        if (Je = Mt, re[rt] = Re(oe, Ce, re, rt), xe = 240 & (Mt = Ae[Je][k[re[rt]]]), Mt &= 15, pe[rt] = st = Ae[Mt][5], xe > 0) if (xe === 16) {
          for (et = ct; et < rt; et++) pe[et] = 1;
          ct = -1;
        } else ct = -1;
        if (Ae[Mt][6]) ct === -1 && (ct = rt);
        else if (ct > -1) {
          for (et = ct; et < rt; et++) pe[et] = st;
          ct = -1;
        }
        Ce[rt] === "B" && (pe[rt] = 0), Te.hiLevel |= st;
      }
      o && function(Ue, qe, He) {
        for (var Ye = 0; Ye < He; Ye++) if (Ue[Ye] === "S") {
          qe[Ye] = ie;
          for (var Ze = Ye - 1; Ze >= 0 && Ue[Ze] === "WS"; Ze--) qe[Ze] = ie;
        }
      }(Ce, pe, ot);
    }, Ge = function(oe, pe, Te, xe, et) {
      if (!(et.hiLevel < oe)) {
        if (oe === 1 && ie === 1 && !i) return pe.reverse(), void (Te && Te.reverse());
        for (var rt, st, Je, ct, ot = pe.length, Mt = 0; Mt < ot; ) {
          if (xe[Mt] >= oe) {
            for (Je = Mt + 1; Je < ot && xe[Je] >= oe; ) Je++;
            for (ct = Mt, st = Je - 1; ct < st; ct++, st--) rt = pe[ct], pe[ct] = pe[st], pe[st] = rt, Te && (rt = Te[ct], Te[ct] = Te[st], Te[st] = rt);
            Mt = Je;
          }
          Mt++;
        }
      }
    }, ke = function(oe, pe, Te) {
      var xe = oe.split(""), et = { hiLevel: ie };
      return Te || (Te = []), _e(xe, Te, et), function(rt, st, Je) {
        if (Je.hiLevel !== 0 && w) for (var ct, ot = 0; ot < rt.length; ot++) st[ot] === 1 && (ct = G.indexOf(rt[ot])) >= 0 && (rt[ot] = G[ct + 1]);
      }(xe, Te, et), Ge(2, xe, pe, Te, et), Ge(1, xe, pe, Te, et), xe.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(oe, pe, Te) {
      if (function(et, rt) {
        if (rt) for (var st = 0; st < et.length; st++) rt[st] = st;
        l === void 0 && (l = Se(et)), b === void 0 && (b = Se(et));
      }(oe, pe), c || !_ || b)
        if (c && _ && l ^ b) ie = l ? 1 : 0, oe = Le(oe, pe, Te);
        else if (!c && _ && b) ie = l ? 1 : 0, oe = ke(oe, pe, Te), oe = Le(oe, pe);
        else if (!c || l || _ || b) {
          if (c && !_ && l ^ b) oe = Le(oe, pe), l ? (ie = 0, oe = ke(oe, pe, Te)) : (ie = 1, oe = ke(oe, pe, Te), oe = Le(oe, pe));
          else if (c && l && !_ && b) ie = 1, oe = ke(oe, pe, Te), oe = Le(oe, pe);
          else if (!c && !_ && l ^ b) {
            var xe = w;
            l ? (ie = 1, oe = ke(oe, pe, Te), ie = 0, w = !1, oe = ke(oe, pe, Te), w = xe) : (ie = 0, oe = ke(oe, pe, Te), oe = Le(oe, pe), ie = 1, w = !1, oe = ke(oe, pe, Te), w = xe, oe = Le(oe, pe));
          }
        } else ie = 0, oe = ke(oe, pe, Te);
      else ie = l ? 1 : 0, oe = ke(oe, pe, Te);
      return oe;
    }, this.__bidiEngine__.setOptions = function(oe) {
      oe && (c = oe.isInputVisual, _ = oe.isOutputVisual, l = oe.isInputRtl, b = oe.isOutputRtl, w = oe.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(r), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new n.__bidiEngine__({ isInputVisual: !0 });
  n.API.events.push(["postProcessText", function(r) {
    var i = r.text, o = (r.x, r.y, r.options || {}), c = (r.mutex, o.lang, []);
    if (o.isInputVisual = typeof o.isInputVisual != "boolean" || o.isInputVisual, t.setOptions(o), Object.prototype.toString.call(i) === "[object Array]") {
      var l = 0;
      for (c = [], l = 0; l < i.length; l += 1) Object.prototype.toString.call(i[l]) === "[object Array]" ? c.push([t.doBidiReorder(i[l][0]), i[l][1], i[l][2]]) : c.push([t.doBidiReorder(i[l])]);
      r.text = c;
    } else r.text = t.doBidiReorder(i);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(Bn), Bn.API.TTFFont = function() {
  function n(e) {
    var t;
    if (this.rawData = e, t = this.contents = new $u(e), this.contents.pos = 4, t.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new jV(this), this.registerTTF();
  }
  return n.open = function(e) {
    return new n(e);
  }, n.prototype.parse = function() {
    return this.directory = new CV(this.contents), this.head = new PV(this), this.name = new OV(this), this.cmap = new FT(this), this.toUnicode = {}, this.hhea = new LV(this), this.maxp = new DV(this), this.hmtx = new FV(this), this.post = new BV(this), this.os2 = new MV(this), this.loca = new UV(this), this.glyf = new kV(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, n.prototype.registerTTF = function() {
    var e, t, r, i, o;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var c, l, _, b;
      for (b = [], c = 0, l = (_ = this.bbox).length; c < l; c++) e = _[c], b.push(Math.round(e * this.scaleFactor));
      return b;
    }).call(this), this.stemV = 0, this.post.exists ? (r = 255 & (i = this.post.italic_angle), 32768 & (t = i >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (o = this.familyClass) === 1 || o === 2 || o === 3 || o === 4 || o === 5 || o === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, n.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, n.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, n.prototype.widthOfString = function(e, t, r) {
    var i, o, c, l;
    for (c = 0, o = 0, l = (e = "" + e).length; 0 <= l ? o < l : o > l; o = 0 <= l ? ++o : --o) i = e.charCodeAt(o), c += this.widthOfGlyph(this.characterToGlyph(i)) + r * (1e3 / t) || 0;
    return c * (t / 1e3);
  }, n.prototype.lineHeight = function(e, t) {
    var r;
    return t == null && (t = !1), r = t ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * e;
  }, n;
}();
var Il, $u = function() {
  function n(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return n.prototype.readByte = function() {
    return this.data[this.pos++];
  }, n.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, n.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, n.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, n.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, n.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, n.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, n.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, n.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, n.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, n.prototype.readString = function(e) {
    var t, r;
    for (r = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t) r[t] = String.fromCharCode(this.readByte());
    return r.join("");
  }, n.prototype.writeString = function(e) {
    var t, r, i;
    for (i = [], t = 0, r = e.length; 0 <= r ? t < r : t > r; t = 0 <= r ? ++t : --t) i.push(this.writeByte(e.charCodeAt(t)));
    return i;
  }, n.prototype.readShort = function() {
    return this.readInt16();
  }, n.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, n.prototype.readLongLong = function() {
    var e, t, r, i, o, c, l, _;
    return e = this.readByte(), t = this.readByte(), r = this.readByte(), i = this.readByte(), o = this.readByte(), c = this.readByte(), l = this.readByte(), _ = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ i) + 16777216 * (255 ^ o) + 65536 * (255 ^ c) + 256 * (255 ^ l) + (255 ^ _) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * r + 4294967296 * i + 16777216 * o + 65536 * c + 256 * l + _;
  }, n.prototype.writeLongLong = function(e) {
    var t, r;
    return t = Math.floor(e / 4294967296), r = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
  }, n.prototype.readInt = function() {
    return this.readInt32();
  }, n.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, n.prototype.read = function(e) {
    var t, r;
    for (t = [], r = 0; 0 <= e ? r < e : r > e; r = 0 <= e ? ++r : --r) t.push(this.readByte());
    return t;
  }, n.prototype.write = function(e) {
    var t, r, i, o;
    for (o = [], r = 0, i = e.length; r < i; r++) t = e[r], o.push(this.writeByte(t));
    return o;
  }, n;
}(), CV = function() {
  var n;
  function e(t) {
    var r, i, o;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, i = 0, o = this.tableCount; 0 <= o ? i < o : i > o; i = 0 <= o ? ++i : --i) r = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[r.tag] = r;
  }
  return e.prototype.encode = function(t) {
    var r, i, o, c, l, _, b, w, T, I, P, k, U;
    for (U in P = Object.keys(t).length, _ = Math.log(2), T = 16 * Math.floor(Math.log(P) / _), c = Math.floor(T / _), w = 16 * P - T, (i = new $u()).writeInt(this.scalarType), i.writeShort(P), i.writeShort(T), i.writeShort(c), i.writeShort(w), o = 16 * P, b = i.pos + o, l = null, k = [], t) for (I = t[U], i.writeString(U), i.writeInt(n(I)), i.writeInt(b), i.writeInt(I.length), k = k.concat(I), U === "head" && (l = b), b += I.length; b % 4; ) k.push(0), b++;
    return i.write(k), r = 2981146554 - n(i.data), i.pos = l + 8, i.writeUInt32(r), i.data;
  }, n = function(t) {
    var r, i, o, c;
    for (t = kT.call(t); t.length % 4; ) t.push(0);
    for (o = new $u(t), i = 0, r = 0, c = t.length; r < c; r = r += 4) i += o.readUInt32();
    return 4294967295 & i;
  }, e;
}(), IV = {}.hasOwnProperty, Ac = function(n, e) {
  for (var t in e) IV.call(e, t) && (n[t] = e[t]);
  function r() {
    this.constructor = n;
  }
  return r.prototype = e.prototype, n.prototype = new r(), n.__super__ = e.prototype, n;
};
Il = function() {
  function n(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return n.prototype.parse = function() {
  }, n.prototype.encode = function() {
  }, n.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, n;
}();
var PV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var r;
    return (r = new $u()).writeInt(this.version), r.writeInt(this.revision), r.writeInt(this.checkSumAdjustment), r.writeInt(this.magicNumber), r.writeShort(this.flags), r.writeShort(this.unitsPerEm), r.writeLongLong(this.created), r.writeLongLong(this.modified), r.writeShort(this.xMin), r.writeShort(this.yMin), r.writeShort(this.xMax), r.writeShort(this.yMax), r.writeShort(this.macStyle), r.writeShort(this.lowestRecPPEM), r.writeShort(this.fontDirectionHint), r.writeShort(t), r.writeShort(this.glyphDataFormat), r.data;
  }, e;
}(), t5 = function() {
  function n(e, t) {
    var r, i, o, c, l, _, b, w, T, I, P, k, U, G, H, $, ie;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), T = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (_ = 0; _ < 256; ++_) this.codeMap[_] = e.readByte();
        break;
      case 4:
        for (P = e.readUInt16(), I = P / 2, e.pos += 6, o = function() {
          var ge, Se;
          for (Se = [], _ = ge = 0; 0 <= I ? ge < I : ge > I; _ = 0 <= I ? ++ge : --ge) Se.push(e.readUInt16());
          return Se;
        }(), e.pos += 2, U = function() {
          var ge, Se;
          for (Se = [], _ = ge = 0; 0 <= I ? ge < I : ge > I; _ = 0 <= I ? ++ge : --ge) Se.push(e.readUInt16());
          return Se;
        }(), b = function() {
          var ge, Se;
          for (Se = [], _ = ge = 0; 0 <= I ? ge < I : ge > I; _ = 0 <= I ? ++ge : --ge) Se.push(e.readUInt16());
          return Se;
        }(), w = function() {
          var ge, Se;
          for (Se = [], _ = ge = 0; 0 <= I ? ge < I : ge > I; _ = 0 <= I ? ++ge : --ge) Se.push(e.readUInt16());
          return Se;
        }(), i = (this.length - e.pos + this.offset) / 2, l = function() {
          var ge, Se;
          for (Se = [], _ = ge = 0; 0 <= i ? ge < i : ge > i; _ = 0 <= i ? ++ge : --ge) Se.push(e.readUInt16());
          return Se;
        }(), _ = H = 0, ie = o.length; H < ie; _ = ++H) for (G = o[_], r = $ = k = U[_]; k <= G ? $ <= G : $ >= G; r = k <= G ? ++$ : --$) w[_] === 0 ? c = r + b[_] : (c = l[w[_] / 2 + (r - k) - (I - _)] || 0) !== 0 && (c += b[_]), this.codeMap[r] = 65535 & c;
    }
    e.pos = T;
  }
  return n.encode = function(e, t) {
    var r, i, o, c, l, _, b, w, T, I, P, k, U, G, H, $, ie, ge, Se, Re, Le, _e, Ge, ke, oe, pe, Te, xe, et, rt, st, Je, ct, ot, Mt, re, Ae, Ce, Ue, qe, He, Ye, Ze, St, Lt, Dt;
    switch (xe = new $u(), c = Object.keys(e).sort(function(Nt, an) {
      return Nt - an;
    }), t) {
      case "macroman":
        for (U = 0, G = function() {
          var Nt = [];
          for (k = 0; k < 256; ++k) Nt.push(0);
          return Nt;
        }(), $ = { 0: 0 }, o = {}, et = 0, ct = c.length; et < ct; et++) $[Ze = e[i = c[et]]] == null && ($[Ze] = ++U), o[i] = { old: e[i], new: $[e[i]] }, G[i] = $[e[i]];
        return xe.writeUInt16(1), xe.writeUInt16(0), xe.writeUInt32(12), xe.writeUInt16(0), xe.writeUInt16(262), xe.writeUInt16(0), xe.write(G), { charMap: o, subtable: xe.data, maxGlyphID: U + 1 };
      case "unicode":
        for (pe = [], T = [], ie = 0, $ = {}, r = {}, H = b = null, rt = 0, ot = c.length; rt < ot; rt++) $[Se = e[i = c[rt]]] == null && ($[Se] = ++ie), r[i] = { old: Se, new: $[Se] }, l = $[Se] - i, H != null && l === b || (H && T.push(H), pe.push(i), b = l), H = i;
        for (H && T.push(H), T.push(65535), pe.push(65535), ke = 2 * (Ge = pe.length), _e = 2 * Math.pow(Math.log(Ge) / Math.LN2, 2), I = Math.log(_e / 2) / Math.LN2, Le = 2 * Ge - _e, _ = [], Re = [], P = [], k = st = 0, Mt = pe.length; st < Mt; k = ++st) {
          if (oe = pe[k], w = T[k], oe === 65535) {
            _.push(0), Re.push(0);
            break;
          }
          if (oe - (Te = r[oe].new) >= 32768) for (_.push(0), Re.push(2 * (P.length + Ge - k)), i = Je = oe; oe <= w ? Je <= w : Je >= w; i = oe <= w ? ++Je : --Je) P.push(r[i].new);
          else _.push(Te - oe), Re.push(0);
        }
        for (xe.writeUInt16(3), xe.writeUInt16(1), xe.writeUInt32(12), xe.writeUInt16(4), xe.writeUInt16(16 + 8 * Ge + 2 * P.length), xe.writeUInt16(0), xe.writeUInt16(ke), xe.writeUInt16(_e), xe.writeUInt16(I), xe.writeUInt16(Le), He = 0, re = T.length; He < re; He++) i = T[He], xe.writeUInt16(i);
        for (xe.writeUInt16(0), Ye = 0, Ae = pe.length; Ye < Ae; Ye++) i = pe[Ye], xe.writeUInt16(i);
        for (St = 0, Ce = _.length; St < Ce; St++) l = _[St], xe.writeUInt16(l);
        for (Lt = 0, Ue = Re.length; Lt < Ue; Lt++) ge = Re[Lt], xe.writeUInt16(ge);
        for (Dt = 0, qe = P.length; Dt < qe; Dt++) U = P[Dt], xe.writeUInt16(U);
        return { charMap: r, subtable: xe.data, maxGlyphID: ie + 1 };
    }
  }, n;
}(), FT = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var r, i, o;
    for (t.pos = this.offset, this.version = t.readUInt16(), o = t.readUInt16(), this.tables = [], this.unicode = null, i = 0; 0 <= o ? i < o : i > o; i = 0 <= o ? ++i : --i) r = new t5(t, this.offset), this.tables.push(r), r.isUnicode && this.unicode == null && (this.unicode = r);
    return !0;
  }, e.encode = function(t, r) {
    var i, o;
    return r == null && (r = "macroman"), i = t5.encode(t, r), (o = new $u()).writeUInt16(0), o.writeUInt16(1), i.table = o.data.concat(i.subtable), i;
  }, e;
}(), LV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}(), MV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var r, i;
      for (i = [], r = 0; r < 10; ++r) i.push(t.readByte());
      return i;
    }(), this.charRange = function() {
      var r, i;
      for (i = [], r = 0; r < 4; ++r) i.push(t.readInt());
      return i;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var r, i;
      for (i = [], r = 0; r < 2; r = ++r) i.push(t.readInt());
      return i;
    }(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}(), BV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var r, i, o;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var c;
        for (i = t.readUInt16(), this.glyphNameIndex = [], c = 0; 0 <= i ? c < i : c > i; c = 0 <= i ? ++c : --c) this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], o = []; t.pos < this.offset + this.length; ) r = t.readByte(), o.push(this.names.push(t.readString(r)));
        return o;
      case 151552:
        return i = t.readUInt16(), this.offsets = t.read(i);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var l, _, b;
          for (b = [], c = l = 0, _ = this.file.maxp.numGlyphs; 0 <= _ ? l < _ : l > _; c = 0 <= _ ? ++l : --l) b.push(t.readUInt32());
          return b;
        }).call(this);
    }
  }, e;
}(), RV = function(n, e) {
  this.raw = n, this.length = n.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, OV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var r, i, o, c, l, _, b, w, T, I, P;
    for (t.pos = this.offset, t.readShort(), r = t.readShort(), _ = t.readShort(), i = [], c = 0; 0 <= r ? c < r : c > r; c = 0 <= r ? ++c : --c) i.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + _ + t.readShort() });
    for (b = {}, c = T = 0, I = i.length; T < I; c = ++T) o = i[c], t.pos = o.offset, w = t.readString(o.length), l = new RV(w, o), b[P = o.nameID] == null && (b[P] = []), b[o.nameID].push(l);
    this.strings = b, this.copyright = b[0], this.fontFamily = b[1], this.fontSubfamily = b[2], this.uniqueSubfamily = b[3], this.fontName = b[4], this.version = b[5];
    try {
      this.postscriptName = b[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = b[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = b[7], this.manufacturer = b[8], this.designer = b[9], this.description = b[10], this.vendorUrl = b[11], this.designerUrl = b[12], this.license = b[13], this.licenseUrl = b[14], this.preferredFamily = b[15], this.preferredSubfamily = b[17], this.compatibleFull = b[18], this.sampleText = b[19];
  }, e;
}(), DV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}(), FV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var r, i, o, c, l, _, b;
    for (t.pos = this.offset, this.metrics = [], r = 0, _ = this.file.hhea.numberOfMetrics; 0 <= _ ? r < _ : r > _; r = 0 <= _ ? ++r : --r) this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (o = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var w, T;
      for (T = [], r = w = 0; 0 <= o ? w < o : w > o; r = 0 <= o ? ++w : --w) T.push(t.readInt16());
      return T;
    }(), this.widths = (function() {
      var w, T, I, P;
      for (P = [], w = 0, T = (I = this.metrics).length; w < T; w++) c = I[w], P.push(c.advance);
      return P;
    }).call(this), i = this.widths[this.widths.length - 1], b = [], r = l = 0; 0 <= o ? l < o : l > o; r = 0 <= o ? ++l : --l) b.push(this.widths.push(i));
    return b;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
}(), kT = [].slice, kV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var r, i, o, c, l, _, b, w, T, I;
    return t in this.cache ? this.cache[t] : (c = this.file.loca, r = this.file.contents, i = c.indexOf(t), (o = c.lengthOf(t)) === 0 ? this.cache[t] = null : (r.pos = this.offset + i, l = (_ = new $u(r.read(o))).readShort(), w = _.readShort(), I = _.readShort(), b = _.readShort(), T = _.readShort(), this.cache[t] = l === -1 ? new zV(_, w, I, b, T) : new NV(_, l, w, I, b, T), this.cache[t]));
  }, e.prototype.encode = function(t, r, i) {
    var o, c, l, _, b;
    for (l = [], c = [], _ = 0, b = r.length; _ < b; _++) o = t[r[_]], c.push(l.length), o && (l = l.concat(o.encode(i)));
    return c.push(l.length), { table: l, offsets: c };
  }, e;
}(), NV = function() {
  function n(e, t, r, i, o, c) {
    this.raw = e, this.numberOfContours = t, this.xMin = r, this.yMin = i, this.xMax = o, this.yMax = c, this.compound = !1;
  }
  return n.prototype.encode = function() {
    return this.raw.data;
  }, n;
}(), zV = function() {
  function n(e, t, r, i, o) {
    var c, l;
    for (this.raw = e, this.xMin = t, this.yMin = r, this.xMax = i, this.yMax = o, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], c = this.raw; l = c.readShort(), this.glyphOffsets.push(c.pos), this.glyphIDs.push(c.readUInt16()), 32 & l; ) c.pos += 1 & l ? 4 : 2, 128 & l ? c.pos += 8 : 64 & l ? c.pos += 4 : 8 & l && (c.pos += 2);
  }
  return n.prototype.encode = function() {
    var e, t, r;
    for (t = new $u(kT.call(this.raw.data)), e = 0, r = this.glyphIDs.length; e < r; ++e) t.pos = this.glyphOffsets[e];
    return t.data;
  }, n;
}(), UV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Ac(e, Il), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var r, i;
    return t.pos = this.offset, r = this.file.head.indexToLocFormat, this.offsets = r === 0 ? (function() {
      var o, c;
      for (c = [], i = 0, o = this.length; i < o; i += 2) c.push(2 * t.readUInt16());
      return c;
    }).call(this) : (function() {
      var o, c;
      for (c = [], i = 0, o = this.length; i < o; i += 4) c.push(t.readUInt32());
      return c;
    }).call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, r) {
    for (var i = new Uint32Array(this.offsets.length), o = 0, c = 0, l = 0; l < i.length; ++l) if (i[l] = o, c < r.length && r[c] == l) {
      ++c, i[l] = o;
      var _ = this.offsets[l], b = this.offsets[l + 1] - _;
      b > 0 && (o += b);
    }
    for (var w = new Array(4 * i.length), T = 0; T < i.length; ++T) w[4 * T + 3] = 255 & i[T], w[4 * T + 2] = (65280 & i[T]) >> 8, w[4 * T + 1] = (16711680 & i[T]) >> 16, w[4 * T] = (4278190080 & i[T]) >> 24;
    return w;
  }, e;
}(), jV = function() {
  function n(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return n.prototype.generateCmap = function() {
    var e, t, r, i, o;
    for (t in i = this.font.cmap.tables[0].codeMap, e = {}, o = this.subset) r = o[t], e[t] = i[r];
    return e;
  }, n.prototype.glyphsFor = function(e) {
    var t, r, i, o, c, l, _;
    for (i = {}, c = 0, l = e.length; c < l; c++) i[o = e[c]] = this.font.glyf.glyphFor(o);
    for (o in t = [], i) (r = i[o]) != null && r.compound && t.push.apply(t, r.glyphIDs);
    if (t.length > 0) for (o in _ = this.glyphsFor(t)) r = _[o], i[o] = r;
    return i;
  }, n.prototype.encode = function(e, t) {
    var r, i, o, c, l, _, b, w, T, I, P, k, U, G, H;
    for (i in r = FT.encode(this.generateCmap(), "unicode"), c = this.glyphsFor(e), P = { 0: 0 }, H = r.charMap) P[(_ = H[i]).old] = _.new;
    for (k in I = r.maxGlyphID, c) k in P || (P[k] = I++);
    return w = function($) {
      var ie, ge;
      for (ie in ge = {}, $) ge[$[ie]] = ie;
      return ge;
    }(P), T = Object.keys(w).sort(function($, ie) {
      return $ - ie;
    }), U = function() {
      var $, ie, ge;
      for (ge = [], $ = 0, ie = T.length; $ < ie; $++) l = T[$], ge.push(w[l]);
      return ge;
    }(), o = this.font.glyf.encode(c, U, P), b = this.font.loca.encode(o.offsets, U), G = { cmap: this.font.cmap.raw(), glyf: o.table, loca: b, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && (G["OS/2"] = this.font.os2.raw()), this.font.directory.encode(G);
  }, n;
}();
Bn.API.PDFObject = function() {
  var n;
  function e() {
  }
  return n = function(t, r) {
    return (Array(r + 1).join("0") + t).slice(-r);
  }, e.convert = function(t) {
    var r, i, o, c;
    if (Array.isArray(t)) return "[" + function() {
      var l, _, b;
      for (b = [], l = 0, _ = t.length; l < _; l++) r = t[l], b.push(e.convert(r));
      return b;
    }().join(" ") + "]";
    if (typeof t == "string") return "/" + t;
    if (t != null && t.isString) return "(" + t + ")";
    if (t instanceof Date) return "(D:" + n(t.getUTCFullYear(), 4) + n(t.getUTCMonth(), 2) + n(t.getUTCDate(), 2) + n(t.getUTCHours(), 2) + n(t.getUTCMinutes(), 2) + n(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (i in o = ["<<"], t) c = t[i], o.push("/" + i + " " + e.convert(c));
      return o.push(">>"), o.join(`
`);
    }
    return "" + t;
  }, e;
}();
const Ob = { "circle-radius": 8, "circle-color": "red", "circle-stroke-width": 1, "circle-stroke-color": "black" }, Db = { textSize: 16, textHaloColor: "#FFFFFF", textHaloWidth: 0.8, textColor: "#000000", fallbackTextFont: ["Open Sans Regular"] };
class GV {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. deafult is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ph.A4, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Yc.PNG, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : tf.mm, c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "maplibregl-marker", _ = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : Ob, b = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : "maplibregl-ctrl-attrib-inner", w = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : Db;
    gr(this, "map"), gr(this, "width"), gr(this, "height"), gr(this, "dpi"), gr(this, "format"), gr(this, "unit"), gr(this, "fileName"), gr(this, "markerClassName"), gr(this, "markerCirclePaint"), gr(this, "attributionClassName"), gr(this, "attributionStyle"), this.map = e, this.width = t[0], this.height = t[1], this.dpi = r, this.format = i, this.unit = o, this.fileName = c, this.markerClassName = l, this.markerCirclePaint = _, this.attributionClassName = b, this.attributionStyle = w;
  }
  renderMapPost(e) {
    return e;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(e) {
    const t = this.getMarkers();
    for (let r = 0; r < t.length; r++) {
      const i = t.item(r);
      if (!i) continue;
      const o = i.getAttribute("style");
      if (!o) continue;
      const c = /translate\(([^,]+)px,\s*([^,]+)px\)/, l = o.match(c);
      if (!l) continue;
      const _ = parseInt(l[1]), b = parseInt(l[2]), w = this.map.unproject([_, b]), T = `point${r}`;
      e.addSource(T, { type: "geojson", data: { type: "Point", coordinates: [w.lng, w.lat] } }), e.addLayer({ id: T, source: T, type: "circle", paint: this.markerCirclePaint });
    }
    return e;
  }
  /**
  * Generate and download Map image
  */
  generate() {
    const e = this;
    JsLoadingOverlay.show({ overlayBackgroundColor: "#5D5959", overlayOpacity: "0.6", spinnerIcon: "ball-spin", spinnerColor: "#2400FD", spinnerSize: "2x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetX: 0, offsetY: 0, containerID: null, lockScroll: !1, overlayZIndex: 9998, spinnerZIndex: 9999 });
    const t = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", { get() {
      return e.dpi / 96;
    } });
    const r = document.createElement("div");
    r.className = "hidden-map", document.body.appendChild(r);
    const i = document.createElement("div");
    i.style.width = this.toPixels(this.width), i.style.height = this.toPixels(this.height), r.appendChild(i);
    const o = this.map.getStyle();
    if (o && o.sources) {
      const l = o.sources;
      Object.keys(l).forEach((_) => {
        const b = l[_];
        Object.keys(b).forEach((w) => {
          b[w] || delete b[w];
        });
      });
    }
    let c = this.getRenderedMap(i, o);
    c.once("idle", () => {
      this.addAttributions(c) ? c.once("idle", () => {
        c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, r, t) : (c = this.renderMarkers(c), c.once("idle", () => {
          this.exportImage(c, r, t);
        }));
      }) : (c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, r, t) : (c = this.renderMarkers(c), c.once("idle", () => {
        this.exportImage(c, r, t);
      })));
    });
  }
  stripHtml(e) {
    const t = document.createElement("div");
    return t.innerHTML = e, t.textContent || t.innerText || "";
  }
  addAttributions(e) {
    if (!this.map.getStyle().glyphs) return !1;
    const t = e.getContainer(), r = parseInt(t.style.width.replace("px", "")) - 5, i = parseInt(t.style.height.replace("px", "")) - 5, o = [r, i], c = e.unproject(o), l = t.getElementsByClassName(this.attributionClassName), _ = [];
    if ((l == null ? void 0 : l.length) > 0) {
      const P = l.item(0);
      if (P) for (let k = 0; k < P.children.length; k++) {
        const U = P.children.item(k);
        U && _.push(this.stripHtml(U.outerHTML));
      }
    } else {
      const P = this.map.getStyle().sources;
      Object.keys(P).forEach((k) => {
        const U = P[k];
        if ("attribution" in U) {
          const G = U.attribution;
          _.push(this.stripHtml(G));
        }
      });
    }
    if (_.length === 0) return !1;
    const b = _.join(" | "), w = "attribution";
    e.addSource(w, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [c.lng, c.lat] }, properties: { attribution: b } } });
    const T = this.map.getStyle().layers.filter((P) => P.type === "symbol" && P.layout && "text-font" in P.layout), I = T.length > 0 && T[0].layout ? T[0].layout["text-font"] : this.attributionStyle.fallbackTextFont;
    return e.addLayer({ id: w, source: w, type: "symbol", layout: { "text-field": ["get", "attribution"], "text-font": I, "text-max-width": parseInt(`${r / this.attributionStyle.textSize}`), "text-anchor": "bottom-right", "text-justify": "right", "text-size": this.attributionStyle.textSize }, paint: { "text-halo-color": this.attributionStyle.textHaloColor, "text-halo-width": this.attributionStyle.textHaloWidth, "text-color": this.attributionStyle.textColor } }), !0;
  }
  exportImage(e, t, r) {
    var i;
    const o = e.getCanvas(), c = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Yc.PNG:
        this.toPNG(o, c);
        break;
      case Yc.JPEG:
        this.toJPEG(o, c);
        break;
      case Yc.PDF:
        this.toPDF(e, c);
        break;
      case Yc.SVG:
        this.toSVG(o, c);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    e.remove(), (i = t.parentNode) == null || i.removeChild(t), Object.defineProperty(window, "devicePixelRatio", { get() {
      return r;
    } }), t.remove(), JsLoadingOverlay.hide();
  }
  /**
  * Convert canvas to PNG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toPNG(e, t) {
    const r = document.createElement("a");
    r.href = e.toDataURL(), r.download = t, r.click(), r.remove();
  }
  /**
  * Convert canvas to JPEG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toJPEG(e, t) {
    const r = e.toDataURL("image/jpeg", 0.85), i = document.createElement("a");
    i.href = r, i.download = t, i.click(), i.remove();
  }
  /**
  * Convert Map object to PDF
  * @param map Map object
  * @param fileName file name
  */
  toPDF(e, t) {
    const r = e.getCanvas(), i = new Bn({ orientation: this.width > this.height ? "l" : "p", unit: this.unit, compress: !0, format: [this.width, this.height] });
    i.addImage(r.toDataURL("image/png"), "png", 0, 0, this.width, this.height, void 0, "FAST");
    const { lng: o, lat: c } = e.getCenter();
    i.setProperties({ title: e.getStyle().name, subject: `center: [${o}, ${c}], zoom: ${e.getZoom()}`, creator: "Mapbox GL Export Plugin", author: "(c)Mapbox, (c)OpenStreetMap" }), i.save(t);
  }
  /**
  * Convert canvas to SVG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toSVG(e, t) {
    const r = e.toDataURL("image/png"), i = Number(this.toPixels(this.width, this.dpi).replace("px", "")), o = Number(this.toPixels(this.height, this.dpi).replace("px", "")), c = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${i}" 
      height="${o}" 
      viewBox="0 0 ${i} ${o}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${r}" width="${i}" height="${o}"></image>
    </svg>`, l = document.createElement("a");
    l.href = `data:application/xml,${encodeURIComponent(c)}`, l.download = t, l.click(), l.remove();
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === tf.mm && (t /= 25.4), `${t * e}px`;
  }
}
class VV extends GV {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. deafult is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ph.A4, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Yc.PNG, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : tf.mm, c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : Ob, _ = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : Db;
    super(e, t, r, i, o, c, "maplibregl-marker", l, "maplibregl-ctrl-attrib-inner", _);
  }
  getRenderedMap(e, t) {
    const r = new S5.Map({
      container: e,
      style: t,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (r.setMaxPitch(85), r.setPitch(this.map.getPitch()));
    const i = (this.map.style.imageManager || {}).images || [];
    return Object.keys(i).forEach((o) => {
      r.addImage(o, i[o].data);
    }), r;
  }
  renderMapPost(e) {
    const t = this.map.getTerrain();
    return t && e.setTerrain({ source: t.source, exaggeration: t.exaggeration }), e;
  }
}
class qV {
  constructor(e) {
    gr(this, "controlContainer"), gr(this, "exportContainer"), gr(this, "crosshair"), gr(this, "printableArea"), gr(this, "map"), gr(this, "exportButton"), gr(this, "options", { PageSize: Ph.A4, PageOrientation: ip.Landscape, Format: Yc.PDF, DPI: $y[300], Crosshair: !1, PrintableArea: !1, Local: "en", AllowedSizes: Object.keys(Ph), Filename: "map", markerCirclePaint: Ob, attributionStyle: Db }), gr(this, "MAPLIB_CSS_PREFIX", "maplibregl"), e && (this.options = Object.assign(this.options, e)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const e = this.options.Local ?? "en";
    return HG(e);
  }
  onAdd(e) {
    var t;
    this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const r = document.createElement("TABLE");
    r.className = "print-table";
    const i = {};
    (t = this.options.AllowedSizes) == null || t.forEach((w) => {
      Ph[w] && (i[w] = Ph[w]);
    });
    const o = this.createSelection(i, this.getTranslation().PageSize, "page-size", this.options.PageSize, (w, T) => JSON.stringify(w[T]));
    r.appendChild(o);
    const c = this.createSelection(ip, this.getTranslation().PageOrientation, "page-orientation", this.options.PageOrientation, (w, T) => w[T]);
    r.appendChild(c);
    const l = this.createSelection(Yc, this.getTranslation().Format, "format-type", this.options.Format, (w, T) => w[T]);
    r.appendChild(l);
    const _ = this.createSelection($y, this.getTranslation().DPI, "dpi-type", this.options.DPI, (w, T) => w[T]);
    r.appendChild(_), this.exportContainer.appendChild(r);
    const b = document.createElement("button");
    return b.type = "button", b.textContent = this.getTranslation().Generate, b.classList.add("generate-button"), b.addEventListener("click", () => {
      const w = document.getElementById("mapbox-gl-export-page-size"), T = document.getElementById("mapbox-gl-export-page-orientation"), I = document.getElementById("mapbox-gl-export-format-type"), P = document.getElementById("mapbox-gl-export-dpi-type"), k = T.value;
      let U = JSON.parse(w.value);
      k === ip.Portrait && (U = U.reverse()), this.generateMap(e, U, Number(P.value), I.value, tf.mm, this.options.Filename);
    }), this.exportContainer.appendChild(b), this.controlContainer;
  }
  generateMap(e, t, r, i, o, c) {
    new VV(e, t, r, i, o, c, this.options.markerCirclePaint, this.options.attributionStyle).generate();
  }
  createSelection(e, t, r, i, o) {
    const c = document.createElement("label");
    c.textContent = t;
    const l = document.createElement("select");
    l.setAttribute("id", `mapbox-gl-export-${r}`), l.style.width = "100%", Object.keys(e).forEach((T) => {
      const I = document.createElement("option");
      I.setAttribute("value", o(e, T)), I.appendChild(document.createTextNode(T)), I.setAttribute("name", r), i === e[T] && (I.selected = !0), l.appendChild(I);
    }), l.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const _ = document.createElement("TR"), b = document.createElement("TD"), w = document.createElement("TD");
    return b.appendChild(c), w.appendChild(l), _.appendChild(b), _.appendChild(w), _;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(e) {
    this.controlContainer && !this.controlContainer.contains(e.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(e) {
    this.options.Crosshair === !0 && (e === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new LG(this.map), this.crosshair.create()));
  }
  togglePrintableArea(e) {
    this.options.PrintableArea === !0 && (e === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new MG(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0) return;
    const e = document.getElementById("mapbox-gl-export-page-size"), t = document.getElementById("mapbox-gl-export-page-orientation").value;
    let r = JSON.parse(e.value);
    t === ip.Portrait && (r = r.reverse()), this.printableArea.updateArea(r[0], r[1]);
  }
}
var NT = WV, HV = Object.prototype.hasOwnProperty;
function WV() {
  for (var n = {}, e = 0; e < arguments.length; e++) {
    var t = arguments[e];
    for (var r in t)
      HV.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
var zT = { exports: {} };
(function(n, e) {
  (function() {
    var t = {};
    n.exports = t, t.simpleFilter = function(r, i) {
      return i.filter(function(o) {
        return t.test(r, o);
      });
    }, t.test = function(r, i) {
      return t.match(r, i) !== null;
    }, t.match = function(r, i, o) {
      o = o || {};
      var c = 0, l = [], _ = i.length, b = 0, w = 0, T = o.pre || "", I = o.post || "", P = o.caseSensitive && i || i.toLowerCase(), k;
      r = o.caseSensitive && r || r.toLowerCase();
      for (var U = 0; U < _; U++)
        k = i[U], P[U] === r[c] ? (k = T + k + I, c += 1, w += 1 + w) : w = 0, b += w, l[l.length] = k;
      return c === r.length ? (b = P === r ? 1 / 0 : b, {
        rendered: l.join(""),
        score: b
      }) : null;
    }, t.filter = function(r, i, o) {
      return !i || i.length === 0 ? [] : typeof r != "string" ? i : (o = o || {}, i.reduce(function(c, l, _, b) {
        var w = l;
        o.extract && (w = o.extract(l));
        var T = t.match(r, w, o);
        return T != null && (c[c.length] = {
          string: T.rendered,
          score: T.score,
          index: _,
          original: l
        }), c;
      }, []).sort(function(c, l) {
        var _ = l.score - c.score;
        return _ || c.index - l.index;
      }));
    };
  })();
})(zT);
var XV = zT.exports, $o = function(n) {
  return this.component = n, this.items = [], this.active = n.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, n.el.parentNode.insertBefore(this.wrapper, n.el.nextSibling), this;
};
$o.prototype.show = function() {
  this.element.style.display = "block";
};
$o.prototype.hide = function() {
  this.element.style.display = "none";
};
$o.prototype.add = function(n) {
  this.items.push(n);
};
$o.prototype.clear = function() {
  this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
};
$o.prototype.isEmpty = function() {
  return !this.items.length;
};
$o.prototype.isVisible = function() {
  return this.element.style.display === "block";
};
$o.prototype.draw = function() {
  if (this.element.innerHTML = "", this.items.length === 0) {
    this.hide();
    return;
  }
  for (var n = 0; n < this.items.length; n++)
    this.drawItem(this.items[n], this.active === n);
  this.show();
};
$o.prototype.drawItem = function(n, e) {
  var t = document.createElement("li"), r = document.createElement("a");
  e && (t.className += " active"), r.innerHTML = n.string, t.appendChild(r), this.element.appendChild(t), t.addEventListener("mousedown", (function() {
    this.selectingListItem = !0;
  }).bind(this)), t.addEventListener("mouseup", (function() {
    this.handleMouseUp.call(this, n);
  }).bind(this));
};
$o.prototype.handleMouseUp = function(n) {
  this.selectingListItem = !1, this.component.value(n.original), this.clear(), this.draw();
};
$o.prototype.move = function(n) {
  this.active = n, this.draw();
};
$o.prototype.previous = function() {
  this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
};
$o.prototype.next = function() {
  this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
};
$o.prototype.drawError = function(n) {
  var e = document.createElement("li");
  e.innerHTML = n, this.element.appendChild(e), this.show();
};
var $V = $o, ZV = NT, JV = XV, YV = $V, io = function(n, e, t) {
  return t = t || {}, this.options = ZV({
    minLength: 2,
    limit: 5,
    filter: !0,
    hideOnBlur: !0,
    noInitialSelection: !0
  }, t), this.el = n, this.data = e || [], this.list = new YV(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(r) {
    this.handleKeyUp(r.keyCode, r);
  }).bind(this), !1), this.el.addEventListener("keydown", (function(r) {
    this.handleKeyDown(r);
  }).bind(this)), this.el.addEventListener("focus", (function() {
    this.handleFocus();
  }).bind(this)), this.el.addEventListener("blur", (function() {
    this.handleBlur();
  }).bind(this)), this.el.addEventListener("paste", (function(r) {
    this.handlePaste(r);
  }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
};
io.prototype.handleKeyUp = function(n, e) {
  if (!(n === 40 || n === 38 || n === 27 || n === 9)) {
    if (n === 13) {
      this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), e.stopPropagation());
      return;
    }
    this.handleInputChange(this.el.value);
  }
};
io.prototype.handleKeyDown = function(n) {
  switch (n.keyCode) {
    case 13:
      this.list.active >= 0 && (this.list.selectingListItem = !0);
      break;
    case 9:
      this.list.isEmpty() || (this.list.isVisible() && n.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
      break;
    case 27:
      this.list.isEmpty() || this.list.hide();
      break;
    case 38:
      this.list.previous();
      break;
    case 40:
      this.list.next();
      break;
  }
};
io.prototype.handleBlur = function() {
  !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
};
io.prototype.handlePaste = function(n) {
  if (n.clipboardData)
    this.handleInputChange(n.clipboardData.getData("Text"));
  else {
    var e = this;
    setTimeout(function() {
      e.handleInputChange(n.target.value);
    }, 100);
  }
};
io.prototype.handleInputChange = function(n) {
  if (this.query = this.normalize(n), this.list.clear(), this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }
  this.getCandidates((function(e) {
    for (var t = 0; t < e.length && (this.list.add(e[t]), t !== this.options.limit - 1); t++)
      ;
    this.list.draw();
  }).bind(this));
};
io.prototype.handleFocus = function() {
  this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
};
io.prototype.update = function(n) {
  this.data = n, this.handleKeyUp();
};
io.prototype.clear = function() {
  this.data = [], this.list.clear();
};
io.prototype.normalize = function(n) {
  return n = n.toLowerCase(), n;
};
io.prototype.match = function(n, e) {
  return n.indexOf(e) > -1;
};
io.prototype.value = function(n) {
  if (this.selected = n, this.el.value = this.getItemValue(n || {
    place_name: this.query
  }), document.createEvent) {
    var e = document.createEvent("HTMLEvents");
    e.initEvent("change", !0, !1), this.el.dispatchEvent(e);
  } else
    this.el.fireEvent("onchange");
};
io.prototype.getCandidates = function(n) {
  var e = {
    pre: "<strong>",
    post: "</strong>",
    extract: (function(r) {
      return this.getItemValue(r);
    }).bind(this)
  }, t;
  this.options.filter ? (t = JV.filter(this.query, this.data, e), t = t.map((function(r) {
    return {
      original: r.original,
      string: this.render(r.original, r.string)
    };
  }).bind(this))) : t = this.data.map((function(r) {
    var i = this.render(r);
    return {
      original: r,
      string: i
    };
  }).bind(this)), n(t);
};
io.prototype.getItemValue = function(n) {
  return n;
};
io.prototype.render = function(n, e) {
  if (e)
    return e;
  for (var t = n.original ? this.getItemValue(n.original) : this.getItemValue(n), r = this.normalize(t), i = r.lastIndexOf(this.query); i > -1; ) {
    var o = i + this.query.length;
    t = t.slice(0, i) + "<strong>" + t.slice(i, o) + "</strong>" + t.slice(o), i = r.slice(0, i).lastIndexOf(this.query);
  }
  return t;
};
io.prototype.renderError = function(n) {
  this.list.drawError(n);
};
var KV = io, UT = KV, QV = UT;
typeof window < "u" && (window.Suggestions = UT);
var eq = "Expected a function", n5 = NaN, tq = "[object Symbol]", nq = /^\s+|\s+$/g, rq = /^[-+]0x[0-9a-f]+$/i, iq = /^0b[01]+$/i, sq = /^0o[0-7]+$/i, oq = parseInt, aq = typeof Pd == "object" && Pd && Pd.Object === Object && Pd, lq = typeof self == "object" && self && self.Object === Object && self, cq = aq || lq || Function("return this")(), uq = Object.prototype, hq = uq.toString, dq = Math.max, fq = Math.min, Y_ = function() {
  return cq.Date.now();
};
function pq(n, e, t) {
  var r, i, o, c, l, _, b = 0, w = !1, T = !1, I = !0;
  if (typeof n != "function")
    throw new TypeError(eq);
  e = r5(e) || 0, a1(t) && (w = !!t.leading, T = "maxWait" in t, o = T ? dq(r5(t.maxWait) || 0, e) : o, I = "trailing" in t ? !!t.trailing : I);
  function P(Re) {
    var Le = r, _e = i;
    return r = i = void 0, b = Re, c = n.apply(_e, Le), c;
  }
  function k(Re) {
    return b = Re, l = setTimeout(H, e), w ? P(Re) : c;
  }
  function U(Re) {
    var Le = Re - _, _e = Re - b, Ge = e - Le;
    return T ? fq(Ge, o - _e) : Ge;
  }
  function G(Re) {
    var Le = Re - _, _e = Re - b;
    return _ === void 0 || Le >= e || Le < 0 || T && _e >= o;
  }
  function H() {
    var Re = Y_();
    if (G(Re))
      return $(Re);
    l = setTimeout(H, U(Re));
  }
  function $(Re) {
    return l = void 0, I && r ? P(Re) : (r = i = void 0, c);
  }
  function ie() {
    l !== void 0 && clearTimeout(l), b = 0, r = _ = i = l = void 0;
  }
  function ge() {
    return l === void 0 ? c : $(Y_());
  }
  function Se() {
    var Re = Y_(), Le = G(Re);
    if (r = arguments, i = this, _ = Re, Le) {
      if (l === void 0)
        return k(_);
      if (T)
        return l = setTimeout(H, e), P(_);
    }
    return l === void 0 && (l = setTimeout(H, e)), c;
  }
  return Se.cancel = ie, Se.flush = ge, Se;
}
function a1(n) {
  var e = typeof n;
  return !!n && (e == "object" || e == "function");
}
function gq(n) {
  return !!n && typeof n == "object";
}
function mq(n) {
  return typeof n == "symbol" || gq(n) && hq.call(n) == tq;
}
function r5(n) {
  if (typeof n == "number")
    return n;
  if (mq(n))
    return n5;
  if (a1(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = a1(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = n.replace(nq, "");
  var t = iq.test(n);
  return t || sq.test(n) ? oq(n.slice(2), t ? 2 : 8) : rq.test(n) ? n5 : +n;
}
var _q = pq, Fb = { exports: {} }, qd = typeof Reflect == "object" ? Reflect : null, i5 = qd && typeof qd.apply == "function" ? qd.apply : function(e, t, r) {
  return Function.prototype.apply.call(e, t, r);
}, sm;
qd && typeof qd.ownKeys == "function" ? sm = qd.ownKeys : Object.getOwnPropertySymbols ? sm = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : sm = function(e) {
  return Object.getOwnPropertyNames(e);
};
function yq(n) {
  console && console.warn && console.warn(n);
}
var jT = Number.isNaN || function(e) {
  return e !== e;
};
function Hr() {
  Hr.init.call(this);
}
Fb.exports = Hr;
Fb.exports.once = wq;
Hr.EventEmitter = Hr;
Hr.prototype._events = void 0;
Hr.prototype._eventsCount = 0;
Hr.prototype._maxListeners = void 0;
var s5 = 10;
function Jm(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
Object.defineProperty(Hr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return s5;
  },
  set: function(n) {
    if (typeof n != "number" || n < 0 || jT(n))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
    s5 = n;
  }
});
Hr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Hr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || jT(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function GT(n) {
  return n._maxListeners === void 0 ? Hr.defaultMaxListeners : n._maxListeners;
}
Hr.prototype.getMaxListeners = function() {
  return GT(this);
};
Hr.prototype.emit = function(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);
  var i = e === "error", o = this._events;
  if (o !== void 0) i = i && o.error === void 0;
  else if (!i) return !1;
  if (i) {
    var c;
    if (t.length > 0 && (c = t[0]), c instanceof Error)
      throw c;
    var l = new Error("Unhandled error." + (c ? " (" + c.message + ")" : ""));
    throw l.context = c, l;
  }
  var _ = o[e];
  if (_ === void 0) return !1;
  if (typeof _ == "function")
    i5(_, this, t);
  else
    for (var b = _.length, w = XT(_, b), r = 0; r < b; ++r) i5(w[r], this, t);
  return !0;
};
function VT(n, e, t, r) {
  var i, o, c;
  if (Jm(t), o = n._events, o === void 0 ? (o = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (o.newListener !== void 0 && (n.emit("newListener", e, t.listener ? t.listener : t), o = n._events), c = o[e]), c === void 0)
    c = o[e] = t, ++n._eventsCount;
  else if (typeof c == "function" ? c = o[e] = r ? [t, c] : [c, t] : r ? c.unshift(t) : c.push(t), i = GT(n), i > 0 && c.length > i && !c.warned) {
    c.warned = !0;
    var l = new Error("Possible EventEmitter memory leak detected. " + c.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    l.name = "MaxListenersExceededWarning", l.emitter = n, l.type = e, l.count = c.length, yq(l);
  }
  return n;
}
Hr.prototype.addListener = function(e, t) {
  return VT(this, e, t, !1);
};
Hr.prototype.on = Hr.prototype.addListener;
Hr.prototype.prependListener = function(e, t) {
  return VT(this, e, t, !0);
};
function bq() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function qT(n, e, t) {
  var r = {
    fired: !1,
    wrapFn: void 0,
    target: n,
    type: e,
    listener: t
  }, i = bq.bind(r);
  return i.listener = t, r.wrapFn = i, i;
}
Hr.prototype.once = function(e, t) {
  return Jm(t), this.on(e, qT(this, e, t)), this;
};
Hr.prototype.prependOnceListener = function(e, t) {
  return Jm(t), this.prependListener(e, qT(this, e, t)), this;
};
Hr.prototype.removeListener = function(e, t) {
  var r, i, o, c, l;
  if (Jm(t), i = this._events, i === void 0) return this;
  if (r = i[e], r === void 0) return this;
  if (r === t || r.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || t));
  else if (typeof r != "function") {
    for (o = -1, c = r.length - 1; c >= 0; c--)
      if (r[c] === t || r[c].listener === t) {
        l = r[c].listener, o = c;
        break;
      }
    if (o < 0) return this;
    o === 0 ? r.shift() : vq(r, o), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, l || t);
  }
  return this;
};
Hr.prototype.off = Hr.prototype.removeListener;
Hr.prototype.removeAllListeners = function(e) {
  var t, r, i;
  if (r = this._events, r === void 0) return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[e]), this;
  if (arguments.length === 0) {
    var o = Object.keys(r), c;
    for (i = 0; i < o.length; ++i)
      c = o[i], c !== "removeListener" && this.removeAllListeners(c);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = r[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (i = t.length - 1; i >= 0; i--)
      this.removeListener(e, t[i]);
  return this;
};
function HT(n, e, t) {
  var r = n._events;
  if (r === void 0) return [];
  var i = r[e];
  return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? xq(i) : XT(i, i.length);
}
Hr.prototype.listeners = function(e) {
  return HT(this, e, !0);
};
Hr.prototype.rawListeners = function(e) {
  return HT(this, e, !1);
};
Hr.listenerCount = function(n, e) {
  return typeof n.listenerCount == "function" ? n.listenerCount(e) : WT.call(n, e);
};
Hr.prototype.listenerCount = WT;
function WT(n) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[n];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
Hr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? sm(this._events) : [];
};
function XT(n, e) {
  for (var t = new Array(e), r = 0; r < e; ++r) t[r] = n[r];
  return t;
}
function vq(n, e) {
  for (; e + 1 < n.length; e++) n[e] = n[e + 1];
  n.pop();
}
function xq(n) {
  for (var e = new Array(n.length), t = 0; t < e.length; ++t)
    e[t] = n[t].listener || n[t];
  return e;
}
function wq(n, e) {
  return new Promise(function(t, r) {
    function i(c) {
      n.removeListener(e, o), r(c);
    }
    function o() {
      typeof n.removeListener == "function" && n.removeListener("error", i), t([].slice.call(arguments));
    }
    $T(n, e, o, {
      once: !0
    }), e !== "error" && Aq(n, i, {
      once: !0
    });
  });
}
function Aq(n, e, t) {
  typeof n.on == "function" && $T(n, "error", e, t);
}
function $T(n, e, t, r) {
  if (typeof n.on == "function")
    r.once ? n.once(e, t) : n.on(e, t);
  else if (typeof n.addEventListener == "function")
    n.addEventListener(e, function i(o) {
      r.once && n.removeEventListener(e, i), t(o);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
}
var ZT = Fb.exports, Sq = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, Eq = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "לחפש",
  //hebrew
  ja: "サーチ",
  //japanese
  lv: "Meklēt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "Претрага",
  //serbian
  zh: "搜索",
  //chinese-simplified
  cs: "Vyhledávání",
  //czech
  hu: "Keresés",
  //hungarian
  ka: "ძიება",
  // georgian
  nb: "Søke",
  //norwegian
  sk: "Vyhľadávanie",
  //slovak
  th: "ค้นหา",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "수색",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "جستجو",
  //persian(aka farsi)
  ru: "Поиск"
  //russian
}, Tq = {
  placeholder: Eq
}, JT = { exports: {} };
(function(n) {
  (function(e, t, r) {
    n.exports ? n.exports = r() : e[t] = r();
  })(Pd, "subtag", function() {
    var e = "", t = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
    function r(_) {
      return _.match(t) || [];
    }
    function i(_) {
      return r(_).filter(function(b, w) {
        return b && w;
      });
    }
    function o(_) {
      return _ = r(_), {
        language: _[1] || e,
        extlang: _[2] || e,
        script: _[3] || e,
        region: _[4] || e
      };
    }
    function c(_, b, w) {
      Object.defineProperty(_, b, {
        value: w,
        enumerable: !0
      });
    }
    function l(_, b, w) {
      function T(I) {
        return r(I)[_] || e;
      }
      c(T, "pattern", b), c(o, w, T);
    }
    return l(1, /^[a-zA-Z]{2,3}$/, "language"), l(2, /^[a-zA-Z]{3}$/, "extlang"), l(3, /^[a-zA-Z]{4}$/, "script"), l(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), c(o, "split", i), o;
  });
})(JT);
var Cq = JT.exports, Iq = QV, Pq = _q, _a = NT, Lq = ZT.EventEmitter, o5 = Sq, Mq = Tq, Bq = Cq;
function YT(n, e) {
  this._eventEmitter = new Lq(), this.options = _a({}, this.options, e), this.inputString = "", this.fresh = !0, this.lastSelected = null, this.geocoderApi = n;
}
YT.prototype = {
  options: {
    zoom: 16,
    flyTo: !0,
    trackProximity: !0,
    showResultsWhileTyping: !1,
    minLength: 2,
    reverseGeocode: !1,
    limit: 5,
    enableEventLogging: !0,
    marker: !0,
    popup: !1,
    maplibregl: null,
    collapsed: !1,
    clearAndBlurOnEsc: !1,
    clearOnBlur: !1,
    getItemValue: function(n) {
      return n.text !== void 0 ? n.text : n.place_name;
    },
    render: function(n) {
      if (n.geometry) {
        var l = n.place_name.split(",");
        return '<div class="mapboxgl-ctrl-geocoder--result maplibregl-ctrl-geocoder--result"><svg class="mapboxgl-ctrl-geocoder--result-icon maplibre-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="mapboxgl-ctrl-geocoder--result-title maplibregl-ctrl-geocoder--result-title">' + l[0] + '</div><div class="mapboxgl-ctrl-geocoder--result-address maplibregl-ctrl-geocoder--result-address">' + l.splice(1, l.length).join(",") + "</div></div></div>";
      } else {
        var e = n.text, t = e.toLowerCase().indexOf(this.query.toLowerCase()), r = this.query.length, i = e.substring(0, t), o = e.substring(t, t + r), c = e.substring(t + r);
        return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibregl-ctrl-geocoder--suggestion"><svg class="mapboxgl-ctrl-geocoder--suggestion-icon maplibre-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="mapboxgl-ctrl-geocoder--suggestion-info maplibregl-ctrl-geocoder--suggestion-info"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibregl-ctrl-geocoder--suggestion-title">' + i + '<span class="mapboxgl-ctrl-geocoder--suggestion-match maplibregl-ctrl-geocoder--suggestion-match">' + o + "</span>" + c + "</div></div></div>";
      }
    },
    popupRender: function(n) {
      var e = n.place_name.split(",");
      return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibre-ctrl-geocoder--suggestion popup-suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibre-ctrl-geocoder--suggestion-title popup-suggestion-title">' + e[0] + '</div><div class="mapboxgl-ctrl-geocoder--suggestion-address maplibre-ctrl-geocoder--suggestion-address popup-suggestion-address">' + e.splice(1, e.length).join(",") + "</div></div>";
    },
    showResultMarkers: !0,
    debounceSearch: 200
  },
  /**
   * Add the geocoder to a container. The container can be either a `maplibregl.Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`maplibregl.Map`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   *
   * ```javascript
   * var GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * var geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param {String|HTMLElement|maplibregl.Map} container A reference to the container to which to add the geocoder
   */
  addTo: function(n) {
    function e(r, i) {
      if (!document.body.contains(i))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      var o = r.onAdd();
      i.appendChild(o);
    }
    if (n._controlContainer)
      n.addControl(this);
    else if (n instanceof HTMLElement)
      e(this, n);
    else if (typeof n == "string") {
      var t = document.querySelectorAll(n);
      if (t.length === 0)
        throw new Error("Element ", n, "not found.");
      if (t.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      e(this, t[0]);
    } else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  },
  onAdd: function(n) {
    if (n && typeof n != "string" && (this._map = n), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    var e = this.container = document.createElement("div");
    e.className = "mapboxgl-ctrl-geocoder mapboxgl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    var t = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "mapboxgl-ctrl-geocoder--input maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", Pq(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    var r = document.createElement("div");
    r.classList.add("mapboxgl-ctrl-geocoder--pin-right", "maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "mapboxgl-ctrl-geocoder--button maplibregl-ctrl-geocoder--button";
    var i = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(i), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), r.appendChild(this._clearEl), r.appendChild(this._loadingEl), e.appendChild(t), e.appendChild(this._inputEl), e.appendChild(r), this._typeahead = new Iq(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), e;
  },
  createIcon: function(n, e) {
    var t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (t.setAttribute("class", "mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-" + n + " maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + n), t.setAttribute("viewBox", "0 0 18 18"), t.setAttribute("xml:space", "preserve"), t.setAttribute("width", 18), t.setAttribute("height", 18), "innerHTML" in t)
      t.innerHTML = e;
    else {
      var r = document.createElement("div");
      r.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>";
      var i = r.firstChild, o = i.firstChild;
      t.appendChild(o);
    }
    return t;
  },
  onRemove: function() {
    return this.container.parentNode.removeChild(this.container), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  },
  _onPaste: function(n) {
    var e = (n.clipboardData || window.clipboardData).getData("text");
    e.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(e);
  },
  _onKeyDown: function(n) {
    var e = 27, t = 9;
    if (n.keyCode === e && this.options.clearAndBlurOnEsc)
      return this._clear(n), this._inputEl.blur();
    var r = n.target && n.target.shadowRoot ? n.target.shadowRoot.activeElement : n.target, i = r ? r.value : "";
    if (!i)
      return this.fresh = !0, n.keyCode !== t && this.clear(n), this._clearEl.style.display = "none";
    if (!(n.metaKey || [t, e, 37, 39, 38, 40].indexOf(n.keyCode) !== -1)) {
      if (n.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(r.value);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(r.value, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      r.value.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(r.value);
    }
  },
  _showButton: function() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  },
  _hideButton: function() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  },
  _onBlur: function(n) {
    this.options.clearOnBlur && this._clearOnBlur(n), this.options.collapsed && this._collapse();
  },
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange: function() {
    var n = this._typeahead.selected;
    if (n && !n.geometry)
      n.placeId ? this._geocode(n.placeId, !0, !0) : this._geocode(n.text, !0);
    else if (n && JSON.stringify(n) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        var e;
        if (this._removeResultMarkers(), n.properties && o5[n.properties.short_code])
          e = _a({}, this.options.flyTo), this._map && this._map.fitBounds(o5[n.properties.short_code].bbox, e);
        else if (n.bbox) {
          var t = n.bbox;
          e = _a({}, this.options.flyTo), this._map && this._map.fitBounds([[t[0], t[1]], [t[2], t[3]]], e);
        } else {
          var r = {
            zoom: this.options.zoom
          };
          e = _a({}, r, this.options.flyTo), n.center ? e.center = n.center : n.geometry && n.geometry.type && n.geometry.type === "Point" && n.geometry.coordinates && (e.center = n.geometry.coordinates), this._map && this._map.flyTo(e);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(n), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(n), this._typeahead.selected = null, this._eventEmitter.emit("result", {
        result: n
      });
    }
  },
  _getConfigForRequest: function() {
    var n = ["bbox", "limit", "proximity", "countries", "types", "language", "reverseMode"], e = this, t = n.reduce(function(r, i) {
      return e.options[i] && (["countries", "types", "language"].indexOf(i) > -1 ? r[i] = e.options[i].split(/[\s,]+/) : r[i] = e.options[i], i === "proximity" && e.options[i] && typeof e.options[i].longitude == "number" && typeof e.options[i].latitude == "number" && (r[i] = [e.options[i].longitude, e.options[i].latitude])), r;
    }, {});
    return t;
  },
  _geocode: function(n, e, t) {
    this._loadingEl.style.display = "block", this._eventEmitter.emit("loading", {
      query: n
    }), this.inputString = n;
    var r = null, i = this._getConfigForRequest(), o;
    if (this.options.localGeocoderOnly)
      o = Promise.resolve();
    else if (this.options.reverseGeocode && /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/.test(n)) {
      var c = n.split(/[\s(,)?]+/).map(function(b) {
        return parseFloat(b, 10);
      }).reverse();
      i.types && i.types[0], i = _a(i, {
        query: c,
        limit: 1
      }), "proximity" in i && delete i.proximity, o = this.geocoderApi.reverseGeocode(i);
    } else
      i = _a(i, {
        query: n
      }), this.geocoderApi.getSuggestions ? e ? this.geocoderApi.searchByPlaceId && t ? o = this.geocoderApi.searchByPlaceId(i) : o = this.geocoderApi.forwardGeocode(i) : o = this.geocoderApi.getSuggestions(i) : o = this.geocoderApi.forwardGeocode(i);
    var l = [];
    this.options.localGeocoder && (l = this.options.localGeocoder(n), l || (l = []));
    var _ = [];
    return o.catch((function(b) {
      r = b;
    }).bind(this)).then((function(b) {
      this._loadingEl.style.display = "none";
      var w = {};
      return b ? w = b : w = {
        type: "FeatureCollection",
        features: []
      }, w.config = i, this.fresh && (this.fresh = !1), w.features = w.features ? l.concat(w.features) : l, this.options.externalGeocoder ? (_ = this.options.externalGeocoder(n, w.features, i) || [], _.then(function(T) {
        return w.features = w.features ? T.concat(w.features) : T, w;
      }, function() {
        return w;
      })) : w;
    }).bind(this)).then((function(b) {
      if (r)
        throw r;
      this.options.filter && b.features.length && (b.features = b.features.filter(this.options.filter));
      var w = [];
      b.suggestions ? w = b.suggestions : b.place ? w = [b.place] : w = b.features, w.length ? (this._clearEl.style.display = "block", this._typeahead.update(w), (!this.options.showResultsWhileTyping || e) && this.options.showResultMarkers && (b.features.length > 0 || b.place) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", b)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", b));
    }).bind(this)).catch((function(b) {
      this._loadingEl.style.display = "none", l.length && this.options.localGeocoder || _.length && this.options.externalGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(l)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", {
        features: l
      }), this._eventEmitter.emit("error", {
        error: b
      });
    }).bind(this)), o;
  },
  /**
   * Shared logic for clearing input
   * @param {Event} [ev] the event that triggered the clear, if available
   * @private
   *
   */
  _clear: function(n) {
    n && n.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  },
  /**
   * Clear and then focus the input.
   * @param {Event} [ev] the event that triggered the clear, if available
   *
   */
  clear: function(n) {
    this._clear(n), this._inputEl.focus();
  },
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param {Event} [ev] the blur event
   * @private
   */
  _clearOnBlur: function(n) {
    var e = this;
    n.relatedTarget && e._clear(n);
  },
  _onQueryResult: function(n) {
    var e = n;
    if (e.features.length) {
      var t = e.features[0];
      this._typeahead.selected = t, this._inputEl.value = t.place_name, this._onChange();
    }
  },
  _updateProximity: function() {
    if (this._map)
      if (this._map.getZoom() > 9) {
        var n = this._map.getCenter().wrap();
        this.setProximity({
          longitude: n.lng,
          latitude: n.lat
        });
      } else
        this.setProximity(null);
  },
  _collapse: function() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("mapboxgl-ctrl-geocoder--collapsed", "maplibregl-ctrl-geocoder--collapsed");
  },
  _unCollapse: function() {
    this.container.classList.remove("mapboxgl-ctrl-geocoder--collapsed", "maplibregl-ctrl-geocoder--collapsed");
  },
  /**
   * Set & query the input
   * @param {string} searchInput location name or other search input
   * @returns {MaplibreGeocoder} this
   */
  query: function(n) {
    return this._geocode(n).then(this._onQueryResult), this;
  },
  _renderError: function() {
    var n = "<div class='mapbox-gl-geocoder--error maplibre-gl-geocoder--error'>There was an error reaching the server</div>";
    this._renderMessage(n);
  },
  _renderNoResults: function() {
    var n = "<div class='mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>No results found</div>";
    this._renderMessage(n);
  },
  _renderMessage: function(n) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(n);
  },
  /**
   * Get the text to use as the search bar placeholder
   *
   * If placeholder is provided in options, then use options.placeholder
   * Otherwise, if language is provided in options, then use the localized string of the first language if available
   * Otherwise use the default
   *
   * @returns {String} the value to use as the search bar placeholder
   * @private
   */
  _getPlaceholderText: function() {
    if (this.options.placeholder) return this.options.placeholder;
    if (this.options.language) {
      var n = this.options.language.split(",")[0], e = Bq.language(n), t = Mq.placeholder[e];
      if (t) return t;
    }
    return "Search";
  },
  /**
   * Fits the map to the current bounds for the searched results
   *
   * @returns {MaplibreGeocoder} this
   * @private
   */
  _fitBoundsForMarkers: function() {
    if (!(this._typeahead.data.length < 1)) {
      var n = this._typeahead.data.filter(function(i) {
        return typeof i != "string";
      }).slice(0, this.options.limit);
      if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
        var e = {
          padding: 100
        }, t = _a({}, e, this.options.flyTo), r = new this._maplibregl.LngLatBounds();
        n.forEach(function(i) {
          r.extend(i.geometry.coordinates);
        }), this._map.fitBounds(r.toArray(), t);
      }
      return n.length > 0 && this._maplibregl && this._handleResultMarkers(n), this;
    }
  },
  /**
   * Set input
   * @param {string} searchInput location name or other search input
   * @returns {MaplibreGeocoder} this
   */
  setInput: function(n) {
    return this._inputEl.value = n, this._typeahead.selected = null, this._typeahead.clear(), n.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(n), this;
  },
  /**
   * Set proximity
   * @param {Object} proximity The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   * @returns {MaplibreGeocoder} this
   */
  setProximity: function(n) {
    return this.options.proximity = n, this;
  },
  /**
   * Get proximity
   * @returns {Object} The geocoder proximity
   */
  getProximity: function() {
    return this.options.proximity;
  },
  /**
   * Set the render function used in the results dropdown
   * @param {Function} fn The function to use as a render function. This function accepts a single [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) object as input and returns a string.
   * @returns {MaplibreGeocoder} this
   */
  setRenderFunction: function(n) {
    return n && typeof n == "function" && (this._typeahead.render = n), this;
  },
  /**
   * Get the function used to render the results dropdown
   *
   * @returns {Function} the render function
   */
  getRenderFunction: function() {
    return this._typeahead.render;
  },
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param {String} language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   * @returns {MaplibreGeocoder} this
   */
  setLanguage: function(n) {
    var e = navigator.language || navigator.userLanguage || navigator.browserLanguage;
    return this.options.language = n || this.options.language || e, this;
  },
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns {String} The language(s) used by the plugin, if any
   */
  getLanguage: function() {
    return this.options.language;
  },
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns {Number} the map zoom
   */
  getZoom: function() {
    return this.options.zoom;
  },
  /**
   * Set the zoom level
   * @param {Number} zoom The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns {MaplibreGeocoder} this
   */
  setZoom: function(n) {
    return this.options.zoom = n, this;
  },
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns {Boolean|Object} The `flyTo` option
   */
  getFlyTo: function() {
    return this.options.flyTo;
  },
  /**
   * Set the flyTo options
   * @param {Boolean|Object} flyTo If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo: function(n) {
    return this.options.flyTo = n, this;
  },
  /**
   * Get the value of the placeholder string
   * @returns {String} The input element's placeholder value
   */
  getPlaceholder: function() {
    return this.options.placeholder;
  },
  /**
   * Set the value of the input element's placeholder
   * @param {String} placeholder the text to use as the input element's placeholder
   * @returns {MaplibreGeocoder} this
   */
  setPlaceholder: function(n) {
    return this.placeholder = n || this._getPlaceholderText(), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  },
  /**
   * Get the bounding box used by the plugin
   * @returns {Array<Number>} the bounding box, if any
   */
  getBbox: function() {
    return this.options.bbox;
  },
  /**
   * Set the bounding box to limit search results to
   * @param {Array<Number>} bbox a bounding box given as an array in the format [minX, minY, maxX, maxY].
   * @returns {MaplibreGeocoder} this
   */
  setBbox: function(n) {
    return this.options.bbox = n, this;
  },
  /**
   * Get a list of the countries to limit search results to
   * @returns {String} a comma separated list of countries to limit to, if any
   */
  getCountries: function() {
    return this.options.countries;
  },
  /**
   * Set the countries to limit search results to
   * @param {String} countries a comma separated list of countries to limit to
   * @returns {MaplibreGeocoder} this
   */
  setCountries: function(n) {
    return this.options.countries = n, this;
  },
  /**
   * Get a list of the types to limit search results to
   * @returns {String} a comma separated list of types to limit to
   */
  getTypes: function() {
    return this.options.types;
  },
  /**
   * Set the types to limit search results to
   * @param {String} countries a comma separated list of types to limit to
   * @returns {MaplibreGeocoder} this
   */
  setTypes: function(n) {
    return this.options.types = n, this;
  },
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns {Number} The minimum length in characters before a search is triggered
   */
  getMinLength: function() {
    return this.options.minLength;
  },
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param {Number} minLength the minimum length in characters
   * @returns {MaplibreGeocoder} this
   */
  setMinLength: function(n) {
    return this.options.minLength = n, this._typeahead && (this._typeahead.options.minLength = n), this;
  },
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns {Number} The limit value for the number of results to display used by the plugin
   */
  getLimit: function() {
    return this.options.limit;
  },
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param {Number} limit the number of search results to return
   * @returns {MaplibreGeocoder}
   */
  setLimit: function(n) {
    return this.options.limit = n, this._typeahead && (this._typeahead.options.limit = n), this;
  },
  /**
   * Get the filter function used by the plugin
   * @returns {Function} the filter function
   */
  getFilter: function() {
    return this.options.filter;
  },
  /**
   * Set the filter function used by the plugin.
   * @param {Function} filter A function which accepts a Feature in the [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   * @returns {MaplibreGeocoder} this
   */
  setFilter: function(n) {
    return this.options.filter = n, this;
  },
  /**
   * Set the geocoding api used by the plugin.
   * @param {Object} geocoderApi An API which contains reverseGeocode and forwardGeocode functions to be used by this plugin
   * @param {Function} geocoderApi.forwardGeocode Forward geocode function should return an object including a collection of Features in [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format
   * @param {Object} geocoderApi.forwardGeocode.config Query parameters
   * @param {String} geocoderApi.forwardGeocode.config.query Search query string
   * @param {Number} geocoderApi.forwardGeocode.config.limit Number of results to limit by
   * @param {Array} geocoderApi.forwardGeocode.config.bbox a bounding box given as an array in the format `[minX, minY, maxX, maxY]`. Search results will be limited to the bounding box.
   * @param {Object} geocoderApi.forwardGeocode.config.proximity a geographical point given as an object with `latitude` and `longitude` properties. Search results closer to this point will be given higher priority.
   * @param {Array} geocoderApi.forwardGeocode.config.countries a comma separated list of country codes to limit results to specified country or countries.
   * @param {Array} geocoderApi.forwardGeocode.config.types a comma seperated list of types that filter results to match those specified. See https://docs.mapbox.com/api/search/#data-types for available types. If reverseGeocode is enabled, you should specify one type. If you configure more than one type, the first type will be used.
   * @param {String} geocoderApi.forwardGeocode.config.language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas. Defaults to the browser's language settings.
   * @param {distance|score} geocoderApi.forwardGeocode.config.reverseMode Set the factors that are used to sort nearby results.
   *
   * @param {Function} geocoderApi.reverseGeocode Reverse geocode function should return an object including a collection of Features in [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format
   * @param {Object} geocoderApi.reverseGeocode.config Query parameters
   * @param {Object} geocoderApi.reverseGeocode.config.query Search query coordinates
   * @param {Number} geocoderApi.reverseGeocode.config.limit Number of results to limit by
   * @param {Array} geocoderApi.reverseGeocode.config.bbox a bounding box given as an array in the format `[minX, minY, maxX, maxY]`. Search results will be limited to the bounding box.
   * @param {Object} geocoderApi.reverseGeocode.config.proximity a geographical point given as an object with `latitude` and `longitude` properties. Search results closer to this point will be given higher priority.
   * @param {Array} geocoderApi.reverseGeocode.config.countries a comma separated list of country codes to limit results to specified country or countries.
   * @param {Array} geocoderApi.reverseGeocode.config.types a comma seperated list of types that filter results to match those specified. See https://docs.mapbox.com/api/search/#data-types for available types. If reverseGeocode is enabled, you should specify one type. If you configure more than one type, the first type will be used.
   * @param {String} geocoderApi.reverseGeocode.config.language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas. Defaults to the browser's language settings.
   * @param {distance|score} geocoderApi.reverseGeocode.config.reverseMode Set the factors that are used to sort nearby results.
   * @returns {MaplibreGeocoder} this
   */
  setGeocoderApi: function(n) {
    return this.geocoderApi = n, this;
  },
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns {Object} the geocoding API
   */
  getGeocoderApi: function() {
    return this.geocoderApi;
  },
  /**
   * Handle the placement of a result marking the selected result
   * @private
   * @param {Object} selected the selected geojson feature
   * @returns {MaplibreGeocoder} this
   */
  _handleMarker: function(n) {
    if (this._map) {
      this._removeMarker();
      var e = {
        color: "#4668F2"
      }, t = _a({}, e, this.options.marker);
      this.mapMarker = new this._maplibregl.Marker(t);
      var r;
      if (this.options.popup) {
        var i = {}, o = _a({}, i, this.options.popup);
        r = new this._maplibregl.Popup(o).setHTML(this.options.popupRender(n));
      }
      return n.center ? (this.mapMarker.setLngLat(n.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(r)) : n.geometry && n.geometry.type && n.geometry.type === "Point" && n.geometry.coordinates && (this.mapMarker.setLngLat(n.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(r)), this;
    }
  },
  /**
   * Handle the removal of a result marker
   * @private
   */
  _removeMarker: function() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  },
  /**
   * Handle the placement of a result marking the selected result
   * @private
   * @param {Object[]} results the top results to display on the map
   * @returns {MaplibreGeocoder} this
   */
  _handleResultMarkers: function(n) {
    if (this._map) {
      this._removeResultMarkers();
      var e = {
        color: "#4668F2"
      }, t = _a({}, e, this.options.showResultMarkers);
      return n.forEach((function(r) {
        if (this.options.showResultMarkers && this.options.showResultMarkers.element) {
          var i = this.options.showResultMarkers.element.cloneNode(!0);
          t = _a(t, {
            element: i
          });
        }
        var o = new this._maplibregl.Marker(_a({}, t, {
          element: i
        })), c;
        if (this.options.popup) {
          var l = {}, _ = _a({}, l, this.options.popup);
          c = new this._maplibregl.Popup(_).setHTML(this.options.popupRender(r));
        }
        r.center ? (o.setLngLat(r.center).addTo(this._map), this.options.popup && o.setPopup(c)) : r.geometry && r.geometry.type && r.geometry.type === "Point" && r.geometry.coordinates && (o.setLngLat(r.geometry.coordinates).addTo(this._map), this.options.popup && o.setPopup(c)), this.resultMarkers.push(o);
      }).bind(this)), this;
    }
  },
  /**
   * Handle the removal of a result marker
   * @private
   */
  _removeResultMarkers: function() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(n) {
      n.remove();
    }), this.resultMarkers = []);
  },
  /**
   * Subscribe to events that happen within the plugin.
   * @param {String} type name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param {Function} fn function that's called when the event is emitted.
   * @returns {MaplibreGeocoder} this;
   */
  on: function(n, e) {
    return this._eventEmitter.on(n, e), this;
  },
  /**
   * Remove an event
   * @returns {MaplibreGeocoder} this
   * @param {String} type Event name.
   * @param {Function} fn Function that should unsubscribe to the event emitted.
   */
  off: function(n, e) {
    return this._eventEmitter.removeListener(n, e), this;
  }
};
var Rq = YT;
const Oq = /* @__PURE__ */ Ip(Rq), Dq = {
  limitsUrl: "https://tilemaps.icgc.cat/vt/limits-tilejsonV3.json",
  geocoder: {
    peliasUrl1: "https://eines.icgc.cat/geocodificador/autocompletar?text=",
    peliasUrl2: "&layers=topo1%2Ctopo2%2Caddress&size=5"
  },
  mapOptions: {
    container: "map",
    center: {
      0: 1.537786,
      1: 41.837539
    },
    zoom: 7.5,
    bearing: 0,
    pitch: 0,
    hash: !1,
    style: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json.json",
    maxZoom: 18,
    maxPitch: 85
  },
  logoIcgcOptions: {
    logoUrlColor: "https://eines.icgc.cat/recursos/logos/icgc_logo_color.png",
    logoUrlWhite: "https://eines.icgc.cat/recursos/logos/icgc_logo_blanc.svg",
    logoLink: "https://www.icgc.cat",
    logoTitle: "Institut Cartogràfic i Geològic de Catalunya",
    logoWidth: 100,
    logoOpacity: 0.6
  },
  logoGencatOptions: {
    logoUrlColor: "https://eines.icgc.cat/recursos/logos/gencat_logo_color.png",
    logoUrlWhite: "https://eines.icgc.cat/recursos/logos/gencat_logo_blanc.png",
    logoLink: "https://web.gencat.cat/",
    logoTitle: "Generalitat de Catalunya",
    logoWidth: 100,
    logoOpacity: 0.6
  },
  map3dOptions: {
    spaceErrorFactor: 2,
    exaggeration: 1,
    zfactor: 48,
    minZoomRange: 15.5,
    maxZoomRange: 22,
    urlTilesetCities: "https://geoserveis.icgc.cat/servei/catalunya/ciutats/3dtiles/v1/tilesetV1.0.json",
    layerIdOrder: "place-isolated",
    sourceLayerFilterId: "place",
    minZoomFilter: 14,
    layerId3d: "edificisMapboxLayer",
    terrainSource: "ICGC5M",
    style3dName: "orto3d",
    imageIcon: "https://eines.icgc.cat/recursos//images/stick.png"
  },
  baseStyles: [
    {
      key: "TOPO",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_estandard.png"
    },
    {
      key: "ORTO",
      url: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"
    },
    {
      key: "ORTO3D",
      url: "https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"
    },
    {
      key: "ORTOHYBRID",
      url: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_hibrida.png"
    },
    {
      key: "ADMIN",
      url: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_delimitacio_limits_administratius.png"
    },
    {
      key: "DARK",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_fosc.png"
    },
    {
      key: "LIGHT",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_gris.png"
    },
    {
      key: "GEOLOGY",
      url: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_geologic_informacio.png"
    },
    {
      key: "RASTER",
      substyles: {
        TOPO: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo.jpg"
        },
        ADMIN: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_administratiu.jpg"
        },
        LIGHT: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo_gris.jpg"
        },
        STANDARD: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_estandard_0.jpg"
        },
        Simplified: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_simplificat.jpg"
        },
        ORTO: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto.jpg"
        },
        ORTOGREY: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_gris.jpg"
        },
        ORTOHYBRID: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_hibida.jpg"
        }
      }
    }
  ],
  urlTerrainICGC: [
    {
      name: "ICGC5M",
      url: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png"
    },
    {
      name: "WORLD30M",
      url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png",
      encoding: "terrarium"
    }
  ],
  ortoLayersICGC: [
    {
      name: "ortofotoColorProvisional",
      key: "ortofoto_color_provisional",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional"
    },
    {
      name: "ortofotoColor2023",
      key: "ortofoto_color_2023",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023"
    },
    {
      name: "ortofotoColor2022",
      key: "ortofoto_color_2022",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022"
    },
    {
      name: "ortofotoColor2021",
      key: "ortofoto_color_2021",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021"
    },
    {
      name: "ortofotoColor2020",
      key: "ortofoto_color_2020",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020"
    },
    {
      name: "ortofotoColor2019",
      key: "ortofoto_color_2019",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019"
    },
    {
      name: "ortofotoColor2018",
      key: "ortofoto_color_2018",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018"
    },
    {
      name: "ortofotoColor2017",
      key: "ortofoto_color_2017",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017"
    },
    {
      name: "ortofotoColor2016",
      key: "ortofoto_color_2016",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016"
    },
    {
      name: "ortofotoColor2015",
      key: "ortofoto_color_2015",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015"
    },
    {
      name: "ortofotoColor2014",
      key: "ortofoto_color_2014",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014"
    },
    {
      name: "ortofotoColor2013",
      key: "ortofoto_color_2013",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013"
    },
    {
      name: "ortofotoColor2012",
      key: "ortofoto_color_2012",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012"
    },
    {
      name: "ortofotoColor2011",
      key: "ortofoto_color_2011",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011"
    },
    {
      name: "ortofotoColor2010",
      key: "ortofoto_color_2010",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010"
    },
    {
      name: "ortofotoColor2009",
      key: "ortofoto_color_2009",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009"
    },
    {
      name: "ortofotoColor2008",
      key: "ortofoto_color_2008",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008"
    },
    {
      name: "ortofotoColor20062007",
      key: "ortofoto_color_2006-2007",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007"
    },
    {
      name: "ortofotoColor20042005",
      key: "ortofoto_color_2004-2005",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005"
    },
    {
      name: "ortofotoColor20002003",
      key: "ortofoto_color_2000-2003",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003"
    },
    {
      name: "ortofotoBlancINegre1998",
      key: "ortofoto_blanc_i_negre_1998",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998"
    },
    {
      name: "ortofotoBlancINegre19941997",
      key: "ortofoto_blanc_i_negre_1994-1997",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997"
    },
    {
      name: "ortofotoColor1993",
      key: "ortofoto_color_1993",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993"
    },
    {
      name: "ortofotoBlancINegre19831992",
      key: "ortofoto_blanc_i_negre_1983-1992",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992"
    },
    {
      name: "ortofotoBlancINegre19701977",
      key: "ortofoto_blanc_i_negre_1970-1977",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977"
    },
    {
      name: "ortofotoBlancINegre1956",
      key: "ortofoto_blanc_i_negre_1956",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956"
    },
    {
      name: "ortofotoBlancINegre1945",
      key: "ortofoto_blanc_i_negre_1945",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945"
    },
    {
      name: "ortofotoColorSerieAnual",
      key: "ortofoto_color_serie_anual",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual"
    },
    {
      name: "ortofotoInfraroigProvisional",
      key: "ortofoto_infraroig_provisional",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional"
    },
    {
      name: "ortofotoInfraroig2023",
      key: "ortofoto_infraroig_2023",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023"
    },
    {
      name: "ortofotoInfraroig2022",
      key: "ortofoto_infraroig_2022",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022"
    },
    {
      name: "ortofotoInfraroig2021",
      key: "ortofoto_infraroig_2021",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021"
    },
    {
      name: "ortofotoInfraroig2020",
      key: "ortofoto_infraroig_2020",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020"
    },
    {
      name: "ortofotoInfraroig2019",
      key: "ortofoto_infraroig_2019",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019"
    },
    {
      name: "ortofotoInfraroig2018",
      key: "ortofoto_infraroig_2018",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018"
    },
    {
      name: "ortofotoInfraroig2017",
      key: "ortofoto_infraroig_2017",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017"
    },
    {
      name: "ortofotoInfraroig2016",
      key: "ortofoto_infraroig_2016",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016"
    },
    {
      name: "ortofotoInfraroig2015",
      key: "ortofoto_infraroig_2015",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015"
    },
    {
      name: "ortofotoInfraroig2014",
      key: "ortofoto_infraroig_2014",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014"
    },
    {
      name: "ortofotoInfraroig2013",
      key: "ortofoto_infraroig_2013",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013"
    },
    {
      name: "ortofotoInfraroig2012",
      key: "ortofoto_infraroig_2012",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012"
    },
    {
      name: "ortofotoInfraroig2011",
      key: "ortofoto_infraroig_2011",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011"
    },
    {
      name: "ortofotoInfraroig2010",
      key: "ortofoto_infraroig_2010",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010"
    },
    {
      name: "ortofotoInfraroig2009",
      key: "ortofoto_infraroig_2009",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009"
    },
    {
      name: "ortofotoInfraroig2008",
      key: "ortofoto_infraroig_2008",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008"
    },
    {
      name: "ortofotoInfraroig20062007",
      key: "ortofoto_infraroig_2006-2007",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007"
    },
    {
      name: "ortofotoInfraroig19961997",
      key: "ortofoto_infraroig_1996-1997",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997"
    },
    {
      name: "ortofotoInfraroigSerieAnual",
      key: "ortofoto_infraroig_serie_anual",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"
    }
  ],
  vectorLayersICGC: [
    {
      name: "agrupacionsCensals2015",
      key: "agrupacions_censals_2015"
    },
    {
      name: "agrupacionsCensals2016",
      key: "agrupacions_censals_2016"
    },
    {
      name: "agrupacionsCensals2017",
      key: "agrupacions_censals_2017"
    },
    {
      name: "agrupacionsCensals2018",
      key: "agrupacions_censals_2018"
    },
    {
      name: "agrupacionsCensals2019",
      key: "agrupacions_censals_2019"
    },
    {
      name: "agrupacionsCensals2020",
      key: "agrupacions_censals_2020"
    },
    {
      name: "agrupacionsCensals2021",
      key: "agrupacions_censals_2021"
    },
    {
      name: "agrupacionsCensalsVigent",
      key: "agrupacions_censals_vigent"
    },
    {
      name: "agrupacionsCensalsVigentText",
      key: "agrupacions_censals_vigent_text"
    },
    {
      name: "areesBasiquesPolicials2019",
      key: "arees_basiques_policials_2019"
    },
    {
      name: "areesBasiquesPolicials2020",
      key: "arees_basiques_policials_2020"
    },
    {
      name: "areesBasiquesPolicials2022",
      key: "arees_basiques_policials_2022"
    },
    {
      name: "areesBasiquesPolicialsVigent",
      key: "arees_basiques_policials_vigent"
    },
    {
      name: "areesBasiquesPolicialsVigentText",
      key: "arees_basiques_policials_vigent_text"
    },
    {
      name: "areesBasiquesSalutVigent",
      key: "arees_basiques_salut_vigent"
    },
    {
      name: "areesBasiquesServeisSocialsVigent",
      key: "arees_basiques_serveis_socials_vigent"
    },
    {
      name: "areesBasiquesServeisSocialsVigentText",
      key: "arees_basiques_serveis_socials_vigent_text"
    },
    {
      name: "areesGestioAssistencialVigent",
      key: "arees_gestio_assistencial_vigent"
    },
    {
      name: "areesHidrogeologiquesAquifersVigent",
      key: "arees_hidrogeologiques_aquifers_vigent"
    },
    {
      name: "catalunyaVigent",
      key: "catalunya_vigent"
    },
    {
      name: "catalunyaVigentText",
      key: "catalunya_vigent_text"
    },
    {
      name: "comarques2022",
      key: "comarques_2022"
    },
    {
      name: "comarquesVigent",
      key: "comarques_vigent"
    },
    {
      name: "comarquesVigentText",
      key: "comarques_vigent_text"
    },
    {
      name: "districtesCensals2015",
      key: "districtes_censals_2015"
    },
    {
      name: "districtesCensals2016",
      key: "districtes_censals_2016"
    },
    {
      name: "districtesCensals2017",
      key: "districtes_censals_2017"
    },
    {
      name: "districtesCensals2018",
      key: "districtes_censals_2018"
    },
    {
      name: "districtesCensals2019",
      key: "districtes_censals_2019"
    },
    {
      name: "districtesCensals2020",
      key: "districtes_censals_2020"
    },
    {
      name: "districtesCensals2021",
      key: "districtes_censals_2021"
    },
    {
      name: "districtesCensals2022",
      key: "districtes_censals_2022"
    },
    {
      name: "districtesCensals2023",
      key: "districtes_censals_2023"
    },
    {
      name: "districtesCensalsVigent",
      key: "districtes_censals_vigent"
    },
    {
      name: "districtesCensalsVigentText",
      key: "districtes_censals_vigent_text"
    },
    {
      name: "incendisForestalsVigent",
      key: "incendis_forestals_vigent"
    },
    {
      name: "incendisForestalsVigentText",
      key: "incendis_forestals_vigent_text"
    },
    {
      name: "municipis2022",
      key: "municipis_2022"
    },
    {
      name: "municipis2022Text",
      key: "municipis_2022_text"
    },
    {
      name: "municipisVigent",
      key: "municipis_vigent"
    },
    {
      name: "municipisVigentText",
      key: "municipis_vigent_text"
    },
    {
      name: "partitsJudicialsVigent",
      key: "partits_judicials_vigent"
    },
    {
      name: "partitsJudicialsVigentText",
      key: "partits_judicials_vigent_text"
    },
    {
      name: "plaTerritorial2015",
      key: "pla_territorial_2015"
    },
    {
      name: "plaTerritorialVigent",
      key: "pla_territorial_vigent"
    },
    {
      name: "plaTerritorialVigentText",
      key: "pla_territorial_vigent_text"
    },
    {
      name: "provinciesVigent",
      key: "provincies_vigent"
    },
    {
      name: "provinciesVigentText",
      key: "provincies_vigent_text"
    },
    {
      name: "regionsPolicialsVigent",
      key: "regions_policials_vigent"
    },
    {
      name: "regionsPolicialsVigentText",
      key: "regions_policials_vigent_text"
    },
    {
      name: "regionsSanitariesVigent",
      key: "regions_sanitaries_vigent"
    },
    {
      name: "regionsSanitariesVigentText",
      key: "regions_sanitaries_vigent_text"
    },
    {
      name: "seccionsCensals2015",
      key: "seccions_censals_2015"
    },
    {
      name: "seccionsCensals2016",
      key: "seccions_censals_2016"
    },
    {
      name: "seccionsCensals2017",
      key: "seccions_censals_2017"
    },
    {
      name: "seccionsCensals2018",
      key: "seccions_censals_2018"
    },
    {
      name: "seccionsCensals2019",
      key: "seccions_censals_2019"
    },
    {
      name: "seccionsCensals2020",
      key: "seccions_censals_2020"
    },
    {
      name: "seccionsCensals2021",
      key: "seccions_censals_2021"
    },
    {
      name: "seccionsCensals2022",
      key: "seccions_censals_2022"
    },
    {
      name: "seccionsCensals2023",
      key: "seccions_censals_2023"
    },
    {
      name: "seccionsCensalsVigent",
      key: "seccions_censals_vigent"
    },
    {
      name: "seccionsCensalsVigentText",
      key: "seccions_censals_vigent_text"
    },
    {
      name: "sectorsSanitarisVigent",
      key: "sectors_sanitaris_vigent"
    },
    {
      name: "vegueriesVigent",
      key: "vegueries_vigent"
    },
    {
      name: "vegueriesVigentText",
      key: "vegueries_vigent_text"
    }
  ],
  vectorLayers: [
    {
      key: "cobertes2018",
      url: "https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json",
      legend: "https://eines.icgc.cat/recursos//images/llegendaCobertesSol2018.jpg"
    }
  ],
  wmsLayers: [
    {
      key: "espaisInteresGeologic",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "gravimetriaBouguer500000",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "cobertesSol2018",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "administratiu",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png"
    },
    {
      key: "simplificat",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png"
    },
    {
      key: "cims",
      layer: "",
      url: "https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455"
    },
    {
      key: "cobertesSol",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"
    }
  ],
  fgbLayers: [
    {
      name: "agrupacionsCensalsVigent",
      key: "agrupacions_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb"
    },
    {
      name: "agrupacionsCensalsVigentText",
      key: "agrupacions_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb"
    },
    {
      name: "areesBasiquesPolicialsVigent",
      key: "arees_basiques_policials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb"
    },
    {
      name: "areesBasiquesPolicialsVigentText",
      key: "arees_basiques_policials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb"
    },
    {
      name: "areesBasiquesSalutVigent",
      key: "arees_basiques_salut_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb"
    },
    {
      name: "areesBasiquesServeisSocialsVigent",
      key: "arees_basiques_serveis_socials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb"
    },
    {
      name: "areesBasiquesServeisSocialsVigentText",
      key: "arees_basiques_serveis_socials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb"
    },
    {
      name: "areesGestioAssistencialVigent",
      key: "arees_gestio_assistencial_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb"
    },
    {
      name: "areesHidrogeologiquesAquifersVigent",
      key: "arees_hidrogeologiques_aquifers_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb"
    },
    {
      name: "catalunyaVigent",
      key: "catalunya_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb"
    },
    {
      name: "catalunyaVigentText",
      key: "catalunya_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb"
    },
    {
      name: "comarquesVigent",
      key: "comarques_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb"
    },
    {
      name: "comarquesVigentText",
      key: "comarques_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb"
    },
    {
      name: "districtesCensalsVigent",
      key: "districtes_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb"
    },
    {
      name: "districtesCensalsVigentText",
      key: "districtes_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb"
    },
    {
      name: "incendisForestalsVigent",
      key: "incendis_forestals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb"
    },
    {
      name: "incendisForestalsVigentText",
      key: "incendis_forestals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb"
    },
    {
      name: "municipisVigent",
      key: "municipis_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb"
    },
    {
      name: "municipisVigentText",
      key: "municipis_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb"
    },
    {
      name: "partitsJudicialsVigent",
      key: "partits_judicials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb"
    },
    {
      name: "partitsJudicialsVigentText",
      key: "partits_judicials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb"
    },
    {
      name: "plaTerritorialVigent",
      key: "pla_territorial_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb"
    },
    {
      name: "plaTerritorialVigentText",
      key: "pla_territorial_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb"
    },
    {
      name: "provinciesVigent",
      key: "provincies_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb"
    },
    {
      name: "provinciesVigentText",
      key: "provincies_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb"
    },
    {
      name: "regionsPolicialsVigent",
      key: "regions_policials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb"
    },
    {
      name: "regionsPolicialsVigentText",
      key: "regions_policials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb"
    },
    {
      name: "regionsSanitariesVigent",
      key: "regions_sanitaries_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb"
    },
    {
      name: "regionsSanitariesVigentText",
      key: "regions_sanitaries_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb"
    },
    {
      name: "seccionsCensalsVigent",
      key: "seccions_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb"
    },
    {
      name: "seccionsCensalsVigentText",
      key: "seccions_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb"
    },
    {
      name: "sectorsSanitarisVigent",
      key: "sectors_sanitaris_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb"
    },
    {
      name: "vegueriesVigent",
      key: "vegueries_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb"
    },
    {
      name: "vegueriesVigentText",
      key: "vegueries_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"
    }
  ]
}, Fq = {
  TOPO: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json",
  ORTO: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json",
  ORTO3D: "https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json",
  ORTOHYBRID: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json",
  ADMIN: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json",
  DARK: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json",
  LIGHT: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json",
  GEOLOGY: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json",
  RASTER: {
    TOPO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png",
    ADMIN: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png",
    LIGHT: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png",
    STANDARD: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png",
    SIMPLIFIED: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png",
    ORTO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png",
    ORTOGREY: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png",
    ORTOHYBRID: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png"
  }
}, kq = {
  ICGC5M: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png",
  WORLD30M: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png"
}, Nq = {
  Orto: {
    ortofotoColorProvisional: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional",
    ortofotoColor2023: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023",
    ortofotoColor2022: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022",
    ortofotoColor2021: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021",
    ortofotoColor2020: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020",
    ortofotoColor2019: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019",
    ortofotoColor2018: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018",
    ortofotoColor2017: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017",
    ortofotoColor2016: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016",
    ortofotoColor2015: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015",
    ortofotoColor2014: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014",
    ortofotoColor2013: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013",
    ortofotoColor2012: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012",
    ortofotoColor2011: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011",
    ortofotoColor2010: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010",
    ortofotoColor2009: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009",
    ortofotoColor2008: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008",
    ortofotoColor20062007: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007",
    ortofotoColor20042005: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005",
    ortofotoColor20002003: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003",
    ortofotoBlancINegre1998: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998",
    ortofotoBlancINegre19941997: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997",
    ortofotoColor1993: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993",
    ortofotoBlancINegre19831992: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992",
    ortofotoBlancINegre19701977: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977",
    ortofotoBlancINegre1956: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956",
    ortofotoBlancINegre1945: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945",
    ortofotoColorSerieAnual: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual",
    ortofotoInfraroigProvisional: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional",
    ortofotoInfraroig2023: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023",
    ortofotoInfraroig2022: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022",
    ortofotoInfraroig2021: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021",
    ortofotoInfraroig2020: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020",
    ortofotoInfraroig2019: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019",
    ortofotoInfraroig2018: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018",
    ortofotoInfraroig2017: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017",
    ortofotoInfraroig2016: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016",
    ortofotoInfraroig2015: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015",
    ortofotoInfraroig2014: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014",
    ortofotoInfraroig2013: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013",
    ortofotoInfraroig2012: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012",
    ortofotoInfraroig2011: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011",
    ortofotoInfraroig2010: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010",
    ortofotoInfraroig2009: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009",
    ortofotoInfraroig2008: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008",
    ortofotoInfraroig20062007: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007",
    ortofotoInfraroig19961997: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997",
    ortofotoInfraroigSerieAnual: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"
  },
  VectorAdmin: {
    agrupacionsCensals2015: "agrupacions_censals_2015",
    agrupacionsCensals2016: "agrupacions_censals_2016",
    agrupacionsCensals2017: "agrupacions_censals_2017",
    agrupacionsCensals2018: "agrupacions_censals_2018",
    agrupacionsCensals2019: "agrupacions_censals_2019",
    agrupacionsCensals2020: "agrupacions_censals_2020",
    agrupacionsCensals2021: "agrupacions_censals_2021",
    agrupacionsCensalsVigent: "agrupacions_censals_vigent",
    agrupacionsCensalsVigentText: "agrupacions_censals_vigent_text",
    areesBasiquesPolicials2019: "arees_basiques_policials_2019",
    areesBasiquesPolicials2020: "arees_basiques_policials_2020",
    areesBasiquesPolicials2022: "arees_basiques_policials_2022",
    areesBasiquesPolicialsVigent: "arees_basiques_policials_vigent",
    areesBasiquesPolicialsVigentText: "arees_basiques_policials_vigent_text",
    areesBasiquesSalutVigent: "arees_basiques_salut_vigent",
    areesBasiquesServeisSocialsVigent: "arees_basiques_serveis_socials_vigent",
    areesBasiquesServeisSocialsVigentText: "arees_basiques_serveis_socials_vigent_text",
    areesGestioAssistencialVigent: "arees_gestio_assistencial_vigent",
    areesHidrogeologiquesAquifersVigent: "arees_hidrogeologiques_aquifers_vigent",
    catalunyaVigent: "catalunya_vigent",
    catalunyaVigentText: "catalunya_vigent_text",
    comarques2022: "comarques_2022",
    comarquesVigent: "comarques_vigent",
    comarquesVigentText: "comarques_vigent_text",
    districtesCensals2015: "districtes_censals_2015",
    districtesCensals2016: "districtes_censals_2016",
    districtesCensals2017: "districtes_censals_2017",
    districtesCensals2018: "districtes_censals_2018",
    districtesCensals2019: "districtes_censals_2019",
    districtesCensals2020: "districtes_censals_2020",
    districtesCensals2021: "districtes_censals_2021",
    districtesCensals2022: "districtes_censals_2022",
    districtesCensals2023: "districtes_censals_2023",
    districtesCensalsVigent: "districtes_censals_vigent",
    districtesCensalsVigentText: "districtes_censals_vigent_text",
    incendisForestalsVigent: "incendis_forestals_vigent",
    incendisForestalsVigentText: "incendis_forestals_vigent_text",
    municipis2022: "municipis_2022",
    municipis2022Text: "municipis_2022_text",
    municipisVigent: "municipis_vigent",
    municipisVigentText: "municipis_vigent_text",
    partitsJudicialsVigent: "partits_judicials_vigent",
    partitsJudicialsVigentText: "partits_judicials_vigent_text",
    plaTerritorial2015: "pla_territorial_2015",
    plaTerritorialVigent: "pla_territorial_vigent",
    plaTerritorialVigentText: "pla_territorial_vigent_text",
    provinciesVigent: "provincies_vigent",
    provinciesVigentText: "provincies_vigent_text",
    regionsPolicialsVigent: "regions_policials_vigent",
    regionsPolicialsVigentText: "regions_policials_vigent_text",
    regionsSanitariesVigent: "regions_sanitaries_vigent",
    regionsSanitariesVigentText: "regions_sanitaries_vigent_text",
    seccionsCensals2015: "seccions_censals_2015",
    seccionsCensals2016: "seccions_censals_2016",
    seccionsCensals2017: "seccions_censals_2017",
    seccionsCensals2018: "seccions_censals_2018",
    seccionsCensals2019: "seccions_censals_2019",
    seccionsCensals2020: "seccions_censals_2020",
    seccionsCensals2021: "seccions_censals_2021",
    seccionsCensals2022: "seccions_censals_2022",
    seccionsCensals2023: "seccions_censals_2023",
    seccionsCensalsVigent: "seccions_censals_vigent",
    seccionsCensalsVigentText: "seccions_censals_vigent_text",
    sectorsSanitarisVigent: "sectors_sanitaris_vigent",
    vegueriesVigent: "vegueries_vigent",
    vegueriesVigentText: "vegueries_vigent_text"
  },
  FGBAdmin: {
    agrupacionsCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb",
    agrupacionsCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb",
    areesBasiquesPolicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb",
    areesBasiquesPolicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb",
    areesBasiquesSalutVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb",
    areesBasiquesServeisSocialsVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb",
    areesBasiquesServeisSocialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb",
    areesGestioAssistencialVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb",
    areesHidrogeologiquesAquifersVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb",
    catalunyaVigent: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb",
    catalunyaVigentText: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb",
    comarquesVigent: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb",
    comarquesVigentText: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb",
    districtesCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb",
    districtesCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb",
    incendisForestalsVigent: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb",
    incendisForestalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb",
    municipisVigent: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb",
    municipisVigentText: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb",
    partitsJudicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb",
    partitsJudicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb",
    plaTerritorialVigent: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb",
    plaTerritorialVigentText: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb",
    provinciesVigent: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb",
    provinciesVigentText: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb",
    regionsPolicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb",
    regionsPolicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb",
    regionsSanitariesVigent: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb",
    regionsSanitariesVigentText: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb",
    seccionsCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb",
    seccionsCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb",
    sectorsSanitarisVigent: "https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb",
    vegueriesVigent: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb",
    vegueriesVigentText: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"
  },
  Vector: {
    cobertes2018: "https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json"
  },
  WMS: {
    espaisInteresGeologic: "https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    gravimetriaBouguer500000: "https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    cobertesSol2018: "https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    administratiu: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png",
    simplificat: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png",
    cims: "https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455",
    cobertesSol: "http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"
  }
}, Lh = {
  defaultOptions: Dq,
  Styles: Fq,
  Terrains: kq,
  Layers: Nq
};
class zq {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    let t = Lh.defaultOptions;
    return this._map = e, this._img1 = document.createElement("img"), this._img1.className = "maplibregl-ctrl", this._img1.src = this.options.color ? t.logoIcgcOptions.logoUrlColor : t.logoIcgcOptions.logoUrlWhite, this._img1.width = t.logoIcgcOptions.logoWidth, this._img1.title = t.logoIcgcOptions.logoTitle, this._img1.style.opacity = t.logoIcgcOptions.logoOpacity, this.link1 = document.createElement("a"), this.link1.href = t.logoIcgcOptions.logoLink, this.link1.target = "_blank", this.link1.appendChild(this._img1), this._container1 = document.createElement("div"), this._container1.className = "maplibregl-ctrl", this._container1.style.width = `${t.logoIcgcOptions.logoWidth}px`, this._container1.appendChild(this.link1), this._img2 = document.createElement("img"), this._img2.className = "maplibregl-ctrl", this._img2.src = this.options.color ? t.logoGencatOptions.logoUrlColor : t.logoGencatOptions.logoUrlWhite, this._img2.width = t.logoGencatOptions.logoWidth, this._img2.title = t.logoGencatOptions.logoTitle, this._img2.style.opacity = t.logoGencatOptions.logoOpacity, this.link2 = document.createElement("a"), this.link2.href = t.logoGencatOptions.logoLink, this.link2.target = "_blank", this.link2.appendChild(this._img2), this._container2 = document.createElement("div"), this._container2.className = "maplibregl-ctrl", this._container2.style.width = `${t.logoGencatOptions.logoWidth}px`, this._container2.appendChild(this.link2), this._mainContainer = document.createElement("div"), this._mainContainer.className = "divLogos", this._mainContainer.style = "display: flex", this._mainContainer.appendChild(this._container1), this._mainContainer.appendChild(this._container2), this._mainContainer;
  }
}
class Uq {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    this._map = e, this._img1 = document.createElement("img"), this._img1.src = this.options.url, this._img1.width = 150, this._img1.title = 300, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), this.legendContainer = document.createElement("div"), this.legendContainer.classList.add("maplibregl-legend-list"), this.legendButton = document.createElement("button"), this.legendButton.classList.add("maplibregl-ctrl-icon"), this.legendButton.classList.add("maplibregl-legend-switcher"), this.legendButton.addEventListener("click", () => {
      this.legendButton.style.display = "none", this.legendContainer.style.display = "block";
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.legendButton), this.controlContainer.appendChild(this.legendContainer), this.closeButton = document.createElement("button"), this.closeButton.textContent = "x", this.closeButton.classList.add("maplibregl-legend-close-button"), this.closeButton.addEventListener("click", () => {
      this.legendButton.style.display = "block", this.legendContainer.style.display = "none";
    }), this.legendContainer.appendChild(this.closeButton);
    const t = document.createElement("label");
    return t.classList.add("maplibregl-legend-title-label"), t.textContent = this.options.idLayer || "Llegenda", this.legendContainer.appendChild(t), this.legendContainer.appendChild(document.createElement("br")), this.legendContainer.appendChild(this._img1), this.controlContainer;
  }
}
var af = KT.prototype, l1 = "WGS 84";
function KT(n) {
  n !== void 0 && (l1 = n), this.setEllipsoid(l1);
}
af.convertLatLngToUtm = function(n, e, t) {
  var r;
  if (this.status)
    return "No ecclipsoid data associated with unknown datum: " + l1;
  if (!Number.isInteger(t))
    return "Precision is not integer number.";
  n = parseFloat(n), e = parseFloat(e);
  var i = e, o = this.toRadians(n), c = this.toRadians(i);
  i >= 8 && i <= 13 && n > 54.5 && n < 58 || n >= 56 && n < 64 && i >= 3 && i < 12 ? r = 32 : (r = (i + 180) / 6 + 1, n >= 72 && n < 84 && (i >= 0 && i < 9 ? r = 31 : i >= 9 && i < 21 ? r = 33 : i >= 21 && i < 33 ? r = 35 : i >= 33 && i < 42 && (r = 37))), r = parseInt(r);
  var l = (r - 1) * 6 - 180 + 3, _ = this.toRadians(l), b = this.getUtmLetterDesignator(n), w = this.eccSquared / (1 - this.eccSquared), T = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(o) * Math.sin(o)), I = Math.tan(o) * Math.tan(o), P = w * Math.cos(o) * Math.cos(o), k = Math.cos(o) * (c - _), U = this.a * ((1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256) * o - (3 * this.eccSquared / 8 + 3 * this.eccSquared * this.eccSquared / 32 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(2 * o) + (15 * this.eccSquared * this.eccSquared / 256 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(4 * o) - 35 * this.eccSquared * this.eccSquared * this.eccSquared / 3072 * Math.sin(6 * o)), G = parseFloat(0.9996 * T * (k + (1 - I + P) * k * k * k / 6 + (5 - 18 * I + I * I + 72 * P - 58 * w) * k * k * k * k * k / 120) + 5e5), H = parseFloat(0.9996 * (U + T * Math.tan(o) * (k * k / 2 + (5 - I + 9 * P + 4 * P * P) * k * k * k * k / 24 + (61 - 58 * I + I * I + 600 * P - 330 * w) * k * k * k * k * k * k / 720)));
  return n < 0 && (H += 1e7), H = a5(H, t), G = a5(G, t), {
    Easting: G,
    Northing: H,
    ZoneNumber: parseInt(r),
    ZoneLetter: b
  };
};
af.convertUtmToLatLng = function(n, e, t, r) {
  var i = (1 - Math.sqrt(1 - this.eccSquared)) / (1 + Math.sqrt(1 - this.eccSquared)), o = n - 5e5, c = e, l = t, _ = r;
  if (n === void 0)
    return "Please pass the UTMEasting!";
  if (e === void 0)
    return "Please pass the UTMNorthing!";
  if (t === void 0)
    return "Please pass the UTMZoneNumber!";
  if (r === void 0)
    return "Please pass the UTMZoneLetter!";
  ["N", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"].indexOf(_) !== -1 || (c -= 1e7);
  var b = (l - 1) * 6 - 180 + 3, w = this.eccSquared / (1 - this.eccSquared), T = c / 0.9996, I = T / (this.a * (1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256)), P = I + (3 * i / 2 - 27 * i * i * i / 32) * Math.sin(2 * I) + (21 * i * i / 16 - 55 * i * i * i * i / 32) * Math.sin(4 * I) + 151 * i * i * i / 96 * Math.sin(6 * I);
  this.toDegrees(P);
  var k = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(P) * Math.sin(P)), U = Math.tan(P) * Math.tan(P), G = w * Math.cos(P) * Math.cos(P), H = this.a * (1 - this.eccSquared) / Math.pow(1 - this.eccSquared * Math.sin(P) * Math.sin(P), 1.5), $ = o / (k * 0.9996), ie = P - k * Math.tan(P) / H * ($ * $ / 2 - (5 + 3 * U + 10 * G - 4 * G * G - 9 * w) * $ * $ * $ * $ / 24 + (61 + 90 * U + 298 * G + 45 * U * U - 252 * w - 3 * G * G) * $ * $ * $ * $ * $ * $ / 720);
  ie = this.toDegrees(ie);
  var ge = ($ - (1 + 2 * U + G) * $ * $ * $ / 6 + (5 - 2 * G + 28 * U - 3 * G * G + 8 * w + 24 * U * U) * $ * $ * $ * $ * $ / 120) / Math.cos(P);
  return ge = b + this.toDegrees(ge), {
    lat: ie,
    lng: ge
  };
};
af.getUtmLetterDesignator = function(n) {
  return n = parseFloat(n), 84 >= n && n >= 72 ? "X" : 72 > n && n >= 64 ? "W" : 64 > n && n >= 56 ? "V" : 56 > n && n >= 48 ? "U" : 48 > n && n >= 40 ? "T" : 40 > n && n >= 32 ? "S" : 32 > n && n >= 24 ? "R" : 24 > n && n >= 16 ? "Q" : 16 > n && n >= 8 ? "P" : 8 > n && n >= 0 ? "N" : 0 > n && n >= -8 ? "M" : -8 > n && n >= -16 ? "L" : -16 > n && n >= -24 ? "K" : -24 > n && n >= -32 ? "J" : -32 > n && n >= -40 ? "H" : -40 > n && n >= -48 ? "G" : -48 > n && n >= -56 ? "F" : -56 > n && n >= -64 ? "E" : -64 > n && n >= -72 ? "D" : -72 > n && n >= -80 ? "C" : "Z";
};
af.setEllipsoid = function(n) {
  switch (n) {
    case "Airy":
      this.a = 6377563, this.eccSquared = 667054e-8;
      break;
    case "Australian National":
      this.a = 6378160, this.eccSquared = 6694542e-9;
      break;
    case "Bessel 1841":
      this.a = 6377397, this.eccSquared = 6674372e-9;
      break;
    case "Bessel 1841 Nambia":
      this.a = 6377484, this.eccSquared = 6674372e-9;
      break;
    case "Clarke 1866":
      this.a = 6378206, this.eccSquared = 6768658e-9;
      break;
    case "Clarke 1880":
      this.a = 6378249, this.eccSquared = 6803511e-9;
      break;
    case "Everest":
      this.a = 6377276, this.eccSquared = 6637847e-9;
      break;
    case "Fischer 1960 Mercury":
      this.a = 6378166, this.eccSquared = 6693422e-9;
      break;
    case "Fischer 1968":
      this.a = 6378150, this.eccSquared = 6693422e-9;
      break;
    case "GRS 1967":
      this.a = 6378160, this.eccSquared = 6694605e-9;
      break;
    case "GRS 1980":
      this.a = 6378137, this.eccSquared = 669438e-8;
      break;
    case "Helmert 1906":
      this.a = 6378200, this.eccSquared = 6693422e-9;
      break;
    case "Hough":
      this.a = 6378270, this.eccSquared = 672267e-8;
      break;
    case "International":
      this.a = 6378388, this.eccSquared = 672267e-8;
      break;
    case "Krassovsky":
      this.a = 6378245, this.eccSquared = 6693422e-9;
      break;
    case "Modified Airy":
      this.a = 6377340, this.eccSquared = 667054e-8;
      break;
    case "Modified Everest":
      this.a = 6377304, this.eccSquared = 6637847e-9;
      break;
    case "Modified Fischer 1960":
      this.a = 6378155, this.eccSquared = 6693422e-9;
      break;
    case "South American 1969":
      this.a = 6378160, this.eccSquared = 6694542e-9;
      break;
    case "WGS 60":
      this.a = 6378165, this.eccSquared = 6693422e-9;
      break;
    case "WGS 66":
      this.a = 6378145, this.eccSquared = 6694542e-9;
      break;
    case "WGS 72":
      this.a = 6378135, this.eccSquared = 6694318e-9;
      break;
    case "ED50":
      this.a = 6378388, this.eccSquared = 672267e-8;
      break;
    case "WGS 84":
    case "EUREF89":
    case "ETRS89":
      this.a = 6378137, this.eccSquared = 669438e-8;
      break;
    default:
      this.status = !0;
  }
};
af.toDegrees = function(n) {
  return n / Math.PI * 180;
};
af.toRadians = function(n) {
  return n * Math.PI / 180;
};
function a5(n, e) {
  var t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
var jq = KT;
const Gq = /* @__PURE__ */ Ip(jq);
class Vq {
  constructor(e) {
    this.options = e || {}, this.options.utm = this.options.hasOwnProperty("utm") ? this.options.utm : !0, this.options.lonlat = this.options.hasOwnProperty("lonlat") ? this.options.lonlat : !0;
  }
  onAdd(e) {
    const t = new Gq();
    return this._map = e, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl coordControl", this._container.style.width = `${this.options.width || "225px"}`, this._map.on("mousemove", (r) => {
      const i = r.lngLat.lat, o = r.lngLat.lng;
      let c = "", l = "";
      const _ = t.convertLatLngToUtm(i, o, 2), b = i > 0 ? "N" : "S";
      this.options.utm && (c = `ETRS89 UTM ${_.ZoneNumber}${b} X:<b> ${_.Easting}</b> Y:<b> ${_.Northing}</b> <br>`), this.options.lonlat && (l = `WGS 84 Lon:<b> ${o.toFixed(5)}</b>  Lat:<b> ${i.toFixed(5)}</b>`);
      const w = `${c}${l}`;
      this._container.innerHTML = w;
    }), this._container;
  }
  _lookUTM31(e, t) {
    var r = 0, i = 0, o = 6, c = 84;
    return e >= r && e <= o && t >= i && t <= c;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function QT(n, e) {
  return function() {
    return n.apply(e, arguments);
  };
}
const {
  toString: qq
} = Object.prototype, {
  getPrototypeOf: kb
} = Object, Ym = /* @__PURE__ */ ((n) => (e) => {
  const t = qq.call(e);
  return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Pl = (n) => (n = n.toLowerCase(), (e) => Ym(e) === n), Km = (n) => (e) => typeof e === n, {
  isArray: lf
} = Array, Cp = Km("undefined");
function Hq(n) {
  return n !== null && !Cp(n) && n.constructor !== null && !Cp(n.constructor) && wa(n.constructor.isBuffer) && n.constructor.isBuffer(n);
}
const e3 = Pl("ArrayBuffer");
function Wq(n) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && e3(n.buffer), e;
}
const Xq = Km("string"), wa = Km("function"), t3 = Km("number"), Qm = (n) => n !== null && typeof n == "object", $q = (n) => n === !0 || n === !1, om = (n) => {
  if (Ym(n) !== "object")
    return !1;
  const e = kb(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}, Zq = Pl("Date"), Jq = Pl("File"), Yq = Pl("Blob"), Kq = Pl("FileList"), Qq = (n) => Qm(n) && wa(n.pipe), eH = (n) => {
  let e;
  return n && (typeof FormData == "function" && n instanceof FormData || wa(n.append) && ((e = Ym(n)) === "formdata" || // detect form-data instance
  e === "object" && wa(n.toString) && n.toString() === "[object FormData]"));
}, tH = Pl("URLSearchParams"), [nH, rH, iH, sH] = ["ReadableStream", "Request", "Response", "Headers"].map(Pl), oH = (n) => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Hp(n, e) {
  let {
    allOwnKeys: t = !1
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (n === null || typeof n > "u")
    return;
  let r, i;
  if (typeof n != "object" && (n = [n]), lf(n))
    for (r = 0, i = n.length; r < i; r++)
      e.call(null, n[r], r, n);
  else {
    const o = t ? Object.getOwnPropertyNames(n) : Object.keys(n), c = o.length;
    let l;
    for (r = 0; r < c; r++)
      l = o[r], e.call(null, n[l], l, n);
  }
}
function n3(n, e) {
  e = e.toLowerCase();
  const t = Object.keys(n);
  let r = t.length, i;
  for (; r-- > 0; )
    if (i = t[r], e === i.toLowerCase())
      return i;
  return null;
}
const Mh = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, r3 = (n) => !Cp(n) && n !== Mh;
function c1() {
  const {
    caseless: n
  } = r3(this) && this || {}, e = {}, t = (r, i) => {
    const o = n && n3(e, i) || i;
    om(e[o]) && om(r) ? e[o] = c1(e[o], r) : om(r) ? e[o] = c1({}, r) : lf(r) ? e[o] = r.slice() : e[o] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Hp(arguments[r], t);
  return e;
}
const aH = function(n, e, t) {
  let {
    allOwnKeys: r
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  return Hp(e, (i, o) => {
    t && wa(i) ? n[o] = QT(i, t) : n[o] = i;
  }, {
    allOwnKeys: r
  }), n;
}, lH = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), cH = (n, e, t, r) => {
  n.prototype = Object.create(e.prototype, r), n.prototype.constructor = n, Object.defineProperty(n, "super", {
    value: e.prototype
  }), t && Object.assign(n.prototype, t);
}, uH = (n, e, t, r) => {
  let i, o, c;
  const l = {};
  if (e = e || {}, n == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(n), o = i.length; o-- > 0; )
      c = i[o], (!r || r(c, n, e)) && !l[c] && (e[c] = n[c], l[c] = !0);
    n = t !== !1 && kb(n);
  } while (n && (!t || t(n, e)) && n !== Object.prototype);
  return e;
}, hH = (n, e, t) => {
  n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length;
  const r = n.indexOf(e, t);
  return r !== -1 && r === t;
}, dH = (n) => {
  if (!n) return null;
  if (lf(n)) return n;
  let e = n.length;
  if (!t3(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = n[e];
  return t;
}, fH = /* @__PURE__ */ ((n) => (e) => n && e instanceof n)(typeof Uint8Array < "u" && kb(Uint8Array)), pH = (n, e) => {
  const r = (n && n[Symbol.iterator]).call(n);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const o = i.value;
    e.call(n, o[0], o[1]);
  }
}, gH = (n, e) => {
  let t;
  const r = [];
  for (; (t = n.exec(e)) !== null; )
    r.push(t);
  return r;
}, mH = Pl("HTMLFormElement"), _H = (n) => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, r, i) {
  return r.toUpperCase() + i;
}), l5 = ((n) => {
  let {
    hasOwnProperty: e
  } = n;
  return (t, r) => e.call(t, r);
})(Object.prototype), yH = Pl("RegExp"), i3 = (n, e) => {
  const t = Object.getOwnPropertyDescriptors(n), r = {};
  Hp(t, (i, o) => {
    let c;
    (c = e(i, o, n)) !== !1 && (r[o] = c || i);
  }), Object.defineProperties(n, r);
}, bH = (n) => {
  i3(n, (e, t) => {
    if (wa(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const r = n[t];
    if (wa(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, vH = (n, e) => {
  const t = {}, r = (i) => {
    i.forEach((o) => {
      t[o] = !0;
    });
  };
  return lf(n) ? r(n) : r(String(n).split(e)), t;
}, xH = () => {
}, wH = (n, e) => n != null && Number.isFinite(n = +n) ? n : e, K_ = "abcdefghijklmnopqrstuvwxyz", c5 = "0123456789", s3 = {
  DIGIT: c5,
  ALPHA: K_,
  ALPHA_DIGIT: K_ + K_.toUpperCase() + c5
}, AH = function() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s3.ALPHA_DIGIT, t = "";
  const {
    length: r
  } = e;
  for (; n--; )
    t += e[Math.random() * r | 0];
  return t;
};
function SH(n) {
  return !!(n && wa(n.append) && n[Symbol.toStringTag] === "FormData" && n[Symbol.iterator]);
}
const EH = (n) => {
  const e = new Array(10), t = (r, i) => {
    if (Qm(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[i] = r;
        const o = lf(r) ? [] : {};
        return Hp(r, (c, l) => {
          const _ = t(c, i + 1);
          !Cp(_) && (o[l] = _);
        }), e[i] = void 0, o;
      }
    }
    return r;
  };
  return t(n, 0);
}, TH = Pl("AsyncFunction"), CH = (n) => n && (Qm(n) || wa(n)) && wa(n.then) && wa(n.catch), o3 = ((n, e) => n ? setImmediate : e ? ((t, r) => (Mh.addEventListener("message", (i) => {
  let {
    source: o,
    data: c
  } = i;
  o === Mh && c === t && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), Mh.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(typeof setImmediate == "function", wa(Mh.postMessage)), IH = typeof queueMicrotask < "u" ? queueMicrotask.bind(Mh) : typeof process < "u" && process.nextTick || o3, ht = {
  isArray: lf,
  isArrayBuffer: e3,
  isBuffer: Hq,
  isFormData: eH,
  isArrayBufferView: Wq,
  isString: Xq,
  isNumber: t3,
  isBoolean: $q,
  isObject: Qm,
  isPlainObject: om,
  isReadableStream: nH,
  isRequest: rH,
  isResponse: iH,
  isHeaders: sH,
  isUndefined: Cp,
  isDate: Zq,
  isFile: Jq,
  isBlob: Yq,
  isRegExp: yH,
  isFunction: wa,
  isStream: Qq,
  isURLSearchParams: tH,
  isTypedArray: fH,
  isFileList: Kq,
  forEach: Hp,
  merge: c1,
  extend: aH,
  trim: oH,
  stripBOM: lH,
  inherits: cH,
  toFlatObject: uH,
  kindOf: Ym,
  kindOfTest: Pl,
  endsWith: hH,
  toArray: dH,
  forEachEntry: pH,
  matchAll: gH,
  isHTMLForm: mH,
  hasOwnProperty: l5,
  hasOwnProp: l5,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: i3,
  freezeMethods: bH,
  toObjectSet: vH,
  toCamelCase: _H,
  noop: xH,
  toFiniteNumber: wH,
  findKey: n3,
  global: Mh,
  isContextDefined: r3,
  ALPHABET: s3,
  generateString: AH,
  isSpecCompliantForm: SH,
  toJSONObject: EH,
  isAsyncFn: TH,
  isThenable: CH,
  setImmediate: o3,
  asap: IH
};
function Zn(n, e, t, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
ht.inherits(Zn, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ht.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const a3 = Zn.prototype, l3 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((n) => {
  l3[n] = {
    value: n
  };
});
Object.defineProperties(Zn, l3);
Object.defineProperty(a3, "isAxiosError", {
  value: !0
});
Zn.from = (n, e, t, r, i, o) => {
  const c = Object.create(a3);
  return ht.toFlatObject(n, c, function(_) {
    return _ !== Error.prototype;
  }, (l) => l !== "isAxiosError"), Zn.call(c, n.message, e, t, r, i), c.cause = n, c.name = n.name, o && Object.assign(c, o), c;
};
const PH = null;
function u1(n) {
  return ht.isPlainObject(n) || ht.isArray(n);
}
function c3(n) {
  return ht.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function u5(n, e, t) {
  return n ? n.concat(e).map(function(i, o) {
    return i = c3(i), !t && o ? "[" + i + "]" : i;
  }).join(t ? "." : "") : e;
}
function LH(n) {
  return ht.isArray(n) && !n.some(u1);
}
const MH = ht.toFlatObject(ht, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function e0(n, e, t) {
  if (!ht.isObject(n))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = ht.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(U, G) {
    return !ht.isUndefined(G[U]);
  });
  const r = t.metaTokens, i = t.visitor || w, o = t.dots, c = t.indexes, _ = (t.Blob || typeof Blob < "u" && Blob) && ht.isSpecCompliantForm(e);
  if (!ht.isFunction(i))
    throw new TypeError("visitor must be a function");
  function b(k) {
    if (k === null) return "";
    if (ht.isDate(k))
      return k.toISOString();
    if (!_ && ht.isBlob(k))
      throw new Zn("Blob is not supported. Use a Buffer instead.");
    return ht.isArrayBuffer(k) || ht.isTypedArray(k) ? _ && typeof Blob == "function" ? new Blob([k]) : Buffer.from(k) : k;
  }
  function w(k, U, G) {
    let H = k;
    if (k && !G && typeof k == "object") {
      if (ht.endsWith(U, "{}"))
        U = r ? U : U.slice(0, -2), k = JSON.stringify(k);
      else if (ht.isArray(k) && LH(k) || (ht.isFileList(k) || ht.endsWith(U, "[]")) && (H = ht.toArray(k)))
        return U = c3(U), H.forEach(function(ie, ge) {
          !(ht.isUndefined(ie) || ie === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            c === !0 ? u5([U], ge, o) : c === null ? U : U + "[]",
            b(ie)
          );
        }), !1;
    }
    return u1(k) ? !0 : (e.append(u5(G, U, o), b(k)), !1);
  }
  const T = [], I = Object.assign(MH, {
    defaultVisitor: w,
    convertValue: b,
    isVisitable: u1
  });
  function P(k, U) {
    if (!ht.isUndefined(k)) {
      if (T.indexOf(k) !== -1)
        throw Error("Circular reference detected in " + U.join("."));
      T.push(k), ht.forEach(k, function(H, $) {
        (!(ht.isUndefined(H) || H === null) && i.call(e, H, ht.isString($) ? $.trim() : $, U, I)) === !0 && P(H, U ? U.concat($) : [$]);
      }), T.pop();
    }
  }
  if (!ht.isObject(n))
    throw new TypeError("data must be an object");
  return P(n), e;
}
function h5(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function Nb(n, e) {
  this._pairs = [], n && e0(n, this, e);
}
const u3 = Nb.prototype;
u3.append = function(e, t) {
  this._pairs.push([e, t]);
};
u3.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, h5);
  } : h5;
  return this._pairs.map(function(i) {
    return t(i[0]) + "=" + t(i[1]);
  }, "").join("&");
};
function BH(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function h3(n, e, t) {
  if (!e)
    return n;
  const r = t && t.encode || BH;
  ht.isFunction(t) && (t = {
    serialize: t
  });
  const i = t && t.serialize;
  let o;
  if (i ? o = i(e, t) : o = ht.isURLSearchParams(e) ? e.toString() : new Nb(e, t).toString(r), o) {
    const c = n.indexOf("#");
    c !== -1 && (n = n.slice(0, c)), n += (n.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return n;
}
class d5 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    ht.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const d3 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, RH = typeof URLSearchParams < "u" ? URLSearchParams : Nb, OH = typeof FormData < "u" ? FormData : null, DH = typeof Blob < "u" ? Blob : null, FH = {
  isBrowser: !0,
  classes: {
    URLSearchParams: RH,
    FormData: OH,
    Blob: DH
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, zb = typeof window < "u" && typeof document < "u", h1 = typeof navigator == "object" && navigator || void 0, kH = zb && (!h1 || ["ReactNative", "NativeScript", "NS"].indexOf(h1.product) < 0), NH = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", zH = zb && window.location.href || "http://localhost", UH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: zb,
  hasStandardBrowserEnv: kH,
  hasStandardBrowserWebWorkerEnv: NH,
  navigator: h1,
  origin: zH
}, Symbol.toStringTag, { value: "Module" })), no = {
  ...UH,
  ...FH
};
function jH(n, e) {
  return e0(n, new no.classes.URLSearchParams(), Object.assign({
    visitor: function(t, r, i, o) {
      return no.isNode && ht.isBuffer(t) ? (this.append(r, t.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function GH(n) {
  return ht.matchAll(/\w+|\[(\w*)]/g, n).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function VH(n) {
  const e = {}, t = Object.keys(n);
  let r;
  const i = t.length;
  let o;
  for (r = 0; r < i; r++)
    o = t[r], e[o] = n[o];
  return e;
}
function f3(n) {
  function e(t, r, i, o) {
    let c = t[o++];
    if (c === "__proto__") return !0;
    const l = Number.isFinite(+c), _ = o >= t.length;
    return c = !c && ht.isArray(i) ? i.length : c, _ ? (ht.hasOwnProp(i, c) ? i[c] = [i[c], r] : i[c] = r, !l) : ((!i[c] || !ht.isObject(i[c])) && (i[c] = []), e(t, r, i[c], o) && ht.isArray(i[c]) && (i[c] = VH(i[c])), !l);
  }
  if (ht.isFormData(n) && ht.isFunction(n.entries)) {
    const t = {};
    return ht.forEachEntry(n, (r, i) => {
      e(GH(r), i, t, 0);
    }), t;
  }
  return null;
}
function qH(n, e, t) {
  if (ht.isString(n))
    try {
      return (e || JSON.parse)(n), ht.trim(n);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (0, JSON.stringify)(n);
}
const Wp = {
  transitional: d3,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", i = r.indexOf("application/json") > -1, o = ht.isObject(e);
    if (o && ht.isHTMLForm(e) && (e = new FormData(e)), ht.isFormData(e))
      return i ? JSON.stringify(f3(e)) : e;
    if (ht.isArrayBuffer(e) || ht.isBuffer(e) || ht.isStream(e) || ht.isFile(e) || ht.isBlob(e) || ht.isReadableStream(e))
      return e;
    if (ht.isArrayBufferView(e))
      return e.buffer;
    if (ht.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let l;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return jH(e, this.formSerializer).toString();
      if ((l = ht.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const _ = this.env && this.env.FormData;
        return e0(l ? {
          "files[]": e
        } : e, _ && new _(), this.formSerializer);
      }
    }
    return o || i ? (t.setContentType("application/json", !1), qH(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || Wp.transitional, r = t && t.forcedJSONParsing, i = this.responseType === "json";
    if (ht.isResponse(e) || ht.isReadableStream(e))
      return e;
    if (e && ht.isString(e) && (r && !this.responseType || i)) {
      const c = !(t && t.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (l) {
        if (c)
          throw l.name === "SyntaxError" ? Zn.from(l, Zn.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: no.classes.FormData,
    Blob: no.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ht.forEach(["delete", "get", "head", "post", "put", "patch"], (n) => {
  Wp.headers[n] = {};
});
const HH = ht.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), WH = (n) => {
  const e = {};
  let t, r, i;
  return n && n.split(`
`).forEach(function(c) {
    i = c.indexOf(":"), t = c.substring(0, i).trim().toLowerCase(), r = c.substring(i + 1).trim(), !(!t || e[t] && HH[t]) && (t === "set-cookie" ? e[t] ? e[t].push(r) : e[t] = [r] : e[t] = e[t] ? e[t] + ", " + r : r);
  }), e;
}, f5 = Symbol("internals");
function Qf(n) {
  return n && String(n).trim().toLowerCase();
}
function am(n) {
  return n === !1 || n == null ? n : ht.isArray(n) ? n.map(am) : String(n);
}
function XH(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = t.exec(n); )
    e[r[1]] = r[2];
  return e;
}
const $H = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function Q_(n, e, t, r, i) {
  if (ht.isFunction(r))
    return r.call(this, e, t);
  if (i && (e = t), !!ht.isString(e)) {
    if (ht.isString(r))
      return e.indexOf(r) !== -1;
    if (ht.isRegExp(r))
      return r.test(e);
  }
}
function ZH(n) {
  return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r);
}
function JH(n, e) {
  const t = ht.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(n, r + t, {
      value: function(i, o, c) {
        return this[r].call(this, e, i, o, c);
      },
      configurable: !0
    });
  });
}
class Ho {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, r) {
    const i = this;
    function o(l, _, b) {
      const w = Qf(_);
      if (!w)
        throw new Error("header name must be a non-empty string");
      const T = ht.findKey(i, w);
      (!T || i[T] === void 0 || b === !0 || b === void 0 && i[T] !== !1) && (i[T || _] = am(l));
    }
    const c = (l, _) => ht.forEach(l, (b, w) => o(b, w, _));
    if (ht.isPlainObject(e) || e instanceof this.constructor)
      c(e, t);
    else if (ht.isString(e) && (e = e.trim()) && !$H(e))
      c(WH(e), t);
    else if (ht.isHeaders(e))
      for (const [l, _] of e.entries())
        o(_, l, r);
    else
      e != null && o(t, e, r);
    return this;
  }
  get(e, t) {
    if (e = Qf(e), e) {
      const r = ht.findKey(this, e);
      if (r) {
        const i = this[r];
        if (!t)
          return i;
        if (t === !0)
          return XH(i);
        if (ht.isFunction(t))
          return t.call(this, i, r);
        if (ht.isRegExp(t))
          return t.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = Qf(e), e) {
      const r = ht.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!t || Q_(this, this[r], r, t)));
    }
    return !1;
  }
  delete(e, t) {
    const r = this;
    let i = !1;
    function o(c) {
      if (c = Qf(c), c) {
        const l = ht.findKey(r, c);
        l && (!t || Q_(r, r[l], l, t)) && (delete r[l], i = !0);
      }
    }
    return ht.isArray(e) ? e.forEach(o) : o(e), i;
  }
  clear(e) {
    const t = Object.keys(this);
    let r = t.length, i = !1;
    for (; r--; ) {
      const o = t[r];
      (!e || Q_(this, this[o], o, e, !0)) && (delete this[o], i = !0);
    }
    return i;
  }
  normalize(e) {
    const t = this, r = {};
    return ht.forEach(this, (i, o) => {
      const c = ht.findKey(r, o);
      if (c) {
        t[c] = am(i), delete t[o];
        return;
      }
      const l = e ? ZH(o) : String(o).trim();
      l !== o && delete t[o], t[l] = am(i), r[l] = !0;
    }), this;
  }
  concat() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return this.constructor.concat(this, ...t);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return ht.forEach(this, (r, i) => {
      r != null && r !== !1 && (t[i] = e && ht.isArray(r) ? r.join(", ") : r);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((e) => {
      let [t, r] = e;
      return t + ": " + r;
    }).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e) {
    const t = new this(e);
    for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      i[o - 1] = arguments[o];
    return i.forEach((c) => t.set(c)), t;
  }
  static accessor(e) {
    const r = (this[f5] = this[f5] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function o(c) {
      const l = Qf(c);
      r[l] || (JH(i, c), r[l] = !0);
    }
    return ht.isArray(e) ? e.forEach(o) : o(e), this;
  }
}
Ho.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ht.reduceDescriptors(Ho.prototype, (n, e) => {
  let {
    value: t
  } = n, r = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(i) {
      this[r] = i;
    }
  };
});
ht.freezeMethods(Ho);
function ey(n, e) {
  const t = this || Wp, r = e || t, i = Ho.from(r.headers);
  let o = r.data;
  return ht.forEach(n, function(l) {
    o = l.call(t, o, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), o;
}
function p3(n) {
  return !!(n && n.__CANCEL__);
}
function cf(n, e, t) {
  Zn.call(this, n ?? "canceled", Zn.ERR_CANCELED, e, t), this.name = "CanceledError";
}
ht.inherits(cf, Zn, {
  __CANCEL__: !0
});
function g3(n, e, t) {
  const r = t.config.validateStatus;
  !t.status || !r || r(t.status) ? n(t) : e(new Zn("Request failed with status code " + t.status, [Zn.ERR_BAD_REQUEST, Zn.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t));
}
function YH(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return e && e[1] || "";
}
function KH(n, e) {
  n = n || 10;
  const t = new Array(n), r = new Array(n);
  let i = 0, o = 0, c;
  return e = e !== void 0 ? e : 1e3, function(_) {
    const b = Date.now(), w = r[o];
    c || (c = b), t[i] = _, r[i] = b;
    let T = o, I = 0;
    for (; T !== i; )
      I += t[T++], T = T % n;
    if (i = (i + 1) % n, i === o && (o = (o + 1) % n), b - c < e)
      return;
    const P = w && b - w;
    return P ? Math.round(I * 1e3 / P) : void 0;
  };
}
function QH(n, e) {
  let t = 0, r = 1e3 / e, i, o;
  const c = function(b) {
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now(), i = null, o && (clearTimeout(o), o = null), n.apply(null, b);
  };
  return [function() {
    const b = Date.now(), w = b - t;
    for (var T = arguments.length, I = new Array(T), P = 0; P < T; P++)
      I[P] = arguments[P];
    w >= r ? c(I, b) : (i = I, o || (o = setTimeout(() => {
      o = null, c(i);
    }, r - w)));
  }, () => i && c(i)];
}
const Bm = function(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3, r = 0;
  const i = KH(50, 250);
  return QH((o) => {
    const c = o.loaded, l = o.lengthComputable ? o.total : void 0, _ = c - r, b = i(_), w = c <= l;
    r = c;
    const T = {
      loaded: c,
      total: l,
      progress: l ? c / l : void 0,
      bytes: _,
      rate: b || void 0,
      estimated: b && l && w ? (l - c) / b : void 0,
      event: o,
      lengthComputable: l != null,
      [e ? "download" : "upload"]: !0
    };
    n(T);
  }, t);
}, p5 = (n, e) => {
  const t = n != null;
  return [(r) => e[0]({
    lengthComputable: t,
    total: n,
    loaded: r
  }), e[1]];
}, g5 = (n) => function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return ht.asap(() => n(...t));
}, eW = no.hasStandardBrowserEnv ? /* @__PURE__ */ ((n, e) => (t) => (t = new URL(t, no.origin), n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)))(new URL(no.origin), no.navigator && /(msie|trident)/i.test(no.navigator.userAgent)) : () => !0, tW = no.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(n, e, t, r, i, o) {
      const c = [n + "=" + encodeURIComponent(e)];
      ht.isNumber(t) && c.push("expires=" + new Date(t).toGMTString()), ht.isString(r) && c.push("path=" + r), ht.isString(i) && c.push("domain=" + i), o === !0 && c.push("secure"), document.cookie = c.join("; ");
    },
    read(n) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(n) {
      this.write(n, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function nW(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function rW(n, e) {
  return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function m3(n, e) {
  return n && !nW(e) ? rW(n, e) : e;
}
const m5 = (n) => n instanceof Ho ? {
  ...n
} : n;
function Uh(n, e) {
  e = e || {};
  const t = {};
  function r(b, w, T, I) {
    return ht.isPlainObject(b) && ht.isPlainObject(w) ? ht.merge.call({
      caseless: I
    }, b, w) : ht.isPlainObject(w) ? ht.merge({}, w) : ht.isArray(w) ? w.slice() : w;
  }
  function i(b, w, T, I) {
    if (ht.isUndefined(w)) {
      if (!ht.isUndefined(b))
        return r(void 0, b, T, I);
    } else return r(b, w, T, I);
  }
  function o(b, w) {
    if (!ht.isUndefined(w))
      return r(void 0, w);
  }
  function c(b, w) {
    if (ht.isUndefined(w)) {
      if (!ht.isUndefined(b))
        return r(void 0, b);
    } else return r(void 0, w);
  }
  function l(b, w, T) {
    if (T in e)
      return r(b, w);
    if (T in n)
      return r(void 0, b);
  }
  const _ = {
    url: o,
    method: o,
    data: o,
    baseURL: c,
    transformRequest: c,
    transformResponse: c,
    paramsSerializer: c,
    timeout: c,
    timeoutMessage: c,
    withCredentials: c,
    withXSRFToken: c,
    adapter: c,
    responseType: c,
    xsrfCookieName: c,
    xsrfHeaderName: c,
    onUploadProgress: c,
    onDownloadProgress: c,
    decompress: c,
    maxContentLength: c,
    maxBodyLength: c,
    beforeRedirect: c,
    transport: c,
    httpAgent: c,
    httpsAgent: c,
    cancelToken: c,
    socketPath: c,
    responseEncoding: c,
    validateStatus: l,
    headers: (b, w, T) => i(m5(b), m5(w), T, !0)
  };
  return ht.forEach(Object.keys(Object.assign({}, n, e)), function(w) {
    const T = _[w] || i, I = T(n[w], e[w], w);
    ht.isUndefined(I) && T !== l || (t[w] = I);
  }), t;
}
const _3 = (n) => {
  const e = Uh({}, n);
  let {
    data: t,
    withXSRFToken: r,
    xsrfHeaderName: i,
    xsrfCookieName: o,
    headers: c,
    auth: l
  } = e;
  e.headers = c = Ho.from(c), e.url = h3(m3(e.baseURL, e.url), n.params, n.paramsSerializer), l && c.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : "")));
  let _;
  if (ht.isFormData(t)) {
    if (no.hasStandardBrowserEnv || no.hasStandardBrowserWebWorkerEnv)
      c.setContentType(void 0);
    else if ((_ = c.getContentType()) !== !1) {
      const [b, ...w] = _ ? _.split(";").map((T) => T.trim()).filter(Boolean) : [];
      c.setContentType([b || "multipart/form-data", ...w].join("; "));
    }
  }
  if (no.hasStandardBrowserEnv && (r && ht.isFunction(r) && (r = r(e)), r || r !== !1 && eW(e.url))) {
    const b = i && o && tW.read(o);
    b && c.set(i, b);
  }
  return e;
}, iW = typeof XMLHttpRequest < "u", sW = iW && function(n) {
  return new Promise(function(t, r) {
    const i = _3(n);
    let o = i.data;
    const c = Ho.from(i.headers).normalize();
    let {
      responseType: l,
      onUploadProgress: _,
      onDownloadProgress: b
    } = i, w, T, I, P, k;
    function U() {
      P && P(), k && k(), i.cancelToken && i.cancelToken.unsubscribe(w), i.signal && i.signal.removeEventListener("abort", w);
    }
    let G = new XMLHttpRequest();
    G.open(i.method.toUpperCase(), i.url, !0), G.timeout = i.timeout;
    function H() {
      if (!G)
        return;
      const ie = Ho.from("getAllResponseHeaders" in G && G.getAllResponseHeaders()), Se = {
        data: !l || l === "text" || l === "json" ? G.responseText : G.response,
        status: G.status,
        statusText: G.statusText,
        headers: ie,
        config: n,
        request: G
      };
      g3(function(Le) {
        t(Le), U();
      }, function(Le) {
        r(Le), U();
      }, Se), G = null;
    }
    "onloadend" in G ? G.onloadend = H : G.onreadystatechange = function() {
      !G || G.readyState !== 4 || G.status === 0 && !(G.responseURL && G.responseURL.indexOf("file:") === 0) || setTimeout(H);
    }, G.onabort = function() {
      G && (r(new Zn("Request aborted", Zn.ECONNABORTED, n, G)), G = null);
    }, G.onerror = function() {
      r(new Zn("Network Error", Zn.ERR_NETWORK, n, G)), G = null;
    }, G.ontimeout = function() {
      let ge = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const Se = i.transitional || d3;
      i.timeoutErrorMessage && (ge = i.timeoutErrorMessage), r(new Zn(ge, Se.clarifyTimeoutError ? Zn.ETIMEDOUT : Zn.ECONNABORTED, n, G)), G = null;
    }, o === void 0 && c.setContentType(null), "setRequestHeader" in G && ht.forEach(c.toJSON(), function(ge, Se) {
      G.setRequestHeader(Se, ge);
    }), ht.isUndefined(i.withCredentials) || (G.withCredentials = !!i.withCredentials), l && l !== "json" && (G.responseType = i.responseType), b && ([I, k] = Bm(b, !0), G.addEventListener("progress", I)), _ && G.upload && ([T, P] = Bm(_), G.upload.addEventListener("progress", T), G.upload.addEventListener("loadend", P)), (i.cancelToken || i.signal) && (w = (ie) => {
      G && (r(!ie || ie.type ? new cf(null, n, G) : ie), G.abort(), G = null);
    }, i.cancelToken && i.cancelToken.subscribe(w), i.signal && (i.signal.aborted ? w() : i.signal.addEventListener("abort", w)));
    const $ = YH(i.url);
    if ($ && no.protocols.indexOf($) === -1) {
      r(new Zn("Unsupported protocol " + $ + ":", Zn.ERR_BAD_REQUEST, n));
      return;
    }
    G.send(o || null);
  });
}, oW = (n, e) => {
  const {
    length: t
  } = n = n ? n.filter(Boolean) : [];
  if (e || t) {
    let r = new AbortController(), i;
    const o = function(b) {
      if (!i) {
        i = !0, l();
        const w = b instanceof Error ? b : this.reason;
        r.abort(w instanceof Zn ? w : new cf(w instanceof Error ? w.message : w));
      }
    };
    let c = e && setTimeout(() => {
      c = null, o(new Zn(`timeout ${e} of ms exceeded`, Zn.ETIMEDOUT));
    }, e);
    const l = () => {
      n && (c && clearTimeout(c), c = null, n.forEach((b) => {
        b.unsubscribe ? b.unsubscribe(o) : b.removeEventListener("abort", o);
      }), n = null);
    };
    n.forEach((b) => b.addEventListener("abort", o));
    const {
      signal: _
    } = r;
    return _.unsubscribe = () => ht.asap(l), _;
  }
}, aW = function* (n, e) {
  let t = n.byteLength;
  if (t < e) {
    yield n;
    return;
  }
  let r = 0, i;
  for (; r < t; )
    i = r + e, yield n.slice(r, i), r = i;
}, lW = async function* (n, e) {
  for await (const t of cW(n))
    yield* aW(t, e);
}, cW = async function* (n) {
  if (n[Symbol.asyncIterator]) {
    yield* n;
    return;
  }
  const e = n.getReader();
  try {
    for (; ; ) {
      const {
        done: t,
        value: r
      } = await e.read();
      if (t)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, _5 = (n, e, t, r) => {
  const i = lW(n, e);
  let o = 0, c, l = (_) => {
    c || (c = !0, r && r(_));
  };
  return new ReadableStream({
    async pull(_) {
      try {
        const {
          done: b,
          value: w
        } = await i.next();
        if (b) {
          l(), _.close();
          return;
        }
        let T = w.byteLength;
        if (t) {
          let I = o += T;
          t(I);
        }
        _.enqueue(new Uint8Array(w));
      } catch (b) {
        throw l(b), b;
      }
    },
    cancel(_) {
      return l(_), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, t0 = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", y3 = t0 && typeof ReadableStream == "function", uW = t0 && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((n) => (e) => n.encode(e))(new TextEncoder()) : async (n) => new Uint8Array(await new Response(n).arrayBuffer())), b3 = function(n) {
  try {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
      t[r - 1] = arguments[r];
    return !!n(...t);
  } catch {
    return !1;
  }
}, hW = y3 && b3(() => {
  let n = !1;
  const e = new Request(no.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return n = !0, "half";
    }
  }).headers.has("Content-Type");
  return n && !e;
}), y5 = 64 * 1024, d1 = y3 && b3(() => ht.isReadableStream(new Response("").body)), Rm = {
  stream: d1 && ((n) => n.body)
};
t0 && ((n) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Rm[e] && (Rm[e] = ht.isFunction(n[e]) ? (t) => t[e]() : (t, r) => {
      throw new Zn(`Response type '${e}' is not supported`, Zn.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const dW = async (n) => {
  if (n == null)
    return 0;
  if (ht.isBlob(n))
    return n.size;
  if (ht.isSpecCompliantForm(n))
    return (await new Request(no.origin, {
      method: "POST",
      body: n
    }).arrayBuffer()).byteLength;
  if (ht.isArrayBufferView(n) || ht.isArrayBuffer(n))
    return n.byteLength;
  if (ht.isURLSearchParams(n) && (n = n + ""), ht.isString(n))
    return (await uW(n)).byteLength;
}, fW = async (n, e) => {
  const t = ht.toFiniteNumber(n.getContentLength());
  return t ?? dW(e);
}, pW = t0 && (async (n) => {
  let {
    url: e,
    method: t,
    data: r,
    signal: i,
    cancelToken: o,
    timeout: c,
    onDownloadProgress: l,
    onUploadProgress: _,
    responseType: b,
    headers: w,
    withCredentials: T = "same-origin",
    fetchOptions: I
  } = _3(n);
  b = b ? (b + "").toLowerCase() : "text";
  let P = oW([i, o && o.toAbortSignal()], c), k;
  const U = P && P.unsubscribe && (() => {
    P.unsubscribe();
  });
  let G;
  try {
    if (_ && hW && t !== "get" && t !== "head" && (G = await fW(w, r)) !== 0) {
      let Se = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), Re;
      if (ht.isFormData(r) && (Re = Se.headers.get("content-type")) && w.setContentType(Re), Se.body) {
        const [Le, _e] = p5(G, Bm(g5(_)));
        r = _5(Se.body, y5, Le, _e);
      }
    }
    ht.isString(T) || (T = T ? "include" : "omit");
    const H = "credentials" in Request.prototype;
    k = new Request(e, {
      ...I,
      signal: P,
      method: t.toUpperCase(),
      headers: w.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: H ? T : void 0
    });
    let $ = await fetch(k);
    const ie = d1 && (b === "stream" || b === "response");
    if (d1 && (l || ie && U)) {
      const Se = {};
      ["status", "statusText", "headers"].forEach((Ge) => {
        Se[Ge] = $[Ge];
      });
      const Re = ht.toFiniteNumber($.headers.get("content-length")), [Le, _e] = l && p5(Re, Bm(g5(l), !0)) || [];
      $ = new Response(_5($.body, y5, Le, () => {
        _e && _e(), U && U();
      }), Se);
    }
    b = b || "text";
    let ge = await Rm[ht.findKey(Rm, b) || "text"]($, n);
    return !ie && U && U(), await new Promise((Se, Re) => {
      g3(Se, Re, {
        data: ge,
        headers: Ho.from($.headers),
        status: $.status,
        statusText: $.statusText,
        config: n,
        request: k
      });
    });
  } catch (H) {
    throw U && U(), H && H.name === "TypeError" && /fetch/i.test(H.message) ? Object.assign(new Zn("Network Error", Zn.ERR_NETWORK, n, k), {
      cause: H.cause || H
    }) : Zn.from(H, H && H.code, n, k);
  }
}), f1 = {
  http: PH,
  xhr: sW,
  fetch: pW
};
ht.forEach(f1, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", {
        value: e
      });
    } catch {
    }
    Object.defineProperty(n, "adapterName", {
      value: e
    });
  }
});
const b5 = (n) => `- ${n}`, gW = (n) => ht.isFunction(n) || n === null || n === !1, v3 = {
  getAdapter: (n) => {
    n = ht.isArray(n) ? n : [n];
    const {
      length: e
    } = n;
    let t, r;
    const i = {};
    for (let o = 0; o < e; o++) {
      t = n[o];
      let c;
      if (r = t, !gW(t) && (r = f1[(c = String(t)).toLowerCase()], r === void 0))
        throw new Zn(`Unknown adapter '${c}'`);
      if (r)
        break;
      i[c || "#" + o] = r;
    }
    if (!r) {
      const o = Object.entries(i).map((l) => {
        let [_, b] = l;
        return `adapter ${_} ` + (b === !1 ? "is not supported by the environment" : "is not available in the build");
      });
      let c = e ? o.length > 1 ? `since :
` + o.map(b5).join(`
`) : " " + b5(o[0]) : "as no adapter specified";
      throw new Zn("There is no suitable adapter to dispatch the request " + c, "ERR_NOT_SUPPORT");
    }
    return r;
  },
  adapters: f1
};
function ty(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new cf(null, n);
}
function v5(n) {
  return ty(n), n.headers = Ho.from(n.headers), n.data = ey.call(n, n.transformRequest), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), v3.getAdapter(n.adapter || Wp.adapter)(n).then(function(r) {
    return ty(n), r.data = ey.call(n, n.transformResponse, r), r.headers = Ho.from(r.headers), r;
  }, function(r) {
    return p3(r) || (ty(n), r && r.response && (r.response.data = ey.call(n, n.transformResponse, r.response), r.response.headers = Ho.from(r.response.headers))), Promise.reject(r);
  });
}
const x3 = "1.7.9", n0 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => {
  n0[n] = function(r) {
    return typeof r === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
const x5 = {};
n0.transitional = function(e, t, r) {
  function i(o, c) {
    return "[Axios v" + x3 + "] Transitional option '" + o + "'" + c + (r ? ". " + r : "");
  }
  return (o, c, l) => {
    if (e === !1)
      throw new Zn(i(c, " has been removed" + (t ? " in " + t : "")), Zn.ERR_DEPRECATED);
    return t && !x5[c] && (x5[c] = !0, console.warn(i(c, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(o, c, l) : !0;
  };
};
n0.spelling = function(e) {
  return (t, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function mW(n, e, t) {
  if (typeof n != "object")
    throw new Zn("options must be an object", Zn.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(n);
  let i = r.length;
  for (; i-- > 0; ) {
    const o = r[i], c = e[o];
    if (c) {
      const l = n[o], _ = l === void 0 || c(l, o, n);
      if (_ !== !0)
        throw new Zn("option " + o + " must be " + _, Zn.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new Zn("Unknown option " + o, Zn.ERR_BAD_OPTION);
  }
}
const lm = {
  assertOptions: mW,
  validators: n0
}, dc = lm.validators;
class Dh {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new d5(),
      response: new d5()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (r) {
      if (r instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + o) : r.stack = o;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Uh(this.defaults, t);
    const {
      transitional: r,
      paramsSerializer: i,
      headers: o
    } = t;
    r !== void 0 && lm.assertOptions(r, {
      silentJSONParsing: dc.transitional(dc.boolean),
      forcedJSONParsing: dc.transitional(dc.boolean),
      clarifyTimeoutError: dc.transitional(dc.boolean)
    }, !1), i != null && (ht.isFunction(i) ? t.paramsSerializer = {
      serialize: i
    } : lm.assertOptions(i, {
      encode: dc.function,
      serialize: dc.function
    }, !0)), lm.assertOptions(t, {
      baseUrl: dc.spelling("baseURL"),
      withXsrfToken: dc.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let c = o && ht.merge(o.common, o[t.method]);
    o && ht.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (k) => {
      delete o[k];
    }), t.headers = Ho.concat(c, o);
    const l = [];
    let _ = !0;
    this.interceptors.request.forEach(function(U) {
      typeof U.runWhen == "function" && U.runWhen(t) === !1 || (_ = _ && U.synchronous, l.unshift(U.fulfilled, U.rejected));
    });
    const b = [];
    this.interceptors.response.forEach(function(U) {
      b.push(U.fulfilled, U.rejected);
    });
    let w, T = 0, I;
    if (!_) {
      const k = [v5.bind(this), void 0];
      for (k.unshift.apply(k, l), k.push.apply(k, b), I = k.length, w = Promise.resolve(t); T < I; )
        w = w.then(k[T++], k[T++]);
      return w;
    }
    I = l.length;
    let P = t;
    for (T = 0; T < I; ) {
      const k = l[T++], U = l[T++];
      try {
        P = k(P);
      } catch (G) {
        U.call(this, G);
        break;
      }
    }
    try {
      w = v5.call(this, P);
    } catch (k) {
      return Promise.reject(k);
    }
    for (T = 0, I = b.length; T < I; )
      w = w.then(b[T++], b[T++]);
    return w;
  }
  getUri(e) {
    e = Uh(this.defaults, e);
    const t = m3(e.baseURL, e.url);
    return h3(t, e.params, e.paramsSerializer);
  }
}
ht.forEach(["delete", "get", "head", "options"], function(e) {
  Dh.prototype[e] = function(t, r) {
    return this.request(Uh(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
ht.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(o, c, l) {
      return this.request(Uh(l || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: c
      }));
    };
  }
  Dh.prototype[e] = t(), Dh.prototype[e + "Form"] = t(!0);
});
class Ub {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(o) {
      t = o;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let o = r._listeners.length;
      for (; o-- > 0; )
        r._listeners[o](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let o;
      const c = new Promise((l) => {
        r.subscribe(l), o = l;
      }).then(i);
      return c.cancel = function() {
        r.unsubscribe(o);
      }, c;
    }, e(function(o, c, l) {
      r.reason || (r.reason = new cf(o, c, l), t(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (r) => {
      e.abort(r);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new Ub(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
}
function _W(n) {
  return function(t) {
    return n.apply(null, t);
  };
}
function yW(n) {
  return ht.isObject(n) && n.isAxiosError === !0;
}
const p1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(p1).forEach((n) => {
  let [e, t] = n;
  p1[t] = e;
});
function w3(n) {
  const e = new Dh(n), t = QT(Dh.prototype.request, e);
  return ht.extend(t, Dh.prototype, e, {
    allOwnKeys: !0
  }), ht.extend(t, e, null, {
    allOwnKeys: !0
  }), t.create = function(i) {
    return w3(Uh(n, i));
  }, t;
}
const Wi = w3(Wp);
Wi.Axios = Dh;
Wi.CanceledError = cf;
Wi.CancelToken = Ub;
Wi.isCancel = p3;
Wi.VERSION = x3;
Wi.toFormData = e0;
Wi.AxiosError = Zn;
Wi.Cancel = Wi.CanceledError;
Wi.all = function(e) {
  return Promise.all(e);
};
Wi.spread = _W;
Wi.isAxiosError = yW;
Wi.mergeConfig = Uh;
Wi.AxiosHeaders = Ho;
Wi.formToJSON = (n) => f3(ht.isHTMLForm(n) ? new FormData(n) : n);
Wi.getAdapter = v3.getAdapter;
Wi.HttpStatusCode = p1;
Wi.default = Wi;
const bW = "https://eines.icgc.cat/recursos/mapicgc-gl-js/mapicgc-config.json", vW = 5e3;
class xW {
  static async getConfigICGC() {
    try {
      const e = await Wi.get(bW, {
        timeout: vW
      });
      return e.data ? e.data : (console.log("Resposta sense dades:", e), Lh);
    } catch (e) {
      return e.response ? (console.error("Error de resposta:", e.response.data), console.error("Codi d'estat:", e.response.status)) : e.request ? console.error("No s'ha rebut resposta del servidor:", e.request) : console.error("Error:", e.message), Lh;
    }
  }
}
const wW = {
  "fill-opacity": ["interpolate", ["exponential", 0.5], ["zoom"], 13.5, 1, 18, 0.4],
  "fill-outline-color": "rgba(0,0, 0, 0)",
  "fill-color": ["interpolate", ["cubic-bezier", 0.5, 1, 1, 1], ["get", "nivell_2"], 0, "#ffffff", 111, "#ffff00", 112, "#ccff33", 113, "#af5b15", 114, "#808000", 115, "#cdcd00", 116, "#ffffcc", 221, "#33cc33", 222, "#66ff33", 223, "#689018", 224, "#967d5f", 225, "#19e61e", 226, "#b4ff9b", 227, "#aaa500", 228, "#c3c3a0", 229, "#00ff9b", 230, "#ff9632", 231, "#282828", 232, "#79797a", 233, "#f5df78", 234, "#3296ff", 341, "#ff007d", 342, "#ff53cd", 343, "#ffa4e2", 344, "#ffc8e2", 345, "#ffb4b4", 346, "#0f3700", 347, "#730055", 348, "#6200c4", 349, "#4a9595", 350, "#ff00f0", 351, "#adaaca", 352, "#ffe6e6", 353, "#67629a", 354, "#4a466e", 355, "#2f2d46", 461, "#6f6fff", 462, "#0000dc", 463, "#000064", 464, "#185f94", 465, "#12466d", 466, "#000080"]
}, AW = {
  cobertesSol: wW
}, SW = "lines", Vg = "labels";
let xh, ep, Si, hr, OW = class {
  /**
   * Constructor for the Map class.
   * @param {Object} options - Options to initialize the map.
   */
  constructor(e) {
    xW.getConfigICGC().then((t) => {
      xh = {
        ...t.Styles
      }, Si = {
        ...t.Layers
      }, ep = {
        ...t.Terrains
      }, hr = {
        ...t.defaultOptions
      }, this.initTheMap(e);
    }).catch((t) => {
      console.info("Configuracio per defecte", t), xh = {
        ...Lh.Styles
      }, Si = {
        ...Lh.Layers
      }, ep = {
        ...Lh.Terrains
      }, hr = {
        ...Lh.defaultOptions
      }, this.initTheMap(e);
    });
  }
  initTheMap(e) {
    if (!e)
      e = hr.mapOptions;
    else
      for (const r in hr.mapOptions) {
        let i = [hr.mapOptions.center[0], hr.mapOptions.center[1]];
        hr.mapOptions.center = i, e.hasOwnProperty(r) || (e[r] = hr.mapOptions[r]);
      }
    e.maxPitch = 85, e.maplibreLogo = !1, e.attributionControl = !1;
    const t = e.style.includes("https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/");
    t ? (this.map = new gs.Map({
      container: e.container,
      center: e.center,
      zoom: e.zoom,
      pitch: e.pitch || 0,
      hash: e.hash || !1,
      style: {
        version: 8,
        sources: {},
        layers: []
      }
    }), this.map.on("load", () => {
      this.map.addSource("raster-source", {
        type: "raster",
        tiles: [e.style],
        // URL del raster
        tileSize: 256
      }), this.map.addLayer({
        id: "raster-layer",
        type: "raster",
        source: "raster-source"
      });
    })) : this.map = new gs.Map(e), this.map.on("load", () => {
      if (!t) {
        const r = this.map.getStyle().name, i = e.style;
        this.map.addControl(new zq({
          color: i.indexOf("orto") === -1,
          defaultOptions: hr
        }), "bottom-left"), this._dealOrto3dStyle(r);
      }
    });
  }
  /**
   * Add geocoder with customizable options.
   * @function addGeocoderICGC
   * @param {Object} [options={}] - Optional configuration options for the geocoder. Defaults to an empty object.
   * @param {string} [position='top-right'] - Position to add the geocoder control on the map. Defaults to 'top-right'.
   * @returns {Object} - The merged configuration options for the geocoder, including the position.
   * 
   */
  addGeocoderICGC() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top-right";
    try {
      e = {
        ...{
          collapsed: !0,
          marker: !0,
          zoom: 16,
          popup: !0,
          showResultMarkers: !0,
          maplibregl: gs,
          showResultsWhileTyping: !0,
          minLength: 2
        },
        ...e
      };
      const i = {
        forwardGeocode: async (c) => {
          const l = [];
          try {
            const _ = hr.geocoder.peliasUrl1 + encodeURIComponent(c.query) + hr.geocoder.peliasUrl2, w = await (await fetch(_)).json();
            for (const T of w.features) {
              const I = T.geometry.coordinates, P = {
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: I
                },
                place_name: T.properties.etiqueta,
                properties: T.properties,
                text: T.properties.etiqueta,
                place_type: ["place"],
                center: I
              };
              l.push(P);
            }
          } catch (_) {
            console.error(`Failed to forwardGeocode with error: ${_}`);
          }
          return {
            features: l
          };
        }
      };
      this.map.addControl(new Oq(i, e), t);
      let o = document.getElementsByClassName("maplibregl-ctrl-geocoder--input");
      o[0].attributes[2].nodeValue = "Cerca...", o[0].addEventListener("input", function(c) {
        c.target.value.length > 3;
      });
    } catch (r) {
      console.error(`Error adding ICGC geocoder: ${r.message}`);
    }
  }
  //geocoder ends
  async loadImage(e) {
    try {
      return this.map.loadImage(e);
    } catch (t) {
      console.error(`Error getting loadImage: ${t.message}`);
    }
  }
  /**
   * Retrieves the available base styles from default options.
   * @function getConfigStyles
   * @returns {Array} - Array containing the names of available base styles.
   */
  getConfigStyles() {
    try {
      let e = [];
      for (const t of xh)
        e.push(t.name);
      return e;
    } catch (e) {
      console.error(`Error retrieving base styles: ${e.message}`);
    }
  }
  /**
   * Retrieves the available WMS image layers from default options.
   * @function getConfigWMSLayers
   * @returns {Array} - Array containing the keys of available WMS image layers.
   */
  getConfigWMSLayers() {
    try {
      let e = [];
      for (const t in Si.WMS)
        Si.WMS.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving WMS layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available orto image layers from default options.
   * @function getConfigOrtoLayers
   * @returns {Array} - Array containing the keys of available image layers.
   */
  getConfigOrtoLayers() {
    try {
      let e = [];
      for (const t in Si.Orto)
        Si.Orto.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving orto image layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorLayers
   * @returns {Array} - Array containing the keys of available vector layers.
   */
  getConfigVectorLayers() {
    try {
      let e = [];
      for (const t in Si.Vector)
        Si.Vector.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vector layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorAdminLayers
   * @returns {Array} - Array containing the keys of available vectorAdmin layers.
   */
  getConfigVectorAdminLayers() {
    try {
      let e = [];
      for (const t in Si.VectorAdmin)
        Si.VectorAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vectorAdmin layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available fgb layers from default options.
   * @function getConfigFGBAdminLayers
   * @returns {Array} - Array containing the keys of available fgbadmin layers.
   */
  getConfigFGBAdminLayers() {
    try {
      let e = [];
      for (const t in Si.FGBAdmin)
        Si.FGBAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving FGBAdmin layers: ${e.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The id for the layer.
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchData(e, t, r) {
    try {
      (!r || r === void 0) && (r = {
        type: "line",
        layout: {
          visibility: "visible"
        },
        paint: {
          "line-color": "grey",
          "line-width": 2
        },
        layerPosition: "top"
        // select: 'top', 'lines' or 'labels'
      });
      let i = r.layerPosition;
      if (e.includes(".fgb"))
        this.addFGBLayerICGC(e, t, r);
      else {
        const c = await (await fetch(e)).json();
        let l = t, _ = this._dealOrderLayer(i), b = c.features[0].geometry.type;
        b.includes("ine") && (r !== void 0 ? this.map.addLayer({
          id: l,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: r.layout || {},
          paint: r.paint || {}
        }, _) : this.map.addLayer({
          id: l,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "line-color": "black",
            "line-width": 2,
            "line-opacity": 1
          }
        }, _)), b.includes("olygon") && (r !== void 0 ? this.map.addLayer({
          id: l,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: r.layout,
          paint: r.paint
        }, _) : this.map.addLayer({
          id: l,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "fill-color": "blue",
            "fill-opacity": 0.6
          }
        }, _)), b.includes("oint") && (r !== void 0 ? this.map.addLayer({
          id: l,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: r.layout,
          paint: r.paint
        }, _) : this.map.addLayer({
          id: l,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "circle-color": "red",
            "circle-opacity": 0.85
          }
        }, _));
      }
    } catch (i) {
      console.error(`Error fetching data: ${i.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type and adds to the Menu as a checkbox item.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The geometry name (e.g., 'buildings').
   * @param {string} filterField - Import all features as unique or group based on a field ('all', 'field').
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchDataAndMenu(e, t, r, i) {
    try {
      let o;
      i !== null ? o = i.layerPosition : o = Vg;
      let c, l = document.getElementById("map");
      if (document.getElementById("menu-group") ? c = document.getElementById("menu-group") : (c = document.createElement("nav"), c.id = "menu-group", c.classList.add = "filter-group", l.appendChild(c)), c !== null) {
        let _ = "visible", b = this._dealOrderLayer(o), w;
        if (e.includes(".fgb")) {
          let I = this._getKeyByUrlFGB(e);
          I === null && (I = "userFGB");
          const P = await fetch(e), k = {
            type: "FeatureCollection",
            features: []
          };
          for await (const G of A2(P.body)) k.features.push(G);
          w = k;
          let U = t;
          if (this.map.addSource(U, {
            type: "geojson",
            data: k
          }), e.includes("text"))
            i !== void 0 ? this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: i.layout,
              paint: i.paint
            }, b) : this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: _,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, b);
          else {
            let G = t + "Text";
            this.map.addLayer({
              id: G,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: _,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, b);
          }
        } else
          w = await (await fetch(e)).json();
        if (r !== "all") {
          const I = document.createElement("div");
          I.id = "titleDivMenu", I.textContent = t, c.appendChild(I);
          const P = document.createElement("div");
          P.id = "titleDivMenuSub", P.textContent = `📂 ${r}`, c.appendChild(P);
        }
        let T;
        if (i.type ? T = i.type : T = w.features[0].geometry.type, r === "all")
          T.includes("ine") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: w
            },
            layout: i.layout,
            paint: i.paint
          }, b) : this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: w
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "line-color": "black",
              "line-width": 2,
              "line-opacity": 1
            }
          }, b)), T.includes("olygon") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: w
            },
            layout: i.layout,
            paint: i.paint
          }, b) : this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: w
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "fill-color": "#0000FF",
              "fill-opacity": 0
            }
          }, b)), T.includes("oint") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: w
            },
            layout: i.layout,
            paint: i.paint
          }, b) : this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: w
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "circle-color": "red",
              "circle-opacity": 0.85
            }
          }, b)), T.includes("ymbol") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: w
            },
            layout: i.layout,
            paint: i.paint
          }, b) : this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: w
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "text-halo-blur": 0.5,
              "text-color": "rgba(90, 7, 7, 1)",
              "text-halo-width": 2,
              "text-halo-color": "rgba(255, 255, 255,0.8)"
            }
          }, b)), this.addMenuItem(t);
        else {
          let I = r;
          const P = {};
          w.features.forEach((k) => {
            const U = k.properties[I], G = U + "-userFieldFilter-" + t;
            U !== null && (P[G] || (T.includes("ine") && (i !== void 0 ? this.map.addLayer({
              id: G,
              type: "line",
              source: {
                type: "geojson",
                data: w
              },
              layout: i.layout,
              paint: i.paint,
              filter: ["==", `${I}`, U]
            }, b) : this.map.addLayer({
              id: G,
              type: "line",
              source: {
                type: "geojson",
                data: w
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, U],
              paint: {
                "line-color": "black",
                "line-width": 2,
                "line-opacity": 1
              }
            }, b)), T.includes("olygon") && (i !== void 0 ? this.map.addLayer({
              id: G,
              type: "fill",
              source: {
                type: "geojson",
                data: w
              },
              filter: ["==", `${I}`, U],
              layout: i.layout,
              paint: i.paint
            }, b) : this.map.addLayer({
              id: G,
              type: "fill",
              source: {
                type: "geojson",
                data: w
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, U],
              paint: {
                "fill-color": "blue",
                "fill-opacity": 0.6
              }
            }, b)), T.includes("oint") && (i !== void 0 ? this.map.addLayer({
              id: G,
              type: "circle",
              source: {
                type: "geojson",
                data: w
              },
              filter: ["==", `${I}`, U],
              layout: i.layout,
              paint: i.paint
            }, b) : this.map.addLayer({
              id: G,
              type: "circle",
              source: {
                type: "geojson",
                data: w
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, U],
              paint: {
                "circle-color": "red",
                "circle-opacity": 0.85
              }
            }, b)), P[G] = !0, this.addMenuItem(G)));
          });
        }
      }
    } catch (o) {
      console.error(`Error fetching data: ${o.message}`);
    }
  }
  /**
   * Adds an event listener to the map.
   * @function on
   * @param {string} type - The type of the event.
   * @param {Function} func - The callback function to be executed when the event occurs.
   */
  on(e, t) {
    setTimeout(() => {
      try {
        return this.map.on(e, t);
      } catch (r) {
        console.error(`Error adding event ON listener: ${r.message}`);
      }
    }, 100);
  }
  /**
   * Sets the style of the map.
   * @function setStyle
   * @param {string} style - Name of the map style.
   * @param {Object} [options] - Options for setting the style.
   */
  setStyle(e, t) {
    try {
      t !== void 0 ? this.map.setStyle(e, t) : this.map.setStyle(e), this.map.on("styledata", () => {
        if (window.document.querySelector(".maplibregl-compact-show")) {
          var r = window.document.querySelector(".maplibregl-compact-show");
          r.classList.remove("maplibregl-compact-show");
        }
        this._dealOrto3dStyle(this.map.getStyle().name);
      });
    } catch (r) {
      console.error(`Error setting style: ${r.message}`);
    }
  }
  /**
   * Adds a control to the map with the specified position.
   * @function addControl
   * @param {Object} control - The control to add.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(e, t);
    } catch (r) {
      console.error(`Error adding control: ${r.message}`);
    }
  }
  /**
   * Sets the sky properties of the map.
   * @function setSky
   * @param {Object} options - Options to set the sky properties.
   * @param {string} [options.skyType='gradient'] - Type of sky to set (e.g., 'gradient', 'atmosphere').
   * @param {string} [options.color='lightblue'] - Color of the sky.
   * @param {Number} [options.horizonBlend=0.03] - Blend horizon value.
   * @param {Number} [options.starIntensity=0.5] - Intensity of stars in the sky.
   * @param {Number} [options.sunIntensity=0.1] - Intensity of the sun in the sky.
   * @param {Array<Number>} [options.sunPosition=[0, 0]] - Position of the sun in the sky.
   */
  setSky(e) {
    try {
      e === void 0 && (this.map.style.stylesheet.id.includes("orto") ? e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("mapa_estandard_general") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("icgc_mapa_vissir") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("fosc") ? e = {
        "sky-color": "#232423",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#969996",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#383838"
      } : e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      }), this.map.setSky(e);
    } catch (t) {
      console.error(`Error setting sky properties: ${t.message}`);
    }
  }
  /**
   * Adds a mouse coordinate control to the map.
   * @function addMouseCoordControl
   * @param {Number} options.width - Width control i.
   * @param {Boolean} options.utm - Boolean to show coordinates in UTM.
   * @param {Boolean} options.lonlat - Boolean to show coordinates in Lon Lat.
   * @param {string} [position='bottom-left'] - Position to add the control on the map.
   */
  addMouseCoordControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "bottom-left";
    try {
      this.map.addControl(new Vq(e), t);
    } catch (r) {
      console.error(`Error adding mouse coordinate control: ${r.message}`);
    }
  }
  /**
   * Adds a geolocate control to the map.
   * @function addGeolocateControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addGeolocateControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new gs.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: !0
        },
        trackUserLocation: !0
      }), t) : this.map.addControl(new gs.GeolocateControl(e), t);
    } catch (r) {
      console.error(`Error adding geolocate control: ${r.message}`);
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullscreenControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullscreenControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new gs.FullscreenControl({
        container: HTMLElement
      }), t) : this.map.addControl(new gs.FullscreenControl(e), t);
    } catch (r) {
      console.error(`Error adding fullscreen control: ${r.message}`);
    }
  }
  /**
   * Adds a layer to the map.
   * @function addLayer
   * @param {Object} layer - Options for the layer to add.
   * @param {string} layerIdOrder - Optional layer Id draw position.
   */
  addLayer(e, t) {
    try {
      this.map.addLayer(e, t);
    } catch (r) {
      console.error(`Error adding layer: ${r.message}`);
    }
  }
  //add maplibre methods
  /**
   * Adds an image to the map.
   * @function addImage
   * @param {string} id - The ID of the image.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The image object to add.
   * @param {Partial<StyleImageMetadata>} options - Optional metadata for the image.
   * @returns {this}
   */
  addImage(e, t, r) {
    try {
      this.map.addImage(e, t, r);
    } catch (i) {
      console.error(`Error adding image: ${i.message}`);
    }
    return this;
  }
  /**
   * Adds a source to the map.
   * @function addSource
   * @param {string} id - The ID of the source.
   * @param {SourceSpecification} source - The source object to add.
   * @returns {this}
   */
  addSource(e, t) {
    try {
      this.map.addSource(e, t);
    } catch (r) {
      console.error(`Error adding source: ${r.message}`);
    }
    return this;
  }
  /**
   * Adds a sprite to the map.
   * @function addSprite
   * @param {string} id - The ID of the sprite.
   * @param {string} url - The URL to load the sprite from.
   * @param {StyleSetterOptions} options - Options object.
   * @returns {this}
   */
  addSprite(e, t, r) {
    try {
      this.map.addSprite(e, t, r);
    } catch (i) {
      console.error(`Error adding sprite: ${i.message}`);
    }
    return this;
  }
  /**
   * Checks if all tiles in the viewport are loaded.
   * @function areTilesLoaded
   * @returns {boolean}
   */
  areTilesLoaded() {
    return this.map.areTilesLoaded();
  }
  /**
   * Calculates the camera position for given bounds.
   * @function cameraForBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {CameraForBoundsOptions} options - Options object.
   * @returns {CenterZoomBearing | undefined}
   */
  cameraForBounds(e, t) {
    return this.map.cameraForBounds(e, t);
  }
  /**
   * Eases the camera to a new position.
   * @function easeTo
   * @param {object} options - Options describing the animation.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  easeTo(e, t) {
    return this.map.easeTo(e, t), this;
  }
  /**
   * Fits the map to the given geographical bounds.
   * @function fitBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitBounds(e, t, r) {
    return this.map.fitBounds(e, t, r), this;
  }
  /**
   * Fits the map to the given screen coordinates.
   * @function fitScreenCoordinates
   * @param {PointLike} p0 - First point on screen, in pixel coordinates.
   * @param {PointLike} p1 - Second point on screen, in pixel coordinates.
   * @param {number} bearing - Desired map bearing at end of animation, in degrees.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitScreenCoordinates(e, t, r, i, o) {
    return this.map.fitScreenCoordinates(e, t, r, i, o), this;
  }
  /**
   * Flies the camera to a new position.
   * @function flyTo
   * @param {FlyToOptions} options - Options describing the flight.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  flyTo(e, t) {
    return this.map.flyTo(e, t), this;
  }
  /**
   * Gets the current bearing of the map.
   * @function getBearing
   * @returns {number}
   */
  getBearing() {
    return this.map.getBearing();
  }
  /**
   * Gets the current geographical bounds of the map.
   * @function getBounds
   * @returns {LngLatBounds}
   */
  getBounds() {
    return this.map.getBounds();
  }
  /**
   * Gets the elevation for the point where the camera is looking.
   * @function getCameraTargetElevation
   * @returns {number}
   */
  getCameraTargetElevation() {
    return this.map.getCameraTargetElevation();
  }
  /**
   * Gets the map's <canvas> element.
   * @function getCanvas
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.map.getCanvas();
  }
  /**
   * Gets the HTML element containing the map's <canvas> element.
   * @function getCanvasContainer
   * @returns {HTMLElement}
   */
  getCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  /**
   * Returns the map's geographical centerpoint.
   * @function getCenter
   * @returns {LngLat} The map's geographical centerpoint.
   */
  getCenter() {
    return this.map.getCenter();
  }
  /**
   * Returns the map's containing HTML element.
   * @function getContainer
   * @returns {HTMLElement} The map's container.
   */
  getContainer() {
    return this.map.getContainer();
  }
  /**
   * Gets the state of a feature.
   * @function getFeatureState
   * @param {FeatureIdentifier} feature - Feature identifier.
   * @returns {any} The state of the feature.
   */
  getFeatureState(e) {
    return this.map.getFeatureState(e);
  }
  /**
   * Returns the filter applied to the specified style layer.
   * @function getFilter
   * @param {string} layerId - The ID of the style layer.
   * @returns {void | FilterSpecification} The layer's filter.
   */
  getFilter(e) {
    return this.map.getFilter(e);
  }
  /**
   * Returns the value of the style's glyphs URL.
   * @function getGlyphs
   * @returns {string} The glyphs Style's glyphs URL.
   */
  getGlyphs() {
    return this.map.getGlyphs();
  }
  /**
   * Returns an image currently available in the map.
   * @function getImage
   * @param {string} id - The ID of the image.
   * @returns {StyleImage} An image in the map with the specified ID.
   */
  getImage(e) {
    return this.map.getImage(e);
  }
  /**
   * Returns the layer with the specified ID in the map's style.
   * @function getLayer
   * @param {string} id - The ID of the layer to get.
   * @returns {StyleLayer} The layer with the specified ID.
   */
  getLayer(e) {
    return this.map.getLayer(e);
  }
  /**
   * Return the ids of all layers currently in the style, including custom layers, in order.
   * @function getLayersOrder
   * @returns {string[]} Ids of layers, in order.
   */
  getLayersOrder() {
    return this.map.getLayersOrder();
  }
  /**
   * Returns the value of a layout property in the specified style layer.
   * @function getLayoutProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of the layout property.
   * @returns {any} The value of the specified layout property.
   */
  getLayoutProperty(e, t) {
    return this.map.getLayoutProperty(e, t);
  }
  /**
   * Returns the value of the light object.
   * @function getLight
   * @returns {LightSpecification} Light properties of the style.
   */
  getLight() {
    return this.map.getLight();
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to.
   * @function getMaxBounds
   * @returns {LngLatBounds} The map's maximum geographical bounds.
   */
  getMaxBounds() {
    return this.map.getMaxBounds();
  }
  /**
   * Returns the map's maximum allowable pitch.
   * @function getMaxPitch
   * @returns {number} The maxPitch.
   */
  getMaxPitch() {
    return this.map.getMaxPitch();
  }
  /**
   * Returns the map's maximum allowable zoom level.
   * @function getMaxZoom
   * @returns {number} The maxZoom.
   */
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  /**
   * Returns the map's minimum allowable pitch.
   * @function getMinPitch
   * @returns {number} The minPitch.
   */
  getMinPitch() {
    return this.map.getMinPitch();
  }
  /**
   * Returns the map's minimum allowable zoom level.
   * @function getMinZoom
   * @returns {number} The minZoom.
   */
  getMinZoom() {
    return this.map.getMinZoom();
  }
  /**
   * Returns the current padding applied around the map viewport.
   * @function getPadding
   * @returns {PaddingOptions} The current padding around the map viewport.
   */
  getPadding() {
    return this.map.getPadding();
  }
  /**
   * Returns the value of a paint property in the specified style layer.
   * @function getPaintProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of a paint property.
   * @returns {unknown} The value of the specified paint property.
   */
  getPaintProperty(e, t) {
    return this.map.getPaintProperty(e, t);
  }
  /**
   * Returns the map's current pitch (tilt).
   * @function getPitch
   * @returns {number} The map's current pitch, measured in degrees away from the plane of the screen.
   */
  getPitch() {
    return this.map.getPitch();
  }
  /**
   * Returns the map's pixel ratio.
   * @function getPixelRatio
   * @returns {number} The pixel ratio.
   */
  getPixelRatio() {
    return this.map.getPixelRatio();
  }
  /**
   * Returns the state of renderWorldCopies.
   * @function getRenderWorldCopies
   * @returns {boolean} The renderWorldCopies.
   */
  getRenderWorldCopies() {
    return this.map.getRenderWorldCopies();
  }
  /**
   * Returns the source with the specified ID in the map's style.
   * @function getSource
   * @param {string} id - The ID of the source to get.
   * @returns {Source} The style source with the specified ID.
   */
  getSource(e) {
    return this.map.getSource(e);
  }
  /**
   * Returns the as-is value of the style's sprite.
   * @function getSprite
   * @returns {object[]} Style's sprite list of id-url pairs.
   */
  getSprite() {
    return this.map.getSprite();
  }
  /**
   * Returns the map's MapLibre style object.
   * @function getStyle
   * @returns {StyleSpecification} The map's style JSON object.
   */
  getStyle() {
    return this.map.getStyle();
  }
  /**
   * Get the terrain-options if terrain is loaded.
   * @function getTerrain
   * @returns {TerrainSpecification} The TerrainSpecification passed to setTerrain.
   */
  getTerrain() {
    return this.map.getTerrain();
  }
  //  Function getZoom()
  /**
   * Returns the map's current zoom level.
   * @function getZoom
   * @returns {number} The map's current zoom level.
   */
  getZoom() {
    return this.map.getZoom();
  }
  //  Function hasControl()
  /**
   * Checks if a control exists on the map.
   * @function hasControl
   * @param {IControl} control - The IControl to check.
   * @returns {boolean} true if map contains control.
   */
  hasControl(e) {
    return this.map.hasControl(e);
  }
  //  Function hasImage()
  /**
   * Check whether or not an image with a specific ID exists in the style.
   * @function hasImage
   * @param {string} id - The ID of the image.
   * @returns {boolean} A Boolean indicating whether the image exists.
   */
  hasImage(e) {
    return this.map.hasImage(e);
  }
  //  Function isMoving()
  /**
   * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
   * @function isMoving
   * @returns {boolean} true if the map is moving.
   */
  isMoving() {
    return this.map.isMoving();
  }
  //  Function isRotating()
  /**
   * Returns true if the map is rotating due to a camera animation or user gesture.
   * @function isRotating
   * @returns {boolean} true if the map is rotating.
   */
  isRotating() {
    return this.map.isRotating();
  }
  //  Function isSourceLoaded()
  /**
   * Returns a Boolean indicating whether the source is loaded.
   * @function isSourceLoaded
   * @param {string} id - The ID of the source to be checked.
   * @returns {boolean} A Boolean indicating whether the source is loaded.
   */
  isSourceLoaded(e) {
    return this.map.isSourceLoaded(e);
  }
  //  Function isStyleLoaded()
  /**
   * Returns a Boolean indicating whether the map's style is fully loaded.
   * @function isStyleLoaded
   * @returns {boolean | void} A Boolean indicating whether the style is fully loaded.
   */
  isStyleLoaded() {
    return this.map.isStyleLoaded();
  }
  //  Function isZooming()
  /**
   * Returns true if the map is zooming due to a camera animation or user gesture.
   * @function isZooming
   * @returns {boolean} true if the map is zooming.
   */
  isZooming() {
    return this.map.isZooming();
  }
  //  Function jumpTo()
  /**
   * Changes any combination of center, zoom, bearing, and pitch, without an animated transition.
   * @function jumpTo
   * @param {JumpToOptions} options - Options object
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  jumpTo(e, t) {
    return this.map.jumpTo(e, t);
  }
  //  Function listImages()
  /**
   * Returns an Array of strings containing the IDs of all images currently available in the map.
   * @function listImages
   * @returns {string[]} An Array of strings containing the names of all sprites/images currently available in the map.
   */
  listImages() {
    return this.map.listImages();
  }
  //  Function listens()
  /**
   * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
   * @function listens
   * @param {string} type - The event type.
   * @returns {boolean} true if there is at least one registered listener for specified event type, false otherwise.
   */
  listens(e) {
    return this.map.listens(e);
  }
  //  Function loadImage()
  /**
   * Load an image from an external URL to be used with Map#addImage.
   * @function loadImage
   * @param {string} url - The URL of the image file. Image file must be in png, webp, or jpg format.
   * @returns {Promise<GetResourceResponse<ImageBitmap | HTMLImageElement>>} A promise that is resolved when the image is loaded.
   */
  loadImage(e) {
    return this.map.loadImage(e);
  }
  //  Function loaded()
  /**
   * Returns a Boolean indicating whether the map is fully loaded.
   * @function loaded
   * @returns {boolean} A Boolean indicating whether the map is fully loaded.
   */
  loaded() {
    return this.map.loaded();
  }
  //  Function new LngLatBounds()
  /**
   * Constructs a new LngLatBounds object representing a geographical bounding box.
   * @class LngLatBounds
   * @constructor
   * @param {LngLatLike} [sw] - The southwest corner of the bounding box. Can be specified as an array of 4 numbers in the order of west, south, east, north, or an array of 2 LngLatLike representing [sw,ne].
   * @param {LngLatLike} [ne] - The northeast corner of the bounding box.
   */
  LngLatBounds(e, t) {
    return new gs.LngLatBounds(e, t);
  }
  //  Function addProtocol()
  /**
   * Adds a custom load resource function that will be called when using a URL that starts with a custom URL schema.
   * @function addProtocol
   * @param {string} customProtocol - The protocol to hook, for example 'custom'.
   * @param {AddProtocolAction} loadFn - The function to use when trying to fetch a resource specified by the customProtocol.
   * @returns {void}
   */
  addProtocol(e, t) {
    return this.map.addProtocol(e, t);
  }
  //  Function moveLayer()
  /**
   * Moves a layer to a different z-position.
   * @function moveLayer
   * @param {string} id - The ID of the layer to move.
   * @param {string} [beforeId] - The ID of an existing layer to insert the new layer before.
   * @returns {this}
   */
  moveLayer(e, t) {
    return this.map.moveLayer(e, t);
  }
  //  Function panBy()
  /**
   * Pans the map by the specified offset.
   * @function panBy
   * @param {PointLike} offset - x and y coordinates by which to pan the map.
   * @param {AnimationOptions} [options] - Options object.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panBy(e, t, r) {
    return this.map.panBy(e, t, r);
  }
  //  Function panTo()
  /**
   * Pans the map to the specified location with an animated transition.
   * @function panTo
   * @param {LngLatLike} lnglat - The location to pan the map to.
   * @param {AnimationOptions} [options] - Options describing the destination and animation of the transition.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panTo(e, t, r) {
    return this.map.panTo(e, t, r);
  }
  //  Function project()
  /**
   * Returns a Point representing pixel coordinates, relative to the map's container, that correspond to the specified geographical location.
   * @function project
   * @param {LngLatLike} lnglat - The geographical location to project.
   * @returns {Point} The Point corresponding to lnglat, relative to the map's container.
   */
  project(e) {
    return this.map.project(e);
  }
  //  Function queryRenderedFeatures()
  /**
   * Queries rendered features within a specified geometry or bounding box.
   * @function queryRenderedFeatures
   * @param {GeometryLike | Array | Object} [geometryOrOptions] - The geometry or options for the query.
   * @param {Object} [options] - Options for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features that intersect the query geometry.
   */
  queryRenderedFeatures(e, t) {
    return this.map.queryRenderedFeatures(e, t);
  }
  //  Function querySourceFeatures()
  /**
   * Queries source features within a specified source.
   * @function querySourceFeatures
   * @param {string} sourceId - The ID of the source to query.
   * @param {Object} parameters - Parameters for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features in the source that satisfy the query parameters.
   */
  querySourceFeatures(e, t) {
    return this.map.querySourceFeatures(e, t);
  }
  //  Function queryTerrainElevation()
  /**
   * Queries the terrain elevation at a specified geographical location.
   * @function queryTerrainElevation
   * @param {LngLatLike} lngLatLike - The geographical location to query.
   * @returns {number} The elevation (in meters) at the specified location.
   */
  queryTerrainElevation(e) {
    return this.map.queryTerrainElevation(e);
  }
  //  Function redraw()
  /**
   * Redraws the map.
   * @function redraw
   * @returns {this}
   */
  redraw() {
    return this.map.redraw();
  }
  //  Function remove()
  /**
   * Removes the map from the DOM.
   * @function remove
   * @returns {this}
   */
  remove() {
    return this.map.remove();
  }
  //  Function removeControl()
  /**
   * Removes a control from the map.
   * @function removeControl
   * @param {Object} control - The control to remove.
   * @returns {this}
   */
  removeControl(e) {
    return this.map.removeControl(e);
  }
  //  Function removeFeatureState()
  /**
   * Removes the state of a feature.
   * @function removeFeatureState
   * @param {Object} target - The target feature.
   * @param {string} [key] - The key of the state to remove.
   * @returns {this}
   */
  removeFeatureState(e, t) {
    return this.map.removeFeatureState(e, t);
  }
  //  Function removeImage()
  /**
   * Removes an image from the style's sprite.
   * @function removeImage
   * @param {string} id - The ID of the image to remove.
   * @returns {this}
   */
  removeImage(e) {
    return this.map.removeImage(e);
  }
  /**
   * Removes a layer from the map.
   * @function removeLayer
   * @param {string} idLayer - Identifier of the layer to remove.
   */
  removeLayer(e) {
    try {
      this.map.removeLayer(e);
    } catch (t) {
      console.error(`Error removing layer: ${t.message}`);
    }
  }
  /**
   * Removes a source from the map.
   * @function removeSource
   * @param {string} idLayer - Identifier of the source to remove.
   */
  removeSource(e) {
    try {
      this.map.removeSource(e);
    } catch (t) {
      console.error(`Error removing source: ${t.message}`);
    }
  }
  //  Function removeSprite()
  /**
   * Removes a sprite from the style.
   * @function removeSprite
   * @param {string} id - The ID of the sprite to remove.
   * @returns {this}
   */
  removeSprite(e) {
    return this.map.removeSprite(e);
  }
  //  Function resetNorth()
  /**
   * Resets the map orientation so that north is up.
   * @function resetNorth
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorth(e, t) {
    return this.map.resetNorth(e, t);
  }
  //  Function resetNorthPitch()
  /**
   * Resets the map orientation so that north is up and pitch is set to 0°.
   * @function resetNorthPitch
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorthPitch(e, t) {
    return this.map.resetNorthPitch(e, t);
  }
  //  Function resize()
  /**
   * Resizes the map to fit its container.
   * @function resize
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resize(e) {
    return this.map.resize(e);
  }
  //  Function rotateTo()
  /**
   * Rotates the map to the specified bearing with an animated transition.
   * @function rotateTo
   * @param {number} bearing - The desired bearing (in degrees) to rotate the map to.
   * @param {Object} [options] - Options for the rotation.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  rotateTo(e, t, r) {
    return this.map.rotateTo(e, t, r);
  }
  //  Function setBearing()
  /**
   * Sets the map's bearing with an optional animated transition.
   * @function setBearing
   * @param {number} bearing - The desired bearing (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setBearing(e, t) {
    return this.map.setBearing(e, t);
  }
  //  Function setCenter()
  /**
   * Sets the map's center coordinates with an optional animated transition.
   * @function setCenter
   * @param {LngLatLike} center - The desired center coordinates to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setCenter(e, t) {
    return this.map.setCenter(e, t);
  }
  //  Function setEventedParent()
  /**
   * Sets the parent of the map's event emitter.
   * @function setEventedParent
   * @param {any} [parent] - The parent object to set for the event emitter.
   * @param {any} [data] - Additional data to pass to the parent.
   * @returns {this}
   */
  setEventedParent(e, t) {
    return this.map.setEventedParent(e, t);
  }
  //  Function setFeatureState()
  /**
   * Sets the state of a feature.
   * @function setFeatureState
   * @param {Object} feature - The feature to set the state for.
   * @param {Object} state - The state object to set for the feature.
   * @returns {this}
   */
  setFeatureState(e, t) {
    return this.map.setFeatureState(e, t);
  }
  //  Function setFilter()
  /**
   * Sets the filter for a specified layer.
   * @function setFilter
   * @param {string} layerId - The ID of the layer to set the filter for.
   * @param {Array} [filter] - The filter array to apply to the layer.
   * @param {Object} [options] - Options for the filter.
   * @returns {this}
   */
  setFilter(e, t, r) {
    return this.map.setFilter(e, t, r);
  }
  //  Function setGlyphs()
  /**
   * Sets the glyphs for the map's style.
   * @function setGlyphs
   * @param {string} glyphsUrl - The URL to the glyphs.
   * @param {Object} [options] - Options for setting the glyphs.
   * @returns {this}
   */
  setGlyphs(e, t) {
    return this.map.setGlyphs(e, t);
  }
  //  Function setLayerZoomRange()
  /**
   * Sets the zoom range for a specified layer.
   * @function setLayerZoomRange
   * @param {string} layerId - The ID of the layer to set the zoom range for.
   * @param {number} minzoom - The minimum zoom level for the layer.
   * @param {number} maxzoom - The maximum zoom level for the layer.
   * @returns {this}
   */
  setLayerZoomRange(e, t, r) {
    return this.map.setLayerZoomRange(e, t, r);
  }
  //  Function setLayoutProperty()
  /**
   * Sets a layout property for a specified layer.
   * @function setLayoutProperty
   * @param {string} layerId - The ID of the layer to set the layout property for.
   * @param {string} name - The name of the layout property to set.
   * @param {any} value - The value to set for the layout property.
   * @param {Object} [options] - Options for setting the layout property.
   * @returns {this}
   */
  setLayoutProperty(e, t, r, i) {
    return this.map.setLayoutProperty(e, t, r, i);
  }
  //  Function setLight()
  /**
   * Sets the light for the map's style.
   * @function setLight
   * @param {Object} light - The light object to set for the map.
   * @param {Object} [options] - Options for setting the light.
   * @returns {this}
   */
  setLight(e, t) {
    return this.map.setLight(e, t);
  }
  //  Function setMaxBounds()
  /**
   * Sets the maximum bounds for the map.
   * @function setMaxBounds
   * @param {Array} bounds - The maximum bounds for the map.
   * @returns {this}
   */
  setMaxBounds(e) {
    return this.map.setMaxBounds(e);
  }
  //  Function setMaxPitch()
  /**
   * Sets the maximum pitch for the map.
   * @function setMaxPitch
   * @param {number} maxPitch - The maximum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMaxPitch(e) {
    return this.map.setMaxPitch(e);
  }
  //  Function setMaxZoom()
  /**
   * Sets the maximum zoom level for the map.
   * @function setMaxZoom
   * @param {number} maxZoom - The maximum zoom level for the map.
   * @returns {this}
   */
  setMaxZoom(e) {
    return this.map.setMaxZoom(e);
  }
  //  Function setMinPitch()
  /**
   * Sets the minimum pitch for the map.
   * @function setMinPitch
   * @param {number} minPitch - The minimum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMinPitch(e) {
    return this.map.setMinPitch(e);
  }
  //  Function setMinZoom()
  /**
   * Sets the minimum zoom level for the map.
   * @function setMinZoom
   * @param {number} minZoom - The minimum zoom level for the map.
   * @returns {this}
   */
  setMinZoom(e) {
    return this.map.setMinZoom(e);
  }
  //  Function setPadding()
  /**
   * Sets padding for the map's container.
   * @function setPadding
   * @param {Object} padding - The padding object to set for the map's container.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPadding(e, t) {
    return this.map.setPadding(e, t);
  }
  //  Function setPaintProperty()
  /**
   * Sets a paint property for a specified layer.
   * @function setPaintProperty
   * @param {string} layerId - The ID of the layer to set the paint property for.
   * @param {string} name - The name of the paint property to set.
   * @param {any} value - The value to set for the paint property.
   * @param {Object} [options] - Options for setting the paint property.
   * @returns {this}
   */
  setPaintProperty(e, t, r, i) {
    return this.map.setPaintProperty(e, t, r, i);
  }
  //  Function setPitch()
  /**
   * Sets the map's pitch angle with an optional animated transition.
   * @function setPitch
   * @param {number} pitch - The desired pitch angle (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPitch(e, t) {
    return this.map.setPitch(e, t);
  }
  //  Function setPixelRatio()
  /**
   * Sets the pixel ratio for the map.
   * @function setPixelRatio
   * @param {number} pixelRatio - The desired pixel ratio for the map.
   * @returns {this}
   */
  setPixelRatio(e) {
    return this.map.setPixelRatio(e);
  }
  //  Function setRenderWorldCopies()
  /**
   * Sets whether the map should render world copies when the center longitude is greater than or less than ±180 degrees.
   * @function setRenderWorldCopies
   * @param {boolean} renderWorldCopies - A boolean indicating whether to render world copies.
   * @returns {this}
   */
  setRenderWorldCopies(e) {
    return this.map.setRenderWorldCopies(e);
  }
  //  Function setSprite()
  /**
   * Sets the sprite for the map's style.
   * @function setSprite
   * @param {string} spriteUrl - The URL to the sprite.
   * @param {Object} [options] - Options for setting the sprite.
   * @returns {this}
   */
  setSprite(e, t) {
    return this.map.setSprite(e, t);
  }
  //  Function setTerrain()
  /**
   * Loads a 3D terrain mesh based on a "raster-dem" source.
   * @function setTerrain
   * @param {TerrainSpecification} options - Options object specifying the terrain source.
   * @returns {this}
   */
  setTerrain(e) {
    return this.map.setTerrain(e);
  }
  //  Function setTransformRequest()
  /**
   * Updates the requestManager's transform request with a new function.
   * @function setTransformRequest
   * @param {RequestTransformFunction} transformRequest - The callback function to update the transform request.
   * @returns {this}
   */
  setTransformRequest(e) {
    return this.map.setTransformRequest(e);
  }
  //  Function setZoom()
  /**
   * Sets the map's zoom level.
   * @function setZoom
   * @param {number} zoom - The zoom level to set (0-20).
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setZoom(e, t) {
    return this.map.setZoom(e, t);
  }
  //  Function snapToNorth()
  /**
   * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it.
   * @function snapToNorth
   * @param {Object} [options] - Options for snapping to north.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  snapToNorth(e, t) {
    return this.map.snapToNorth(e, t);
  }
  //  Function stop()
  /**
   * Stops any animated transition underway.
   * @function stop
   * @returns {this}
   */
  stop() {
    return this.map.stop();
  }
  //  Function triggerRepaint()
  /**
   * Triggers the rendering of a single frame.
   * @function triggerRepaint
   * @returns {void}
   */
  triggerRepaint() {
    return this.map.triggerRepaint();
  }
  //  Function unproject()
  /**
   * Returns geographical coordinates corresponding to the specified pixel coordinates.
   * @function unproject
   * @param {PointLike} point - The pixel coordinates to unproject.
   * @returns {LngLat} The geographical coordinates corresponding to the specified pixel coordinates.
   */
  unproject(e) {
    return this.map.unproject(e);
  }
  //  Function updateImage()
  /**
   * Updates an existing image in the style's sprite.
   * @function updateImage
   * @param {string} id - The ID of the image to update.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The new image data.
   * @returns {this}
   */
  updateImage(e, t) {
    return this.map.updateImage(e, t);
  }
  //  Function zoomIn()
  /**
   * Increases the map's zoom level by 1.
   * @function zoomIn
   * @param {Object} [options] - Options for zooming in.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomIn(e, t) {
    return this.map.zoomIn(e, t);
  }
  //  Function zoomOut()
  /**
   * Decreases the map's zoom level by 1.
   * @function zoomOut
   * @param {Object} [options] - Options for zooming out.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomOut(e, t) {
    return this.map.zoomOut(e, t);
  }
  //  Function zoomTo()
  /**
   * Zooms the map to the specified zoom level with an animated transition.
   * @function zoomTo
   * @param {number} zoom - The zoom level to transition to.
   * @param {Object} [options] - Options for zooming to.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomTo(e, t, r) {
    return this.map.zoomTo(e, t, r);
  }
  // end maplibre methods
  /**
   * Adds a GeoJSON layer to the map.
   * @function addLayerGeoJSON
   * @param {Object} layer - Options for the GeoJSON layer to add.
   * @param {string} layer.id - Unique identifier for the layer.
   * @param {Object} layer.data - GeoJSON data for the layer.
   * @param {string} layer.type - Map layer type (e.g., 'symbol', 'circle', 'fill').   *
   * @param {Object} layer.layout - Layer layout configuration.
   * @param {Object} layer.paint - Layer paint configuration.
   * @param {string} layerPosition - Position of the layer: 'top', below 'labels' or below 'lines'.
   */
  addLayerGeoJSON(e, t) {
    try {
      let r = this._dealOrderLayer(t);
      this.map.addSource(`${e.id}`, {
        type: "geojson",
        data: e.data
      }), this.map.addLayer({
        id: `${e.id}-layerIcgcMap`,
        type: e.type,
        source: `${e.id}`,
        layout: e.layout,
        paint: e.paint
      }, r);
    } catch (r) {
      console.error(`Error adding GeoJSON layer: ${r.message}`);
    }
  }
  /**
   * Adds a WMS layer to the map.
   * @function addLayerWMS
   
   * @param {string[]} tiles - Tiles for the raster layer.
   * @param {string} idLayer - Unique identifier for the layer.
   * @param {Object} options - Options of the layer: layout, paint and layerPosition.
   */
  addLayerWMS(e, t, r) {
    try {
      let i = this._dealOrderLayer(r.layerPosition);
      r ? (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, i), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        layout: r.layout,
        paint: r.paint
      }, i)) : (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, i), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        paint: {}
      }, i));
    } catch (i) {
      console.error(`Error adding WMS layer: ${i.message}`);
    }
  }
  /**
   * Adds a logo to the map.
   * @function addLogo
   * @param {Object} options - Options for the logo to add.
   * @param {string} options.id - Unique identifier for the logo.
   * @param {string} options.url - URL of the logo image.
   * @param {string} options.href - URL to navigate to when the logo is clicked.
   * @param {string} options.height - Height of the logo.
   */
  addLogo(e) {
    try {
      let t = document.getElementById("map"), r;
      r = document.createElement("div"), r.id = "logos", t.appendChild(r);
      const i = document.createElement("img");
      i.src = e.url, i.style.height = e.height;
      const o = document.getElementById("logos"), c = document.createElement("a");
      c.id = e.id, c.href = e.href, c.target = "_blank", c.style.position = "relative", c.style.bottom = "1px", c.appendChild(i), o.appendChild(c);
    } catch (t) {
      console.error(`Error adding logo: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemapsICGC
   * @param {Object[]} basesArray - Array of base layer objects.
   */
  addBasemapsICGC(e) {
    try {
      const t = (c) => {
        this.map.setStyle(c);
      };
      let r = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "basemap-group", i.classList.add = "filter-group", r.appendChild(i);
      const o = document.getElementById("basemap-group");
      for (const c of e)
        for (const l of Object.keys(hr.baseStyles)) {
          const _ = hr.baseStyles[l];
          if (c === _.url) {
            const b = document.createElement("div");
            b.className = "basemap-item", b.title = _.key, b.style.backgroundImage = `url('${_.image}')`, o.appendChild(b), b.addEventListener("click", () => t(_.url));
          }
        }
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemaps
   * @param {Object[]} baseLayers - Array of base layer objects.
   * @param {string} baseLayers.label - Label for the base layer.
   * @param {string} baseLayers.image - URL of the image representing the base layer.
   * @param {string} baseLayers.url - URL of the base layer style.
   */
  addBasemaps(e) {
    try {
      const t = (c) => {
        map.setStyle(c.url);
      };
      let r = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "basemap-group", i.classList.add = "basemap-group", r.appendChild(i);
      const o = document.getElementById("basemap-group");
      e.forEach((c) => {
        const l = document.createElement("div");
        l.className = "basemap-item", l.title = c.label, l.style.backgroundImage = `url('${c.image}')`, o.appendChild(l), l.addEventListener("click", () => t(c));
      });
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds feature query function to a layer.
   * @function addFeatureQuery
   * @param {string} idLayer - name of the layer
   * @param {objetc} queryFields - optional indications for the popup
   * @param {objetc} popupStyle - optional indications for the popup style
   */
  addFeatureQuery(e, t, r) {
    try {
      let i;
      this.map.on("mouseenter", e, () => {
        this.map.getCanvas().style.cursor = "pointer";
      }), this.map.on("mouseleave", e, () => {
        this.map.getCanvas().style.cursor = "";
      }), this.map.on("click", (o) => {
        let c = this.map.queryRenderedFeatures(o.point);
        if (c && c[0].source.includes(e)) {
          let l = [o.lngLat.lng, o.lngLat.lat];
          if (t !== void 0 && t.length > 0 && t !== "all") {
            if (t !== null) {
              let _ = "";
              t.forEach((b) => {
                let w = c[0].properties[b];
                _ = _ + `<h4>${w}</h4>`;
              }), i = _, this.addPopup(l, i, r);
            }
          } else {
            let _ = "";
            for (const b in c[0].properties)
              _ += "<b>" + b + "</b>:" + c[0].properties[b] + "<br>";
            i = _, this.addPopup(l, i, r);
          }
        }
      });
    } catch (i) {
      console.error(`Error adding feature query: ${i.message}`);
    }
  }
  /**
   * Adds a scale control to the map.
   *  * @function addScaleControl
   * @param {Object} options - Options for configuring the scale control.
   * @param {string} position - The position on the map to place the scale control (e.g., 'top-left', 'bottom-right').
   */
  addScaleControl(e, t) {
    try {
      var r = new gs.ScaleControl(e);
      this.map.addControl(r, t);
    } catch (i) {
      console.error(`Error adding scale: ${i.message}`);
    }
  }
  /**
   * Adds an export control to the map with the provided options and position.
   * @function addExportControl
   * @param {Object|string} options - Options for the export control or position if provided as a string.
   * @param {string} [position] - Position to place the export control (e.g., 'top-right').
   */
  addExportControl(e, t) {
    try {
      typeof e == "string" && (t = e, e = void 0), e === void 0 && (e = {
        PageSize: Ph.A4,
        PageOrientation: ip.Landscape,
        Format: Yc.PNG,
        DPI: $y[300],
        Crosshair: !0,
        PrintableArea: !0,
        Local: "ca"
      }, t = "top-right"), this.map.addControl(new qV(e), t);
    } catch (r) {
      console.error(`Error adding export control: ${r.message}`);
    }
  }
  /**
   * Adds a marker to the map.
   * @function addMarker
   * @param {Object} options - Options for the marker to add.
   * @param {string} options.text - Text content for the marker popup.
   * @param {Object} options.options - Marker options.
   * @param {LngLatLike} options.coord - Coordinates for placing the marker.
   * @param {Object} options.textOffset - Text offset for the marker popup.
   * @returns {Object} - Instance of the added marker.
   */
  addMarker(e) {
    try {
      let t, r;
      return e.text === void 0 ? t = new gs.Marker(e.options).setLngLat(e.coord).addTo(this.map) : (r = new gs.Popup({
        offset: e.textOffset
      }).setHTML(e.text), t = new gs.Marker(e.options).setLngLat(e.coord).setPopup(r).addTo(this.map)), t;
    } catch (t) {
      return console.error(`Error adding marker: ${t.message}`), null;
    }
  }
  /**
   * Adds a popup to the map.
   * @function addPopup
   * @param {Object} options - Options for the popup to add.
   * @param {LngLatLike} coord - Coordinates for placing the popup.
   * @param {string} text - HTML content for the popup.
   * @param {string} popupStyle - css content for the popup style.
   * @returns {Object} - Instance of the added popup.
   */
  addPopup(e, t, r) {
    try {
      return r.image === void 0 ? new gs.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${r.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
 ${t}
          </div>
          <div class="popupBottomDown">
          </div>
          </div>
        </div>
      `).addTo(this.map) : new gs.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${r.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
          ${t}
          </div>
          <div class="popupBottomDown">
             <img style="  padding: 8px;  width: 50%;" src=${r.image} />
          </div>
          </div>
        </div>
      `).addTo(this.map);
    } catch (i) {
      return console.error(`Error adding popup: ${i.message}`), null;
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullScreen
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullScreen(e) {
    try {
      e === void 0 && (e = "top-right"), this.map.addControl(new gs.FullscreenControl(), e);
    } catch (t) {
      console.error(`Error adding fullscreen control: ${t.message}`);
    }
  }
  /**
   * Adds a menu item with a checkbox for controlling the visibility of a layer on the map.
   * @function addMenuItem
   * @param {string} name - The name of the layer corresponding to the menu item.
   */
  addMenuItem(e) {
    try {
      let t;
      if (e.includes("-userFieldFilter-") ? t = e.split("-userFieldFilter-")[0] : t = e, e.length > 0) {
        const r = document.getElementById("menu-group"), i = document.createElement("input");
        i.type = "checkbox", i.id = e, i.checked = !0, r.appendChild(i);
        const o = document.createElement("label");
        o.setAttribute("for", e), o.textContent = t, r.appendChild(o), i.addEventListener("change", (c) => {
          this.map.setLayoutProperty(e, "visibility", c.target.checked ? "visible" : "none");
        });
      }
    } catch (t) {
      console.error(`Error adding menu item: ${t.message}`);
    }
  }
  /**
   * Adds a layer tree to the map.
   * @function addLayerTree
   * @param {Object} options - Options for the layer tree to add.
   * @param {Object} options.features - Features for the layer tree.
   * @param {string} options.id - Unique identifier for the layer tree.
   * @param {string} options.type - Type of layer tree ('geojson', 'raster', etc.).
   */
  addLayerTree(e) {
    try {
      let t = e.features, r = document.getElementById("map"), i = document.createElement("nav");
      i.id = "filter-group", r.appendChild(i);
      const o = document.getElementById("filter-group");
      this.map.addSource(`${e.id}`, {
        type: e.type,
        data: t
      }), t.features.forEach((c) => {
        const l = c.properties.icon, _ = `poi-${l}`;
        if (!this.map.getLayer(_)) {
          this.map.addLayer({
            id: _,
            type: "circle",
            source: `${e.id}`,
            paint: {
              "circle-radius": 6,
              "circle-color": "#B42222"
            },
            filter: ["==", "icon", l]
          }, this._firstSymbolLayer());
          const b = document.createElement("input");
          b.type = "checkbox", b.id = _, b.checked = !0, o.appendChild(b);
          const w = document.createElement("label");
          w.setAttribute("for", _), w.textContent = l, o.appendChild(w), b.addEventListener("change", (T) => {
            this.map.setLayoutProperty(_, "visibility", T.target.checked ? "visible" : "none");
          });
        }
      });
    } catch (t) {
      console.error(`Error adding layer tree: ${t.message}`);
    }
  }
  /**
   * Creates a navigation control with the provided options.
   * @function createNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   * @returns {Object} - Instance of the created navigation control.
   */
  createNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new gs.NavigationControl(e), t);
    } catch (r) {
      return console.error(`Error creating navigation control: ${r.message}`), null;
    }
  }
  /**
   * Adds a navigation control to the map with the provided options.
   * @function addNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new gs.NavigationControl(e), t);
    } catch (r) {
      console.error(`Error adding navigation control: ${r.message}`);
    }
  }
  /**
   * Adds an attribution control to the map with the provided options.
   * @function addAttributionControl
   * @param {Object} options - Options for the attribution control.
   * @param {string} [position='bottom-right'] - Position to add the control on the map.
   */
  addAttributionControl(e, t) {
    try {
      this.map.addControl(new gs.AttributionControl(e), t);
    } catch (r) {
      console.error(`Error adding attribution control: ${r.message}`);
    }
  }
  /**
   * Adds an ICGC image layer to the map based on the specified name and year.
   * @function addImageLayerICGC
   * @param {string} url - The url of the  layer.
   * @param {string} idLayer - The user id for the  layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   */
  addImageLayerICGC(e, t, r) {
    try {
      let i = null, o, c;
      r ? (c = r, o = r.layerPosition) : c = {
        type: "raster",
        layout: {
          visibility: "visible"
        },
        paint: {
          "raster-opacity": 1
        },
        layerPosition: Vg
      }, i = this._findImageType(e, Si.Orto, Si.VectorAdmin, Si.WMS, Si.Vector), i || console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
      let l = {
        id: t,
        tiles: e
      };
      this.addLayerWMS(e, t, c);
    } catch (i) {
      console.error(`Error adding ICGC image layer: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC vector layer to the map based on the specified name and year.
   * @function addVectorLayerICGC
   * @param {string} url - The url of the vector layer.
   * @param {string} idLayer - The user id for the vector layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   *
   */
  async addVectorLayerICGC(e, t, r) {
    try {
      let {
        type: i = "line",
        layerPosition: o = Vg,
        layoutOptions: c = {
          visibility: "visible"
        },
        paintOption: l
      } = r || {}, _ = this._dealOrderLayer(o);
      if (!e) {
        console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
        return;
      }
      if (e.includes("https")) {
        let b = this._getKeyByUrlVector(e);
        this.map.addSource(b, {
          type: "vector",
          url: e
        });
        let w = {
          id: b,
          type: "fill",
          source: b,
          "source-layer": "cobertes",
          maxzoom: 18,
          layout: r.layout,
          paint: AW.cobertesSol
        };
        if (b === "cobertes2018" && this.map.addLayer(w, _), c.visibility === "visible") {
          let T = this._getLegendByName(b);
          this.addLegend(T, b);
        }
      } else {
        let b = t;
        this.map.addSource(b, {
          type: "vector",
          url: hr.limitsUrl
        });
        let w = {
          id: t,
          type: i,
          source: b,
          "source-layer": e,
          layout: r.layout,
          paint: r.paint || {}
        };
        i === "fill" || i === "polygon" ? w.paint = l || {
          "fill-color": "#0000FF",
          "fill-opacity": 0
        } : i === "line" && (w.paint = l || {
          "line-color": "#4832a8",
          "line-opacity": 1,
          "line-width": 1
        }), this.map.addLayer(w, _);
      }
    } catch (i) {
      console.error(`Error adding ICGC vector layer: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC FGB layer to the map based on the specified name and year.
   * @function addFGBLayerICGC
   * @param {string} url - The url of the FGB layer.
   * @param {string} idLayer - Id for the layer.
   * @param {object} options - Paint option for the layer
   *
   */
  async addFGBLayerICGC(e, t, r) {
    try {
      r || (r.layout = {
        visibility: !0
      }, r.paint = {
        "line-color": "#4832a8",
        "line-opacity": 1,
        "line-width": 1
      }, r.type = "lines", r.layerPosition = "labels");
      let i = this._dealOrderLayer(r.layerPosition);
      const o = await fetch(e), c = {
        type: "FeatureCollection",
        features: []
      };
      for await (const _ of A2(o.body)) c.features.push(_);
      let l = t;
      this.map.addSource(l, {
        type: "geojson",
        data: c
      }), e.includes("text") ? this.map.addLayer({
        id: t,
        type: "symbol",
        source: l,
        layout: {
          "text-letter-spacing": 0.1,
          "text-size": {
            base: 1.2,
            stops: [[8, 0], [12, 14], [15, 15]]
          },
          "text-font": ["FiraSans-Regular"],
          "text-field": ["get", "NOM_AC"],
          "text-transform": "none",
          "text-max-width": 25,
          visibility: r.layout.visibility,
          "text-justify": "right",
          "text-anchor": "top",
          "text-allow-overlap": !1,
          "symbol-spacing": 2,
          "text-line-height": 1
        },
        paint: {
          "text-halo-blur": 0.5,
          "text-color": "rgba(90, 7, 7, 1)",
          "text-halo-width": 2,
          "text-halo-color": "rgba(255, 255, 255,0.8)"
        }
      }, i) : this.map.addLayer({
        id: t,
        type: r.type,
        source: l,
        layout: r.layout,
        paint: r.paint
      }, i);
    } catch (i) {
      console.error(`Error adding ICGC FGB layer: ${i.message}`);
    }
  }
  /**
   * Adds 3D terrain to the map using hillshade.
   * @function addTerrainICGC
   * @param {string} url - dataset url of the terrain
   * @param {string} controlPosition - Position to add the control on the map.
   */
  addTerrainICGC(e, t) {
    try {
      let r;
      for (const o in ep)
        if (ep.hasOwnProperty(o)) {
          const c = ep[o];
          c === e && (r = c);
        }
      let i = r;
      this.getSource("terrainICGC") !== void 0 && (this.getStyle().layers.forEach((c) => {
        c.source === "terrainICGC" && this.removeLayer(c.id);
      }), this.removeSource("terrainICGC")), this.getSource("terrainICGC") === void 0 && (e.includes("terrarium") ? this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [i],
        tileSize: 512,
        encoding: "terrarium",
        maxzoom: 16
      }) : this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [i],
        tileSize: 512,
        maxzoom: 16
      })), this.map.setTerrain({
        source: "terrainICGC",
        exaggeration: 1.5
      }), t == null || this.map.addControl(new NI({
        pitch: 90,
        bearing: null,
        minpitchzoom: null
      }), t);
    } catch (r) {
      console.error(`Error adding 3D terrain: ${r.message}`);
    }
  }
  /**
   * Add image legend.
   * @function addLegend
   * @param {string} url - image legend url.
   * @param {string} idLayer - layer's name.
   */
  addLegend(e, t) {
    try {
      this.map.addControl(new Uq({
        url: e,
        idLayer: t
      }));
    } catch (r) {
      console.error(`Error adding legend: ${r.message}`);
    }
  }
  //Internal methods
  /**
   * Finds the type of image based on the provided URL and specified vectors.
   * @function _findImageType
   * @param {string} url - The URL of the image to find the type for.
   * @param {Object} var1 - The first vector object containing key-value pairs.
   * @param {Object} var2 - The second vector object containing key-value pairs.
   * @param {Object} var3 - The third vector object containing key-value pairs.
   * @param {Object} var4 - The fourth vector object containing key-value pairs.
   * @returns {string|null} - The type of image if found, otherwise null.
   */
  _findImageType(e, t, r, i, o) {
    const c = [t, r, i, o];
    for (const l of c)
      for (const [_, b] of Object.entries(l))
        if (b === e)
          return _;
    return null;
  }
  /**
   * Gets the key by URL from the FGBAdmin layers.
   * @function _getKeyByUrlFGB
   * @param {string} url - The URL to find the key for in the FGBAdmin layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlFGB(e) {
    for (const t in Si.FGBAdmin)
      if (Si.FGBAdmin.hasOwnProperty(t) && Si.FGBAdmin[t] === e)
        return t;
    return null;
  }
  /**
   * Gets the legend by name from the default vector layers.
   * @function _getLegendByName
   * @param {string} name - The name of the vector layer to get the legend for.
   * @returns {string|null} - The legend if found, otherwise null.
   */
  _getLegendByName(e) {
    for (const t in hr.vectorLayers) {
      const r = hr.vectorLayers[t];
      if (r.key === e)
        return r.legend;
    }
    return null;
  }
  /**
   * Gets the key by URL from the Vector layers.
   * @function _getKeyByUrlVector
   * @param {string} url - The URL to find the key for in the Vector layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlVector(e) {
    for (const t in Si.Vector)
      if (Si.Vector.hasOwnProperty(t) && Si.Vector[t] === e)
        return t;
    return null;
  }
  /**
   * Raises text 3D style on the map.
   * @function _raiseText3DStyle
   * @async
   * @returns {Promise<void>} - A promise that resolves after updating the text 3D style on the map.
   */
  async _raiseText3DStyle() {
    try {
      const e = await this.map.loadImage(hr.map3dOptions.imageIcon);
      this.map.addImage("stick", e.data), this.map.getStyle().layers.forEach((t) => {
        if (t["source-layer"] === hr.map3dOptions.sourceLayerFilterId && t.minzoom >= hr.map3dOptions.minZoomFilter && e) {
          const r = t.id;
          this.map.setLayoutProperty(r, "icon-image", "stick"), this.map.setLayoutProperty(r, "text-offset", [0, -9]), this.map.setLayoutProperty(r, "symbol-placement", "point"), this.map.setLayoutProperty(r, "symbol-avoid-edges", !1), this.map.setLayoutProperty(r, "text-allow-overlap", !0), this.map.setLayoutProperty(r, "text-ignore-placement", !1), this.map.setLayoutProperty(r, "text-pitch-alignment", "auto"), this.map.setLayoutProperty(r, "text-rotation-alignment", "auto"), this.map.setLayoutProperty(r, "text-justify", "center"), this.map.setLayoutProperty(r, "text-anchor", "bottom"), this.map.setLayoutProperty(r, "icon-anchor", "bottom"), this.map.setPaintProperty(r, "text-color", "#ffffff"), this.map.setPaintProperty(r, "text-halo-color", "#000000"), this.map.setPaintProperty(r, "text-halo-width", 2);
        }
      });
    } catch (e) {
      return console.error(`Error dealing orto 3D: ${e.message}`), null;
    }
  }
  /**
   * Deals with map styles based on the name.
   * @function _dealStyleMaps
   * @param {string} name - The name of the map style.
   * @returns {Object|string|null} - The map style object if found, or the input name if not found, or null if an error occurs.
   */
  _dealStyleMaps(e) {
    try {
      if (e && e.indexOf("icgc.cat") != -1) {
        for (const t in xh)
          if (xh.hasOwnProperty(t)) {
            const r = xh[t];
            if (t === e)
              return r;
          }
        return xh[0];
      } else
        return e;
    } catch (t) {
      return console.error(`Error dealing with map styles: ${t.message}`), null;
    }
  }
  /**
   * Deals with the 3D ortho style based on the name.
   * @function _dealOrto3dStyle
   * @param {string} name - The name of the orto3D style.
   * @returns {void|null} - Returns null if an error occurs.
   */
  _dealOrto3dStyle(e) {
    try {
      if (e == "orto3d") {
        this.map.setMaxZoom(18.8), this.map.easeTo({
          pitch: 45
        });
        const t = new HS({
          intensity: 4
        }), r = new tb({
          ambientLight: t
        });
        this.map.setTerrain({
          source: hr.map3dOptions.terrainSource,
          exaggeration: hr.map3dOptions.exaggeration
        });
        const i = this._createCitiesMapboxLayer();
        this.map.getLayer(hr.map3dOptions.layerId3d) || (this.map.addLayer(i, hr.map3dOptions.layerIdOrder), this.map.setLayerZoomRange(hr.map3dOptions.layerId3d, hr.map3dOptions.minZoomRange, hr.map3dOptions.maxZoomRange), i.deck.setProps({
          effects: [r]
        }), this._raiseText3DStyle()), this.map.setSky({
          "sky-color": "#86bbd5",
          "sky-horizon-blend": 0.3,
          "horizon-color": "#ffffff33",
          "horizon-fog-blend": 0.1,
          "fog-ground-blend": 0.75,
          "fog-color": "#c5d6d6"
        });
      } else
        this.map.getLayer(hr.map3dOptions.layerId3d) && (this.map.removeLayer(hr.map3dOptions.layerId3d), this.map.setTerrain(null));
    } catch (t) {
      return console.error(`Error dealing orto 3D: ${t.message}`), null;
    }
  }
  /**
   * Deals with the order of the layer.
   * @function _dealOrderLayer
   * @param {string} order - The order of the layer.
   * @returns {string} - The id of the first symbol layer if the order is 'symbol', the id of the first line layer if the order is 'line', otherwise an empty string.
   */
  _dealOrderLayer(e) {
    return e === Vg ? this._firstSymbolLayer() : e === SW ? this._firstLineLayer() : "";
  }
  /**
   * Retrieves the id of the first symbol layer.
   * @function _firstSymbolLayer
   * @returns {string|undefined} - The id of the first symbol layer if found, otherwise undefined.
   */
  _firstSymbolLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let r = 0; r < e.length; r++)
        if (e[r].type === "symbol" && e[r].id.indexOf("contour") === -1 && e[r].id.indexOf("water") === -1) {
          t = e[r].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Retrieves the id of the first line layer.
   * @function _firstLineLayer
   * @returns {string|undefined} - The id of the first line layer if found, otherwise undefined.
   */
  _firstLineLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let r = 0; r < e.length; r++)
        if (e[r].type === "line") {
          t = e[r].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Creates a Mapbox layer for displaying cities in 3D.
   * @function _createCitiesMapboxLayer
   * @returns {MapboxLayer|null} - The Mapbox layer for displaying cities in 3D if created successfully, otherwise null.
   */
  _createCitiesMapboxLayer() {
    try {
      return new m8({
        id: hr.map3dOptions.layerId3d,
        type: Mb,
        data: hr.map3dOptions.urlTilesetCities,
        loader: Lb,
        loadOptions: {
          tileset: {
            viewDistanceScale: 1,
            updateTransforms: !0,
            maximumScreenSpaceError: hr.map3dOptions.spaceErrorFactor
          }
        },
        onTilesetLoad: (t) => {
          t.options.maximumScreenSpaceError = hr.map3dOptions.spaceErrorFactor;
        },
        onTileLoad: (t) => {
          t.content.cartographicOrigin.z -= hr.map3dOptions.zfactor;
        },
        operation: "terrain+draw"
      });
    } catch (e) {
      return console.error(`Error adding MapboxLayer: ${e.message}`), null;
    }
  }
};
var A3 = { exports: {} };
function EW(n, e) {
  var t = n.getCenter(), r = n.getZoom(), i = n.getBearing(), o = n.getPitch();
  e.forEach(function(c) {
    c.jumpTo({
      center: t,
      zoom: r,
      bearing: i,
      pitch: o
    });
  });
}
function TW() {
  var n, e = arguments.length;
  if (e === 1)
    n = arguments[0];
  else {
    n = [];
    for (var t = 0; t < e; t++)
      n.push(arguments[t]);
  }
  var r = [];
  n.forEach(function(l, _) {
    r[_] = c.bind(null, l, n.filter(function(b, w) {
      return w !== _;
    }));
  });
  function i() {
    n.forEach(function(l, _) {
      l.on("move", r[_]);
    });
  }
  function o() {
    n.forEach(function(l, _) {
      l.off("move", r[_]);
    });
  }
  function c(l, _) {
    o(), EW(l, _), i();
  }
  return i(), function() {
    o(), r = [], n = [];
  };
}
var CW = TW;
(function(n) {
  var e = CW, t = ZT.EventEmitter;
  function r(i, o, c, l) {
    if (this.options = l || {}, this._mapA = i, this._mapB = o, this._horizontal = this.options.orientation === "horizontal", this._onDown = this._onDown.bind(this), this._onMove = this._onMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._ev = new t(), this._swiper = document.createElement("div"), this._swiper.className = this._horizontal ? "compare-swiper-horizontal" : "compare-swiper-vertical", this._controlContainer = document.createElement("div"), this._controlContainer.className = this._horizontal ? "maplibregl-compare maplibregl-compare-horizontal" : "maplibregl-compare", this._controlContainer.className = this._controlContainer.className, this._controlContainer.appendChild(this._swiper), typeof c == "string" && document.body.querySelectorAll) {
      var _ = document.body.querySelectorAll(c)[0];
      if (!_)
        throw new Error("Cannot find element with specified container selector.");
      _.appendChild(this._controlContainer);
    } else if (c instanceof Element && c.appendChild)
      c.appendChild(this._controlContainer);
    else
      throw new Error("Invalid container specified. Must be CSS selector or HTML element.");
    this._bounds = o.getContainer().getBoundingClientRect();
    var b = (this._horizontal ? this._bounds.height : this._bounds.width) / 2;
    this._setPosition(b), this._clearSync = e(i, o), this._onResize = (function() {
      this._bounds = o.getContainer().getBoundingClientRect(), this.currentPosition && this._setPosition(this.currentPosition);
    }).bind(this), o.on("resize", this._onResize), this.options && this.options.mousemove && (i.getContainer().addEventListener("mousemove", this._onMove), o.getContainer().addEventListener("mousemove", this._onMove)), this._swiper.addEventListener("mousedown", this._onDown), this._swiper.addEventListener("touchstart", this._onDown);
  }
  r.prototype = {
    _setPointerEvents: function(i) {
      this._controlContainer.style.pointerEvents = i, this._swiper.style.pointerEvents = i;
    },
    _onDown: function(i) {
      i.touches ? (document.addEventListener("touchmove", this._onMove), document.addEventListener("touchend", this._onTouchEnd)) : (document.addEventListener("mousemove", this._onMove), document.addEventListener("mouseup", this._onMouseUp));
    },
    _setPosition: function(i) {
      i = Math.min(i, this._horizontal ? this._bounds.height : this._bounds.width);
      var o = this._horizontal ? "translate(0, " + i + "px)" : "translate(" + i + "px, 0)";
      this._controlContainer.style.transform = o, this._controlContainer.style.WebkitTransform = o;
      var c = this._horizontal ? "rect(0, 999em, " + i + "px, 0)" : "rect(0, " + i + "px, " + this._bounds.height + "px, 0)", l = this._horizontal ? "rect(" + i + "px, 999em, " + this._bounds.height + "px,0)" : "rect(0, 999em, " + this._bounds.height + "px," + i + "px)";
      this._mapA.getContainer().style.clip = c, this._mapB.getContainer().style.clip = l, this.currentPosition = i;
    },
    _onMove: function(i) {
      this.options && this.options.mousemove && this._setPointerEvents(i.touches ? "auto" : "none"), this._horizontal ? this._setPosition(this._getY(i)) : this._setPosition(this._getX(i));
    },
    _onMouseUp: function() {
      document.removeEventListener("mousemove", this._onMove), document.removeEventListener("mouseup", this._onMouseUp), this.fire("slideend", {
        currentPosition: this.currentPosition
      });
    },
    _onTouchEnd: function() {
      document.removeEventListener("touchmove", this._onMove), document.removeEventListener("touchend", this._onTouchEnd), this.fire("slideend", {
        currentPosition: this.currentPosition
      });
    },
    _getX: function(i) {
      i = i.touches ? i.touches[0] : i;
      var o = i.clientX - this._bounds.left;
      return o < 0 && (o = 0), o > this._bounds.width && (o = this._bounds.width), o;
    },
    _getY: function(i) {
      i = i.touches ? i.touches[0] : i;
      var o = i.clientY - this._bounds.top;
      return o < 0 && (o = 0), o > this._bounds.height && (o = this._bounds.height), o;
    },
    /**
     * Set the position of the slider.
     *
     * @param {number} x Slider position in pixels from left/top.
     */
    setSlider: function(i) {
      this._setPosition(i);
    },
    /**
     * Adds a listener for events of a specified type.
     *
     * @param {string} type The event type to listen for; one of `slideend`.
     * @param {Function} listener The function to be called when the event is fired.
     * @returns {Compare} `this`
     */
    on: function(i, o) {
      return this._ev.on(i, o), this;
    },
    /**
     * Fire an event of a specified type.
     *
     * @param {string} type The event type to fire; one of `slideend`.
     * @param {Object} data Data passed to the event listener.
     * @returns {Compare} `this`
     */
    fire: function(i, o) {
      return this._ev.emit(i, o), this;
    },
    /**
     * Removes an event listener previously added with `Compare#on`.
     *
     * @param {string} type The event type previously used to install the listener.
     * @param {Function} listener The function previously installed as a listener.
     * @returns {Compare} `this`
     */
    off: function(i, o) {
      return this._ev.removeListener(i, o), this;
    },
    remove: function() {
      this._clearSync(), this._mapB.off("resize", this._onResize);
      var i = this._mapA.getContainer();
      i && (i.style.clip = null, i.removeEventListener("mousemove", this._onMove));
      var o = this._mapB.getContainer();
      o && (o.style.clip = null, o.removeEventListener("mousemove", this._onMove)), this._swiper.removeEventListener("mousedown", this._onDown), this._swiper.removeEventListener("touchstart", this._onDown), this._controlContainer.remove();
    }
  }, window.maplibregl ? maplibregl.Compare = r : n.exports = r;
})(A3);
var IW = A3.exports;
const PW = /* @__PURE__ */ Ip(IW);
class FW {
  /**
   * Constructor for the map comparison class.
   * @class MapComparison
   * @param {Object} map1 - The first map object to compare.
   * @param {Object} map2 - The second map object to compare.
   * @param {string} container - The HTML container element ID for displaying the comparison.
   * @param {Object} options - Additional options for map comparison (if needed).
   */
  constructor(e, t, r, i) {
    const o = this;
    setTimeout(function() {
      o.mapCompare = new PW(e.map, t.map, r, {});
    }, 1e3);
  }
}
export {
  FW as C,
  OW as M,
  xW as a,
  zr as p
};
